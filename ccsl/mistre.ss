Æ’CCSL Mark 4.4 Update 4.4.39 28-August-2017 (10:48)
C
C
C
C
C
C               C A M B R I D G E   C R Y S T A L L O G R A P H Y
C
C                      S U B R O U T I N E   L I B R A R Y
C
C
C
C
C
C
C
C
C
UPDT
                           M I S T R E S S   F I L E
Updates
C4.40  Nov 4 2017 minor corrections to GETDC and LSQCYC
C4.39 28-August-2017 STPLOT replaced in LIB. PIGLET replaced in PIG. ATMPIG
      replaced in LIB. Additions to PLOTGP to colour positive and negative contours.
C4.38 5-August-2017Changes made to allow Map plotting and contouring with GNUPLOT
      ATMPLT,GFDEFS,GPLFIL,GPPREF,HCNAME,INPUTM,LENGT,SETFOU,STPLOT,
      SYMEQU,USYM modified in LIB. GNUSYM,MAPBX,MAPGP,PLOTGP,PRIMBX,STGPLT added to
      LIB. FOUGPL inserted in MAI.
      New common blocks MAPMAP and GPLMAP added
      Bad duplicate version of LGFSYM removed from LIB
C4.35 6-March 2017 Misuse of KSTAR corrected by removing KSTAR entry to PROPER
      and including the vectors AKSTAR in the star  of PROP in common SATELL.
C4.34 19-February-2017 GFDEFS,KANGA3,LGFSYM replaced in LIB.
C4.33 17-February-2017 GFDEFS,HCNAME,LGFCOL replaced in LIB. GF2GPL,GPCHAR,
      GPLFIL,GPPREF,GRAFDV replaced in PIG. LGFSYM replaced in LIB.
C4.32 27-January-2017 GFDEFS inserted in LIB.
C4.31 12-December-2016 Better version of ATMPLT which corrects errors in plotting
      atomic positions in non-trivial sections uses new subroutine MAPBOX and
      function NHCF.
      SYMEQU and USYM modified to store transformed symmetry operators rather than
       replacing existing, FOURPL updated accordingly. A new PICLET PIGNUP inserted
      in PIG which uses GNUPLOT for graphical output.
C4.30 1-September-2016 DOMAG1,FMCALC,STATPA replaced in LIB. AVERPA inserted in
      MAI. INDOM,INPSYM,POLAXE,PSYMOP,SYMDOM inserted in LIB. SORPOL inserted in
      MAI. These to implement better averaging of SNP data allowing for S-domains.
      COMMON STATP modified and COMMON MAGSF added.
C4.29 10-June 2013 3 versions of ICDINC attached to main programs removed and
      replaced with a general version  in LIB. Some missing header and
      classifiaction lines added
C4.28 5-June-2013 Correction to LSQCYC for acentric structure factor format
C4.27 5-April-2013 CALCQX,CALPOW,CAMPHS,CPVCON,DATASF,LSQCYC,REFHDR,REPREF,
      RREFSF modified in LIB. MAGLSQ modified in MAI.
C4.26 22-March-2013 APSHSF,CALCMG,DFLTMG,DOMAG1,DOMAG2,FUDGIN,INCELL,INITIL,
      INPUTQ,LMAGPR,LOGMAG,LSETSF,LSQCYC,MAGABS,MAGCNC,MAGCNL,MAGSYM,MATSHF,
      OPMSYM,PARSSF,PROPER,RDFV,REPREF,RFACS,ROTOSM,VARMAK,VARSSF updated
      in LIB.
      CALCQX,CAMPHS,CPVCON,CPVESD,CPVMUS,CPVSYM,CVPARS,DOINC1,DOINC2,ESDFOR,
      LPVCAL,MTPROD,RMCSCA new in LIB. SFTLSQ updated in MAI.
C4.25 26 Jan 2012 correction to ICDFMT in calculation of ITEMS
C4.24 16 Sept 2011 RANGE replaced by RANGER in external statements. Correction to format 2200 in
	  CALMPL
C4.23 27 May/June 2011 Mod to program genref to generate -h-k-l correctly when non-centric.
      correct printing of rho. SORASY correct esd when R-1=0. Correction to INPLSF for default
      weight. Mods to  CALMMG and LSQCYC for magnetic twinning. MGTDOM (in SNPLSQ)
      rewritten to write new crystal data correctly. INPUTD modified to prefer UB matrix
      from data to that from D cards.
C4.22 28-March-2011 Mods to correct symmetry constraints on susceptiility tensors
      for non-=orthogonal crystal axes: new modules CHICON and RELSMO inserted
      in LIB. Changes to CHITRN,DOCHI1,DOCHI2 and TCHALC.
      Allow SXD and Vivaldi type data with wavelength and path given for each reflection.
      New program ABSSXD makes the .SF file from Arrnged data. Read in LSQ with MODE 12.
      Consequent mods to LSQCYC,REPMOD,RREFSF,DATASF and INPLSF in lib
      and MAGLSQ,SFLSQ,SNPLSQ MAI.
      The unique module RREFSF now reads all SF type data in CCSL free format
      RREFLS,RREFSA have been deleted.
      A new common block DSRCNM holds the data filnames and identifiers.
      Corrections to ARRHED and HDROUT.
      Make constrained angles in MAGCON as near to chosen values as possible
C4.21 Sifted out all gfortran warnings, several were serious.
C4.20 24-September-2010 ARREAD updated DTYP 11 for D3 fli files from instrument,
      ARPRIN corrected for ARRINC, HDROUT updated to treat absence of header info.
      ICDFMT corrected for SCD data format.
C4.19 22-March-2010 LSQ programs CHILSQ,MAGLSQ,MPCLSQ,MPLSQ,MMPLSQ,SFLSQ,SNPLSQ,
      restructured to use a common cycling module LSQCYC.
      CALCFR,CALCMG,CALPOW,DATASF,INPUTD modified to use ALAMB2 for lambda/2
      correction.
      Programs ABSMSF,SORASY,SORGAM modified to use common module REFOUT to write the
      header on the data file
C4.18 Corrections to CALCFR include COMPLEX CRSCLP, CALCMG remove calculation of
      SINTH and COSTH, DGEOM not needed. Default DSRC increased to 6.
      Correction to derivative of SCAT in LFCALC. ITER in GAMEX increased to 500
C4.17 22-October-2009 Modify CHILSQ to do powder data
      CALCFR,CALCMG,CHITRN,DATASF,REFHDR,REPMOD,REPREF,RREFSA
      replaced in LIB. CHILSQ MPCLSQ replaced in MAI. CALPOW,MULPCY,PRJECT,TCHALC,
      TRAN2K inserted in LIB. Common blocks BRAGG CHITRN, MAGCHI, MCAL, QCAL,
      QCALD modified.
C4.16 19-Aug-2009 Correction to INPLSF to count DPOPS read correctlu
C4.15 5-August-2009 GENREF added depolarisarion for search,GRAFIC added date to
      plot, header format corrected in SORASY.
C4.14 16-April 2009 SETGAU replaced by SETABS in all LSQ prorams to ensure G
      cards are interpreted properly
C4.13 4-November-2008 Minor corrections to make gfortran compilation run without
      warnings and to give the same results with testdata as g77.
      STATPA and AVERPA updates for headings. Corrections to OPMSYM and NUMDEN
C4.12 31-October-2008 Changes to enable reading and writing of header info
      throughout the data chain raw_dat->arranged->averaged. Subroutines
      ARPRIN,ARREAD,INPUAR,INPUTD,SETDC modified also the programs ABSMSF,
      AVEXAR,INCMSF,SORASY,SORGAM which read dataI. The new subroutine ARRHED
      reads the headers of arranged data (.arr files).
C4.11 Mods to allow structure factor refiments with CHILSQ and MPCLSQ.
      Logical PARA added to common MAGSYM, magnetic field added to possible
      SRCPARS, common DSOURC expanded to accomodate it. The CHI's are now true
      susceptibilities in muB/T.
      Consequent changes to DATASF,DOCHI1,LOGMAG,MUCALC,RREFSA in LIB, CHILSQ
      and MPCLSQ in MAI. New routines CHITRN,REFHDR,REPMOD added to LIB. LCHALC
      detached from CHILSQ and inserted in LIB.
C4.10 26-Sept-2008 RLINE2 in block data VARFMT F10 changed to F10.2 to conform
      with gfortran.
C4.9 19-May-2008 Minor corrections to DOTWN1,INPLSF,MUCALC,SETDC in lib and
     ARISNP and AVERPA in mai.
     Logical TMUNIT added to common TWIN to indicate cell not changed.
C4.8 4-April-2008 Main MAXENT modified to use SMAX, includes only reflections
     with sintheta/lambda < SMAX.
C4.7 31-March-2008 RREFSA modified to call SETDC when needed, main LSQ  programs
     modified to remove SETDC and SETPOL calls. RREFSA must be called before
     VARMAK.
     IGOR format in PLREAD corrected.
C4.6 28-March-2008 further mods to SNPLSQ APSHSF,DOPOPS,INPLSF,INPUTQ,LDSCAL,
     LLDPOP,NDPOPS, NWINSF,PARRD to set up naming of data sources and domains
     so that their names can be used as family 3 names. New routine PRIDOM
     indicates which name belongs to which domain. Diagnostic output in PSICON
     made optional.
C4.5 18-March-2008 CALCPA,CALMMG,DOTWN1,INPLSF,LMCALC,PARNAM,STLSSF all
     updated for new multisource conventions ie L DATA and L SORC cards
     all these used by updated main program SNPLSQ. New routines DOPOPS, LDSCAL,
     LLDPOP,NDPOPS,REPREF,RREFLS  deal with reading and updating scale factors.
     Sign of phase offset changed in in LMCALC to match FMCALC.
C4.5 16-November-2007 ABSMSF, CALMSF and MG3DGL corrected in MAI.
C4.4  Unused labels detected by gfortran removed. Unused dummy arguments in
      dummy modules set equal to themselves to avoid compiler complaints
Changes : from version 4.3 to version 4.4
C4.3 10-October-2007 Add arranging of SNP data ARRINC,ARRNGE now have PARAMETER
     KEYS to give the number of sort keys. AINOUT,ARPRIN,ICDFMT modified to
     accomdate. New main programs ARRSNP and ARISNP do the arranging for
     commensurate and incommensurate indices repectively, new subroutine PLREAD
     reads the SNP data. New main program AVEPA to average the polarisation
     matrix elements, using chosen symmetry. subroutine STATPA does this
     average. DOMAG1 and INPUTQ modified so they only give a warning for words
     they don't recognise.
     SNP data can now be included in multisource refinements, main program
     SNPLSQ/SFDATA/ increased to include ICODES. New subroutines CALCPA,CALMMG,
     LMTCAL do the calculations, small mods needed and done in INPLSF and
     RREFSA.
C4.2 September-2007 SFTLSQ CHILSQ and MPCLSQ updated to multi-source.
     TYPO (1 for i) corrected in CALCFR, correction to USYM.
     ARREAD modified for type 10 input D3 peaak heights
     SETDC and DOTWN1 modified to deal with UB matrices for twinned crystals.
     ICDFMT corrected to count deffraction angles for different geometries.
     small corrections to NB01A and RANGE.
     RREFSA modified to skip data with zero esd.
     MPLSQ corrected, common DERABS needed.
C4.1 New program SORASY added to MAI, calculates polarised neutron assymetries.
     INPUTD modified to allow input of Busing levy form of UB matrix (D UMBL)
     INPLSF modified to allow IREF=7 polarised neutron asymmetries,
     BLOCK DATA F2PARS corrected for generic magnetic parameters
     Logical PATHS added to COMMON EXTN ti indicate that data for path length
     calculation have been given.
     EXTINC corrected and new entries EXTPAR and EXTALL added, paths
     now calculated internally.
     Note that the correction to EXTINC makes MOSC come out 100 times larger!
     Its dimensions are reciprocal radians.
     RREFSF modified so that it calculates weights when reading esd's
     from the data. It will also accept certain character strings introduced by
     # giving information about the data such as wavelength, UB-matrix
     polarisation etc. This is for compatibility with the new routine RREFSA.
     RREFSA is a new subroutine which stores the data in the new
     COMMON block SFDATA rather than re-reading it on each least squares cycle.
     There is a companion routine DATASF which implements reading of the data
     for all structure factor least squares programs. It is designed to
     deal with multi-source refinements and uses the new COMMON block
     DSOURCE to store information about the sources. The structure factor
     least squares programs MAGLSQ,MMPLSQ,MPLSQ and SFLSQ have
     been modified so as to use the stored data and accept multiple data
     sources.
     Mods to LMCALC,LMMPCA,FMCALC and FMMPCA to deal correctly with FERA
     Corrected bad use of 1 rather than NOPC+1 for centre in SUBSYM.
     Correction to PSICON for case where centre gives new sublattice,
     and correction to setting of FCENT in MAGCON.
     MODE in common POLDA changed to MODEP to avoid name conflicts.
C
C Updates made in version 4.30 can be found in updates/updates_4.3.txt

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!                                                                !
!                          DISCLAIMER                            !
!  This software is distributed in the hope that it will be      !
!  useful but \emph{without any warranty}. The author(s) do not  !
!  accept responsibility  to anyone for the consequences of      !
!  using it or for whether it serves  any particular purpose or  !
!  works at all. No warranty is made about  the software or its  !
!  performance.                                                  !
!                                                                !
!                          COPYING                               !
!  Use and copying of this software and the preparation of       !
!  derivative works based on it are permitted, so long as the    !
!  following conditions are met:                                 !
!                                                                !
!    1. The copyright notice and this entire notice are          !
!       included intact and prominently carried on all           !
!       copies and supporting documentation.                     !
!   2.  No fees or compensation are charged for use,             !
!       copies, or access to this software. You may charge       !
!       a nominal distribution fee for the physical act of       !
!       transferring a copy, but you may not charge for the      !
!       programs themselves.                                     !
!    3. If you modify this software, you must cause the          !
!       modified file(s) to carry notices describing the         !
!       changes, who made  the changes, and the date of          !
!       those changes.                                           !
!                                                                !
!                         AUTHORS                                !
!  The CCSL library was written by J.C. Matthewman and           !
!  P.J. Brown with contributions from W.I.F. David, J.B.         !
!  Forsyth and J.H. Matthewman.                                  !
!  Copyright c  1999--2000. All rights reserved.                 !
!                                                                !             !
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+                                                                 +
+ For documentation purposes (Appendix A of the Manual) each      +
+                routine is being given:                          +
+                                                                 +
+ an indicator "CX" if it is to be included in any version of the +
+                Appendix,  The CX is missing for really special- +
+                ised routines.                                   +
+                                                                 +
+ a category "CC" followed by a number and A,B, or C which        +
+                correspond to the categories in the MK3 Manual.  +
+                                                                 +
+                           CATEGORIES:                           +
+                                                                 +
+            1     'BASIC CRYSTALLOGRAPHY',                       +
+            2     'DATA COLLECTION AND REDUCTION',               +
+            3     'MANIPULATION OF REFLECTION INDICES',          +
+            4     'STRUCTURE FACTOR CALCULATIONS',               +
+            5     'FOURIER CALCULATIONS AND MAP PLOTTING',       +
+            6     'LEAST SQUARES REFINEMENT - GENERAL',          +
+            7     'LEAST SQUARES REFINEMENT - SPECIFIC',         +
+            8     'CRYSTAL GEOMETRY',                            +
+            9     'MATHEMATICAL FUNCTIONS',                      +
+            10    'TRIGONOMETRY',                                +
+            11    'TESTS',                                       +
+            12    'MATRICES AND VECTORS',                        +
+            13    'CCSL INPUT/OUTPUT ROUTINES',                  +
+            14    'GRAPHICAL OUTPUT',                            +
+            15    'LOGICAL OPERATIONS',                          +
+            16    'MISCELLANEOUS',                               +
+            17    'MAGNETIC STRUCTURE FACTORS',                  +
+            18    'MULTIPOLES',                                  +
+            19    'PROFILE REFINEMENT',                          +
+            20    'UNCLASSIFIED' (indistinguishable from         +
+                                  'miscellaneous', and not       +
+                                    fact used)                   +
+                                                                 +
+ line(s) starting "CH " with HEADING line(s) of summary          +
+                description                                      +
+                                                                 +
+ a selection of other lines from the following vocabulary:       +
+                                                                 +
+ starting "CA " listing the ARGUMENTS of the call                +
+                (saying also whether each argument is expected to+
+                have been set before entry, and/or whether it    +
+                will be set on exit from the routine)            +
+                                                                 +
+ starting "CP " giving PREREQUISITE calls (which includes where  +
+                appropriate what should be PRESET in COMMON)     +
+                                                                 +
+ starting "CD " for DESCRIPTION, saying what the routine DOES,   +
+                (where this information is not covered elsewhere)+
+                 including what is set into COMMON.              +
+                                                                 +
+ starting "CI " describing any INPUT from external sources       +
+                                                                 +
+ starting "CO " describing any OUTPUT to external sources (except+
+                simple error messages which occur so often they  +
+                are not worth mentioning)                        +
+                                                                 +
+ starting "CN " giving NOTES not covered elsewhere               +
+                                                                 +
+ for Main programs there are in addition lines                                  +
+                                                                 +
+ starting "CR" indicating how to run the program                                                                 +
+                                                                 +
+ ORFEUS, which makes Appendix A, will pick out such lines in the +
+         above sequence, and copy out what follows the "Cx "     +
+                                                                 +
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


 This first section is a list of the symbolic parameters and their
 default values.  Please consult the accompanying perl script "extract"
PARS
      ALLC 200    total number of permanent constraints held
      AL+1 201
      ATFS 20     number of anisotropic temperature factors
      ATOM 50     number of atomic positions
      BACK 100    items in background interpolation table
      BSAV 100    number of saved bonds
      BVAR 200    number of basic variables (size of LSQ matrix)
      BV+1 201
      CBIT 108    number of "bits" for contouring (see manual)
      CONC 500    constraint coefficients in permanent list
      CONT 50     contour levels on maps
      CPAR 500    parameters in constraints
      CPLN 15     number of plane faces of crystal
      CSTC 200    coefficients in constraint equations
      CSTR 20     number of constraints on LSQ
      CS+1 21
      CWRD 4      number of "words" for contouring (see manual)
      DCRD 10      possible words on D cards
      DOMS 24     number of allowed S-domains
      D*18 24     Doms*18 number of slots for polarisation matrix elements
      DP*2 48     Doms*2 number of dpops for S + 180 degree domains
      DPOP 24     number of domain populations which can be treated in LSQ
      DSRC 6      number of different data files read (sources)
      EXCL 40     number of excluded regions
      FAMS 6      number of families of parameters
      FA+1 7
      FFT1 64     first FFT parameter
      FFT2 256    second FFT parameter
      FILE 15     number of file names
      FNAM 100    maximum length of an expanded file name
      FORM 20     number of distinct form factors
      FTAB 40     number of entries in form factor table
      FUDG 20     number of fudge factors
      FVPK 30     packed incomplete fix/vary requests
      FXVA 200    fix/vary requests
      F2PR 44     names of words used in family 2 parameter specifications
      F2VA 200    family 2 variables
      GCRD 4      possible words on G cards
      GDEV 10     maximum GNUPLOT terminals defined
      GETM 20     previously saved maps to retrieve
      GFCL 15     number of defined graphic colours
      GFSM 11     number of graphic symbols defined
      GFTP 2      number of symbol types (open filled for now)
      GFLS 5      number of line styles
      GPTS 1000   total Gauss points (3 directions, multiplied together)
      ICRD 20     total possible words on I cards
      INVB 10     maximum number of bonds in algebraic expression of constraint
      LABA 50     number of atom labels on a map
      LAMB 5      wavelengths
      LCRD 22     possible words on L cards
      LNPP 110    number of lines per line-printer page
      MARK 4      mark number of CCSL
      MATS 3000   dimension of LSQ matrix
      MBLK 100    possible blocks of l in multipoles
      MCRD 19     possible words on M cards
      MESS 100    length of MESSAG in SCRACH
      MGAT 10     number of magnetic atoms
      MLAB 12     Number of different atoms to be labelled in a map
      MPAR 17     number of magnetic parameter names in F2PARS
      MPAT 20     number of multipole atoms
      MP+1 21
      MPFO 10     number of multipole form factors
      MPFL 6      number of multipole form factor L values
      MPOL 200    number of multipoles
      NGKS 100    number of points in GKS buffer
      NLSQ 5000   number of data for structure factor least squares
      NOBS 4000   number of observations for ARRNGE sort
      NO*5 20000
      NSFS 3000   number of structure factors for GETSFZ sort
      OLAP 70     overlapping reflections (size of cyclic store)
      OMAX 200    overlap (max no. contributing at one point)
      OMIT 100    number of reflections to omit in Profile Refinement
      PCOL 15    number of colours defined
      PSYM  9    number of symbols defined
      PTYP  2    number of fill types defined
      PHAS 1      number of phases in PR multiphase refinement
      PKGN 8      number of peak descriptors (genera)
      PK+2 10
      PKSP 6      number of coefficients for each peak descriptor (species)
      PLAN 20     nunber of atoms constrained to plane
      PLOT 20     number of plotted maps
      PRIN 20     number of printed maps
      PRPR 14     names of words used in profile parameter specifications
      PSIS 4      number of psi values in helical and 'AMOD' magnetics
      PSLK 300    slack constraints of Pawley type in PR
      PTIC 33000  number of points allowed in TIC and PICTIC
      PVAR 1000   parameters in LSQ
      PWRD 10     words in special Profile PKFN card list
      RADF 5      radial functions
      READ 20     number of binary maps to read
      REFS 1000   reflections in Profile Refinement
      SANG 100    angles in geometric slack constraints
      SAVE 20     number of saved maps
      SCAL 20     scale factors
      SKTP 4      types of slack constraint expected
      SLAK 20     slack constraints (of bond length type)
      SORC 1      number of sources of data in one job
      SYMO 24     symmetry operators
      SY*2 48
      SY+1 25
      TANG 100    torsion angles in geometric slack constraints
      TFAC 10     overall temperature factors
      TWIN 12     number of twin matrices
      UPDT 0      Update level to be filled in from header line
      VERS 40     version number of CCSL Mark
      VVAR 250    variables in LSQ
      WGHT 4      constants in weighting scheme
      WORD 60     words to define LSQ problem
STOP      Signals the end of the parameter list

  Now follow the COMMON blocks ready to take the substitutions
  for their symbolic parameters, and then to be themselves
  substituted in the code.

  Note also the artificial PROGRAM COMMON, which may be extracted from
  files which are collections of MK3 MAIN programs (eg MAILIB.FOR on
  VAXs).  This is kept in step with the list below so that the writer of
  MAIN programs may have access to a definitive set of COMMON blocks.

COMM
 1
      COMMON /ABSDAT/AMU,MODEA
-2
        AMU is coefficient of absorption
        MODEA requests one or more of selection of 3 integrals
 1
      COMMON /ADASH/DASH,X1,Y1,REM,IPEN,IDSH,DTRAN(2,2)
-6
        DASH is the length of a plotted dash within a dashed line, in cms
        X1 and Y1 remember dash position internally
        REM holds remainder of a dash not yet plotted
        IPEN remembers if pen up or down
        IDSH holds space from previous entry to DPLOT
        DTRAN holds transformation matrix for space in DPLOT
 2
      COMMON /ANISO/ATF(6,%ATFS%),KATF(6,%ATFS%),IAPT(%ATOM%),
     & IATYP(%ATFS%),KOM1
-4
        ATF holds standard beta anisotropic temperature factor coefficients
        KATF indicates which ATF are to be varied
        IAPT(N) shows which members of ATF apply to the Nth atom
        IATYP(J) gives type of Jth ATF as input
 2
      COMMON /ANSCAT/NAMODE(%FORM%),FDASH(%FORM%),KOM2
      COMPLEX FDASH
-2
        NAMODE(I) gives type of Ith anomalous scattering factor
        FDASH holds the real and imaginary parts of factor for type 1
 4
      COMMON /ARRDAT/IFOR(6),INC,LINO,NREF,INLBUF,NBUF,IBUF,INFBUF,
     & INDLEN,NUMVAL,IPOS,ISTORE,ICHNGE,NEW,LPRINT,ICD,IS,NREF1,
     & NREFL,NUMOR
      LOGICAL INC,NEW,LPRINT
-1
        IFOR holds the array of user's options for ARRNGE and related programs
 2
      COMMON /ARSORT/NREFS,KEYS,ITEMS,LRPACK(10,3),
     & MS,KP,JPOINT,ICOUNT,KOLD(6)
-4
        Holds sorting information for ARRNGE type programs
        NREFS is the number of reflections
        KEYS the sort keys
        ITEMS the number of data items attached to each reflection
 2
      COMMON /ATBLOC/NAME,IPNAME(12)
      CHARACTER *4 NAME,IPNAME
 -3
        Holds character specification for a block of shifts
        NAME is the atom to which the block refers
        IPNAME is the list of parameters to which shifts are applied
 2
      COMMON /ATBLOK/IBUFF,PNEW(12),PESD(12),PSHIFT(12),POLD(12),
     & PSESD(12)
-4
        Holds numerical specification for a block of shifts
        IBUFF is the number of shifts to be printed
        PNEW,PESD,PSHIFT,POLD,PSESD hold the newvalue, ESD, shift,
        old value and shift/ESD ratio for each parameter.
 2
      COMMON /ATNAM/ATNAME(%ATOM%),ATNA(%ATOM%,%PHAS%)
      CHARACTER *4 ATNA,ATNAME
-1
        ATNAME(N) holds the name of atom N as read from an A card
 2
      COMMON /ATNMPK/ATPACK(10,3)
      INTEGER ATPACK
-1
        ATPACK contains packed atom specifications name, operator, and cell
 3
      COMMON /BANERR/IPFIX(3,3),APFIX(3,3),RELMT(3,3,3),IATS(3),IOP(2),
     &BNDESD,ANGESD
      LOGICAL BNDESD,ANGESD
-6
      IPFIX and APFIX contain fix and relation info for up to 3 atoms
      involved in bond length or angle calculations.
      RELMT(3,3,3) are the associated matrices projecting the parameters
      on the variables.
      IATS and IOP indicate the atoms and operators to which these matrices
      belong
 1
      COMMON /BITMAP/IBIT(%CBIT%,%CWRD%),NWORDS
-2
        IBIT is the bit map indicating where contours are
        NWORDS is the number of machine words necessary to hold a row of IBIT
 4
      COMMON /BONDLA/NB,BSAVE(%BSAV%),DXSAVE(3,%BSAV%),NBSAVE(%BSAV%),
     & N2SAVE(%BSAV%),N3SAVE(%BSAV%),I1LAST,BMAX,BMIN,BBMAX,SDMAX,
     & ANG1,ANG2,BON2,SD1,SD2,BONOUT,LSK,SLK,LBOND
      LOGICAL SLK,BONOUT
-7
        NB is the number of saved bonds
        BSAVE are the saved bonds
        DXSAVE are the saved corresponding coordinate differences
        N2SAVE are the saved specifications of the destination atoms
        I1LAST is the number of the last saved source
        BMAX is the maximum bond to consider, read from an I card
        BMIN is the minimum bond to consider, read from an I card
 3
      COMMON /BRAGG/STHMXX(%SORC%),STHL,SINTH,COSTH,SSQRD,TWSNTH(%SORC%),
     & DSTAR2,TWOTHD(%SORC%),DIFANG(6)
      EQUIVALENCE(STHLMX,STHMXX(1)),(TWSNTH(1),ANGFAC)
-9
        STHLMX holds maximum sin theta/lambda
        STHL holds sin theta/lambda
        SINTH holds sin theta
        COSTH holds cos theta
        SSQRD holds sin squared theta/lambda squared
        TWSNTH holds 2 sin theta
        DSTAR2 holds d star squared
        TWOTHD holds 2 theta degrees
        DIFANG holds gamma, omega, chi, phi, nu & another
 6
      COMMON /CARDRC/ICRYDA,NTOTAL(%PHAS%),NYZ,NTOTL,INREA(26,%PHAS%),
     & ICDN(26,%PHAS%),IERR,IO10,SDREAD
      LOGICAL SDREAD
      DIMENSION INREAD(26),ICDNO(26)
      EQUIVALENCE (INREAD(1),INREA(1,1))
      EQUIVALENCE (ICDNO(1),ICDN(1,1))
-6
        IO10 is the unit number of the scratch file for Crystal Data
        IREC is the current record number in this file
        ICRYDA is the unit number of the input Crystal Data file
        NYZ is the number of Y or Z cards read in the course of reading some
             other set of cards
        NTOTL is the total number of records on the crystal data file.
 2
      COMMON /CELFIX/IPTCEL(6),AMCELL(6),NCELF,NCELG,NCELS,
     &RCLMAT(6,6),KOM3
-4
        IPTCEL and AMCELL are used to hold the simple relations between the
             cell parameters, temporarily until they can be incorporated
        RCLMAT holds the matrix projecting the quadratic products on the basic
        quadratic product variables
 3
      COMMON /CELPAR/CELL(3,3,2),V(2),ORTH(3,3,2),CPARS(6,2),KCPARS(6),
     & CELESD(6,6,2),CELLSD(6,6),SDCELL,LSQCEL,PRODSD,KOM4
      LOGICAL SDCELL,PRODSD,LSQCEL
-9
        CELL holds the real and reciprocal cell sides, cosines and sines
        V holds the real and reciprocaL cell volumes
        ORTH holds the matrices which transform crystallographic coordinates
             to the CCSL orthogonal coordinates, in either space
        CPARS hold the real and reciprocal cell quadratic products
        CELESD  holds the real and reciprocal elements of inverse LSQ matrix
        SDCELL is true if Cell ESD's have been read
        LSQCEL is true if they were filled in after a least squares refinement
        PRODSD is true if they were obtained from ESD's in the quad prods
 2
      COMMON /CHARS/LETUP(26),LETLOW(26),ISPCE,IDIGIT(10),ISMBOL(21)
      CHARACTER *1 LETUP,LETLOW,ISPCE,IDIGIT,ISMBOL
-8
        /CHARS/ is an attempt to deal with slightly differing character sets
             on different computers.  All its elements are initialised by
             data statements.  LETUP ans LETLOW hold the upper and lower
             case letters, ISPCE space, IDIGIT digits 0-9, and ISMBOL the
             commonly used symbols, including those which KANGA2 expects to
             be asked to plot.
        If the system is transferred between computers, some of the symbols
             (as listed explicitly in INITIL) may become garbled.
 1
      COMMON /CONSTA/PI,RAD,DEG,TWOPI,FOURPI,PIBY2,ALOG2,SQL2X8,VALMUB
-1
      Contains frequently used constants
 2
      COMMON /CONSTR/JCONST,JROWPT(%CS+1%),JCMAT(%CSTC%),AMOUNT(%CSTC%),
     & NEXTJ
-1
      Holds Constraint information for least squares programs
 2
      COMMON /CONTUR/ZPLVAL(%PLOT%),ZCPL,IPL,IZPL,CONT(%CONT%),
     & NCONT,AXMAP(2),COSPHI,SINPHI
-2
      Holds information needed to draw contours
      CONT contains the NCONT contour levels to be drawn
 1
      COMMON /CPLANE/AA(%CPLN%),BB(%CPLN%),CC(%CPLN%),DD(%CPLN%),NP
-3
      Holds coefficients of equations describing the NP crystal faces
      on CCSL orthogonal axes
      aa(n)*x + bb(n)*y + cc(n)*z = dd(n)
 6
      COMMON /CRPDC/ISNAME,IUNAME,IP1,IP2,OP2,DATDIR,NORD(11),DATE,DVM,
     &TEMP,COMENT,MESBUF
      CHARACTER*19 DATE,DVM*12,TEMP*8,COMENT*80
      CHARACTER*8 ISNAME,IUNAME
      CHARACTER*10 IP1,IP2,OP2
      CHARACTER *80 DATDIR,NORD*4,MESBUF*125
-2
      All character information handed round in the program crypad and its
      associated subroutines.
 4
      COMMON /CRPDN/ALAM,UBM(9),MSTYP,AMSC(4),ANGS(4),DANGS(3),
     &NSTEP,NSEQ,SANG(4),HKL(3),IGEO(3),TMORTS(4),ISEQ,LCOUNT,
     &PLTING,IPOL,LUNO,IEND,PGHARD,LDEV(2)
       LOGICAL PLTING,IEND,PGHARD
-2
      All numerical information handed round in the program crypad and its
      associated subroutines.
 1
      COMMON /DEPMAT/LDEP
-1
        LDEP is the unit on to which output of deposited material is written.
 1
      COMMON /DERBAS/DERIVB(%BVAR%),LVARB
-1
        DERIVB holds the derivitives with respect to the LVARB basic variables
 1
      COMMON /DERVAR/DERIVV(%VVAR%),LVARV
-1
        DERIVV holds the derivitives with respect to all LVARV variables
 3
      COMMON /DGEOM/IGEOM,UM(9),NLR,ANGLIN(3),ALAMBD(%LAMB%,%SORC%),
     & NLAMB,ILAMB,ALAM2
      EQUIVALENCE (WLGTH,ALAMBD(1,1))
-9
        Holds information read from Dcards
        GEOM geometry type
        UM(9) orientation matrix wrt othogonal cryst allographic axes
        NLR left/right indicator
        ANGLIN(3) aangles associated with particular geometries
        ALAMBD wavelengths
        NLAMB number of different wavelenghts
        ILAMB which wavelength in ALAMBD
        ALAM Half wavelength contamination
 2
      COMMON /DREAD/IDREAD(10),DNEEDS(10)
      LOGICAL DNEEDS
-2
       IDREAD indicates the number of each kind of D card read
       DNEEDS indicates which DCARDS are still needed
 2
      COMMON /DSRCNM/DNAME(%DSRC%),IDEN(%DSRC%)
      CHARACTER *100 DNAME,IDEN*4
-3
      Contains character constants for different data sets (sources)
      DNAME The data set's full file-name
      IDEN  Four letter identifier for the data set
 2
      COMMON /DSOURC/NUMSRC,JSRC,MSRC(2,%DSRC%),NOBSRC(%DSRC%),SRCPAR(20,%DSRC%)
     &,SRCWT(%DSRC%),DPOP(%DPOP%),KDPOP(%DPOP%),IPDOM(%DSRC%),IPSCAL(%DSRC%)
 -12
      Contains constants belonging to different types of data (sources)
      NUMSRC number of different types
      JSRC   The current source
      MSRC   MODER:- data format and REFI:- refinement type for each source
      NOBSRC Number of last observation for each source
      SRCPAR Buffer to hold special parameters pertinant to the source
             e.g. the polarisation direction.
      SRCWT  The relative weight to be given to this data source
      DPOP   domain populations and LSQ pointer KDPOP
      IPDOM, IPSCAL position of domain and scale pointers for each source
      IPDOM(I) is the number of domain populations up to but not including
      the Ith source.
 5
      COMMON /D3OPC/ISNAME,IUNAME,IP1,IP2,IPOLD,DATDIR,OP2,OP3,NORD(6),
     &MONOID,FILTER,DATE,TEMPER,FIELD,DVM,MESBUF
      CHARACTER*8 ISNAME,IUNAME,MONOID,FILTER,TEMPER,FIELD,DVM
      CHARACTER*10 IP1,IP2,IPOLD,OP2*100,OP3,DATDIR*80,NORD*4,DATE*19,
     &MESBUF*125
-2
       Contains all character information handed around by D3OP and its
       associated subroutines.
  4
      COMMON /D3OPN/IGEO(3),ALAM,UBM(9),H(3),IMTYP,AIS(3),IAIS,NBPB,
     1NSEQ(4),IMEAS,LCOUNT,ANG(3),POLARS(4),BLSPS(8),TMORTS(4),LUN(4),
     2LUNO,IEND,OLDFIL
      LOGICAL IEND,OLDFIL
-2
       Contains all numerical information handed around by D3OP and its
       associated subroutines.
 1
      COMMON /EXCREG/NEXCL(%SORC%),EXCLUD(%EXCL%,%SORC%)
-1
      Defines excluded regions in profile refinement
  3
      COMMON /EXTN/IEXTYP,DOMR,KDOMR,AMOSC,KMOSC,EXTCOR,CEXT(4),
     & XEXT,DEXDFQ,DEXDRQ,DEXDGQ,LOREN,GAUSS,PATHS
      LOGICAL LOREN,GAUSS,PATHS
-11
        IEXTYP type of exteinction
        DOMR domain radius KDOMR indicates whether it is to be refined
        AMOSC mosaic spread, KMOSC indicates whether it is to be refined
        EXTCOR the extinction correction applied to F (sqrt(y))
        CEXT The 4 constants of the Becker Coppens theory
        XEXT The x parameter in the expansion for y.
        DEXDFQ the derivative of extcor with respect to F
        DEXDRQ the derivative of extcor with respect to DOMR
        DEXDGQ the derivative of extcor with respect to AMOSC
        LOREN Extinction type in Lorentzian
        GAUSS Extinction type is Gaussian
  1
      COMMON /EXTRAE/DOMRI(3),FOVLP,KDOMRI(3),KFOVLP
-2
      Extra extinction parameters needed when the magnetic and nuclear
      domain sizes are different
 2
      COMMON /FCAL/FC,DERIVT(%F2VA%),FCMOD,COSAL,SINAL,FCDERS(%F2VA%)
      COMPLEX FC,DERIVT
-6
        FC the complex structure factor
        FCMOD the modulaus of FC
        COSAL real(fc)/fcmod
        SINAL imag(fc/fcmod)
        FCDERS derivatives of FCMOD with respect to all family 2 parameters
        DERIVT derivatives of FC with respect to all family 2 parameters
  4
      COMMON /FCCDAT/DATFIL,INSTNM,LONGTI,RUNUSR,STTIME,
     & WSHIST,XCAPT,YCAPT,MCAPT
      CHARACTER DATFIL*80,INSTNM*8,LONGTI*80,RUNUSR*20,
     & STTIME*20,WSHIST*200,XCAPT*40,YCAPT*40,MCAPT*40
-1
     Character information used by PICTIC (profile plotting routine)
 2
      COMMON /FINAME/FILNAM(%FILE%)
      CHARACTER *10 FILNAM
-1
      FILNAM the leaf names of files associated with CCSL I/O units
 5
      COMMON /FOCDAT/NOTC,NCYMIN,NCYMAX,DELTA,LDFIL,FI,
     & INSTCO,INSTST,NXCODE,LNPDFN,AL1,AL2,NOSPEC,NPT,
     & NUMRUN,RUNDUR,TTHET,XMN,XMX,YMN,YMX,NYCODE,NEMODE,
     & EFIXED,USERPR(30),TDATA(%PTIC%),BACK(%PTIC%),OBSDAT(%PTIC%),
     & CALDAT(%PTIC%),ERR(%PTIC%),STADAT(%PTIC%),YRANGE,IUNIT
-1
     Numerical information used by PICTIC (profile plotting routine)
 2
      COMMON /FONAM/FONA(%FORM%,%PHAS%),FONAME(%FORM%)
      CHARACTER *4 FONAME,FONA
-1
        Table of form factor names
 1
      COMMON /FORGRP/NATFOR(%FORM%,%ATOM%),NAFPNT(%FORM%)
-4
      NATFOR(I,1:n) holds n atom numbers, being a list of which atoms from
        A cards have form factor number I.
      NAFPNT(I) says how many atoms from A cards have form factor I (which
        is therefore the n in the 1:n in the definition of NATFOR).
 3
      COMMON /FORMDA/NFORMF(%ATOM%),MODE(%FORM%),NT(%FORM%),F(%FTAB%,%FORM%),
     & S(%FTAB%,%FORM%),CMULT(%FORM%),KCMULT(%ATOM%),NBAKF(%FORM%),
     & NUMFNM,KOM7
-7
       NFORMF form factor identifier,
       MODE type of form factor
       NT number of terms
       F form factor table
       CMULTcontanst multiplier KCMULTindicates whether it is refined
       NBAKF back reference to first atom using this factor
       NUMFNM number of form factor names
 1
      COMMON /FORMD2/NBKF(%FORM%,%PHAS%),NMFNM(%PHAS%)
-1
         For multiphase refinementss
 2
      COMMON /FRIED/FRIEDL,KOM8
      LOGICAL FRIEDL
-2
        FRIEDL true if friedel is to be inposed on a non-centrosymmetric
        structure
 2
      COMMON /FUDG/NFUDGE,IFDGPT(%FUDG%),FUDGE1(%FUDG%),FUDGE2(%FUDG%),
     & IFDTYP(%FUDG%)
-5
       NFUDGE number of fudged parameters
       FDGPT pointer to parameter
       FUDGE1 fudge parameter: factor or lower limit (if range)
       FUDGE2 upper limit if range
       IFDTYP type of fudge
 1
      COMMON /FUNIT/NASYM,ASYM(3,3),EDGE(3,3),ANG(3),NMUL,KOM10
-6
       Definition of asymmetric unit
       NASYM number of planes
       ASYM inices of planes
       EDGE indices of edges
       ANG Dividing angles
       NMUL maximum multiplicity
 1
      COMMON /FWVALS/NVALS,COEFFS(9)
-3
        Forsyth and Wells coefficients
        NVALS number of coefficients
        COEFFS  A a, B, b .....etc.
 2
      COMMON /F2NAMS/F2NAME(%F2PR%)
      CHARACTER *4 F2NAME
-1
        F2NAME: names of all family 2 parameters
 1
      COMMON /F2NUMS/NF2NUM(3,%F2PR%)
-1
        F2NUMS: specifications of all family 2 parameters
 2
      COMMON /F4PARS/NGEN4(%PHAS%,%SORC%),F4VAL(3,%REFS%),
     & F4PAR(3,%REFS%),KF4PAR(3,%REFS%),F4PESD(3,%REFS%),KOM6
-1
       Specifications of family 4 parameters
 1
      COMMON /GAUSS/XX(%GPTS%),YY(%GPTS%),ZZ(%GPTS%),WW(%GPTS%),NL,NM,NN,NQ
-1
        Coordinates and weights of Gauss points
 2
      COMMON /GKSDAT/NP,XP(%NGKS%),YP(%NGKS%),LASER,PICTS
      LOGICAL LASER,PICTS
-4
      Data for plotting with GKS
      NP,XP,YP dfinition of polyline
      LASER if laser output
      PICTS if a picture has been drawn
 2
      COMMON /GNPLT/INPLOT,LDAT,LNECOL,TNUMS(2,2)
      LOGICAL INPLOT
-5
      Data for plotting using GNUPLOT
      INPLOT true when plot data being recorded
      LDAT unit number of the output file
      LNECOL the current color
      TNUMS terminal data (size and scale)
 2
      COMMON /GPCHRS/TERM(2),TOPTS(2),HCOUT
      CHARACTER TOPTS*40 ,TERM*10,HCOUT*40
-4
      Character data for GNUPLOT plotting
      TERM the device names (display and print)
      TOPTS special terminal options needed for gnuplot  "set terminal"
      HCOUT the name of the print file
 1
      COMMON /GFNUMS/NGFCOL,NGFSYM,NGFTYP,NGFLS
-2
      Numbers defined for graphics programs
      Numbers of colors, symbols, fill types and line tyles
 3
      COMMON /GFWRDS/GFCOLS(%GFCL%),RGBWRD(%GFCL%),GFSYMS(%GFSM%),
     & GFTYPS(%GFTP%),GFLSTY(%GFLS%)
      CHARACTER RGBWRD*7,GFCOLS*3,GFSYMS*6,GFTYPS*4,GFLSTY*4
-6
      Words understood by graphics programs
      RGBWRD Hexadecimal representation of RGB colour spec
      GFCOLS first 3 characters of the names of the defined colours
      GFSYMS names of defined symbols
      GFTYPS 1 for unfilled symbol, 2 for filled symbol
      GFLSTY words for line styles (full, dash, dado etc)
 2
      COMMON /GLOBAL/NINIT,NBATCH,NSYSTM,MULFAS,MULSOU,MULONE
      LOGICAL MULFAS,MULSOU,MULONE
-7
        Global information about jobs
        NINIT set once INIT has been called
        NBATCH set if Batch run
        NSYSTM type of system
        MULFAS true if multi-phase
        MULSOU true if multi-source
        MULONE true if either multi-phase or multi-source
 2
       COMMON /GPLMAP/WIDMAP,HGTMAP,WIDBOX,XORIG,XPROJ,FRACXY,
     & TMAP(2,3)
-1
      Data needed to plot maps with GNUPLOT, replaces contur used by FOURPL
 3
      COMMON /GRDBCK/IBACK,NBACK(%SORC%),ARGBAK(%BACK%,%SORC%),
     & BACKGD(%BACK%,%SORC%),KBCKGD(%BACK%,%SORC%),NBK,LBKD(20),ZBAKIN
      LOGICAL ZBAKIN1
-1
      Background parameters for profile refinement
 1
      COMMON /GREAD/IGREAD(%GCRD%)
-1
      IGREAD indicates which words have been read from G cards
 1
      COMMON /GUNIT/MARK(3,2),BSYM(3,3),IBOX,KOM11
-1
      Data used to define the type of asymmetric unit
 2
      COMMON /HKLGEN/STEP(3,3),PT(3,3),VECEND(3,3),PRPT(3,3),
     & NPRIM(2,2),NP,LFAC(2),MCOUNT(2),KOM5
-4
      Keeps data saved between successive calls of GETGEN
      STEP(3,3) reciprocal space stepping vectors
      PT(3,3) current position
      VECEND(3,3) endpoints
 1
      COMMON /IINFO/IIN,ACOEFF(%ICRD%)
-3
      Data read from I cards
      IIN number of word value pairs read
      ACOEFF value read for each
 2
      COMMON /IINFOW/IIREAD(%ICRD%)
      CHARACTER *4 IIREAD
-1
      IIREAD words  read from I cards
 1
      COMMON /INCDAT/FMULT,FMUL(3),MULINT
-1
      Defines possible multiplication factors for indices
 1
      COMMON /IOUNIT/LPT,ITI,ITO,IPLO,LUNI,IOUT
-6
      LPT fortran unit number of listing output
      ITI fortran unit number for terminal input
      ITO fortran unit number for terminal output
      IPLO fortran unit number for graphic output
      LUNI general purpose fortran input unit
      IOUT Level at which diagnostic output is required
 1
      COMMON /LENINT/NBITS
-1
      Length in bits of an integer (system dependent)
 3
      COMMON /LINKAG/NUMFV,NUMPAK,KKFV(%FXVA%),KTYPFV(%FXVA%),KSTFV(%FXVA%),
     & KTIME(%FXVA%),KUNPFV(5,%FVPK%),NTIME,NUMCON,KKCON(%CONC%),AMCON(%CONC%),
     & KPTCON(%AL+1%),KSTCON(%ALLC%),KTPCON(%ALLC%)
-1
      All information for fixing, varying and constraining parameters in LSQ
 1
      COMMON /LOONEY/IOTAB(%FILE%),LUNTAB(%FILE%)
-3
      CCSL input output units
      IOTAB marks which are available
      LUNTAB gives the unit number associated with each allocated unit
 3
      COMMON /LREAD/ILREA(%LCRD%,%SORC%),KOM18
      DIMENSION ILREAD(%LCRD%)
      EQUIVALENCE (ILREAD(1),ILREA(1,1))
-1
      ILREAD Indicates which L cards have been read
 1
      COMMON /LSETDA/MFAM,MGEN,MSPC,LASTST
-1
      Maximum number of Families, Genuses and Species in the problem
 1
      COMMON /LSQPAK/KKPACK(10,3)
-1
      Packing specification for least squares parameters
 1
      COMMON /MAGCHI/CHISYM(6,6,%SYMO%),FIELD
-1
      Transformed susceptibility tensors for each symmetry operator
 8
      COMMON /MAGDAT/NMAG,MAGAT(250),JMAGAT(50),NMFORM(50),
     &ANGM(4,50),SMOD(2,50),SPIND(3,3,2,50),PHIH(4,50),LPHI(4,50),
     &KANGM(4,50),KSMOD(2,50),KPHIH(4,50),NPHI(50),KDUM(13,50),
     &KSPORD(2,2),FCENT(50),IPTAB(49,50),KOM19
      INTEGER KRVEC(3,2,2,50)
      COMPLEX RVEC(3,2,50),SPORD(2)
      EQUIVALENCE (RVEC,ANGM),(KRVEC,KANGM),(PHIH,SPORD)
      LOGICAL FCENT
-19
     NMAG number of magnetic atoms
     MAGAT indicates which atoms are magnetic
     JMAGAT indicated which magnetic atom correspond to which atom
     NMFORM form factor numbers of magnetic atoms,
     ANGM spherical polar coordinates of spin directions of magnetic atoms
     KANGM which directions are being refined
     SMOD magnetic moments of magnetic atoms
     KSMOD which magnetic moments are being refined
     RVEC complex vector fourier coefficients for each atom
     KRVEC which components of RVEC are refined
     SPORD complex order parameters
     KSPORD which order parameters are to be refined
     PHIH Psi values (phase shifts) of magnetic atoms
     KPHIH which Psi values are being refined
     LPHI which psi value corresponds to which operator
     NPHI number of Psi values for each atom
     FCENT is true for an atom whose centric partner can have a phase shift
     IPTAB number of the Psi to be used with each operator
     SPIND orthogonal coordinates of spin vectors and derivatives
 2
      COMMON /MAGSF/FMC(3),FMSQR
      COMPLEX FMC
-4
      Allows the magnetic structure factor (not the interaction vector)
      calculated in FMCALC to be used in other modules
      FMC is the complex vector magnetic structure factor
      FMSQR  is its amplitude squared
  3
      COMMON /MAPDA/U(3,3),OUTLIM(3,3),NX,NY,NXY,NH,NK,NHK,NKX,NDIM,
     & DENS(10201),MODEF,NOBSIN,NUSED,SCALF1,SCALF2,DELTA,MODED,SMAX,
     & MODET,SECZER(3),SECEND
-17
     U Zone axes defining the axes of a map
     OUTLIM max, min and step along each axis
     NX,NY,NXY number of x, y, and x*y points
     NH,NK,NHK,NKX,number of h, k and  h*k values
     NKX number points in kx grid
     NDIM number of dimensions for map
     DENS the calculated density
     MODEF type of map
     NOBSIN number of observations and NUSED number used
     SCALF1 user scale
     SCALF2 actual scale including area or volume
     DELTA resolution length
     MODED data format
     SMAX  maximum sin(theta)/lambda
     MODET type of transformation
     SECZER(3) base of sections
     SECEND final z for this section
 1
      COMMON /MAPGT/ZGTVAL(20),ZCGT,IGT,IZGT,IDUMPG
-3
      ZGTVAL Z values at which saved maps are to be "got"
      ZCGT Current value, IGT current index,
      IZGT number to be "got",IDUMPG number of dumps available
 4
      COMMON /MAPLAB/NLABS,NFOUND,LFOUND,SYSIZE(%MLAB%),LABAT(%MLAB%),
     &LSYMB(%MLAB%),MCOLOR(%MLAB%),FILL(%MLAB%),FOUNDL(%MLAB%),
     &LABNO(%LABA%),POSLAB(2,%LABA%)
      LOGICAL FOUNDL,FILL
-7
      Atom and symbol information for labelling maps
      NLABS number of different atoms to be labelled
      SYSIZE Symbol sizes of the labels
      LABAT identifying number of the atom to be labelled
      LSYMB , LCOLOR The symbol and colour to use
      FOUNDL A logical indicating whether this atom was found in the
      section or projection
1
      COMMON /MAPMAP/UINV(3,3),DET,AXLEN(3),NPRIM
-5
      Data needed to plot atom positions on maps
      UINV inverse of Map orientation U in /MAPDA
      DET  determinant of U
      AXLEN lengths of axes defined by UM
      NPRIM number of primitive with origins cells in the map
 1
      COMMON /MAPPR/ZPRVAL(20),ZCPR,IPR,IZPR
-1
      ZPRVAL(20) z values at which maps are to be printed
 1
      COMMON /MAPRD/ZRDVAL(20),ZCRD,IRD,IZRD,IDUMPR
-1
      ZRDVAL(20) z values at which dumped maps are to be read
 1
      COMMON /MAPSV/ZSVVAL(20),ZCSV,ISV,IZSV,NDUMPS,NSAV
-1
      ZSVVAL(20) z values at which  maps are to be saved
 1
      COMMON /MATDAT/MATPNT(%BV+1%),BLSQ(%BVAR%)
-1
      Pointers into least squares matrix
 2
      COMMON /MCAL/FMCMOD,FMCSQR,FMCDER(%F2VA%),QDOTP,DQDOTP(%F2VA%)
      COMPLEX QDOTP,DQDOTP
-6
      FMCMOD The modulus of the magnetic interaction vector averaged over
      domains
      FMCSQR its square
      FMCDER its derivatives with respect to the family 2 parameters
      QDOTP scalar product of Q with P for polarised neutron data
      QDOTP derivatives of QDOTP with respect to the family 2 parameters
 3
      COMMON /MPODA/NMPAT,NMPOL,MPATAB(%MPAT%),MPNMTB(%ATOM%),
     & NCLUMP,KCLUMP(%MBLK%),MPTAB(%MP+1%),POLAMP(%MPOL%,6),KPOLMP(%MPOL%),
     & NCMAT,CONMAT(600,2)
-11
      NMPAT the number of atoms with multipole form factors
      NMPOL the number of multipoles
      MPATAB which atom corresponds to which multipole atom
      MPNMTB which multipole atom corresponds to which atom
      NCLUMP number of lvalue blocks
      KCLUMP which of above are refined
      MPTAB pointers to the multipoles of each multipole atom
      POLAMP multipole amplitudes
      KPOLMP which of above are refined
      NCMAT number of constraint matrices
      CONMAT Constraint matrices
 2
      COMMON /MPODAC/MPNAM(%MPOL%)
      CHARACTER *4 MPNAM
-1
      MPNAM multipole names
 1
      COMMON /MREAD/IMREAD(%MCRD%)
-1
      IMREAD which M cards have been read
 1
      COMMON /MULPLY/AMUL(3)
-1
      Multiplication factor for indices
 2
      COMMON /NEWOLD/SHIFT,XOLD,XNEW,ESD,IFAM,IGEN,ISPC,
     & NEWIN,KPACK,LKH,SHESD,ISHFT,AVSHFT,AMAXSH
-10
      Shift information for one parameter after a least squares cycle
      SHIFT shift, XOLD old value, XNEW new value ESD standard deviation
      IFAM, IGEN,  ISPC, family,genus and  species of parameter
      NEWIN fortran unit number of "new" crystal data file
      KPACK packed parameter specification
      LKH fortran unit number for hkl output
      SHESD ratio  SHIFT/ESD
      ISHFT number of shifts dealt with so far in this cycle
      AVSHFT the sum of their SHIFT/ESD so far
      AMAXSH the maximum SHIFT/ESD so far
 2
      COMMON /NSYM/NOP,NCENT,NOPC,NLAT,NGEN,CENTRC,KOM13
      LOGICAL CENTRC
-6
      NOP number of symmetry operators
      NCENT 1 if there is a centre of symmetry, 0 otherwise
      NOPC  2 if there is a centre of symmetry, 1 otherwis
      NLAT Number of non-primitive lattice translations
      NGEN number of generating elements in the group
      CENTRC true if centro-symmetric
 1
      COMMON /NTITL/NTITLE,KOM14
-1
      NTITLE Number of character i the title
 4
      COMMON /OBSCAL/OBS,DOBS,GCALC,YCALC,DIFF,ICODE,SUMWD,NOBS,
     & IWGH(1),WTC(4),WT,SQRTWT,WDIFF,YBACK,YPEAK,YMAX,NBSTOT,SWDTOT,
     & CSQTOT
      EQUIVALENCE (IWGHT,IWGH(1))
-10
      Data for the observation currently being treated
      OBS, DOBS observed value and its standard deviation
      GCALC calculated value of observation
      YCALC calculated value of slackly constrain-d distance
      DIFF difference between OBS and GCALC
      ICODE observation code
      SUMWD sum of weighted differences
      NOBS number of observations
      NBSTOT number of observations summed over data sets
      SWDTOT sum of weighted differences  summed over data sets
 3
      COMMON /OLDSYM/OSYM(3,3,%SYMO%),OTRANS(3,%SYMO%),JNVERS(%SYMO%),
     & JNORD(%SYMO%),MOLTAB(%SYMO%,%SYMO%),IOGEN(3),NOPONT(%SYMO%),NOPO,
     & NCENTO,NOPCO
-2
     Copy of information in /NSYM/ and /SYMDA/ used when swapping between
     magnetic and nuclear symmetries
 1
      COMMON /OMITPR/MIS,AMISS(3,%OMIT%),KOM12
-1
      Specifies regions to be omitted in profile refinement
 1
      COMMON /ORTSYM/SYMORT(3,3,24),NFLAG
-2
      SYMORT symmetry operators on oorthogonal axes
      NFLAG set when the above have been calculated
 2
      COMMON /OVER/ITFAC,OTFAC(%TFAC%),KOTFAC(%TFAC%),NTFAC,JTFAC,KOM15
      EQUIVALENCE (TFAC,OTFAC(1)),(KTFAC,KOTFAC(1))
-4
      ITFAC whic overall temperature factor is to be used
      OTFAC overall temperature factors
      KOTFAC which are being refined
      NTFAC number of overall temperature factors
 4
      COMMON /PAWLPR/AKLO,AKHI,SLACK,STRKT,STRTOL,SLKTOL,ITST,
     & ISPSLK(2,%PSLK%),IGSLAK(%PSLK%),AMSLAK(2,%PSLK%),WTSLAK(%PSLK%),
     & WEELEV,KOM16
      LOGICAL STRKT
 2
 1
      COMMON /PHAS0/INRLP0,ICDLP0,INRLP1,ICDLP1,NCDF0
-1
      Multiphase refinement data
 3
      COMMON /PHASE/NPHASE,IPHASE,JPHASE,KPHASE,NPHUNI(%PHAS%),
     & SCALEP(%PHAS%),KSCALP(%PHAS%),PHMAG(%PHAS%)
      LOGICAL PHMAG
-1
      More ultiphase refinement data
 1
      COMMON /PICDEF/CMPERA,FRLINE,APERMB,PWIDTH,PHGHT,X0,Y0
-6
      Picure definition (MAG3D)
      CMPERA cms per angsrtom unit
      FRLINE fractional line-width
      APERMB angstom units per Bohr mageton (arrow length)
      PWIDTH,PHGHT picture width and height
      X0,Y0 starting positions
 1
      COMMON /PLODAT/PAPERW,PAPERH,ASPECT,BORDER,CHUNIT,FROMCM,CHMAP
-7
      Plotter data
      PAPERW,PAPERH paper width and height
      ASPECT aspect ratio
      BORDER border width
      CHUNIT size of one character unit
      FROMCM scale map or fill screen?
      CHMAP Scale from CCSL cms to map cms (from pixels) for pixel based screen devices

 3
      COMMON /PLOMAP/WIDTOT,HGTTOT,WIDPIC,HGTPIC,WIDMAP,HGTMAP,WIDTTL,
     & HGTTTL,WIDTXT,HGTTXT,WIDCON,HGTCON,XMARG,YMARG,XWHITE,YWHITE,
     & NYPIC,IYPIC,CHSCAL(2,3),SCALMP
-12
     Data for plotting maps
     WIDTOT,HGTTOT total width and height of output (may be many pictures)
     WIDPIC,HGTPIC,width and height of one picture
     WIDMAP,HGTMAP width and height of maps
     WIDTTL,HGTTTL width and height of title
     WIDTXT,HGTTXT width anf heigth of text panel
     WIDCON,HGTCON,width and height of contour panel
     XMARG,YMARG,XWHITE,YWHITE borders,
     NYPIC numbr of pictures in y direction
     IYPIC identifies the one being plotted
     CHSCAL(2,3) character scales
     SCALMP scale of map cm/angstrom
 2
      COMMON /PLOTCH/ITEXT,NTEX(2)
      CHARACTER *80 ITEXT,NTEX*15
-2
      ITEXT Graph title
      NTEX Labels of x and y axes
 2
      COMMON /PLTRAN/PMTRIX(2,3,10),PTRAN(2,3,2),NSPCE,NCON1,NCON2,MPEN,
     & NTRAN(10),MAXSP
-6
     PMTRIX plotter transformation matrices
     PTRAN transformation in use
     NSPCE number of current plotter space
     NCON1,NCON2 spaces related by PTRAN
     NTRAN which space is given by which PMTRIX
     MAXSP maximum spaces used
 1
      COMMON /PLTS/X(2,5),S(2),CH,XS,ISIG(2),YS,NDIVS(2,2)
-14
      Graph definition
      X(I,J )defines how the graph will be drawn
         I=1 for x-axis, I=2 for y-axis.
         J=1  length of axis in user units
         J=2  length of axis in cms.
         J=3  division of axis in user units
         J=4  minimum value in user units
         J=5  position of axis to be plotted
         S(I) scale for axis
         CH  character size
         XS x mark length
         ISIG(I) number of signicicant figures for axis numbers
         YS y mark length
         NDIVS(2,I) number of major and minor divisions
 1
      COMMON /POINTS/LVRBS(%VVAR%),LVRPR(%VVAR%),LBSVR(%BVAR%),LRDVR(%CSTR%)
-4
      LVRBS which basic is this variable (+=basic, -=redundant)
      LVRPR which parameter is this variable (packed)
      LBSVR which variable is this basic variable" (all +ve)
      LRDVR which variable is this redundant variable
 1
      COMMON /POLDA/POLUP,DPOLUP,POLDW,DPOLDW,MODEP,POLND(3)
-4
      POLUP,DPOLUP polarisation for spin up state  and esd
      POLDW,DPOLDW polarisation for spin up state  and esd
      MODEP type of depolarisation
      POLND polarisation direction (orthogonal crystallographic axes)
 4
      COMMON /POLDAT/DXSDN,DXSDQ(3,%DOMS%),DPOLDN(3),DPOLDQ(3,3,%DOMS%),
     & NDOMN,POLIT(3,3),POLM(6),POLO(3,%DOMS%),QSQR(%DOMS%),
     & POLD(3),QSQRM
      COMPLEX DXSDN,DXSDQ,DPOLDN,DPOLDQ
-1
      Incident and scattered Polarisation information used in PALSQ
 2
      COMMON /POLFOR/MPFOR(%FORM%),NMPFOR,MPLFOR(%MPFL%,%MPFO%),NUMGEN,
     &PFORFA(%MPFL%),LMAX
-6
      MPFOR(I) multipole form factor identifier I refers to form factor table
      NMPFOR number of multipole form factors
      MPLFOR(L,I) form factor <jL>  to be used for Ith multipole form-factor
      NUMGEN number of form factor names generated
      PFORFA(J) value of form factor for J-1 th
      LMAX max L in calculation
 3
      COMMON /POLKA/NDOM,FRAC(24),NPTS,PANGS(3,2,50),DPANGS(3,50),
     & ERRCH(50)
      CHARACTER *1 ERRCH
-1
      Polarisation and domain information
 5
      COMMON /POSNS/NATOM,X(3,%ATOM%),KX(3,%ATOM%),AMULT(%ATOM%),
     & TF(%ATOM%),KTF(%ATOM%),SITE(%ATOM%),KSITE(%ATOM%),
     & ISGEN(3,%ATOM%),SDX(3,%ATOM%),SDTF(%ATOM%),SDSITE(%ATOM%),
     & ATESDS,KOM17
       LOGICAL ATESDS
-9
       NATOM number of independent atoms
       X atomic positions, KX position refinement switch
       AMULT fractional multiplicity of each site
       TF Isotropic temperature factor for each site
       KTF ITF refinement switch
       SITE,KSITE site occupation factor and refinement switch
       ISGEN generators of the point group symmetry of the sites
       SDX,SDTF,SDSITE esd's in positions, ITF's and occupation factors
       ATESDS is true if esd'd in the positions have been read
 1
      COMMON /POSNS2/NATO(%PHAS%)
-1
      Number of atoms for each phase (multiphase PR)
 1
      COMMON /POSREL/NXYZ(3,%ATOM%),XYZ(3,%ATOM%)
-2
      NXYZ type of constraint on each coordinate and each atom (0=none)
      XYZ amount of constraint on each coordinate and each atom
 2
      COMMON /PRABSC/NABTYP(%SORC%),ABSPR(2,%SORC%),KABSPR(2,%SORC%),
     & ABSCOR,DERABQ(2),NABSPR(%SORC%)
-1
     Parameters for absorption corrections in LSQ
 6
      COMMON /PRBLEM/NFAM,NGENPS(%FAMS%,%PHAS%),NSPCPS(%FAMS%,%PHAS%),
     & LF1SP(5),LF3SP(10,%PHAS%,%SORC%),LVFST1(%FAMS%,%PHAS%,%SORC%),
     & LBFST1(%FAMS%,%PHAS%,%SORC%),NVARF(%FAMS%,%PHAS%,%SORC%),
     & NBARF(%FAMS%,%PHAS%,%SORC%),LF6SP(3,%SORC%)
      DIMENSION NGENS(%FAMS%),NSPC(%FAMS%)
      EQUIVALENCE (NGENS(1),NGENPS(1,1)),(NSPC(1),NSPCPS(1,1))
-10
      NFAM number of families of parameters
      NGENPS number of genuses in each family
      NSPCPS number of species in each family
      LF1SP type of each family 1 species
      LF3SP,ype of each family 13species
      LVFST1 base pointer yo variables of each family
      LBFST1 base pointer to basic variables of each family
      NVARF number of variables in each family
      NBARF number of basic variables in each family
      LF6SP pointers to family 6 (peak parameters)
 1
      COMMON /PREORI/NPRTYP,PRFDIR(3),PRFLEN,PRFPAR,KPRFPR,PRFCOR,DERPRQ
-1
      Preferred orientation parameters (profile refinement)
 1
      COMMON /PREXTN/NEXTYP,EXTPR,KEXTPR,EXTCO,DEREXQ,DXDFQ
-1
      Profile refinement extinction parameters
 2
      COMMON /PRNAMS/PRNAME(%PRPR%)
      CHARACTER *4 PRNAME
-1
      PRNAME list of names of special profile refinemnt parameters
 1
      COMMON /PRNUMS/NPRNUM(3,%PRPR%)
-1
      NPRNUM specifications of parameters corresponding to PRNAMEs
 4
      COMMON /PRPKCN/ARGK,PKCNSP(%PKSP%,%PHAS%,%SORC%),
     & KPCNSP(%PKSP%,%PHAS%,%SORC%),DTDPCN(%PKSP%),DTDWL,
     & NPKCSP(%PHAS%,%SORC%),ARGMIN(%SORC%),ARGMAX(%SORC%),
     & ARGSTP(%SORC%),PCON
-1
      Profile refinement peak parameters
 7
      COMMON /PRPKFN/ARGI,YNORM,PKFNSP(%PKGN%,%PKSP%,%PHAS%,%SORC%),
     & KPFNSP(%PKGN%,%PKSP%,%PHAS%,%SORC%),
     & DERPFN(%PKGN%,%PKSP%),NPKFSP(%PKGN%,%PHAS%,%SORC%),TOLER(%PKGN%,%PHAS%,
     & %SORC%),NPKGEN(%PHAS%,%SORC%),PKFNVA(%PKGN%),DYNDVQ(%PKGN%),
     & DYNDKQ,REFUSE,CYC1,NOPKRF,TOLR(2,%SORC%),NFFT,AKNOTS,
     & NBASF4(%REFS%,2,%PHAS%),L4END(%PHAS%),L6ST,L6END
      LOGICAL REFUSE,CYC1,NOPKRF
-1
      Profile refinement peak function parameters
 2
      COMMON /PRSAVE/KPOINT(%OLAP%),SAVP2(%OLAP%),SAVDER(%F2VA%,%OLAP%),
     & SAVPRC(%OLAP%),SAVDPC(%OLAP%),SAVFCN(%OLAP%)
-1
      Saved structure factor data (profile refinement)
 2
      COMMON /PRSAVF/PKLIST(%FFT2%,9,%OLAP%),XPKDEL(%OLAP%),PKADD(%FFT2%,9),
     & ARGNOT(50),PKNOT(%FFT1%,9,50),XPDKNT(50)
-1
      Saved peak position data (profile refinement)
 2
      COMMON /PRSTAT/SMYC,SMYD,SMYO,SMIO,SMID,SMWYOS,IZCT,
     & P5,IOP1,IOP2,KMI(%PHAS%),KMA(%PHAS%)
-1
      Statistical data for profile refinement
 2
      COMMON /PRZERO/ZEROSP(%PKSP%,%PHAS%,%SORC%),KZROSP(%PKSP%,
     & %PHAS%,%SORC%),DKDZER(%PKSP%),NZERSP(%PHAS%,%SORC%)
-1
      Zero point parameters (profile refiment)
 2
      COMMON /PWORDS/PWD(%PWRD%,%PHAS%,%SORC%)
      CHARACTER *4 PWD
-2
      List of words 'SWCH','TAUF','TAUS','SIGM','GAMM', 'CANI
      (profile refinement)
 3
      COMMON /QCAL/Q
      COMPLEX Q(3,%DOMS%),TCALC(6)
      EQUIVALENCE (Q,TCALC)
-2
      Q Magnetic interaction vector for each domain
      TCALC Tensor stucture factor for anisotropic paramagnets
 3
      COMMON /QCALD/FQCDER
      COMPLEX FQCDER(3,%DOMS%,%F2VA%),FTCDER(6,%F2VA%)
      EQUIVALENCE (FQCDER,FTCDER)
-3
      Derivatives of Magnetic interaction vector for each domain with
      respect to family 2 parameters
      FTCDER derivatives of tensor structure factor
 1
      COMMON /QROT/ROT(3,3,%MPAT%)
-2
      Matrix relating quantum to orthogonal crystallographic axes for
      each multipole atom
 2
      COMMON /RADINT/N(20,%RADF%),FF(2,20,%RADF%),NTERMS(%RADF%),
     & IRADF(%RADF%),NRADF
-7
      Data for Slater expansion if radial wave functions
      N(I,J) power of r in Ith term of Jth function
      FF(1,I,J)) amplitude of Ith term of Jth function (Atomoc units)
      FF(2,I,J)) exponent of Ith term of Jth function
      NTERMS(J) number of terms in Jth function
      IRADF(J) type of function (normalised or not)
      NRADF totla number of functions given
 5
      COMMON /REFINE/IREF,NCYC,NCYC1,LASTCY,ICYC,MODERR(%SORC%),
     & MODEOB(%SORC%),IPRNT(20),MAXCOR,IONLY(%PHAS%),SIMUL,MAG,MPL,CHI,
     & TWIN,FIXED,DONE,CONV
      LOGICAL SIMUL,MAG,MPL,CHI,TWIN,FIXED,DONE
      EQUIVALENCE (MODER,MODERR(1)),(MODOBS,MODEOB(1))
-14
      IREF type of refinement (single crystal)
      NCYC numer ot least squares cycles required
      NCYC1,LASTCY numbers of first and last cycles
      ICYC number of this cycle
      MODERR type of refinement (profile)
      MODEOB type of data (profile)
      IPRNT(20) when to print
      Print % correlations above MAXCOR
      IONLY an only command is in effect
      SIMUL indicates a simulation
      MAG there are magnetic parameters
      MPL there are multipole form factors
      CHI Paramagentic susceptibilities
      TWIN for twinned crystals
 2
      COMMON /REFIPR/RIET,CAIL,SAPS,APES,RAPS,TOF,CN,LX,SR,ED,PRECYC,TIC
      LOGICAL RIET,CAIL,SAPS,APES,RAPS,TOF,CN,LX,SR,ED,PRECYC,TIC
-1
      Logicals indicating particular types of least squares refinement
 5
      COMMON /REFLNS/REFH(3,%REFS%),AMUL(%REFS%),AICALC(%REFS%),
     & AIOBS(%REFS%),ESDOBS(%REFS%),SOMEGA(%REFS%),GGCALC(%OMAX%),
     & MAXKK(%PHAS%),KMIN,KMAX,KMOD,KNOW,DSTAR(%REFS%),ISMAG(%REFS%),
     & DKDDS,KOM23
      EQUIVALENCE (MAXK,MAXKK(1))
-1
      Reflection data for profile refinement
 2
      COMMON /REFS/K(3,2),JJ(48,2),LL(48,2),R(500,2),SCALE(2),INC,II,NR,
     &FF(3,2),ITEMS
-5
      Holds a group of equivalent reflections read from an ".arr" file
      K The labeling indices of the group
      JJ the operator number for this equivalent
      LL the number of entries for each equivalent reflection
      R the data (ITEMS entries per reflection)
 2
      COMMON /RSTATS/RNUM,RDEN,RSNUM,RSDEN,RWNUM,RWDEN,RWSNUM,RWSDEN,
     &CHI2
-1
      Data for R factor calculations
 4
      COMMON /SATELL/PROP(3),AKSTAR(3,%SY+1%),KPROP(3),KSTAB(%SY+1%),
     & SIGMAT(2,2,%SY+1%),PHIK(%SY+1%),NKSTAR,IPROP,FKSTAR,NKC,KCENT,
     &ND180,INCOM,KOM21
      LOGICAL INCOM
-11
      PROP, KPROP magnetic propagation vector and refinement switch
      AKSTAR symmetry star of vector PROP
      KSTAB Symmetry table for configuration symmetry
      SIGMAT symmetry matrices for order parameters, INCM structures
      PHIK phase offsets for translation symmetry, INCM structures
      NKSTAR number of arms in the star of PROP
      IPROP Type of magnetic reflections
      FKSTAR factor to scale magnetic intensities to account for
      multiplicity of the star
      KCENT 2 if PROP .NE. -PROP
      ND180 NUMBER OF 180 DEGREE DOMAINS  (1 OR 2)
 2
      COMMON /SCAN/PL(100),DP(100),VAR(100),PLMIN,PLMAX,VMIN,VMAX,
     & ICYC,SA,JANG
-1
      Data for a scan
 2
      COMMON /SCLDAT/ISCALE,NSCALE,SCALE(%SCAL%),KSCALE(%SCAL%),
     & NSCL,LSCD(10)
-1
      Scale data for least squares
 3
      COMMON /SCRACH/MESSAG,NAMFIL
      CHARACTER *80 ICARD,MESSAG*%MESS%,NAMFIL*%FNAM%
      EQUIVALENCE (ICARD,MESSAG)
-2
      Shared character buffers
      ICARD receives all data read from CDF or with ASK
 2
      COMMON /SFDATA/NDATA,HS(3,%NLSQ%),GOBS(%NLSQ%),WGTS(%NLSQ%),
     &JSCALE(%NLSQ%),ICODES(%NLSQ%),CPARS(5,%NLSQ%)
-8
      Stored structure factor and other data for least squares refinements
      NDATA   the number of reflections stored
      HS      3xNDATA vector of reflection indices
      GOBS    the array of data values
      WGTS    the weight of each observation
      JSCALE  the scaling zone number for each observation
      CPARS   Other constants which are needed and are independent of the LSQ
              parameters (eg extinction constants)
 2
      COMMON /SFHEDP/NHEAD,LHEAD(7),HMASK(6)
      LOGICAL HMASK
-4
      Description of headers on SF data files
      NHEAD   number of different header words
      LHEAD   pointers to where header values are stored
      HMASK   says which headers are needed or have been read
 2
      COMMON /SLAKDA/NSLAK(%SKTP%),SLKSWD(%SKTP%),SLAKWT(%SKTP%),
     & CHISQD(%SKTP%),ISLKTP,NSKTOT,KOM24
-1
      Data describing slack constraints
 3
      COMMON /SLKGEC/ATTNAM(%SLAK%),BONNAM(%SLAK%),ANGNAM(%SANG%),
     & TORNAM(%TANG%)
      CHARACTER *4 ATTNAM,BONNAM,ANGNAM,TORNAM
-1
      Definitions of slack constraints
 7
      COMMON /SLKGEO/NSTYP,BOBS(%SLAK%),EOBS(%SLAK%),IATM(%SLAK%,2),
     & ISYM(%SLAK%),ILAT(%SLAK%),CELLTR(3,%SLAK%),XSLAK(3,%SLAK%),
     & COSIN(3,3),IABASE(%SLAK%),NST1,SLONLY,TOSTAR(6,6),BCALC(%SLAK%),
     & DERCEL(6,%SLAK%),DERPOS(3,%SLAK%,2),ITYPSK(%SLAK%),INVBON(%INVB%,
     & %SLAK%),NINVB(%SLAK%),INANG(%SANG%,3),INTOR(%TANG%,6),
     & DERBON(%INVB%),NVB(%INVB%),NUMBON,NTARNM,NUMANG,NUMTOR,KOM25
      LOGICAL SLONLY
-1
      Geometry of slack constraints
 3
      COMMON /SOURCE/NSOURC,JSOURC,KSOURC,NDASOU(%SORC%),METHOD(
     & %PHAS%),NPFSOU(%PHAS%,%SORC%),NSOBS(%SORC%),SCALES(%SORC%),
     & KSCALS(%SORC%),NPCSOU(%PHAS%,%SORC%),LRFSRC(%SORC%,%PHAS%)
-1
      Multi-source information
 1
      COMMON /SPLBCK/SCOEFF(%BACK%,%SORC%)
-1
      Coefficients of splines used for backgrounds
 2
      COMMON /STATP/HLABEL(3),WRK(5,%D*18%),AMEAN(%D*18%),DEV(%D*18%),IPOLN(%D*18%),
     &IPAR(18),ZSUMS(5),NPOLN,MAXP
-6
 	  Holds statistics for averaging polarisation matrix elements
 	  WRK are the WTMEAN working spaces for each matrix element and domain
 	  NPOLN counts the number used, and IPOLN gives the domain and component of each
 	  ZSUMS provides the working space for zero elements
 	  IPAR holds the parameter number of each element,
 	  MAXP is the number of independent parameters
 2
      COMMON /STATS/WRK1(5),WRK2(5),WRK3(5),AMEAN(2),DEV(2),SUMS(12),
     & X,DX,RAT,DRAT
-1
      Holds statisics for a group of equivalent reflections
 2
      COMMON /SYMDA/SYM(3,3,%SYMO%),TRANS(3,%SYMO%),ALAT(3,4),
     & ORIGIN(3),KOM26
-4
     SYM rotation matrice of symmnetry operators
     TRANS translation vectors of symmetry operators
     ALAT non-primitive lattive translations,
     ORIGIN(3) displacement of origin from centre (not yet used)
 4
      COMMON /SYMMAG/MTSYM(%SY+1%),MSTAB(%SY+1%),NMSYM,OTRSYM(3,3,%SY+1%),
     &MTYP,NDOM,FERO,FERA,HELI,AMOD,ANTI,FANI,PARA,MODUL,
     &CPVEC,MAGCEN,KOM20
      LOGICAL FERO,FERA,FANI,HELI,AMOD,ANTI,PARA,MODUL,CPVEC,MAGCEN
-9
      MTSYM time inversion operator for each symmetry element
      MSTAB magnetic symmetry table
      NMSYM number of elements in the magnetic group
      OTRSYM magnetic symmetry operators on orthogonal axes
      MTYP type of magnetic structure
      NDOM number of s domains
      FERO,FERA,HELI,AMOD,ANTI,PARA,MODUL,CPVEC,logicals indicating the
      structure type
      MAGCEN logical true if magnetic structure is centric
 3
      COMMON /SYMREP/REP(9,%SY+1%),AKVEC(3),LREP(%SY+1%),NREP,IVEC,ANORM,
     & NOPS,NOPP,NCSTAR,TREP(%SY+1%,2,2)
      COMPLEX REP,TREP
-1
      Symmetry representations
 2
      COMMON /SYMTAB/MULTAB(%SYMO%,%SYMO%),INVERS(%SYMO%),
     & NORD(%SYMO%),IGENER(3),KOM22
-5
      Symmetry tables for the space group
      MULTAB the multiplication tables
      INVERS tables of inverse elements
      NORDorder of each element
      IGENER(3) list of generating elements
 1
      COMMON /THET2/THE2,KTHE2,THCON1
-1
     Fixed scattering angle data for TOF profile refinement
 2
      COMMON /TITLE/ITITLE
      CHARACTER *80 ITITLE
-1
      ITITLE The title of the CDF
 1
      COMMON /TSYMDA/TSYM(3,3,%SYMO%),TTRANS(3,%SYMO%),TMAT(3,3)
-4
      Symmetry operators transformed to new axes
      TSYM transformed rotation matrice of symmnetry operators
      TRANS transformed translation vectors of symmetry operators
      TMAT matrix of the transformation
 2
      COMMON /TTHMNC/TTHMON(%SORC%),KTHMON(%SORC%),C2TMON(%SORC%),
     & S4TMON(%SORC%),OPCMON(%SORC%),ALPCOR,DLPCOR
-1
      Data for X-ray monochromator
 3
      COMMON /TWIN/TWMAT(3,3,12),TWPOP(12),KTWPOP(12),NTWIN,
     &TORTH(3,3,2),MTWIN,TMUNIT
      LOGICAL MTWIN,TMUNIT
-6
      TWMAT twin matrices
      TWPOP, KTWPOP Twin populations and refinement switch
      NTWIN number of twins
      TORTH(3,3,2) matrix relating the untwinned othogonal exes to
      those of the 1st twin.
      MTWIN logical to indicate "magnetic" twinning
 2
      COMMON /WAVCHR/IFUN(10,5)
      CHARACTER*4 IFUN
-1
      IFUN names of wave-functions
 3
      COMMON /WAVEFN/NQUANT(70,5,5),IREST(70,5,5),AMP(70,5),
     & PAMP(10,5),NEL(5),IX(5),NFUN(10,5),NEIG(5)
      COMPLEX AMP,PAMP
-1
      Data for molecular orbital wave-functions
 3
      COMMON /WHEN/DATIM,MAIN
      CHARACTER *24 DATIM
      CHARACTER *6 MAIN
-3
      Job specific information
      DATIM date and time at which run
      MAIN name of program
 1
      COMMON /WDSPC/IWDNUM,IWDSPC(%WORD%)
-1
      Specifications for IWDNUM CCSL parameter names
 2
      COMMON /WORDS/LSQWD(%WORD%)
      CHARACTER *4 LSQWD
-1
      IWDNUM CCSL parameter names
 1
      COMMON /XENDA/UU(3,3,2),XLIM(3,3),NDIMEN,VOLEL,MSTOP,MODEL,DEFVAL
-6
      Data for MAXENT calculations
      UU orientation matrix of the calculation and its inverse
      XLIM max, min and step multipliers of UU
      NDIMEN 2 or 3 for projection or complete 3d map
      Volume of calculation cell
      MSTOP, MODEL, DEFVAL type of maxent calculation
 1
      COMMON /ZEROPT/ZERO,KZERO
-1
      Zero offset and refinement switch (profile refinement)
DONE
C
C
C
##NEW
C
C
C
C                                N E W
C    R O U T I N E S   F O R   I N D I R E C T   A D D R E S S I N G
C                     O F   S Y M M E T R Y   C O D E
C
C
C
C
C LEVEL 4      SUBROUTINE POLUNI
      SUBROUTINE POLUNI
C
C *** POLUNI by PJB 8 Aug 83 ***
C
CX
CC 1A
CH A specialist routine to "polish" the edges of a found asymmetric unit
CH by specifying exactly how its faces and edges should be treated.
C
CP POLUNI is called from the end of SYMUNI, and would not be useful
CP outside this context.
C
CD Sets the array MARK in /GUNIT/ to indicate the exact treat ment of
CD faces and edges of the reciprocal cell asymmetric unit in order to
CD deduce the multiplicites of reflections occurring on them.
C
      LOGICAL BINDIG
/CONSTA/
/FRIED/
/FUNIT/
/GUNIT/
/IOUNIT/
/NSYM/
      COMMON /TEMP/JUSYM(25)
%      COMMON /SCRAT/AXI(3,%SYMO%,2),MIRROR(%SYMO%),D(3,3),PL1(3),PL2(3),PL3(3),
     & HT(3),ASY(3,4),NSTAT(4),NOPL,NICE,VOL,MOP1,MOP2
/SYMTAB/
C
C  CLEAR MARK TO 1
      DO 10 I=1,3
      DO 10 J=1,2
   10 MARK(I,J)=1
C
C  DEAL WITH P1 AND P-1
      IF ((NOP.EQ.1) .AND. .NOT. FRIEDL) GO TO 100
      IF (NUMSYM(JUSYM,NOPC).GT.1) GO TO 14
C  FIND ANY LINE IN THE PLANE
      CALL INVENT(ASYM(1,1),ASYM(1,1),BSYM(1,1))
      CALL VECPRD(ASYM(1,1),BSYM(1,1),BSYM(1,2))
      MARK(1,1)=4
      GO TO 100
C
C  WORK OVER SYMMETRY ELEMENTS
   14 DO 1 N=2,NOPC
      IF (JUSYM(N) .EQ.0) GO TO 1
      IF (IABS(NORD(N)).GT.100) GO TO 1
      IORD=IABS(NORD(N))
      IF (MIRROR(N).EQ.0) GO TO 2
C
C  PROCEDURE IF MIRROR PLANE,EITHER END OF AXIS WILL DO
      DO 15 IR=1,2
      CALL EQVEC(ASYM,AXI(1,N,1),NASYM,M,0)
      IF (M.GT.NASYM) GO TO 15
C
C  MARK PLANE AS MIRROR
      MARK(M,1)=2
      GO TO 16
   15 CALL GMREV(AXI(1,N,1),AXI(1,N,1),3,1)
C
C  JUMP IF NOT A DIAD AXIS
   16 IF(NORD(N).EQ.-2 .AND. .NOT. FRIEDL ) GO TO 1
C
C  PROCEDURE FOR SYMMETRY AXES
    2 CALL INBOX(AXI(1,N,2),IN)
      IF (IN) 1,3,4
C
C  SYMMETRY AXIS INSIDE UNIT - ERROR\
   3  WRITE (LPT,3000)(AXI(I,N,1),I=1,3),N
      WRITE (ITO,3000)(AXI(I,N,1),I=1,3),N
3000  FORMAT (/' ERROR ** in POLUNI - symmetry axis ',3F5.1,
     & ' inside unit - operator number',I4)
      STOP
C
C  AXIS IS ON UNIT
    4 IF (IN.GT.10) GO TO 5
      IF (IORD.GT.2) GO TO 3
C
C  HERE FOR DIAD AXIS ON A PLANE - NOT AT CORNER
      CALL VECPRD(ASYM(1,IN),AXI(1,N,2),BSYM(1,IN))
      MARK(IN,1)=3
C  DECIDE WHICH EDGE TO INCLUDE
      IF (NASYM .GT. 2) GO TO 8
      MARK(3,2)=-IABS(MARK(3,2))
      GO TO 1
   8  M1=MOD(IN,3)+1
      M2=MOD(M1,3)+1
      M=M1
      L=M2
      IF (SCALPR(BSYM(1,IN),EDGE(1,M)).GT.0.) GO TO 13
      M=M2
      L=M1
C  CHECK MARK NOT ZERO ALREADY
   13 IF (MARK(L,2).NE.0) MARK(M,2)=0
      GO TO 1
C
C  AXIS ON EDGE
    5 IN=IN-10
      IF (NASYM.GT.2) GO TO 11
      IF (IORD.NE.3 .OR..NOT.FRIEDL) GO TO 11
C  SPECIAL BLISTER FOR BAR 3 AXIS
      MARK(IN,2)=-3*IABS(MARK(IN,2))
      RANG=TWOPI/6.
      GO TO 9
   11 MARK(IN,2)=ISIGN(MARK(IN,2)*IORD,NORD(N))
      IF (MARK(IN,2).LT.0 .AND. .NOT. FRIEDL) MARK(IN,2)=MARK(IN,2)/2
      IF (IORD.EQ.2) GO TO 1
      RANG=TWOPI/IORD
      IF (NASYM.EQ.2) GO TO 9
      IF (NORD(N) .LT. 0 .AND. .NOT. FRIEDL) RANG=RANG*2.
   9  IF (ABS(RANG-ANG(IN)).GT..0001) GO TO 1
      M=MOD(IN,3)+1
C  MARK POINTS ON PLANE AND AXIS NOT TO BE USED
      IF (NASYM.LT.3) GO TO 12
C  NO EDGES
C  IS AN EDGE ALREADY MARKED ZERO?
      M1=MOD(M,3)+1
      IF (MARK(M1,2).EQ.0) GO TO 12
C  IF THAT NOT ZERO MARK THE OTHER ONE
      MARK(M,2)=0
      M=M1
   12 MARK(M,1)=0
C
    1 CONTINUE
C
C  PUT IN EXTRA DIVISION IF A MIRROR PLANE GOES THROUGH AN EDGE
      IF (NASYM.LT.2) GO TO 100
C  NO EDGES:
      J=2
      K=3
      DO 7 I=1,3
      IF (MARK(I,1).EQ.2 .OR.MARK(J,1).EQ.2) MARK(K,2)=MARK(K,2)*2
      IF (NASYM.EQ.2) GO TO 100
      J=K
      K=I
    7 CONTINUE
  100 IF (BINDIG(IOUT,16)) THEN
        WRITE (LPT,4000) ((MARK(I,J),I=1,3),J=1,2),BSYM,EDGE
        WRITE (ITO,4000) ((MARK(I,J),I=1,3),J=1,2),BSYM,EDGE
 4000   FORMAT (/' MARK :',3I5,4X,3I5/' BSYM, EDGE :'/3(/3(1X,3F8.2/)))
      ENDIF
      RETURN
      END
C LEVEL 7      SUBROUTINE SYMUNI
      SUBROUTINE SYMUNI
C
C *** SYMUNI updated by PJB 14 Jun 88 ***
C
CX
CC 1A
CH Selects a reciprocal space asymmetric unit fitting the symmetry.
CP SYMOP should have been obeyed, leaving NORD holding the orders of the
CP       symmetry operators, INVERS pointing at their inverse elements,
CP       FRIEDL set and the operators in SYM and TRANS.
CD Sets up in /FUNIT:
CD         NASYM planes bounding an asymmetric unit in ASYM
CD         EDGE to hold edges
CD         ANG to hold angles
CD         NMUL to hold fraction of reciprocal space used
CD By a call of UNITID makes the found unit hold the required typical h,k,l
CD whose default is 13,11,10 (i.e. all positive, h > k > l)
CD
CD By a call of POLUNI fills in /GUNIT with indicators used in finding the
CD multiplicity of a reflection.
CD
CD Builds up tentative unit in COMMON /SCRAT in ASY, communicating with other
CD routines like FIXUNI via /SCRAT.
CD
CD Works from a list of mirror planes in /SCRAT;  a unit may not contain A
CD mirror.  Notes also if point group is cubic, and takes those separately.
CD
CD Uses a list of axes of symmetry elements in AXI in /SCRAT.
CD If not cubic, and mirror planes are not enough to form a unit of the correct
CD size, uses such axes to form the remaining planes.  If there is only 1 axis,
CD takes an arbitrary plane containing it, and symmetry related planes.
CD
CD If there are more than one, the first is "principal" and must either be
CD perpendicular to a unit plane, or contained in it (all planes).  Planes
CD are taken through this axis and those of other elements in turn.
CD
CD Point group are dealt with as follows:
CD
CD Triclinic: 1 and -1 are singled out; -1 is given an arbitrary plane.
CD Cubic: 3 planes are needed, each containing two axes.  If no 4 axis,we have:
CD    either  23 for which we need three 3 axes (distinguished by NMUL=12)
CD    or      m3 for which we need one 3 and two 2's
CD
CD    If a 4 is present, then 4 3 3 will do for 432 and -43m,
CD           but m3m needs 4 3 2 (and is detected by having NMUL=48).
CD
CD Mirrors: use of mirrors as planes will finish:
CD       monoclinic: m
CD       orthorhombic: mm2 and mmm
CD       tetragonal: 4mm and 4/mmm
CD       trigonal 3m
CD       hexagonal: 6mm, -6m2 and 6/mmm
CD
CD Single axis: a number of planes through a single axis will finish:
CD       monoclinic: 2 and 2/m
CD       orthorhombic: no more
CD       tetragonal: 4, -4 and 4/m (which has also 1 mirror)
CD       trigonal: 3 and -3
CD       hexagonal:  6, -6, 6/m (the last two having 1 mirror also)
CD
CD Principal axis: planes through principal axis and a "2" axis finish:
CD       orthorhombic: 222
CD       tetragonal: 422 and -42m (which has 1 mirror also)
CD       trigonal: 32
CD       hexagonal: 622
CD
CD This leaves -3m, which belongs to the "principal axis" category above, but
CD because we have removed the centrosymmetrically related operators has no
CD explicit "2" axes left.  There are two ways of dealing with this - a plane
CD perpendicular to the principal axis, or a halving of the angle between
CD existing planes.  For the moment the former is taken.
CD
CO If the procedure outlined above does not produce a sensible outcome, writes
CO error mesages and stops.
C
CN This highlights a general point.  For most point groups it is evident how
CN many planes must be used to slice space into suitable units, but for a
CN subset of them (422, -42m, -3, 32, -3m, 622 : for laymen, those which:
CN          are non-cubic
CN          have at least 6 spots
CN          have both black and white spots
CN          but not superimposed
CN the space may be carved into two different sets of units, one with 3 faces
CN and one with 2.  The above methods will generally give preference to 2,
CN except in the case of -3m as described.
CN
CN The user may not get exactly the unit he wants for this reason.  He is
CN allowed to specify typical indices of a reflection to be inside the finished
CN unit, but this will not influence the carving in the cases mentioned.  I
CN have in mind to allow him also to offer a plane, so that, e.g., in
CN 422 if he offers the equator plane, he will get the broader wedge of space
CN cut off by that plane, instead of the narrower wedge "infinite" in both
CN directions.
C
      DIMENSION XAX(3),ZAX(3)
/FRIED/
/FUNIT/
/IOUNIT/
/NSYM/
      COMMON /TEMP/JUSYM(25)
%      COMMON /SCRAT/AXI(3,%SYMO%,2),MIRROR(%SYMO%),D(3,3),PL1(3),PL2(3),PL3(3),
     & HT(3),ASY(3,4),NSTAT(4),NOPL,NICE,VOL,MOP1,MOP2
/SYMDA/
/SYMTAB/
      DATA XAX,ZAX/1.0,0.,0.,0.,0.,1./
C
C READ IN POSSIBLE U CARD GIVING 3 TYPICAL INDICES REQUIRED BY USER TO
C BE WITHIN THE FINISHED ASYMMETRIC UNIT.  IF NO U CARD USE 13,11,10:
      CALL INPUTU(HT)
C
C CLEAR SPACE FOR FIXUNI TO BUILD UP NOPL PLANES IN ASY WITH STATUS NSTAT:
      NOPL=0
      CALL GMZER(ASY(1,1),3,4)
      CALL JGMZER(NSTAT,1,4)
C
C NMUL=FRACTION OF UNIT INVOLVED AND MUST TAKE ACCOUNT OF FRIEDEL:
      NMUL=NOP
      NUSED=NUMSYM(JUSYM,NOPC)
      IF (FRIEDL) NMUL=NUSED*2
C
C JUMP IF POINT GROUP 1, NO PLANES AT ALL REQUIRED:
      IF (NMUL.EQ.1) GO TO 102
C JUMP IF NOT POINT GROUP -1:
      IF (NUSED .GT. 1) GO TO 2
C SPECIAL FOR P-1 OR P1 WITH FRIEDEL - PUT IN 0 0 1 AND ACCEPT:
      CALL FIXUNI(ZAX,1)
      GO TO 102
C
C HERE FOR MONOCLINIC ONWARDS:
C SET UP AXES OF SYMMETRY ELEMENTS, AND MARK MIRROR PLANES IF THEY EXIST:
C NOTE LASTAX=NO. OF LAST ELEMENT OF LIST (IRRELEVANT ELEMENTS ARE ALREADY 0)
C NP2 = FIRST "2", NP3 = FIRST "3" (THERE ARE NO -3) AND NP4 = FIRST "4"
C AND COUNT "3" AXES IN N3, BEAUSE CUBIC HAS 4 OF THESE AND NOTHING ELSE HAS >1
C ALSO, NPP2 IS SET TO POINT TO THE FIRST +2 (NOT -2) FOR THE SPECIAL CASE -3M.
C
   2  LASTAX=0
      N3=0
      NP2=0
      NPP2=0
      NP3=0
      NP4=0
      DO 3 N=2,NOPC
      IF (JUSYM(N).EQ.0) GO TO 3
      MIRROR(N)=0
      IF (IABS(NORD(N)).GT.100) THEN
        CALL GMZER(AXI(1,N,1),3,1)
        CALL GMZER(AXI(1,N,2),3,1)
        GO TO 3
      ENDIF
C  GET THE AXIS IN REAL SPACE
      CALL AXIS(SYM(1,1,N),AXI(1,N,1))
C  GET THE AXIS IN RECIPROCAL COORDINATES
      CALL GMEQ(SYM(1,1,INVERS(N)),D,3,3)
      CALL TRANSQ(D,3)
      CALL AXIS(D,AXI(1,N,2))
C
C PICK OUT USEFUL AXES:
      LASTAX=N
      IF (NORD(N) .EQ. 2) NPP2=N
      I=IABS(NORD(N))
      IF (I .EQ. 3) N3=N3+1
      IF (I .EQ. 2 .AND. NP2 .EQ. 0) NP2=N
      IF (I .EQ. 3 .AND. NP3 .EQ. 0) NP3=N
      IF (I .EQ. 4 .AND. NP4 .EQ. 0) NP4=N
C
C MARK MIRRORS:
      IF (NORD(N).EQ.-6 .OR. NORD(N).EQ.-2) GO TO 4
      IF (.NOT.FRIEDL) GO TO 3
      IF (NORD(N).EQ.3) GO TO 3
   4  MIRROR(N)=1
   3  CONTINUE
C
C IF PRINCIPAL AXIS IS A "2" MOVE NP2 PAST IT:
      IF (NP2 .EQ. 2) NP2=3
C
C JUMP IF NOT CUBIC:
      IF (N3 .NE. 4) GO TO 5
C JUMP IF NO "4" AXIS:
      IF (NP4 .EQ. 0) GO TO 6
C
C PICK PLANE THROUGH 4 AND ANY 3:
      CALL VECPRD(AXI(1,NP4,2),AXI(1,NP3,2),PL1)
C AND INSIST ON KEEPING IT:
      CALL FIXUNI(PL1,2)
C NOW DISTINGUISH BETWEEN M3M AND THE REST;  4 3 3 FOR M3M IS NOT SMALL ENOUGH:
      NSTART=NP3+1
      NS=3
      IF (NMUL .LT. 48) GO TO 19
      NSTART=NP2
      NS=2
C SCAN REMAINING OPERATORS LOOKING ONLY AT SUITABLE AXES:
  19  DO 7 J=NSTART,LASTAX
      IF (JUSYM(J).EQ.0) GO TO 7
      IF (IABS(NORD(J)) .NE. NS) GO TO 7
C MAKE 2 MORE PLANES, EACH THROUGH NEW AXIS AND ONE OF ORIGINAL:
      CALL VECPRD(AXI(1,J,2),AXI(1,NP4,2),PL1)
      CALL VECPRD(AXI(1,NP3,2),AXI(1,J,2),PL2)
      CALL FIXUNI(PL1,1)
      CALL FIXUNI(PL2,1)
      IF (NICE) 8,102,8
C IF NICE IS EVER 0 WE ARE HOME - OTHERWISE TAKE NEXT 3RD AXIS:
   8  CALL FIXUNI(PL1,-2)
      CALL FIXUNI(PL2,-3)
   7  CONTINUE
C
C  SHOULD NOT GET HERE:
      GO TO 11
C
C CUBIC WITH NO 4 AXIS - IS IT 23 OR 3M?:
   6  IF (NMUL .NE. 12) GO TO 20
C 23 - UNIT MUST HAVE THREE 3 AXES AS EDGES, ANY ANY 3 SHOULD DO:
      I=NP3
      J=I
  21  J=J+1
      IF (J .GT. LASTAX) GO TO 11
      IF (NORD(J) .NE. 3) GO TO 21
      K=J
  22  K=K+1
      IF (K .GT. LASTAX) GO TO 11
      IF (NORD(K) .NE. 3) GO TO 22
      CALL PLN3AD(I,J,K)
      IF (NICE) 11,102,11
C
C M3 - WANT ONE 3 AXIS AND TWO 2S:
  20  DO 9 J=NP2,LASTAX
      IF (JUSYM(J).EQ.0) GO TO 9
C PICK OUT PAIRS OF 2 AXES TO PUT WITH 3:
      IF (NORD(J) .NE. 2) GO TO 9
      IF (J .EQ. LASTAX) GO TO 11
      J1=J+1
      DO 39 K=J1,LASTAX
      IF (JUSYM(K).EQ.0) GO TO 39
      IF (NORD(K) .NE. 2) GO TO 39
      CALL PLN3AD(NP3,J,K)
      IF (NICE) 10,102,10
C
C IF DO NOT MAKE GOOD CELL, TAKE ALL 3 OUT AGAIN:
  10  CALL FIXUNI(PL1,-1)
      CALL FIXUNI(PL2,-2)
      CALL FIXUNI(PL3,-3)
  39  CONTINUE
   9  CONTINUE
C
C SHOULD HAVE MADE GOOD UNIT BY NOW:
  11  WRITE (LPT,3000)NP2,NP3,NP4
      WRITE (ITO,3000)NP2,NP3,NP4
3000  FORMAT (/' *** PROGRAM ERROR in SYMUNI - all cubic axes scanned',
     & ' - NP2, NP3, NP4=',3I3)
      STOP
C
C NEITHER TRICLINIC NOR CUBIC - TRY ALL MIRRORS:
   5  DO 12 N=2,LASTAX
      IF (JUSYM(N).EQ.0) GO TO 12
      IF (MIRROR(N).EQ.0) GO TO 12
      CALL FIXUNI(AXI(1,N,1),1)
      IF (NICE) 12,102,12
   12 CONTINUE
C
C MIRRORS INADEQUATE - PICK OUT THOSE WITH ONLY 1 SYMMETRY ELEMENT (OTHER THAN
C THE UNIT, A CENTRE, OR THOSE GENERATED FROM THE ONE):
      IF (LASTAX .NE. 2) GO TO 13
C THIS ASSUMES THAT SUCH AN AXIS IS ELEMENT 2 - SO LONG AS WE HAVE COME IN VIA
C SYMOP, SYMGEN IT WILL BE:
C
C TAKE PLANE THROUGH AXIS AND X AXIS (OR Z AXIS):
  18  CALL VECPRD(AXI(1,2,2),XAX,PL1)
      IF (VCTMOD(1.0,PL1,1).LT.0.0001) CALL VECPRD(AXI(1,2,2),ZAX,PL1)
C MAKE THIS FIRST PLANE MANDATORY:
      CALL FIXUNI(PL1,2)
      IF (NICE) 15,102,15
C NEED ANOTHER PLANE - SWING IT:
  15  DO 14 I=2,NOPC
      IF (JUSYM(I).EQ.0) GO TO 14
      CALL ROTSYM(PL1,PL2,I,1)
      CALL FIXUNI(PL2,1)
      IF (NICE) 14,102,14
  14  CONTINUE
C
C SHOULD BE ENOUGH:
      CALL ERRMES(-1,0,'in SYMUNI - single axis not enough')
C
C HAVE PRINCIPAL AXES PLUS OTHERS - ARE THERE ANY 2'S?
  13  IF (NPP2 .EQ. 0) GO TO 16
C MAKE PLANES THROUGH PRINCIPAL AND A 2 AND OFFER IN TURN:
      DO 17 J=NP2,LASTAX
      IF (JUSYM(J).EQ.0) GO TO 17
      IF (NORD(J) .NE. 2) GO TO 17
      CALL VECPRD(AXI(1,2,2),AXI(1,J,2),PL1)
      CALL FIXUNI(PL1,1)
      IF (NICE) 17,102,17
  17  CONTINUE
C
C THIS CONTINUAL OFFERING DOES NOT REMOVE THE PLANES IT DOES NOT LIKE, AND
C MAY CAUSE TROUBLE.
C
C SHOULD HAVE BEEN ENOUGH - IF NOT ONLY CASE  SHOULD BE CENTRE NOT AT ORIGIN:
      IF (.NOT. CENTRC) GO TO 18
      CALL ERRMES(-1,0,
     & 'in SYMUNI - principal axis plus 2 axes not enough')
C
C WE SHOULD BE AT -3M HERE, WITH 2 MIRRORS, BUT UNIT TOO BIG.  HALVE IT:
  16  CALL FIXUNI(AXI(1,2,1),1)
      IF (NICE .NE. 0) CALL ERRMES(-1,0,'reached end of SYMUNI')
C
C SUCCESSFUL UNIT - TIDY IT AND TRANSFORM TO HOLD TYPICAL REFLECTION:
 102  CALL UNITID
C
C FINAL UNIT - MARK EDGES FOR MULTIPLICITY:
      CALL POLUNI
C
      RETURN
      END
C LEVEL 4      SUBROUTINE TRYUNI(NCHK)
      SUBROUTINE TRYUNI(NCHK)
C
C *** TRYUNI by JCM 25 Sep 84 ***
C
CX
CC 1A
CH A specialist routine used in the setting up of the asymmetric unit, to
CH try out a given set of planes as faces of the unit.
CA On entry NCHK non-zero indicates that a check on the given representative
CA indices HT (see below) is to be performed whatever the given unit
CA is like.
C
CP The scratch COMMON /SCRAT/ is set up as follows:
CP A tentative asymmetric unit is held as NOPL planes in the array ASY,
CP the dimension of 4 allowing for "dead" planes in case we need to
CP revive them.
C
CP The status of each plane is in NSTAT:
CP       0=not there
CP       1=possible
CP       2=mandatory
C
CP HT is a 1x3 array holding the indices of a typical reflection which
CP must occur within (that is, not on the faces or the edges of) the
CP finished asymmetric unit.
C
C
CD TRYUNI does not necessarily produce the correct unit, but it checks
CD that any unit it sends out has 1 and only 1 relative of HT in it.
C
CD A unit which is too small, or which fails the above test, is
CD flagged on exit by NICE=-1.
CD An acceptable unit is falgged by NICE=1.
C
CD NOPL is expected to be 1, 2 or 3.  Copies NOPL planes out of the
CD temporary array ASY to the (eventually) permanent array ASYM in
CD /FUNIT/.
C
CD If there is more than 1 plane, the edge(s) and angle(s) involved are
CD set up, together with AMUL = the proportion of reciprocal space
CD occupied by the given unit.
CD
CD We then have VOL=AMUL*NMUL, and aim at VOL=1.
CD
CD If there are 3 planes forming a hinge, sets VOL=0., and NICE=1, and
CD leaves the configuration for the calling routine (FIXUNI) to deal with.
CD
CD If VOL=1., checks that the unit contains 1 and only 1 relative of
CD the representative indices in HT.
CD
CD If NCHK is non-zero does this check in any case, counting the number
CD of relatives both inside and outside.  This caould be useful if the
CD user is ever allowe to specify his own unit.
C
      DIMENSION NNSTAT(3)
/CONSTA/
/FRIED/
/FUNIT/
/IOUNIT/
/NSYM/
      COMMON /TEMP/JUSYM(25)
%      COMMON /SCRAT/AXI(3,%SYMO%,2),MIRROR(%SYMO%),D(3,3),PL1(3),PL2(3),PL3(3),
     & HT(3),ASY(3,4),NSTAT(4),NOPL,NICE,VOL,MOP1,MOP2
C
      NASYM=NOPL
      IF (NASYM .LE. 0 .OR. NASYM .GE. 4)
     & CALL ERRIN2(NASYM,0,'in PROGRAM using TRYUNI with NOPL=',' ')
C
   1  I=1
      DO 2 J=1,NASYM
   3  IF (NSTAT(I) .NE. 0) GO TO 4
      I=I+1
      IF (I .LT. 5) GO TO 3
      CALL ERRMES(-1,0,'TRYUNI not given enough planes')
C
   4  CALL GMEQ(ASY(1,I),ASYM(1,J),1,3)
      NNSTAT(I)=NSTAT(J)
      I=I+1
   2  CONTINUE
C
C SET UP PI/3 FOR DETECTION OF ANGLE, NICE INITIALISED TO 'TOO BIG', AND
C CLEAR INDICATOR THAT WE HAVE PI/3 OR 2PI/3 ANGLE:
      PIBY3=PI/3.
      NICE=1
      N3AX=0
C BRANCH ON 1, 2 OR 3 PLANES:
   25  GO TO (7,8,9) , NASYM
C
C SINGLE PLANE - HALF SPACE:
   7  AMUL=0.5
      GO TO 10
C
C TWO PLANES - MAY FIRST NEED TO REVERSE ONE FOR SMALLER ANGLE:
   8  ANG(3)=ANGRAD(ASYM(1,1),ASYM(1,2),1)
      IF (ABS(ANG(3)-PIBY3) .LT. 0.0001) N3AX=3
      IF (ABS(ANG(3)-2.*PIBY3) .LT. 0.0001) N3AX=3
C DO NOT TRY TO REVERSE IF STATUS 3:
      IF (NNSTAT(1) .EQ. 3 .AND. NNSTAT(2) .EQ. 3) GO TO 11
      IF ((NICE .NE. -1) .AND. (ANG(3) .LE. PIBY2)) GO TO 11
      IF ((NICE .EQ. -1) .AND. (ANG(3) .GE. PIBY2)) GO TO 11
C ANGLE MUST BE ACUTE BETWEEN PLANES EXCEPT FOR CERTAIN CASES WHERE
C 2PI/3 NOT PI/3 IS WANTED
      NREV=2
      IF (NNSTAT(2) .EQ. 3) NREV=1
      CALL GMREV(ASYM(1,NREV),ASYM(1,NREV),1,3)
      ANG(3)=PI-ANG(3)
  11  AMUL=ANG(3)/TWOPI
      CALL VECPRD(ASYM(1,1),ASYM(1,2),EDGE(1,3))
C TAKE OUT ANY COMMON FACTOR:
      CALL FCTOR(EDGE(1,3),N)
      GO TO 10
C
C THREE PLANES - MAKE ANGLES SMALLER AS ABOVE, MAKE EDGES AND ANGLES:
   9  SUM=-PI
      NFLIP=0
      J2=2
      J3=3
      DO 12 J=1,3
      ANG(J)=ANGRAD(ASYM(1,J2),ASYM(1,J3),1)
      IF (ABS(ANG(J)-PIBY3) .LT. 0.0001) N3AX=J
      IF (ABS(ANG(J)-2.*PIBY3) .LT. 0.0001) N3AX=J
C DO NOT TEST 3RD ANGLE AS WE CANNOT COPE IF IT IS TOO BIG:
      IF (NFLIP .GT. 1) GO TO 13
      IF (NNSTAT(J2) .EQ. 3 .AND. NNSTAT(J3) .EQ. 3) GO TO 13
      IF ((NICE .NE. -1) .AND. (ANG(J) .LE. PIBY2)) GO TO 13
      IF ((NICE .EQ. -1) .AND. (ANG(J) .GE. PIBY2)) GO TO 13
      NREV=J3
      IF (NNSTAT(J3) .EQ.3 ) NREV=J2
      CALL GMREV(ASYM(1,NREV),ASYM(1,NREV),1,3)
C CHOOSE PLANE TO REVERSE IF NECESSARY
      ANG(J)=PI-ANG(J)
      NFLIP=NFLIP+1
  13  SUM=SUM+ANG(J)
C
C MAKE EDGE, POINTING SAME WAY AS OPPOSITE PLANE:
      CALL VECPRD(ASYM(1,J2),ASYM(1,J3),EDGE(1,J))
      IF (SCALPR(EDGE(1,J),ASYM(1,J)) .LT.0.) CALL GMREV(EDGE(1,J),
     & EDGE(1,J),1,3)
      CALL FCTOR(EDGE(1,J),N)
      J2=J3
      J3=J
  12  CONTINUE
      AMUL=SUM/FOURPI
C
C DETECT HINGE - 3 PLANES, BUT WITH A COMMON EDGE:
      CALL EQVEC(EDGE(1,1),EDGE(1,3),2,M,0)
      IF (M .GE.3) GO TO 10
C MARK HINGE TO BE DEALT WITH OUTSIDE:
      VOL=0.
      GO TO 100
C
C JOIN - WE HAVE A UNIT WITH 1, 2 OR 3 PLANES (NOT HINGE), AND WHERE RELEVANT
C EDGES AND ANGLES HAVE BEEN STORED;  MUL=FRACTION OCCUPIED:
  10  VOL=AMUL*FLOAT(NMUL)
C IF VOL IS 1 WE HAVE A UNIT OF THE RIGHT SIZE:
      IF (ABS(VOL-1.) .LT. 0.00001) NICE=0
C IF VOL IS TOO SMALL WE MAY HAVE TO REMOVE A PLANE, OR WE MAY HAVE TO STOP
C REDUCING THE ANGLE BETWEEN TWO PLANES TO PI/3 AND LEAVE IT AT 2PI/3:
      IF (VOL .LT. 0.9998) NICE=-1
      IF (NICE .EQ. -1 .AND. N3AX .NE. 0) GO TO 25
C THIS MAY LOOP, BUT THE SECOND TIME WE LOOK AT SUCH A UNIT IT SHOULD BE OK.
      IF (NCHK .EQ. 0 .AND. NICE .NE. 0) GO TO 100
C
C IF VOLUME OK, OR IF ASKED TO CHECK ANYWAY, COUNT RELATIVES OF TYPICAL REFLN:
      MOP1=0
      IC=1
      IF (FRIEDL) IC=2
C IF FRIEDEL, SCAN -HT AS WELL AS HT:
      CALL GMREV(HT,PL2,3,1)
      DO 18 NC=1,IC
      CALL GMREV(PL2,PL2,3,1)
C SCAN ALL SYMMETRY OPERATORS STORED:
      DO 18 N1=1,NOPC
      IF (JUSYM(N1).EQ. 0) GO TO 18
      CALL ROTSYM(PL2,PL1,N1,2)
      CALL INBOX(PL1,IN)
C TEST RELATIVE FOR BEING IN GIVEN BOX - "ON" AS AN ANSWER IS AN ERROR:
      IF (IN .LE. 0) GO TO 19
      WRITE (LPT,3002) HT
      WRITE (ITO,3002) HT
3002  FORMAT (/' *** ERROR - Typical reflection',3F5.0,' not general')
      STOP
C
  19  IF (IN .LT. 0) GO TO 18
C MOP1=NUMBER OF RELATIVES INSIDE BOX:
C MOP2 WILL HOLD "WHICH OPERATOR PUTS HT INTO BOX", -VELY IF BY A CENTRE ALSO:
      MOP1=MOP1+1
      MOP2=N1*(3-2*NC)
  18  CONTINUE
C
C MOP1=0 MEANS WRONG BOX:
      IF (MOP1 .EQ. 0) NICE=-1
 100  RETURN
      END
C
C
C
C
C LEVEL 1      FUNCTION NUMSYM(ITAB,NUM)
      FUNCTION NUMSYM(ITAB,NUM)
C
C *** NUMSYM by JCM 8 Nov 91 ***
C
CH Counts symmetry elements in current use
CA On entry integer array ITAB holds 1 for used, 0 for not
C
      DIMENSION ITAB(NUM)
      N=0
      DO 1 I=1,NUM
      N=N+ITAB(I)
   1  CONTINUE
      NUMSYM=N
      RETURN
      END
##ENDNEW
PRUPDT
C 90.88 Fix apshpr for reindexing magnetic peaks in multiphase fits.
C 90.87 see 90.81  SPHELI - Should be JPHASE,JSOURC instead of 1,1 in KPAK
C       STUPID JON!!! Should be JPHASE,1 - always src 1. Day wasted :(
C 90.86 Allow inrfpr to write lists of reflections up to 99999 (I5)
C 90.85 Insert val file printing
        add routine summar.f to pr section
        adjust.f call parnam and passes names and details to summar.f (pr)
        iicd2 altered to recognise word PVAL on I card
C 90.84 Inserted PFTF06, FDTF06 and adjusted pfall, pfxx accordingly.
C 90.83 INRFPR - Fix for magnetic space group absences,use magabs instead of ispabs
C 90.82 PRODD - scan through phases setting up spherical polars
C ... various in inobpr to do with gsas data.
C 90.81 SPHELI - Should be JPHASE,JSOURC instead of 1,1 in KPAK
C 90.80 Add PICN05 - interpolation routine for pfcn05 - hopefully for speed.
C 90.79 VARMAK Make universal default to fix variables in LSQ
C 90.78 ANGLST fix mismathcing subroutine args. Looks like they've been moved to a common
C 90.77 CONTRI etc to add JHIST marking the source on the scratch data file
C 90.76 PFCN05 added. Not for general use, double lorentzian for JPW Fe3O4 ESRF data.
C 90.75 PCTF01 - get working for multiphase/multisource by having peak centre
        identical for all phases.
C 90.74 Add PFCN04 - CW neutron/x-ray peak shape. Uses "profval" from Larry Finger
C       to get an asymetry corrected pseudo voigt peakshape. Parameterised as a full
C       voigt using the thompson cox and hastings formulae.
C 90.73 Add FDCN04 to figure out function descriptors and derivativeds for PFCN04.
C 90.72 PRODD - Just write time per cycle to lis file
C 90.71 PFXX - Add entry for pfcn05 - for JPW Fe3O4 peakshape (sorry) sum of two
        lorentzians, based on PROFVAL, with asymetry correction
C 90.70 CALPRD - Add common /speed/ to facilitate long tails on intense reflections
C       and short tails on weaker ones.
C ***** Following updates to make the first release version of PRODD
C 90.69 Alter formatting on writing out scal card
C 90.68 Add entry N=2 to PFALL for check on reading in pkfn specifiers
C 90.67 In CALPRD - Sort out Lorentz corrections (JBF) and AICALC
C 90.66 In prodd - add jhist as for inobpr, try to fix stats (needs further work)
C 90.65 Have matinv write out phase and source of vars with zero diagonal elements
C 90.64 Fix zeropr to read same zero for all phases.
C 90.63 Save STHMXX in INRFPR, as it gets altered somewhere therein.
C 90.62 INOBPR read in m/phase, m/sourc data correctly.
C 90.61 Fixes in CALPRD, trying to keep all derivatives, (90.57 ct'd), f4par stuff too.
C 90.60 Get pctf01 to read in peak centres for all phases. Presumably needed in pccn etc
C ***** Happy New Year. Appears to all still work in Y2K
C 90.59 Add a timing routine to PRODD. This may turn out to be DEC specific
C 90.58 Try to fix the excluded region bug in GOF. If YCALC is zero the point is out
       of the statistics.
C 90.57 Try to fix CALPRD by clearing out DERIVA when sources are flipped. A problem still
     appears to remain with copying the right contents of DERIVA into DERIVV?
C 90.56 Fix ABCRPR for multisource by flipping J to KSOURC for reading L ABSC cards.
C 90.58 Changes - some(?) becoming prodd specific:
        INRFPR - stop overwriting dstamxx(jsourc) for magnetic phases by saving it and
               restoring it at the end of the routine. Need to test with many phase/source.
        INOBPR - Read GSAS data as OTYP 5
        CALPRD - Make obs and calc instensity P2 as opposed to P1*P2*P3*P4. First step to
               doing Lebail fits
        GOF    - Write out a file of the derivatives at each point.
        FAM4PR - Trying to get lebail fits going with PRECYC set and also stop magnetite
               blowing up when doing a Pawley fit.
        APSHPR - Add /CELPAR/ and alter to call matcel directly. Trying to get cell esd's right.
        IICD2  - Add PDER as keyword for printing a file of derivatives from I card
        INPLP0 - Allow OTYP 5.
        DFLTPR - Default is to fix all parameters in LSQ. If you want it varied have to say so.
        INPUTA - Read esd as 0 for site if absent.
        CELNEW - Pick up chi^2 factor from refinement and let MATCEL be called from APSHPR
        RECELL - Fix esd's for chi^2
        MATCEL - The error in getting the covariance matrix was here!
        ANGERS & ANGLST fixed to get bonds to compile. Wrong args in call.
        ISPABS - Fixed error in update 90.56 (typo 0.1 -> 0.01)
        PRODD  - Working on the lebail fits. Set precyc appropriately.
C 90.57 Avoid a zero vars refined array overstep in mattos
C 90.56 Try to get space group exclusion working for k=(000) in inrfpr.
C 90.55 Add a save statement to GOF, still believe there is a first versus latter
 cycles bug in here somewhere.
C 90.54 Apply extinction correction to CN as well as TOF data. Appears to work OK?
C 90.53 Get contri to check there aren't too many reflections on a data point
C 90.52 Add refinable linear interpolated background with IBACK=5
C 90.51 Make LATABS use the F77 nint rather than JFIX. Ought to be equivalent.
C 90.50 Oddity in ISPABS. Introduced a series of temporaries which avoid
 a k=(000) bug for DVF.
C 90.49 Add external range to magcon and domag
C 90.48 Fix bug in CALPRD - For TOF need d^4*sin(theta), not just d^4.
C 90.47 Make GOF write to ITO instead of ITI
C 90.46 Started with DVF6.0B3 in Cambridge - add external p{c/f}cxx to calpr,calprm,apshpr
C 90.45 Lsscal to write error for multiple scale cards
C 90.44 Backpr to write out bigger numbers
C 90.43 Alter PRODD to get logsou right for FORMFA
C 90.42 SETFOR altered to pick up *S on F cards. Will need to be further
  altered to recognise a lack of *S one day. Or get FORMFA to intelligently
  use the information in /SOURCE/
C 90.41 INPUTF: set ksourc when reading labels on F cards
C 90.40 In PFCN01 check fwhm is not negative to avoid div0
C 90.39 In GOF tidy printing
C 90.38 NWINPR Add a phase write so as to preserve shifts, I think
 apshpr should cover this from it's own end too. Also alter so that F cards
 are just given back unaltered. i.e. preserve or not *Sn.
C 90.37 In logsou call swapfc to read in form factors
C 90.36 Insert routine SWAPFC for swapping form factors
C 90.35 APSHPR no longer arbitrarily writes out to nphase but to jphase and
  also reloads phase 1 source 1 when it's done.
C 90.34 In inrfpr change: IF (LX) FAC=FAC*(1.+COS(DEG*ARGK)**2) to
  IF (LX) FAC=ALPCOR*V(2)*V(2) which is from calpr. No idea what or why(!)
C 90.33 Some hit and miss re-organising in VARSAL - needs a proper look
C 90.32 Alter CONTRI to set KMIN for each source appropriately
C 90.31 Alter CALPRD to check for zero scale factor
C ***** 6-10-99 90.31 to : Freeze snapshot for compilation and testing
C
C 90.30 Changed my mind in SETPR a third time!! Need to specify problem
C       for all sources
C 90.29 Remove RFACPR from PRODD and replace with GOF which is in PR
C 90.28 Add subroutine CALPRD which replaces CALPRM and CALPR for PRODD
C 90.27 In INRFPR write which source reflections belong to.
C 90.26 Alter SETPR so as not to read phases for each source. Will have to
C     attend to scattering factors later.
C 90.25 Temporary fix to PFALL to include source printing with peak
C descriptors
C 90.24 Alter PHCINI so it doesn't die on VAX and PC, by
C     copying common block variable into a local before
C     using it
C 90.23 Fix inrfpr for multisource with same pkcn
C 90.22 Disable flipping of KSOURC in PARRD from TBLFND.
C 90.21 Further to 90.17 - family 3 genus 1,2 but not others..
C 90.20 SETPR. Restore JSOURC for looping after call stlsp0/stlspr.
C 90.19 Make apshpr print out source for family 3 and 6 vars.
C 90.18 Undid 90.11, it was wrong!
C 90.17 Alter PRIWRD to find family 3 words in multisource
C 90.16 Make LRFSRC (/SOURC/) be phase dependant
C 90.15 Fixed bug in calprm. Now magnetic peaks correct whether refined or not
C 90.14 Make logsou set correct sinth for a source
C 90.13 More on reflection generation. CONTRI, INRFPR
C 90.12 Fix FETSHF so as not to crash when nothing refined
C 90.11 See 90.18 Make PARSPR SOURC safe. Call for each JSOURC from PRODD
C 90.10 IN ZEROPR; READ zero's to KSOURC, rather that JSOURC
C 90.09 In SETPR; Set up all sourc pkfn before reading more cards etc
C 90.08 In NWINPR and PFALL, SET JSOURC=KSOURC for writing out new cards.
       Relying on clusters of cards following L PK{CF}N *Sn to identify SOURC
C 90.07 In BACKIN, BACKPR and COMMON /GRDBCK/ alter NBK to NBK(%SORC%)
       and alter ILREAD to ILREA for SORC applications
C 90.06 In INRFPR, sort reflections by d instead of TOF/theta
C 90.05 In INPLP0, set cards read per sourc to avoid errors
C 90.04 In INOBPR, extra flipping of units to deal with sourc
C 90.03 LSSCAL - Read nsourc scales instead on %SORC%
C 90.02 STLSP0 - uncomment loop over sources and comment out a scale
        card check.
C 90.01 PFALL - alter to recognise *Sn *Pn and read ksourc and
        kphase using different call to RDWORD (wants further work)
C 90.00 Prodd started
C 89.16 July 12 1996 fix to sort out simul with no step in inobpr
C 89.15 Added PIGLET for SUTEKH machine at RAL to PIG.
C 89.14 Alterations to sixty2 and apshpr for multiphase/mag use.
C 89.13 Minor alterations due to G77/PC compiler.
          Logical LATABS declared in
          CS PC lines added (still need most of CS UNIX)
          Variable G77NAM added for printing main program name
C 89.12 Various fixes to sixty2, 1) nwinpr needs to be magnetic specific
          2) Need to save phase info after calling parspr
          3) New subroutine varsal for forming mag/non mag vars.
C 88.11 In lmagpr added a line for pr on magnetic and atomic pars
C 88.10 In Inrfpr added statements to allow minimum
magnetic d-spacings
        for tf112m etc.
C 88.09 In VECOUP = SQRT(FLOAT(2*J+1).. was changed to SQRT((2.*J+1.) as
        J is declared as real.
C 88.08 The one occurence of CS-PICKY (in nopfil) replaced with CS LAX
C 88.07 Removed multiple declaration of IATS and IOP. Used those in /BANERR/
C 88.06      SAVE SMYOB,SWYOBS added in RFACPR. From KS diff.
C 88.05 IF(ISMAG(KNOW).EQ.O) to .EQ.0) in pftf12. From KS diff.
C 88.04 JNINT to NINT in pftf04. From KS diff
C 88.03 JNINT to NINT in pfcn03. From KS diff
C 88.02 ISPABS(1,KNOW) to ISPABS(REFH(1,KNOW) in INRFPR,  also fixed
        formats from X to 1X. From KS diff.
C 88.01 CELLTR(I,N) to CELLTR(I,L) in GEOMCO from KS diff.
C 88.00 JPW/JBF alterations. In each case the original code should be
    preserved with a C nn.nn prefix and then the new put in.

##PR
C *** Version from JPW and JBF 21-Mar-2001  ***
C
C
C                      P R O F I L E   R E F I N E M E N T
C
C
C LEVEL 8      SUBROUTINE ABCRPR(N)
        SUBROUTINE ABCRPR(N)
C
C *** ABCRPR updated by WIFD 22 Feb 89 ***
C
C 90.56 Fix ABCRPR for multisource by flipping J to KSOURC for reading L ABSC cards.
C
CH Multiple entry routine to deal with all aspects of absorption correction
CH for Profile Refinement
CA On entry N gives action required:
CA    N=1 interpret L ABSC card
CA    N=2 calculate absorption correction and its parameter's derivative
CA    N=3 apply shift to parameter
CA    N=4 write out new L ABSC card
CA    N=5 deal with absence of L ABSC card
CA    N=6 fix parameter if no card given
C
/BRAGG/
/DGEOM/
/IOUNIT/
/NEWOLD/
/PHASE/
/PRABSC/
/REFINE/
/REFIPR/
/SOURCE/
C
      GO TO (1,2,3,4,5,6) , N
      GO TO 100
C
C HAVE IN COMM0N /SCRACH/ A CARD STARTING 'L ABSC' - READ REST:
   1  CALL RDINTG(NABTYP(KSOURC),7,IPT,80,IER)
      IF (NABTYP(KSOURC) .EQ. 0) THEN
        CALL MESS(LPT,0,'No absorption correction')
        GO TO 50
      ENDIF
      CALL RDNUMS(ABSPR(1,KSOURC),IPT,2,NABSPR(KSOURC),IER)
      WRITE (LPT,2000) (ABSPR(II,KSOURC),II=1,NABSPR(KSOURC))
2000  FORMAT (/' Absorption coefficient(s)=',2F12.4)
      IF (ABS(ABSPR(1,KSOURC))+ABS(ABSPR(2,KSOURC)) .EQ. 0.) GO TO 10
      GO TO 100
C
C CALCULATE FUNCTION WHICH WILL BE P4 IN CALxx, AND ITS DERIVATIVE
   2  IF (NABTYP(JSOURC) .EQ. 0) GO TO 10
C THIS BIT NOT YET WRITTEN FOR CN:
      IF (.NOT. TOF) GO TO 10
C TIME OF FLIGHT:
      WABSPR=ALAMBD(1,JSOURC)*ABSPR(2,JSOURC)+ABSPR(1,JSOURC)
      IF (WABSPR .LE. 0.001) THEN
        WA=WABSPR/3.
        ABSCOR=1.-WABSPR*(1.-2.*WA)
        DERABQ(1)=(4.*WA-1.)/ABSCOR
      ELSE
        EXPABS=EXP((-2.)*WABSPR)
        ABSCOR=(1.-EXPABS)/(2.*WABSPR)
        DERABQ(1)=(EXPABS/ABSCOR-1.)/WABSPR
      ENDIF
      DERABQ(2)=DERABQ(1)*ALAMBD(1,JSOURC)
      GO TO 100
C
C APPLY SHIFT IN COEFFICIENT:
   3  IF (JPHASE .EQ. 1) CALL ADJUST(ABSPR(ISPC,JSOURC))
      GO TO 100
C
C WRITE OUT NEW 'L ABSC' CARD FOR PR:
   4  WRITE (NEWIN,2001) NABTYP(KSOURC),ABSPR(1,KSOURC),
     & ABSPR(2,KSOURC)
2001  FORMAT ('L ABSC',I2,2F10.4)
** NEED METHOD OF PUTTING OUT *S
      GO TO 100
C
C DEAL WITH ABSENCE OF 'L ABSC' CARD:
   5  CALL MESS(LPT,1,
     & 'No L ABSC card - assuming no absorption correction')
      NABTYP(JSOURC)=0
  50  ABSPR(1,JSOURC)=0.
      ABSPR(2,JSOURC)=0.
  10  ABSCOR=1.
      DERABQ(1)=0.
      DERABQ(2)=0.
      GO TO 100
C
C FIX ABS COR IF NO CARD WAS GIVEN:
   6  IF (NABTYP(JSOURC) .EQ. 0) CALL ADDFX5(6,2,0,1,JSOURC,4)
      GO TO 100
C
C
      ENTRY ABCPR8(NP,NV)
C RECORD NP'TH PARAMETER AS VARIABLE NUMBER NV:
      KABSPR(NP,JSOURC)=NV
      GO TO 100
C
C
      ENTRY ABCPR9
C RECORD ALL PARAMETERS FIXED:
      DO 11 I=1,2
      DO 11 J=1,NSOURC
  11  KABSPR(I,J)=0
C
100   RETURN
      END
C
C
C
C
C LEVEL 3      SUBROUTINE ADDPAW(NSLTYP,ISGEN,ISP,AM,WEIGHT)
      SUBROUTINE ADDPAW(NSLTYP,ISGEN,ISP,AM,WEIGHT)
C
C *** ADDPAW updated by JCM 8 Mar 89 ***
C
CC 19B
CH Add slack constraint to list for Pawley type constrained PR
CA On entry NSLTYP=type of constraint:
CA      NSLTYP=3 means 2 constrained clumps of intensities as found by FAM4PR
CA On entry ISGEN  is the GENUS of the variable to be slackly constrained.
CA On entry ISP(1) is the species of the first intensity of the first clump
CA          ISP(2) is the species of the first intensity of the second clump
CA          AM  is a 1x2 real array holding the coefficents of the constraint
CA          WEIGHT is to weight this "observation" by 1/sigma squared.
C
CD Adds constraint to list for type NSLTYP slack constraints
CN Only at present for NSLTYP=3, so expects specifically only 2 clumps of
CN intensities to be linked.
C
      DIMENSION ISP(2),AM(2)
/PAWLPR/
/SLAKDA/
C
      NSKTOT=NSKTOT+1
%      CALL ERRCHK(2,NSLAK(NSLTYP),%PSLK%,0,
     & 'Pawley-type slack constraiints')
      NSLTEM=NSLAK(NSLTYP)
      IGSLAK(NSLTEM)=ISGEN
      ISPSLK(1,NSLTEM)=ISP(1)
      ISPSLK(2,NSLTEM)=ISP(2)
      AMSLAK(1,NSLTEM)=AM(1)
      AMSLAK(2,NSLTEM)=AM(2)
      WTSLAK(NSLTEM)=WEIGHT
      RETURN
      END
C
C
C
C
C LEVEL 1     SUBROUTINE ADF4G2(PAR)
      SUBROUTINE ADF4G2(PAR)
C
C *** ADF4G2 by WIFD 2 Jun 89 ***
C
CH Like ADJUST, but special to deal with family 4, genus 2
CA On entry PAR is the parameter to be updated
C
/F4PARS/
/NEWOLD/
C
      XOLD=PAR
      XTEM=(XOLD+SHIFT)/F4VAL(IGEN,ISPC)
      ARG=0.2*(XTEM-1.)
      SHINE=(ARG+SQRT(ARG*ARG+1.))**25
      XNEW=0.2*F4VAL(IGEN,ISPC)*ALOG(1.+148.4131591*SHINE)
      PAR=XNEW
      RETURN
      END
C
C
C
C
C LEVEL 8      SUBROUTINE APSHD2
      SUBROUTINE APSHD2
C
C *** APSHD2 updated by PJB Sept 93 ***
C
CX
CC 7B
CH Applies shifts for 2theta, time and cell for D2 type LSQ
CP Only useful if called from CELLSQ, D2LSQ or similar.  Expects suitable type
CP of Least Squares to be set up.
C
CP Also expects shifts in BLSQ and esds in DERIVB (as these are not now needed
CP for their original uses).
CD Scans all variables, deals with those which are redundant and whose shifts
CD are therefore not immediately available, deals with possible fudging, and
CD applies the shifts.
C
CO Outputs new values, shifts, esds, old values and shift/esd
C
      LOGICAL SHFCEL
      CHARACTER *4 LNAM1,LNAM2
/DERBAS/
/DERVAR/
/IOUNIT/
/MATDAT/
/NEWOLD/
/POINTS/
/REFINE/
C
      SHFCEL=.FALSE.
      WRITE (LPT,2000) ICYC
2000  FORMAT (/////'1 ++++++++++ Shifts in variables for cycle',I3,
     & ' ++++++++++ ')
      CALL MESS(LPT,2,'  Variable       New           Esd          '//
     & 'Shift          Old          Shift/Esd ')
C
C INITIALISE SHIFT AVERAGES:
      CALL FETSHF(1,0.,0.)
C
C COUNT ALL VARIABLES:
      DO 1 I=1,LVARV
C J=WHICH BASIC VARIABLE:
      J=LVRBS(I)
C KPACK=WHICH PACKED PARAMETER SPEC:
      KPACK=LVRPR(I)
C IF VARIABLE IS BASIC:
      IF (J .GT. 0) THEN
        SHIFT=BLSQ(J)
        ESD=DERIVB(J)
C OTHERWISE IT IS REDUNDANT, BY CONSTRAINT NUMBER -J:
      ELSE
        CALL SHFESD(-J)
      ENDIF
C
C GET ITS PRINTING NAME:
      CALL PARNAM(LNAM1,LNAM2,3,KPACK)
C AND ITS FAMILY, GENUS AND SPECIES:
      CALL PUNPAK(KPACK,IFAM,IGEN,ISPC)
C FAMILY 1, GENUS 1 - CELL PARAMETERS:
      IF (IGEN .EQ. 1) THEN
        IF (ISPC .EQ. 7) THEN
          CALL THETA2(3)
          GO TO 2
        ENDIF
        CALL CELSHF(ISPC)
        SHFCEL=.TRUE.
      ENDIF
C FAMILY 1, GENUS 2 - PKCN PARAMETERS:
      IF (IGEN .EQ. 2) CALL PCTF01(3)
C FAMILY 1, GENUS 3 - ZEROPOINT
      IF (IGEN .EQ. 3) CALL ZEROPR(3)
C
   2  CALL FETSHF(2,SHIFT,ESD)
      WRITE (LPT,2006) LNAM1,LNAM2,XNEW,ESD,SHIFT,XOLD,SHESD
2006  FORMAT (' ',1X,A4,1X,A4,5G14.5)
   1  CONTINUE
      CALL FETSHF(3,0.,0.)
      IF (SHFCEL) CALL RECELL(1,1)
      RETURN
      END
C
C
C
C
C LEVEL 10      SUBROUTINE APSHPR(ALSQ,MATSZ,PCXX,PFXX,MAGSHF)
      SUBROUTINE APSHPR(ALSQ,MATSZ,PCXX,PFXX,MAGSHF)
C
C *** APSHPR updated by PJB 1 Feb 1994 ***
C
CX
CC 19B
CH Applies shifts to parameters for PR with slack constraints
C
CP On entry, array BLSQ holds shifts, and DERIVB holds esds
CD Deals with redundant variables by interpreting constraints
CD Finds and applies fudge factors
CD Identifies species of parameter, then calls specific routines actually
CD    to apply shifts, thus not needing all COMMONs to be explicit here
CD
CD If slack constraints are used, just before exit recalculates ends of bonds
CO Prints original value, shift, esd and new value for each basic variable
CO Puts this printing in lines for everything except family 2 parameters,
CO    and in clumps per atom for family 2
C
      EXTERNAL PCXX,PFXX
      LOGICAL SHFCEL,TESTOV,HEAD,NPROP
      DIMENSION DPROP(3)
      CHARACTER *4 LNAM1,LNAM2
/ATBLOC/
/ATBLOK/
/CELPAR/
/DERBAS/
/DERVAR/
/GLOBAL/
/IOUNIT/
/MATDAT/
/NEWOLD/
/PHASE/
/POINTS/
/REFINE/
/REFIPR/
/SLAKDA/
/SLKGEO/
/SOURCE/
C
      IF (SIMUL) GO TO 100
      WRITE (LPT,2000) ICYC
2000  FORMAT (/////'1 ++++++++++ Shifts in variables for cycle',I3,
     & ' ++++++++++ ')
C
C START PRINT CONTROL:
      IG=0
      IBUFF=0
      HEAD=.FALSE.
      JPHASE=0
      JSOURC=0
      SHFCEL=.FALSE.
C
C CLEAR SHIFT AVERAGING:
      CALL FETSHF(1,0.,0.)
C SCAN ALL VARIABLES:
      DO 1 I=1,LVARV
C J=WHICH BASIC VARIABLE IS THIS I'TH VARIABLE
      J=LVRBS(I)
C KPACK=PACKED SPEC OF THIS PARAMETER
      KPACK=LVRPR(I)
      IF (J .LE. 0) THEN
C VARIABLE IS REDUNDANT, BY CONSTRAINT NUMBER -J:
        CALL SHFESD(-J)
      ELSE
C
C BASIC VARIABLE:
        SHIFT=BLSQ(J)
        ESD=DERIVB(J)
      ENDIF
C
C KEEP CURRENT PHASE & SOURCE:
      JP=JPHASE
      JS=JSOURC
C UNPACK PARAMETER SPEC:
      CALL KUNPAK(KPACK,IFAM,IGEN,ISPC,JPHASE,JSOURC)
      IF (JPHASE .NE. IPHASE) THEN
C NEW PHASE:
        IF (MULFAS) THEN
C TIDY PREVIOUS:
          IF (SHFCEL) THEN
            CALL MATCEL(ALSQ,MATSZ)
            CALL RECELL(1,1)
            CALL CELSDP(ALSQ,MATSZ)
          ENDIF
          IF(NPROP) THEN
            CALL REINDX(DPROP)
            NPROP=.FALSE.
          ENDIF
C ADJUST ENDS OF ANY BONDS INVOLVING ALTERED COORDINATES:
          CALL GEOMCO(2)
          CALL PHMOVE(-1,IPHASE)
          WRITE (LPT,2011) JPHASE
2011      FORMAT (/' Phase',I3,' :')
C 89.14 Try to print headers with each phase...
          HEAD=.FALSE.
          CALL PHMOVE(1,JPHASE)
          CALL LOGPHA(JPHASE)
        ENDIF
        SHFCEL=.FALSE.
      ENDIF
      IF (IFAM .EQ.3 .OR. IFAM .EQ. 6 .AND. (JS .NE. JSOURC))
     &  CALL LOGSOU(JSOURC)
C
C BRANCH ON FAMILY:
      GO TO (11,12,13,14,15,16), IFAM
      CALL ERRMES(-1,0,'family too big in APSHPR')
C
C FAMILY 1, GENUS 1 - MISCELLANEOUS SINGLY NAMED SPECIES (TFAC, A* ETC,
C EXTN,PROR,SPHA)
  11  GO TO (31,35,35,35,35,35,35,36,37,38,39,39,39) , ISPC
      CALL ERRMES(-1,0,'species too big in APSHPR')
C
C TFAC:
  31  CALL LLTFAC(3)
      GO TO 40
C
C FAMILY 1 GENUS 1 ALSO CONTAINS THE CELL PARAMETERS:
  35  CALL CELSHF(ISPC-1)
      SHFCEL=.TRUE.
      LSQCEL=.TRUE.
      GO TO 40
C
C EXTINCTION CORRECTION PARAMETER EXTN:
  36  CALL EXCRPR(3)
      GO TO 40
C
C PREFERRED ORIENTATION
  37  CALL PREFOR(3)
      GO TO 40
C
C FAMILY 1, GENUS 1, SPECIES 10 - SCALE FOR PHASE, SPHA:
  38  CALL LPSCAL(3)
      GO TO 40
C FAMILY 1 GENUS 1, SPECIES 11,12,13 PROPAGATION VECTOR
   39 CALL PROPAG(3,ISPC-10)
        DPROP(ISPC-10)=SHIFT
        NPROP=.TRUE.
      GO TO 40
C
C FAMILY 6: MISCELLANEOUS SOURCE DEPENDENT;
  16  GO TO (61,62,63) , IGEN
      CALL ERRMES(-1,0,'genus too big in APSHPR')
C
C FAMILY 6 GENUS 1 - SINGLY NAMED, SOURCE-DEPENDENT SPECIES (SCAL,TTHM)
  61  GO TO (51,52) , ISPC
      CALL ERRMES(-1,0,'species too big in APSHPR')
C
C FAMILY 6, GENUS 1, SPECIES 1 - SCALE FOR SOURCE, SCAL:
  51  CALL LSSCAL(3)
      GO TO 40
C
C MONOCHROMATOR 2 THETA FOR LX:
  52  CALL TTHMLX(3)
      GO TO 40
C
C FAMILY 6, GENUS 2 - ABSC:
  62  CALL ABCRPR(3)
      GO TO 40
C
C FAMILY 6, GENUS 3 - BACK:
  63  CALL BACKPR(3)
      GO TO 40
C
C FAMILY 2 - THESE ARE ALL TO DO WITH THE STRUCTURE FACTOR:
C STOP APPLYING THE SHIFT MORE THAN ONCE TO RELATED SCATS:
  12  IF (J .LT. 0 .AND. ISPC .EQ. 10) GO TO 1
      IF (ISPC .LE. 12) CALL F2SHFT
      IF (ISPC .GT. 12) CALL MAGSHF(3)
      GO TO 40
C
C FAMILY 3 - ZERO POINT, PEAK CENTRE AND PEAK FUNCTION PARAMETERS:
C IF ANY FAMILY 2 SHIFTS LEFT IN BUFFER, PRINT THEM:
  13  CALL PRBLOK
C
C GENUS 1=ZERO POINT, 2=PEAK CENTRE, REST ARE PEAK FUNCTION:
      GO TO (41,42) , IGEN
      GO TO 43
C
C ZERO:
  41  CALL ZEROPR(3)
      GO TO 40
C
C PEAK CENTRE PARAMETERS DEPEND ON TYPE OF REFINEMENT:
  42  CALL PCXX(3)
      GO TO 40
C
C REMAINING PEAK FUNCTION PARAMETERS:
  43  CALL PFALL(3)
      GO TO 40
C
C FAMILY 4 - LONG VECTORS (SO FAR, INTS, SIGS, GAMS . . IN PAWLEY)
  14  CALL FAM4PR(3,PCXX,PFXX)
      GO TO 40
C
C FAMILY 5 ARE MULTIPOLES, EXCLUDED FOR NOW:
  15  GO TO 1
C
C COMM0N EXIT TO PRINT SHIFTS:
  40  CALL FETSHF(2,SHIFT,ESD)
      CALL PARNAM(LNAM1,LNAM2,3,KPACK)
      IF (IFAM .NE. 2) GO TO 6
C FOR FAMILY 2, DETECT CHANGE OF GENUS (ATOM)
      IF (IG .NE. IGEN) THEN
        HEAD=.FALSE.
        CALL PRBLOK
C
C PUT FIRST ENTRY FOR NEW ATOM INTO BUFFERS:
        NAME=LNAM1
        IG=IGEN
      ENDIF
      IF (IBUFF .GE. 12) CALL PRBLOK
      IBUFF=IBUFF+1
      IPNAME(IBUFF)=LNAM2
      PNEW(IBUFF)=XNEW
      PESD(IBUFF)=ESD
      PSHIFT(IBUFF)=SHIFT
      POLD(IBUFF)=XOLD
      PSESD(IBUFF)=SHESD
      GO TO 1
C
C HERE TO PRINT NOT FAMILY 2 SHIFT AS BEFORE:
C JPW/JBF
   6  IF (IFAM.EQ.3 .OR. IFAM.EQ.6) THEN
      IF (.NOT. HEAD) CALL MESS(LPT,1,'Src  Variable       New      '//
     & '     Esd          Shift          Old          Shift/Esd ')
      HEAD=.TRUE.
      WRITE (LPT,2006)JSOURC,LNAM1,LNAM2,XNEW,ESD,SHIFT,XOLD,SHESD
2006  FORMAT (' ',I4,1X,A4,1X,A4,5G14.5)
      ELSE
      IF (.NOT. HEAD) CALL MESS(LPT,1,'Variable       New      '//
     & '     Esd          Shift          Old          Shift/Esd ')
      HEAD=.TRUE.
      WRITE (LPT,2007)LNAM1,LNAM2,XNEW,ESD,SHIFT,XOLD,SHESD
2007  FORMAT (' ',A4,1X,A4,5G14.5)
      ENDIF
   1  CONTINUE
      CALL PRBLOK
      IF (SHFCEL) THEN
        CALL MATCEL(ALSQ,MATSZ)
        CALL RECELL(1,1)
        CALL CELSDP(ALSQ,MATSZ)
      ENDIF
      IF (NPROP) THEN
        CALL REINDX(DPROP)
        NPROP=.FALSE.
      ENDIF
C
C ADJUST ENDS OF ANY BONDS INVOLVING ALTERED COORDINATES:
      CALL GEOMCO(2)
C C 90.35 replace ... CALL PHMOVE(-1,NPHASE) ... with
      IF(NPHASE.GT.1)CALL PHMOVE(-1,JPHASE)
      IF(NPHASE.GT.1)CALL PHMOVE(1,1)
      CALL LOGPHA(1)
      CALL LOGSOU(1)
C end of 90.35
      CALL FETSHF(3,0.,0.)
C
 100  RETURN
      END
C
C
C
C
C LEVEL 5      SUBROUTINE BACKIN
      SUBROUTINE BACKIN
C
C *** BACKIN by JCM 18 Jun 85 ***
C
C INTERPRETS ONE 'L BACK' CARD - USED IN PROFILE REFINEMENT INPUT
C
/CARDRC/
/GRDBCK/
/IOUNIT/
/LREAD/
/SOURCE/
C
      IPT=7
      N=NBACK(KSOURC)+1
C
C IF NOT FIRST L BACK CARD READ BRANCH ON WHETHER IBACK .GT./.LT. 0
      IF (ILREA(11,KSOURC) .GT. 1 .AND. IBACK .LT. 0) GO TO 150
      IF (ILREA(11,KSOURC) .GT. 1 .AND. IBACK .GT. 0) GO TO 200
C
C IF FIRST L BACK CARD FIND OUT WHAT IBACK IS
      IF (ILREA(11,KSOURC) .EQ. 1) CALL RDINTG(IBACK,IPT,IPT,80,IER)
C
C BRANCH ON WHETHER IBACK .GT./.LT. 0
      IF (IBACK .LT. 0) GO TO 160
C
C IBACK .GT. 0 :      BACKGROUND REFINEMENT
C
 302  WRITE (LPT,2500) IBACK
2500  FORMAT(/' Background refinement type ',I5)
      GO TO (310,320,330,340,350) ,IBACK
      CALL ERRIN2(IBACK,1,'Type of background refinement',
     & 'illegal - 1, 2, 3, 4 or 5 only')
      GO TO 100
C
 310  CALL MESS(LPT,1,'Polynomial function')
      GO TO 400
C
 320  CALL MESS(LPT,1,'Chebyschev polynomial (1st kind) function')
      GO TO 400
C
 330  CALL MESS(LPT,1,'Chebyschev polynomial (2nd kind) function')
      GO TO 400
C
 340  CALL MESS(LPT,1,'Fourier cosine series function')
      GO TO 400
C
 350  CALL MESS(LPT,1,'Refinable linear interpolation')
      GO TO 400
C
 400  NBK(KSOURC)= 0
 200  IF(IBACK.EQ.5) GO TO 1
C
C 1ST BACKGROUND CARD NOW JOINS UP WITH FURTHER BACKGROUND CARDS
      NBK(KSOURC)= NBK(KSOURC)+1
      LBKD(NBK(KSOURC),KSOURC)= N
      CALL RDNUMS(BACKGD(N,KSOURC),IPT,20,NUM,IER)
      IF (IER .NE. 0) IERR= IERR+1
      NBACK(KSOURC)= NBACK(KSOURC)+NUM
      IER=IERR
%      CALL ERRCHK(1,NBACK(KSOURC),%BACK%,1,'background parameters')
      IF (IER .NE. IERR) GO TO 100
C
      LBKD(NBK(KSOURC)+1,KSOURC)= NBACK(KSOURC)+1
      CALL MESS(LPT,1,'Background parameter(s) :')
      CALL PRILIS(BACKGD(1,KSOURC),N,NBACK(KSOURC))
      GO TO 100
C
C
C
C NOT 1ST CARD AND IBACK .LT. 0 : READ TYPE OF BACKGROUND WANTED -
C OCCURS ON EVERY CARD, SAME ON EACH IF IBACK .LT. 0:
 150  CALL RDINTG(IB,IPT,IPT,80,IER)
C 1ST CARD AND IBACK .LT. 0 JUMPS TO THIS POINT
 160  IF (NBACK(KSOURC) .EQ. 0) GO TO 2
      IF (IB .EQ. IBACK) GO TO 1
      WRITE (LPT,3001) IBACK,IB
      WRITE (ITO,3001) IBACK,IB
3001  FORMAT (/' ERROR ** background type altered from',I4,' to',I4)
      IERR=IERR+1
      GO TO 100
C
C   2  IBACK=IB
   2  IF ((IBACK .GE. 0) .OR. (IBACK .LE. -3)) THEN
        CALL ERRIN2(IBACK,2,'type of background approximation',
     &  'not allowed - only -1 or -2')
        GO TO 100
      ENDIF
C
C READ NEXT NUMBER PAIR ON CARD:
   1  CALL RDREAL(ARGBAK(NBACK(KSOURC)+1,KSOURC),IPT,IPT,80,IER)
C JUMP ON END OF CARD INFORMATION:
      IF (IER .EQ. 100) GO TO 7
      IER=IERR
%      CALL ERRCHK(2,NBACK(KSOURC),%BACK%,1,
     & 'background table entries')
      IF (IER .NE. IERR) GO TO 100
C
   5  CALL RDREAL(BACKGD(NBACK(KSOURC),KSOURC),IPT,IPT,80,IER)
      IF (IER .NE. 100) GO TO 6
      CALL ERRRE2(ARGBAK(NBACK(KSOURC),KSOURC),2,
     & 'no background value with arg=',' ')
      GO TO 10
C
   6  IF (NBACK(KSOURC) .EQ. 1) GO TO 1
      IF (ARGBAK(NBACK(KSOURC),KSOURC) .GT.
     & ARGBAK(NBACK(KSOURC)-1,KSOURC)) GO TO 1
      WRITE (LPT,3004) ARGBAK(NBACK(KSOURC),KSOURC),
     & ARGBAK(NBACK(KSOURC)-1,KSOURC)
      WRITE (ITO,3004) ARGBAK(NBACK(KSOURC),KSOURC),
     & ARGBAK(NBACK(KSOURC)-1,KSOURC)
3004  FORMAT (/' ERROR ** arguments for backgrounds not in',
     & ' strictly ascending order'/' ',F12.2,' follows',F12.2)
      IERR=IERR+1
      GO TO 100
C
   7  IF (NBACK(KSOURC) .EQ. N-1) THEN
        CALL ERRMES(1,1,'no non-zero numbers given on L BACK card')
        GO TO 100
      ENDIF
C
  10  IF (N .NE. 1) GO TO 3
      IF (IBACK .EQ. 5) GO TO 4
      WRITE (LPT,2000) IBACK
2000  FORMAT(/' Background approximation type ',I5)
      GO TO (11,12) ,-IBACK
      CALL ERRIN2(IBACK,2,'Type of background','illegal')
      GO TO 100
C
  11  CALL MESS(LPT,1,'Linear interpolation required')
      GO TO 4
C
  12  CALL MESS(LPT,1,'Cubic spline approximation to be used')
C
   4  CALL MESS(LPT,1,'Argument    Background')
   3  WRITE (LPT,2001) (ARGBAK(J,KSOURC),
     & BACKGD(J,KSOURC),J=N,NBACK(KSOURC))
      NBK(KSOURC)= NBK(KSOURC)+1
      LBKD(NBK(KSOURC),KSOURC)=NBK(KSOURC)
2001  FORMAT (1X,F12.2,F12.2)
      GO TO 100
C
 100  RETURN
      END
C
C
C
C
C LEVEL 6      SUBROUTINE BACKPR(N)
      SUBROUTINE BACKPR(N)
C
C *** BACKPR by WIFD 20 Aug 86
C
C MULTIPLE ENTRY ROUTINE TO DEAL WITH ALL ASPECTS OF BACKGROUNDS FOR CN
C
C ON ENTRY, N=1 MEANS INTERPRET L BACK CARD
C           N=2
C             IBACK .LT. 0
C               MEANS SET YBACK (IN COMM0N /OBSCAL) TO BE BACKGROUND AT
C               ARGI (IN COMMON /PRPKFN)
C             IBACK .GT. 0
C               MEANS CALCULATE YBACK AND ITS DERIVATIVES
C           N=3 APPLICABLE ONLY FOR IBACK .GT. 0
C               MEANS APPLY SHIFTS TO BACKGROUND PARAMETERS
C           N=4 APPLICABLE ONLY FOR IBACK .GT. 0
C               MEANS WRITE OUT NEW L BACK CARD
C               (IBACK .LT. 0 LEADS TO TRIVIAL OUTPUT OF LBACK CARD
C
C USES IBACK TO INDICATE MODE OF FINDING BACKGROUND;
C IF IBACK .LT. 0 THEN BACKGROUND APPROXIMATION IS REQUIRED.
C AT PRESENT IBACK=-1 OR -2
C AVAILABLE,     -1  MEANING LINEAR INTERPOLATION IN TABLE USING ALNINT
C                -2  MEANING USE CUBIC SPLINE PREVIOUSLY SET UP
C                (0 WILL MEAN READ VALUES FROM FILE ?)
C IF IBACK .GT. 0 THEN BACKGROUND REFINEMENT IS REQUIRED
C
/CONSTA/
/DERVAR/
/GLOBAL/
/GRDBCK/
/IOUNIT/
/NEWOLD/
/OBSCAL/
/PHASE/
/POINTS/
/PRPKCN/
/PRPKFN/
/SOURCE/
/SPLBCK/
C
      GO TO (1,2,3,4) , N
      GO TO 100
C
C READ ONE L BACK CARD:
   1  CALL BACKIN
      GO TO 100
C
C CALCULATE YBACK VALUE AT ARGI: BIFURCATE ON WHETHER IBACK LT/EQ/GT 0
   2  IF (IBACK) 200,250,300
C
C BACKGROUND INTERPOLATION APPROXIMATIONS
 200  GO TO (11,12) , -IBACK
  11  YBACK=ALNINT(ARGBAK(1,JSOURC),BACKGD(1,JSOURC),ARGI,
     & NBACK(JSOURC))
      GO TO 100
C
  12  YBACK=SPLINT(-1,NBACK(JSOURC),ARGBAK(1,JSOURC),
     & BACKGD(1,JSOURC),SCOEFF(1,JSOURC),ARGI)
      GO TO 100
C
C BACKGROUND READ FROM FILE
 250  GO TO 100
C
C BACKGROUND AND DERIVATIVES CALCULATED FROM BACKGROUND FUNCTION
 300  GO TO (310,320,330,340,350) , IBACK
C
C SIMPLE POLYNOMIAL MODEL
 310  YBACK= 0.
      AMUL= 1.
      BMUL= (ARGI-ARGMIN(JSOURC))/(ARGMAX(JSOURC)-ARGMIN(JSOURC))
      DO 311 I=1,NBACK(JSOURC)
      YBACK= YBACK+BACKGD(I,JSOURC)*AMUL
      L=KBCKGD(I,JSOURC)
      IF (L .NE. 0) DERIVV(L)= DERIVV(L) + AMUL
      AMUL= AMUL*BMUL
 311  CONTINUE
      GO TO 100
C
C CHEBYSCHEV POLYNOMIAL (OF THE FIRST KIND) MODEL
 320  YBACK= BACKGD(1,JSOURC)
      L=KBCKGD(1,JSOURC)
      IF (L .NE. 0) DERIVV(L)= DERIVV(L) + 1.
      IF (NBACK(JSOURC) .LE. 1) GO TO 100
C XCHEB IS DEFINED BETWEEN -1 AND 1
      XCHEB= (2.*ARGI-(ARGMAX(JSOURC)+ARGMIN(JSOURC)))/
     & (ARGMAX(JSOURC)-ARGMIN(JSOURC))
      CHEB0= 0.
      CHEB1= 1.
      DO 321 I=2,NBACK(JSOURC)
      CHEB2= 2.*XCHEB*CHEB1-CHEB0
      IF (I .EQ. 2) CHEB2= 0.5*CHEB2
      YBACK= YBACK+BACKGD(I,JSOURC)*CHEB2
      L=KBCKGD(I,JSOURC)
      IF (L .NE. 0) DERIVV(L)= DERIVV(L) + CHEB2
      CHEB0=CHEB1
      CHEB1=CHEB2
 321  CONTINUE
      GO TO 100
C
C CHEBYSCHEV POLYNOMIAL (OF THE SECOND KIND) MODEL
 330  YBACK= BACKGD(1,JSOURC)
      L=KBCKGD(1,JSOURC)
      IF (L .NE. 0) DERIVV(L)= DERIVV(L) + 1.
      IF (NBACK(JSOURC) .LE. 1) GO TO 100
C XCHEB IS DEFINED BETWEEN -1 AND 1
      XCHEB= (2.*ARGI-(ARGMAX(JSOURC)+ARGMIN(JSOURC)))/
     & (ARGMAX(JSOURC)-ARGMIN(JSOURC))
      CHEB0= 0.
      CHEB1= 1.
      DO 331 I=2,NBACK(JSOURC)
      CHEB2= 2.*XCHEB*CHEB1-CHEB0
      YBACK= YBACK+BACKGD(I,JSOURC)*CHEB2
      L=KBCKGD(I,JSOURC)
      IF (L .NE. 0) DERIVV(L)= DERIVV(L) + CHEB2
      CHEB0=CHEB1
      CHEB1=CHEB2
 331  CONTINUE
      GO TO 100
C
C FOURIER COSINE SERIES
 340  YBACK= BACKGD(1,JSOURC)
      L=KBCKGD(1,JSOURC)
      IF (L .NE. 0) DERIVV(L)= DERIVV(L) + 1.
      IF (NBACK(JSOURC) .LE. 1) GO TO 100
C XTEM IS DEFINED BETWEEN 0 AND TWOPI
      XTEM= (ARGI-ARGMIN(JSOURC))/(ARGMAX(JSOURC)-ARGMIN(JSOURC))
      DO 341 I=2,NBACK(JSOURC)
      COSNX= COS(TWOPI*FLOAT(I-1)*XTEM)
      YBACK= YBACK+BACKGD(I,JSOURC)*COSNX
      L=KBCKGD(I,JSOURC)
      IF (L .NE. 0) DERIVV(L)= DERIVV(L) + COSNX
 341  CONTINUE
      GO TO 100
C
C Refinable linear interpolation function
 350  DO 351 I=1,NBACK(JSOURC)
      IF (ARGBAK(I,JSOURC) .GT. ARGI) GO TO 352
 351  CONTINUE
      I=0
 352  IF (I.EQ.1 .OR. I.EQ.0) THEN
        IF (I.EQ.0) I=NBACK(JSOURC)
        YBACK=BACKGD(I,JSOURC)
        L=KBCKGD(I,JSOURC)
        IF (L .NE. 0) DERIVV(L)= DERIVV(L) + 1.
      ELSE
        YBACK=(BACKGD(I-1,JSOURC)*( ARGBAK(I  ,JSOURC)-ARGI) +
     &         BACKGD(I,  JSOURC)*(-ARGBAK(I-1,JSOURC)+ARGI) ) /
     &        (ARGBAK(I,JSOURC)-ARGBAK(I-1,JSOURC))
        L=KBCKGD(I,JSOURC)
        IF (L .NE. 0) DERIVV(L)= DERIVV(L) +
     &(-ARGBAK(I-1,JSOURC)+ARGI)/(ARGBAK(I,JSOURC)-ARGBAK(I-1,JSOURC))
        L=KBCKGD(I-1,JSOURC)
        IF (L .NE. 0) DERIVV(L)= DERIVV(L) +
     &( ARGBAK(I  ,JSOURC)-ARGI)/(ARGBAK(I,JSOURC)-ARGBAK(I-1,JSOURC))
      ENDIF
      GO TO 100
C
C APPLY SHIFTS TO BACKGROUND PARAMETERS
   3  IF (IBACK .GT. 0) THEN
        IF (MULFAS .AND. JPHASE .GT. 1) GO TO 100
        CALL ADJUST(BACKGD(ISPC,JSOURC))
      ENDIF
      GO TO 100
C
C WRITE NEW L BACK CARD (APPLICABLE ONLY FOR IBACK .GT. 0)
   4  DO 40 I=1,NBK(KSOURC)
      IF (LBKD(I,KSOURC) .GT. 0) GO TO 42
  40  CONTINUE
      WRITE(LPT,3001) NBK,(LBKD(J,KSOURC),J=1,10)
3001  FORMAT(/' PROGRAM ERROR *** Too many background cards being '//
%     & 'written out - NBK =',I4/' LBKD holds ',10I3)
      STOP
C
  42  N1= LBKD(I,KSOURC)
      N2= LBKD(I+1,KSOURC)-1
      LBKD(I,KSOURC)= -LBKD(I,KSOURC)
      IF(IBACK.EQ.5) GO TO 43
      IF (I. EQ. 1) WRITE(NEWIN,2004) IBACK,(BACKGD(J,KSOURC),
     & J=N1,N2)
      IF (I. NE. 1) WRITE(NEWIN,2005) (BACKGD(J,KSOURC),J=N1,N2)
 2004 FORMAT('L BACK',1X,I4,4X,6(F12.5,1X))
 2005 FORMAT('L BACK',1X,7(F12.5,1X))
      GO TO 100
C
  43  IF(I.EQ.1) THEN
        WRITE(NEWIN,2006) IBACK,ARGBAK(N1,KSOURC),BACKGD(N1,KSOURC)
      ELSE
        WRITE(NEWIN,2007) ARGBAK(N1,KSOURC),BACKGD(N1,KSOURC)
      ENDIF
 2006 FORMAT('L BACK',1X,I4,4X,2(F12.5,1X))
 2007 FORMAT('L BACK',4X,2(F12.5,1X))
      GO TO 100
C
C
      ENTRY BACKP8(NP,NV)
C RECORD THAT PARAMETER NP IS VARIABLE NUMBER NV:
      KBCKGD(NP,JSOURC)=NV
      GO TO 100
C
C
      ENTRY BACKP9
C RECORD ALL PARAMETERS FIXED:
      DO 21 J=1,NSOURC
      DO 21 I=1,NBACK(J)
  21  KBCKGD(I,J)=0
C
 100  RETURN
      END
C
C
C
C
C LEVEL 7      SUBROUTINE CALCD2(H)
      SUBROUTINE CALCD2(H)
C
C *** CALCD2 by JCM 14 Mar 85 ***
C
CX
CC 7B
CH Gives the calculated function for LSQ refinement for which the
CH observations are time-of-flight values, and calculates derivatives.
CA On entry H is a 1x3 vector holding h,k,l
CP /CELPAR/ holds the reciprocal cell quadratic products in CPARS(1:6,2), and
CP                their fix/vary information in KCPARS(1:6)
CP /THET2/ holds THE2, the refinabale value of 2 theta degrees
CP               KTHE2, the fix/vary information for THE2, and
CP               THCON1=cos theta (converted to radians)
CD Forms GCALC in /OBSCAL/ as PKCN(1)*252.777*lambda + PKVCN(2) lambda squared
CP                          + ZERO
CD and all derivatives in DERIVV in /DERVAR/
C
      DIMENSION H(3),C(6)
/BRAGG/
/CELPAR/
/DERVAR/
/DGEOM/
/OBSCAL/
/POINTS/
/PHASE/
/PRPKCN/
** THIS IS ONLY HERE FOR KNOW, WHICH IS NOT NICE
/REFLNS/
/PRZERO/
/SOURCE/
/THET2/
C
C FIRST FORM D* SQUARED AND ITS DERIVATIVE WRT A*, B* ETC:
      CALL CELDER(H,C)
C
C NOW D*:
      DSTAR(1)=SQRT(DSTAR2)
      KNOW=1
      TWOTHD(JSOURC)=THE2
      CALL PCTF01(2)
      GCALC=ARGK
C
C DERIVATIVE WRT 2THETA DEGREES IF REQD:
      L=KTHE2
C DT/DLAM * DLAM/D(2THETA DEGREES) ; THCON1 HOLDS COS THETA * RADIANS
      IF (L .GT. 0) DERIVV(L)=DTDWL*THCON1/DSTAR(1)
C
C DERIVATIVES WRT PEAK CENTRE PARAMETERS:
      L=KPCNSP(1,JPHASE,JSOURC)
      IF (L .GT. 0) DERIVV(L)=DTDPCN(1)
      L=KPCNSP(2,JPHASE,JSOURC)
      IF (L .GT. 0) DERIVV(L)=DTDPCN(2)
C AND ZERO
      L=KZROSP(1,JPHASE,JSOURC)
      IF (L .GT. 0) DERIVV(L)=DKDZER(1)
C
C DERIVATIVES WRT CELL PARAMETERS A* B* ETC; IN STAGES, DT/DLAM,
C DLAM/D(DSTAR SQRD), D(DSTAR SQRD)/DA* (AS OUT OF CELDER):
      FAC=DTDWL*(-0.5*ALAMBD(1,JSOURC)/DSTAR2)
      DO 2 I=1,6
      L=KCPARS(I)
      IF (L .GT. 0) DERIVV(L)=C(I)*FAC
   2  CONTINUE
C
      RETURN
      END
C
C
C
C
C LEVEL 9       SUBROUTINE CALPR(PCXX,PFXX)
      SUBROUTINE CALPR(PCXX,PFXX)
C
C  *** CALPR updated by JCM 17 Apr 89 ***
C
CH Gives calculated function to match observed for all PR applications
CA PCXX is the name of the routine giving peak centre
CA PFXX is the name of the routine giving peak function
CP on entry in /PRPKFN/ expects ARGI, the argument for the I'th observation
C
CD Forms GCALC, then summed to make YPEAK
CD Adds derivatives of GCALC into previously cleared DERIVV, and via RFACPR
CD gives GGCALC and contributions to SOMEGA.
C
CD GCALC is made from several functions multiplied together.
CD We write GCALC = P1*P2*P3* . . . where:
CD    P1 is an outside multiplying factor containing scale, Lp, multiplicity,
CD       overal tf, etc - it does not contain any structure parameters
CD    P2 is a fuction of the structure factor, usually Fc squared.
CD    P3 is an extinction correction
CD    P4 is an absorption correction
CD    P5 is the peak function
CD
CD YPEAK is then the sum over contributing k values of GCALC.
C
CD Should work for all refinement types (RIET, CAILS, SAPS . .)
CD                 all data sources (TOF, CN, LX . . )
C
C
      EXTERNAL PCXX,PFXX
      LOGICAL TESTOV
      COMPLEX FCALC
%      DIMENSION DERIVA(%VVAR%),CDERS(6),DERIV4(5)
/BRAGG/
/CARDRC/
/CELPAR/
/CONSTA/
/DERVAR/
/DGEOM/
/FCAL/
/F4PARS/
/OBSCAL/
/OVER/
/PHASE/
/POINTS/
/POSNS/
/PRABSC/
/PRBLEM/
/PREORI/
/PREXTN/
/PRPKCN/
/PRPKFN/
/PRSAVE/
/PRSTAT/
/PRZERO/
/REFINE/
/REFIPR/
/REFLNS/
/SOURCE/
/TTHMNC/
C
C IF X-RAY, DEAL FIRST WITH LP FOR THIS ARGI:
      IF (LX) CALL TTHMLX(2)
C
C CYCLE OVER K:
      DO 11 KNOW=KMIN,KMAX
C
C THIS KNOW MAY HAVE OCCURRED RECENTLY:
%      KMOD=MOD(KNOW-1,%OLAP%)+1
      REFUSE=(KNOW .EQ. KPOINT(KMOD))
C FORM D* SQUARED,S SQUARED, AND DERIVATIVES WRT RECIPROCAL CELL
C PARAMETERS:
        CALL CELDER(REFH(1,KNOW),CDERS)
        DSTAR(KNOW)=SQRT(DSTAR2)
C
C SET ARGK AND LAMBDA FOR THIS REFLECTION:
      CALL PCXX(2)
C
      L2=NVARF(2,JPHASE,1)
      L123=NVARF(1,JPHASE,JSOURC)+L2+NVARF(3,JPHASE,JSOURC)*NSOURC
      L1ST=LVFST1(1,JPHASE,1)
C
C FORM P1 AND SOME FAMILY 1 QUOTIENT DERIVATIVES (ALL /P1):
C EACH DATA TYPE HAS DIFFERENT FACTOR:
      IF (TOF) FAC=1./(DSTAR2*DSTAR2)
      IF (CN) FAC=1./(SIN(RAD*ARGK)*SIN(0.5*RAD*ARGK))
      IF (LX) FAC=ALPCOR*V(2)*V(2)
      P1=SCALEP(JPHASE)*SCALES(JSOURC)*EXP((-2.)*SSQRD*TFAC)*
     & AMUL(KNOW)*FAC
C TFAC DERIVATIVE:
      L=KTFAC
      IF (L .NE. 0) DERIVA(L)=-2.*SSQRD
C SCALE DERIVATIVES:
      L=KSCALS(JSOURC)
      IF (L .NE. 0) DERIVA(L)=1./SCALES(JSOURC)
      L=KSCALP(JPHASE)
      IF (L .NE. 0) DERIVA(L)=1./SCALEP(JPHASE)
C
C PREFERRED ORIENTATION:
      IF (NPRTYP .GT. 0) THEN
        L=KPRFPR
        IF (.NOT. REFUSE) THEN
          CALL PREFOR(2)
          SAVPRC(KMOD)=PRFCOR
          IF (L .GT. 0) SAVDPC(KMOD)=DERPRQ
        ENDIF
        P1=P1*SAVPRC(KMOD)
        IF (L .NE. 0) DERIVA(L)=SAVDPC(KMOD)
      ENDIF
C
C IF X-RAY, MONOCHROMATOR ANGLE:
      IF (LX) THEN
        L=KTHMON(JSOURC)
        IF (L .NE. 0) DERIVA(L)=DLPCOR
      ENDIF
C
C NEXT DO P2, THE PART DEPENDENT ON THE STRUCTURE FACTOR:
C IF CAIL, P2 IS SIMPLY F4PAR(1,KNOW):
      IF (CAIL .OR. APES) THEN
C MUST SET KPOINT FOR USE BY FFT NEXT TIME ROUND:
        KPOINT(KMOD)=KNOW
        IF (KF4PAR(1,KNOW) .EQ. 0) THEN
          F4PAR(1,KNOW)=1.
        ELSE
          DERIV4(1)=1.
        ENDIF
        IF (F4PAR(1,KNOW).NE. 0.) DERIV4(1)=1./F4PAR(1,KNOW)
        P2=F4PAR(1,KNOW)
      ELSE
C SET BASE FOR DERIVATIVES:
        III=LVFST1(2,JPHASE,1)
        IF (.NOT. REFUSE) THEN
C NEW K:
C IF NO FAMILY 2 VARIABLES, NO NEED FOR LFCALC:
          IF (L2 .GT. 0) THEN
            CALL LFCALC(REFH(1,KNOW))
            F=0.
            IF (.NOT. TESTOV(2.,FCMOD)) F=2./FCMOD
            P2=FCMOD*FCMOD
C CONVERT DERIVATIVES FOR FAMILY 2 FROM BEING 'OF FCMOD' TO 'OF P2'
C DP2/DV = DMODFC/DV * DP2/DMODFC - AND ALL ARE DIVIDED BY P2
C GIVING D(GCALC)/DV OVER GCALC=(DP2/DV OVER P2)
            DO 4 I=1,L2
            DERIVA(III+I)=F*FCDERS(I)
            SAVDER(I,KMOD)=DERIVA(III+I)
   4        CONTINUE
          ELSE
            FC=FCALC(REFH(1,KNOW))
            P2=FC*CONJG(FC)
            FCMOD=SQRT(P2)
          ENDIF
C
          KPOINT(KMOD)=KNOW
          SAVP2(KMOD)=P2
C OLD K:
        ELSE
C
C P2 FOR THIS K SAVED WHEN USED PREVIOUSLY:
** 12 july '91 - SUSPECT NEED TO PRESERVE FCMOD ALSO, SO PROBABLY SHOULD SAVE
** IT AND NOT P2, TO AVOID REPEATED SQRT
          P2=SAVP2(KMOD)
          FCMOD=SQRT(P2)
          DO 420 I=1,L2
 420      DERIVA(III+I)=SAVDER(I,KMOD)
        ENDIF
      ENDIF
C
C P3:
      CALL EXCRPR(2)
      P3=EXTCO
      DP2DFQ=DP2DFQ+DXDFQ
      L=KEXTPR
      IF (L .GT. 0) DERIVA(L)=DEREXQ
C
C P4:
      CALL ABCRPR(2)
      P4=ABSCOR
      DO 88 IA=1,2
      L=KABSPR(IA,JSOURC)
      IF (L .GT. 0) DERIVA(L)=DERABQ(IA)
  88  CONTINUE
C
C P5 - PEAK FUNCTION:
      CALL PFXX(2)
      P5=YNORM
C
C ADJUST DERIVATIVES WRT ZERO POINT:
      DO 14 I=1,NZERSP(JPHASE,JSOURC)
      L=KZROSP(I,JPHASE,JSOURC)
      IF (L .GT. 0) DERIVA(L)=DYNDKQ*DKDZER(I)
  14  CONTINUE
C
C ADJUST DERIVATIVES WRT PEAK CENTRE PARAMETERS, IF ANY:
      DO 13 I=1,NPKCSP(JPHASE,JSOURC)
      L=KPCNSP(I,JPHASE,JSOURC)
      IF (L .GT. 0) DERIVA(L)=DYNDKQ*DTDPCN(I)
  13  CONTINUE
C
C TAKE DERIVATIVES AS FORMED BY PFXX AND PUT INTO DERIVA
C ^^^^^ WE COULD CONSIDER ADDING CONTRIBUTIONS IN SIGS AND GAMS RATHER THAN
C ^^^^^ JUST SWITCHING BETWEEN A FUNCTIONAL VARIATION AND A SPECIAL REFINEMENT
C ^^^^^ I.E. S^2 = S1^2 + S2^2
      DO 12 I=1,NPKGEN(JPHASE,JSOURC)
      DDDTEM=DYNDVQ(I)
C IF SAPS OR APES, AND REFINING THIS SIGS/GAMS:
      IF (RIET .OR. CAIL) GO TO 29
C ^^^^^ INSTEAD OF 4 IN THE FOLLOWING LINE WE MAY WISH, AT A LATER DATE,
C ^^^^^ TO CONNECT THE GENERA OF FAMILIES 2 & 4 ASSOCIATED WITH THE
C ^^^^^ SAME VARIABLE. I.E. INSTEAD OF 4 WE HAVE I4PD(I)
C      IF (I .NE. 4) GO TO 29
C ^^^^^ THE FOLLOWING IS A BIT OBSCURE AND QUIRKY
      IF (TOF) THEN
        IG=I-2
      ELSE
        IG=I+1
      ENDIF
      IF (IG .NE. 2 .AND. IG .NE. 3) GO TO 29
      IF (KF4PAR(IG,KNOW) .GT. 0) THEN
**** CHECK THIS - SHOULD BE DERIVATIVE OF P5 WRT SIGS
C ^^^^^ NEXT LINE MAY HAVE DPDDPD(I,2) MULTIPLIED IN AT A LATER DATE.
        DERIV4(IG)=DDDTEM
        GO TO 12
      ENDIF
  29  DO 112 J=1,NPKFSP(I,JPHASE,JSOURC)
C ^^^^^ NEXT LINE MAY HAVE DPDDPD(I,1) MULTIPLIED IN AT A LATER DATE.
      L=KPFNSP(I,J,JPHASE,JSOURC)
      IF (L .GT. 0) DERIVA(L)=DDDTEM*DERPFN(I,J)
  112 CONTINUE
   12 CONTINUE
C
C NOW CELL PARAMETERS, A* - F*, WHOSE DERIVATIVES SO FAR ARE OF D*SQUARED:
      IF (CN .OR. LX) FAC=DKDDS
      IF (TOF) FAC=DTDWL*(-0.5*ALAMBD(1,JSOURC))/DSTAR2
      DO 10 I=1,6
C CHAIN RULE: YNORM - ARGK - D*SQRD - CELL PARAM.
      L=KCPARS(I)
      IF (L .GT. 0) DERIVA(L)=DYNDKQ*CDERS(I)*FAC
   10 CONTINUE
C
C
      GCALC = P1*P2*P3*P4*P5
      YPEAK=YPEAK+GCALC
C
C PUT APPROXIMATION TO I(CALC) INTO COMM0N:
      AICALC(KNOW)=P1*P2
C
C SET GGCALC(K FOR THIS I), AND ADD P5 IN TO SOMEGA(K):
      CALL RFACPR(6,PCXX)
C
C FAMILIES 1,2,3:
C THIS ONLY WORKS IF WE DO NOT HAVE 2 CAIL PHASES:
      DO 6 I=1,L123
   6  DERIVV(L1ST+I)=DERIVV(L1ST+I) + DERIVA(L1ST+I)*GCALC
C FAMILY 4:
      IF (.NOT. RIET) THEN
C WE NOW PICK UP WHICHEVER FAMILY 4 GENERA ARE BEING REFINED
** THIS WON'T BE RIGHT YET BUT COULD BE WORKED ON:
** (AND ONCE RIGHT, IT COULD BE SET ONCE ONLY RATHER THAN EVERY TIME):
        L4ST=1
        L4FIN=1
        IF (.NOT. CAIL) L4FIN=4
        DO 42 I=L4ST,L4FIN
        L4=KF4PAR(I,KNOW)
        IF (L4 .NE. 0) DERIVV(L4)=DERIVV(L4)+DERIV4(I)*GCALC
  42    CONTINUE
      ENDIF
C FAMILY 6:
C SCALE DERIVATIVES:
      L=KSCALS(JSOURC)
      IF (L.GT.0) DERIVV(L)=DERIVV(L) + DERIVA(L)*GCALC
      DO 7 IA=1,2
      L=KABSPR(IA,JSOURC)
      IF (L.GT.0) DERIVV(L)=DERIVV(L) + DERIVA(L)*GCALC
   7  CONTINUE
  11  CONTINUE
C
 100  RETURN
      END
C
C
C
C
C
C LEVEL 9       SUBROUTINE CALPRD(PCXX,PFXX)
      SUBROUTINE CALPRD(PCXX,PFXX)
C
C 90.28
C  *** CALPRD by JPW/JBF 29-Sept-99 ***
CN almost identical to CALPRM Should be safe for use by both magnetic and non
CN magnetic phases
C
CH Gives calculated function to match observed for all PR applications
CH which involve both nuclear and magnetic structure factors
CA PCXX is the name of the routine giving peak centre
CA PFXX is the name of the routine giving peak function
CP on entry in /PRPKFN/ expects ARGI, the argument for the I'th observation
C
CD Forms GCALC, then summed to make YPEAK
CD Adds derivatives of GCALC into previously cleared DERIVV,
CD gives GGCALC and contributions to SOMEGA.
C
CD GCALC is made from several functions multiplied together.
CD We write GCALC = P1*P2*P3* . . . where:
CD    P1 is an outside multiplying factor containing scale, Lp, multiplicity,
CD       overal tf, etc - it does not contain any structure parameters
CD    P2 is a fuction of both types of structure factor, being
CD             Fc(nuc) squared + Fc(mag) squared
CD    P3 is an extinction correction
CD    P4 is an absorption correction
CD    P5 is the peak function
CD
CD YPEAK is then the sum over contributing k values of GCALC.
C
CD Should work for all refinement types (RIET, CAIL, SAPS, . .)
CD                 all data sources (TOF, CN, LX . . )
C
      LOGICAL TESTOV,LATABS
      COMPLEX FCALC
%      DIMENSION DERIVA(%VVAR%),CDERS(6),PDERS(3),DERIV4(5)
/BRAGG/
/CARDRC/
/CONSTA/
/CELPAR/
/DERVAR/
/DGEOM/
/FCAL/
/F4PARS/
/MCAL/
/OBSCAL/
/OVER/
/PHASE/
/POINTS/
/POSNS/
/PRABSC/
/PRBLEM/
/PREORI/
/PREXTN/
/PRPKCN/
/PRPKFN/
/PRSAVE/
/PRSTAT/
/PRZERO/
/REFINE/
/REFIPR/
/REFLNS/
/SATELL/
/SOURCE/
/SPEED/
/TTHMNC/
      INTEGER NOWSRC
      SAVE NOWSRC
C
C IF X-RAY, DEAL FIRST WITH LP FOR THIS ARGI:
      IF (LX) CALL TTHMLX(2)
C
C 90.57 Check if the source has changed to clear out DERIVA if needed
      IF(NOWSRC.NE.JSOURC) THEN
         NOWSRC=JSOURC
%         CALL GMZER(DERIVA,%VVAR%,1)
      ENDIF
C
C CYCLE OVER K:
      DO 11 KNOW=KMIN,KMAX
C
C THIS KNOW MAY HAVE OCCURRED RECENTLY:
%      KMOD=MOD(KNOW-1,%OLAP%)+1
      REFUSE=(KNOW .EQ. KPOINT(KMOD))
C FORM D* SQUARED,S SQUARED, AND DERIVATIVES WRT RECIPROCAL CELL
C PARAMETERS:
        CALL CELDER(REFH(1,KNOW),CDERS)
        IF (PHMAG(JPHASE))
     &     CALL PROPDR(REFH(1,KNOW),ISMAG(KNOW),PDERS)
        DSTAR(KNOW)=SQRT(DSTAR2)
C
C SET ARGK AND LAMBDA FOR THIS REFLECTION:
      CALL PCXX(2)
C
C CLEAR INTERNAL DERIVATIVES:
      L2=NVARF(2,JPHASE,1)
      L123=NVARF(1,JPHASE,JSOURC)+L2+NVARF(3,JPHASE,JSOURC)*NSOURC
      L1ST=LVFST1(1,JPHASE,JSOURC)
      DO 18 L=1,LVARV
   18 DERIVA(L)=0.0
      SKIPRF=.FALSE.
C
C FORM P1 AND SOME FAMILY 1 QUOTIENT DERIVATIVES (ALL /P1):
C EACH DATA TYPE HAS DIFFERENT FACTOR:
      IF (TOF) FAC=TWSNTH(JSOURC)/(2.*DSTAR2*DSTAR2)
      IF (CN) FAC=1./(SIN(RAD*ARGK)*SIN(0.5*RAD*ARGK))
      IF (LX) FAC=ALPCOR
C Factor of 1/vol put into P1 so it's there for all types of radiation
C FAC is the lorentz correction
      P1=SCALEP(JPHASE)*SCALES(JSOURC)*EXP((-2.)*SSQRD*TFAC)*
     & AMUL(KNOW)*FAC*V(2)
C TFAC DERIVATIVE:
      L=KTFAC
      IF (L .GT. 0) DERIVA(L)=-2.*SSQRD
C SCAL DERIVATIVE:
C 90.31
      L=KSCALS(JSOURC)
      IF (L .GT. 0) THEN
        IF (TESTOV(1.,SCALES(JSOURC))) THEN
          CALL ERRIN2(JSOURC,0,'1./Scale for source','overflows')
        ENDIF
        DERIVA(L)=1./SCALES(JSOURC)
      ENDIF
      L=KSCALP(JPHASE)
      IF (L .GT. 0) THEN
        IF(TESTOV(1.,SCALEP(JPHASE))) THEN
          CALL ERRIN2(JSOURC,0,'1./Scale for phase','overflows')
        ENDIF
        DERIVA(L)=1./SCALEP(JPHASE)
      ENDIF
C
C PREFERRED ORIENTATION:
      IF (NPRTYP .GT. 0) THEN
        L=KPRFPR
        IF (.NOT. REFUSE) THEN
          CALL PREFOR(2)
          SAVPRC(KMOD)=PRFCOR
          IF (L .GT. 0) SAVDPC(KMOD)=DERPRQ
        ENDIF
        P1=P1*SAVPRC(KMOD)
        IF (L .GT. 0) DERIVA(L)=SAVDPC(KMOD)
      ENDIF
C
C IF X-RAY, MONOCHROMATOR ANGLE:
      IF (LX) THEN
        L=KTHMON(JSOURC)
        IF (L .NE. 0) DERIVA(L)=DLPCOR
      ENDIF
C
C NEXT DO P2, THE PART DEPENDENT ON THE STRUCTURE FACTOR:
C IF CAIL, P2 IS SIMPLY F4PAR(1,KNOW):
      IF (CAIL .OR. APES) THEN
C MUST SET KPOINT FOR USE BY FFT NEXT TIME ROUND:
        KPOINT(KMOD)=KNOW
        L4=KF4PAR(1,KNOW)
        IF (L4 .EQ. 0) THEN
C 90.61          IF(PRECYC)F4PAR(1,KNOW)=1.
          F4PAR(1,KNOW)=1.
        ELSE
          DERIV4(1)=1.
        ENDIF
        IF (F4PAR(1,KNOW).NE. 0.) DERIV4(1)=1./F4PAR(1,KNOW)
        P2=F4PAR(1,KNOW)
      ELSE
C SET BASE FOR DERIVATIVES:
        III=LVFST1(2,JPHASE,1)
        IF (.NOT. REFUSE) THEN
C NEW K:
          IF (L2 .GT. 0) THEN
            CALL LFCALC(REFH(1,KNOW))
            P2=FCMOD*FCMOD
            IF(PHMAG(JPHASE)) THEN
              CALL LMCALC(REFH(1,KNOW))
              P2 = P2 + FMCSQR
            ENDIF
            F=0.
            IF (.NOT. TESTOV(2.,P2)) F=2./P2
C CONVERT FAMILY 2 DERIVATIVES FROM BEING 'OF FCMOD' TO 'OF P2'
C DP2/DV = DMODFC/DV * DP2/DMODFC - AND ALL ARE DIVIDED BY P2
C GIVING D(GCALC)/DV OVER GCALC=(DP2/DV OVER P2)
            DO 4 I=1,L2
            IF(PHMAG(JPHASE)) THEN
              DERIVA(III+I)=F*(FCDERS(I)*FCMOD+FMCDER(I))
            ELSE
              DERIVA(III+I)=F*FCDERS(I)*FCMOD
            ENDIF
            SAVDER(I,KMOD)=DERIVA(III+I)
   4        CONTINUE
          ELSE
C 90.15 Need to set FC etc to zero if reflection is absent
            IF(LATABS(REFH(1,KNOW))) THEN
             FC=CMPLX(0.,0.)
             FCMOD=0.
             COSAL=0.
             SINAL=0.
            ELSE
             FC=FCALC(REFH(1,KNOW))
            ENDIF
            P2=0.0
            P2NUC=FC*CONJG(FC)
            IF(PHMAG(JPHASE)) THEN
              CALL FMCALC(REFH(1,KNOW),FMCMOD,FMCSQR)
              P2=FMCSQR
            ENDIF
            P2=P2+P2NUC
            FCMOD=SQRT(P2NUC)
          ENDIF
C
          KPOINT(KMOD)=KNOW
**NB IF WE ARE RIGHT ABOUT FCMOD & P2 & SAVING, WE NEED BOTH FCMOD & P2 HERE
** BECAUSE YOU CANNOT DEDUCE ONE FROM THE OTHER
          SAVP2(KMOD)=P2
          SAVFCN(KMOD)=FCMOD
        ELSE
C
C P2 FOR THIS K SAVED WHEN USED PREVIOUSLY:
          P2=SAVP2(KMOD)
          FCMOD=SAVFCN(KMOD)
          DO 420 I=1,L2
 420      DERIVA(III+I)=SAVDER(I,KMOD)
        ENDIF
      ENDIF
C
C P3:
      CALL EXCRPR(2)
      P3=EXTCO
      DP2DFQ=DP2DFQ+DXDFQ
      L=KEXTPR
      IF (L .GT. 0) DERIVA(L)=DEREXQ
C
C P4:
      CALL ABCRPR(2)
      P4=ABSCOR
      DO 88 IA=1,2
      L=KABSPR(IA,JSOURC)
      IF (L .GT. 0) DERIVA(L)=DERABQ(IA)
  88  CONTINUE
C
C P5 - PEAK FUNCTION:
C OPTIMISATION/SPEED up to have short tails on weaker peaks
      CURFAC=P1*P2*P3*P4
      CURESD=DOBS
      CALL PFXX(2)
C Go onto next reflection if this one is to be skipped
      IF (SKIPRF) GOTO 11
      P5=YNORM
C
C ADJUST DERIVATIVES WRT ZERO POINT:
      DO 14 I=1,NZERSP(JPHASE,JSOURC)
      L=KZROSP(I,JPHASE,JSOURC)
      IF (L .GT. 0) DERIVA(L)=DYNDKQ*DKDZER(I)
  14  CONTINUE
C
C ADJUST DERIVATIVES WRT PEAK CENTRE PARAMETERS, IF ANY:
      DO 13 I=1,NPKCSP(JPHASE,JSOURC)
      L=KPCNSP(I,JPHASE,JSOURC)
      IF (L .GT. 0) DERIVA(L)=DYNDKQ*DTDPCN(I)
  13  CONTINUE
C
C TAKE DERIVATIVES AS FORMED BY PFXX AND PUT INTO DERIVA
      DO 12 I=1,NPKGEN(JPHASE,JSOURC)
      DDDTEM=DYNDVQ(I)
C IF SAPS OR APES, AND REFINING THIS SIGS:
      IF (RIET .OR. CAIL) GO TO 29
C      IF (I .NE. 4) GO TO 29
      IG=I+1
      IF (TOF) IG=I-2
      IF (IG .NE. 2 .AND. IG .NE. 3) GO TO 29
      IF (KF4PAR(IG,KNOW) .GT. 0) THEN
**** CHECK THIS - SHOULD BE DERIVATIVE OF P5 WRT SIGS
        DERIV4(IG)=DDDTEM
        GO TO 12
      ENDIF
  29  DO 112 J=1,NPKFSP(I,JPHASE,JSOURC)
      L=KPFNSP(I,J,JPHASE,JSOURC)
      IF (L .GT. 0) DERIVA(L)=DDDTEM*DERPFN(I,J)
  112 CONTINUE
   12 CONTINUE
C
C NOW CELL PARAMETERS, A* - F*, WHOSE DERIVATIVES SO FAR ARE OF D*SQUARED:
      IF (CN .OR. LX) FAC=DKDDS
      IF (TOF) FAC=DTDWL*(-0.5*ALAMBD(1,JSOURC))/DSTAR2
      DO 10 I=1,6
C CHAIN RULE: YNORM - ARGK - D*SQRD - CELL PARAM.
      L=KCPARS(I)
      IF (L .GT. 0) DERIVA(L)=DYNDKQ*CDERS(I)*FAC
   10 CONTINUE
C
C DERIVS OF PROPAGATION VECTOR
      IF(PHMAG(JPHASE)) THEN
        DO 15 I=1,3
        L=KPROP(I)
        IF (L.GT.0) DERIVA(L)=DYNDKQ*PDERS(I)*FAC
   15   CONTINUE
      ENDIF
C
      GCALC = P1*P2*P3*P4*P5
      YPEAK=YPEAK+GCALC
C
C PUT APPROXIMATION TO I(CALC) INTO COMMON:
      AICALC(KNOW)=P1*P2*P3*P4
C
C SET GGCALC(K FOR THIS I), AND ADD P5 IN TO SOMEGA(K):
C      CALL RFACPR(6,PCXX)
      GGCALC(KNOW-KMIN+1)=GCALC
      SOMEGA(KNOW)=SOMEGA(KNOW)+P5
C
C
C FAMILIES 1,2,3:
C      DO 6 I=1,L123
C   6  DERIVV(L1ST+I)=DERIVV(L1ST+I) + DERIVA(L1ST+I)*GCALC
C FAMILY 4:
      IF (.NOT. RIET) THEN
        IF (L4 .NE. 0) DERIVV(L4)=DERIVV(L4)+DERIV4(1)*GCALC
      ENDIF
C FAMILY 6:
C SCALE DERIVATIVES:
C      L=KSCALS(JSOURC)
C      IF (L.GT.0) DERIVV(L)=DERIVV(L) + DERIVA(L)*GCALC
C      DO 7 IA=1,2
C      L=KABSPR(IA,JSOURC)
C      IF (L.GT.0) DERIVV(L)=DERIVV(L) + DERIVA(L)*GCALC
C 90.61 Keep all derivatives - I hope
      DO 7 L=1,LVARV
   7  DERIVV(L)=DERIVV(L)+DERIVA(L)*GCALC
  11  CONTINUE
C
 100  RETURN
      END
C
C
C
C
C LEVEL 9       SUBROUTINE CALPRM(PCXX,PFXX)
      SUBROUTINE CALPRM(PCXX,PFXX)
C
C  *** CALPRM updated by JBF 13 JAN 1995 ***
C
CH Gives calculated function to match observed for all PR applications
CH which involve both nuclear and magnetic structure factors
CA PCXX is the name of the routine giving peak centre
CA PFXX is the name of the routine giving peak function
CP on entry in /PRPKFN/ expects ARGI, the argument for the I'th observation
C
CD Forms GCALC, then summed to make YPEAK
CD Adds derivatives of GCALC into previously cleared DERIVV, and via RFACPR
CD gives GGCALC and contributions to SOMEGA.
C
CD GCALC is made from several functions multiplied together.
CD We write GCALC = P1*P2*P3* . . . where:
CD    P1 is an outside multiplying factor containing scale, Lp, multiplicity,
CD       overal tf, etc - it does not contain any structure parameters
CD    P2 is a fuction of both types of structure factor, being
CD             Fc(nuc) squared + Fc(mag) squared
CD    P3 is an extinction correction
CD    P4 is an absorption correction
CD    P5 is the peak function
CD
CD YPEAK is then the sum over contributing k values of GCALC.
C
CD Should work for all refinement types (RIET, CAIL, SAPS, . .)
CD                 all data sources (TOF, CN, LX . . )
C
      EXTERNAL PCXX,PFXX
      LOGICAL TESTOV,LATABS
      COMPLEX FCALC
%      DIMENSION DERIVA(%VVAR%),CDERS(6),PDERS(3),DERIV4(5)
/BRAGG/
/CARDRC/
/CONSTA/
/CELPAR/
/DERVAR/
/DGEOM/
/FCAL/
/F4PARS/
/MCAL/
/OBSCAL/
/OVER/
/PHASE/
/POINTS/
/POSNS/
/PRABSC/
/PRBLEM/
/PREORI/
/PREXTN/
/PRPKCN/
/PRPKFN/
/PRSAVE/
/PRSTAT/
/PRZERO/
/REFINE/
/REFIPR/
/REFLNS/
/SATELL/
/SOURCE/
/TTHMNC/
C
C IF X-RAY, DEAL FIRST WITH LP FOR THIS ARGI:
      IF (LX) CALL TTHMLX(2)
C
C CYCLE OVER K:
      DO 11 KNOW=KMIN,KMAX
C
C THIS KNOW MAY HAVE OCCURRED RECENTLY:
%      KMOD=MOD(KNOW-1,%OLAP%)+1
      REFUSE=(KNOW .EQ. KPOINT(KMOD))
C FORM D* SQUARED,S SQUARED, AND DERIVATIVES WRT RECIPROCAL CELL
C PARAMETERS:
        CALL CELDER(REFH(1,KNOW),CDERS)
        IF (MAG) CALL PROPDR(REFH(1,KNOW),ISMAG(KNOW),PDERS)
        DSTAR(KNOW)=SQRT(DSTAR2)
C
C SET ARGK AND LAMBDA FOR THIS REFLECTION:
      CALL PCXX(2)
C
C CLEAR INTERNAL DERIVATIVES:
      L2=NVARF(2,JPHASE,1)
      L123=NVARF(1,JPHASE,JSOURC)+L2+NVARF(3,JPHASE,JSOURC)*NSOURC
      L1ST=LVFST1(1,JPHASE,1)
C
C FORM P1 AND SOME FAMILY 1 QUOTIENT DERIVATIVES (ALL /P1):
C EACH DATA TYPE HAS DIFFERENT FACTOR:
      IF (TOF) FAC=1./(DSTAR2*DSTAR2)
      IF (CN) FAC=1./(SIN(RAD*ARGK)*SIN(0.5*RAD*ARGK))
      IF (LX) FAC=ALPCOR*V(2)*V(2)
      P1=SCALEP(JPHASE)*SCALES(JSOURC)*EXP((-2.)*SSQRD*TFAC)*
     & AMUL(KNOW)*FAC
C TFAC DERIVATIVE:
      L=KTFAC
      IF (L .GT. 0) DERIVA(L)=-2.*SSQRD
C SCAL DERIVATIVE:
      L=KSCALS(JSOURC)
      IF (L .GT. 0) DERIVA(L)=1./SCALES(JSOURC)
      L=KSCALP(JPHASE)
      IF (L .GT. 0) DERIVA(L)=1./SCALEP(JPHASE)
C
C PREFERRED ORIENTATION:
      IF (NPRTYP .GT. 0) THEN
        L=KPRFPR
        IF (.NOT. REFUSE) THEN
          CALL PREFOR(2)
          SAVPRC(KMOD)=PRFCOR
          IF (L .GT. 0) SAVDPC(KMOD)=DERPRQ
        ENDIF
        P1=P1*SAVPRC(KMOD)
        IF (L .GT. 0) DERIVA(L)=SAVDPC(KMOD)
      ENDIF
C
C IF X-RAY, MONOCHROMATOR ANGLE:
      IF (LX) THEN
        L=KTHMON(JSOURC)
        IF (L .NE. 0) DERIVA(L)=DLPCOR
      ENDIF
C
C NEXT DO P2, THE PART DEPENDENT ON THE STRUCTURE FACTOR:
C IF CAIL, P2 IS SIMPLY F4PAR(1,KNOW):
      IF (CAIL .OR. APES) THEN
C MUST SET KPOINT FOR USE BY FFT NEXT TIME ROUND:
        KPOINT(KMOD)=KNOW
        L4=KF4PAR(1,KNOW)
        IF (L4 .EQ. 0) THEN
          F4PAR(1,KNOW)=1.
        ELSE
          DERIV4(1)=1.
        ENDIF
        IF (F4PAR(1,KNOW).NE. 0.) DERIV4(1)=1./F4PAR(1,KNOW)
        P2=F4PAR(1,KNOW)
      ELSE
C SET BASE FOR DERIVATIVES:
        III=LVFST1(2,JPHASE,1)
        IF (.NOT. REFUSE) THEN
C NEW K:
          IF (L2 .GT. 0) THEN
            CALL LFCALC(REFH(1,KNOW))
            CALL LMCALC(REFH(1,KNOW))
            P2=FCMOD*FCMOD + FMCSQR
            F=0.
            IF (.NOT. TESTOV(2.,P2)) F=2./P2
C CONVERT FAMILY 2 DERIVATIVES FROM BEING 'OF FCMOD' TO 'OF P2'
C DP2/DV = DMODFC/DV * DP2/DMODFC - AND ALL ARE DIVIDED BY P2
C GIVING D(GCALC)/DV OVER GCALC=(DP2/DV OVER P2)
            DO 4 I=1,L2
            DERIVA(III+I)=F*(FCDERS(I)*FCMOD+FMCDER(I))
            SAVDER(I,KMOD)=DERIVA(III+I)
   4        CONTINUE
          ELSE
C 90.15 Need to set FC etc to zero if reflection is absent
            IF(LATABS(REFH(1,KNOW))) THEN
             FC=CMPLX(0.,0.)
             FCMOD=0.
             COSAL=0.
             SINAL=0.
            ELSE
             FC=FCALC(REFH(1,KNOW))
            ENDIF
            CALL FMCALC(REFH(1,KNOW),FMCMOD,FMCSQR)
            P2NUC=FC*CONJG(FC)
            P2=P2NUC + FMCSQR
            FCMOD=SQRT(P2NUC)
          ENDIF
C
          KPOINT(KMOD)=KNOW
**NB IF WE ARE RIGHT ABOUT FCMOD & P2 & SAVING, WE NEED BOTH FCMOD & P2 HERE
** BECAUSE YOU CANNOT DEDUCE ONE FROM THE OTHER
          SAVP2(KMOD)=P2
          SAVFCN(KMOD)=FCMOD
        ELSE
C
C P2 FOR THIS K SAVED WHEN USED PREVIOUSLY:
          P2=SAVP2(KMOD)
          FCMOD=SAVFCN(KMOD)
          DO 420 I=1,L2
 420      DERIVA(III+I)=SAVDER(I,KMOD)
        ENDIF
      ENDIF
C
C P3:
      CALL EXCRPR(2)
      P3=EXTCO
      DP2DFQ=DP2DFQ+DXDFQ
      L=KEXTPR
      IF (L .GT. 0) DERIVA(L)=DEREXQ
C
C P4:
      CALL ABCRPR(2)
      P4=ABSCOR
      DO 88 IA=1,2
      L=KABSPR(IA,JSOURC)
      IF (L .GT. 0) DERIVA(L)=DERABQ(IA)
  88  CONTINUE
C
C P5 - PEAK FUNCTION:
      CALL PFXX(2)
      P5=YNORM
C
C ADJUST DERIVATIVES WRT ZERO POINT:
      DO 14 I=1,NZERSP(JPHASE,JSOURC)
      L=KZROSP(I,JPHASE,JSOURC)
      IF (L .GT. 0) DERIVA(L)=DYNDKQ*DKDZER(I)
  14  CONTINUE
C
C ADJUST DERIVATIVES WRT PEAK CENTRE PARAMETERS, IF ANY:
      DO 13 I=1,NPKCSP(JPHASE,JSOURC)
      L=KPCNSP(I,JPHASE,JSOURC)
      IF (L .GT. 0) DERIVA(L)=DYNDKQ*DTDPCN(I)
  13  CONTINUE
C
C TAKE DERIVATIVES AS FORMED BY PFXX AND PUT INTO DERIVA
      DO 12 I=1,NPKGEN(JPHASE,JSOURC)
      DDDTEM=DYNDVQ(I)
C IF SAPS OR APES, AND REFINING THIS SIGS:
      IF (RIET .OR. CAIL) GO TO 29
C      IF (I .NE. 4) GO TO 29
      IG=I+1
      IF (TOF) IG=I-2
      IF (IG .NE. 2 .AND. IG .NE. 3) GO TO 29
      IF (KF4PAR(IG,KNOW) .GT. 0) THEN
**** CHECK THIS - SHOULD BE DERIVATIVE OF P5 WRT SIGS
        DERIV4(IG)=DDDTEM
        GO TO 12
      ENDIF
  29  DO 112 J=1,NPKFSP(I,JPHASE,JSOURC)
      L=KPFNSP(I,J,JPHASE,JSOURC)
      IF (L .GT. 0) DERIVA(L)=DDDTEM*DERPFN(I,J)
  112 CONTINUE
   12 CONTINUE
C
C NOW CELL PARAMETERS, A* - F*, WHOSE DERIVATIVES SO FAR ARE OF D*SQUARED:
      IF (CN .OR. LX) FAC=DKDDS
      IF (TOF) FAC=DTDWL*(-0.5*ALAMBD(1,JSOURC))/DSTAR2
      DO 10 I=1,6
C CHAIN RULE: YNORM - ARGK - D*SQRD - CELL PARAM.
      L=KCPARS(I)
      IF (L .GT. 0) DERIVA(L)=DYNDKQ*CDERS(I)*FAC
   10 CONTINUE
C
C DERIVS OF PROPAGATION VECTOR
      DO 15 I=1,3
      L=KPROP(I)
      IF (L.GT.0) DERIVA(L)=DYNDKQ*PDERS(I)*FAC
   15 CONTINUE
C
      GCALC = P1*P2*P3*P4*P5
      YPEAK=YPEAK+GCALC
C
C PUT APPROXIMATION TO I(CALC) INTO COMMON:
      AICALC(KNOW)=P1*P2
C
C SET GGCALC(K FOR THIS I), AND ADD P5 IN TO SOMEGA(K):
      CALL RFACPR(6,PCXX)
C
C
C FAMILIES 1,2,3:
      DO 6 I=1,L123
   6  DERIVV(L1ST+I)=DERIVV(L1ST+I) + DERIVA(L1ST+I)*GCALC
C FAMILY 4:
      IF (.NOT. RIET) THEN
        IF (L4 .NE. 0) DERIVV(L4)=DERIVV(L4)+DERIV4(1)*GCALC
      ENDIF
C FAMILY 6:
C SCALE DERIVATIVES:
      L=KSCALS(JSOURC)
      IF (L.GT.0) DERIVV(L)=DERIVV(L) + DERIVA(L)*GCALC
      DO 7 IA=1,2
      L=KABSPR(IA,JSOURC)
      IF (L.GT.0) DERIVV(L)=DERIVV(L) + DERIVA(L)*GCALC
   7  CONTINUE
  11  CONTINUE
C
 100  RETURN
      END
C
C
C
C
C LEVEL 9      SUBROUTINE CONTRI(PCXX,PFXX,IUNI)
      SUBROUTINE CONTRI(PCXX,PFXX,IUNI)
C
C *** CONTRI BY JCM 26 Sep 90 ***
C
CH Determines which (if any) reflections contribute to a given data point
CH And does other processing, writing to temporary file
C
      EXTERNAL PCXX,PFXX
      LOGICAL CONT,EXCLD
      DIMENSION TEMP(6)
/BRAGG/
/EXCREG/
/OBSCAL/
/PHASE/
/PRPKCN/
/PRPKFN/
/PRSTAT/
/REFLNS/
/SOURCE/
C
C NON-ZERO CODE FOR EXCLUDED REGIONS:
      ICODE=0
      IF (NEXCL(JSOURC) .NE. 0) THEN
        IF (EXCLD(ARGI,EXCLUD(1,JSOURC),NEXCL(JSOURC))) ICODE=1
      ENDIF
C
C DISCOVER LOWER AND UPPER LIMITS OF REFLECTION NUMBERS CONTRIBUTING TO THIS:
      CONT=.FALSE.
      IF (ICODE .EQ. 0) THEN
C 90.13
C First reflection is LRFSRC(JSOURC-1,JPHASE)+1
        IF(JSOURC .EQ. 1) THEN
         IFIRST=1
        ELSE
         IFIRST=LRFSRC(JSOURC-1,JPHASE)+1
        ENDIF
C 90.32
        IF(KMIN .LT. IFIRST) KMIN=IFIRST
C 90.13 The 10 remains arbitrary (can it be 1?)
        KM=KMIN-10
        IF (KM .LT.IFIRST) KM=IFIRST
        DO 1 KNOW=KM,LRFSRC(JSOURC,JPHASE)
        CALL CELDER(REFH(1,KNOW),TEMP)
        DSTAR(KNOW)=SQRT(DSTAR2)
        CALL PCXX(5)
        CALL PFXX(5)
        IF (.NOT.REFUSE) THEN
          CONT=.TRUE.
          KMAX=KNOW
C SET 'WE HAVE AT LEAST ONE CONTRIBUTING REFLECTION':
        ELSE
          IF (ARGK .GT. ARGI) GO TO 2
          KMIN=KNOW+1
        ENDIF
C
   1    CONTINUE
C
C KMAX=0 IF NONE CONTRIBUTING, OTHERWISE = NUMBER OF LAST CONTRIBUTING:
   2    CONTINUE
      ENDIF
      IF (.NOT. CONT) KMAX=0
C
C GET WEIGHT INTO WT:
      IF (JPHASE .EQ. 1) CALL WGHTLS(2,ARGI)
C COLLECT LARGEST:
** NOT YET USED & NOT YET IN COMMON
      YMAX=AMAX1(YMAX,OBS)
C WRITE OUT TO SCRATCH DATASET, UNFORMATTED, FOR REINPUT EVERY CYCLE:
      IF (JPHASE .EQ. 1) NOBS=NOBS+1
      KMI(JPHASE)=KMIN
      KMA(JPHASE)=KMAX
      YOLD=0.0
C 90.53 Check not too many refs overlapping
%      IF((KMAX-KMIN).GT.%OMAX%)
     & CALL ERRRE2(ARGI,0,'For x=',
%     & ' there are too many overlapping reflections. Increase OMAX')
      WRITE (IUNI) ARGI,OBS,DOBS,WT,ICODE,JSOURC,(KMI(J),
     & KMA(J),J=1,NPHASE),YOLD
      RETURN
      END
C
C
C
C
C LEVEL 1      LOGICAL FUNCTION DFLTD2(IFAM,IGEN,ISPC)
      LOGICAL FUNCTION DFLTD2(IFAM,IGEN,ISPC)
C
C *** DFLTD2 moved by JCM to PR section 23 March 92 ***
C
CX
CC 7A
CH Called as a substitute for DEFALT out of VARMAK in main program CELLSQ
CA On entry IFAM, ISPC, IGEN give family, genus, species of parameter
CA On exit LOGICAL DFLTD2 is TRUE if the parameter is to be varied, or
CA                           FALSE if to be fixed.
C
C ONLY VARY CELL BY DEFAULT:
C TO KEEP COMPILERS HAPPY:
      I=IFAM
      DFLTD2=(IGEN .EQ. 1 .AND. ISPC .LE. 6)
      RETURN
      END
C
C
C
C
C LEVEL 1      LOGICAL FUNCTION DFLTPR(IFAM,IGEN,ISPC)
      LOGICAL FUNCTION DFLTPR(IFAM,IGEN,ISPC)
C
C *** DFLTPR updated by JCM 17 Apr 89 ***
C
CH Gives default setting of fix/vary for parameters of PR LSQ (CN, LX, TOF . .)
CA IFAM,IGEN,ISPC on entry specify parameter
CA DFLTPR on exit is TRUE if the parameter is by default varied, FALSE fixed
CD Called as substitute for DEFALT out of VARMAK
C
/ANISO/
/MAGDAT/
C
C JPW      DFLTPR=.TRUE.
C No long justification - I *always* say "vary only scal", so killing the only.
C For multiphase it's a pain to refine nothing otherwise.
      DFLTPR=.FALSE.
C VARY ANYTHING GIVEN IN FAMILIES 1, 3  AND 4:
      GO TO (100,2,100,100,100,100) , IFAM
      GO TO 100
C
C IN FAMILY 2 MOSTLY VARY, BUT FIX SITE:
   2  IF (ISPC .LT. 10) GO TO 100
      IF (ISPC .EQ. 11) GO TO 101
C IF VARYING ITF BY DEFAULT, CHECK THERE IS NOT ALSO ATF:
      IF (ISPC .EQ. 12) THEN
        IF (IAPT(IGEN) .EQ. 0) GO TO 100
        GO TO 101
      ENDIF
      IF (ISPC .GT. 12) THEN
        IF (MAGAT(IGEN) .NE. 0) GO TO 100
      ENDIF
C
C FIX:
 101  DFLTPR=.FALSE.
 100  RETURN
      END
C
C
C
C
C LEVEL 5      SUBROUTINE EIGEN(ALSQ,MATSZ)
      SUBROUTINE EIGEN(ALSQ,MATSZ)
C
C *** EIGEN redefined by JCM 14 Jan 93 ***
C
CX
CC 19B
CH Writes eigenvalues and eigenvectors of normal matrix for CAIL
CH intensities to a file, and/or the matrix itself.
C
CA ALSQ and MATSZ specify the LSQ matrix in the usual way.
CP For a CAIL refinement, NVARF must hold information about family 4 parameters
CP On an I card read by IICD2, the integer after PREE signals:
CP      containing 1= print eigenvalues, send both values & vectors
CP                    to binary file .EIG
CP      containing 2= as 1, but print both values & vectors.
CP      containing 100= print matrix to binary file .IHM (for Intesity Hessian
CP                    matrix.
CO Writes eigenvalues of the matrix on the printer output
CO Writes eigenvalues and eigenvectors, unformatted, to a file whose name
CO is requested intetractively, and whose default extension is .EIG
CO Writes the original matrix to a file whose name is requested interactively,
CO and whose default extension is .IHM.
C
      DIMENSION ALSQ(MATSZ)
%      DIMENSION A(%BVAR%,%BVAR%),D(%BVAR%),E(%BVAR%)
/IOUNIT/
/PHASE/
/PRBLEM/
/PRPKFN/
/REFINE/
/REFIPR/
/SCRACH/
C
C OUT IF LIST NOT WANTED:
       IF (SIMUL .OR. .NOT. CAIL .OR. IPRNT(6) .EQ. 0) GO TO 100
C
      I1=IPRNT(6)/100
      I2=IPRNT(6)-I1*100
C
C SET UP MATRIX FROM INVERSE LSQ MATRIX:
C NUMBER OF BASIC VARIABLES IN FAMILY 4:
*** ??? SUSPECT NEED FOR CYCLE OVER PHASES:
      N=NBARF(4,JPHASE,1)
      L=LBFST1(4,JPHASE,1)
      DO 5 I=1,N
      DO 6 J=I,N
      A(I,J)=ELEMAT(ALSQ,MATSZ,I+L,J+L)
      A(J,I)=A(I,J)
   6  CONTINUE
   5  CONTINUE
C
C PRINT MATRIX IF REQUIRED:
      IF (I1 .NE. 0) THEN
        MESSAG='intensity Hessian matrix'
        NAMFIL='.IHM'
        IHM=NOPFIL(1112)
        DO 9 I=1,N
        WRITE (IHM) (A(L,I),L=1,N)
   9    CONTINUE
      ENDIF
      IF (I2 .NE. 0) THEN
        MESSAG='eigenvalues & vectors'
        NAMFIL='.EIG'
        MAT=NOPFIL(1112)
C HOUSEHOLDER:
%        CALL TRED2(A,N,%BVAR%,D,E,.TRUE.)
C QL:
%        CALL TQLI(D,E,N,%BVAR%,A,.TRUE.)
C
C PRINT EIGENVALUES:
        CALL MESS(LPT,2,
     &  'Eigenvalues of normal LSQ matrix relating to INTS:')
        DO 1 I=1,N
        IF (I2 .EQ. 1) WRITE (LPT,2001) D(I)
2001    FORMAT (1X,G12.3)
        IF (I2 .EQ. 2) WRITE (LPT,2002) D(I),(A(L,I),L=1,N)
2002    FORMAT (/1X,G12.3/(1X,7G11.3))
C AND UNFORMATTED TO UNIT MAT:
        WRITE (MAT) D(I),(A(L,I),L=1,N)
   1    CONTINUE
      ENDIF
C
 100  RETURN
      END
C
C
C
C
C LEVEL 3      SUBROUTINE EXCLIN
      SUBROUTINE EXCLIN
C
C *** EXCLIN by JCM 18 Jun 85 ***
C
C INTRPETS ONE L EXCL CARD
C
/CARDRC/
/EXCREG/
/IOUNIT/
/SOURCE/
C
      IPT=7
      N=NEXCL(KSOURC)+1
C READ PAIRS OF NUMBERS TILL END OF CARD:
   1  CALL RDREAL(EXCLUD(NEXCL(KSOURC)+1,KSOURC),IPT,IPT,80,IER)
      IF (IER .EQ. 100) GO TO 101
C
C CHECK NOT TOO MANY:
      IER=IERR
%      CALL ERRCHK(1,NEXCL(KSOURC),%EXCL%,1,'excluded regions')
      IF (IER .NE. IERR) GO TO 100
C
      CALL RDREAL(EXCLUD(NEXCL(KSOURC)+2,KSOURC),IPT,IPT,80,IER)
      NEXCL(KSOURC)=NEXCL(KSOURC)+2
      IF (NEXCL(KSOURC).EQ.2) GO TO 1
      IF (EXCLUD(NEXCL(KSOURC)-1,KSOURC) .LT. EXCLUD(NEXCL(KSOURC)-2,
     & KSOURC)) GO TO 3
      IF (EXCLUD(NEXCL(KSOURC),KSOURC) .GT. EXCLUD(NEXCL(KSOURC)-1,
     & KSOURC)) GO TO 1
   3  WRITE (LPT,3000) EXCLUD(NEXCL(KSOURC),KSOURC),EXCLUD(NEXCL(KSOURC)
     & -1,KSOURC)
      WRITE (ITO,3000) EXCLUD(NEXCL(KSOURC),KSOURC),EXCLUD(NEXCL(KSOURC)
     & -1,KSOURC)
3000  FORMAT (/' ERROR ** boundaries for excluded regions',
     & 'not in strictly ascending order'/' Pair',F12.2,' and',F12.2)
      IERR=IERR+1
      GO TO 100
C
 101  WRITE (LPT,2000) (EXCLUD(I,KSOURC),I=N,NEXCL(KSOURC))
2000  FORMAT(/' Exclude '/(1X,F12.2,' TO',F12.2/))
 100  RETURN
      END
C
C
C
C
C LEVEL 8      SUBROUTINE EXCRPR(N)
      SUBROUTINE EXCRPR(N)
C
C *** EXCRPR by JCM 9 May 88 ***
C
CH Multiple entry routine to deal with all aspects of extinction corrections
CH  for profile refinement
C
/BRAGG/
/CELPAR/
/DGEOM/
/FCAL/
/IOUNIT/
/NEWOLD/
/PREXTN/
/REFINE/
/REFIPR/
/SOURCE/
C
      GO TO (1,2,3,4,5,6) , N
C
C GIVEN AN 'L EXTN' CARD IN COMM0N /SCRACH/, READ REST OF IT:
   1  CALL RDINTG(NEXTYP,7,IPT,80,IER)
C DO NOT LOOK FURTHER AT NEXTYP YET AS 1 IS ASSUMED
      IF (TOF) THEN
        WRITE (LPT,2000) NEXTYP
2000    FORMAT (/' Type ',I2,' extinction correction -- simple Bragg',
     &  ' model'/'      (ref. Sabine, Aust. J. Phys. 1985,38,507.) ')
      ENDIF
      CALL RDREAL (EXTPR,IPT,IPT,80,IER)
      WRITE (LPT,2005) EXTPR
2005  FORMAT (/' Extinction correction parameter =',F10.4,' microns ')
      IF (EXTPR .EQ. 0.) GO TO 10
      GO TO 100
C
C FORM EXTINCTION CORRECTION WHICH WILL BE P3 IN CALxx, AND DERIVATIVE:
   2  IF (EXTPR .EQ. 0.) GO TO 10
C ONLY FOR TOF AT PRESENT:
C 90.54 Try it for CN too. Needs to be source dependant one day
      IF (.NOT. TOF .AND. .NOT. CN) GO TO 10
      UCOF=0.75*ALAMBD(1,JSOURC)*V(2)
      UTEM=UCOF*FCMOD
      UALP=UCOF*EXTPR
      UEXT=UTEM*EXTPR
      EXTCO=1./(1.+UEXT*UEXT)
      DEREXQ=-EXTCO*UTEM*UEXT
      DXDFQ=-EXTCO*UALP*UEXT
      EXTCO= SQRT(EXTCO)
      GO TO 100
C
C APPLY SHIFT IN COEFFICIENT:
   3  CALL ADJUST(EXTPR)
      GO TO 100
C
C WRITE OUT NEW 'L EXTN' CARD FOR TOF:
   4  WRITE (NEWIN,2001) NEXTYP,EXTPR
2001  FORMAT ('L EXTN',2X,I2,1X,F10.4)
      GO TO 100
C
C
C DEAL WITH ABSENCE OF 'L EXTN' CARD:
   5  CALL MESS(LPT,1,
     & 'No L EXTN card - assuming no extinction correction')
      NEXTYP=0
      EXTPR=0.
  10  EXTCO=1.0
      DEREXQ=0.
      DXDFQ=0.
      GO TO 100
C
C FIX EXT COR IF NO CARD GIVEN:
   6  IF (NEXTYP .EQ. 0) CALL ADDFX5(1,1,8,1,1,4)
      GO TO 100
C
C
      ENTRY EXCPR8(NV)
C RECORD THAT THE EXTN CORRECTION PARAMETER IS VARIABLE NUMBER NV:
      KEXTPR=NV
      GO TO 100
C
C
      ENTRY EXCPR9
C RECORD THAT THE EXTN CORRECTION PARAMETER IS FIXED:
      KEXTPR=0
C
 100  RETURN
      END
C
C
C
C
C LEVEL 9      SUBROUTINE FAM4PR(N,PCXX,PFXX)
      SUBROUTINE FAM4PR(N,PCXX,PFXX)
C
C *** FAM4PR updated by PJB 1 Feb 1994 ***
C
CC 19B
CH Multiple entry subroutine for CAIL, SAPS operations
C
      LOGICAL OMIT,ISPABS
      DIMENSION KK1(2),AM(2),BM(2),IH(3),SUMPKN(5)
      LOGICAL TOOWEE
%      DIMENSION ISTRIK(%REFS%),ISLAK(%REFS%),ARCLUM(%REFS%),
%     1ICLUMP(%REFS%),CLUMUL(%REFS%),TOOWEE(%REFS%)
** CAN WE USE /SCRAT/ FOR THAT LOT ?? **
/BRAGG/
/CARDRC/
/DGEOM/
/F4PARS/
/IOUNIT/
/NEWOLD/
/PAWLPR/
/PHASE/
/POINTS/
/PRBLEM/
/PRPKCN/
/REFINE/
/REFIPR/
/REFLNS/
/SLAKDA/
      CHARACTER*10 CONTYP(5)
      DATA CONTYP/' ',' STRICT * ','SLACK TO *',' FIXED *',
     & ' STRICT - '/
C
      GO TO (10,20,30,100,50) , N
C
C ENTRY FROM INPLPR TO READ LIMITS FROM L SLIM CARD:
  10  CALL RDREAL(STRTOL,7,IPT,80,IER)
      CALL RDREAL(SLKTOL,IPT,IPT,80,IER)
      IF (SAPS .OR. APES) THEN
        CALL RDREAL(WEELEV,IPT,IPT,80,IER)
        WRITE (LPT,2029) WEELEV
2029    FORMAT (/' Intensity/ESD slack constraint criterion = ',F10.3)
      ENDIF
      WRITE (LPT,2019) STRTOL,SLKTOL
2019  FORMAT (/' Limit for strict constraints=',F10.3/
     & '        for slack constraints=',F10.3)
      GO TO 100
C
C ENTRY FROM MAIN PROGRAMS TO DETERMINE CONSTRAINTS EACH CYCLE:
C  20  IF (PRECYC) GO TO 100
C JPW - No idea how to fix this at the moment - needs a lot more work
  20    CALL JGMZER(ISTRIK,1,MAXKK(JPHASE))
      CALL JGMZER(ISLAK,1,MAXKK(JPHASE))
      NSPCPS(4,JPHASE)=MAXKK(JPHASE)
C REMOVE ALL CONSTRAINTS ON FAMILY 4 PARS - THIS WILL TAKE OUT ANY
C THE USER GAVE ON CARDS ALSO:
C ^^^^^ HOWEVER, WE MUST BE ABLE TO ALLOW USER TO FIX AND RELATE PARAMETERS
C ^^^^^ AND KEEP THEM SO.
      KK1(1)=KPAK(4,0,0,0,0)
      CALL SUBCON(2,KK1,AM,4)
      NSLAK(3)=0
      ITST=0
C
      AM(1)=1.
      AM(2)=-1.
C
C SCAN FIRST FOR STRICT:
      KNOW=1
C ^^^^^ NOTE CHANGE OF LABEL 2
      CALL PCXX(5)
   2  AKLO=ARGK
      KNOW=KNOW+1
      IF (KNOW .GT. MAXKK(JPHASE)) GO TO 1
      CALL PCXX(5)
      AKHI=ARGK
C PFXX(6) GIVES SEPARATION OF ADJACENT REFLECTION POSITIONS,
C AND FLAGS AS STRICT OR SLACK ACCORDING TO STRTOL OR SLKTOL
      CALL PFXX(6)
      IF ( STRKT) THEN
        ITST=ITST+1
        ISTRIK(KNOW-1)=1
C RELATE PARAMETER KNOW-1 AND PARAMETER KNOW:
        IGST=1
        IF (SAPS) IGST=2
        DO 35 IG=IGST,NGENPS(4,JPHASE)
        KK1(1)=KPAK(4,IG,KNOW-1,JPHASE,1)
        KK1(2)=KPAK(4,IG,KNOW,JPHASE,1)
        CALL ADDCON(2,KK1,AM,4)
  35    CONTINUE
      ENDIF
      GO TO 2
C
C SCAN AGAIN FOR SLACK:
   1  K=1
      AM(2)=1.
C K IS THE FIRST OF A POTENTIAL CLUMP:
      NCLUMP=0
   3  KNOW=K
      ISLAK(K)=0
      CALL PCXX(5)
      SUMMUL=AMUL(K)
      SUMMAR=SUMMUL*ARGK
C SUM INTENSITIES BUT ALSO ESDs.
      SUMMIN=SUMMUL*F4PAR(1,K)
      SUMESD=SUMMUL*F4PESD(1,K)
      IF (SAPS .OR. APES) THEN
        DO 24 IG=2,NGENPS(4,JPHASE)
        SUMPKN(IG)=F4PAR(IG,K)*SUMMUL
  24    CONTINUE
      ENDIF
C K IS THE BASE FROM WHICH WE TEST (POSSIBLY) SEVERAL ADJACENT:
C K1 RECORDS THE "PREVIOUS" NON-FIXED K:
      K1=K
      DO 5 L=K+1,MAXKK(JPHASE)
C IF ALREADY FIXED, IGNORE:
      IF (ISTRIK(L) .EQ. 2) GO TO 5
C COLLECT A CLUMP OF ALL REFLECTIONS STRICTLY CONSTRAINED TO THE BASE K:
      IF (ISTRIK(K1) .NE. 1) GO TO 11
C CURRENT REFLECTION IS STRICTLY CONSTRAINED TO PREVIOUS (NON-FIXED) ONE:
      SUMMUL=SUMMUL+AMUL(L)
      KNOW=L
      CALL PCXX(5)
      SUMMAR=SUMMAR+AMUL(L)*ARGK
      DELTIN=AMUL(L)*F4PAR(1,L)
      SUMMIN=SUMMIN+DELTIN
      SUMESD=SUMESD+AMUL(L)*F4PESD(1,L)
      IF (SAPS .OR. APES) THEN
        DO 25 IG=2,NGENPS(4,JPHASE)
        SUMPKN(IG)=SUMPKN(IG)+AMUL(L)*F4PAR(IG,L)
  25    CONTINUE
      ENDIF
      K1=L
   5  CONTINUE
      L=MAXKK(JPHASE)+1
C
C END OF CLUMP:
  11  NCLUMP=NCLUMP+1
      ICLUMP(NCLUMP)=K
      ICLUMP(NCLUMP+1)=L
      ARCLUM(NCLUMP)=SUMMAR/SUMMUL
      CLUMUL(NCLUMP)=SUMMUL
C NOW FORCE ALL INTS IN CLUMP TO BE THE MEAN VALUE:
      FAV=SUMMIN/SUMMUL
      DO 12 I=K,L-1
      F4PAR(1,I)=FAV
  12  CONTINUE
      IF (SAPS .OR. APES) THEN
C CHECK IF THE INTENSITY OF THIS CLUMP IS TOO SMALL -
C THIS IS ONLY NEEDED FOR SAPS OR APES.
        TOOWEE(NCLUMP)= SUMMIN/SUMESD .LT. WEELEV
        DO 26 I=K,L-1
        DO 27 IG=2,NGENPS(4,JPHASE)
        IF (TOOWEE(NCLUMP)) CALL ADDFX5(4,IG,I,JPHASE,1,4)
        F4PAR(IG,I)=SUMPKN(IG)/SUMMUL
  27    CONTINUE
  26    CONTINUE
      ENDIF
C
C DETECT SLACK CONSTRAINT BETWEEN THIS CLUMP AND ANY PREVIOUS:
      AKHI=ARCLUM(NCLUMP)
      KK1(1)=ICLUMP(NCLUMP)
      BM(1)=CLUMUL(NCLUMP)
      DO 13 I=NCLUMP-1,1,-1
      AKLO=ARCLUM(I)
      CALL PFXX(6)
C IF THIS IS NOT SLACK, NONE FURTHER WILL BE:
      IF (SLACK .EQ. 0.) GO TO 33
C A SLACK CONSTRAINT:
      KK1(2)=ICLUMP(I)
C
C TAKE ACTION ON SLACK CONSTRAINTS FOR INTENSITIES IF CAIL OR APES
      IF (CAIL .OR. APES) THEN
        ISLAK(K)=ISLAK(K)+1
C EVALUATE WEIGHT AND THEN INCLUDE THE EXTRA WEIGHTING:
        WEIGHT=3./(F4PAR(1,ICLUMP(NCLUMP))+F4PAR(1,ICLUMP(I)))**2
        WEIGHT=WEIGHT*SLACK
        BM(2)=CLUMUL(I)
        CALL ADDPAW(3,1,KK1,BM,WEIGHT)
      ENDIF
C
C TAKE ACTION ON SLACK CONSTRAINTS FOR PEAK WIDTHS FOR SAPS AND APES ONLY
C IF INTENSITIES OF EITHER CLUMP ARE NOT TOO SMALL.
      IF (SAPS .OR. APES) THEN
        IF (TOOWEE(I) .OR. TOOWEE(NCLUMP)) GO TO 13
        DO 29 IG=2,NGENPS(4,JPHASE)
        ISLAK(K)=ISLAK(K)+1
C ^^^^^ THE FOLLOWING WEIGHTING IS RATHER RANDOM AT PRESENT
        WEIGHT=400./(F4PAR(IG,ICLUMP(NCLUMP))+F4PAR(IG,ICLUMP(I)))**2
        WEIGHT=WEIGHT*SLACK
        CALL ADDPAW(3,IG,KK1,AM,WEIGHT)
  29    CONTINUE
      ENDIF
  13  CONTINUE
C NO MORE SLACK CONSTRAINTS START FROM CURRENT CLUMP:
  33  K=L
      IF (K .LE. MAXKK(JPHASE)) GO TO 3
C
C FINALLY A PRINTING CYCLE:
C ^^^^^ ALL THIS PRINTING NEEDS TIDYING UP
   4  WRITE (LPT,2000) ICYC
2000  FORMAT(// ' Processing reflections on cycle ',I4)
      IF (FIXED .AND. CAIL) CALL MESS(LPT,1,
     & ' No.  h    k    l  INTENSITY     Posn         Flags ')
      IF (FIXED .AND. .NOT.CAIL) CALL MESS(LPT,1,
     & ' No.  h    k    l  INTENSITY     Posn    SIGS     Flags ')
      IF (.NOT. FIXED .AND. CAIL) CALL MESS(LPT,1,
     & ' No.   h       k       l     INTENSITY     Posn         Flags ')
      IF (.NOT. FIXED .AND. .NOT.CAIL) CALL MESS(LPT,1,
     & ' No.   h       k       l     INTENSITY     Posn    SIGS'//
     &'     Flags ')
C ^^^^^ WE CAN WRITE THE ABOVE LINE WITH SIGS / GAMS ETC.
C ^^^^^ USING DYNAMIC FORMATTING - SEE SUBROUTINE HKLOUT.
C
C ^^^^^ THE FOLLOWING DO LOOP NEEDS COMPLETELY REVAMPED
      DO 40 KNOW=1,MAXKK(JPHASE)
      NTYP1=1
      NTYP2=1
      CALL PCXX(5)
      IF (FIXED) CALL INDFIX(REFH(1,KNOW),IH)
      IF (ISTRIK(KNOW) .EQ. 1) NTYP1=2
      IF (KNOW.GT.1 .AND. ISTRIK(KNOW-1).EQ.1 .AND. ISTRIK(KNOW)
     & .NE. 1) NTYP1=5
C ^^^^^ BE CAREFUL OF THE NEXT LINE
      IF (ISTRIK(KNOW) .EQ. 2) NTYP1=4
      IF (ISLAK(KNOW) .NE. 0) NTYP2=3
C
      IF (CAIL) THEN
        IF (NTYP2 .EQ. 3) THEN
          IF (FIXED) THEN
            WRITE(LPT,2001) KNOW,IH,F4PAR(1,KNOW),ARGK,CONTYP(NTYP1),
     &      CONTYP(NTYP2),ISLAK(KNOW)
          ELSE
            WRITE(LPT,2003) KNOW,(REFH(I,KNOW),I=1,3),F4PAR(1,KNOW),
     &      ARGK,CONTYP(NTYP1),CONTYP(NTYP2),ISLAK(KNOW)
          ENDIF
        ELSE
          IF (FIXED) THEN
            WRITE(LPT,2001) KNOW,IH,F4PAR(1,KNOW),ARGK,CONTYP(NTYP1)
2001      FORMAT (1X,I3,3I5,F12.3,1X,F12.3,2A10,I4)
2003      FORMAT (1X,I3,3F8.3,F12.3,1X,F12.3,2A10,I4)
          ELSE
            WRITE(LPT,2003) KNOW,(REFH(I,KNOW),I=1,3),F4PAR(1,KNOW),
     &      ARGK,CONTYP(NTYP1)
          ENDIF
        ENDIF
      ENDIF
      IF (.NOT.CAIL) THEN
        IF (NTYP2 .EQ. 3) THEN
          IF (NGENPS(4,JPHASE).EQ.2) THEN
            IF (FIXED) THEN
              WRITE (LPT,2002) KNOW,IH,F4PAR(1,KNOW),ARGK,
     &        F4PAR(2,KNOW),
     &        CONTYP(NTYP1),CONTYP(NTYP2),ISLAK(KNOW)
            ELSE
              WRITE (LPT,2004) KNOW,(REFH(I,KNOW),I=1,3),
     &        F4PAR(1,KNOW),ARGK,F4PAR(2,KNOW),
     &        CONTYP(NTYP1),CONTYP(NTYP2),ISLAK(KNOW)
            ENDIF
2002        FORMAT (1X,I3,3I5,F10.3,1X,F12.3,1X,F10.3,2A12,I4)
2004        FORMAT (1X,I3,3F8.3,F10.3,1X,F12.3,1X,F10.3,2A12,I4)
          ELSE IF (NGENPS(4,JPHASE).EQ.3) THEN
            IF (FIXED) THEN
              WRITE (LPT,2202) KNOW,IH,F4PAR(1,KNOW),ARGK,
     &        (F4PAR(IG,KNOW),IG=2,3),
     &        CONTYP(NTYP1),CONTYP(NTYP2),ISLAK(KNOW)
            ELSE
              WRITE (LPT,2204) KNOW,(REFH(I,KNOW),I=1,3),
     &        F4PAR(1,KNOW),ARGK,(F4PAR(IG,KNOW),IG=2,3),
     &        CONTYP(NTYP1),CONTYP(NTYP2),ISLAK(KNOW)
            ENDIF
2202        FORMAT (1X,I3,3I5,F10.3,1X,F12.3,2(1X,F10.3),2A12,I4)
2204        FORMAT (1X,I3,3F8.3,F10.3,1X,F12.3,2(1X,F10.3),2A12,I4)
          ENDIF
        ELSE
          IF (NGENPS(4,JPHASE).EQ.2) THEN
            IF (FIXED) THEN
              WRITE (LPT,2002) KNOW,IH,F4PAR(1,KNOW),ARGK,F4PAR(2,KNOW),
     &        CONTYP(NTYP1)
            ELSE
              WRITE (LPT,2004) KNOW,(REFH(I,KNOW),I=1,3),
     &        F4PAR(1,KNOW),ARGK,F4PAR(2,KNOW),CONTYP(NTYP1)
            ENDIF
          ELSE IF (NGENPS(4,JPHASE).EQ.3) THEN
            IF (FIXED) THEN
              WRITE (LPT,2202) KNOW,IH,F4PAR(1,KNOW),ARGK,
     &        (F4PAR(IG,KNOW),IG=2,3),CONTYP(NTYP1)
            ELSE
              WRITE (LPT,2204) KNOW,(REFH(I,KNOW),I=1,3),
     &        F4PAR(1,KNOW),ARGK,
     &        (F4PAR(IG,KNOW),IG=2,3),CONTYP(NTYP1)
            ENDIF
          ENDIF
        ENDIF
      ENDIF
  40  CONTINUE
C
      WRITE( LPT,2008) MAXKK(JPHASE),ITST,NSLAK(3),MAXKK(JPHASE)-ITST
2008  FORMAT( //,' Total of ',I5,' reflections ',/
     &           '          ',I5,' strict constraints ',/
     &           '          ',I5,' slack constraints ',//
     &           '  making  ',I5,' possible variable intensities '/)
      GO TO 100
C
C ENTRY FROM NWINPR TO APPLY SHIFT:
  30  IF (IGEN .EQ. 2) THEN
        CALL ADF4G2(F4PAR(IGEN,ISPC))
      ELSE
        CALL ADJUST(F4PAR(IGEN,ISPC))
      ENDIF
      F4PESD(IGEN,ISPC)=ESD
      GO TO 100
C
C ENTRY FROM SETPR TO SET UP DEFAULTS:
  50  STRTOL=0.05
      SLKTOL=1.
      WEELEV=3.
      WRITE (LPT,2018) STRTOL,SLKTOL,WEELEV
2018  FORMAT (/' No L SLIM card read -'/
     &' Limit for strict constraints=',F10.3/
     &'        for slack constraints=',F10.3/
     &'        for intensity/ESDs   =',F10.3)
      GO TO 100
C
C
      ENTRY FM4PR8(NG,NS,NV)
C SET PARAMETER TO BE VARIABLE NV:
      KF4PAR(NG,NS)=NV
      GO TO 100
C
C
      ENTRY FM4PR9
C CLEAR ALL FAMILY 4 PARAMETERS TO BE FIXED (EVEN IF NONE INVOLVED):
      DO 9 I=1,3
%      DO 9 J=1,%REFS%
   9  KF4PAR(I,J)=0
      GO TO 100
C
 100  RETURN
      END
C
C
C
C
C LEVEL 14      SUBROUTINE FORTY(PNAME,ALSQ,MATSZ,PCXX,PFXX,MAGROU,CALROU)
      SUBROUTINE FORTY(PNAME,ALSQ,MATSZ,PCXX,PFXX,MAGROU,CALROU)
C
C *** FORTY updated by JCM 15 JAN 93 ***
C
CX
CC 19B
CH Main body of a PR LSQ program, with dummy arguments
CA PNAME holds the name, probably of the calling program, to print
CA PCXX is the routine for the peak centre
CA PFXX is the routine for the peak function
CA MAGROU is the routine to deal with magnetic parameters.  this will be set to
CA        DOMAG if expecting magnetic parameters, or DUMMY if not.
CA CALROU is the routine to give the calculated function.  At present expected
CA        settings for this are CALPRM for magnetic, CALPR for non-magnetic.
C
      LOGICAL DFLTPR,ONCARD
      EXTERNAL DFLTPR,PCXX,PFXX,MAGROU,CALROU,RUNPAR,DUMMY,VARSPR
      CHARACTER *6 PNAME
/DERVAR/
/GRDBCK/
/IOUNIT/
/NEWOLD/
/OBSCAL/
/PAWLPR/
/PHASE/
/PRBLEM/
/PRPKFN/
/PRSAVE/
/REFINE/
/REFIPR/
/REFLNS/
/SLAKDA/
/SLKGEO/
/SOURCE/
C
      CALL PREFIN(PNAME)
C
C SET UP PRECISE PROBLEM, AND READ MOST L CARDS:
      CALL REFSET
C DISCOVER WHETHER SLACK CONSTRAINTS:
      CALL GEOMIN(0)
C THIS ROUTINE IS ONLY FOR ONE PHASE:
      CALL LOGPHA(1)
      CALL SETPR(PCXX,PFXX,MAGROU)
C
C COLLECT CONSTRAINTS IMPOSED BY SYMMETRY, AND THOSE REQUESTED, AND
C SET UP PARAMETERS AS VARIABLES (NOT YET AS BASIC VARIABLES)
      CALL PARSPR(MAGROU)
C
C MAKE LIST OF REFLECTION INDICES:
      CALL INRFPR(PCXX,PFXX)
C
C READ OBS DATA AND SEND OUT TO TEMPORARY UNIT FOR REINPUT EACH CYCLE
      CALL INOBPR(ISCR,NFLIP,PCXX,PFXX)
C
      DONE=.FALSE.
      DO 1 ICYC=NCYC1,LASTCY
      WRITE (ITO,2000) ICYC
2000  FORMAT (' >>> Starting cycle',I4)
      IF (PRECYC .AND. ICYC .NE. NCYC1) THEN
         SIMUL=.FALSE.
         PRECYC=.FALSE.
      ENDIF
C
C IF NEEDED, CAIL/SAPS/APES PROCESSING ON EACH CYCLE
C FOR NOW, IMPOSE PHASE 1, SOURCE 1 WHICH WE HOPE STAY THERE:
      JPHASE=1
      JSOURC=1
      IF (.NOT.RIET) CALL FAM4PR(2,PCXX,PFXX)
      CALL VARMAK(DFLTPR,RUNPAR,VARSPR)
** this won't actually do - we want varspm if magnetic
C FOR NOW, IMPOSE PHASE 1, SOURCE 1 WHICH WE HOPE STAY THERE:
      JPHASE=1
      JSOURC=1
C
C IF ANY SLACK CONSTRAINTS, SET UP:
      CALL GEOMCO(1)
C
      CALL LOGSET
C
C INITIALISE R FACTOR SUMS:
      CALL RFACS(1)
      CALL RFACPR(1,PCXX)
C
C SET UP POINTERS IN TRIANGULAR MATRIX AND CLEAR OUT LSQ MATRIX AND RHS
      CALL MATSET(ALSQ,MATSZ)
C
C COUNT USED OBSERVATIONS :
      NOBS=0
** NOTICE HERE IF SLONLY
      REWIND ISCR
C
C CLEAR POINTERS INDICATING SAVED FC CALCULATIONS FROM ONE INTENSITY TO THE
C NEXT:
%      CALL JGMZER(KPOINT,1,%OLAP%)
C
C INOBPR HAS TURNED THE VARIOUS FORMATS FOR INPUT INTO ONE, AND DECIDED WHICH
C REFLECTIONS CONTRIBUTE.
C
C
C NEW ENTRY TO ARRANGE INTERPOLATION FOR SPEED IF APPROPRIATE:
      CALL PFXX(3)
C
   2  READ (ISCR,END=3) ARGI,OBS,DOBS,WT,ICODE,KMIN,KMAX
C
C CLEAR YCALC TO COLLECT QUANTITY COMPARABLE WITH OBS, AND DERIVV TO COLLECT
C THE CORRESPONDING DERIVATIVES OF YCALC WRT ALL VARIABLES:
C (DONE HERE IN CASE NO CONTRIBUTING REFLNS)
      YBACK=0.
      YPEAK=0.
      YCALC=0.
      IF (LVARV.GT.0 .AND. .NOT. SIMUL) CALL GMZER(DERIVV,1,LVARV)
** ASK BILL - SHOULD EXCLUDED REGIONS BE IN OR OUT OF THE STATISTICS?
C
C DEAL WITH CASE YCALC=0 (EITHER BY BEING EXCLUDED OR BY HAVING NO CONTRIBUTING
C REFLECTIONS) - NB ICODE IS NON-ZERO FOR DO **NOT** USE:
      IF (KMAX .EQ. 0 .AND. .NOT. ZBAKIN) ICODE= -1
      IF (ICODE .NE. 0) THEN
        CALL RFACPR(5,PCXX)
        GO TO 2
      ENDIF
C
C CALCULATE FUNCTION TO MATCH OBSERVED, AND ITS DERIVATIVES, AND DO SOME
C STATISTICS:
      IF (KMAX .NE. 0) CALL CALROU(PCXX,PFXX)
      CALL BACKPR(2)
      YCALC=YBACK+YPEAK
C
C MAKE DERIVATIVES WRT BASIC VARIABLES FROM THOSE WRT VARIABLES:
      CALL RELATE
C
C DIFFERENCE:
      IF (SIMUL) OBS=YCALC
      DIFF = OBS - YCALC
C FROM WEIGHT GET SQRTWT AND WDIFF INTO COMM0N:
      CALL WGHTLS(3,ARGI)
C
C ADD IN TO R FACTORS:
      CALL RFACPR(2,PCXX)
C
C ADD DERIVATIVES IN TO LSQ MATRIX:
      IF (CAIL) THEN
        CALL MATTOS(ALSQ,MATSZ)
      ELSE
        CALL MATTOT(ALSQ,MATSZ)
      ENDIF
      NOBS=NOBS+1
C
C NEXT OBSERVATION:
      GO TO 2
C
C HERE ON NO MORE PROFILE OBSERVATIONS - PRINT R FACTORS:
   3  CALL RFACPR(3,PCXX)
C
C SLACK CONSTRAINTS - FIRST PAWLEY-TYPE:
      CALL PAWLS(ALSQ,MATSZ,3)
** JOIN HERE IF ONLY SLACK:
C THEN GEOMETRICAL:
      CALL GEOMLS(ALSQ,MATSZ)
C COMBINED CHI SQUARED:
      CALL RFACS(6)
C IF CAIL, OUTPUT EIGENVALUES & EIGENVECTORS IF REQUIRED BY "I PREE"
      IF (DONE) CALL EIGEN(ALSQ,MATSZ)
C
C INVERT MATRIX:
      CALL MATINV(ALSQ,MATSZ)
C CALCULATE SHIFTS AND ESD'S:
      CALL MATSHF(ALSQ,MATSZ)
C APPLY SHIFTS AND PRINT:
      CALL APSHPR(ALSQ,MATSZ,PCXX,PFXX,MAGROU)
C
C IF PREVIOUS CYCLE HAD CONVERGED ACCORDING TO I CONV, FINISH:
      IF (DONE) GO TO 39
      DONE=(AMAXSH.LT.CONV .OR. ICYC.EQ.LASTCY-1 .OR. NCYC.EQ.1)
C OUTPUT NEW CRYSTAL DATA FOR PENULTIMATE CYCLE:
      IF (DONE) CALL NWINPR(PCXX,PFXX,MAGROU)
   1  CONTINUE
C
C PRINT CORRELATION MATRIX:
  39  CALL MATCOR(ALSQ,MATSZ)
C
C OUTPUT H,K,L IF REQUIRED:
      CALL HKLOUT(ALSQ,MATSZ)
 100  RETURN
      END
C
C
C
C
C LEVEL 16      SUBROUTINE FORTYM(PNAME,ALSQ,MATSZ,PCXX,PFXX,MAGROU,CALROU)
      SUBROUTINE FORTYM(PNAME,ALSQ,MATSZ,PCXX,PFXX,MAGROU,CALROU)
C
C *** FORTYM updated by PJB 14-Dec-1994 ***
C
CX
CC 19B
CH Main body of a PR LSQ program, with dummy arguments
CA PNAME holds the name, probably of the calling program, to print
CA PCXX is the routine for the peak centre
CA PFXX is the routine for the peak function
CA MAGROU is the routine to deal with magnetic parameters.  this will be set to
CA        DOMAG if expecting magnetic parameters, or DUMMY if not.
** BUT NB MAGCNL NOT MAGPAR IS CALLED FROM PARSPR
CA CALROU is the routine to give the calculated funstion.  At present expected
CA        settings for this are CALPRM for magnetic, CALPR for non-magnetic.
C
      LOGICAL DFLTPR,ONCARD
      EXTERNAL DFLTPR,PCXX,PFXX,MAGROU,CALROU,RUNPAR,DUMMY,VARSPM
      EXTERNAL MAGCNL
      CHARACTER *6 PNAME
/DERVAR/
/GRDBCK/
/IOUNIT/
/NEWOLD/
/OBSCAL/
/PAWLPR/
/PHASE/
/PRBLEM/
/PRPKFN/
/PRSAVE/
/REFINE/
/REFIPR/
/REFLNS/
/SLAKDA/
/SLKGEO/
/SOURCE/
C
      CALL PREFIN(PNAME)
C
C SET UP PRECISE PROBLEM, AND READ MOST L CARDS:
      CALL REFSET
C DISCOVER WHETHER SLACK CONSTRAINTS:
      CALL GEOMIN(0)
C THIS ROUTINE IS ONLY FOR ONE PHASE:
      CALL LOGPHA(1)
      CALL SETPR(PCXX,PFXX,MAGROU)
C
C COLLECT CONSTRAINTS IMPOSED BY SYMMETRY, AND THOSE REQUESTED, AND
C SET UP PARAMETERS AS VARIABLES (NOT YET AS BASIC VARIABLES)
*** TEMPORARY FIX
      CALL PARSPR(MAGCNL)
      CALL MAGROU(2)
C
C MAKE LIST OF REFLECTION INDICES:
      CALL INRFPR(PCXX,PFXX)
C
C READ OBS DATA AND SEND OUT TO TEMPORARY UNIT FOR REINPUT EACH CYCLE
      CALL INOBPR(ISCR,NFLIP,PCXX,PFXX)
C
      DONE=.FALSE.
      DO 1 ICYC=NCYC1,LASTCY
      WRITE (ITO,2000) ICYC
2000  FORMAT (' >>> Starting cycle',I4)
      IF (PRECYC .AND. ICYC .NE. NCYC1) THEN
         SIMUL=.FALSE.
         PRECYC=.FALSE.
      ENDIF
C
C FOR NOW, IMPOSE PHASE 1, SOURCE 1 WHICH WE HOPE STAY THERE:
      JPHASE=1
      JSOURC=1
C
C IF NEEDED, CAIL/SAPS/APES PROCESSING ON EACH CYCLE
      IF (.NOT.RIET) CALL FAM4PR(2,PCXX,PFXX)
      CALL VARMAK(DFLTPR,RUNPAR,VARSPM)
** this won't actually do - we want varspr if non-magnetic
C
C IF ANY SLACK CONSTRAINTS, SET UP:
      CALL GEOMCO(1)
C
      CALL LOGSET
C
C INITIALISE R FACTOR SUMS:
      CALL RFACS(1)
      CALL RFACPR(1,PCXX)
C
C SET UP POINTERS IN TRIANGULAR MATRIX AND CLEAR OUT LSQ MATRIX AND RHS
      CALL MATSET(ALSQ,MATSZ)
C
C COUNT USED OBSERVATIONS :
      NOBS=0
      REWIND ISCR
C
C CLEAR POINTERS INDICATING SAVED FC CALCULATIONS FROM ONE INTENSITY TO THE
C NEXT:
%      CALL JGMZER(KPOINT,1,%OLAP%)
C
C INOBPR HAS TURNED THE VARIOUS FORMATS FOR INPUT INTO ONE, AND DECIDED WHICH
C REFLECTIONS CONTRIBUTE.
C
C
C NEW ENTRY TO ARRANGE INTERPOLATION FOR SPEED IF APPROPRIATE:
      CALL PFXX(3)
C
   2  READ (ISCR,END=3) ARGI,OBS,DOBS,WT,ICODE,KMIN,KMAX
C
C CLEAR YCALC TO COLLECT QUANTITY COMPARABLE WITH OBS, AND DERIVV TO COLLECT
C THE CORRESPONDING DERIVATIVES OF YCALC WRT ALL VARIABLES:
C (DONE HERE IN CASE NO CONTRIBUTING REFLNS)
      YBACK=0.
      YPEAK=0.
      YCALC=0.
      IF (LVARV.GT.0 .AND. .NOT. SIMUL) CALL GMZER(DERIVV,1,LVARV)
** ASK BILL - SHOULD EXCLUDED REGIONS BE IN OR OUT OF THE STATISTICS?
C
C DEAL WITH CASE YCALC=0 (EITHER BY BEING EXCLUDED OR BY HAVING NO CONTRIBUTING
C REFLECTIONS) - NB ICODE IS NON-ZERO FOR DO **NOT** USE:
      IF (KMAX .EQ. 0 .AND. .NOT. ZBAKIN) ICODE= -1
      IF (ICODE .NE. 0) THEN
        CALL RFACPR(5,PCXX)
        GO TO 2
      ENDIF
C
C CALCULATE FUNCTION TO MATCH OBSERVED, AND ITS DERIVATIVES, AND DO SOME
C STATISTICS:
      IF (KMAX .NE. 0) CALL CALROU(PCXX,PFXX)
      CALL BACKPR(2)
      YCALC=YBACK+YPEAK
C
C MAKE DERIVATIVES WRT BASIC VARIABLES FROM THOSE WRT VARIABLES:
      CALL RELATE
C
C DIFFERENCE:
      IF (SIMUL) OBS=YCALC
      DIFF = OBS - YCALC
C FROM WEIGHT GET SQRTWT AND WDIFF INTO COMM0N:
      CALL WGHTLS(3,ARGI)
C
C ADD IN TO R FACTORS:
      CALL RFACPR(2,PCXX)
C
C ADD DERIVATIVES IN TO LSQ MATRIX:
      IF (CAIL) THEN
        CALL MATTOS(ALSQ,MATSZ)
      ELSE
        CALL MATTOT(ALSQ,MATSZ)
      ENDIF
      NOBS=NOBS+1
C
C NEXT OBSERVATION:
      GO TO 2
C
C HERE ON NO MORE PROFILE OBSERVATIONS - PRINT R FACTORS:
   3  CALL RFACPR(3,PCXX)
C
C SLACK CONSTRAINTS - FIRST PAWLEY-TYPE::
      CALL PAWLS(ALSQ,MATSZ,3)
** JOIN HERE IF ONLY SLACK:
C THEN GEOMETRICAL:
      CALL GEOMLS(ALSQ,MATSZ)
C COMBINED CHI SQUARED:
      CALL RFACS(6)
C
C INVERT MATRIX:
      CALL MATINV(ALSQ,MATSZ)
C CALCULATE SHIFTS AND ESD'S:
      CALL MATSHF(ALSQ,MATSZ)
C APPLY SHIFTS AND PRINT:
      CALL APSHPR(ALSQ,MATSZ,PCXX,PFXX,MAGROU)
C
C IF PREVIOUS CYCLE HAD CONVERGED ACCORDING TO I CONV, FINISH:
      IF (DONE) GO TO 39
      DONE=(AMAXSH.LT.CONV .OR. ICYC.EQ.LASTCY-1 .OR. NCYC.EQ.1)
C OUTPUT NEW CRYSTAL DATA FOR PENULTIMATE CYCLE:
      IF (DONE) CALL NWINPR(PCXX,PFXX,MAGROU)
      IF (ICYC .NE. LASTCY) CALL MAGROU(6)
   1  CONTINUE
C
C PRINT CORRELATION MATRIX:
  39  CALL MATCOR(ALSQ,MATSZ)
C
C OUTPUT H,K,L IF REQUIRED:
      CALL HKLOUT(ALSQ,MATSZ)
C IF CAIL, OUTPUT EIGENVALUES & EIGENVECTORS IF REQUIRED BY "I PREE"
      CALL EIGEN(ALSQ,MATSZ)
 100  RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE FRENEL(Z,FRCOS,FRSIN)
      SUBROUTINE FRENEL(Z,FRCOS,FRSIN)
C
C *** FRENEL by WIFD 23 Feb 93 ***
C
CX
CC 9C
CH Calculates ?
CA On entry Z holds the argument
CA On exit FRCOS, FRSIN hold ?
C
      COMMON /CONSTA/PI,RAD,DEG,TWOPI,FOURPI,PIBY2,ALOG2,SQL2X8,VALMUB
C
      FZ= (1.+Z*0.926)/(2.+Z*(1.792+Z*3.104))
      GZ= 1./(2.+Z*(4.142+Z*(3.492+Z*6.670)))
C
      ARG=PIBY2*Z*Z
      SINARG=SIN(ARG)
      COSARG=COS(ARG)
      FRCOS=0.5+FZ*SINARG-GZ*COSARG
      FRSIN=0.5-FZ*COSARG-GZ*SINARG
C
      RETURN
      END
C
C
C
C
C LEVEL 5      SUBROUTINE HKLEBO()
      SUBROUTINE HKLEBO()
C
C JPW MARCH 2001
C WRITE OUT AFTER LEBAIL FITS FOR PRODD (MAYBE?)
C FROM:
C *** HKLOUT updated by PJB 1 Feb 1994 ***
C
CH Writes h,k,l list, possibly plus other info, to unit LKH
CP On entry, reflection indices must be in REFH in /REFLNS/
CP IREF, various LOGICALS in /REFIPR give type of refinement -
CP in particular RIET, CAIL, SAPS, APES . .
C
%      DIMENSION IH(3),ADIAG(%BVAR%),ICOV(30)
      CHARACTER *80 FMT1,FMT2
/DERBAS/
/F4PARS/
/NEWOLD/
/PHASE/
/PRPKFN/
/POINTS/
/PRBLEM/
/REFINE/
/REFIPR/
/REFLNS/
/SCRACH/
/SOURCE/
      DATA FMT1/'(3I5  ,F10.3,F10.4,I5,30I4)'/
      DATA FMT2/'(3I5,1X  ,3(F10.3,1X,F10.4))'/
C
C OUT IF LIST NOT WANTED:
      IF (SIMUL) GO TO 100
      IF (IABS(MODERR(JSOURC)).NE.2 .AND. RIET) GO TO 100
      MESSAG='HKL list'
      NAMFIL='.HKL'
      CALL OPNFIL(LKH,112)
C IF CAIL, GET DIAGONAL LSQ MATRIX INVERSE ELEMEMTS:
      DO 5 I=1,MAXKK(JSOURC)
      IF (FIXED) CALL INDFIX(REFH(1,I),IH)
      IF (RIET) THEN
        IF (FIXED) THEN
          WRITE (LKH,FMT2) IH
        ELSE
          WRITE (LKH,FMT2) (REFH(J,I),J=1,3)
        ENDIF
      ENDIF
C CAIL:
      IF (CAIL) THEN
          IF (FIXED) THEN
            WRITE (LKH,FMT2) IH,AIOBS(I),ESDOBS(I)
          ELSE
            WRITE (LKH,FMT2) (REFH(J,I),J=1,3),F4PAR(1,I),
     &      F4PESD(1,I)
          ENDIF
      ENDIF
** THIS WON'T DO - NGEN4 IS AT PRESENT IN COMMON WHICH IS SWOPPED - SORT OUT
   5  CONTINUE
 100  RETURN
      END
C
C
C
C
C LEVEL 5      SUBROUTINE HKLOUT(ALSQ,MATSZ)
      SUBROUTINE HKLOUT(ALSQ,MATSZ)
C
C *** HKLOUT updated by PJB 1 Feb 1994 ***
C
CH Writes h,k,l list, possibly plus other info, to unit LKH
CP On entry, reflection indices must be in REFH in /REFLNS/
CP IREF, various LOGICALS in /REFIPR give type of refinement -
CP in particular RIET, CAIL, SAPS, APES . .
C
      DIMENSION ALSQ(MATSZ)
%      DIMENSION IH(3),ADIAG(%BVAR%),ICOV(30)
      CHARACTER *80 FMT1,FMT2
/DERBAS/
/F4PARS/
/NEWOLD/
/PHASE/
/PRPKFN/
/POINTS/
/PRBLEM/
/REFINE/
/REFIPR/
/REFLNS/
/SCRACH/
/SOURCE/
      DATA FMT1/'(3I5  ,F10.3,F10.4,I5,30I4)'/
      DATA FMT2/'(3I5  ,3(F10.3,F10.4))'/
C
C OUT IF LIST NOT WANTED:
      IF (SIMUL) GO TO 100
      IF (IABS(MODERR(JSOURC)).NE.2 .AND. RIET) GO TO 100
      MESSAG='HKL list'
      NAMFIL='.HKL'
      CALL OPNFIL(LKH,112)
C IF CAIL, GET DIAGONAL LSQ MATRIX INVERSE ELEMEMTS:
      IF (CAIL) THEN
        DO 88 I=1,LVARB
  88    ADIAG(I)=SQRT(ELEMAT(ALSQ,MATSZ,I,I))
      ENDIF
C IF LX, ALTER FORMATS:
      IF (LX) THEN
        FMT1(10:10)='5'
        FMT1(16:16)='5'
        FMT2(12:12)='5'
        FMT2(18:18)='5'
      ENDIF
C FLOATING FORMATS
      IF (.NOT. FIXED) THEN
        FMT1(3:6)='F8.3'
        FMT2(3:6)='F8.3'
      ENDIF
      DO 5 I=1,MAXKK(JPHASE)
      IF (FIXED) CALL INDFIX(REFH(1,I),IH)
      IF (RIET) THEN
        IF (FIXED) THEN
          WRITE (LKH,FMT2) IH
        ELSE
          WRITE (LKH,FMT2) (REFH(J,I),J=1,3)
        ENDIF
      ENDIF
C CAIL:
      IF (CAIL) THEN
        IF (IPRNT(5) .EQ. 0) THEN
          IF (FIXED) THEN
            WRITE (LKH,FMT2) IH,F4PAR(1,I),
     &      F4PESD(1,I)
          ELSE
            WRITE (LKH,FMT2) (REFH(J,I),J=1,3),F4PAR(1,I),
     &      F4PESD(1,I)
          ENDIF
        ENDIF
        IF (IPRNT(5) .GT. 0) THEN
C SET NO COVARIANCES:
          CALL JGMZER(ICOV,1,30)
C WHICH VARIABLE IS THIS PARAMETER?
          K=KF4PAR(1,I)
C IF FIXED, NO COVARIANCES:
          IF (K .EQ. 0) GO TO 89
C WHICH BASIC VARIABLE (IE ROW OF LSQ MATRIX) IS THIS VARIABLE?
          I1=K
  90      K=LVRBS(I1)
C STARTING INTS MAY BE STRICTLY RELATED TO ONE PREVIOUS:
          IF (K .LT. 0) THEN
            I1=I1-1
            GO TO 90
          ENDIF
C
C IF FIRST INTS, RECORD OFFSET FOR PRINTING CLUMP NUMBER:
          IF (I .EQ. 1) KBASE=K-1
C NOW FIND THE NEXT IPRNT(5) BASICS AFTER K:
          L1=K+IPRNT(5)
          IF (L1 .GT. L4END(JPHASE)) L1=L4END(JPHASE)
          DO 91 L=K+1,L1
  91      ICOV(L-K)=JFIX(100.*ELEMAT(ALSQ,MATSZ,K,L)/
     &    (ADIAG(K)*ADIAG(L)))
  89      WRITE (LKH,FMT1) IH,F4PAR(1,I),F4PESD(1,I),K-KBASE,
     &    (ICOV(L),L=1,IPRNT(5))
        ENDIF
      ENDIF
** THIS WON'T DO - NGEN4 IS AT PRESENT IN COMMON WHICH IS SWOPPED - SORT OUT
      IF (SAPS.OR.APES) WRITE (LKH,FMT2) IH,
     & (F4PAR(IG,I),F4PESD(IG,I),IG=1,NGEN4(JPHASE,JSOURC))
   5  CONTINUE
 100  RETURN
      END
C
C
C
C
C LEVEL 7      SUBROUTINE IICD2
      SUBROUTINE IICD2
C
C *** IICD2 updated by JCM 13 May 90 ***
C
      CHARACTER *4 INEED(9)
      CHARACTER *2 INEX(2)
/GRDBCK/
/IINFO/
/IINFOW/
/IOUNIT/
/REFINE/
/REFIPR/
      DATA INEED/'PRFC','PRFO','PRPR','PRCV','PREE','ZBAK','XXXX',
     & 'PDER','PVAL'/
      DATA INEX/'In','Ex'/
C
C FIRST READ STANDARD LSQ OPTIONS NCYC, CYC1, PRIN, MCOR:
      CALL IICD1
C
C REMAINING OPTIONS PECULIAR TO PR:
C DEFAULTS:
      IPRNT(2)=0
      IPRNT(3)=0
      IPRNT(4)=0
      IPRNT(5)=0
      IPRNT(6)=0
      IPRNT(7)=0
      IPRNT(8)=0
      IPRNT(9)=0
      DO 1 I=1,9
      DO 2 J=1,IIN
      IF (INEED(I) .EQ. IIREAD(J)) GO TO 3
   2  CONTINUE
      GO TO 1
C
   3  IF (I .EQ. 6) THEN
        ZBAKIN=ACOEFF(J) .EQ. 1.
      ELSE
        IPRNT(I+1)=JFIX(ACOEFF(J))
      ENDIF
   1  CONTINUE
C
      IF (IPRNT(2) .NE. 0) THEN
        CALL MESS(LPT,1,'Reflection information to be printed ')
        CALL DEPRIN(IPRNT(2))
      ENDIF
      IF (IPRNT(3) .NE. 0) THEN
        CALL MESS(LPT,1,'Reflections to be output to file for Fourier')
        CALL DEPRIN(IPRNT(3))
      ENDIF
      IF (IPRNT(4) .NE. 0) THEN
        CALL MESS(LPT,1,'Profile including zeros to be output to file')
        CALL DEPRIN(IPRNT(4))
      ENDIF
      IF (IPRNT(5) .NE. 0) WRITE (LPT,2003) IPRNT(5)
2003  FORMAT (' Print',I3,' covariances between I and successive',
     & ' intensities on .HKL file')
      IF (IPRNT(6) .NE. 0) CALL MESS(LPT,1,
     & 'CAIL intensity eigenvalues and eigenvectors to be sent to'//
     & ' .EIG file')
      IF (IPRNT(8) .NE. 0) CALL MESS(LPT,1,
     & 'Derivative w.r.t basic variables to be sent to .DER file')
      IF (IPRNT(9) .NE. 0) CALL MESS(LPT,1,
     & 'Summary .val file to be written')
C
      I=2
      IF (ZBAKIN) I=1
      CALL MESS(LPT,1,INEX(I)//'clude points at which Y(peak)=0'//
     & ' while collecting counts')
C
      RETURN
      END
C
C
C
C
C LEVEL 10       SUBROUTINE INOBPR(ISCR,NFLOP,PCXX,PFXX)
       SUBROUTINE INOBPR(ISCR,NFLOP,PCXX,PFXX)
C
C *** INOBPR updated BY JBF and PJB 8 Mar 1994 ***
C
CH Read PR observation data, and write to scratch dataset
C MODEOB gives type of data: 1 3 FP numbers ARGI OBS DOBS
C                            2 Binary ARGI OBS DOBS ICODE
C                            3 ILL Grenoble CN powder data format
C                            4 X-ray data format
C                            5 GSAS - D20 for now at least (CONST/STD)
C                            6 GEM SPEC FORMAT
C
      EXTERNAL PCXX,PFXX
      CHARACTER *4 BANK
      CHARACTER *5 BINTYP
      LOGICAL ENDIP,TESTOV
      DIMENSION YINOBS(10),INOBS(10),NN(10),ISCR(2),A(4)
/GLOBAL/
/IOUNIT/
/OBSCAL/
/PHASE/
/PRPKCN/
/PRPKFN/
/PRSTAT/
/REFINE/
/REFIPR/
/REFLNS/
/SCRACH/
/SOURCE/
C
C MAKE SCRATCH FILE ON WHICH TO HAND OVER OBSERVATIONS TO MAIN:
      ISCR(1)=NOPFIL(1005)
C AND IF MULTI-PHASE, ANOTHER ONE FOR ALTERNATE USE:
      IF (MULFAS) ISCR(2)=NOPFIL(1005)
      NFLIP=1
      NFLOP=2
      NOBS=0
C CYCLE OVER SOURCES:
      DO 52 JSOUR=1,NSOURC
      JSOURC=JSOUR
      JPHASE=1
C SET UP WHETHER TOF, CN ETC:
      CALL LOGSOU(JSOURC)
C
  15  IF (SIMUL .AND. .NOT. PRECYC) THEN
C INITIALISE SCRATCH FILE QUANTITIES FOR SIMULATION:
C 89.16 July 12 1996 fix to sort out simul with no step in inobpr
        IF( TESTOV(1.,ARGSTP(JSOURC)) )
     +      CALL ERRMES(2,0,'Step length on L RTYP '//
     + 'apparently zero')
        IF (TOF) THEN
          OPDTOT=1.+ARGSTP(JSOURC)
          ARGI=ARGMIN(JSOURC)/OPDTOT
        ENDIF
        OBS=0.
        DOBS=1.
        ICODE=0
      ELSE
C
C OPEN OBSERVATIONS FILE
        MESSAG='Observations file'
        IF (JSOURC .GT. 1) MESSAG='Next obs file'
        M=11
        IF (MODEOB(JSOURC) .EQ. 2) M=1011
        CALL OPNFIL(LUNI,M)
      ENDIF
C
C COLLECT MAXIMUM OBS:
      YMAX=0.
C
C SCAN ALL PHASES:
      DO 51 JP=1,NPHASE
      JPHASE=JP
      IF (JPHASE .GT. 1) THEN
        REWIND(ISCR(NFLOP))
        REWIND(ISCR(NFLIP))
C 90.62 no need to rewind as only read once
C        REWIND(LUNI)
      ENDIF
C 90.62 Always check phase - not just for JPHASE .GT. 1
** DO WE NEED TO DUMP OUT THE EXISTING PHASE?
      CALL PHMOVE(1,JPHASE)
C
C START COUNT UP CONTRIBUTING REFLECTIONS - OBSERVATIONS MUST BE IN SEQUENCE:
      KMIN=1
      KOUNT=0
** NB WE HAVE NO WAY OF SIMULATING ANYTHING BUT TF AT PRESENT
      IF (JPHASE.GT.1) GO TO 10
C
C
      IF (MODEOB(JSOURC).EQ.6) THEN
C GEM SPEC FILE FORMAT. SCAN THRU FILE TILL WE FIND '#S n' WITH N.EQ.JSOURC
C THEN SKIP LINES WITH #P or #L TILL WE FIND ANOTHER #S.
   13   READ(LUNI,'(A80)',END=14) ICARD
        IF (ICARD(1:2).EQ.'#S') THEN
          CALL RDINTG(III,3,ICURR,80,IER)
C HAVE WE FOUND THE RIGHT BANK?
          IF(III.EQ.JSOURC) GOTO 10
        ENDIF
C LOOP UNTIL WE FIND THEN RIGHT #S n.
        GO TO 13
C ERROR - WE DIDN'T FIND #S CORRESPONDING TO THE RIGHT SOURCE.
   14   WRITE(ITO,*)'No line with #S ',JSOURC,'found in data file'
        WRITE(LPT,*)'No line with #S ',JSOURC,'found in data file'
        STOP
      ENDIF
C
C
      IF (MODEOB(JSOURC) .EQ. 3) THEN
C GRENOBLE FORMAT FOR CONSTANT WAVELENGTH NEUTRON DIFFRACTOMETERS
C READ 4 LINES OF COMMENT AND IGNORE;  THEN READ IN FORMAT 10(I2,I8)
        READ (LUNI,1010) ICARD
1010    FORMAT (A80,///)
        CALL MESS(LPT,1,'Data file in Grenoble sum file format:')
        CALL MESS(LPT,1,'Title reads: ')
        CALL MESS(LPT,0,ICARD)
      ELSE IF (MODEOB(JSOURC) .EQ. 4) THEN
C THIS IS SOMETIMES USED FOR LABORATORY X-RAY DATA TOO
        DO 16 I=1,10
  16    NN(I)=1
      ELSE IF (MODEOB(JSOURC) .EQ. 5) THEN
        READ (LUNI,1050) ICARD
1050    FORMAT(A80)
        CALL MESS(LPT,1,'Data file in GSAS format, title reads: ')
        CALL MESS(LPT,0,ICARD)
        CALL MESS(ITO,1,'Data file in GSAS format, title reads: ')
        CALL MESS(ITO,0,ICARD)
  55    READ (LUNI,1050) ICARD
        CALL RDWORD(BANK,ILEN,1,ICURR,4,0,IER)
        IF (BANK.EQ.'BANK') THEN
          CALL RDINTG(III,ICURR,ICURR2,80,IER)
          IBANK=III
          CALL RDINTG(III,ICURR2,ICURR,80,IER)
          NCHAN=III
          CALL RDINTG(III,ICURR,ICURR2,80,IER)
          NREC=III
          CALL RDWORD(BINTYP,ILEN,ICURR2,ICURR,80,0,IER)
          DO 57 I=1,4
            CALL RDREAL(A(I),ICURR,ICURR2,80,IE)
            ICURR=ICURR2
  57      CONTINUE
        ARGMIN(JSOURC)=A(1)/100.0
        ARGSTP(JSOURC)=A(2)/100.0
      ELSE
C Scan till find a bank record
          GOTO 55
        ENDIF
      ENDIF
C
C GET NEXT OBSERVATION:
  10  IF (SIMUL.AND. .NOT. PRECYC .AND. JPHASE.EQ.1) THEN
        IF (TOF) THEN
          ARGI=ARGI*OPDTOT
          IF (ARGI .GT. ARGMAX(JSOURC)) GO TO 50
        ELSE
          ARGI=ARGMIN(JSOURC)+FLOAT(KOUNT)*ARGSTP(JSOURC)
          KOUNT=KOUNT+1
          IF(ARGI.GT.ARGMAX(JSOURC)) GOTO 50
        ENDIF
        GO TO 11
      ENDIF
C
C PHASES OTHER THAN FIRST:
      IF (JPHASE .GT. 1) THEN
C READ FROM THE OTHER TEMPORARY FILE - KMI & KMA ARE PARTIALLY FILLED:
        READ (ISCR(NFLOP),END=50) ARGI,OBS,DOBS,WT,ICODE,JHIST,
     &  (KMI(I),KMA(I),I=1,NPHASE),YOLD
C 90.62 read in m/phase, m/sourc correctly.
        IF(JHIST.EQ.JSOURC) GO TO 11
        IF(JHIST.LT.JSOURC) THEN
          WRITE(ISCR(NFLIP)) ARGI,OBS,DOBS,WT,ICODE,JHIST,
     &    (KMI(I),KMA(I),I=1,NPHASE),YOLD
          GO TO 10
        ENDIF
C 90.62 If JHIST.GT.JSOURC then we probably will have a problem.
      ELSE
C BRANCH ON DIFFERENT INPUT FORMATS FOR OBSERVATIONS:
        GO TO (60,1,2,3,4,5,6) , MODEOB(JSOURC)+1
      ENDIF
C
C USER'S OWN ROUTINE SUPPLIED FOR NON-STANDARD INPUT IF REQUIRED:
  60  CALL QPRIN(ARGI,OBS,DOBS,ICODE,ENDIP)
      IF (ENDIP) GO TO 50
      GO TO 11
C
C TYPE 1: 3 FLOATING POINT NUMBERS:
   1  READ (LUNI,1001,END=50) ICARD
1001  FORMAT (A80)
      CALL RDREAL(ARGI,1,IPT,80,IER)
      CALL RDREAL(OBS,IPT,IPT,80,IER)
      CALL RDREAL(DOBS,IPT,IPT,80,IER)
      IF (IER .EQ. 100) DOBS=SQRT(OBS)
      GO TO 11
C
C MODE 6: 3 FLOATING POINT NUMBERS WITH # IGNORED AND STOPPING WHEN
C WE FIND ANOTHER #S
   6  READ (LUNI,'(A80)',END=50) ICARD
      IF(ICARD(1:2).EQ.'#S') GOTO 50
      IF(ICARD(1:1).EQ.'#')GOTO 10
      CALL RDREAL(ARGI,1,IPT,80,IER)
      CALL RDREAL(OBS,IPT,IPT,80,IER)
      CALL RDREAL(DOBS,IPT,IPT,80,IER)
      IF (IER .EQ. 100) DOBS=SQRT(OBS)
      GOTO 11
C
C MODE 2 INPUT (FOR ANY DATA SOURCE) - BINARY:
   2  READ (LUNI,END=50) ARGI,OBS,DOBS,ICODE
  11  CALL CONTRI(PCXX,PFXX,ISCR(NFLIP))
      GO TO 10
C
C MODEOB(JSOURC) = 3 IS GRENOBLE SUM FILE FORMAT (USUALLY CN):
   3  READ(LUNI,1000,END=50) (NN(I),INOBS(I),I=1,10)
1000  FORMAT (10(I2,I6))
      GO TO 19
C
C MODEB(JSOURC) = 4 (USUALLY LX):
   4  READ(LUNI,1002,END=50) (INOBS(I),I=1,10)
1002  FORMAT (10I8)
      GO TO 19
C
C MODEB(JSOURC) = 5 GSAS (D20 at least) format
   5  READ(LUNI,1005,END=50) (NN(I),YINOBS(I),I=1,10)
1005  FORMAT (10(I2,F6.0))
C
C PROCESS A WHOLE LINE OF 10 ENTRIES:
  19  DO 12 I=1,10
      ARGI=ARGMIN(JSOURC)+FLOAT(KOUNT)*ARGSTP(JSOURC)
      KOUNT=KOUNT+1
      IF (NN(I) .EQ. 0 .AND.
     & ( (MODEOB(JSOURC).EQ.3) .OR. (MODEOB(JSOURC).EQ.5) )
     &                  ) GO TO 12
      IF(MODEOB(JSOURC).EQ.5) THEN
      OBS=YINOBS(I)
      ELSE
       OBS=FLOAT(INOBS(I))
      ENDIF
      DOBS=SQRT(OBS/FLOAT(NN(I)))
      CALL CONTRI(PCXX,PFXX,ISCR(NFLIP))
  12  CONTINUE
      GO TO 10
C
C END OF INPUT:
  50  IF (JPHASE .EQ. 1) NSOBS(JSOURC)=NOBS
C SWITCH TEMPORARY DATASETS:
      CALL FLIP(NFLIP,NFLOP)
C END OF ONE PHASE
  51  CONTINUE
C
C END OF ONE SOURCE OF OBS:
C
C 90.04 In INOBPR, extra flipping of units to deal with sourc
      CALL FLIP(NFLIP,NFLOP)
C
  52  IF (.NOT. SIMUL .OR. PRECYC) CALL CLOFIL(LUNI)
C
C LEAVES NFLOP AS ONE TO READ FROM:
C
C 90.04
      CALL FLIP(NFLIP,NFLOP)
C
 100  RETURN
      END
C
C
C
C
C LEVEL 9      SUBROUTINE INPLP0(PCXX,PFXX)
      SUBROUTINE INPLP0(PCXX,PFXX)
C
C *** INPLP0 updated by JBF Oct 95 ***
C Format of Step from F12.2 to F12.5
C
CH Reads L cards for Profile refinement, phase 0 (phase independent cards)
CD Reads most L cards, ignoring FIX, VARY, RELA, FUDG which will be read later.
C
CD If called from RDPHA0, records information off the following:
CD    SCAL   Scale factor
CD    RTYP   Mode of presentation of input reflection data
CD    WGHT   Weighting scheme (one day take this out into STLSP0 and use WGHTLS)
CD    PKCN   Peak centre parameters (which NB are being kept as one
CD           for each phase at present, just in case)
CD    ZERO   Zero point (ditto)
CD    OTYP   Mode of presentation of input observation data
CD    BACK   Background approximation - may be several cards
CD    EXCL   Excluded regions - may be several cards
CD    WVLN   Wavelengths (for constant wavelength or X-Ray)
CD    ABSC   Absorption correction coefficient
CD    EXTN   Extinction correction coefficient
CD    PROR   Preferred orientation coefficient
CD    THE2   2 theta for time of flight
CD    TTHM   Monochromator 2 theta angle (X-Ray)
C
      EXTERNAL PCXX,PFXX
      CHARACTER *2 INEX(2)
      CHARACTER *14 ARGTYP(2)
%      CHARACTER *4 IWD,LTABLE(%LCRD%),LTICTB(5),LPH0TB(14)
      LOGICAL ONCARD
      DIMENSION IH(3),H(3)
/BRAGG/
/CARDRC/
/DGEOM/
/GLOBAL/
/IOUNIT/
/LREAD/
/OBSCAL/
/OMITPR/
/PAWLPR/
/PHASE/
/PRPKCN/
/REFINE/
/REFIPR/
/SOURCE/
      DATA LTABLE/'TFAC','SCAL','SLIM','RTYP','SPHA','WGHT',
     & 'PKCN','ZERO','PKFN','OTYP','BACK','EXCL','WVLN','ABSC',
     & 'EXTN','PROR','TTHM','THE2','OMIT','REFK',' ',' '/
      DATA LPH0TB/'SCAL','RTYP','WGHT','PKCN','ZERO','OTYP','BACK',
     & 'EXCL','WVLN','ABSC','EXTN','PROR','TTHM','THE2'/
      DATA LTICTB/'RTYP','PKCN','ZERO','WVLN','THE2'/
      DATA INEX/'In','Ex'/
      DATA ARGTYP/'Time of flight','2 theta'/
C
C SET 'NO L CARDS READ':
%      CALL JGMZER(ILREA,%SORC%,%LCRD%)
C
C READ ALL 'L' CARDS:
      IF (MULFAS) CALL P0TEMP(.TRUE.)
      ID=IABS(INREAD(12))
      NCARD=ICDNO(12)
      IF (NCARD .LE. 0) THEN
        CALL ERRMES(1,1,'No "L" cards given')
        GO TO 100
      ENDIF
C
      DO 3 ICD=1,NCARD
      CALL CARDIN(ID)
      ID=ID+NYZ
      CALL RDWORD(IWD,LEN,3,IPT,80,0,IER)
C IGNORE L CARD IF NOT ONE WE WANT:
%      L=NCFIND(IWD,LTABLE,%LCRD%)
      IF (L .LE. 0) GO TO 3
** NB IF WE EVER WANT THESE AFTER THE INPUT PHASE WE MUST DO BETTER THAN THIS
      IF (TIC) THEN
        L=NCFIND(IWD,LTICTB,5)
        IF (L .LE. 0) GO TO 3
        GO TO (14,17,18,23,28) , L
      ENDIF
C NOW DO WE WANT IT FOR PHASE 0?
      LL=NCFIND(IWD,LPH0TB,14)
      IF (LL .LE. 0) GO TO 3
C 90.05 In INPLP0, set cards read per sourc to avoid errors
      ILREA(L,KSOURC)=ILREA(L,KSOURC)+1
C      ILREAD(L)=ILREAD(L)+1
      GO TO (12,14,16,17,18,20,21,22,23,
     & 24,25,26,27,28) , LL
C
C L SCAL - THIS IS THE SCALE OF A SOURCE:
  12  CALL LSSCAL(1)
      GO TO 3
C
C L RTYP:
  14  CALL RDINTG(MODERR(KSOURC),IPT,IPT,80,IER)
      MMODER=IABS(MODERR(KSOURC))
      IF (MMODER .GT. 3) GO TO 7
      IA=1
      IF (.NOT. TOF) IA=2
      CALL RDREAL(ARGMIN(KSOURC),IPT,IPT,80,IER)
      CALL RDREAL(ARGMAX(KSOURC),IPT,IPT,80,IER)
      CALL RDREAL(ARGSTP(KSOURC),IPT,IPT,80,IER)
      WRITE (LPT,2009) ARGTYP(IA),ARGMIN(KSOURC)
2009  FORMAT (//' Data limits considered:'/' Minimum ',A14,' =',F12.2)
      IF (ARGMAX(KSOURC).NE.0.)WRITE (LPT,2006)ARGTYP(IA),ARGMAX(KSOURC)
2006  FORMAT (' Maximum ',A14,' =',F12.2)
      IF (ARGSTP(KSOURC) .NE. 0.) WRITE (LPT,2007) ARGTYP(IA),
     & ARGSTP(KSOURC)
2007  FORMAT (' Step in ',A14,' =',F12.5)
      GO TO (71,72,73) , MMODER
   7  CALL ERRIN2(MODERR(KSOURC),2,'reflection input type',
     & 'not allowed')
      GO TO 3
C
  71  CALL MESS(LPT,1,'Reflection indices input as sets of 3 I5'//
     & ' integers from .HKL file')
      GO TO 10
C
  72  CALL MESS(LPT,1,'Reflection indices to be generated by program'//
     & ' then output to file .HKL')
      GO TO 10
C
  73  CALL MESS(LPT,1,'Reflection indices to be generated by program'//
     & ' - regenerate next run')
  10  I=2
      IF (MODERR(KSOURC) .LT. 0) I=1
      CALL MESS(LPT,1,INEX(I)//'clude any space group absences')
      GO TO 3
C
C L WGHT:
  16  CALL RDINTG(IWGH(KSOURC),IPT,IPT,80,IER)
      IF (IWGH(KSOURC) .GT. 3 .OR. IWGH(KSOURC) .LE. 0) GO TO 8
      GO TO (41,42,43) , IWGH(KSOURC)
   8  CALL ERRIN2(IWGH(KSOURC),2,'weighting scheme',
     & 'not allowed - type 1, 2 or 3 only')
      GO TO 3
C
C UNIT WEIGHTS:
  41  CALL MESS(LPT,1,'Unit weights')
      GO TO 3
C
C WEIGHT TO BE USED AS READ:
  42  CALL MESS(LPT,1,
     & 'Weights to be used as read from reflection data')
      GO TO 3
C
C SIGMA READ, WEIGHT IS 1/SIGMA SQUARED:
  43  CALL MESS(LPT,1,'Sigma read from reflection data'//
     & ' - weight is 1/sigma squared')
      GO TO 3
C
C L PKCN:
  17  CALL RDWORD(IWD,LEN,IPT,IPT,80,1,IER)
      CALL LOGSOU(KSOURC)
      IF (IWD .NE. 'TYPE') CALL PCXX(1)
** TEMPORARY - PFXX - IE PFALL - IGNORES ITS OWN 'TYPE' CARDS
      GO TO 3
C
C L ZERO:
  18  CALL ZEROPR(1)
      GO TO 3
C
C L OTYP:
  20  CALL RDINTG(MODEOB(KSOURC),IPT,IPT,80,IER)
      IF (MODEOB(KSOURC) .LT. 0 .OR. MODEOB(KSOURC) .GT. 6) THEN
        CALL ERRIN2(MODEOB(KSOURC),2,'mode of giving obs data',
     &  'unacceptable')
        GO TO 3
      ENDIF
C
      GO TO (61,62,63,64,65,66) , MODEOB(KSOURC)+1
  61  CALL MESS(LPT,1,
     & 'Observations to be input by user''s routine QPRIN')
      GO TO 3
C
  62  CALL MESS(LPT,1,'Observations to be input as '//
     & 'tof,Yobs,DYobs,(scale),(code), in formats F10 and I5')
      GO TO 3
C
  63  CALL MESS(LPT,1,'Observations to be input as tof,Yobs,DYobs,'//
     & '(scale),(code), unformatted from binary file')
      GO TO 3
C
  64  CALL MESS(LPT,1,
     & 'Observations to be input as sets of n,obs in format 10(I2,I6)')
      GO TO 3
C
  65  CALL MESS(LPT,1,
     & 'Observations to be input as sets of obs in format 10(I8)')
      GO TO 3
C
  66  CALL MESS(LPT,1,
     & 'Observations to be input in GEM SPEC format')
      GO TO 3
C
C L BACK:
  21  CALL BACKPR(1)
      GO TO 3
C
**???ought these to be per phase?
C L EXCL:
  22  CALL EXCLIN
      GO TO 3
C
C L WVLN:
  23  IF (TOF) GO TO 3
      IF (CN) CALL PCXX(1)
      GO TO 3
C
C L ABSC:
  24  CALL ABCRPR(1)
      GO TO 3
C
C L EXTN:
  25  CALL EXCRPR(1)
      GO TO 3
C
C L PROR:
  26  CALL PREFOR(1)
      GO TO 3
C
C L TTHM:
  27  CALL TTHMLX(1)
      GO TO 3
C
C L THE2:
  28  CALL RDREAL(TWOTHD(KSOURC),IPT,IPT,80,IER)
      SINTH=SIN(RADIAN(TWOTHD(KSOURC)/2.))
      TWSNTH(KSOURC)=2.*SINTH
      WRITE (LPT,2020) TWOTHD(KSOURC),TWSNTH(KSOURC)
2020  FORMAT (/' 2 theta =',F10.3,' degrees;  2 sin theta =',F10.5)
      GO TO 3
C
   3  CONTINUE
C
 100  IF (MULFAS) CALL P0TEMP(.FALSE.)
      RETURN
      END
C
C
C
C
C LEVEL 10      SUBROUTINE INPLPR(PCXX,PFXX)
      SUBROUTINE INPLPR(PCXX,PFXX)
C
C *** INPLPR updated by JCM 30 Jan 92 ***
C
CH Reads most L cards for Profile refinement, in sequence
CD Reads L cards, ignoring FIX, VARY, RELA, FUDG which will be read later,
CD and all the cards which would be phase-independent in multiphase, which
CD have been read already by INPLP0.
C
CD If called from STLSPR, records information off the following:
CD    TFAC   An overall temperature factor (applied squared in this case)
*CD    SCAL   Scale factors
*CD    RTYP   Mode of presentation of input reflection data
*CD    WGHT   Weighting scheme
*CD    PKCN   Peak centre parameters
*CD    ZERO   Zero point
CD    PKFN   Peak function parameters
*CD    OTYP   Mode of presentation of input observation data
*CD    BACK   Background approximation - may be several cards
*CD    EXCL   Excluded regions - may be several cards
*CD    WVLN   Wavelengths (for constant wavelength or X-Ray)
*CD    ABSC   Absorption correction coefficient
*CD    EXTN   Extinction correction coefficient
*CD    PROR   Preferred orientation coefficient
*CD    THE2   2 theta for time of flight
*CD    TTHM   Monochromator 2 theta angle (X-Ray)
CD    SLIM   Limits for CAIL - SAPS - APES
CD    OMIT   h k l values for reflection to omit this run
C
*CD If called from PICTIC, interprets only the 5 cards:
*CD    RTYP, PKCN, ZERO WVLN, THE2
C
      EXTERNAL PCXX,PFXX
      CHARACTER *2 INEX(2)
      CHARACTER *14 ARGTYP(2)
%      CHARACTER *4 IWD,LTABLE(%LCRD%),LTICTB(5),LPHNTB(6)
      LOGICAL ONCARD
      DIMENSION IH(3),H(3)
/BRAGG/
/CARDRC/
/DGEOM/
/IOUNIT
/LREAD/
/OBSCAL/
/OMITPR/
/PAWLPR/
/PHASE/
/PRPKCN/
/REFINE/
/REFIPR/
/SOURCE/
      DATA LTABLE/'TFAC','SCAL','SLIM','RTYP','SPHA','WGHT',
     & 'PKCN','ZERO','PKFN','OTYP','BACK','EXCL','WVLN','ABSC',
     & 'EXTN','PROR','TTHM','THE2','OMIT','REFK',' ',' '/
      DATA LTICTB/'RTYP','PKCN','ZERO','WVLN','THE2'/
      DATA LPHNTB/'TFAC','PKFN','SLIM','OMIT','SPHA','REFK'/
      DATA INEX/'In','Ex'/
      DATA ARGTYP/'Time of flight','2 theta'/
C
*C SET 'NO L CARDS READ':
*%      CALL JGMZER(ILREAD,1,%LCRD%)
C
C READ ALL 'L' CARDS:
      INREAD(12)=-IABS(INREAD(12))
      ID=IABS(INREAD(12))
      NCARD=ICDNO(12)
      IF (NCARD .LE. 0) THEN
        CALL ERRMES(1,1,'No "L" cards given')
        GO TO 100
      ENDIF
C
      DO 3 ICD=1,NCARD
      CALL CARDIN(ID)
      ID=ID+NYZ
      CALL RDWORD(IWD,LEN,3,IPT,80,0,IER)
C IGNORE L CARD IF NOT ONE WE WANT:
%      L=NCFIND(IWD,LTABLE,%LCRD%)
      IF (L .LE. 0) GO TO 3
C NOW FIND OUT IF WE REALLY WANT IT:
      IF (.NOT. TIC) THEN
        LL=NCFIND(IWD,LPHNTB,6)
        IF (LL .EQ. 0) GO TO 3
        ILREAD(L)=ILREAD(L)+1
        GO TO (11,19,13,29,15,30) , LL
      ELSE
        LL=NCFIND(IWD,LTICTB,5)
        IF (LL .LE. 0) GO TO 3
        ILREAD(L)=ILREAD(L)+1
        GO TO (14,17,18,23,28) , LL
      ENDIF
C
C L TFAC:
  11  CALL LLTFAC(1)
      GO TO 3
*C
*C L SCAL - THIS IS THE SCALE OF A SOURCE:
*  12  CALL LSSCAL(1)
*      GO TO 3
C
C L SLIM:
  13  CALL FAM4PR(1,PCXX,PFXX)
      GO TO 3
C
**???only once?
C L RTYP:
  14  CALL RDINTG(MODERR(KSOURC),IPT,IPT,80,IER)
      MMODER=IABS(MODERR(KSOURC))
      IF (MMODER .GT. 3) GO TO 7
      IA=1
      IF (.NOT. TOF) IA=2
      CALL RDREAL(ARGMIN(KSOURC),IPT,IPT,80,IER)
      CALL RDREAL(ARGMAX(KSOURC),IPT,IPT,80,IER)
      CALL RDREAL(ARGSTP(KSOURC),IPT,IPT,80,IER)
      WRITE (LPT,2009) ARGTYP(IA),ARGMIN(KSOURC)
2009  FORMAT (//' Data limits considered:'/' Minimum ',A14,' =',F12.2)
      IF (ARGMAX(KSOURC).NE.0.)WRITE (LPT,2006)ARGTYP(IA),ARGMAX(KSOURC)
2006  FORMAT (' Maximum ',A14,' =',F12.2)
      IF (ARGSTP(KSOURC) .NE. 0.) WRITE (LPT,2007) ARGTYP(IA),
     & ARGSTP(KSOURC)
2007  FORMAT (' Step in ',A14,' =',F12.2)
      GO TO (71,72,73) , MMODER
   7  CALL ERRIN2(MODERR(KSOURC),2,'reflection input type',
     & 'not allowed')
      GO TO 3
C
  71  CALL MESS(LPT,1,'Reflection indices input as sets of 3 I5 '//
     & 'integers from .HKL file')
      GO TO 10
C
  72  CALL MESS(LPT,1,'Reflection indices to be generated by program'//
     & ' then output to file .HKL')
      GO TO 10
C
  73  CALL MESS(LPT,1,'Reflection indices to be generated by program'//
     & ' - regenerate next run')
  10  I=2
      IF (MODERR(KSOURC) .LT. 0) I=1
      CALL MESS(LPT,1,INEX(I)//'clude any space group absences')
      GO TO 3
C
C L SPHA:
  15  CALL LPSCAL(1)
      GO TO 3
C
C L PKCN:
  17  CALL RDWORD(IWD,LEN,IPT,IPT,80,-1,IER)
      IF (IWD .NE. 'TYPE') CALL PCXX(1)
** TEMPORARY - PFXX - IE PFALL - IGNORES ITS OWN 'TYPE' CARDS
      GO TO 3
C
C L ZERO:
  18  CALL ZEROPR(1)
      GO TO 3
C
C L PKFN:
  19  CALL PFALL(1)
      GO TO 3
C
C L WVLN:
  23  IF (TOF) GO TO 3
      CALL RDNUMS(ALAMBD(1,KSOURC),IPT,5,NLAMB,IER)
      WRITE(LPT,2002) NLAMB,(ALAMBD(I,KSOURC),I=1,NLAMB)
2002  FORMAT (' ',I3,' Wavelength(s): ',5(1X,F9.6))
      GO TO 3
C
C L THE2:
  28  CALL RDREAL(TWOTHD(KSOURC),IPT,IPT,80,IER)
      SINTH=SIN(RADIAN(TWOTHD(KSOURC)/2.))
      TWSNTH(KSOURC)=2.*SINTH
      WRITE (LPT,2020) TWOTHD(KSOURC),TWSNTH(KSOURC)
2020  FORMAT (/' 2 theta =',F10.3,' degrees;  2 sin theta =',F10.5)
      GO TO 3
C
C L OMIT:
  29  DO 79 I=1,3
      CALL RDINTG(IH(I),IPT,IPT,80,IER)
  79  CONTINUE
      IER=IERR
%      CALL ERRCHK(2,MIS,%OMIT%,0,'omitted reflections')
      IF (IER .NE. IERR) GO TO 3
C
      CALL INDFLO(AMISS(1,MIS),IH)
      WRITE (LPT,2000) IH
2000  FORMAT (' Reflection',3I5,' to be EXcluded from the ',
     & 'refinement')
      GO TO 3
C
C L REFK:
  30  CALL RDREAL(AKNOTS,IPT,IPT,80,IER)
      IF (AKNOTS .LE. 1.) THEN
        WRITE(LPT,2051) AKNOTS
2051    FORMAT (/' Knots required at spacing of',F7.3,
     &  ' times number of reflections')
      ELSE
        WRITE (LPT,2052) AINT(AKNOTS)
2052    FORMAT (/' Knots required at',I4,' peaks')
      ENDIF
C
   3  CONTINUE
C
 100  RETURN
      END
C
C
C
C
C LEVEL 9      SUBROUTINE INRFPR(PCXX,PFXX)
      SUBROUTINE INRFPR(PCXX,PFXX)
C
C *** INRFPR updated by JBF 4 July 1955 ***
C
CC 19B
CH Organises reflection data for all sorts of PR
CA PCXX must be set to the required Peak Centre subroutine
CA PFXX must be set to the required Peak Function subroutine
CP MODER must have been set to give type of reflection input
CP MAG must be .FALSE. for non-magnetic, .TRUE. for magnetic
CP Symmetry must be set by SYMOP and SYMUNI
CP IREF etc must be set in /REFINE/ giving type of refinement
C
CD Obtains list of h,k,l s, either by reading them in from some
CD previous run, or generating them.  Fills in /REFLNS/ arrays REFH,
CD AMUL, and if Pawley-type and reading h,k,l, reads F4PAR(1, in /F4PARS/
CD also, and possibly F4PAR(2.
CD
CD If entered with TIC = .TRUE. generates reflections.
C
C
C 88.10 added declaration
      REAL MAGMIN
      LOGICAL NOMORE,ISPABS,SFC,MAGABS,MAGNET
      CHARACTER *1 ICHR
      CHARACTER *129 VFMT
      CHARACTER *131 VFMM
      COMPLEX FCALC,FCAL
      EXTERNAL PCXX,PFXX
%      DIMENSION IH(3),H(3),TEMREF(3,%REFS%),IORDER(%REFS%),
%     & TEMMUL(%REFS%),ARG(%REFS%),TF4P(6,%REFS%),TEMP(6),
%     & ARGN(%REFS%),ANT(%REFS%)
/BRAGG/
/CARDRC/
/CELPAR/
/CONSTA/
/DGEOM/
/F4PARS/
/IOUNIT/
/OMITPR/
/PHASE/
/PRBLEM/
/PRPKCN/
/PRPKFN/
/REFINE/
/REFIPR/
/REFLNS/
/SATELL/
/SCRACH/
/SOURCE/
/TTHMNC/
      DATA VFMT/'(/'' Reflections to be used:''/'' Serial  h'',3X,''k'',
     &3X,''l'',2X,''  Argument  D-spacing M'',7X,''F = A + iB'',5X,    '
     &'F*F     Intensity'')'/
      DATA VFMM/'(/'' Reflections to be used:''/'' Serial  h'',3X,''k'',
     &3X,''l'',2X,''  Argument  D-spacing M'',3X,''    F*F   '',6X,    '
     &'Q*Q        Intensity'')'/
%      DIMENSION STHMX(%SORC%)
      SAVE STHMX
      DO 9 I=1,NSOURC
   9  STHMX(I)=STHMXX(I)
C
C DECIDE WHETHER INDICES MAY HAVE FRACTIONAL PARTS:
C
      FIXED=(.NOT. MAG .OR. (IPROP.LE.0))
      IF (.NOT. FIXED) THEN
        VFMM(43:43)='5'
        VFMM(50:50)='5'
        VFMM(57:57)='4'
      ENDIF
C DECIDE WHETHER FCS MAY BE PRINTED:
      IF (TIC) THEN
        SFC= (ICDNO(1).NE.0.AND.ICDNO(6).NE.0)
      ELSE
        SFC= (RIET .OR. SAPS)
      ENDIF
      IF (.NOT. SFC) THEN
        VFMT(86:)=')'
        VFMT(86:)=')'
      ENDIF
C
C COUNT REFLECTIONS:
      MAXKK(JPHASE)=0
C
C FOR ALL SOURCES:
C      DO 5 JSOUR=1,NSOURC
C      JSOURC=JSOUR
      CALL LOGSOU(JSOURC)
C
C IF MODER +VE, SPACE GROUP ABSENCES TO BE EXCLUDED:
      MMODER=IABS(MODERR(JSOURC))
C SET SINTHETA/LAMBDA LIMIT
      SM=STHMXX(JSOURC)
      DSTAMX=2.*SM
C
C 88.10
      IF (MAG) THEN
   31  CALL ASK('Enter minimum d-spacing for magnetic reflections')
       CALL RDNUMS(MAGMIN,1,1,N,IER)
       IF (IER.NE.0) GO TO 31
       IF(MAGMIN.LE. (1/DSTAMX) ) THEN
        MAGMIN=1/DSTAMX
        WRITE(ITO,*),'Smaller than structural min, setting to ',MAGMIN
       ENDIF
      MAGMIN=1/MAGMIN
      ENDIF
C IF REQUIRED, OPEN FILE ON WHICH TO READ H,K,L,INTS:
      IF (MMODER .EQ. 1 .AND. .NOT. TIC) THEN
        MESSAG='File to read h,k,l list'
        NAMFIL='.HKL'
        INHKL=-9999
        CALL OPNFIL(INHKL,111)
      ELSE
C
C  SET UP TO GENERATE NUCLEAR HKLS:
        CALL SETGEN(SM)
      ENDIF
      MAGREF=1
      IF (MMODER .EQ. 1 .AND. .NOT. TIC) MAGREF=3
      NFLAG=-9999
C
C TYPE 1 READS LIST OF HKL'S TO USE FROM FILE:
C IF CAIL, READ INTS FOR EACH REFLECTION FROM PREVIOUS CYCLES
C IF SAPS/APES, READ INTS FOR EACH REFLECTION, AND POSSIBLY ALSO SIGS
C N.B. BOTH INTS AND SIGS HAVE THEIR SIGMAS THERE ALSO
   2  GO TO (46,47,49) , MAGREF
  49  N2G4L=NUMS
      CALL RDDATA(INHKL,IH,H,TF4P(1,MAXKK(JPHASE)+1),-6,NUMS)
      IF (NUMS .EQ. -9999) GO TO 4
C
      MUL=MULBOX(H)
C JOIN TO TEST WHETHER WANTED:
      GO TO 50
C
C HERE TO GENERATE ALL HKL'S WITHIN GIVEN MAX THETA:
   46 CALL GENMUL(H,NOMORE,MUL)
      IF (NOMORE) THEN
        IF (MAG .AND. IPROP .NE. 0) THEN
          MAGREF=2
          GO TO 2
        ELSE
          GO TO 4
        ENDIF
      ENDIF
      GO TO 50
C
   47 CALL GENMAG(H,NOMORE,MUL,SM,NFLAG)
      IF (NOMORE) THEN
C RESTORE FULL SYMMETRY IF NECESSARY (JBF modification)
        IF (NKSTAR.GT.1) CALL SYMBAK
        GO TO 4
      ENDIF
C
C IF ASKED, IGNORE SPACE GROUP ABSENCES:
C 90.83 ISPABS no good for magnetic peaks - hence use magabs
C 90.56  50  IF (.NOT. MAG .AND. MODERR(JSOURC) .GT. 0) THEN
  50  IF (MODERR(JSOURC) .GT. 0) THEN
        IF(MAGREF.EQ.1) THEN
           IF (ISPABS(H)) GO TO 2
        ENDIF
       IF(MAGREF.EQ.2) THEN
         IF(NFLAG.EQ.1) III=1
           IF(NFLAG.EQ.0) III=-1
           IF (MAGABS(H,III)) GO TO 2
        ENDIF
      ENDIF
      DSTAR(1)=VCTMOD(1.,H,2)
      IF (DSTAR(1) .GT. DSTAMX) GO TO 2
C
C 88.10 ADDED A DSTAR LIMIT FOR MAGNETIC REFLECTIONS
      IF(DSTAR(1).GT.MAGMIN.AND.MAGREF.EQ.2) GO TO 2
C CHECK WHETHER INDICES ARE IN LIST TO OMIT:
      M=1
      IF (MIS .GT. 0) CALL EQVEC(AMISS,H,MIS,M,0)
      IF (M .LE. MIS) GO TO 2
C
C CHECK LIMITS OF ARGK:
      KNOW=1
      CALL PCXX(5)
      IF (ARGK .LT. ARGMIN(JSOURC) .OR. (ARGMAX(JSOURC) .NE. 0. .AND.
     & ARGK .GT. ARGMAX(JSOURC))) GO TO 2
C
C CHECK REFLECTION IN GIVEN ASYMMETRIC UNIT:
      IF (MUL .EQ. 0) THEN
        WRITE (LPT,2000) H
2000    FORMAT (/' Reflection',3F5.1,' not in given unit -- IGNORED')
        GO TO 2
      ENDIF
C
C HERE TO ACCEPT A SET OF INDICES:
%      CALL ERRCHK(2,MAXKK(JPHASE),%REFS%,0,'reflections')
C
      IF(JSOURC.EQ.1) THEN
       CALL GMEQ(H,TEMREF(1,MAXKK(JPHASE)),1,3)
       TEMMUL(MAXKK(JPHASE))=FLOAT(MUL)
       ARG(MAXKK(JPHASE))=ARGK
      ELSE
       CALL GMEQ(H,TEMREF(1,MAXKK(JPHASE)-
     & LRFSRC(JSOURC,JPHASE)),1,3)
       TEMMUL(MAXKK(JPHASE)-LRFSRC(JSOURC,JPHASE))=FLOAT(MUL)
       ARG(MAXKK(JPHASE)-LRFSRC(JSOURC,JPHASE))=ARGK
      ENDIF
      GO TO 2
C
C ALL INDICES STORED NOW
   4  IF (MMODER .EQ. 1) CALL CLOFIL(INHKL)
C
      IF (MAXKK(JPHASE) .LE. 0) CALL ERRMES(1,0,
     & 'no reflections found in data limits')
C
C SORT INTO ORDER
      CALL SORTX(ARG,IORDER,MAXKK(JPHASE))
      IF (TIC .OR. (IPRNT(2) .GT. 0)) THEN
        IF (SFC) THEN
          DO 1 I=1,3
   1      H(I)=0.
          FCAL=FCALC(H)
          FC=CABS(FCAL)
          FCSQ=FC*FC
C 90.27 In INRFPR write which source reflections belong to.
          WRITE(LPT,2050) JSOURC,FC,FCSQ
2050      FORMAT (//'For source',I3,
     &  ':   Nuclear F(0,0,0)   is   ',F10.2/
     &    '        F(0,0,0)^2 is ',F12.2//)
        ENDIF
        IF (MAG) THEN
          WRITE(LPT,FMT='(A12,I3)')'For source: ',JSOURC
          WRITE(LPT,VFMM)
        ELSE
          WRITE(LPT,FMT='(A12,I3)')'For source: ',JSOURC
          WRITE(LPT,VFMT)
        ENDIF
      ENDIF
C** EXPAND THIS IF FLOATING
C ^^^^^ WRITE MORE IF I OR SIGS READ
C THIS IS OUTPUT IF ANY PRINTING AT ALL IS REQUESTED FOR REFLNS
C
      IF (SAPS .OR. APES) THEN
        NG4L=N2G4L/2
        PRECYC= NG4L .LT. NGENPS(4,JPHASE)
        IF (PRECYC) SIMUL=.TRUE.
      ENDIF
C
      IF(JSOURC.EQ.1) THEN
       KNOW=0
      ELSE
       KNOW=LRFSRC(JSOURC-1,JPHASE)
      ENDIF
      LOWST=KNOW+1
      KTIC=0
      DO 6 KSORT=1,MAXKK(JPHASE)
      IF (KNOW .GT.0) THEN
        DO 144 K=KNOW,LOWST,-1
        IF (ARG(IORDER(KSORT)) .GT. ARGN(K)) GO TO 143
        DO 142 I=1,3
        IF (ABS(TEMREF(I,IORDER(KSORT))-REFH(I,K)) .GT. .0001)
     &  GO TO 144
 142    CONTINUE
C SAME H,K,L WITH SAME ARG - IGNORE:
        GO TO 6
 144    CONTINUE
      ENDIF
 143  KNOW=KNOW+1
      CALL GMEQ(TEMREF(1,IORDER(KSORT)),REFH(1,KNOW),1,3)
      IF (FIXED) CALL INDFIX(REFH(1,KNOW),IH)
      CALL CELDER(REFH(1,KNOW),TEMP)
      DSTAR(KNOW)=SQRT(DSTAR2)
      DSP=1./DSTAR(KNOW)
      AMUL(KNOW)=TEMMUL(IORDER(KSORT))
      MUL=JFIX(AMUL(KNOW))
C ^^^^ THE FOLLOWING DO LOOP IS NEW
      IF (CAIL .OR. SAPS .OR. APES) THEN
        DO 16 IG=1,NGENPS(4,JPHASE)
        IT2=2*IG
        IT1=IT2-1
        F4PAR(IG,KNOW)=TF4P(IT1,IORDER(KSORT))
        F4PESD(IG,KNOW)=TF4P(IT2,IORDER(KSORT))
  16    CONTINUE
      ENDIF
      ARGK=ARG(IORDER(KSORT))
      ARGN(KNOW)=ARGK
      ICHR=' '
      IF (MODER .LT. 0) THEN
        IF (ISPABS(REFH(1,KNOW))) ICHR='*'
      ENDIF
      MAGNET = .NOT.MAGABS(REFH(1,KNOW),IKK)
      IF (MAGNET) THEN
        ISMAG(KNOW)=IKK
      ELSE
        ISMAG(KNOW)= 0
      ENDIF
C ARE WE DOING A STRUCTURE FACTOR CALCULATION?
      IF (SFC) THEN
C SET UP MULTIPLIERS OF F*F TO GIVE OBSERVED INTENSITY
        IF (TOF) THEN
          FAC=1./(DSTAR2*DSTAR2)
        ELSE
          IF (CN) FAC=1./(SIN(RAD*ARGK)*SIN(0.5*RAD*ARGK))
C 90.34          IF (LX) FAC=FAC*(1.+COS(DEG*ARGK)**2)
          IF (LX) FAC=ALPCOR*V(2)*V(2)
        ENDIF
C NOW CALCULATE NUCLEAR F*F IF REQUIRED
        STHL=0.5/DSP
        IF (ISMAG(KNOW). EQ .0) THEN
          FCAL=FCALC(REFH(1,KNOW))
          FC=CABS(FCAL)
          AF=REAL(FCAL)
          BF=AIMAG(FCAL)
          FCSQ = REAL(FCAL*CONJG(FCAL))
C IF TIC, WE STORE SEPARATE DETAILS OF NUCLEAR AND MAGNETIC INTENSITIES IN
C COMMON /REFLNS/ USING AICALC FOR ARG, AND AIOBS FOR NUCLEAR (+VE) OR
C MAGNETIC (-VE) INTENSITIES.
          IF (TIC) THEN
%            CALL ERRCHK(2,KTIC,%REFS%,0,'intensity contributions')
            AICALC(KTIC)=ARGK
            AIOBS(KTIC)=FAC*FCSQ*FLOAT(MUL)
          ENDIF
        ELSE
          FCSQ=0.
        ENDIF
C AND MAGNETIC Q*Q IF NECESSARY
        IF (MAGNET) THEN
          CALL FMCALC(REFH(1,KNOW),FMCMOD,FMCSQR)
          IF (TIC) THEN
%            CALL ERRCHK(2,KTIC,%REFS%,0,'intensity contributions')
            AICALC(KTIC)=ARGK
            AIOBS(KTIC)= -FAC*FMCSQR*FLOAT(MUL)
          ENDIF
        ELSE
          FMCSQR = 0.0
        ENDIF
        ANT(KNOW)=FAC*FLOAT(MUL)* (FCSQ + FMCSQR)
C NOW THE PRINTING IF REQUIRED
        IF (TIC .OR. (IPRNT(2) .GT. 0)) THEN
          IF (.NOT. MAG) THEN
            WRITE (LPT,2002) KNOW,ICHR,
     &      (IH(J),J=1,3),ARGK,DSP,MUL,AF,BF,FCSQ,ANT(KNOW)
          ELSE
            IF (IPROP.LE.0) THEN
              WRITE (LPT,2006) KNOW,ICHR,(IH(J),J=1,3),
     &        ARGK,DSP,MUL,FCSQ,FMCSQR,ANT(KNOW)
            ELSE
              WRITE (LPT,2012) KNOW,ICHR,(REFH(J,KNOW),J=1,3),
     &        ARGK,DSP,MUL,FCSQ,FMCSQR,ANT(KNOW)
            ENDIF
          ENDIF
        ENDIF
2002    FORMAT(' ',I5,A1,3I4,F12.3,F10.5,I3,3F9.3,F12.3)
2006    FORMAT(' ',I5,A1,3I4,F12.3,F10.5,I3,2(3X,F9.3),3X,F12.2)
2012    FORMAT(' ',I5,A1,3F6.2,F12.3,F10.5,I3,2(3X,2F9.3),F12.2)
      ELSE
C
C HERE IF WE CAN DO NO CALCULATIONS OF INTENSITY
C
        IF (TIC .OR. (IPRNT(2) .GT. 0)) THEN
C 88.02          IF (.NOT. MAG .AND. .NOT. ISPABS(KNOW)) THEN
C 88.02 ISPABS(1,KNOW) to ISPABS(REFH(1,KNOW) from KS diff.
          IF (.NOT. MAG .AND. .NOT. ISPABS(REFH(1,KNOW))) THEN
C IF TIC, WE STORE SEPARATE DETAILS OF NUCLEAR AND MAGNETIC REFLECTIONS IN
C COMMON /REFLNS/ USING AICALC FOR ARG, AND AIOBS FOR NUCLEAR (+VE) OR
C MAGNETIC (-VE) REFLECTIONS.
            IF (TIC) THEN
%              CALL ERRCHK(2,KTIC,%REFS%,0,'intensity contributions')
              AICALC(KTIC)=ARGK
              AIOBS(KTIC)= 100.*MUL
            ENDIF
          ENDIF
C AND MAGNETIC F*F IF NECESSARY
          IF (MAG .AND. .NOT. MAGABS(REFH(J,KNOW),IKK)) THEN
            IF (TIC) THEN
%              CALL ERRCHK(2,KTIC,%REFS%,0,'intensity contributions')
              AICALC(KTIC)=ARGK
              AIOBS(KTIC)= -100.*MUL
            ENDIF
          ENDIF
C
C AND NOW THE WRITING
C
          IF (FIXED) THEN
            WRITE (LPT,2004) KNOW,ICHR,(IH(J),J=1,3),ARGK,DSP,MUL
          ELSE
            WRITE (LPT,2014) KNOW,ICHR,(REFH(J,KNOW),J=1,3)
     &      ,ARGK,DSP,MUL
          ENDIF
        ENDIF
2004    FORMAT(' ',I4,A1,1X,3I4,3X,F12.3,1X,F10.5,1X,I3)
2014    FORMAT(' ',I4,A1,3F6.2,F12.3,1X,F10.5,1X,I3)
      ENDIF
C
C PAWLEY-TYPE SETTING UP - IF NO F4PAR(1 READ SET IT TO BE 1:
      IF (CAIL .AND. F4PAR(1,KNOW) .EQ. 0.) F4PAR(1,KNOW)=1.
      IF (RIET .OR. CAIL) GO TO 6
C
C IF SAPS OR APES, WE HAVE VARIOUS CASES:
C  A) ONCE WE HAVE STARTED, I, SIGI, SIGS AND SIGSIGS ARE ALL READ FROM .HKL
C  B) A .HKL FILE MAY HAVE I, SIGI BUT NO SGSQ AND SIGSIGS;  IN THAT CASE
C     THE INITIAL SIGS VALUES CAN BE CALCULATED BY FDXX (VIA PFXX(7))
C  C) IF THERE IS NO .HKL FILE, AT THIS POINT WE SHALL HAVE NO I AND NO SIGS.
C     IN THAT CASE WE NEED AN INITIAL CYCLE TO GENERATE I AND SIGI.
C     SIGS INITIALLY CAN COME VIA PFXX, AS IN (B).
C
C SAPS AND APES:
C INITIAL CYCLE NEEDED FOR VALUES OF I:
      IF (SAPS .OR. APES) THEN
        IF (PRECYC) THEN
C WE HAVE I VALUES, BUT NOT SIGS:
          CALL PCXX(5)
          CALL PFXX(7)
        ENDIF
      ENDIF
   6  CONTINUE
C FINISHED LIST. STORE NUMBER OF INTENSITIES IN MAXKK
      MAXKK(JPHASE)=KNOW
      IF (TIC) MAXKK(JPHASE)=KTIC
      LRFSRC(JSOURC,JPHASE)=KNOW
C   5  CONTINUE
      DO 10 I=1,NSOURC
  10  STHMXX(I)=STHMX(I)
      RETURN
      END

C
C
C
C
C LEVEL 1      SUBROUTINE LIMITS(YVALS,N,MIN,MAX,YMIN,YMAX)
      SUBROUTINE LIMITS(YVALS,N,MIN,MAX,YMIN,YMAX)
C
C *** LIMITS corrected by JCM 28 Dec 92 ***
C
CH Finds the maximum and minimum of the members of a given array
CA On entry YVALS is an array of REAL numbers
CA          N is the number of elements in the array (and must be > 0)
CA On exit  YMIN is the smallest value found, occurring at element MIN
CA          YMAX is the largest value found, occurring at element MAX
C
CN If all elements are equal, MIN=1 and MAX=N
C
      DIMENSION YVALS(N)
C
      MIN=1
      MAX=N
      YMIN=YVALS(1)
      YMAX=YVALS(1)
      DO 1 I=1,N
      IF (YVALS(I).LT.YMIN) THEN
        YMIN=YVALS(I)
        MIN=I
      ENDIF
      IF (YVALS(I).GT.YMAX) THEN
        YMAX=YVALS(I)
        MAX=I
      ENDIF
   1  CONTINUE
      RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE LOGPHA(N)
      SUBROUTINE LOGPHA(N)
C
C *** LOGPHA by JCM 16 May 90 ***
C
CH Converts integer descibing refinement type to and from logicals
CA On entry N=which phase
CD Takes METHOD from /SOURCE/ and sets one of the logicals RIET, CAIL, SAPS,
CD APES, RAPS etc.
C
/REFIPR/
/SOURCE/
C
      RIET=METHOD(N).EQ.1
      CAIL=METHOD(N).EQ.2
      SAPS=METHOD(N).EQ.3
      APES=METHOD(N).EQ.4
      RAPS=METHOD(N).EQ.5
C
 100  RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE LOGSOU(N)
      SUBROUTINE LOGSOU(N)
C
C *** LOGSOU updated by JCM 23 Feb 93 ***
C
CH Converts integer descibing data source to logicals
CA On entry N=which source
CD Sets one of the logicals TOF, CN, LX, SR, ED
C
/BRAGG/
/PHASE/
/REFINE/
/REFIPR/
/SOURCE/
C
      TOF=NDASOU(N).EQ.1
      CN=NDASOU(N).EQ.2
      LX=NDASOU(N).EQ.3
      SR=NDASOU(N).EQ.4
      ED=NDASOU(N).EQ.5
C 90.14
      SINTH=SIN(RADIAN(TWOTHD(N)/2.))
C 90.37 Read in appropriate form factors for this source
      CALL SWAPFC(N,JPHASE,-1)
 100  RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE LOGSET
      SUBROUTINE LOGSET
C
C *** LOGSET updated by JCM 14 Nov 90 ***
C
CH Sets up logicals needed for PR after variables have been made
CD Sets NOPKRF for "no peak refine", that is, there are no peak descriptor
CD parameters being refined on this cycle.
CD Sets CYC1 for "this is cycle 1" (CYC1 is thus also .TRUE. if this is
CD the pre-cycle for SAPS or APES.)
C
/CONSTR/
/F4PARS/
/PHASE/
/POINTS/
/PRBLEM/
/PRPKFN/
/REFINE/
/REFIPR/
/REFLNS/
/SOURCE/
C
      CYC1=(ICYC .EQ. NCYC1)
C
C SET NOPKRF TO BE TRUE IF NO PEAK FUNCTION PARAMETERS ARE TO BE REFINED:
      NOPKRF=.FALSE.
      DO 1 JP=1,NPHASE
      DO 1 JS=1,NSOURC
      DO 1 I=1,NPKGEN(JP,JS)
      DO 1 J=1,NPKFSP(I,JP,JS)
      IF (KPFNSP(I,J,JP,JS) .GT. 0) GO TO 9
   1  CONTINUE
      NOPKRF=.TRUE.
   9  CONTINUE
C
**
C IF CAIL, SET UP 2 VECTORS OF BASIC VARIABLE NUMBERS FOR INTS:
      IF (CAIL) THEN
C AND OVER ALL PHASES:
        DO 20 JP=1,NPHASE
        DO 3 K=1,MAXKK(JP)
C NB=WHICH BASIC (OR REDUNDANT) VARIABLE THIS "INTS" IS:
        NB=KF4PAR(1,K)
        IF (NB .GT. 0) NB=LVRBS(NB)
C IF REDUNDANT, IT SHOULD BE BY A SIMPLE CONSTRAINT - SET NB TO BE THE
C BASIC VARIABLE INVOLVED:
        IF (NB .LT. 0) NB=JCMAT(JROWPT(-NB))
        NBASF4(K,1,JP)=NB
        NBASF4(K,2,JP)=NB
   3    CONTINUE
C NOW FILL IN ANY ZEROS (EXCEPT AT THE TWO ENDS) -  ( ,1)=THE FIRST
C NON-ZERO FOR INCREASING K, ( ,2)= THE FIRST NON-ZERO FOR DECREASING K:
        DO 5 K=1,MAXKK(JP)
        IF (NBASF4(K,1,JP) .GT. 0) GO TO 5
        DO 6 I=K+1,MAXKK(JP)
        IF (NBASF4(I,1,JP) .EQ. 0) GO TO 6
        NBASF4(K,1,JP)=NBASF4(I,1,JP)
        GO TO 4
   6    CONTINUE
C
   4    DO 7 I=K-1,1,-1
        IF (NBASF4(I,2,JP) .EQ. 0) GO TO 7
        NBASF4(K,2,JP)=NBASF4(I,2,JP)
        GO TO 5
   7    CONTINUE
   5    CONTINUE
C POINT TO LAST FAMILY 4 BASIC VARIABLE:
        L4END(JP)=LBFST1(4,JP,1)+NBARF(4,JP,1)
  20    CONTINUE
C
      ENDIF
C POINTERS TO START & END OF FAMILY 6 (PHASE-INDEPENDENT):
      L6ST=LBFST1(6,1,1)+1
      L6END=LBFST1(6,1,1)+NBARF(6,1,1)
C
 100  RETURN
      END
C
C
C
C
C LEVEL 2      SUBROUTINE LOWER(C)
      SUBROUTINE LOWER(C)
C
C *** LOWER by JCM 3 Aug 92 ***
C
CX
CC 13C
CH Replaces any upper case letters in C by lower case.
C
      CHARACTER *(*) C
/CHARS/
C
      L=LENGT(C)
      DO 1 I=1,L
      M=LETTER(C(I:I))
      IF (M .GT. 0) C(I:I)=LETLOW(M)
   1  CONTINUE
      RETURN
      END
C
C
C
C
C LEVEL 6      SUBROUTINE LPSCAL(N)
      SUBROUTINE LPSCAL(N)
C
C *** LPSCAL MK4 BY JCM AUG 89 ***
C
CH Deals with the Profile LSQ parameter SPHA, scale for this phase.
CA On entry N gives the required action:
CA   N=1 reads in an L SPHA card and records the scale factor for this phase
CA   N=3 applies a shift to a specific scale
CA   N=4 writes out a new L SPHA card to unit NEWIN
CA   N=5 deals with absence of L SPHA card
C
/CARDRC/
/IOUNIT/
/LREAD/
/NEWOLD/
/PHASE/
C
      GO TO (1,100,3,4,5) , N
C
   1  CALL RDREAL(SCALEP(JPHASE),7,IPT,80,IER)
      IF (IER .NE. 0) IERR=IERR+1
      WRITE (LPT,2000) JPHASE,SCALEP(JPHASE)
2000  FORMAT (/' Scale factor for phase',I4,' =',F10.4)
      GO TO 100
C
   3  CALL ADJUST(SCALEP(JPHASE))
      GO TO 100
C
C NEW L SPHA CARD:
   4  WRITE (NEWIN,2005) (SCALEP(JPHASE))
2005  FORMAT ('L SPHA',F10.5)
      GO TO 100
C
C N=5 - DEAL WITH NO SCAL CARDS:
   5  SCALEP(JPHASE)=1.0
      GO TO 100
C
C
      ENTRY LPSCA8(NV)
C RECORD THAT THIS PHASE'S SCALE IS VARIABLE NUMBER NV:
      KSCALP(JPHASE)=NV
      GO TO 100
C
C
      ENTRY LPSCA9
C RECORD THAT THIS PHASE'S SCALE IS FIXED:
      KSCALP(JPHASE)=0
C
 100  RETURN
      END
C
C
C
C
C LEVEL 9      SUBROUTINE LSETPR(PCXX,PFXX)
      SUBROUTINE LSETPR(PCXX,PFXX)
C
C *** LSETPR updated for MK4 by JCM 25 Jan 91 ***
C
CX
CC 6A
CH Set up specific LSQ problem - copy vocabulary to standard COMMON
CP The problem must have already been specified to the extent of:
CP    NFAM=number of families
CP    NGENPS(I,JPHASE)=number of genera in family I, phase JPHASE
CP    NSPCPS(I,JPHASE)=number of species in each genus of family I, phase JPHASE
CD Packs the LSPEC integers to 1 word, with phase and source, usually both
CD zero.
CD Copies both arrays LSPEC and LWORDS into standard arrays IWDSPC  and
CD LSQWD in /WDSPEC/ and /WORDS/.
CD Sets up pointers to starts of families of parameters.
CD Sets up the packing of IFAM, IGEN, ISPC, PHASE, SOURCE  into one integer
CD Sets up the permanent fix, vary and constraint lists
C
      EXTERNAL PFXX,PCXX
      EXTERNAL F2PARS
      EXTERNAL PRPARS
%      CHARACTER *4 TEMWRD(%WORD%)
%      DIMENSION ITMWRD(3,%WORD%)
      DIMENSION LPAK(5)
/F2NAMS/
/F2NUMS/
/GLOBAL/
/IOUNIT/
/LINKAG/
/LSETDA/
/LSQPAK/
/PHASE/
/PRBLEM/
/PRNAMS/
/PRNUMS/
/SOURCE/
/WDSPC/
/WORDS/
C
C125 Force inclusion of BLOCK DATA F2PARS
      CALL F2PARP
C ONLY ENTRY IF SINGLE PHASE, OR FIRST ENTRY IF MULTIPHASE:
      IF (JPHASE .EQ. 1) THEN
        MFAM=0
        MGEN=0
        MSPC=0
C
C PREPARE FIX LIST AND CONSTRAINT LIST FOR CALLS OF ADDFIX, ADDCON
        NUMFV=0
        NUMPAK=0
        NUMCON=0
        KPTCON(1)=1
      ENDIF
C
%      CALL ERRCHK(1,NFAM,%FAMS%,0,'LSQ families of parameters')
C
C STARTS OF FAMILIES OF PARAMETERS:
      IF (NFAM .GT. MFAM) MFAM=NFAM
      DO 1 I=1,NFAM
      IF (NGENPS(I,JPHASE) .GT. MGEN) MGEN=NGENPS(I,JPHASE)
      IF (NSPCPS(I,JPHASE) .GT. MSPC) MSPC=NSPCPS(I,JPHASE)
   1  CONTINUE
C
C IF LAST PHASE:
      IF (JPHASE .EQ. NPHASE) THEN
C SET UP PACKING OF IFAM,IGEN,ISPC,PHASE,SOURCE:
        LPAK(1)=MFAM
        LPAK(2)=MGEN
        LPAK(3)=MSPC
        LPAK(4)=NPHASE
        LPAK(5)=NSOURC
C THIS INITIALISES ALL SUBSEQUENT CALLS OF KPAK, KUNPAK
        L=3
        IF (MULONE) L=5
        CALL NPACK(N,LPAK,L,0,KKPACK)
C
C WORDS RELEVANT TO THIS PROBLEM FROM DATA INTO COMMON:
        KPHASE=0
        KSOURC=0
C SET UP VOCABULARY: FIRST, THE CORE FOR ALL STRUCTURE FACTOR LSQ:
        IWDNUM=0
%        CALL VOCAB(F2NAME,NF2NUM,%F2PR%)
C
C THEN A DEFAULT PROFILE VOCABULARY:
%        CALL VOCAB(PRNAME,NPRNUM,%PRPR%)
C
C ADD SPECIAL VOCABULARY LINKED TO PEAK FUNCTION:
        DO 3 JSOUR=1,NSOURC
        JSOURC=JSOUR
        KPHASE=0
        KSOURC=JSOURC
   3    CALL PFXX(1)
C
      ENDIF
 100  RETURN
      END
C
C
C
C
      BLOCK DATA PRPARS
/PRNAMS/
/PRNUMS/
      DATA PRNAME/
     & 'PKFN','FAM4','FAM6',
     & 'EXTN','PROR','SPHA',
     & 'ZERO','PKCN','INTS','SIGS','GAMS',
     & 'SCAL','ABSC','BACK'/
      DATA NPRNUM/
     & 3,0,0, 4,0,0, 6,0,0,
     & 1,1,8, 1,1,9, 1,1,10,
     & 3,1,0, 3,2,0, 4,1,0, 4,2,0, 4,3,0,
     & 6,1,1, 6,2,0, 6,3,0/
      END
C
C
C
C
C LEVEL 6      SUBROUTINE LSSCAL(N)
      SUBROUTINE LSSCAL(N)
C
C *** LSSCAL MK4 by JCM Aug 89 ***
C
C DOES MOST OF THE DEALING WITH THE PARAMETER IN LSQ CALLED 'SCAL' FOR SCALE
C FACTORS.
C
** FOR THE MOMENT WE HAVE LOST N=0 - SO THERE MUST BE AN L SCAL CARD
C N=0 DEALS WITH THE INTRODUCTION OF A SINGLE SCALE FACTOR OF 1., TO BE REFINED,
C     IF NO L SCAL CARDS HAVE BEEN READ.
C N=1 READS IN AN L SCAL CARD AND RECORDS THE SCALE FACTORS
C N=2 DOES NOT FOR THE MOMENT EXIST.  IF IT DID, IT WOULD DO THE 'CALCULATE'
C     STEP, I.E. SEND OUT A CALCULATED VALUE TO USE IN THE REFINEMENT. SINCE
C     THIS IS ACTUALLY A TRIVIAL OPERATION, IT IS DONE IN THE VARIOUS
C     SUBR0UTINES 'CALCXX' RATHER THAN BY A SPECIAL CALL TO LSSCAL.
C N=3 APPLIES A SHIFT TO A SPECIFIC SCALE(ISPC)
C N=4 WRITES OUT A NEW L SCAL CARD
C N=-4 WRITES OUT A NEWLY GENERATED SCALE CARD (IF THERE HAD BEEN NONE AT ALL,
C      SO ONE HAD BEEN MADE
C
/CARDRC/
/IOUNIT/
/LREAD/
/NEWOLD/
/PHASE/
/SOURCE/
C 90.45
      LOGICAL READ
      SAVE READ
      DATA READ /.FALSE./
C
      IF (N .EQ. 0) THEN
        CALL ERRMES(3,1,'L SCAL')
        GO TO 100
      ENDIF
C
      GO TO (1,100,3,4) , N
C
C 90.03,90.45 %   1  CALL RDNUMS(SCALES,7,%SORC%,NUM,IER)
   1  IF(READ) THEN
       CALL ERRMES(1,0,'Found more than one card labelled L SCAL')
      ELSE
       CALL RDNUMS(SCALES,7,NSOURC,NUM,IER)
       IF (IER .NE. 0) IERR=IERR+1
       IER=IERR
       IF (IER .NE. IERR) GO TO 100
C
       CALL MESS(LPT,1,'Scale factor(s) :')
       CALL PRILIS(SCALES,1,NUM)
       READ=.TRUE.
       ENDIF
      GO TO 100
C
C TAKE CARE ONLY TO APPLY THE SHIFT ONCE:
   3  IF (JPHASE .EQ. 1) CALL ADJUST(SCALES(JSOURC))
      GO TO 100
C
C NEW L SCAL CARD:
   4  WRITE (NEWIN,2005) (SCALES(J),J=1,NSOURC)
C 90.69 8F10.5 previously.
2005  FORMAT ('L SCAL',8(1X,G11.5))
** PROVISION FOR *S NEEDED
      GO TO 100
C
C
      ENTRY LSSCA8(NV)
C RECORD THIS SOURCE'S SCALE IS VARIABLE NUMBER NV:
      KSCALS(JSOURC)=NV
      GO TO 100
C
C
      ENTRY LSSCA9
C RECORD THIS SOURCE'S SCALE IS FIXED:
      KSCALS(JSOURC)=0
C
 100  RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE MATTOS(ALSQ,MATSZ)
      SUBROUTINE MATTOS(ALSQ,MATSZ)
C
C *** MATTOS updated by JCM 23 Jun 92 ***
C
C SPEEDED UP CAILS-TYPE VERSION OF  MATTOT
C
C ALL REFERENCE TO THE LSQ MATRIX, ALSQ, IS MADE THROUGH ROUTINES STARTING "MAT"
C THIS ENABLES ALSQ TO BE DIMENSIONED EVERYWHERE EXCEPT IN MAIN AS ALSQ(MATSZ)
C
C   MATTOT  ADDS IN CONTRIBUTIONS TO LSQ MATRIX AND RHS FOR THIS OBSERVATION
C
C 90.57 add some IF's to avoid array overstepping with 0 LSQ vars
C
%      DIMENSION ALSQ(MATSZ),MM(%BVAR%)
      EQUIVALENCE (MM(1),MATPNT(2))
/DERBAS/
/MATDAT/
/OBSCAL/
/PHASE/
/PRBLEM/
/PRPKFN/
/REFINE/
/REFLNS/
C
      IF (SIMUL) GO TO 100
      SQWDIF=SQRTWT*DIFF
C
C THIS ONLY WORKS IF THERE ARE NOT 2 CAIL PHASES, (& AT PRESENT IF THE CAIL
C PHASE IS AT THE END)
      DO 3 I=1,LBFST1(4,JPHASE,1)
   3  DERIVB(I)=SQRTWT*DERIVB(I)
      IF (KMAX.NE.0) THEN
        DO 4 I=NBASF4(KMIN,1,JPHASE),NBASF4(KMAX,2,JPHASE)
   4    IF (I.NE.0) DERIVB(I)=SQRTWT*DERIVB(I)
      ENDIF
      DO 9 I=L6ST,L6END
   9  DERIVB(I)=SQRTWT*DERIVB(I)
C
      DO 1 I=1,LBFST1(4,JPHASE,1)
      IR=MM(I)
      DO 2 J=I,LBFST1(4,JPHASE,1)
   2  ALSQ(IR+J)=ALSQ(IR+J)+DERIVB(I)*DERIVB(J)
      IF (KMAX.NE.0) THEN
        DO 5 J=NBASF4(KMIN,1,JPHASE),NBASF4(KMAX,2,JPHASE)
   5      IF (J.NE.0)
     &      ALSQ(IR+J)=ALSQ(IR+J)+DERIVB(I)*DERIVB(J)
      ENDIF
      DO 8 J=L6ST,L6END
   8  ALSQ(IR+J)=ALSQ(IR+J)+DERIVB(I)*DERIVB(J)
   1  BLSQ(I)=BLSQ(I)+SQWDIF*DERIVB(I)
C
      IF (KMAX.NE.0.AND.NBASF4(KMIN,1,JPHASE).NE.0) THEN
        DO 6 I=NBASF4(KMIN,1,JPHASE),NBASF4(KMAX,2,JPHASE)
        IR=MM(I)
        DO 7 J=I,NBASF4(KMAX,2,JPHASE)
   7    ALSQ(IR+J)=ALSQ(IR+J)+DERIVB(I)*DERIVB(J)
        DO 10 J=L6ST,L6END
  10    ALSQ(IR+J)=ALSQ(IR+J)+DERIVB(I)*DERIVB(J)
   6    BLSQ(I)=BLSQ(I)+SQWDIF*DERIVB(I)
      ENDIF
C
      DO 11 I=L6ST,L6END
      IR=MM(I)
      DO 12 J=I,L6END
  12  ALSQ(IR+J)=ALSQ(IR+J)+DERIVB(I)*DERIVB(J)
  11  BLSQ(I)=BLSQ(I)+SQWDIF*DERIVB(I)
C
 100  RETURN
      END
C
C
C
C
C LEVEL 7      SUBROUTINE NWIND2
      SUBROUTINE NWIND2
C
C *** NWIND2 updated by JCM 20 Aug 92 ***
C
CX
CC 7B
CH Writes out a new Crystal Data File for the main program CELLSQ.
CP NWIND2 must be called in the context of CELLSQ, with an old Crystal
CP Data File held on the scratch unit number IO10.  A cycle of
CP LSQ refinement should have adjusted some of the parameters involved.
CD Writes out a new CDF with possibly changed values on the C card or
CD L PKCN, L ZERO or L THE2 cards.
C
CO Writes the updated file to unit NEWIN.
C
      CHARACTER *4 WORD
/CARDRC/
/NEWOLD/
/SCRACH/
C
      CALL NEWCD
      ID=0
   1  ID=ID+1
      IF (ID .GT. NTOTAL(1)) GO TO 100
      READ(IO10,FMT=1000,REC=ID) ICARD
1000  FORMAT (A80)
      L=LETTER(ICARD(1:1))
      IF (L .EQ.3) THEN
C
C OUTPUT NEW C CARD WITH NEW VALUES:
        CALL CELNEW
        GO TO 1
      ELSE IF (L .EQ. 9) THEN
C
C OUTPUT NEW I CARD:
        CALL OTPUTI
        GO TO 1
      ELSE IF (L .EQ. 12) THEN
C
C IF 'L' IS IT ALSO 'PKCN', 'ZERO' OR 'THE2'?
        CALL RDWORD (WORD,ILEN,3,IPT,80,0,IER)
C NEW L PKCN CARD:
        IF (WORD .EQ. 'PKCN') THEN
          CALL PCTF01(4)
          GO TO 1
        ELSE IF (WORD .EQ. 'ZERO') THEN
C NEW L ZERO CARD:
          CALL ZEROPR(4)
          GO TO 1
C NEW L THE2 CARD:
        ELSE IF (WORD .EQ. 'THE2') THEN
          CALL THETA2(4)
          GO TO 1
        ENDIF
      ENDIF
C COPY UNCHANGED CARD:
      WRITE (NEWIN,2000) (ICARD(I:I),I=1,LENGT(ICARD))
2000  FORMAT (80A1)
      GO TO 1
C
 100  RETURN
      END
C
C
C
C
C LEVEL 9      SUBROUTINE NWINPR(PCXX,PFXX,MAGSHF)
      SUBROUTINE NWINPR(PCXX,PFXX,MAGSHF)
C
C *** NWINPR updated by PJB 1 Feb 1994 ***
C
CC 19B
CH Output updated Crystal Data file to unit NEWIN
C
CP All necessary shifts must have already been applied, say by APSHPR
CD Rereads all cards;  selects those which contain variables
CO Writes all new and unchanged cards to unit NEWIN, using calls to
CO parameter-specific routines
C
C
      DIMENSION IH(3)
      CHARACTER *4 WORD,CHANGE(14)
/CARDRC/
/F4PARS/
/GLOBAL/
/GRDBCK/
/NEWOLD/
/PHAS0/
/PHASE/
/PRPKCN/
/REFINE/
/REFIPR/
/REFLNS/
/SCRACH/
/SLAKDA/
/SLKGEO/
/SOURCE/
      DATA CHANGE/'TFAC','SCAL','RTYP','PKCN','PKFN','ZERO','ATOM',
     & 'BACK','ABSC','EXTN','PROR','TTHM','SPHA','WVLN'/
C
      IF (SIMUL) GO TO 100
C OPEN NEW CD FILE:
      CALL NEWCD
C
C START RECORD COUNT IN IO10:
      ID=0
      JPHASE=1
C 90.38 write out old before reading in new.
      CALL PHMOVE(-1,IPHASE)
      CALL PHMOVE(1,1)
C
   1  ID=ID+1
      IF (MULFAS .AND. ID .EQ. NCDF0+1) WRITE (NEWIN,2005)
      IF (ID .GT. NTOTAL(JPHASE)) THEN
        IF (JPHASE .EQ. NPHASE) GO TO 100
        WRITE (NEWIN,2005)
2005    FORMAT ('**')
        JPHASE=JPHASE+1
        CALL PHMOVE(1,JPHASE)
      ENDIF
      READ(IO10,REC=ID,FMT=1000) ICARD
1000  FORMAT(A80)
      L=LETTER(ICARD(1:1))
      IF (L .EQ.3) THEN
C OUTPUT NEW C CARD WITH NEW VALUES:
        CALL CELNEW
        GO TO 1
      ELSE IF (L .EQ. 12) THEN
C L CARD - CONSULT LIST OF WORDS INDICATING CARDS TO CHANGE
        CALL RDWORD(WORD,IWDLEN,3,IPT,80,0,IER)
        N=NCFIND(WORD,CHANGE,14)
        IF (N .EQ. 0) GO TO 2
C
        GO TO (21,22,23,24,25,26,27,28,29,30,31,32,33,34), N
C
      ELSE IF (L.EQ.1 .OR. L.EQ.20) THEN
C 90.38 No longer.... TREAT A, F AND T ALIKE:
C but for L=6 (F card) just reproduce the old one.
C NOT IF CAIL/APES - THERE WILL BE NO STRUCTURE PARAMETERS:
        IF (CAIL .OR. APES) GO TO 2
        CALL F2NEW(L)
        GO TO 1
      ELSE IF (L .EQ. 17) THEN
C "Q" CARD:
        IF (.NOT. MAG) GO TO 2
        IF (CAIL .OR. APES) THEN
          CALL PROPAG(4,NEWIN)
        ELSE
          CALL MAGSHF(4)
        ENDIF
        GO TO 1
      ELSE IF (L .EQ. 9) THEN
C OUTPUT NEW I CARD:
        CALL OTPUTI
        GO TO 1
      ENDIF
      GO TO 2
C
C TFAC:
  21  CALL LLTFAC(4)
      GO TO 1
C
C SCAL:
  22  CALL LSSCAL(4)
      GO TO 1
C
C RTYP:
  23  MM=MODERR(JSOURC)
      CALL LOGSOU(JSOURC)
      IF (IABS(MM) .NE. 3) MM=ISIGN(1,MM)
      IF (TOF) THEN
        WRITE(NEWIN,2001) MM,ARGMIN(JSOURC),ARGMAX(JSOURC)
2001    FORMAT ('L RTYP',I5,2F10.2)
      ELSE
        WRITE (NEWIN,2002) MM,ARGMIN(JSOURC),ARGMAX(JSOURC),
     &  ARGSTP(JSOURC)
2002    FORMAT ('L RTYP',I5,3F10.3)
      ENDIF
      GO TO 1
C
C PKCN:
  24  CALL RDWORD(WORD,LEN,IPT,IPT,80,1,IER)
C 90.08 Set JSOURC=KSOURC for further writing
      IF (WORD .EQ. 'TYPE') THEN
       JSOURC=KSOURC
       CALL LOGSOU(JSOURC)
       GO TO 2
      ENDIF
      CALL PCXX(4)
** TEMPORARY - PFXX - IE PFALL - IGNORES ITS OWN 'TYPE' CARDS
      GO TO 1
C
C PKFN:
  25  CALL PFALL(4)
      GO TO 1
C
C ZERO:
  26  CALL ZEROPR(4)
      GO TO 1
C
C L ATOM
  27  CALL GEOMCO(3)
      GO TO 1
C
C L BACK
  28  IF (IBACK .LE. 0) GO TO 2
      CALL BACKPR(4)
      GO TO 1
C
C ABSC
  29  CALL ABCRPR(4)
      GO TO 1
C
C EXTN
  30  CALL EXCRPR(4)
      GO TO 1
C
C PROR
  31  CALL PREFOR(4)
      GO TO 1
C
C TTHM
  32  CALL TTHMLX(4)
      GO TO 1
C
C SPHA:
  33  CALL LPSCAL(4)
      GO TO 1
C WVLN:
  34  CALL PCXX(4)
      GO TO 1
C
C COPY UNCHANGED CARD:
   2  WRITE (NEWIN,2000) (ICARD(I:I),I=1,LENGT(ICARD))
2000  FORMAT (80A1)
      GO TO 1
C
C
 100  RETURN
      END
C
C
C
C
C LEVEL 11       SUBROUTINE OUTTIC
      SUBROUTINE OUTTIC
C
C *** OUTTIC by JBF 17 June 93. ***
C
CH To write an ascii file of TIC marks for GENIE plots
CD Reads an I card for TICS followed by integer:
CD a non-zero integer requests TICs as amplitudes proportional
CD to calculated intensity in powder pattern. Default 0, amplitudes are +/- 10.
CD +ve for nuclear, -ve for magnetic.
C
      LOGICAL NOMORE,ISPABS,SFC,FIXED,MAGABS,LATABS,ONCARD
      CHARACTER *4 INEED
      DATA INEED/'TICS'/
      CHARACTER *1 ICHR(4)
      CHARACTER *127 VFMT
      COMPLEX FCALC,FCAL
      EXTERNAL PCXX,PFXX
%      DIMENSION IH(3),H(3),TEMREF(3,%REFS%),IORDER(%REFS%)
%      DIMENSION TEMMUL(%REFS%),ARG(%REFS%),TF4P(6,%REFS%),TEMP(6)
%      DIMENSION ARGN(%REFS%),ANT(%REFS%)
/IOUNIT/
/PHASE/
/REFLNS/
/SCRACH/
/SOURCE/
C
      MESSAG='TIC list'
      NAMFIL='.TIC'
      CALL OPNFIL(ITC,112)
      ITIC=0
C INTERPRET I CARD:
      IF (.NOT. ONCARD('I',INEED,A)) GO TO 2
C TICS RECOGNISED
      IF (JFIX(A).NE.0) ITIC=1
    2 ESD = 0.1
      DO 1 KNOW=1,MAXKK(1)
      IF(ITIC .EQ. 0) THEN
        ATIC=10.
        IF (AIOBS(KNOW) .LT. 0.) ATIC= -10.
        WRITE (ITC,1000) AICALC(KNOW),ATIC,ESD
      ELSE
        WRITE (ITC,1000) AICALC(KNOW),AIOBS(KNOW),ESD
      ENDIF
    1 CONTINUE
 1000 FORMAT (F10.2,2(F12.1))
      RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE P0TEMP(L)
      SUBROUTINE P0TEMP(L)
C
C *** P0TEMP by JCM 23 Jan 92 ***
C
CH Sets or unsets phase 0 for L cards temporarily
C
      LOGICAL L
/CARDRC/
/GLOBAL/
/PHAS0/
C
      IF (L) THEN
        INRLP1=INREA(12,1)
        ICDLP1=ICDN(12,1)
        INREAD(12)=INRLP0
        ICDNO(12)=ICDLP0
      ELSE
        INREAD(12)=INRLP1
        ICDNO(12)=ICDLP1
      ENDIF
      RETURN
      END
C
C
C
C
C LEVEL 10      SUBROUTINE PARSPR(MAGPAR)
      SUBROUTINE PARSPR(MAGPAR)
C
C *** PARSPR updated by PJB C105 April 2001 ***
C
CH Collect all parameter fix and vary and relate info for 1 phase PR LSQ
CA On entry MAGPAR is replaced by the name of the subroutine to deal with
CA species 13,14,15 of family 2.  If non-magnetic, these should not occur,
CA so MAGPAR=LDUMMY.  For magnetic, MAGPAR=DOMAG (or MAGCNL from PARSPR).
CP On entry JPHASE and JSOURC should hold phase and source.
CP Type of refinement, RIET, CAIL, SAPS, APES 1, must be set in /REFIPR
C
      DIMENSION ISPVEC(10)
      LOGICAL CLAIMD
C
/GLOBAL/
/NEWOLD/
/PHASE/
/REFINE/
/REFIPR/
/SOURCE/
C
C ABSORB EXISTING CONSTRAINTS ON CELL PARAMETERS DUE TO SYMMETRY:
      CALL CELREL(1,1,2)
C
C ABSORB EXISTING CONSTRAINTS ON STRUCTURE PARAMETERS DUE TO SYMMETRY:
      IF (RIET .OR. SAPS) THEN
C SPECIES OF X:
        ISPVEC(1)=1
C SPECIES OF B11:
        ISPVEC(2)=4
C SPECIES OF SCAT:
        ISPVEC(3)=10
        CALL F2RELA(2,ISPVEC)
      ELSE
C FIX ALL FAMILY 2 IF CAIL:
        CALL ADDFX5(2,0,0,JPHASE,1,5)
      ENDIF
C
C DEAL WITH ABSENCE OF L TFAC CARD:
      IFAM=1
      IGEN=1
      ISPC=1
      CALL LLTFAC(6)
C
C DEAL WITH ABSENCE OF L ABSC CARD:
      DO 1 JSOUR=1,NSOURC
      JSOURC=JSOUR
    1 CALL ABCRPR(6)
C
C DEAL WITH ABSENCE OF L EXTN CARD:
      CALL EXCRPR(6)
C
C DEAL WITH ABSENCE OF L PROR CARD:
      CALL PREFOR(6)
C
C IF XRAY, DEAL WITH ABSENCE OF 'L TTHM' CARD:
      IF (LX) CALL TTHMLX(6)
C
C DEAL WITH ALL MAGNETIC CONSTRAINTS IF APPROPRIATE:
      CLAIMD = MAGPAR(0,1)
C
      JSOURC=1
C IF MULTIPHASE, THERE IS A PHASE 0 WHICH MUST ALSO BE SCANNED:
      IF (MULFAS .AND. JPHASE .EQ. 1) THEN
        CALL P0TEMP(.TRUE.)
C READ ALL 'L RELA' CARDS:
        CALL RDRELA
C READ ALL 'L FUDG' CARDS:
        CALL FUDGIN
C READ ALL 'L FIX' AND 'L VARY' CARDS:
        CALL RDFV(MAGPAR)
        CALL P0TEMP(.FALSE.)
      ENDIF
C READ ALL 'L RELA' CARDS:
      CALL RDRELA
C READ ALL 'L FUDG' CARDS:
      CALL FUDGIN
C READ ALL 'L FIX' AND 'L VARY' CARDS:
      CALL RDFV(MAGPAR)
      RETURN
      END
C
C
C
C
C LEVEL 4      SUBROUTINE PAWLS(ALSQ,MATSZ,NSLTYP)
      SUBROUTINE PAWLS(ALSQ,MATSZ,NSLTYP)
C
C *** PAWLS updated by JCM 10 Mar 89 ***
C
CC 19B
CH Application of Pawley-type slack constraints
CH Called from MAIN program to add to the LSQ matrix once per cycle
C
CA ALSQ and MATSZ are handed all through LSQ programs in this fashion
CA      - they are needed here for the call of MATTOT
CA NSLTYP=which type of constraint - only 3 at present:
C
CP On entry, /SLAKDA/ should contain NSLAK(NSLTYP)=actual number of slack
CP constraints of this type present.
CP On entry, /PAWLPR/ holds the paramters specs for these constraint
CP in ISPSLK with weights in WTSLAK.
C
CD For each slack constraint in turn, proceeds exactly as though these are
CD      conventional observations and calculated functions;  makes basic
CD      variable derivatives, gets weights, and adds totals in to LSQ matrix.
C
      LOGICAL PRNCYC
      DIMENSION ALSQ(MATSZ)
      DIMENSION DERS(3,2)
/DERVAR/
/F4PARS/
/IOUNIT/
/OBSCAL/
/PAWLPR/
/REFINE/
/REFIPR/
/SLAKDA/
C
C OUT IF SIMULATION CYCLE:
      IF (SIMUL) GO TO 100
C
C OUT IF NOT TYPE 3
      IF (NSLTYP .NE. 3) GO TO 100
C
C OUT IF NO SLACK CONSTRAINTS:
      IF (NSLAK(NSLTYP) .EQ. 0) GO TO 100
C
C HEADING FOR PRINTING IF REQUESTED:
      IF (PRNCYC(8)) THEN
        CALL MESS(LPT,1,'  Slack Constraints')
        CALL MESS(LPT,1,'  No.   Obs      Calc      Diff      Weight')
      ENDIF
C
C FOR NOW ONLY TYPE 3,  PAWLEY SLACK CONSTRAINTS FROM CAIL OR SAPS:
C COUNT ALL SLACK CONSTRAINTS:
      DO 1 ISK=1,NSLAK(NSLTYP)
C
C CLEAR WHOLE DERIVATIVE VECTOR - ONLY A FEW ITEMS WILL BE FILLED BY
C ANY PARTICULAR CONSTRAINT:
*** SO POSSIBLY WE WANT TO ADD 3 ITEMS TO THE LSQ MATRIX AND 1 TO THE RHS
*** DIRECTLY, RATHER THAN PRETEND THAT THESE ARE OBSERVATIONS ***
C
C ^^^^^ THE FOLLOWING SECTION NEEDS ATTENTION
C ^^^^^ WE COULD ALSO DO YCALC = F1/F2 -A1/A2 I.E. CONSTRAIN THE SIG/GAM RATIO
      DO 221 LV=1,LVARV
 221  DERIVV(LV)=0.
      IG=IGSLAK(ISK)
      YCALC=AMSLAK(IG,ISK)*F4PAR(IG,ISPSLK(1,ISK))
     & -AMSLAK(2,ISK)*F4PAR(IG,ISPSLK(2,ISK))
      DERIVV(KF4PAR(IG,ISPSLK(1,ISK)))=AMSLAK(1,ISK)
      DERIVV(KF4PAR(IG,ISPSLK(2,ISK)))=-AMSLAK(2,ISK)
C
      CALL RELATE
      OBS=YCALC
      DIFF=0.
C
C WEIGHT
C FOR NOW, EXTRA WEIGHT IS UNITY:
  20  SLAKWT(NSLTYP)=1.
      WT=WTSLAK(ISK)*SLAKWT(NSLTYP)*SLAKWT(NSLTYP)
      SQRTWT=SQRT(WT)
      WDIFF=SQRTWT*DIFF
      IF (PRNCYC(8)) WRITE(LPT,2001) ISK,OBS,YCALC,DIFF,WTSLAK(ISK)
2001  FORMAT (1X,I4,F10.4,F10.4,F10.5,G12.4)
      CALL MATTOT(ALSQ,MATSZ)
C
C ADD IN  SLACK CONSTRAINT STATISTICS:
      ISLKTP=NSLTYP
      CALL RFACS(4)
   1  CONTINUE
C PRINT SLACK CONSTRAINT STATISTICS:
      CALL RFACS(5)
 100  RETURN
      END
C
C
C
C
C LEVEL 7      SUBROUTINE PCXX(N)
      SUBROUTINE PCXX(N)
C
C **** PCXX by JCM 25 Apr 90 ***
C
CH An explicit routine to cater for multisource peak centres
C
/PHASE/
/PRPKCN/
/REFIPR/
/SOURCE/
C
C AT PRESENT, EACH PEAK CENTRE TYPE IS 1:
      IF (TOF) CALL PCTF01(N)
      IF (CN) THEN
         IF(NPCSOU(JPHASE,JSOURC).EQ.1)CALL PCCN01(N)
         IF(NPCSOU(JPHASE,JSOURC).EQ.2)CALL PCCN02(N)
        ENDIF
      IF (LX) CALL PCLX01(N)
      GO TO 100
C
C
      ENTRY PCXX8(NP,NV)
C SET PEAK CENTRE PARAMETER NP IS VARIABLE NV:
      KPCNSP(NP,JPHASE,JSOURC)=NV
      GO TO 100
C
C
      ENTRY PCXX9
C SET ALL PEAK CENTRE PARAMETERS FIXED:
      DO 9 JP=1,NPHASE
      DO 9 JS=1,NSOURC
      DO 9 I=1,NPKCSP(JP,JS)
   9  KPCNSP(I,JP,JS)=0
      GO TO 100
C
 100  RETURN
      END
C
C
C
C
C LEVEL 6      SUBROUTINE PFALL(N)
      SUBROUTINE PFALL(N)
C
C *** PFALL updated by JCM 24 Jan 91 ***
C
C90.68 added entry N=2 JPW/JBF
C
CH Multiple entry routine to deal with aspects of L PKFN cards common
CH to all peak function types
CA On entry N=1,3 or 4 (as a relic from PFXX entries)
CA     N=1 means interpret the L PKFN card in ICARD
CA     N=2 means check we have read all the parameters we think we need
CA     N=3 means apply a shift to a parameter of genus IGEN, species ISPC
CA     N=4 means write out to unit NEWIN a new L PKFN card
CP For N=1 or 4:
CP The card has already been read into /SCRACH/
CP The array PWD holds the allowed vocabulary
CP NPKGEN(JPHASE,JSOURC) holds the total number of words which are names
CP for family 3 genera, and also words to be found after L PKFN.
CD For N=1:
CD Given a card in /SCRACH/ which starts L PKFN, read the remaining  information
CD For N=3:
CD Applies shift (in SHIFT in /NEWOLD/) to peak function parameter in
CD PKFNSP, using genus and species from /NEWOLD/
CD For N=4:
CD Given a card in /SCRACH/ which starts L PKFN, reads the next word to
CD decide the type of card, then writes a new card to unit NEWIN.
CN Used to be entries 1,3,4 of PFXX
C
      CHARACTER *4 WORD
/CARDRC/
/IOUNIT/
/NEWOLD/
/PHASE/
/PRBLEM/
/PRPKFN/
/PWORDS/
/SCRACH/
/SOURCE/
      DIMENSION ATEMP(6)
C
      GO TO (1,2,3,4) , N
C
C 90.01 PFALL - alter to recognise *Sn *Pn and read ksourc and
C  1  CALL RDWORD(WORD,IWDLEN,8,IPT,80,0,IER)
C READ NEXT WORD ON CARD (ASSUMES THAT "L PKFN" HAS NO EXTRA SPACES):
   1  CALL RDWORD(WORD,IWDLEN,8,IPT,80,1,IER)
      JSOURC=KSOURC
      IF (WORD .EQ. 'TYPE') GO TO 100
      IF (WORD .EQ. 'TOLR') THEN
        CALL RDREAL(TOLR(1,JSOURC),IPT,IPT,80,IER)
        CALL RDREAL(TOLR(2,JSOURC),IPT,IPT,80,IER)
        NO=2
        IF (IER .EQ. 100) THEN
          TOLR(2,JSOURC)=TOLR(1,JSOURC)
          NO=1
        ENDIF
        DO 8 I=1,NO
        IF (TOLR(I,JSOURC) .LE. 1.) THEN
          WRITE (LPT,2008) NO,TOLR(I,JSOURC)
2008      FORMAT (/' Tolerance',I2,': to',F6.3,' of peak height')
        ELSE
          WRITE (LPT,2009) NO,TOLR(I,JSOURC)
2009      FORMAT (/' Tolerance',I2,': ',F6.1,
     &    ' full widths at half maximum')
        ENDIF
   8    CONTINUE
        GO TO 100
      ENDIF
C
      IF (WORD .EQ. 'NFFT') THEN
        CALL RDINTG(NFFT,IPT,IPT,80,IER)
        WRITE (LPT,2007) NFFT
2007    FORMAT (/' Number of fast Fourier transforms =',I2)
        GO TO 100
      ENDIF
C
      L=NCFIND(WORD,PWD(1,JPHASE,JSOURC),NPKGEN(JPHASE,JSOURC))
      IF (L .LE. 0) THEN
        CALL ERRCH2(WORD,2,'word','after PKFN not recognised')
        GO TO 100
      ENDIF
C
C READ ALL REMAINING NUMBERS ON CARD - SETS NUM TO BE HOW MANY:
      CALL RDREAL(TOLER(L,JPHASE,JSOURC),IPT,IPT,80,IER)
      CALL RDNUMS(ATEMP,IPT,7,NUM,IER)
      DO 23 I=1,NUM
  23  PKFNSP(L,I,JPHASE,JSOURC)=ATEMP(I)
      NPKFSP(L,JPHASE,JSOURC)=NUM
C
C 90.25 - Print source information too.
C PRINT VALUES:
      WRITE (LPT,2000) JSOURC,WORD,TOLER(L,JPHASE,JSOURC),NUM,
     & (ATEMP(I),I=1,NUM)
2000  FORMAT (/'Src ',I3,' : ',A4,' - toler.',F10.4,I3,
     & ' pars.:',6F10.4)
      GO TO 100
C
C Check we have read all we expected
   2  DO 21 I=1,NSOURC
        DO 22 J=1,NPKGEN(JPHASE,I)
          IF( NPKFSP(J,JPHASE,I) .NE. ABS(LF3SP(J+2,JPHASE,I)) ) THEN
            CALL ERRCH2(PWD(J,JPHASE,I),1,'For PKFN card ',
     &  ' incorrect number of parameters')
          ENDIF
  22    CONTINUE
  21  CONTINUE
      WRITE(LPT,*)'Apparently all PKFN specifiers read in'
      GO TO 100
C
C APPLY SHIFT:
   3  CALL ADJUST(PKFNSP(IGEN-2,ISPC,JPHASE,JSOURC))
      GO TO 100
C
C WRITE NEW L PKFN CARD TO UNIT NEWIN, GIVEN OLD CARD IN /SCRACH:
   4  CALL RDWORD(WORD,IWDLEN,8,IPT,80,1,IER)
C 90.08
      JSOURC=KSOURC
      L=NCFIND(WORD,PWD(1,JPHASE,JSOURC),NPKGEN(JPHASE,JSOURC))
      IF  (L .EQ. 0) THEN
        WRITE (NEWIN,2002) (ICARD(I:I),I=1,LENGT(ICARD))
2002    FORMAT (80A1)
      ELSE
        NUM=NPKFSP(L,JPHASE,JSOURC)
        IF(NDASOU(JSOURC).EQ.1.AND.NPFSOU(JPHASE,JSOURC).EQ.6) THEN
        WRITE (NEWIN,2003) WORD,TOLER(L,JPHASE,JSOURC),
     &  (PKFNSP(L,I,JPHASE,JSOURC),I=1,NUM)
*** NEEDS *S IF MULTISOURCE
2003    FORMAT ('L PKFN ',A4,7(1X,G9.4E1))
        ELSE
        WRITE (NEWIN,2001) WORD,TOLER(L,JPHASE,JSOURC),
     &  (PKFNSP(L,I,JPHASE,JSOURC),I=1,NUM)
*** NEEDS *S IF MULTISOURCE
2001    FORMAT ('L PKFN ',A4,F10.4,6F10.4)
        ENDIF
      ENDIF
      GO TO 100
C
C
      ENTRY PFALL8(NG,NS,NV)
C SET PARAMETER OF PEAK FUNCTION TO BE VARIABLE NV:
      KPFNSP(NG-2,NS,JPHASE,JSOURC)=NV
      GO TO 100
C
C
      ENTRY PFALL9
C SET ALL PARAMETERS OF PEAK FUNCTION TO BE FIXED:
      DO 9 JP=1,NPHASE
      DO 9 JS=1,NSOURC
      DO 9 I=1,NPKGEN(JP,JS)
      DO 9 J=1,NPKFSP(I,JP,JS)
   9  KPFNSP(I,J,JP,JS)=0
      GO TO 100
C
 100  RETURN
      END
C
C
C
C
C LEVEL 8      SUBROUTINE PFXX(N)
      SUBROUTINE PFXX(N)
C
C **** PFXX updated by JCM 23 Feb 93 ***
C
CH An explicit routine to cater for multisource peak functions
C
/PHASE/
/REFIPR/
/SOURCE/
C
   1  IF (TOF) THEN
        IF (NPFSOU(JPHASE,JSOURC) .EQ. 1) CALL PFTF01(N)
        IF (NPFSOU(JPHASE,JSOURC) .EQ. 2) CALL PFTF02(N)
        IF (NPFSOU(JPHASE,JSOURC) .EQ. 3) CALL PFTF03(N)
        IF (NPFSOU(JPHASE,JSOURC) .EQ. 4) CALL PFTF04(N)
        IF (NPFSOU(JPHASE,JSOURC) .EQ. 5) CALL PFTF05(N)
        IF (NPFSOU(JPHASE,JSOURC) .EQ. 6) CALL PFTF06(N)
        IF (NPFSOU(JPHASE,JSOURC) .EQ. 8) CALL PFTF08(N)
        IF (NPFSOU(JPHASE,JSOURC) .EQ. 12) CALL PFTF12(N)
        IF (NPFSOU(JPHASE,JSOURC) .EQ. 92) CALL PFTF92(N)
      ELSE IF (CN) THEN
        IF (NPFSOU(JPHASE,JSOURC) .EQ. 1) CALL PFCN01(N)
        IF (NPFSOU(JPHASE,JSOURC) .EQ. 3) CALL PFCN03(N)
        IF (NPFSOU(JPHASE,JSOURC) .EQ. 4) CALL PFCN04(N)
        IF (NPFSOU(JPHASE,JSOURC) .EQ. 5) CALL PFCN05(N)
      ELSE IF (LX) THEN
        IF (NPFSOU(JPHASE,JSOURC) .EQ. 1) CALL PFLX01(N)
        IF (NPFSOU(JPHASE,JSOURC) .EQ. 2) CALL PFLX02(N)
      ENDIF
      RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE PHCINI(KOMM,N)
      SUBROUTINE PHCINI(KOMM,N)
C
C *** PHCINI BY JCM 6 JUL 87 ***
C
CH Initialises COMMON equivalanced to KOMM by finding its end in N
C
CA On entry KOMM is the array equivalenced to the required COMMON
CA On exit  N is set to point to the last element of KOMM
C
      DIMENSION KOMM(1)
      INTEGER J
C
      I=0
   2  N=-42
   1  I=I+1
C 90.24 Alter PHCINI so it doesn't die on VAX and PC, by
C     copying common block variable into a local before
C     using it.
C For vax compile with /nooptimise (ize?)
C For g77 use J=KOMM(I) and bung J in the tests below
C The following compiles with DVF on a PC with debug on and optimise off
C ...I think. It's illegal code.
      IF (KOMM(I) .NE. -42) GO TO 1
      N=I
      IF (KOMM(I) .NE. I) GO TO 2
C
      RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE PHFIND(KOMM,N,ISCR)
      SUBROUTINE PHFIND(KOMM,N,ISCR)
C
C *** PHFIND BY JCM 6 JUL 87 **
C
CH Read COMMON block whose contents are equivalenced to KOMM from unit ISCR
C
CA KOMM is an array which has been equivalenced to the entire required
CA   COMMON block.
CA N is the actual number of numbers to transfer
CA ISCR is the number of the unit from which to read KOMM
CA      assumed positioned and reading sequentially
CP A call of PHLOSE must have put the COMMON on to unit ISCR first.
C
      DIMENSION KOMM(N)
C
      READ (ISCR) KOMM
      RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE PHLOSE(KOMM,N,ISCR)
      SUBROUTINE PHLOSE(KOMM,N,ISCR)
C
C *** PHLOSE BY JCM 6 JUL 87 **
C
CH Write COMMON block whose contents are equivalenced to KOMM to unit ISCR
C
CA KOMM is an array which has been equivalenced to the entire required
CA   COMMON block.
CA N is the actual number of numbers to transfer
CA ISCR is the number of the unit to which to write KOMM
C
      DIMENSION KOMM(N)
C
      WRITE (ISCR) KOMM
      RETURN
      END
C
C
C
C
C LEVEL 5      SUBROUTINE PHMOVE(IO,N)
      SUBROUTINE PHMOVE(IO,N)
C
C *** PHMOVE BY JCM 7 FEB 88 ***
C
CH Initialise, write out or read back whole/part phase number N
CA On entry IO =0 for initialise phase moving
CA               -2 for write out phase N, just after reading it from
CA                  the crystal data file, and adjust NATOM etc
CA               -1 for write out phase N
CA                1 for read back phase N, readjust NATOM etc, and set IPHASE=N
CA           N is the required phase number.
C
/ATNAM/
/GLOBAL/
/PHASE/
/REFINE/
C
/ANISO/+
/ANSCAT/+
/CELFIX/+
/CELPAR/+
/FORMDA/+
/FORMD2/
/FRIED/+
/FUNIT/+
/F4PARS/+
/GUNIT/+
/HKLGEN/+
/LREAD/+
/MAGDAT/+
/NSYM/+
/NTITL/+
/OMITPR/+
/OVER/+
/PAWLPR/+
/POSNS/+
/POSNS2/
/REFLNS/+
/SATELL/+
/SLAKDA/+
/SLKGEO/+
/SYMDA/+
/SYMMAG/+
/SYMTAB/+
C
/FONAM/
/TITLE/
C
C IF NOT ACTUALLY MULTIPHASE, EXIT:
      IF (.NOT. MULFAS) GO TO 100
C
C BRANCH ON WRITE, INITIALISE OR READ:
      IF (IO .EQ. 0) THEN
C
C INITIALISE:
C ALL NUMBER COMMON:
        CALL PHCINI(KOMM1,KOM1)
        CALL PHCINI(KOMM2,KOM2)
        CALL PHCINI(KOMM3,KOM3)
        CALL PHCINI(KOMM4,KOM4)
        CALL PHCINI(KOMM5,KOM5)
        CALL PHCINI(KOMM6,KOM6)
        CALL PHCINI(KOMM7,KOM7)
        CALL PHCINI(KOMM8,KOM8)
        CALL PHCINI(KOMM10,KOM10)
        CALL PHCINI(KOMM11,KOM11)
        CALL PHCINI(KOMM12,KOM12)
        CALL PHCINI(KOMM13,KOM13)
        CALL PHCINI(KOMM14,KOM14)
        CALL PHCINI(KOMM15,KOM15)
        CALL PHCINI(KOMM16,KOM16)
        CALL PHCINI(KOMM17,KOM17)
        CALL PHCINI(KOMM18,KOM18)
        CALL PHCINI(KOMM19,KOM19)
        CALL PHCINI(KOMM20,KOM20)
        CALL PHCINI(KOMM21,KOM21)
        CALL PHCINI(KOMM22,KOM22)
        CALL PHCINI(KOMM23,KOM23)
        CALL PHCINI(KOMM24,KOM24)
        CALL PHCINI(KOMM25,KOM25)
        CALL PHCINI(KOMM26,KOM26)
C
C   ALL CHARACTER COMMON IS MOVED AROUND BY EXPLICIT NAME.
C
C SET UP THE UNITS ON WHICH TO DUMP EACH PHASE:
        DO 1 I=1,NPHASE
   1    NPHUNI(I)=NOPFIL(1005)
        GO TO 100
      ENDIF
C
C READ PHASE N OR WRITE PHASE N:
C SET ISCR = UNIT NUMBER FOR PHASE - SEQUENTIAL, UNFORMATTED
      ISCR=NPHUNI(N)
C BRANCH ON READ/WRITE:
      IF (IO .LT. 0) GO TO 2
C
C IF ALREADY THERE, EXIT:
      IF (N .EQ. IPHASE) GO TO 100
C
C READ IN ALL COMMONS IN SEQUENCE:
C
C FULL PHASE SWOP:
      READ (ISCR) ITITLE
      CALL PHFIND(KOMM1,KOM1,ISCR)
      CALL PHFIND(KOMM2,KOM2,ISCR)
      CALL PHFIND(KOMM3,KOM3,ISCR)
      CALL PHFIND(KOMM4,KOM4,ISCR)
      CALL PHFIND(KOMM5,KOM5,ISCR)
      CALL PHFIND(KOMM6,KOM6,ISCR)
      CALL PHFIND(KOMM7,KOM7,ISCR)
      CALL PHFIND(KOMM8,KOM8,ISCR)
      CALL PHFIND(KOMM10,KOM10,ISCR)
      CALL PHFIND(KOMM11,KOM11,ISCR)
      CALL PHFIND(KOMM12,KOM12,ISCR)
      CALL PHFIND(KOMM13,KOM13,ISCR)
      CALL PHFIND(KOMM14,KOM14,ISCR)
      CALL PHFIND(KOMM15,KOM15,ISCR)
      CALL PHFIND(KOMM16,KOM16,ISCR)
      CALL PHFIND(KOMM17,KOM17,ISCR)
      CALL PHFIND(KOMM18,KOM18,ISCR)
      CALL PHFIND(KOMM19,KOM19,ISCR)
      CALL PHFIND(KOMM20,KOM20,ISCR)
      CALL PHFIND(KOMM21,KOM21,ISCR)
      CALL PHFIND(KOMM22,KOM22,ISCR)
      CALL PHFIND(KOMM23,KOM23,ISCR)
      CALL PHFIND(KOMM24,KOM24,ISCR)
      CALL PHFIND(KOMM25,KOM25,ISCR)
      CALL PHFIND(KOMM26,KOM26,ISCR)
C
C A NEW BIT WHICH I HOPE IS RIGHT - SET UP SINGLE PHASE ITEMS:
      NATOM=NATO(N)
      DO 19 I=1,NATOM
  19  ATNAME(I)=ATNA(I,N)
      NUMFNM=NMFNM(N)
      DO 20 I=1,NUMFNM
      FONAME(I)=FONA(I,N)
  20  NBAKF(I)=NBKF(I,N)
C AND DO MAGNETIC PHASES (JBF 2-8-94)
      MAG=PHMAG(N)
      FIXED=(.NOT. MAG .OR. IPROP .LE. 0)
C OK FOR THE MOMENT, BUT WE COULD SWAP LESS COMMON IF .NOT. MAG
      CALL LOGPHA(N)
      IPHASE=N
      GO TO 101
C
C WRITE PHASE N:
   2  WRITE (ISCR) ITITLE
      CALL PHLOSE(KOMM1,KOM1,ISCR)
      CALL PHLOSE(KOMM2,KOM2,ISCR)
      CALL PHLOSE(KOMM3,KOM3,ISCR)
      CALL PHLOSE(KOMM4,KOM4,ISCR)
      CALL PHLOSE(KOMM5,KOM5,ISCR)
      CALL PHLOSE(KOMM6,KOM6,ISCR)
      CALL PHLOSE(KOMM7,KOM7,ISCR)
      CALL PHLOSE(KOMM8,KOM8,ISCR)
      CALL PHLOSE(KOMM10,KOM10,ISCR)
      CALL PHLOSE(KOMM11,KOM11,ISCR)
      CALL PHLOSE(KOMM12,KOM12,ISCR)
      CALL PHLOSE(KOMM13,KOM13,ISCR)
      CALL PHLOSE(KOMM14,KOM14,ISCR)
      CALL PHLOSE(KOMM15,KOM15,ISCR)
      CALL PHLOSE(KOMM16,KOM16,ISCR)
      CALL PHLOSE(KOMM17,KOM17,ISCR)
      CALL PHLOSE(KOMM18,KOM18,ISCR)
      CALL PHLOSE(KOMM19,KOM19,ISCR)
      CALL PHLOSE(KOMM20,KOM20,ISCR)
      CALL PHLOSE(KOMM21,KOM21,ISCR)
      CALL PHLOSE(KOMM22,KOM22,ISCR)
      CALL PHLOSE(KOMM23,KOM23,ISCR)
      CALL PHLOSE(KOMM24,KOM24,ISCR)
      CALL PHLOSE(KOMM25,KOM25,ISCR)
      CALL PHLOSE(KOMM26,KOM26,ISCR)
      IF (IO .EQ. -2) THEN
C INITIAL ENTRY - PUT IN PLACE UNCHANGING VECTORS WHICH ARE PHASE DEPENDENT:
        NATO(N)=NATOM
        DO 9 I=1,NATOM
   9    ATNA(I,N)=ATNAME(I)
        NMFNM(N)=NUMFNM
        DO 10 I=1,NUMFNM
        FONA(I,N)=FONAME(I)
  10    NBKF(I,N)=NBAKF(I)
      ENDIF
C
 101  REWIND ISCR
 100  RETURN
      END
C
C
C
C
C
C
C
C
C LEVEL 8      SUBROUTINE PREFAS(PROGRM)
      SUBROUTINE PREFAS(PROGRM)
C
C *** PREFAS updated by JCM 21 Jan 92
C
CH Reads in the crystal data file for multiphase job, making temporary files.
CD Makes all the cdfs readable in random order.
CD For details, see the specification of PREFIN.
CI Reads first cdf in same way as PREFIN.   If there is more material after the
CI terminator, sets "multiphase", notes the pointers to the L cards (which
CI are the only ones expected to be duplicated), then reads N more cdfs from
CI the same input dataset for an N-phase job.  Phase 1 must not first clear out
CI the card pointers, as we wish to make it the union of phases 0 and 1.
CN At one time expected its cdfs on separate files.  Now does not.
C
      CHARACTER *(*) PROGRM
      LOGICAL ENDIP
/CARDRC/
/GLOBAL/
/IOUNIT/
/PHAS0/
/PHASE/
/SCRACH/
C
C INITIALISE WHOLE SYSTEM - DATE, TIME, CONSTANTS, I/O UNIT NUMBERS ETC:
C AND SET ALL OF NPHASE, IPHASE, JPHASE , NSOURC, JSOURC to 1:
      CALL INITIL(PROGRM)
C
C OPEN CRYSTAL DATA:
      MESSAG='Crystal data file'
CS ILL      NAMFIL='.CRY'
CS RAL      NAMFIL='.CCL'
      CALL OPNFIL(ICRYDA,111)
C OPEN SCRATCH FILE TO HOLD COPIES OF ALL CRYSTAL DATA FILES SEQUENTIALLY:
      IO10=NOPFIL(10005)
C SET NO ERRORS DETECTED ON INPUT - SYSTEM PLOUGHS ON AS LONG AS IT CAN:
      IERR=0
C START COUNT OF OUTPUT RECORDS TO UNIT IO10:
      ID=0
C
C READ AS MANY PHASES AS ARE GIVEN:
      NPHASE=0
      MULFAS=.FALSE.
   1  NPHASE=NPHASE+1
      CALL CDFIN(NPHASE,ID,ENDIP)
      IF (ENDIP) GO TO 2
C WE HAVE FOUND MORE THAN ONE SECTION OF CDF, SO WE NOW EXPECT N+1 SECTIONS IN
C TOTAL FOR MULTIPHASE WITH N PHASES.  IF WE HAVE JUST READ PHASE 0, WE MUST
C KEEP ITS 'L' CARD POINTERS:
      IF (.NOT. MULFAS) THEN
        MULFAS=.TRUE.
        NPHASE=0
        INRLP0=INREAD(12)
        ICDLP0=ICDNO(12)
      ENDIF
      GO TO 1
C
C ALL CDFS IN:
   2  IF (MULFAS)  THEN
        CALL WRLINE(2,60,'*',0)
        WRITE (LPT,2005) NPHASE
2005    FORMAT (//15X,' JCM Multiphase refinement on',I3,' phases'//)
        CALL WRLINE(0,60,'*',2)
      ENDIF
C
      NTOTL=NTOTAL(NPHASE)
      RETURN
      END
C
C
C
C
C LEVEL 8      SUBROUTINE PREFOR(N)
      SUBROUTINE PREFOR(N)
C
C *** PREFOR by WIFD 10 Jun 1987 ***
C
C MULTIPLE ENTRY ROUTINE TO DEAL WITH ALL ASPECTS OF THE PREFERRED
C ORIENTATION CORRECTION
C FOR SINGLE FRAME TIME OF FLIGHT LSQ ("TOF").
C
%      DIMENSION REFHT(3,%SY*2%),PHASES(%SY*2%)
/BRAGG/
/IOUNIT/
/NEWOLD/
/PREORI/
/REFLNS/
C
      GO TO (1,2,3,4,5,6) , N
C
C HAVE IN COMM0N /SCRACH/ A CARD STARTING 'L PROR' - READ REST:
   1  CALL RDINTG(NPRTYP,7,IPT,80,IER)
      IF (NPRTYP .EQ. 0) THEN
        CALL MESS(LPT,1,'No preferred orientation')
        GO TO 50
      ENDIF
      CALL RDREAL(PRFPAR,IPT,IPT,80,IER)
      WRITE (LPT,2000) PRFPAR
2000  FORMAT (/' Preferred orientation coefficient=',F12.4)
C READ ALL REMAINING NUMBERS ON CARD - SETS NUM TO BE HOW MANY:
      CALL GMZER(PRFDIR,1,3)
      CALL RDNUMS(PRFDIR,IPT,3,NUM,IER)
      WRITE (LPT,2010) (PRFDIR(I),I=1,3)
2010  FORMAT (' Preferred orientation direction=',3F4.0)
      PRFLEN=VCTMOD(1.,PRFDIR,2)
      GO TO 100
C
C CALCULATE FUNCTION WHICH WILL BE PART OF P1 IN CALPR
C AND ITS DERIVATIVE
   2  IF (NPRTYP .EQ. 0) GO TO 100
      CALL SYMREF(REFH(1,KNOW),REFHT,IREFT,PHASES)
      PRFCOR=0.
      DERPRQ=0.
      REFLEN= VCTMOD(1.,REFH(1,KNOW),2)
      ATEM= 1./(REFLEN*PRFLEN)
      DO 20 IR=1,IREFT
      SPRD=SCLPRD(PRFDIR,REFHT(1,IR),2)
      CSQA= (ATEM*SPRD)**2
      SSQA=1.-CSQA
      BTEM=CSQA*PRFPAR**2+SSQA/PRFPAR
      BTEM=1./SQRT(BTEM)
      PRFCOR=PRFCOR+BTEM**3
      DERPRQ=DERPRQ-1.5*BTEM**5*(2.*PRFPAR*CSQA-SSQA/PRFPAR**2)
   20 CONTINUE
      DERPRQ=DERPRQ/PRFCOR
      PRFCOR=PRFCOR/FLOAT(IREFT)
*** SHOULD DERPRQ BE TIMES THIS ALSO?
      GO TO 100
C
C APPLY SHIFT IN COEFFICIENT:
   3  CALL ADJUST(PRFPAR)
      GO TO 100
C
C WRITE OUT NEW 'L PROR' CARD:
   4  WRITE (NEWIN,2001) NPRTYP,PRFPAR,(PRFDIR(I),I=1,3)
2001  FORMAT ('L PROR',I5,F10.4,3F4.0)
      GO TO 100
C
C DEAL WITH ABSENCE OF 'L PROR' CARD:
   5  CALL MESS(LPT,1,'No L PROR card - assuming no preferred '//
     & 'orientation correction')
      NPRTYP=0
  50  PRFPAR=1.
      PRFCOR=1.
      DERPRQ=0.
      PRFDIR(1)=0.
      PRFDIR(2)=0.
      PRFDIR(3)=1.
      GO TO 100
C
C FIX PROR COR IF NO CARD WAS GIVEN, OR TYPE 0 READ:
   6  IF (NPRTYP .EQ. 0) CALL ADDFX5(1,1,9,1,1,4)
      GO TO 100
C
C
      ENTRY PREFO8(NV)
C RECORD THAT THE PREFERRED ORIENTATION PARAMETER IS VARIABLE NUMBER NV:
      KPRFPR=NV
      GO TO 100
C
C
      ENTRY PREFO9
C RECORD THAT THE PREFERRED ORIENTATION PARAMETER IS FIXED:
      KPRFPR=0
      GO TO 100
C
100   RETURN
      END
C
C
C
C
C LEVEL 13      SUBROUTINE PTIC
      SUBROUTINE PTIC
C
C *** PTIC by JCM 14 Aug 91 ***
C
CH Most of the Main program for either TIC or PICTIC
C
      EXTERNAL PCTF01,PCCN01,PCLX01
/BRAGG/
/CARDRC/
/FCCDAT/
/FOCDAT/
/IOUNIT/
/PHASE/
/PRPKCN/
/REFINE/
/REFIPR/
/REFLNS/
/SOURCE/
C
C READ AND INTERPRET "L REFI" CARD:
      CALL REFSET
C
C ONLY IF A & F CARDS SET UP REST OF STRUCTURE FACTOR CALCULATION:
** SEE WHAT HAPPENS IF WE CALL SETFC ANYWAY
*      SFC= (ICDNO(1).NE.0.AND.ICDNO(6).NE.0)
*      IF (SFC) THEN
        CALL SETFC
*      ELSE
*        CALL RECIP
*        CALL OPSYM(1)
*      ENDIF
C SET UP ASYMMETRIC UNIT:
      CALL SYMUNI
C
      IF (TOF) CALL SETTIC(PCTF01)
      IF (CN) CALL SETTIC(PCCN01)
      IF (LX) CALL SETTIC(PCLX01)
C
      INSTCO=1
      INSTNM='HRPD    '
C
      AL2=1.
      TTHET=RADIAN(TWOTHD(JSOURC))
      PATH=PKCNSP(1,JPHASE,JSOURC)
      AL1=PATH-AL2
      IF (PATH.LT.90.) THEN
        INSTCO=8
        INSTNM='POLARIS '
      ENDIF
C
C
      DELTA=0.0
      LDFIL= 1
      DATFIL(1:14)=' '
      NXCODE=2
      RUNDUR=1.
      NYCODE=-1
      LNPDFN=LDFIL
      NUMRUN=0
      IF (TOF) THEN
        XCAPT= 'TOF (microseconds)'
        YCAPT= 'NEUTRONS/MICROSECOND'
        MCAPT= ' '
      ELSE IF (CN) THEN
        XCAPT= '2 THETA (degrees)'
        YCAPT= 'NEUTRON COUNTS'
        MCAPT= ' '
      ELSE IF (LX) THEN
        XCAPT= '2 THETA (degrees)'
        YCAPT= 'PHOTON COUNTS'
        MCAPT= ' '
      ENDIF
      RETURN
      END
C
C
C
C
C LEVEL 13      SUBROUTINE PTICN
      SUBROUTINE PTICN
C
C *** PTICN by JBF from PTIC for magnetic materials 2-Jun-95 ***
C
CH Most of the Main program for either TIC or PICTIC
C
      EXTERNAL PCTF01,PCCN01,PCLX01,DUMMY,DOMAG
/CARDRC/
/REFIPR/
C
C READ AND INTERPRET "L REFI" CARD:
      CALL REFSET
C
      IF (ICDNO(17).NE.0) THEN
        CALL SETFCM(DOMAG)
        CALL MAGCNC
        CALL DOMAG(2)
      ELSE
        CALL SETFCM(DUMMY)
      ENDIF
C SET UP ASYMMETRIC UNIT:
      CALL SYMUNI
C
      IF (TOF) CALL SETICN(PCTF01)
      IF (CN) CALL SETICN(PCCN01)
      IF (LX) CALL SETICN(PCLX01)
      RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE QPRIN(ARGI,OBS,DOBS,ICODE,ENDIP)
      SUBROUTINE QPRIN(ARGI,OBS,DOBS,ICODE,ENDIP)
C
C *** QPRIN DUMMY by JCM 10 May 88 ***
C
CH User to replace this by his own routine to read observation, if needed
C
      LOGICAL ENDIP
      RETURN
      END
C
C
C
C
C LEVEL 11      SUBROUTINE RDPHA0(PCXX,PFXX)
      SUBROUTINE RDPHA0(PCXX,PFXX)
C
C *** RDPHA0 by JCM 4 Dec 91 ***
C
CH Starts a multiphase job and reads in phase 0
C
CP Expects that phases 0 and 1 are pointed to together in INREA(,1) and
CP ICDN(,1), and that the separate phase 0 'L' cards are pointed to by
CP INRLP0 and ICDLP0  in /PHAS0/.
CD
CD At present expects multiphase data.  Will sort it out eventually for
CD single phase also.
CD
CD Initialises for multiphase, and calls REFSET to sort out what we expect.
CD Calls INPLP0 to read and interpret the phase 0 'L' cards.
C
      EXTERNAL PCXX,PFXX
/CARDRC/
/GLOBAL/
/PHAS0/
C
      IF (MULFAS) THEN
C SET UP PHASE DUMPING AND RETRIEVAL:
        CALL PHMOVE(0,0)
C
C SET UP TYPE OF REFINEMENT FOR EVERY PHASE, EVERY SOURCE:
        CALL REFSET
C
C READ PHASE 0 L CARDS IF PRESENT:
        CALL STLSP0(PCXX,PFXX)
      ENDIF
      RETURN
      END
C
C
C
C
C LEVEL 5      SUBROUTINE REFSET
      SUBROUTINE REFSET
C
C *** REFSET updated by JBF July 95 ***
C
CX
CC 19A
CH Finds L REFI and L SORC cards and deduces which refinement required
CH Also L *Sn PKCN and L *Sn PKFN cards.
CD Entered once at the start of a multi-job.  Constructs what were for
CD non-multi-jobs the program name, the peak centre subroutine name, and
CD the peak function name.
CD
CD Reads the first cdf and finds L SORC which should be followed by a
CD string of data sources like TF, CN, LX, ED - one per source;  keeps these
CD in NDASOU.
CD Read every cdf - one per phase - and picks up information:
CD       from L REFI which type of refinement (RIET, CAIL, . .) for this phase
CD       from L *Sn PKCN TYPE <number> which peak centre approximation number
CD                  for this phase and source n,
**CD Altered to expect only one set of L *Sn PKCN cards, therefore on phase 0
CD       from L *Sn PKFN TYPE <number> which peak function approximation number
CD                  for this phase and source n.
CD
CD If used with an old-style L REFI card, expects a signed packed integer.
CO Prints out what it has read. NB No longer sets LOGICAL TIC.
C
      LOGICAL ONCARD,OLD
      CHARACTER *4 SWORDS(5),TYPWDS(6),WORD
      CHARACTER *27 SORCWD(5),TYPEWD(6)
/CARDRC/
/GLOBAL/
/GRDBCK/
/IOUNIT/
/PHASE/
/REFINE/
/REFIPR/
/SOURCE/
/WHEN/
      DATA SWORDS/'TF','CN','LX','SR','ED'/
      DATA SORCWD/'Time of flight','Constant wavelength neutron',
     & 'Constant Wavelength X-ray','Synchrotron X-Ray',
     & 'Energy Dispersive'/
      DATA TYPEWD/'RIET','CAIL','SAPS','APES','RAPS','PEWS'/
C
      CALL WRLINE(1,60,'-',1)
      DO 2 JPHASE=1,NPHASE
C ARRANGE TO ADDRESS THE CORRECT CRYSTAL DATA FILE:
      IF (JPHASE .NE. 1) THEN
        CALL VCSWOP(INREA(1,JPHASE),INREA(1,1),26)
        CALL VCSWOP(ICDN(1,JPHASE),ICDN(1,1),26)
      ELSE
        IF (MULFAS) CALL P0TEMP(.TRUE.)
        CALL FINDCD('L','SORC',4,0,L)
C DETECT OLDER USE BY SPECIFIC PROGRAM:
        IF (L .EQ. 0) THEN
          IF (MAIN .EQ. 'FORTY1') CALL ERRMES(1,0,'Need L SORC card')
          OLD=.TRUE.
          NSOURC=1
C ARE TICs REQUIRED? IF SO, LOGICAL TIC MUST BE SET IN MAIN PROGRAM
          IF (TIC) GO TO 4
          WORD=MAIN(1:2)
          NDASOU(1)=NCFIND(WORD,SWORDS,5)
          NPCSOU(1,1)=NCHINT(MAIN(3:3))
          NPFSOU(1,1)=NCHINT(MAIN(4:4))
          IF (NPCSOU(1,1) .EQ. 9) THEN
            NPCSOU(1,1)=90+NCHINT(MAIN(4:4))
            NPFSOU(1,1)=90+NCHINT(MAIN(6:6))
          ENDIF
          GO TO 22
        ENDIF
C
C READ ALL SOURCES FROM THE ONE CARD ON CDF FOR FIRST PHASE:
        OLD=.FALSE.
        NSOURC=0
        IPT=7
   3    CALL RDWORD(WORD,LEN,IPT,IPT,80,0,IER)
        IF (IER .EQ. 100) GO TO 4
%        CALL ERRCHK(2,NSOURC,%SORC%,0,'PR data sources')
        NDASOU(NSOURC)=NCFIND(WORD,SWORDS,5)
  22    IF (NDASOU(NSOURC) .EQ. 0) THEN
          I=2
          IF (OLD) I=1
          CALL ERRCH2(WORD,I,'data source word <','> not recognised')
        ELSE
          IF (NSOURC .EQ. 1) CALL MESS(LPT,1,
     &    'Source of data       : '//SORCWD(NDASOU(1)))
          IF (NSOURC .GT. 1)
     &    WRITE (LPT,2005) NSOURC,SORCWD(NDASOU(NSOURC))
2005      FORMAT (' Source of data no.',I3,' : ',A27)
        ENDIF
        IF (.NOT. OLD) GO TO 3
   4    MULSOU=NSOURC .GT. 1
        MULONE=MULFAS .OR. MULSOU
        IF (TIC) GO TO 88
C
C READ "L PKCN" *Sn "TYPE" CARDS - THESE ARE IN PHASE 0 IF MULTI :
        K=0
   6    CALL FINDCD('L','PKCN',4,K,L)
        IF (L .LE. 0) GO TO 7
        K=L
        IPT=7
        CALL RDWORD(WORD,LEN,IPT,IPT,80,1,IER)
        IF (WORD .EQ. 'TYPE') THEN
        CALL RDINTG(NPCSOU(JPHASE,KSOURC),IPT,IPT,80,IER)
        DO 42 IJ=2,NPHASE
  42    NPCSOU(IJ,KSOURC)=NPCSOU(1,KSOURC)
* ONE DAY CHECK COMPATIBILITY
      ENDIF
      GO TO 6
C
C CHECK ALL PEAK CENTRE TYPES SET:
   7  DO 11 I=1,NSOURC
      IF (NPCSOU(JPHASE,I) .EQ. 0) THEN
        WRITE (LPT,3002) JPHASE,I
        WRITE (ITO,3002) JPHASE,I
3002    FORMAT(' ERROR ** need L PKCN TYPE card for phase',I3,
     &  ' source',I3)
        IERR=IERR+1
      ELSE
        IF (.NOT. MULONE) THEN
          WRITE (LPT,2011) NPCSOU(1,1)
2011      FORMAT(' Peak centre type =',I3)
        ELSE
          IF (.NOT. MULSOU) THEN
            WRITE (LPT,2011) NPCSOU(JPHASE,1)
          ELSE
            WRITE (LPT,2013) I,NPCSOU(JPHASE,I)
2013        FORMAT(' For source',I3,' Peak centre type =',I3)
          ENDIF
        ENDIF
      ENDIF
  11  CONTINUE
C
      IF (MULFAS .AND. JPHASE .EQ. 1) CALL P0TEMP(.FALSE.)
      ENDIF
C
C FOR EACH PHASE, SHOULD BE AN L REFI CARD:
  88  CALL FINDCD('L','REFI',4,0,L)
      IF (L .EQ. 0) CALL ERRMES(3,0,'L REFI')
C IN CASE OLD-STYLE, TRY TO READ INTEGER:
      CALL RDINTG(IREF,7,IPT,80,IER)
C
C IF A WORD WAS READ INSTEAD OF A NUMBER:
      IF (IER .NE. 0) GO TO 1
C
C CHECK IREF;  SET various LOGICALS RIET, CAIL, SAPS, APES
C AND TOF, CN, CX, ED . .
      IREF1=IABS(IREF)/100
      IREF2=(IABS(IREF)-100*(IREF1))/10
      METHOD(1)=IREF1+1
      IF (TIC) THEN
        NDASOU(1)=IREF2
        NPCSOU(1,1)=1
C I WONDER WHY?
        NPFSOU(1,1)=0
      ENDIF
      IF (NDASOU(1) .NE. IREF2) THEN
        CALL MESS(LPT,1,'Program is written for '//SORCWD(NDASOU(1)))
        CALL MESS(LPT,0,'Data given for '//SORCWD(IREF2))
        CALL ERRMES(1,0,'wrong MAIN program')
      ENDIF
      IF (IABS(IREF) .GT. 349) CALL ERRIN2(IREF,0,
     & 'refining mode','not allowed')
C SET WHETHER ZERO YCALCS OCCUR IN STATISTICS:
      ZBAKIN=IREF .GT. 0
C L REFI <INTEGER> CAN STILL OCCUR USING FORTY1:
      IF (MAIN .EQ. 'FORTY1') GO TO 5
      GO TO 101
C
   1  CALL RDWORD(WORD,LEN,7,IPT,80,0,IER)
      METHOD(JPHASE)=NCFIND(WORD,TYPEWD,6)
      IF (METHOD(JPHASE) .EQ. 0) THEN
        CALL ERRCH2(WORD,0,'refinement type word','not recognised')
      ELSE
        IF (MULFAS) THEN
          WRITE (LPT,2001) JPHASE,TYPEWD(METHOD(JPHASE))
2001      FORMAT (/' Phase',I3,' : Refinement type ',A27)
        ELSE
          CALL MESS(LPT,1,
     &    '           Refinement type '//TYPEWD(METHOD(JPHASE)))
        ENDIF
      ENDIF
C
C READ "L PKFN" *Sn "TYPE" CARDS:
   5  K=0
   8  CALL FINDCD('L','PKFN',4,K,L)
      IF (L .LE. 0) GO TO 12
      K=L
      IPT=7
      CALL RDWORD(WORD,LEN,IPT,IPT,80,1,IER)
      IF (WORD .NE. 'TYPE') GO TO 8
      CALL RDINTG(NPFSOU(JPHASE,KSOURC),IPT,IPT,80,IER)
* CHECK COMPATIBILITY
      GO TO 8
C
C CHECK ALL PEAK FUNCTION TYPES SET:
  12  DO 13 I=1,NSOURC
      IF (NPFSOU(JPHASE,I) .EQ. 0) THEN
        WRITE (LPT,3003) JPHASE,I
        WRITE (ITO,3003) JPHASE,I
3003    FORMAT(' ERROR ** need L PKFN TYPE card for phase',I3,
     &  ' source',I3)
        IERR=IERR+1
      ELSE
        IF (.NOT. MULONE) THEN
          WRITE (LPT,2021) NPFSOU(1,1)
2021      FORMAT(' Peak function type =',I3)
        ELSE
           IF (.NOT. MULSOU) THEN
            WRITE (LPT,2021) NPFSOU(JPHASE,1)
          ELSE
            WRITE (LPT,2023) I,NPFSOU(JPHASE,I)
2023        FORMAT(' For source',I3,' Peak function type =',I3)
          ENDIF
        ENDIF
      ENDIF
  13  CONTINUE
C
   2  CONTINUE
        CALL WRLINE(1,60,'-',1)
C
C PUT VECTORS BACK:
      DO 14 JPHASE=NPHASE,2,-1
      CALL VCSWOP(INREA(1,JPHASE),INREA(1,1),26)
      CALL VCSWOP(ICDN(1,JPHASE),ICDN(1,1),26)
  14  CONTINUE
C FOR USES OTHER THAN MULTIPHASE LSQ (EG TIC) - HOPE THIS DOES NOT MESS UP THE
C REST:
 101  CALL LOGSOU(1)
      CALL LOGPHA(1)
 100  RETURN
      END
C
C
C
C
C LEVEL 8       SUBROUTINE RFACPR(IRFAC,PCXX)
      SUBROUTINE RFACPR(IRFAC,PCXX)
C
C *** RFACPR updated by JBF 13-Jan-95 ***
C
CH Multiple entry routine to deal with Profile refinement R Factors
CA On entry IRAFC indicates the actions required:
CA   IRFAC=1  set up - clear totals
CA   IRFAC=2  add in contributions, given values, differences and weights
CA   IRFAC=3  just precedes entry 4
CA   IRFAC=4 if required, send to file H,K,L, F CALC, F OBS, DIFF
CA   IRFAC=5 as entry 2, but dealing with a zero Ycalc
CA   IRFAC=6 used for every K out of CALXX - save GCALC and add in to SOMEGA
CA   IRFAC= 11,12,13 as for 1,2,3 but for multiphase applications
C
      EXTERNAL PCXX
      COMPLEX FCALC
      LOGICAL PRNCYC,TESTOV,LATABS
      DIMENSION IH(3)
/BRAGG/
/DERBAS/
/F4PARS/
/FCAL/
/GLOBAL/
/GRDBCK/
/IOUNIT/
/NSYM/
/OBSCAL/
/OVER/
/PHASE/
/PRBLEM/
/PRPKCN/
/PRPKFN/
/PRSTAT/
/REFINE/
/REFIPR/
/REFLNS/
/SCRACH/
/WHEN/
C 88.06      SAVE SMYOB,SWYOBS added in RFACPR
      SAVE SMYOB,SWYOBS
C
      GO TO (1,2,3,4,5,6,100,100,100,100,11,12,13) ,IRFAC
C
C INITIAL ENTRY : CLEARS ALL IF SINGLE PHASE
   1  SUMWD=0.0
      SMYC=0.0
      SMYD=0.0
      SMYO=0.0
      SMYOB=0.0
      SWYOBS=0.0
      SMWYOS=0.0
C
C COUNT ZERO Y CALCS
      IZCT=0
C
C OPEN FILE TO RECEIVE PROFILE IF NEEDED:
      MESSAG='File to output Profiles'
      NAMFIL='.PRO'
      IF (PRNCYC(4)) CALL OPNFIL(IOP2,112)
      IF (MULFAS) GO TO 100
C
  11  SMIO=0.0
      SMID=0.0
      RINUM=0.
      RIDEN=0.
%      DO 21 I=1,%REFS%
      AIOBS(I)=0.0
      ESDOBS(I)=0.0
      SOMEGA(I)=0.0
C TO INDICATE WHETHER OR NOT USED
      AICALC(I)=-9999.
  21  CONTINUE
C
      IF (PRNCYC(1)) CALL MESS(LPT,1,'Argument    Yobs     Ycalc'//
     & '     Diff First and last reflns')
C OPEN FILE FOR FOURIER INPUT IF REQUIRED:
      MESSAG='File for h k l Fc Fo'
      NAMFIL='.FOU'
      IF (PRNCYC(3)) CALL OPNFIL(IOP1,112)
      GO TO 100
C
C DEAL WITH ZERO YCALC:
   5  IZCT=IZCT+1
C IF REQUESTED ON "L REFI" CARD, OMIT ZEROS FROM STATISTICS:
      IF (.NOT. ZBAKIN) GO TO 29
C
C ADDING IN ENTRY: THIS IS THE ENTIRE ENTRY IF SINGLE PHASE
   2  SUMWD=SUMWD+WDIFF*WDIFF
      SMYC=SMYC+ABS(YPEAK)
      SMYD=SMYD+ABS(DIFF)
      SMYO=SMYO+ABS(OBS)
      OB=OBS-YBACK
      SMYOB=SMYOB+ABS(OB)
      SWYOBS=SWYOBS+WT*OB*OB
      SMWYOS=SMWYOS+WT*OBS*OBS
C
      IF (.NOT. PRNCYC(1)) GO TO 29
      IF (IZCT .NE. 0) WRITE (LPT,2001) IZCT
2001  FORMAT (' (',I5,' zeros )')
      IZCT=0
      WRITE (LPT,2002) ARGI,OBS,YCALC,DIFF,KMIN,KMAX
2002  FORMAT (' ',F12.2,2F12.4,F14.4,(2X,I5,2X,I5,2X))
C
C IF REQUESTED, WRITE OUT PROFILE FOR FUTURE REINPUT (INCLUDING ZERO
C YCALCS:
  29  IF (PRNCYC(4)) WRITE (IOP2,2003) ARGI,YBACK,OBS,YCALC,DOBS
2003  FORMAT (F12.4,4G12.4)
      IF (MAIN .EQ. 'FORTY1' .OR. MULFAS) GO TO 100
C
C REMAINING COUNTS - OR SEPARATE ENTRY PER PHASE, IF MULTIPHASE:
  12  KK=KMIN
      OB=OBS-YBACK
      DO 33 J=KMIN,KMAX
      IF (TESTOV(GGCALC(J-KMIN+1),YPEAK)) GO TO 33
      TEMP=GGCALC(J-KMIN+1)/YPEAK
      IF (TESTOV(TEMP,WT)) GO TO 33
C COLLECT INTEGRATED INTENSITIES:
      AIOBS(J)=AIOBS(J)+TEMP*OB
C63: ONE TEMP REMOVED:
      ESDOBS(J)=ESDOBS(J)+TEMP/WT
  33  CONTINUE
      GO TO 100
C
C AT CYCLE END, MAKE I OBS AND SUM THEM, AND DIFFS, THEN PRINT R FACTORS ETC:
C ALL OBEYED FOR SINGLE PHASE:
   3  IF ((IZCT .NE. 0) .AND. PRNCYC(1)) WRITE (LPT,2001) IZCT
C
C NOT IF SIMULATION:
      IF (SIMUL) GO TO 13
C
C PRINT R FACTORS FOR END OF CYCLE:
      CALL MESS(LPT,1,'R Factors:')
C
      IF (TESTOV(SMYD,SMYO)) THEN
        CALL MESS(LPT,0,'- not available because denominators zero')
        GO TO 13
      ENDIF
C
      WRITE (LPT,2016) 100.*SMYD/SMYO
2016  FORMAT (/' Profile R factors'
     & /' 100 (Sum Y Diffs/Y Obs) =                  ',F8.2)
      WRITE (LPT,2021) 100.*SMYD/SMYOB
2021  FORMAT (' 100 (Sum Y Diffs/(Sum Y Obs - Y Back)) =   ',F8.2)
      WRITE (LPT,2012) 100.*SQRT(SUMWD/SMWYOS)
2012  FORMAT (/' Weighted Profile R factors'
     & /' 100 Sqrt(Sum wt diffs sqrd/Sum wt obs sqrd)  ',
     & '=        ',F8.2)
      WRITE (LPT,2022) 100.*SQRT(SUMWD/SWYOBS)
2022  FORMAT (' 100 Sqrt(Sum wt diffs sqrd/Sum wt (obs-back) ',
     & 'sqrd)  = ',F8.2)
      FREE=FLOAT(NOBS-LVARB)
      WRITE (LPT,2013) 100.*SQRT(FREE/SMWYOS)
2013  FORMAT (/' Expected R factor =                  ',F8.2)
      WRITE (LPT,2023) 100.*SQRT(FREE/SWYOBS)
2023  FORMAT (' Expected R factor (using obs-back) = ',F8.2)
      WRITE (LPT,2014) FREE
2014  FORMAT (/' N-P+C =',F8.0)
      CHISQ=SUMWD/FREE
      WRITE (ITO,2004) CHISQ,NOBS,LVARB
      WRITE (LPT,2004) CHISQ,NOBS,LVARB
2004  FORMAT (' Chi squared =',F10.4,' for',I6,' observations',
     & ' and',I4,' basic variables')
      WRITE (LPT,2019) SMYD,SMYO,SMYOB,SMYC,SMWYOS,SWYOBS,SUMWD
2019  FORMAT (//6X,'SumYdif    SumYobs     SumYobs     SumYcalc    ',
     & 'Sum w obs sqrd '/18X,'as read     -Yback',20X,'as read'/
     & 1X,3F12.2,1X,F12.2,1X,F12.2//2X,'Sum w obs sqrd    ',
     & 'SumWdiff sq'/6X,'- Yback'/1X,2F13.2)
      IF (MAIN .EQ. 'FORTY1' .OR. MULFAS) GO TO 100
C
C PRINTING ENTRY PER PHASE IF MULTIPHASE, OR EVERY TIME IF SINGLE:
  13  DO 24 K=1,MAXKK(JPHASE)
C IGNORE IF NOT USED:
      IF (AICALC(K) .EQ. -9999.) GO TO 24
C IGNORE IF DIVIDING SUM HAS STAYED ZERO:
      IF (SOMEGA(K) .EQ. 0.) GO TO 24
      AIOBS(K)=AIOBS(K)/SOMEGA(K)
      SMIO=SMIO+AIOBS(K)
      D=ABS(AIOBS(K)-ABS(AICALC(K)))
      SMID=SMID+D
      IF (.NOT. TESTOV(SOMEGA(K),ESDOBS(K))) THEN
        TEMP=SOMEGA(K)*SOMEGA(K)/ESDOBS(K)
        RINUM=RINUM+D*D*TEMP
        RIDEN=RIDEN+AIOBS(K)*AIOBS(K)*TEMP
      ENDIF
  24  CONTINUE
C
      IF (TESTOV(SMID,SMIO)) GO TO 14
      IF (NVARF(2,JPHASE,1) .EQ. 0) GO TO 14
      IF (MULFAS) WRITE(LPT,2080) JPHASE
2080  FORMAT (/' Phase',I3,' :')
C
      WRITE (LPT,2011) 100.*SMID/SMIO
2011  FORMAT (/' Integrated Intensity R factor'
     & /' 100 (Sum I Diffs/Sum I Obs) = ',F8.2)
C
C WEIGHTED, SQUARED INTENSITY R FACTOR:
      WRITE (LPT,2029) 100.*RINUM/RIDEN
2029  FORMAT (/' Weighted, squared Integrated Intensity R factor'/
     & ' 100 (Sqrd sum I Diffs/Sqrd sum I Obs)'/
     & ' weighted by 1/sigma sqrd     = ',F8.2)
C
C CHI SQUARED FOR INTENSITIES:
      WRITE (LPT,2028) RINUM/(FLOAT(MAXKK(JPHASE)-NVARF(2,JPHASE,1))),
     & MAXKK(JPHASE),NVARF(2,JPHASE,1)
2028  FORMAT (/' Chi squared for Intensities =',F10.4,' for',I5,
     & ' reflections and',I4,' structure variables')
C
C AND SUMS OF IDIFFS, IOBS:
      WRITE (LPT,2024) SMID,SMIO
2024  FORMAT (' Sum I diffs =',G12.2,6X,'Sum I obs =',G12.2)
C
C AND OTHER CONSTITUENT PARTS:
      WRITE (LPT,2027) RINUM,RIDEN
2027  FORMAT (/' Sum weighted I diffs sqrd =',F12.2,' Sum weighted',
     & ' I obs sqrd =',F12.2)
C
C  PRINT IOBS, ICALC ETC.
  14  IF (.NOT. PRNCYC(2) .AND. .NOT. PRECYC) GO TO 4
      IF (PRECYC) THEN
        DO 87 I=1,MAXKK(JPHASE)
        F4PAR(1,I)=0.
  87    F4PESD(1,I)=0.
      ENDIF
      IF (MAG .AND. .NOT. FIXED) CALL MESS(LPT,1,'      h       k'//
     & '       l      Argument      I(obs)       I(calc)'//
     & '         Diff        Esd(obs)     F*F       Q*Q')
      IF (MAG .AND. FIXED) CALL MESS(LPT,1,'    h    k'//
     & '    l      Argument      I(obs)       I(calc)'//
     & '         Diff        Esd(obs)     F*F       Q*Q')
      IF (.NOT. MAG) CALL MESS(LPT,1,'    h    k    l    Argument'//
     & '      I(obs)       I(calc)         Diff'//
     & '        Esd(obs)     F*F')
      DO 25 K=1,MAXKK(JPHASE)
      CALL INDFIX(REFH(1,K),IH)
      IF (AICALC(K) .NE. -9999.) GO TO 26
      IF (FIXED) THEN
        WRITE (LPT,2008) IH
      ELSE
        WRITE (LPT,2009) (REFH(I,K),I=1,3)
      ENDIF
2008  FORMAT (1X,3I5,' not used')
2009  FORMAT (1X,3F8.3,' not used')
      GO TO 25
  26  IF (SOMEGA(K) .NE. 0.) GO TO 27
      WRITE (LPT,2007) IH
2007  FORMAT (1X,3I5,' gave zero denominator')
      GO TO 25
C
  27  AIDIFF=AIOBS(K)-AICALC(K)
C63: TEMPORARY AS ESDOBS COMING -VE:
      ESDOB=0.
      IF (ESDOBS(K) .GE. 0.)  ESDOB=SQRT(ESDOBS(K))/SOMEGA(K)
C FOR PCTF1 WHICH REFERS TO DSTAR2(KNOW) TO GET WAVELENGTH:
      KNOW=K
      CALL PCXX(2)
C   BY JBF 5/1/95 TO REMOVE A NUCLEAR CALCULATION IF SHOULD BE ABSENT
      FNSQ = 0.0
      IF (.NOT. LATABS(REFH(1,K))) THEN
        FC=FCALC(REFH(1,K))
        FNSQ=FC*CONJG(FC)
      ENDIF
      IF (MAG) THEN
        CALL FMCALC(REFH(1,K),FMCMOD,FMCSQR)
        IF (.NOT. FIXED) THEN
          WRITE (LPT,2042) (REFH(I,K),I=1,3),ARGK,AIOBS(K),
     &    AICALC(K),AIDIFF,ESDOB,FNSQ,FMCSQR
        ELSE
          WRITE (LPT,2043) IH,ARGK,AIOBS(K),
     &    AICALC(K),AIDIFF,ESDOB,FNSQ,FMCSQR
        ENDIF
2042    FORMAT(1X,3F8.3,F12.2,4F14.4,2F10.3)
2043    FORMAT(1X,3I5,F12.2,4F14.4,2F10.3)
      ELSE
        WRITE (LPT,2006) IH,ARGK,AIOBS(K),AICALC(K),AIDIFF,
     &  ESDOB,FNSQ
2006    FORMAT (1X,3I5,F12.2,4F14.4,F10.3)
      ENDIF
      IF (PRECYC) THEN
        F4PAR(1,K)=AIOBS(K)
        F4PESD(1,K)=ESDOB
      ENDIF
  25  CONTINUE
C
C SEND H,K,L, F CALC, F OBS AND DIFF TO FILE FOR FOURIER
   4  IF (.NOT. PRNCYC(3)) GO TO 100
      DO 22 K=1,MAXKK(JPHASE)
      IF (AICALC(K) .EQ. -9999.) GO TO 22
      IF (SOMEGA(K) .EQ. 0.) GO TO 22
      FCA=0.
      IF (AICALC(K) .GT. 0.) FCA=SQRT(AICALC(K))
      FOB=0.
      IF (AIOBS(K) .GT. 0.) FOB=SQRT(AIOBS(K))
C  IS THIS A PROBLEM JBF 5-1-95
      FC=(0.0,0.0)
      IF (.NOT. LATABS(REFH(1,K))) THEN
        FC=FCALC(REFH(1,K))
      ENDIF
      STHL=VCTMOD(0.5,REFH(1,K),2)
      E=EXP((-TFAC)*STHL*STHL)
      CALL INDFIX(REFH(1,K),IH)
      A=REAL(FC)
      B=AIMAG(FC)
      FCMOD=SQRT(A*A+B*B)
      IF (.NOT. TESTOV(FOB,FCA)) FOB=FCMOD*E*FOB/FCA
      IF (CENTRC) THEN
        WRITE (IOP1,2030) IH,A,FOB
2030    FORMAT (3I5,3F10.3)
      ELSE
        WRITE (IOP1,2030) IH,FC,FOB
      ENDIF
  22  CONTINUE
C READY FOR REINPUT BY FOURIER:
      REWIND IOP1
      GO TO 100
C
C ENTRY FROM CALXX TO KEEP GCALC OF ALL K FOR THIS ONE I, AND ADD IN
C CONTRIBUTIONS TO SOMEGA - KNOW HOLDS CURRENT K:
   6  GGCALC(KNOW-KMIN+1)=GCALC
      SOMEGA(KNOW)=SOMEGA(KNOW)+P5
      GO TO 100
C
 100  RETURN
      END
C
C
C
C
C LEVEL 5      SUBROUTINE RUNPAR(IFAM,IGEN,ISPC)
      SUBROUTINE RUNPAR(IFAM,IGEN,ISPC)
C
C *** RUNPAR corrected by PJB and JBF Jun 93 ***
C
CH Control cycling over all parameters in LSQ
C
CA IFAM on exit contains family of "next" parameter, or -1 if end
CA IGEN on exit contains genus of "next" parameter
CA ISPC on exit contains species of "next" parameter
CA JPHASE on exit contains the phase of the "next" parameter.
CA JSOURC on exit contains the source of the "next" parameter.
CA On entry, if IFAM=0 the cycle is to be initialised
CA       and otherwise IFAM,IGEN,ISPC,JPHASE,JSOURC contain the "previous"
CA       values.
C
CD If JPHASE is changed, the new phase is read into store.
CD If SAPS, expects family 4 geners to start at 2, not 1
CD For family 4, cycles genus before species to keep together variables suitable
CD to make a banded matrix.
C
/GLOBAL/
/PHASE/
/PRBLEM/
/REFINE/
/REFIPR/
/SOURCE/
C
C INITIALISE ENTRY:
      IF (IFAM .EQ. 0) THEN
        JPHASE=1
        GO TO 5
      ENDIF
C
C ENTRY TO ADVANCE - IF FAMILY 4, WANT TO ADVANCE IGEN NOT ISPC FIRST:
      IF (IFAM .NE. 4) GO TO 6
C
C THIS LETS OUT THE FIRST FAMILY 4 MEMBER AS USUAL
      IGEN=IGEN+1
   8  IF (IGEN .LE. NGENPS(IFAM,JPHASE)) GO TO 100
C FOR FAMILY 4, NEXT SPECIES:
*** I THINK SPECIES 1 OF GAMS DISAPPEARS - INVESTIGATE
      ISPC=ISPC+1
      IGEN=1
      IF (SAPS) IGEN=2
      IF (ISPC .LE. NSPCPS(4,JPHASE)) GO TO 8
C FAMILY 4 END:
      ISPC=1
      GO TO 4
C
C FAMILIES OTHER THAN 4 JUST AS IN PARRUN:
   6  ISPC=ISPC+1
C CHECK NOT TOO MANY SPECIES FOR THIS FAMILY+GENUS:
   3  IF (ISPC .GT. NSPCPS(IFAM,JPHASE)) GO TO 2
C ALSO, FAMILIES 1, 3 AND 6 HAVE INDIVIDUAL GENERA OF DIFFERING LENGTHS:
      IF (IFAM.EQ.1 .AND. ISPC.GT.IABS(LF1SP(IGEN))) GO TO 2
      IF (IFAM.EQ.3 .AND. ISPC.GT.IABS(LF3SP(IGEN,JPHASE,JSOURC)))
     & GO TO 2
      IF (IFAM.EQ.6 .AND. ISPC.GT.IABS(LF6SP(IGEN,JSOURC))) GO TO 2
C
      GO TO 100
C
C NEXT GENUS:
   2  IGEN=IGEN+1
   1  ISPC=1
      IF (IGEN .LE. NGENPS(IFAM,JPHASE)) GO TO 3
C ARE THERE OTHER SOURCES?
      IF (IFAM .NE. 3 .AND. IFAM .NE. 6) GO TO 4
C NEXT SOURCE:
      JSOURC=JSOURC+1
      IF (JSOURC .LE. NSOURC) GO TO 7
   4  IFAM=IFAM+1
      JSOURC=1
   7  IGEN=1
      IF (SAPS .AND. IFAM .EQ. 4) IGEN=2
C
C IF LAST PHASE AND FAMILY 6, TO END:
      IF (JPHASE .GT. 1.AND. IFAM .EQ. 6) GO TO 42
C
C IN CASE NGENPS(IFAM,JPHASE) = 0
      IF (IFAM .LE. NFAM) GO TO 1
C NEXT PHASE:
   42 IF (JPHASE .GE. NPHASE) GO TO 101
      JPHASE = JPHASE + 1
   5  IFAM=0
      IF (MULFAS) CALL PHMOVE(1,JPHASE)
      GO TO 4
C
 101  IFAM=-1
 100  RETURN
      END
C
C
C
C
C LEVEL 11       SUBROUTINE SETICN(PCXX)
       SUBROUTINE SETICN(PCXX)
C
C *** SETICN from SETTIC by JBF to deal with magnetism 2-Jun-95 ***
C
CH Prepare to write ASCII files by reading L cards and generating reflection
      EXTERNAL PCXX,DUMMY
/BRAGG/
/DGEOM/
/IOUNIT/
/LREAD/
/PHASE/
/PRPKCN/
/PRZERO/
/REFIPR/
/SOURCE/
C
C READ RELEVANT L CARDS:
      CALL INPLPR(PCXX,DUMMY)
C
C DEAL WITH THE CARDS WHICH ARE DIFFERENT ACCORDING TO TYPE OF DIFFRACTION:
C
C TF:
C NEED L THE2 CARD GIVING 2 THETA DEGREES:
      IF (TOF) THEN
        IF (ILREAD(18) .EQ. 0)
     &  CALL ERRMES(2,1,'L THE2 card giving counter angle')
C FOR TF MUST HAVE L PKCN CARD:
        IF (ILREAD(7) .EQ. 0)
     &  CALL ERRMES(2,1,'L PKCN card giving peak centre')
      ELSE
C
C CN AND/OR LX - NEED L WVLN CARD:
        IF (ILREAD(13) .EQ. 0) THEN
          NLAMB=IREF2-1
          IF (CN) THEN
            ALAMBD(1,KSOURC)=1.900
          ELSE IF (LX) THEN
            ALAMBD(1,KSOURC)=1.544390
            ALAMBD(2,KSOURC)=1.540562
          ENDIF
          WRITE(LPT,2002) NLAMB,(ALAMBD(I,KSOURC),I=1,NLAMB)
2002      FORMAT (' ',I3,' Wavelength(s): ',5(1X,F9.6))
        ENDIF
        PKCNSP(1,JPHASE,JSOURC)=96.0505
        TWOTHD(JSOURC)=RADIAN(168.329)
      ENDIF
C
**??NOT USED ELSEWHERE:
C IF NO L ZERO CARD THEN ZEROPT=0:
      IF (ILREAD(8) .EQ. 0) ZEROSP(1,JPHASE,JSOURC)=0.
C
      CALL PCXX(6)
      WRITE (LPT,2018) STHLMX
2018  FORMAT (/' Maximum sin theta for generation of indices is',F10.4)
C
C GENERATE REFLECTIONS:
      CALL INRFPR(PCXX,DUMMY)
C
      RETURN
      END
C
C
C
C
C LEVEL 13      SUBROUTINE SETPR(PCXX,PFXX,MAGSET)
      SUBROUTINE SETPR(PCXX,PFXX,MAGSET)
C
C *** SETPR updated by PJB 1 Feb 1994 ***
C
CC 12C
CH Sets up sizes and pointers for PR LSQ for one phase.
CH Also reads in most of CDF to find out exactly what it is doing
CA PCXX is the subroutine to deal with peak centres
CA PFXX is the subroutine to deal with peak functions
CA MAGSET is a subroutine to deal with magnetic setting up, if needed.
CA            MAGSET=DUMMY for non-magnetic, DOMAG for magnetic.
CD Sets up the COMM0N /PRBLEM with NFAM, NGENPS, NSPCPS, LF1SP, LF3SP etc
CD then call LSETPR to set up packing of parameter names, etc
C
       EXTERNAL PFXX,PCXX,MAGSET
/F4PARS/
/GLOBAL/
/GRDBCK/
/PHASE/
/POSNS2/
/PRBLEM/
/PRPKCN/
/PRPKFN/
/PWORDS/
/REFINE/
/REFIPR/
/SCLDAT/
/SOURCE/
C
      DO 2 JSOUR = 1,NSOURC
      JSOURC = JSOUR
      CALL LOGSOU(JSOURC)
C SET UP WHICH DATA SOURCE, WHICH PEAK FUNCTION:
      CALL PFXX(0)
   2  CONTINUE
C 90.09 In SETPR; Set up all sourc pkfn before reading more cards etc
C 90.26 Changed my mind - don't re-read phase info for all sources
** Must fix scattering factors?
C      DO 1 JSOUR = 1,NSOURC
C      JSOURC = JSOUR
C      CALL LOGSOU(JSOURC)
C
C UNLESS CAIL OR APES SET UP REST OF STRUCTURE FACTOR CALCULATION:
      IF (RIET .OR. SAPS) THEN
** TO USE SLONLY, TAKE SETFCM APART & USE INDIVDUALLY
        CALL SETFCM(MAGSET)
        IF (PHMAG(JPHASE)) THEN
          CALL MAGCNC
          CALL MAGSET(2)
        ENDIF
      ELSE
        CALL RECIP
        CALL OPSYM(1)
C ENSURE POSSIBLE PROPAGATION VECTOR IS READ EVEN IF CAILS
        CALL PROPAG(1,INOUT)
        MAG=(INOUT.EQ.1)
      ENDIF
C SET UP ASYMMETRIC UNIT:
      CALL SYMUNI
C
C READ I AND MOST L CARDS:
      IF (.NOT. MULFAS) CALL STLSP0(PCXX,PFXX)
      CALL STLSPR(PCXX,PFXX)
C 90.20
C 90.30
C      JSOURC = JSOUR
C
C ADJUST WORDS AND THEIR SPECS TO FIT PRECISE PROBLEM:
** READ L ADDP CARDS AND ADD TO TEMWRD AND ITMWD OR WHATEVER
** AND IF FAMILY 3 OR 1, EXPECT A VALUE FOR LFnSP() ON CARD ALSO.
C
C SPECIFY PROBLEM:
C 90.30
      DO 1 JSOUR = 1,NSOURC
      JSOURC = JSOUR
      CALL LOGSOU(JSOURC)
      NGENPS(1,JPHASE)=1
      NSPCPS(1,JPHASE)=20
      NGENPS(6,JPHASE)=3
%      NSPCPS(6,JPHASE)=%BACK%
      NFAM=6
      IF (RIET) THEN
        NGENPS(4,JPHASE)=0
        NSPCPS(4,JPHASE)=0
      ELSE
        IF (CAIL) THEN
          NGENPS(4,JPHASE)=1
        ELSE
          NGENPS(4,JPHASE)=NGEN4(JPHASE,JSOURC)
        ENDIF
C SPECIES IN FAMILY 4 ALSO SET WHEN MAX K KNOWN - THIS IS FOR PACKING KK:
%        NSPCPS(4,JPHASE)=%REFS%
      ENDIF
C IN CASE USER GIVES A CARDS ETC FOR A CAIL PHASE, AND L RELA ETC:
*      IF (RIET .OR. SAPS) THEN
        NGENPS(2,JPHASE)=NATO(JPHASE)
C ALLOW ALL MAGNETIC:
        NSPCPS(2,JPHASE)=22
*      ELSE
C NO STRUCTURE PARAMETERS IN CAIL OR APES:
*        NGENPS(2,JPHASE)=0
*        NSPCPS(2,JPHASE)=0
*      ENDIF
C
C FAMILY 5 ARE MULTIPOLES, AND EXCLUDED:
      NGENPS(5,JPHASE)=0
      NSPCPS(5,JPHASE)=0
C
C NOW DEAL WITH FAMILY 3
      NGENPS(3,JPHASE)=10
      NSPCPS(3,JPHASE)=6
C
C SPECIES TYPES FOR EACH GENUS OF FAMILY 1:
      LF1SP(1)=13
C AND FOR FAMILY 3:
      LF3SP(1,JPHASE,JSOURC)=-1
      LF3SP(2,JPHASE,JSOURC)=-2
C LF3SP(3,4, ETC) SET INDIVIDUALLY IN PFXX:
C NPKGEN(JPHASE,JSOURC) IS NUMBER OF PEAK FUNCTION GENERA, AND SET INDIVIDUALLY
C IN PFXX
      L1=NPKGEN(JPHASE,JSOURC)+3
      L2=NGENPS(3,JPHASE)
      DO 6 I=L1,L2
   6  LF3SP(I,JPHASE,JSOURC)=0
C
C LF6SP(1,JSOURC) VARIES ACCORDING TO PEAK FUNCTION:
      LF6SP(2,JSOURC)=-2
      LF6SP(3,JSOURC)=-NBACK(JSOURC)
   1  CONTINUE
      CALL LSETPR(PCXX,PFXX)
 100  RETURN
      END
C
C
C
C
C LEVEL 11       SUBROUTINE SETTIC(PCXX)
       SUBROUTINE SETTIC(PCXX)
C
C *** SETTIC by JCM 8 Aug 91 ***
C
CH Prepare to write GENIE files by reading L cards and generating reflection
      EXTERNAL PCXX,DUMMY
/BRAGG/
/DGEOM/
/IOUNIT/
/LREAD/
/PHASE/
/PRPKCN/
/PRZERO/
/REFIPR/
/SOURCE/
C
C READ RELEVANT L CARDS:
      CALL INPLPR(PCXX,DUMMY)
C
C DEAL WITH THE CARDS WHICH ARE DIFFERENT ACCORDING TO TYPE OF DIFFRACTION:
C
C TF:
C NEED L THE2 CARD GIVING 2 THETA DEGREES:
      IF (TOF) THEN
        IF (ILREAD(18) .EQ. 0)
     &  CALL ERRMES(2,1,'L THE2 card giving counter angle')
C FOR TF MUST HAVE L PKCN CARD:
        IF (ILREAD(7) .EQ. 0)
     &  CALL ERRMES(2,1,'L PKCN card giving peak centre')
      ELSE
C
C CN AND/OR LX - NEED L WVLN CARD:
        IF (ILREAD(13) .EQ. 0) THEN
          IF (CN) THEN
            NLAMB=1
            ALAMBD(1,KSOURC)=1.900
          ELSE IF (LX) THEN
            NLAMB=2
            ALAMBD(1,KSOURC)=1.544390
            ALAMBD(2,KSOURC)=1.540562
          ENDIF
          WRITE(LPT,2002) NLAMB,(ALAMBD(I,KSOURC),I=1,NLAMB)
2002      FORMAT (' ',I3,' Wavelength(s): ',5(1X,F9.6))
        ENDIF
        PKCNSP(1,JPHASE,JSOURC)=96.0505
        TWOTHD(JSOURC)=RADIAN(168.329)
      ENDIF
C
**??NOT USED ELSEWHERE:
C IF NO L ZERO CARD THEN ZEROPT=0:
      IF (ILREAD(8) .EQ. 0) ZEROSP(1,JPHASE,JSOURC)=0.
C
      CALL PCXX(6)
      WRITE (LPT,2018) STHLMX
2018  FORMAT (/' Maximum sin theta for generation of indices is',F10.4)
C
C GENERATE REFLECTIONS:
      CALL INRFPR(PCXX,DUMMY)
C
      RETURN
      END
C
C
C
C
C LEVEL 8       SUBROUTINE GOF(M,YCPC)
      SUBROUTINE GOF(M,YCPC)
C
C *** Statistics for multi source, multi phase by JPW/JBF 23-Sep-99 ***
C Mostly plagiarised from from RFACPR which was updated by JBF 13-Jan-95
C
CH Multiple entry routine to deal with Profile refinement R Factors
CA On entry M indicates the actions required:
CA  M=1 Initialise - clear totals, to be called at the beginning of each
CA    cycle through the data (ie per phase)
CA  M=2 as entry 3, but dealing with a zero Ycalc
CA  M=3 Add in contributions, given values, differences and weights,
CA    called per point, per phase (uses jsourc)
CA  M=4 Print results
CA
CA YCPC hold {YC}ALC for the {P}revious {C}ycle. This appears to be an
CA  unavoidable fudge for getting the integrated peak intensities on
CA  a per phase basis. When phase 1 is processed the contributions from
CA  phases 2,3 etc are not know. When they are known, then the common
CA  block REFLNS is no longer available for adding in the contributions.
CA  As such I('obs') is being partitioned according to the contribution
CA  in the previous cycle, not the current one. Accordingly all quantities
CA  relying on it are meaningless until a refinement converges. For single
CA  phase refinements YCPC is set to YCALC in this routine.
C
C  *** SUGGESTIONS PLEASE *** I'd rather not do a series of phase swaps
C   before finishing each cycle.
C
C
%      DIMENSION SSUMWD(%SORC%),SMYC(%SORC%),SMYD(%SORC%),SMYO(%SORC%),
%     & SMYOB(%SORC%),SWYOBS(%SORC%),SMWYOS(%SORC%),SMIO(%SORC%),
%     & SMID(%SORC%),RINUM(%SORC%),RIDEN(%SORC%),IZCT(%SORC%),
%     & NOOOBS(%SORC%),FREE(%SORC%),IH(3)
      LOGICAL TESTOV,PRNCYC
/DERBAS/
/F4PARS/
/GLOBAL/
/GRDBCK/
/IOUNIT/
/OBSCAL/
/PHASE/
/PRBLEM/
/PRPKFN/
/REFINE/
/REFIPR/
/REFLNS/
/SCRACH/
/SOURCE/
      DATA IOPRO,IOP1,IODER/-9999,-9999,-9999/
      SAVE IOPRO,IOP1,IODER
      SAVE SSUMWD,SMYC,SMYD,SMYO,SMYOB,SWYOBS,SMWYOS,SMIO,
     & SMID,RINUM,RIDEN,IZCT,NOOOBS,FREE,IH,LDSRC

C
      GO TO (1,2,3,4) ,M
C
***** INITIAL ENTRY : CLEARS ALL
C
C Reflections need to be cleared for each phase
%   1   DO 11 I=1,%REFS%
      AIOBS(I)=0.0
      ESDOBS(I)=0.0
      SOMEGA(I)=0.0
C TO INDICATE WHETHER OR NOT USED
      AICALC(I)=-9999.
  11  CONTINUE
C
C Sums should only be cleared if we are on phase 1
      IF(JPHASE.EQ.1) THEN
%       DO 12 J=1,%SORC%
          SSUMWD(J)=0.0
          SMYC(J)=0.0
          SMYD(J)=0.0
          SMYO(J)=0.0
          SMYOB(J)=0.0
          SWYOBS(J)=0.0
          SMWYOS(J)=0.0
          SMIO(J)=0.0
          SMID(J)=0.0
          IZCT(J)=0
C {NO}. {O}f {OBS}ervations per source.
          NOOOBS(J)=0
  12    CONTINUE
      ENDIF
C
C Initialise printing...
C So we will need to print per phase....
C
C This one is per phase as it uses first and last reflection:
      IF (PRNCYC(1)) CALL MESS(LPT,1,'Argument    Yobs     Ycalc'//
     & '     Diff First and last reflns')
C OPEN FILE FOR FOURIER INPUT IF REQUIRED: (Also per phase)
      IF (PRNCYC(3)) THEN
        MESSAG='File for h k l Fc Fo'
        NAMFIL='.FOU'
        CALL OPNFIL(IOP1,112)
      ENDIF
C OPEN FILE TO RECEIVE PROFILE IF NEEDED: Once only, not every phase
      IF (PRNCYC(4).AND.JPHASE.EQ.1) THEN
        MESSAG='File to output Profiles'
        NAMFIL='.PRO'
        CALL OPNFIL(IOPRO,112)
      ENDIF
C Open file to receive derivatives
      IF (PRNCYC(9).AND.JPHASE.EQ.1) THEN
        MESSAG='File for derivatives'
        NAMFIL='.DER'
      CALL OPNFIL(IODER,112)
      ENDIF
      GO TO 100
C
********** ENTRY 2: DEAL WITH ZERO YCALC:
   2  IZCT(JSOURC)=IZCT(JSOURC)+1
C IF REQUESTED ON "L REFI" CARD, OMIT ZEROS FROM STATISTICS:
** Need to sort out this ZBAKIN business
C      IF (.NOT. ZBAKIN) GO TO 32
C 90.58 Try to fix the excluded region bug in GOF. If YCALC is zero the point is out
C       of the statistics. Still not fixed properly until ZBAKIN is sorted out,
      GO TO 32
C
********** ENTRY 3: ADD IN CONTRIBUTIONS
C This should be called at each data point, for each phase.
C
C Fill in bits of common reflns
   3  KK=KMIN
      DO 31 J=KMIN,KMAX
        IF (NPHASE.EQ.1) YCPC=YPEAK
        IF (TESTOV(GGCALC(J-KMIN+1),YCPC)) GO TO 31
        TEMP=GGCALC(J-KMIN+1)/YCPC
C COLLECT INTEGRATED INTENSITIES FOR EACH PHASE:
        OB=OBS-YBACK
        AIOBS(J)=AIOBS(J)+TEMP*OB
C63: ONE TEMP REMOVED:
        IF (TESTOV(TEMP,WT)) GO TO 31
        ESDOBS(J)=ESDOBS(J)+TEMP/SQRT(WT)
  31  CONTINUE
C
      IF (JPHASE.EQ.NPHASE) THEN
        SSUMWD(JSOURC)=SSUMWD(JSOURC)+WDIFF*WDIFF
        SMYC(JSOURC)=SMYC(JSOURC)+ABS(YPEAK)
        SMYD(JSOURC)=SMYD(JSOURC)+ABS(DIFF)
        SMYO(JSOURC)=SMYO(JSOURC)+ABS(OBS)
        SMYOB(JSOURC)=SMYOB(JSOURC)+ABS(OB)
        SWYOBS(JSOURC)=SWYOBS(JSOURC)+WT*OB*OB
        SMWYOS(JSOURC)=SMWYOS(JSOURC)+WT*OBS*OBS
        NOOOBS(JSOURC)=NOOOBS(JSOURC)+1
      ENDIF
C
C IF REQUESTED, WRITE OUT PROFILE FOR FUTURE REINPUT (INCLUDING ZERO
C YCALCS: (last phase only)
**** Re-entry for ycalc=0
**** Re-entry for ycalc=0
  32  IF (PRNCYC(4) .AND. JPHASE.EQ.NPHASE) THEN
C
C Write out an extra two carriage returns at the end of a source
        IF(JSOURC .NE. LDSRC) THEN
          WRITE(IOPRO,'(//)')
          LDSRC=JSOURC
        ENDIF
        WRITE (IOPRO,2003) ARGI,YBACK,OBS,YCALC,DOBS
2003    FORMAT (F12.4,8F12.4)
      ENDIF
      IF (PRNCYC(9) .AND. JPHASE.EQ.NPHASE)
     &  WRITE (IODER,*) ARGI,(DERIVB(I),I=1,LVARB)
      IF(PRNCYC(1)) THEN
        IF (IZCT(JSOURC) .NE. 0) WRITE (LPT,2001) IZCT(JSOURC)
2001    FORMAT (' (',I5,' zeros )')
        IZCT(JSOURC)=0
        WRITE (LPT,2002) ARGI,OBS,YCALC,DIFF,KMIN,KMAX
2002    FORMAT (' ',F12.2,2F12.4,F14.4,(2X,I5,2X,I5,2X))
      ENDIF
      GO TO 100
C
********** ENTRY 4: PRINT - per phase
C NOT IF SIMULATION: ??
C
C Now get integrated intensity quantities per phase
   4  DO 42 JSRC=1,NSOURC
        IF(JSRC.EQ.1) THEN
          IFIRST=1
        ELSE
          IFIRST=LRFSRC(JSRC-1,JPHASE)+1
        ENDIF
        DO 41 K=IFIRST,LRFSRC(JSRC,JPHASE)
C IGNORE IF NOT USED:
          IF (AICALC(K) .EQ. -9999.) GO TO 41
C IGNORE IF DIVIDING SUM HAS STAYED ZERO:
          IF (SOMEGA(K) .EQ. 0.) GO TO 41
          AIOBS(K)=AIOBS(K)/SOMEGA(K)
          ESDOBS(K)=ESDOBS(K)/SOMEGA(K)
          SMIO(JSRC)=SMIO(JSRC)+AIOBS(K)
          D=ABS(AIOBS(K)-AICALC(K))
          SMID(JSRC)=SMID(JSRC)+D
          IF (.NOT. TESTOV(SOMEGA(K),ESDOBS(K))) THEN
C             TEMP=SOMEGA(K)*SOMEGA(K)/ESDOBS(K)
             RINUM(JSRC)=RINUM(JSRC)+D*D/(ESDOBS(K)**2)
             RIDEN(JSRC)=RIDEN(JSRC)+AIOBS(K)*AIOBS(K)/(ESDOBS(K)**2)
          ENDIF
  41    CONTINUE
  42  CONTINUE
C
      IF (.NOT. PRNCYC(2) .AND. .NOT. PRECYC) GO TO 45
      IF (PRECYC) THEN
        DO 46 I=1,MAXKK(JPHASE)
        F4PAR(1,I)=0.
  46    F4PESD(1,I)=0.
      ENDIF
      WRITE (LPT,FMT='(/1X,3(1X,A1,5X),A5,5X,4(A7,5X))')'h','k','l',
     &  'Dstar',' I(obs)','I(calc)','   Diff','   Esd'

      DO 47 K=1,LRFSRC(NSOURC,JPHASE)
C     WRITE(LPT,*)K,(REFH(I,K),I=1,3)
C 90.39 always call indfix
      CALL INDFIX(REFH(1,K),IH)
      IF (AICALC(K) .EQ. -9999.) THEN
        IF (FIXED) THEN
          WRITE (LPT,FMT='(1X,3I5,A9)') IH,' not used'
        ELSE
          WRITE (LPT,FMT='(1X,3F8.3,A9)')(REFH(I,K),I=1,3),' not used'
        ENDIF
        GO TO 47
      ENDIF
      IF (SOMEGA(K) .EQ. 0.) THEN
        IF(FIXED) THEN
          WRITE (LPT,FMT='(1X,3I5,A25)') IH,' gave zero denominator'
        ELSE
          WRITE (LPT,FMT='(1X,3I5,A25)') (REFH(I,K),I=1,3),
     &    ' gave zero denominator'
        ENDIF
        GO TO 47
      ENDIF
C
      AIDIFF=AIOBS(K)-AICALC(K)
C63: TEMPORARY AS ESDOBS COMING -VE:
      ESDOB=0.
      IF (ESDOBS(K) .GE. 0.) THEN
        ESDOB=SQRT(ESDOBS(K))/SOMEGA(K)
      ELSE
        WRITE(LPT,*)'How on earth is an esd negative??'
      ENDIF
      IF (.NOT. FIXED) THEN
       WRITE (LPT,FMT='(1X,3(1X,F6.3),F10.5,4F12.2)')
     &    (REFH(I,K),I=1,3),DSTAR(K),AIOBS(K),AICALC(K),AIDIFF,ESDOBS(K)
      ELSE
       WRITE (LPT,FMT='(1X,3(1X,I6),F10.5,4F12.2)')
     &    IH,DSTAR(K),AIOBS(K),AICALC(K),AIDIFF,ESDOBS(K)
      ENDIF
      IF (PRECYC) THEN
        F4PAR(1,K)=AIOBS(K)
        F4PESD(1,K)=ESDOB
      ENDIF
  47  CONTINUE
C
C Print integrated intensity R-factors per phase:
  45  IF(TESTOV(SMIO,SMID)) GO TO 43
      IF(NVARF(2,JPHASE,1) .EQ. 0) GO TO 43
      IF(MULFAS) WRITE (LPT,FMT='(/1X,A5,I3,A2)')'Phase',JPHASE,' :'
C      IF(MULFAS) WRITE (ITO,FMT='(/1X,A5,I3,A2)')'Phase',JPHASE,' :'
C PRINT R FACTORS FOR END OF CYCLE:
      WRITE(LPT,FMT='(//1X,A10/)')'R Factors:'
C      WRITE (ITO,FMT='(9X,A5,9(2X,A3,I3))') 'Total',
C     &    ('Src',I,I=1,NSOURC)
      WRITE (LPT,FMT='(9X,A5,9(2X,A3,I3))') 'Total',
     &    ('Src',I,I=1,NSOURC)
C
C Others to be added - but are they useful and are they right?
C hold off for now (28-9-99 JPW)
C
C R_f The integrated intensity Rfactor
      CALL SUMVEC(SMID,1,NSOURC,1,TOTID)
      CALL SUMVEC(SMIO,1,NSOURC,1,TOTIO)
      WRITE(LPT,FMT='(1X,A3,2X,10F8.4)')'R_f',
     & 100.*TOTID/TOTIO,(100.*SMID(I)/SMIO(I),I=1,NSOURC)
      WRITE(LPT,*)'R_f !! health warning'
C      WRITE(ITO,FMT='(1X,A3,2X,10F8.4)')'R_f',
C     & 100.*TOTID/TOTIO,(100.*SMID(I)/SMIO(I),I=1,NSOURC)
C
C Weighted squared integrated intensity Rfactor
      CALL SUMVEC(RINUM,1,NSOURC,1,TOTUM)
      CALL SUMVEC(RIDEN,1,NSOURC,1,TOTEN)
      WRITE(LPT,FMT='(1X,A5,10F8.4)')'Rwf^2',
     & 100.*TOTUM/TOTEN,(100.*RINUM(I)/RIDEN(I),I=1,NSOURC)
      WRITE(LPT,*)'!! Health Warning'
C      WRITE(ITI,FMT='(1X,A5,10F8.4)')'Rwf^2',
C     & 100.*TOTUM/TOTEN,(100.*RINUM(I)/RIDEN(I),I=1,NSOURC)
C
C
  43  IF(JPHASE.NE.NPHASE) GO TO 100
C
      WRITE(LPT,FMT='(//1X,A11)')'Definitions'
      WRITE(LPT,FMT='(A36)') 'R_f   = 100*(Sum I diffs/Sum I obs)'
      WRITE(LPT,FMT='(A36)') 'Rwf^2 = 100*(Sum I diffs/Sum I obs)'
      WRITE (LPT,FMT='(A36)')
     & 'R_p   = 100*(Sum Y diffs/Sum Y obs)'
      WRITE (LPT,FMT='(1X,A46)')
     & 'R_pb  = 100*(Sum Y Diffs/(Sum Y Obs - Y Back))'
      WRITE (LPT,FMT='(1X,A45)')
     & 'R_wp  = 100*Sqrt(Sum wt diffs^2/Sum wt Obs^2)'
      WRITE (LPT,FMT='(1X,A52)')
     & 'R_wp  = 100*Sqrt(Sum wt diffs^2/Sum wt (Obs-back)^2)'
      WRITE (LPT,FMT='(1X,A20)')
     & 'Nobs  = Number of Observations'
      WRITE (ITO,FMT='(/9X,A5,9(2X,A3,I3))') 'Total',
     &    ('Src',I,I=1,NSOURC)
      WRITE (LPT,FMT='(/9X,A5,9(2X,A3,I3))') 'Total',
     &    ('Src',I,I=1,NSOURC)
C
C R_p Profile R-factor
      CALL SUMVEC(SMYD,1,NSOURC,1,TOT1)
      CALL SUMVEC(SMYO,1,NSOURC,1,TOT2)
      WRITE (ITO,FMT='(1X,A3,2X,10F8.3)') 'R_p',
     &  100*TOT1/TOT2,((100.*SMYD(I)/SMYO(I)),I=1,NSOURC)
      WRITE (LPT,FMT='(1X,A3,2X,10F8.3)') 'R_p',
     &  100*TOT1/TOT2,((100.*SMYD(I)/SMYO(I)),I=1,NSOURC)
C
C R_p Profile R-factor using obs-back
      CALL SUMVEC(SMYOB,1,NSOURC,1,TOT3)
      IF(.NOT.TESTOV(TOT1,TOT3)) THEN
      WRITE (ITO,FMT='(1X,A4,1X,10F8.3)')'R_pb',
     &  100.*TOT1/TOT3,((100.*SMYD(I)/SMYOB(I)),I=1,NSOURC)
      WRITE (LPT,FMT='(1X,A4,1X,10F8.3)')'R_pb',
     &  100.*TOT1/TOT3,((100.*SMYD(I)/SMYOB(I)),I=1,NSOURC)
      ENDIF
C
C R_wp Weight profile R-factor
      CALL SUMVEC(SSUMWD,1,NSOURC,1,TOT4)
      CALL SUMVEC(SMWYOS,1,NSOURC,1,TOT5)
      IF(.NOT.TESTOV(TOT4,TOT5)) THEN
      WRITE (ITO,FMT='(1X,A4,1X,10F8.3)')'R_wp',
     &  100.*SQRT(TOT4/TOT5),
     &  ( (100.*SQRT( (SSUMWD(I)/SMWYOS(I)) )), I=1, NSOURC )
      WRITE (LPT,FMT='(1X,A4,1X,10F8.3)')'R_wp',
     &  100.*SQRT(TOT4/TOT5),
     &  ( (100.*SQRT( (SSUMWD(I)/SMWYOS(I)) )), I=1, NSOURC )
      ENDIF
C
C R_wp Weight profile R-factor using obs-back
      CALL SUMVEC(SWYOBS,1,NSOURC,1,TOT6)
      IF(.NOT.TESTOV(TOT4,TOT6)) THEN
      WRITE (ITO,FMT='(1X,A5,10F8.3)')'R_wpb',
     &  100.*SQRT(TOT4/TOT6),
     &  ( (100.*SQRT( (SSUMWD(I)/SWYOBS(I)) )), I=1, NSOURC )
      WRITE (LPT,FMT='(1X,A5,10F8.3)')'R_wpb',
     &  100.*SQRT(TOT4/TOT6),
     &  ( (100.*SQRT( (SSUMWD(I)/SWYOBS(I)) )), I=1, NSOURC )
      ENDIF
C
C Nobs Number of observations and N-P+C for each - print lower down
      NTOT7=0
      DO 44,I=1,NSOURC
      FREE(I)=FLOAT(NOOOBS(I)-LVARB)
  44  NTOT7=NTOT7+NOOOBS(I)
C
C R_e Expected Rfactor for each - Is this valid ??
      ALFREE=FLOAT(NTOT7-LVARB)
      WRITE(ITO,FMT='(1X,A3,2X,10F8.4)'),'R_e',
     & 100.*SQRT(ALFREE/TOT5),
     & (100.*SQRT(FREE(I)/SMWYOS(I)),I=1,NSOURC)
      WRITE(LPT,FMT='(1X,A3,2X,10F8.4)'),'R_e',
     & 100.*SQRT(ALFREE/TOT5),
     & (100.*SQRT(FREE(I)/SMWYOS(I)),I=1,NSOURC)
C
C R_eb Expected obs/back Rfactor for each - Again, is it valid?
      IF(.NOT.TESTOV(ALFREE,TOT6)) THEN
      WRITE(ITO,FMT='(1X,A4,1X,10F8.4)'),'R_eb',
     & 100.*SQRT(ALFREE/TOT6),
     & (100.*SQRT(FREE(I)/SWYOBS(I)),I=1,NSOURC)
      WRITE(LPT,FMT='(1X,A3,2X,10F8.4)'),'R_e',
     & 100.*SQRT(ALFREE/TOT6),
     & (100.*SQRT(FREE(I)/SWYOBS(I)),I=1,NSOURC)
      ENDIF
C
C Now print nobs.
      WRITE (ITO,FMT='(1X,A4,1X,10I8)'),'Nobs',
     & NTOT7, (NOOOBS(I),I=1,NSOURC)
      WRITE (LPT,FMT='(1X,A4,1X,10I8)'),'Nobs',
     & NTOT7, (NOOOBS(I),I=1,NSOURC)
C
C Chi^2
      CHISQ=TOT4/ALFREE
      WRITE(ITO,FMT='(/1X,A5,10F8.2)')'Chi^2',
     & CHISQ,(SSUMWD(I)/FREE(I),I=1,NSOURC)
      WRITE(LPT,FMT='(/1X,A5,10F8.2)')'Chi^2',
     & CHISQ,(SSUMWD(I)/FREE(I),I=1,NSOURC)
C
      WRITE(ITO,FMT='(3X,A3,I5,A10)')'For',LVARB,' variables'
      WRITE(LPT,FMT='(3X,A3,I5,A10)')'For',LVARB,' variables'
C
      IF(JPHASE.EQ.NPHASE) CALL ESDFIX(TOT4,NTOT7)
 100  RETURN
      END
C
C
C
C
      SUBROUTINE ESDFIX(A,J)
/OBSCAL/
C
      SUMWD=A
      NOBS=J
      RETURN
      END
C
C
C
C
C LEVEL 11      SUBROUTINE STLSP0(PCXX,PFXX)
      SUBROUTINE STLSP0(PCXX,PFXX)
C
C *** STLSP0 updated by JCM 28 Dec 92 ***
C
      EXTERNAL PCXX,PFXX
/BRAGG/
/CARDRC/
/EXCREG/
/FUDG/
/GRDBCK/
/IOUNIT/
/LREAD/
/OBSCAL/
/OMITPR/
/PHASE/
/PRBLEM/
/PRPKCN/
/PRPKFN/
/REFINE/
/REFIPR/
/SCLDAT/
/SLAKDA/
/SLKGEO/
/SOURCE/
/SPLBCK/
/PRZERO/
C
C READ THE I CARDS AND ALL THE (RELEVANT) L CARDS.
C
      IF (INREAD(9) .GT. 0) CALL INPUTI
C READ & INTERPRET 'I' CARDS - ALSO SETS (AND REPORTS) SIMUL:
      CALL IICD2
C
C INITIALISE COUNTS FOR THINGS OF WHICH MORE THAN 1 MAY APPEAR:
      MIS=0
      NFUDGE=0
C DEFAULT NO. OF FFT:
      NFFT=1
C
      DO 1 J=1,NSOURC
      NBACK(J)=0
      NEXCL(J)=0
C DEFAULTS, AS YET UNPRINTED:
      TOLR(1,J)=0.01
      TOLR(2,J)=0.01
   1  CONTINUE
C
C READ AND INTERPRET ALL PHASE-INDEPENDENT L CARDS:
      CALL INPLP0(PCXX,PFXX)
C
C CYCLE OVER SOURCES:
C 90.02
      DO 3 JSSS=1,NSOURC
      JSOURC=JSSS
C The variable JSSS avoids an apparent problem with using
C common vars for loops.
C
C SET TOF, CN ETC:
      CALL LOGSOU(JSOURC)
C DEFAULT WEIGHTING IS TYPE 3:
      IF (ILREA(6,JSOURC) .EQ. 0) THEN
        IWGH(JSOURC)=3
        CALL MESS(LPT,1,
     &  'No L WGHT card given - assuming 1/s^2 weights')
      ENDIF
C
C DEFAULT IF NO L OTYP CARD GIVING FORMAT TYPE OF OBSERVATION DATA:
      IF (ILREA(10,JSOURC) .EQ. 0) THEN
        MODEOB(JSOURC)=1
        CALL MESS(LPT,1,'No L OTYP card - assuming observations given'//
     &  ' in mode 1 (format 3F)')
      ENDIF
C
C L BACK CARDS NEEDED:
      IF (ILREA(11,JSOURC) .EQ. 0)
     & CALL ERRMES(2,1,'L BACK cards')
C
C SET UP SPLINE COEFFICIENTS IF REQUIRED:
      IF (IBACK .EQ. -2) CALL SPLINE(NBACK(JSOURC),
     & ARGBAK(1,JSOURC),BACKGD(1,JSOURC),SCOEFF(1,JSOURC))
C
C REMARK IF NO EXCLUDED ZONES:
  10  IF (ILREA(12,JSOURC).EQ.0) CALL MESS(LPT,1,'No excluded regions')
C
C DEFAULT KNOTS (NOT PRINTED IN CASE NOT NEEDED AT ALL)
*        IF (ILREAD(20) .EQ. 0) AKNOTS=10.
C
C NOW THE CARDS WHICH ARE DIFFERENT ACCORDING TO SOURCE OF DATA:
C
C TOF AND/OR ED:
C NEED L THE2 CARD GIVING 2 THETA DEGREES:
      IF ((TOF .OR. ED) .AND. ILREA(18,JSOURC) .EQ. 0)
     & CALL ERRMES(2,1,'L THE2 card giving counter angle')
C
C CN AND/OR LX:
C NEED L WVLN CARD:
      IF ((CN .OR. LX) .AND. ILREA(13,JSOURC) .EQ. 0)
     & CALL ERRMES(2,1,'L WVLN card giving wavelength')
C
C LX:
C NEED L TTHM:
      IF (LX .AND. ILREA(17,JSOURC) .EQ. 0) CALL TTHMLX(5)
C
C DEFAULT IF NO L SCAL:
C 90.02
C      IF (ILREA(2,JSOURC) .EQ. 0) CALL LSSCAL(0)
C
C DEFAULT IF NO L SLIM CARD AND CAIL, SAPS OR APES:
*        IF (ILREAD(3) .EQ. 0 .AND. .NOT. RIET) CALL FAM4PR(5)
C FOR TOF MUST HAVE L PKCN CARD:
      IF (TOF .AND. ILREAD(7) .EQ. 0) THEN
        CALL ERRMES(2,1,'L PKCN card giving peak centre')
      ELSE
C COPY PKCN COEFFICIENTS FOR ALL PHASES.. AT PRESENT PKCN IS PHASE-INDEPENDENT,
C BUT I HAVE A SUSPICIOUS NATURE . .
        DO 42 IJ=2,NPHASE
        PKCNSP(1,IJ,KSOURC)=PKCNSP(1,1,KSOURC)
  42    PKCNSP(2,IJ,KSOURC)=PKCNSP(2,1,KSOURC)
      ENDIF
C
C MUST HAVE L ZERO CARD:
      IF (ILREAD(8) .EQ. 0) THEN
        CALL ERRMES(2,1,'L ZERO card giving zero point')
      ELSE
C COMMENT AS FOR PKCN ABOVE:
        DO 43 IJ=2,NPHASE
  43    ZEROSP(1,IJ,KSOURC)=ZEROSP(1,1,KSOURC)
      ENDIF
C
C DEFAULT IF NO L ABSC CARD FOR ABSORPTION CORRECTION:
  21  IF (ILREA(14,JSOURC) .EQ. 0)  CALL ABCRPR(5)
C
C DEFAULT IF NO RTYP CARD - TYPE 1:
      IF (ILREA(4,JSOURC) .EQ. 0) THEN
        MODERR(JSOURC)=1
        CALL MESS(LPT,1,'No L RTYP card - assuming  reflection '//
     &  'indices input as a list of 3I5 h,k,l on given file')
      ENDIF
C
      CALL PCXX(6)
      WRITE (LPT,2008) STHMXX(JSOURC)
2008  FORMAT (/' Maximum sin theta is',F10.4)
C
   3  CONTINUE
C
C DEFAULT IF NO L EXTN CARD FOR EXTINCTION CORRECTION:
      IF (ILREAD(15) .EQ. 0)  CALL EXCRPR(5)
C
C DEFAULT IF NO L PROR CARD FOR PREFERRED ORIENTATION
      IF (ILREAD(16) .EQ. 0) CALL PREFOR(5)
C
 100  RETURN
      END
C
C
C
C
C LEVEL 11      SUBROUTINE STLSPR(PCXX,PFXX)
      SUBROUTINE STLSPR(PCXX,PFXX)
C
C *** STLSPR updated by JCM Jun 92 ***
C
      EXTERNAL PCXX,PFXX
/BRAGG/
/CARDRC/
/EXCREG/
/FUDG/
/GLOBAL/
/GRDBCK/
/IOUNIT/
/LREAD/
/OBSCAL/
/OMITPR/
/PHASE/
/PRBLEM/
/PRPKFN/
/REFINE/
/REFIPR/
/SCLDAT/
/SLAKDA/
/SLKGEO/
/SOURCE/
/SPLBCK/
C
C READ AND INTERPRET ALL L CARDS EXCEPT SLAK ETC., FUDG,REFI, FIX,
C VARY, RELA:
      CALL INPLPR(PCXX,PFXX)
C
C MUST HAVE L PKFN CARDS:
C 90.70 Use new PFALL(2) to check
      CALL PFALL(2)
C 90.70        IF (ILREAD(9) .EQ. 0)
C 90.70     &  CALL ERRMES(2,1,'L PKFN cards giving peak function')
C
C NOW FOR THIS PHASE:
C CLEAR CONSTRAINT COUNTS FOR GEOMETRY AND PAWLEY:
      NUMBON=0
      NSKTOT=0
%      CALL JGMZER(NSLAK,1,%SKTP%)
C
C DEFAULT IF NO L TFAC:
  40  IF (ILREAD(1) .EQ. 0) CALL LLTFAC(5)
C
C DEFALT IF NO L SPHA (FOR INSTANCE, IF NOT MULTI):
      IF (ILREAD(5) .EQ. 0) CALL LPSCAL(5)
C
      CALL GEOMIN(1)
      CALL ERRMES(0,0,'for Profile Refinement')
 100  RETURN
      END
C
C
C
C
C LEVEL 6      SUBROUTINE THETA2(N)
      SUBROUTINE THETA2(N)
C
C *** THETA2 updated by JCM 10 Mar 92 ***
C
CX
CC 6A
CH Multiple entry routine to deal with 2theta in CELLSQ
C
CA On entry MODE says which action is required.
CA MODE=1: reads 2theta from an L THE2 card (or set a default of
CA         180 degrees, and set up related constants.
CA MODE=2: dummy entry
CA MODE=3: apply a shift to 2theta, and adjust the constants.
CA MODE=4: write out new L THE2 card.
C
CA ENTRY THET28 sets the parameter as a variable
CA ENTRY THET29 sets the parameter as initially fixed.
C
CD The various entries are used in the main program CELLSQ, which
CD refines cell parameters and 2theta.  Entry 2 would normally form
CD 2theta as a calculated function, but this is done in the main program.
C
CI Reads and interprets L THE2 card from copy of the Crystal Data File
CI on unit IO10.
CO Writes out new L THE2 to unit NEWIN.
C
      LOGICAL ONCARD
/BRAGG/
/IOUNIT/
/NEWOLD/
/PRPKCN/
/SOURCE/
/THET2/
C
      GO TO (1,100,3,4) , N
C
C FIND L THE2 CARD IF THERE IS ONE, AND READ 2THETA FROM IT:
   1  THE2=180.
      IF (ONCARD('L','THE2',THE2)) THEN
        WRITE (LPT,2001) THE2
2001    FORMAT (/' 2 theta =',F10.3,' degrees')
      ELSE
        CALL MESS(LPT,1,'No L THE2 card - 2 theta = 180 degrees')
      ENDIF
C SET UP THETA-RELATED QUANTITIES:
      GO TO 101
C
C APPLY SHIFT:
   3  CALL ADJUST(THE2)
      GO TO 101
C
C NEW L THE2 CARD:
   4  WRITE(NEWIN,2000) THE2
2000  FORMAT ('L THE2',F10.2)
      GO TO 100
C
C SET THE2 TO BE A VARIABLE:
      ENTRY THET28(NV)
      KTHET2=NV
      GO TO 100
C
C SET THET2 TO BE INITIALLY FIXED:
      ENTRY THET29
      KTHET2=0
      GO TO 100
C
 101  THRAD=RADIAN(THE2/2.)
      TWSNTH(JSOURC)=2.*SIN(THRAD)
      THCON1=RADIAN(COS(THRAD))
 100  RETURN
      END
C
C
C
C
C LEVEL 8      SUBROUTINE TTHMLX(N)
      SUBROUTINE TTHMLX(N)
C
C *** TTHMLX updated by JCM 4 Apr 89 ***
C
CH Multiple entry routine to deal with all aspects of 2 theta
CH   monochromator for constant wavelength X Ray Profile Refinement
C
/BRAGG/
/CELPAR/
/DGEOM/
/FCAL/
/IOUNIT/
/NEWOLD/
/PHASE/
/PRPKFN/
/PRZERO/
/SOURCE/
/TTHMNC/
C
      GO TO (1,2,3,4,5,6) , N
C
C GIVEN AN 'L TTHM' CARD IN COMM0N /SCRACH/, READ REST OF IT:
   1  CALL RDREAL(TTHMON(JSOURC),7,IPT,80,IER)
      WRITE (LPT,2000) TTHMON(JSOURC)
2000  FORMAT (/' Monochromator 2 theta angle = ',F10.5)
      GO TO 19
C
C ENTRY FROM CALPR FOR LP CORRECTION:
 2    DTEM=RADIAN(ARGI-ZEROSP(1,JPHASE,JSOURC))
      STEM=SIN(DTEM)
      CTEM=COS(DTEM)
      SHTEM=SIN(0.5*DTEM)
      CCTEM=C2TMON(JSOURC)*CTEM
      CCTEM=1.+CCTEM*CCTEM
      ALPCOR=CCTEM/(STEM*SHTEM*OPCMON(JSOURC))
      DLPCOR=RADIAN(S4TMON(JSOURC)*STEM*STEM)/(CCTEM*OPCMON(JSOURC))
      GO TO 100
C
C APPLY SHIFT IN COEFFICIENT:
   3  IF (JPHASE .NE. 1) GO TO 100
      CALL ADJUST(TTHMON(JSOURC))
  19  C2TMON(JSOURC)=COS(RADIAN(TTHMON(JSOURC)))
      S4TMON(JSOURC)=SIN(2.*RADIAN(TTHMON(JSOURC)))
      OPCMON(JSOURC)=1.+C2TMON(JSOURC)*C2TMON(JSOURC)
      GO TO 100
C
C WRITE OUT NEW 'L TTHM' CARD FOR LX:
   4  WRITE (NEWIN,2001) TTHMON(JSOURC)
2001  FORMAT ('L TTHM',F10.5)
*** WE WILL NEED OUTPUT FACILITIES FOR THESE *S CARDS AS WELL AS IN
      GO TO 100
C
C
C DEAL WITH ABSENCE OF 'L TTHM' CARD:
   5  CALL MESS(LPT,1,'No L TTHM card - assuming monochromator'//
     & ' 2 theta = 0')
  10  TTHMON(JSOURC)=0.0
      GO TO 19
C
C FIX TTHMON  IF NO CARD GIVEN:
   6  IF (ABS(TTHMON(JSOURC)).LT.0.001)
     & CALL ADDFX5(6,1,2,1,JSOURC,4)
      GO TO 100
C
C
      ENTRY THMLX8(NV)
C RECORD PARAMETER AS VARIABLE NUMBER NV:
      KTHMON(JSOURC)=NV
      GO TO 100
C
C
      ENTRY THMLX9
C RECORD PARAMETER AS FIXED:
      KTHMON(JSOURC)=0
C
 100  RETURN
      END
C
C
C
C
C LEVEL 15      SUBROUTINE VARSAL
      SUBROUTINE VARSAL
C
C *** VARSAL from VARSPM JBF/JPW 30-7-1999 ***
C
C Altered to tests for magnetic phases and work for both mag and non mag
C
CX
CC 19B
CH Records which parameters are which variables for magnetic PR
C
CD Identifies species of parameter, then calls specific routines actually
CD    to set variables, thus not needing all COMMONs to be explicit here
CD
C
/DERBAS/
/DERVAR/
/GLOBAL/
/PHASE/
/POINTS/
/REFINE/
/REFIPR/
/SOURCE/
C
      IF (SIMUL) GO TO 100
C SET ALL VARIABLES FIXED:
      DO 111 JPHASE=1,NPHASE
      CALL PHMOVE(1,JPHASE)
C 90.33 added do loop over sources
      DO 111 JSOURC=1,NSOURC
      CALL LOGSOU(JSOURC)
      CALL BACKP9
      CALL PCXX9
      CALL LSSCA9
      CALL ZERPR9
C 90.33 end of added lines - these calls were removed from below
C maybe they should only be done per source and not per phase??
C Be prepared to find problems here!
      CALL LTFAC9
      CALL CELVAR(0,0)
      IF(PHMAG(JPHASE)) CALL PROPAG(0,0)
      CALL F2VAR9
      CALL FM4PR9
      CALL LPSCA9
      IF(PHMAG(JPHASE)) CALL MAGVAR(0,0,0)
      IF(NPHASE.GT.1)CALL PHMOVE(-1,JPHASE)
 111  CONTINUE
C
C BE SURE TO PUT THESE IN THE APPROPRIATE "ALL PHASE" OR "ALL SOURCE" LOOPS:
      CALL PFALL9
      CALL EXCPR9
      CALL PREFO9
      CALL LSSCA9
      CALL THMLX9
      CALL ABCPR9
      CALL BACKP9
      CALL ZERPR9
      CALL PCXX9
C
C SET STARTING PHASE & SOURCE:
      JP=0
      JS=0
C
C SCAN ALL VARIABLES:
      DO 1 I=1,LVARV
C UNPACK PARAMETER SPEC:
      CALL KUNPAK(LVRPR(I),IFAM,IGEN,ISPC,JPHASE,JSOURC)
      IF (JPHASE .NE. IPHASE) THEN
        CALL PHMOVE(-1,IPHASE)
        CALL PHMOVE(1,JPHASE)
        CALL LOGPHA(JPHASE)
      ENDIF
       IF ((IFAM .EQ. 3 .OR. IFAM .EQ. 6) .AND. (JS .NE. JSOURC))
     & CALL LOGSOU(JSOURC)
      JP=JPHASE
      JS=JSOURC
C
C BRANCH ON FAMILY:
      GO TO (11,12,13,14,15,16), IFAM
C
C
C FAMILY 1, GENUS 1 - MISCELLANEOUS SINGLY NAMED SPECIES (TFAC, A* ETC,
C EXTN,PROR,SPHA)
  11  GO TO (31,35,35,35,35,35,35,36,37,38,39,39,39) , ISPC
C
C TFAC:
  31  CALL LTFAC8(I)
      GO TO 1
C
C FAMILY 1 GENUS 1 ALSO CONTAINS THE CELL PARAMETERS:
  35  CALL CELVAR(ISPC-1,I)
      GO TO 1
C
C EXTINCTION CORRECTION PARAMETER EXTN:
  36  CALL EXCPR8(I)
      GO TO 1
C
C PREFERRED ORIENTATION:
  37  CALL PREFO8(I)
      GO TO 1
C
C FAMILY 1, GENUS 1, SPECIES 10 - SCALE FOR PHASE, SPHA:
  38  CALL LPSCA8(I)
      GO TO 1
C
C FAMILY 1 GENUS 1, SPECIES 11-13 PROPAGATION VECTOR
   39 CALL PROPAG(-ISPC+10,I)
      GO TO 1
C
C FAMILY 6: MISCELLANEOUS SOURCE DEPENDENT;
  16  GO TO (61,62,63) , IGEN
C
C FAMIL6 GENUS 1 - SINGLY NAMED, SOURCE-DEPENDENT SPECIES (SCAL,TTHM)
  61  GO TO (51,52) , ISPC
C
C FAMILY 6, GENUS 1, SPECIES 1 - SCALE FOR SOURCE, SCAL:
  51  CALL LSSCA8(I)
      GO TO 1
C
C MONOCHROMATOR 2 THETA FOR LX:
  52  CALL THMLX8(I)
      GO TO 1
C
C FAMILY 6, GENUS 2 - ABSC:
  62  CALL ABCPR8(ISPC,I)
      GO TO 1
C
C FAMILY 6, GENUS 3 - BACK:
  63  CALL BACKP8(ISPC,I)
      GO TO 1
C
C FAMILY 2 - THESE ARE ALL TO DO WITH THE STRUCTURE FACTOR:
  12  IF (ISPC .LE. 12) CALL F2VAR8(IGEN,ISPC,I)
      IF ((ISPC .GT. 12) .AND. PHMAG(JPHASE)) CALL MAGVAR(IGEN,ISPC,I)
      GO TO 1
C
C FAMILY 3 - ZERO POINT, PEAK CENTRE AND PEAK FUNCTION PARAMETERS:
C GENUS 1=ZERO POINT, 2=PEAK CENTRE, REST ARE PEAK FUNCTION:
  13  GO TO (41,42) , IGEN
      GO TO 43
C
C ZERO:
  41  CALL ZERPR8(ISPC,I)
      GO TO 1
C
C PEAK CENTRE PARAMETERS DEPEND ON TYPE OF REFINEMENT:
  42  CALL PCXX8(ISPC,I)
      GO TO 1
C
C REMAINING PEAK FUNCTION PARAMETERS:
  43  CALL PFALL8(IGEN,ISPC,I)
      GO TO 1
C
C FAMILY 4 - LONG VECTORS (SO FAR, INTS, SIGS, GAMS . . IN PAWLEY)
  14  CALL FM4PR8(IGEN,ISPC,I)
      GO TO 1
C
C FAMILY 5 ARE MULTIPOLES, EXCLUDED FOR NOW:
  15  GO TO 1
   1  CONTINUE
      IF (NPHASE.GT.1) CALL PHMOVE(-1,IPHASE)
C
 100  RETURN
      END
C
C
C
C
C LEVEL 8      SUBROUTINE VARSD2
      SUBROUTINE VARSD2
C
C *** VARSD2 updated by JCM 23 Mar 92 ***
C
CX
CC 7B
CH Makes variables for 2theta, zero, peak centre and cell for D2 type LSQ
CP Only useful if called from CELLSQ, D2LSQ or similar.  Expects suitable type
CP of Least Squares to be set up.
C
CD First clears all possible parameters for this application to be fixed.
CD Then scans all variables as made by VARMAK, identifies each variable as a
CD type of parameter, and calls individual routines to record the information.
C
/DERVAR/
/IOUNIT/
/POINTS/
/REFINE/
C
      IF (SIMUL) GO TO 100
C SET ALL VARIABLES FIXED:
      CALL THET29
      CALL CELVAR(0,0)
      CALL PCXX9
      CALL ZERPR9
C
C COUNT ALL VARIABLES:
      DO 1 I=1,LVARV
C J=WHICH BASIC VARIABLE:
      J=LVRBS(I)
C KPACK=WHICH PACKED PARAMETER SPEC:
      KPACK=LVRPR(I)
C
C AND ITS FAMILY, GENUS AND SPECIES:
      CALL PUNPAK(KPACK,IFAM,IGEN,ISPC)
C FAMILY 1, GENUS 1 - CELL PARAMETERS:
      IF (IGEN .EQ. 1) THEN
        IF (ISPC .EQ. 7) THEN
          CALL THET28(I)
          GO TO 1
        ENDIF
        CALL CELVAR(ISPC,I)
      ENDIF
C FAMILY 1, GENUS 2 - PKCN PARAMETERS:
      IF (IGEN .EQ. 2) CALL PCXX8(ISPC,I)
C FAMILY 1, GENUS 3 - ZEROPOINT
      IF (IGEN .EQ. 3) CALL ZERPR8(ISPC,I)
C
   1  CONTINUE
 100  RETURN
      END
C
C
C
C
C LEVEL 15      SUBROUTINE VARSPM
      SUBROUTINE VARSPM
C
C *** VARSPM updated by PJB 1 Feb 1994 ***
C
CX
CC 19B
CH Records which parameters are which variables for magnetic PR
C
CD Identifies species of parameter, then calls specific routines actually
CD    to set variables, thus not needing all COMMONs to be explicit here
CD
C
/DERBAS/
/DERVAR/
/GLOBAL/
/IOUNIT/
/PHASE/
/POINTS/
/REFINE/
/REFIPR/
/SOURCE/
C
      IF (SIMUL) GO TO 100
C SET ALL VARIABLES FIXED:
      DO 111 JPHASE=1,NPHASE
      CALL PHMOVE(1,JPHASE)
      CALL LTFAC9
      CALL CELVAR(0,0)
      CALL PROPAG(0,0)
      CALL F2VAR9
      CALL FM4PR9
      CALL LPSCA9
      CALL MAGVAR(0,0,0)
      CALL PHMOVE(-1,JPHASE)
 111  CONTINUE
C
C BE SURE TO PUT THESE IN THE APPROPRIATE "ALL PHASE" OR "ALL SOURCE" LOOPS:
      CALL PFALL9
      CALL EXCPR9
      CALL PREFO9
      CALL LSSCA9
      CALL THMLX9
      CALL ABCPR9
      CALL BACKP9
      CALL ZERPR9
      CALL PCXX9
C
C SET STARTING PHASE & SOURCE:
      JP=0
      JS=0
C
C SCAN ALL VARIABLES:
      DO 1 I=1,LVARV
C UNPACK PARAMETER SPEC:
      CALL KUNPAK(LVRPR(I),IFAM,IGEN,ISPC,JPHASE,JSOURC)
      IF (JPHASE .NE. IPHASE) THEN
        CALL PHMOVE(-1,IPHASE)
        CALL PHMOVE(1,JPHASE)
        CALL LOGPHA(JPHASE)
      ENDIF
       IF ((IFAM .EQ. 3 .OR. IFAM .EQ. 6) .AND. (JS .NE. JSOURC))
     & CALL LOGSOU(JSOURC)
      JP=JPHASE
      JS=JSOURC
C
C BRANCH ON FAMILY:
      GO TO (11,12,13,14,15,16), IFAM
C
C
C FAMILY 1, GENUS 1 - MISCELLANEOUS SINGLY NAMED SPECIES (TFAC, A* ETC,
C EXTN,PROR,SPHA)
  11  GO TO (31,35,35,35,35,35,35,36,37,38,39,39,39) , ISPC
C
C TFAC:
  31  CALL LTFAC8(I)
      GO TO 1
C
C FAMILY 1 GENUS 1 ALSO CONTAINS THE CELL PARAMETERS:
  35  CALL CELVAR(ISPC-1,I)
      GO TO 1
C
C EXTINCTION CORRECTION PARAMETER EXTN:
  36  CALL EXCPR8(I)
      GO TO 1
C
C PREFERRED ORIENTATION:
  37  CALL PREFO8(I)
      GO TO 1
C
C FAMILY 1, GENUS 1, SPECIES 10 - SCALE FOR PHASE, SPHA:
  38  CALL LPSCA8(I)
      GO TO 1
C
C FAMILY 1 GENUS 1, SPECIES 11-13 PROPAGATION VECTOR
   39 CALL PROPAG(-ISPC+10,I)
      GO TO 1
C
C FAMILY 6: MISCELLANEOUS SOURCE DEPENDENT;
  16  GO TO (61,62,63) , IGEN
C
C FAMIL6 GENUS 1 - SINGLY NAMED, SOURCE-DEPENDENT SPECIES (SCAL,TTHM)
  61  GO TO (51,52) , ISPC
C
C FAMILY 6, GENUS 1, SPECIES 1 - SCALE FOR SOURCE, SCAL:
  51  CALL LSSCA8(I)
      GO TO 1
C
C MONOCHROMATOR 2 THETA FOR LX:
  52  CALL THMLX8(I)
      GO TO 1
C
C FAMILY 6, GENUS 2 - ABSC:
  62  CALL ABCPR8(ISPC,I)
      GO TO 1
C
C FAMILY 6, GENUS 3 - BACK:
  63  CALL BACKP8(ISPC,I)
      GO TO 1
C
C FAMILY 2 - THESE ARE ALL TO DO WITH THE STRUCTURE FACTOR:
  12  IF (ISPC .LE. 12) CALL F2VAR8(IGEN,ISPC,I)
      IF (ISPC .GT. 12) CALL MAGVAR(IGEN,ISPC,I)
      GO TO 1
C
C FAMILY 3 - ZERO POINT, PEAK CENTRE AND PEAK FUNCTION PARAMETERS:
C GENUS 1=ZERO POINT, 2=PEAK CENTRE, REST ARE PEAK FUNCTION:
  13  GO TO (41,42) , IGEN
      GO TO 43
C
C ZERO:
  41  CALL ZERPR8(ISPC,I)
      GO TO 1
C
C PEAK CENTRE PARAMETERS DEPEND ON TYPE OF REFINEMENT:
  42  CALL PCXX8(ISPC,I)
      GO TO 1
C
C REMAINING PEAK FUNCTION PARAMETERS:
  43  CALL PFALL8(IGEN,ISPC,I)
      GO TO 1
C
C FAMILY 4 - LONG VECTORS (SO FAR, INTS, SIGS, GAMS . . IN PAWLEY)
  14  CALL FM4PR8(IGEN,ISPC,I)
      GO TO 1
C
C FAMILY 5 ARE MULTIPOLES, EXCLUDED FOR NOW:
  15  GO TO 1
   1  CONTINUE
      IF (MULFAS) CALL PHMOVE(-1,IPHASE)
C
 100  RETURN
      END
C
C
C
C
C LEVEL 10      SUBROUTINE VARSPR
      SUBROUTINE VARSPR
C
C *** VARSPR by JCM 7 Dec 90 ***
C
CX
CC 19B
CH Records which parameters are which variables for PR
C
CD Identifies species of parameter, then calls specific routines actually
CD    to set variables, thus not needing all COMMONs to be explicit here
CD
CN This exists separately from VARSPM, magnetic.  The other places where we
CN need the distinction, a function name MAGxxx is used as an argument.  But
CN this is called from VARMAK, and at present it is easier done this way.
C
/DERBAS/
/DERVAR/
/GLOBAL/
/IOUNIT/
/PHASE/
/POINTS/
/REFINE/
/REFIPR/
/SOURCE/
C
      IF (SIMUL) GO TO 100
C SET ALL VARIABLES FIXED:
      DO 111 JPHASE=1,NPHASE
      CALL PHMOVE(1,JPHASE)
      CALL LTFAC9
      CALL CELVAR(0,0)
      CALL F2VAR9
      CALL FM4PR9
      CALL LPSCA9
      CALL PHMOVE(-1,JPHASE)
 111  CONTINUE
C
C BE SURE TO PUT THESE IN THE APPROPRIATE "ALL PHASE" OR "ALL SOURCE" LOOPS:
      CALL PFALL9
      CALL EXCPR9
      CALL PREFO9
      CALL LSSCA9
      CALL THMLX9
      CALL ABCPR9
      CALL BACKP9
      CALL ZERPR9
      CALL PCXX9
C
C SET STARTING PHASE & SOURCE:
      JP=0
      JS=0
C
C SCAN ALL VARIABLES:
      DO 1 I=1,LVARV
C UNPACK PARAMETER SPEC:
      CALL KUNPAK(LVRPR(I),IFAM,IGEN,ISPC,JPHASE,JSOURC)
      IF (JPHASE .NE. IPHASE) THEN
        CALL PHMOVE(-1,IPHASE)
        CALL PHMOVE(1,JPHASE)
        CALL LOGPHA(JPHASE)
      ENDIF
       IF ((IFAM .EQ. 3 .OR. IFAM .EQ. 6) .AND. (JS .NE. JSOURC))
     & CALL LOGSOU(JSOURC)
      JP=JPHASE
      JS=JSOURC
C
C BRANCH ON FAMILY:
      GO TO (11,12,13,14,15,16), IFAM
C
C
C FAMILY 1, GENUS 1 - MISCELLANEOUS SINGLY NAMED SPECIES (TFAC, A* ETC,
C EXTN,PROR,SPHA)
  11  GO TO (31,35,35,35,35,35,35,36,37,38) , ISPC
C
C TFAC:
  31  CALL LTFAC8(I)
      GO TO 1
C
C FAMILY 1 GENUS 1 ALSO CONTAINS THE CELL PARAMETERS:
  35  CALL CELVAR(ISPC-1,I)
      GO TO 1
C
C EXTINCTION CORRECTION PARAMETER EXTN:
  36  CALL EXCPR8(I)
      GO TO 1
C
C PREFERRED ORIENTATION:
  37  CALL PREFO8(I)
      GO TO 1
C
C FAMILY 1, GENUS 1, SPECIES 10 - SCALE FOR PHASE, SPHA:
  38  CALL LPSCA8(I)
      GO TO 1
C
C FAMILY 6: MISCELLANEOUS SOURCE DEPENDENT;
  16  GO TO (61,62,63) , IGEN
C
C FAMIL6 GENUS 1 - SINGLY NAMED, SOURCE-DEPENDENT SPECIES (SCAL,TTHM)
  61  GO TO (51,52) , ISPC
C
C FAMILY 6, GENUS 1, SPECIES 1 - SCALE FOR SOURCE, SCAL:
  51  CALL LSSCA8(I)
      GO TO 1
C
C MONOCHROMATOR 2 THETA FOR LX:
  52  CALL THMLX8(I)
      GO TO 1
C
C FAMILY 6, GENUS 2 - ABSC:
  62  CALL ABCPR8(ISPC,I)
      GO TO 1
C
C FAMILY 6, GENUS 3 - BACK:
  63  CALL BACKP8(ISPC,I)
      GO TO 1
C
C FAMILY 2 - THESE ARE ALL TO DO WITH THE STRUCTURE FACTOR:
  12  IF (ISPC .LE. 12) CALL F2VAR8(IGEN,ISPC,I)
      GO TO 1
C
C FAMILY 3 - ZERO POINT, PEAK CENTRE AND PEAK FUNCTION PARAMETERS:
C GENUS 1=ZERO POINT, 2=PEAK CENTRE, REST ARE PEAK FUNCTION:
  13  GO TO (41,42) , IGEN
      GO TO 43
C
C ZERO:
  41  CALL ZERPR8(ISPC,I)
      GO TO 1
C
C PEAK CENTRE PARAMETERS DEPEND ON TYPE OF REFINEMENT:
  42  CALL PCXX8(ISPC,I)
      GO TO 1
C
C REMAINING PEAK FUNCTION PARAMETERS:
  43  CALL PFALL8(IGEN,ISPC,I)
      GO TO 1
C
C FAMILY 4 - LONG VECTORS (SO FAR, INTS, SIGS, GAMS . . IN PAWLEY)
  14  CALL FM4PR8(IGEN,ISPC,I)
      GO TO 1
C
C FAMILY 5 ARE MULTIPOLES, EXCLUDED FOR NOW:
  15  GO TO 1
   1  CONTINUE
      IF (MULFAS) CALL PHMOVE(-1,IPHASE)
C
 100  RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE VCSWOP(N1,N2,J)
      SUBROUTINE VCSWOP(N1,N2,J)
C
C *** VCSWOP BY JCM 3 FEB 88 ***
C
CX
CC 12C
CH Swops 2 integer vectors
CA On entry N1 and N2 are integer vectors each of length at least J
CA On exit their elements have been interchanged from  1 to J
C
      DIMENSION N1(J),N2(J)
C
      DO 1 I=1,J
      NTEMP=N1(I)
      N1(I)=N2(I)
      N2(I)=NTEMP
   1  CONTINUE
      RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE WRDATA(EOD,IUNIT,IVAL,N)
      SUBROUTINE WRDATA(EOD,IUNIT,IVAL,N)
      PARAMETER (NBLCKS=128)
C  Routine to write out fixed length blocks(NBLCKS integers) to a file
C  It accepts an array of values and splits it into blocks. Whenever part
C  of a block is left over it is stored for blocking at a later run of
C  the routine. To clear  out the block at the end of a file a flag,EOD should
C  be set to .TRUE.
C
C  input parameters:
C      EOD      logical, .TRUE. if this is the last record, otherwise .FALSE.
C      IUNIT      unit number to write to
C      IVAL      array containing data
C      N      number of values to be written
      LOGICAL EOD
      DIMENSION IVAL(1),IWORK(NBLCKS)
C ensure IWORK cleared to start with and point to start of IWORK
C THIS SHOULD REALLY BE COMMON:
      DATA IWORK/NBLCKS*0/,INEXT/1/
C
C
C  calculate total number of values to be written
      ILEFT=N
      ITOT=ILEFT+INEXT-1
C
C  if at least 1 block then write out as many whole blocks as possible
      IF (ITOT.GT.NBLCKS) THEN
C  First block is probably part IWORK, part IVAL
        IPART=NBLCKS+1-INEXT
        WRITE(IUNIT) (IWORK(I),I=1,INEXT-1),(IVAL(I),I=1,IPART)
        ITOT=ITOT-NBLCKS
C  next blocks are all wholly IVAL
        NBLOCK=ITOT/NBLCKS
        IF (NBLOCK.GT.0) THEN
          DO 10 I=1,NBLOCK
          WRITE(IUNIT) (IVAL(IPART+(I-1)*NBLCKS+J),
     +                                    J=1,NBLCKS)
 10       CONTINUE
        ENDIF
C  then at the end there are probably a few values left over
        ILEFT=ITOT-NBLOCK*NBLCKS
        INEXT=1
      ENDIF
C  transfer the left overs into the temporary work space and save for next time
      IF (ILEFT.GT.0) THEN
        DO 20 I=1,ILEFT
        IWORK(I+INEXT-1)=IVAL(N-ILEFT+I)
 20     CONTINUE
        INEXT=INEXT+ILEFT
      ENDIF
C  However if I've been told that this is the last block of this file
C  clear it out totally, providing there is something to clear out!
      IF (EOD.AND.INEXT.GT.1) THEN
        WRITE(IUNIT)(IWORK(I),I=1,INEXT-1)
        INEXT=1
      ENDIF
      RETURN
      END
C
C
C
C
C LEVEL 2      SUBROUTINE WRINST(N)
      SUBROUTINE WRINST(N)
C
C *** WRINST by JCM 13 Aug 91 ***
C
CH Set and write first 155 elements of IWORK, instument parameters etc,
CH for TIC & PICTIC
CA On entry N=no. of points to set in IWORK(55)
C
/FCCDAT/
/FOCDAT/
      COMMON /WORKG/IWORK(256)
      REAL RWORK(256)
      CHARACTER*1024 CWORK
C NON-STANDARD FORTRAN 77:
CS LAX      EQUIVALENCE (IWORK,CWORK),(IWORK,RWORK)
C
      IWORK(1)        = NCYMIN
      IWORK(2)        = NCYMAX
      RWORK(3)        = DELTA
      IWORK(4)        = LDFIL
      CWORK(17:96)    = DATFIL
      RWORK(25)       = FI
      IWORK(26)       = INSTCO
      CWORK(105:112)  = INSTNM
      IWORK(29)       = INSTST
      IWORK(30)       = NXCODE
      IWORK(31)       = LNPDFN
      RWORK(32)       = AL1
      RWORK(33)       = AL2
      CWORK(133:212)  = LONGTI
      IWORK(54)       = 1
C N SET AS INPUT ARGUMENT:
      IWORK(55)       = N
      IWORK(56)       = NUMRUN
      CWORK(225:244)  = RUNUSR
      RWORK(62)       = RUNDUR
      CWORK(249:268)  = STTIME
      RWORK(68)       = TTHET
      CWORK(273:472)  = WSHIST
      RWORK(119)      = XMN
      RWORK(120)      = XMX
      RWORK(121)      = YMN
      RWORK(122)      = YMX
** NOW RELYING ON CAPTS SET OUTSIDE
      CWORK(489:528)  = XCAPT
      CWORK(529:568)  = YCAPT
      CWORK(569:608)  = MCAPT
      IWORK(153)      = NYCODE
      IWORK(154)      = NEMODE
      IWORK(155)      = EFIXED
C
C      WRITE THIS DATA TO FILE
C
      CALL WRDATA(.FALSE.,IUNIT,IWORK,155)
      RETURN
      END
C
C
C
C
C LEVEL 5      SUBROUTINE WRIPIC
      SUBROUTINE WRIPIC
C
C      SUBROUTINE TO WRITE A CORRECTLY FORMATTED GENIE INTERMEDIATE FILE
C
/FCCDAT/
/FOCDAT/
/REFINE/
/REFIPR/
/SCRACH/
C
      COMMON /WORKG/IWORK(256)
      REAL RWORK(256)
      CHARACTER*1024 CWORK
C NON-STANDARD FORTRAN 77:
CS LAX      EQUIVALENCE (IWORK,CWORK),(IWORK,RWORK)
C
C      OPEN THE DATA FILE AND FILL THE FIRST 91 PARAMETERS.
C
      MESSAG='PICTIC file'
      IUNIT=NOPFIL(21212)
C
      NTCB=NPT+1
      CALL WRSTRT(NTCB,3)
C
C      WRITE USER PARAMETERS (NOTHING )
      CALL WRDATA(.FALSE.,IUNIT,USERPR,30)
C
C SET & WRITE INITIAL INSTRUMENT PARAMETERS ETC TO FILE:
      CALL WRINST(NPT)
C
C      NOW WRITE RTCB, RCOUNT AND RERR ARRAYS TO DATA FILE
      CALL WRDATA(.FALSE.,IUNIT,TDATA,NTCB)
      CALL WRDATA(.FALSE.,IUNIT,OBSDAT,NTCB)
      CALL WRDATA(.FALSE.,IUNIT,ERR,NTCB)
C
C      WRITE USER PARAMETERS (NOTHING )
      CALL WRDATA(.FALSE.,IUNIT,USERPR,30)
C
C      WRITE INSTRUMENT PARAMETERS ETC. TO FILE.
      CALL LIMITS(CALDAT,NPT,NCYMIN,NCYMAX,YMN,YMX)
      IWORK(1)      = NCYMIN
      IWORK(2)      = NCYMAX
      IWORK(54)     = 2
** THIS WAS:
**      RWORK(119)    = XMN
**      RWORK(120)    = XMX
      RWORK(121)=YMN
      RWORK(122)=YMX
C
C      WRITE THIS DATA TO FILE
      CALL WRDATA(.FALSE.,IUNIT,IWORK,155)
C
C      NOW WRITE RTCB, RCOUNT AND RERR ARRAYS TO DATA FILE
      CALL WRDATA(.FALSE.,IUNIT,TDATA,NTCB)
      CALL WRDATA(.FALSE.,IUNIT,CALDAT,NTCB)
      CALL WRDATA(.FALSE.,IUNIT,ERR,NTCB)
C
C      WRITE USER PARAMETERS (NOTHING )
      CALL WRDATA(.FALSE.,IUNIT,USERPR,30)
C
C      WRITE INSTRUMENT PARAMETERS ETC. TO FILE.
      CALL LIMITS(STADAT,NPT,NCYMIN,NCYMAX,YMN,YMX)
      IWORK(1)      = NCYMIN
      IWORK(2)      = NCYMAX
      IWORK(54)     = 3
      RWORK(121)    = YMN
      RWORK(122)    = YMX
      CWORK(529:568)= '(OBS-CALC)/ESD'
      CWORK(569:608)= '(OBS-CALC)/ESD'
C
C      WRITE THIS DATA TO FILE
      CALL WRDATA(.FALSE.,IUNIT,IWORK,155)
C
C      NOW WRITE RTCB, RCOUNT AND RERR ARRAYS TO DATA FILE
      CALL WRDATA(.FALSE.,IUNIT,TDATA,NTCB)
      CALL WRDATA(.FALSE.,IUNIT,STADAT,NTCB)
      CALL WRDATA(.FALSE.,IUNIT,ERR,NTCB)
C
C      NOW ENSURE THAT FILE IS CLOSED PROPERLY
      CALL WRDATA(.TRUE.,IUNIT,IWORK,0)
      RETURN
      END
C
C
C
C
C LEVEL 5      SUBROUTINE WRITIC
      SUBROUTINE WRITIC
C
C *** WRITIC updated by JCM 28 Dec 92 ***
C
C      SUBROUTINE TO WRITE A CORRECTLY FORMATTED GENIE INTERMEDIATE FILE
C
/FCCDAT/
/FOCDAT/
/REFINE/
/REFIPR/
/REFLNS/
%      COMMON /SCRAT/IH(3),H(3),TEMREF(3,%REFS%),IORDER(%REFS%),
%     & TEMMUL(%REFS%),ARG(%REFS%),TF4P(6,%REFS%),TEMP(6),
%     & ARGN(%REFS%),ANT(%REFS%),EINT(%REFS%)
C
/SCRACH/
/WHEN/
C
      COMMON /WORKG/IWORK(256)
      REAL RWORK(256)
      CHARACTER*1024 CWORK
C NON-STANDARD FORTRAN 77:
CS LAX      EQUIVALENCE (IWORK,CWORK),(IWORK,RWORK)
C
C      OPEN THE DATA FILE AND FILL THE FIRST 91 PARAMETERS.
C
      MESSAG='TIC file'
      IUNIT=NOPFIL(21212)
C
      NTCB=MAXK+1
C
      CALL WRSTRT(NTCB,1)
C
C      WRITE USER PARAMETERS (NOTHING )
      CALL WRDATA(.FALSE.,IUNIT,USERPR,30)
C
C SET UP WHAT DIFFERS FROM THE TIC CALL OF WRINST:
      AINTMX=0.
      NCYMIN=1
      NCYMAX=MAXK
      DO 2 I=1,MAXK
      AINTMX=AMAX1(AINTMX,ANT(I))
** BEWARE IF ANY NEW MAIN PROGRAMS ARE WRITTEN IN THE TIC/PICTIC AREA:
      IF (MAIN .EQ. 'TIC') EINT(I) = 0.2*ANT(I)
   2  CONTINUE
C COMPLAIN ON ALL ZERO (OR -VE) INTS:
      IF (AINTMX .EQ. 0.) CALL ERRMES(1,0,
     & 'no positive integrated intensities')
      YMN=0.
      IF (MAIN .EQ. 'PICTIC') THEN
        YMX=0.20*YRANGE
        ATEM=0.20*YRANGE/AINTMX
        DO 3 I=1,MAXK
        ANT(I)=ATEM*ANT(I)
        EINT(I)=0.20*ANT(I)
   3    CONTINUE
      ELSE
        YMX=AINTMX
      ENDIF
C
C SET & WRITE INITIAL INSTRUMENT PARAMETERS ETC TO FILE:
      CALL WRINST(MAXK)
C
C      NOW WRITE RTCB, RCOUNT AND RERR ARRAYS TO DATA FILE
      CALL WRDATA(.FALSE.,IUNIT,ARGN,NTCB)
      CALL WRDATA(.FALSE.,IUNIT,ANT,NTCB)
      CALL WRDATA(.FALSE.,IUNIT,EINT,NTCB)
C
C      NOW ENSURE THAT FILE IS CLOSED PROPERLY
      CALL WRDATA(.TRUE.,IUNIT,IWORK,0)
      RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE WRLINE(N1,LEN,CHAR,N2)
      SUBROUTINE WRLINE(N1,LEN,CHAR,N2)
C
C *** WRLINE by JCM 31 Jan 91 ***
C
CX
CH Writes a line of a specified character to unit LPT
CA On entry N1 is the number of empty lines required before.
CA          LEN is the required line length
CA          CHAR is the *1 character to be repeated
CA          N2 is the number of empty lines required after.
CO Writes LEN copies of CHAR to unit LPT
C
      CHARACTER *1 CHAR
/IOUNIT/
C
      DO 1 I=1,N1
      WRITE(LPT,2001)
2001  FORMAT(1X)
   1  CONTINUE
C
      WRITE (LPT,2000) (CHAR,I=1,LEN)
2000  FORMAT (1X,120A1)
C
      DO 2 I=1,N2
      WRITE(LPT,2001)
   2  CONTINUE
      RETURN
      END
C
C
C
C
C LEVEL 2      SUBROUTINE WRSTRT(N,NS)
      SUBROUTINE WRSTRT(N,NS)
C
C *** WRSTRT
C
CH Write start of Genie file
CA On entry N= no. of X, Y, or E values
CA          NS= number of spectra (1 for TIC, 3 for PICTIC)
C
      COMMON /WORKG/IWORK(256)
      REAL RWORK(256)
      CHARACTER*1024 CWORK
C NON-STANDARD FORTRAN 77:
CS LAX      EQUIVALENCE (IWORK,CWORK),(IWORK,RWORK)
C
C
      CWORK(1:80)    = ' '
C VERSION:
      IWORK(21)      = 1
C ADDRESS OF HISTORY SECTION (NONE):
      IWORK(22)      = 42
C ADDRESS OF DETECTOR SECTION:
      IWORK(23)      = 0
C ADDRESS OF X VALUES SECTION:
      IWORK(24)      = 0
C ADDRESS OF SPECTRA SECTION
      IWORK(25)      = 92
C NO OF SPECTRA (TIC MARKS)
      IWORK(26)      = NS
C LENGTH OF P BLOCK (GENIE HDR1+HDR2)
      IWORK(27)      = 155+30
C LENGTH OF X BLOCK
      IWORK(28)      = N
C LENGTH OF Y BLOCK
      IWORK(29)      = N
C LENGTH OF E BLOCK
      IWORK(30)      = N
C IWORK(31-41) LENGTHS OF U1-U11 BLOCKS
      DO 1 I=31,41
   1  IWORK(I)=0
C COMMON HISTORY BLANK SO FAR:
      CWORK(165:364) = ' '
C
C      WRITE THESE PARAMETERS TO THE FILE
      CALL WRDATA(.FALSE.,IUNIT,IWORK,91)
C
      RETURN
      END
C
C
C
C
C LEVEL 6      SUBROUTINE ZEROPR(N)
      SUBROUTINE ZEROPR(N)
C
C *** ZEROPR by JCM 9 May 88 ***
C
C MULTIPLE ENTRY ROUTINE DEALING WITH ALL ASPECTS OF ZERO POINT(S)
C
C ENTRY 2 ('USE') IS SO SIMPLE THAT IT IS EXPECTED TO BE DONE IN THE CALLING
C ROUTINE, E.G. CALTF1
C
/IOUNIT/
/NEWOLD/
/PHASE/
/PRZERO/
/SOURCE/
C
      GO TO (1,2,3,4) , N
C
C GIVEN AN 'L ZERO' CARD IN COMM0N /SCRACH/, READ REST OF IT:
C 90.10 IN ZEROPR; READ zero's to KSOURC, rather that JSOURC
   1  CALL RDREAL (ZEROSP(1,1,KSOURC),7,IPT,80,IER)
      WRITE (LPT,2000) ZEROSP(1,1,KSOURC)
2000  FORMAT (/' Zero point =',F10.4)
      NZERSP(1,KSOURC)=1
      IF (NPHASE.GT.1) THEN
        DO 11 I=2,NPHASE
        ZEROSP(1,I,KSOURC)=ZEROSP(1,1,KSOURC)
   11 CONTINUE
      ENDIF
      GO TO 100
C
C ENTRY 2 DUMMY - DONE IN CALL TO PCTF1:
   2  GO TO 100
C
C APPLY SHIFT IN COEFFICIENT:
   3  CALL ADJUST(ZEROSP(ISPC,JPHASE,JSOURC))
      GO TO 100
C
C WRITE OUT NEW 'L ZERO' CARD FOR TOF:
   4  WRITE (NEWIN,2001) ZEROSP(1,JPHASE,JSOURC)
2001  FORMAT ('L ZERO',F10.4)
      GO TO 100
C
C
      ENTRY ZERPR8(NP,NV)
C SET PARAMETER NP TO BE VARIABLE NV
      KZROSP(NP,JPHASE,JSOURC)=NV
      GO TO 100
C
C
      ENTRY ZERPR9
C SET ALL ZEROPOINT PARAMETERS FIXED:
      DO 9 I=1,NZERSP(JPHASE,JSOURC)
   9  KZROSP(I,JPHASE,JSOURC)=0
      GO TO 100
C
 100  RETURN
      END
##ENDPR
##PF
C *** Version from JPW and JBF 21-Mar-2001  ***
C
C                  P E A K   F U N C T I O N   A N D
C               R E L A T E D   S U B R O U T I N E S
C            F O R   P R O F I L E   R E F I N E M E N T
C
C
C
C
C LEVEL 1      SUBROUTINE FCSUB3(MNS)
      SUBROUTINE FCSUB3(MNS)
C
C
CX   For use with PFCN03 constant wavelength data with finite detector height
CC 19B
CH
      LOGICAL NEAR90
      COMPLEX CFFT,DFFT,DDT,CFF
/CONSTA/
/PHASE/
/PRPKCN/
/PRPKFN/
/PRSAVF/
/REFLNS/
/SOURCE/
      DIMENSION CFFT(8),DFFT(8),DDT(8),
%     1FR(%FFT2%,8),FI(%FFT2%,8),DR(%FFT2%,8),DI(%FFT2%,8),
%     2FRE(%FFT2%),FIE(%FFT2%),FRT(%FFT2%),FIT(%FFT2%)
C
      SIG= PKFNVA(1)
      GAM= PKFNVA(2)
      HPS= PKFNVA(3)
      HMS= PKFNVA(4)
C
      DENTEM=(FLOAT(MNS)*XPKDEL(KMOD))
      C2TEM= PI/DENTEM
      CTEM=  2.*C2TEM
      GTEM=  CTEM*SIG
      CLTEM= C2TEM*GAM
C.. TO DEAL WITH (A) 90 DEGREES AND (B) ABOVE ALL WE WILL DO IS
C.. (A) SET FR(I,3)=1 AND ALL ELSE TO ZERO AND
C.. (B) SWITCH THE SIGN OF THE IMAGINARY COMPONENTS
      NEAR90=(ABS(ARGK-90.).LT.2.0)
      IF(.NOT.NEAR90) THEN
        TANRA= ABS(TAN(RAD*ARGK))
        DENASY=0.5*(HPS-HMS)*(HPS+HMS)
C.. BET1 AND NETPI CHANGE SIGN AT 90 DEGREES
C.. BET2, BETP, BETM, BETP2 AND BETM2 DO NOT
        BET1=0.5*RAD*DENTEM*TANRA
        BET2=SQRT(BET1)
        BETP=HPS/BET2
        BETM=HMS/BET2
        BETP2=PIBY2*BETP*BETP
        BETM2=PIBY2*BETM*BETM
        BETPI=BET1/PI
      END IF
C
      MN2=MNS/2
      MN2M1= MN2-1
      MN2P1= MN2+1
      DO 1 I=1,MNS
        II=MOD(I+MN2,MNS)-MN2P1
C.. GAUSSIAN
        ARG= GTEM*FLOAT(II)
        FR(I,1)= EXP((-0.5)*ARG*ARG)
        FI(I,1)= 0.
        DR(I,1)= -ARG*ARG*FR(I,1)/SIG
        DI(I,1)= 0.
C.. LORENTZIAN
        AFII= ABS(FLOAT(II))
        ARG= CLTEM*AFII
        FR(I,2)= EXP(-ARG)
        FI(I,2)= 0.
        DR(I,2)= -C2TEM*AFII*FR(I,2)
        DI(I,2)= 0.
C.. ASYMMETRY FUNCTION FOR UMBRELLA EFFECT
      IF (II.EQ.0..OR.NEAR90) THEN
          FR(I,3)=1.
          DR(I,3)=0.
          DR(I,4)=0.
          FI(I,3)=0.
          DI(I,3)=0.
          DI(I,4)=0.
      ELSE
          SII=SQRT(AFII)
          VAL=FLOAT(II)
          SVAL=SII/VAL
          ARGP1= BETP*SII
          ARGM1= BETM*SII
          CALL FRENEL(ARGP1,FRCP,FRSP)
          CALL FRENEL(ARGM1,FRCM,FRSM)
          FRCP=FRCP*BET2/SII
          FRSP=FRSP*BET2*SVAL
          FRCM=FRCM*BET2/SII
          FRSM=FRSM*BET2*SVAL
          BETPK=BETPI/VAL
          SINP=SIN(BETP2*VAL)
          SINM=SIN(BETM2*VAL)
          COSP=COS(BETP2*VAL)
          COSM=COS(BETM2*VAL)
C.. BET1 AND BETPI CHANGE SIGN AT 90 DEGREES
C.. BET2, BETP, BETM, BETP2 AND BETM2 DO NOT
C
          FR(I,3)=((HPS*FRCP-HMS*FRCM)-BETPK*(SINP-SINM))/DENASY
          FI(I,3)=-((HPS*FRSP-HMS*FRSM)+BETPK*(COSP-COSM))/DENASY
          DR(I,3)= (FRCP-HPS*FR(I,3))/DENASY
          DI(I,3)= -(FRSP-HPS*FI(I,3))/DENASY
          DR(I,4)= (HMS*FR(I,3)-FRCM)/DENASY
          DI(I,4)= -(HMS*FI(I,3)-FRSM)/DENASY
          IF (ARGK.GT.90.) THEN
            FI(I,3)=-FI(I,3)
            DI(I,3)=-DI(I,3)
            DI(I,4)=-DI(I,4)
          END IF
      END IF
   1  CONTINUE
C
C.. NOW FORM PRODUCTS IN FOURIER SPACE
      DO 2 I=1,MNS
       DO 3 J=1,NPKGEN(JPHASE,JSOURC)
        IF(J.NE.4) CFFT(J)=CMPLX(FR(I,J),FI(I,J))
        DFFT(J)=CMPLX(DR(I,J),DI(I,J))
   3  CONTINUE
        DDT(1)=DFFT(1)*CFFT(2)*CFFT(3)
        DDT(2)=DFFT(2)*CFFT(1)*CFFT(3)
        DDT(3)=DFFT(3)*CFFT(1)*CFFT(2)
        DDT(4)=DFFT(4)*CFFT(1)*CFFT(2)
        DO 4 J=1,NPKGEN(JPHASE,JSOURC)
         DR(I,J)=REAL(DDT(J))
         DI(I,J)=AIMAG(DDT(J))
   4  CONTINUE
        CFF=CFFT(1)*CFFT(2)*CFFT(3)
        FRT(I)=REAL(CFF)
        FIT(I)=AIMAG(CFF)
   2  CONTINUE
C
C.. DO INVERSE TRANSFORMS OF FUNCTION AND DERIVATIVES
      INV=1
      CALL FT01A(MNS,INV,FRT,FIT)
C
      DO 5 J=1,NPKGEN(JPHASE,JSOURC)
   5   CALL FT01A(MNS,INV,DR(1,J),DI(1,J))
C.. WRITE FUNCTION AND DERIVATIVES TO ARRAY PKADD
      XTEM=1./XPKDEL(KMOD)
      DO 6 I=1,MNS
      II=MOD(I+MN2M1,MNS)+1
      PKADD(II,1)=FRT(I)*XTEM
      DO 7 J=1,NPKGEN(JPHASE,JSOURC)
      JJ=J+1
      PKADD(II,JJ)=DR(I,J)*XTEM
   7  CONTINUE
   6  CONTINUE
C
      RETURN
      END
C
C
C
C
C LEVEL 2      SUBROUTINE FDCN01(IOPT)
      SUBROUTINE FDCN01(IOPT)
C
C  *** FDCN01 updated by JCM/WIFD 2 Mar 89 ***
C
CX
CC 19B
CH Function descriptors for constant wavelength, with derivatives
CA On entry IOPT=1 if only function descriptors are required
CA               2 if both descriptors and derivatives are required
CP Expects ARGK in /PRPKCN to hold 2thetaK degrees, and the peak
CP function species values in PKFNSP in /PRPKFN to have been read by
CP calls of PFCN0x
C
CD Used when CN, constant wavelength
CD Simple Gaussian, Cagliotti width variation
CD If SAPS and KNOW points to a reflection for which SIGS  is
CD being refined, uses value in F4PAR(2 instead of calculated value.
C
/CONSTA/
/DGEOM/
/F4PARS/
/PHASE/
/POINTS/
/PRPKCN/
/PRPKFN/
/REFINE/
/REFIPR/
/REFLNS/
/SOURCE/
C
C WE DO NOT WANT THE CALCULATION IF:
C  A) SAPS, AND
C  B) IT IS NOT THE SPECIAL INITIAL CYCLE, AND
C  C) WE ARE REFINING THIS SIGMA:
      TANTH=TAN(RAD*ARGK/2.)
      PKFNVA(1)=(PKFNSP(1,1,JPHASE,JSOURC)*TANTH+PKFNSP(1,2,
     & JPHASE,JSOURC))*TANTH+PKFNSP(1,3,JPHASE,JSOURC)
      IF (SAPS .OR. APES) THEN
        IF (PRECYC) THEN
          F4PAR(2,KNOW)=PKFNVA(1)
        ELSE
          IF (KF4PAR(2,KNOW) .GT. 0) PKFNVA(1)=F4PAR(2,KNOW)
        ENDIF
      ENDIF
      IF (IOPT .EQ. 1) GO TO 100
C
C DERIVATIVES OF PKFNVA(1) WRT THE 3 PKFNSP PARAMETERS
      DERPFN(1,1)=TANTH*TANTH
      DERPFN(1,2)=TANTH
      DERPFN(1,3)=1.
100   RETURN
      END
C
C
C
C
C LEVEL 2      SUBROUTINE FDCN03(IOPT)
      SUBROUTINE FDCN03(IOPT)
C
C
CX
CC 19B
CH Function descriptors for constant wavelength data with derivatives
CA On entry IOPT=1 if only function descriptors are required
CA               2 if both descriptors and derivatives are required
CP Expects ARGK in /PRPKCN to hold 2thetaK degrees, and the peak
CP function species values in PKFNSP in /PRPKFN to have been read by
CP calls of PFCN0x
C
CD Used with constant wavelength neutron or synchrotron radiation.
CD Voigt folded with VL&Y peak shape asymmetry
CD If SAPS and KNOW points to a reflection for which SIGS is
CD being refined, uses value in F4PAR(2) instead of calculated value.
C
/CONSTA/
/DGEOM/
/F4PARS/
/PHASE/
/POINTS/
/PRPKCN/
/PRPKFN/
/REFINE/
/REFIPR/
/REFLNS/
/SOURCE/
C
C For the moment, same variable names as TOF case...
C
C WE DO NOT WANT THE CALCULATION IF:
C  A) SAPS, AND
C  B) IT IS NOT THE SPECIAL INITIAL CYCLE, AND
C  C) WE ARE REFINING THIS PEAK VARIABLE:
      TANTH=TAN(RAD*ARGK/2.)
C.. SIGMA=SQRT(U**2 * ( TANTH - V )**2 + W*W)
C.. V=TAN(TH(MIN)) W=SIGMA(MIN)
      SIGU=PKFNSP(1,1,JPHASE,JSOURC)
      SIGV=PKFNSP(1,2,JPHASE,JSOURC)
      SIGW=PKFNSP(1,3,JPHASE,JSOURC)
      TANDIF=(TANTH-SIGV)
      SIGMA=SQRT((TANDIF*SIGU)**2+SIGW**2)
      PKFNVA(1)=SIGMA
      SECTH=SQRT(1. + TANTH*TANTH)
      PKFNVA(2)=PKFNSP(2,1,JPHASE,JSOURC)*SECTH+
     & PKFNSP(2,2,JPHASE,JSOURC)*TANTH
      PKFNVA(3)=PKFNSP(3,1,JPHASE,JSOURC)
      PKFNVA(4)=PKFNSP(4,1,JPHASE,JSOURC)
      IF (SAPS .OR. APES) THEN
        IF (PRECYC) THEN
          F4PAR(2,KNOW)=PKFNVA(1)
          F4PAR(3,KNOW)=PKFNVA(2)
C          F4PAR(4,KNOW)=PKFNVA(3)
C          F4PAR(5,KNOW)=PKFNVA(4)
        ELSE
          IF (KF4PAR(2,KNOW) .GT. 0) PKFNVA(1)=F4PAR(2,KNOW)
          IF (KF4PAR(3,KNOW) .GT. 0) PKFNVA(2)=F4PAR(3,KNOW)
C          IF (KF4PAR(4,KNOW) .GT. 0) PKFNVA(3)=F4PAR(4,KNOW)
C          IF (KF4PAR(5,KNOW) .GT. 0) PKFNVA(4)=F4PAR(5,KNOW)
        ENDIF
      ENDIF
      IF (IOPT .EQ. 1) GO TO 100
C
C DERIVATIVES OF PKFNVA ARRY WRT PKFNSP ARRAY:
      DERPFN(1,1)=SIGU*TANDIF**2/SIGMA
      DERPFN(1,2)=-TANDIF*SIGU**2/SIGMA
      DERPFN(1,3)=SIGW/SIGMA
      DERPFN(2,1)=SECTH
      DERPFN(2,2)=TANTH
      DERPFN(3,1)=1.
      DERPFN(4,1)=1.
100   RETURN
      END
C
C
C
C
C LEVEL 2      SUBROUTINE FDCN04(IOPT)
      SUBROUTINE FDCN04(IOPT)
C
C  *** FDCN04 by JPW 3 Apr 00, from fdcn01 ***
C
CX
CC 19B
CH Function descriptors for constant wavelength, with derivatives
CA On entry IOPT=1 if only function descriptors are required
CA               2 if both descriptors and derivatives are required
CP Expects ARGK in /PRPKCN to hold 2thetaK degrees, and the peak
CP function species values in PKFNSP in /PRPKFN to have been read by
CP calls of PFCN0x
C
CD Used when CN, constant wavelength
CD Gaussian, Cagliotti width variation on PKFN SIGM card of:
CD    FWHM^2= (U*tan(theta) + V)*tan(theta) +W
CD Lorentzian variation of:
CD    FWHM = X*cos(theta) + Y/tan(theta)
CD Asymmetry parameters SOVL and DOVL as S/L and D/L as described
CD in the finger et al paper (profval/pfcn04)
CD If SAPS and KNOW points to a reflection for which SIGS  is
CD being refined, uses value in F4PAR(2 instead of calculated value.
CD SAPS probably not working
C
/CONSTA/
/DGEOM/
/F4PARS/
/PHASE/
/POINTS/
/PRPKCN/
/PRPKFN/
/REFINE/
/REFIPR/
/REFLNS/
/SOURCE/
C
C Constants for use to get the Lorentzian FWHM
      TANTH=TAN(RAD*ARGK/2.)
      SECTH=SQRT(1+TANTH*TANTH)
C FWHM of the gaussian
      PKFNVA(1)=(PKFNSP(1,1,JPHASE,JSOURC)*TANTH+PKFNSP(1,2,
     & JPHASE,JSOURC))*TANTH+PKFNSP(1,3,JPHASE,JSOURC)
      IF (PKFNVA(1).LT.0.0) THEN
        CALL ERRMES(1,0,'Gaussian FWHM is -ve! check your input file')
        PKFNVA(1)=0
      ELSE
        PKFNVA(1)=SQRT(PKFNVA(1))
        ENDIF
C FWHM of the lorentzian
      PKFNVA(2)=PKFNSP(2,1,JPHASE,JSOURC)*SECTH
     & + PKFNSP(2,2,JPHASE,JSOURC)*TANTH
C Asymetry parameters as read
      PKFNVA(3)=PKFNSP(3,1,JPHASE,JSOURC)
      PKFNVA(4)=PKFNSP(4,1,JPHASE,JSOURC)
C This probably doesn't work!
      IF (SAPS .OR. APES) THEN
        IF (PRECYC) THEN
          F4PAR(2,KNOW)=PKFNVA(1)
        ELSE
          IF (KF4PAR(2,KNOW) .GT. 0) PKFNVA(1)=F4PAR(2,KNOW)
        ENDIF
      ENDIF
      IF (IOPT .EQ. 1) GO TO 100
C
C DERIVATIVES OF PKFNVA WRT THE 7 PKFNSP PARAMETERS, U,V,W,X,Y,S_L,D_L
      DERPFN(1,1)=TANTH*TANTH/(2.0*PKFNVA(1))
      DERPFN(1,2)=TANTH/(2.0*PKFNVA(1))
      DERPFN(1,3)=1.0/(2.0*PKFNVA(1))
      DERPFN(2,1)=SECTH
      DERPFN(2,2)=TANTH
      DERPFN(3,1)=1.0
      DERPFN(4,1)=1.0
100   RETURN
      END

C
C
C
C
C LEVEL 2      SUBROUTINE FDLX01(IOPT)
      SUBROUTINE FDLX01(IOPT)
C
C *** FDLX01 updated by WIFD/JCM 7 Mar 89 ***
C
CX
CC 19B
CH Function descriptors for X-Ray data, with derivatives
CA On entry IOPT=1 if only function descriptors are required
CA               2 if both descriptors and derivatives are required
CP Expects ARGK in /PRPKCN to hold 2thetaK degrees, and the peak
CP function species values in PKFNSP in /PRPKFN to have been read by
CP calls of PFCN0x
C
CD Used when LX, LAB X-Ray
CD Simple Gaussian, Cagliotti width variation
CD If SAPS and KNOW points to a reflection for which SIGS is
CD being refined, uses value in F4PAR(2 instead of calculated value.
C
/CONSTA/
/DGEOM/
/F4PARS/
/PHASE/
/POINTS/
/PRPKCN/
/PRPKFN/
/REFINE/
/REFIPR/
/REFLNS/
/SOURCE/
C
C For the moment, same variable names as TOF case...
C
C WE DO NOT WANT THE CALCULATION IF:
C  A) SAPS, AND
C  B) IT IS NOT THE SPECIAL INITIAL CYCLE, AND
C  C) WE ARE REFINING THIS SIGMA:
      TANTH=TAN(RAD*ARGK/2.)
      PKFNVA(1)=(PKFNSP(1,1,JPHASE,JSOURC)*TANTH+PKFNSP(1,2,
     & JPHASE,JSOURC))*TANTH+PKFNSP(1,3,JPHASE,JSOURC)
      IF (SAPS .OR. APES) THEN
        IF (PRECYC) THEN
          F4PAR(2,KNOW)=PKFNVA(1)
        ELSE
          IF (KF4PAR(2,KNOW) .GT. 0) PKFNVA(1)=F4PAR(2,KNOW)
        ENDIF
      ENDIF
      IF (IOPT .EQ. 1) GO TO 100
      DERPFN(1,1)=TANTH*TANTH
      DERPFN(1,2)=TANTH
      DERPFN(1,3)=1.
100   RETURN
      END
C
C
C
C
C LEVEL 2      SUBROUTINE FDLX02(IOPT)
      SUBROUTINE FDLX02(IOPT)
C
C *** FDLX02 updated by WIFD/JCM 7 Mar 89 ***
C
CX
CC 19B
CH Function descriptors for X-Ray data type 2, with derivatives
CA On entry IOPT=1 if only function descriptors are required
CA               2 if both descriptors and derivatives are required
CP Expects ARGK in /PRPKCN to hold 2thetaK degrees, and the peak
CP function species values in PKFNSP in /PRPKFN to have been read by
CP calls of PFCN0x
C
CD Used when LX, LAB X-Ray
CD Simple Gaussian, Cagliotti width variation
CD If SAPS and KNOW points to a reflection for which SIGS is
CD being refined, uses value in F4PAR(2 instead of calculated value.
C
/CONSTA/
/DGEOM/
/F4PARS/
/PHASE/
/POINTS/
/PRPKCN/
/PRPKFN/
/REFINE/
/REFIPR/
/REFLNS/
/SOURCE/
C
C For the moment, same variable names as TOF case...
C
C WE DO NOT WANT THE CALCULATION IF:
C  A) SAPS, AND
C  B) IT IS NOT THE SPECIAL INITIAL CYCLE, AND
C  C) WE ARE REFINING THIS PEAK VARIABLE:
      TANTH=TAN(ARGK/2.)
      PKFNVA(1)=(PKFNSP(1,1,JPHASE,JSOURC)*TANTH+PKFNSP(1,2,
     & JPHASE,JSOURC))*TANTH+PKFNSP(1,3,JPHASE,JSOURC)
      SECTH=SQRT(1. + TANTH*TANTH)
      PKFNVA(2)=PKFNSP(2,1,JPHASE,JSOURC)*TANTH+
     & PKFNSP(2,2,JPHASE,JSOURC)*SECTH
      IF (SAPS .OR. APES) THEN
        IF (PRECYC) THEN
          F4PAR(2,KNOW)=PKFNVA(1)
          F4PAR(3,KNOW)=PKFNVA(2)
        ELSE
          IF (KF4PAR(2,KNOW) .GT. 0) PKFNVA(1)=F4PAR(2,KNOW)
          IF (KF4PAR(3,KNOW) .GT. 0) PKFNVA(2)=F4PAR(3,KNOW)
        ENDIF
      ENDIF
      IF (IOPT .EQ. 1) GO TO 100
C
C DERIVATIVES OF PKFNVA ARRY WRT PKFNSP ARRAY:
      DERPFN(1,1)=TANTH*TANTH
      DERPFN(1,2)=TANTH
      DERPFN(1,3)=1.
      DERPFN(2,1)=TANTH
      DERPFN(2,2)=SECTH
100   RETURN
      END
C
C
C
C
C LEVEL 2      SUBROUTINE FDTF01(IOPT)
      SUBROUTINE FDTF01(IOPT)
C
C *** FDTF01 updated by WIFD/JCM 1 Jun 89 ***
C
CX
CC 19B
CH Evaluates peak function descriptors and their derivatives wrt peak function
CH species for Time of Flight (TOF), type 1
CA IOPT on entry requests option:
CA    If IOPT=1, just calculates peak descriptors
CA    If IOPT=2, calculates descriptors and their derivatives
CP Expects ALAMBD(ILAMB,KSOURC) (or WLNGTH for only one lambda) set in /DGEOM
CD The peak function descriptors are SWCH, TAUF, TAUS, and SIGM.
C
/DGEOM/
/F4PARS/
/PHASE/
/POINTS/
/PRPKCN/
/PRPKFN/
/REFINE/
/REFIPR/
/REFLNS/
/SOURCE/
C
C SWCH:
      ATEM= PKFNSP(1,2,JPHASE,JSOURC) - 1./ALAMBD(1,JSOURC)
      BTEM= PKFNSP(1,1,JPHASE,JSOURC)*ATEM
      PKFNVA(1)= 0.5*ERFNC(BTEM)
C TAUF AND TAUS:
      PKFNVA(2)= PKFNSP(2,1,JPHASE,JSOURC) +
     & PKFNSP(2,2,JPHASE,JSOURC)*ALAMBD(1,JSOURC)
      PKFNVA(3)= PKFNSP(3,1,JPHASE,JSOURC) +
     & PKFNSP(3,2,JPHASE,JSOURC)*ALAMBD(1,JSOURC)
      WSQ=ALAMBD(1,JSOURC)*ALAMBD(1,JSOURC)
C C49: PKFNVA(3) IS SIGMA NOT SIGMA SQUARED
C C54: AND IT IS NOW PKFNVA(4)
C WE DO NOT WANT THE CALCULATION IF:
C  A) SAPS, AND
C  B) IT IS NOT THE SPECIAL INITIAL CYCLE, AND
C  C) WE ARE REFINING THIS PEAK WIDTH:
      SIGMA= SQRT(PKFNSP(4,1,JPHASE,JSOURC) + (PKFNSP(4,2,JPHASE,
     & JSOURC) +  PKFNSP(4,3,JPHASE,JSOURC)*WSQ)*WSQ)
      PKFNVA(4)= SIGMA
      F4VAL(2,KNOW)=SIGMA
      IF (SAPS .OR. APES) THEN
        IF (PRECYC) THEN
          F4PAR(2,KNOW)=PKFNVA(4)
        ELSE
          IF (KF4PAR(2,KNOW) .GT. 0) PKFNVA(4)=F4PAR(2,KNOW)
        ENDIF
      ENDIF
C
C IOPT=1 EXIT HERE AS ONLY PEAK DESCRIPTORS ARE WANTED (NOT DERIVATIVES)
   2  IF (IOPT .EQ. 1) GO TO 100
C
C DERIVATIVES:
      CTEM= -0.564189584*EXP((-BTEM)*BTEM)
      DERPFN(1,1)= ATEM*CTEM
      DERPFN(1,2)= CTEM*PKFNSP(1,1,JPHASE,JSOURC)
      DERPFN(2,1)= 1.
      DERPFN(2,2)= ALAMBD(1,JSOURC)
      DERPFN(3,1)= 1.
      DERPFN(3,2)= ALAMBD(1,JSOURC)
      D41= 0.5/SIGMA
      DERPFN(4,1)= D41
      DERPFN(4,2)= WSQ*D41
      DERPFN(4,3)= WSQ*WSQ*D41
 100  RETURN
      END
C
C
C
C
C LEVEL 2      SUBROUTINE FDTF02(IOPT)
      SUBROUTINE FDTF02(IOPT)
C
C *** FDTF02 updated by WIFD/JCM 7 Mar 89 ***
C
C THIS SUBROUTINE EVALUATES THE PEAK FUNCTION DESCRIPTORS (PKFNVA)
C IN TERMS OF AND THEIR DERIVATIVES (DERPFN) WRT PKFNSP.
C
C EXPECTS ALAMBD(ILAMB,KSOURC) TO BE SET IN /DGEOM.
C
C IF IOPT=1, JUST CALCULATES THE VALUES OF THE PEAK DESCRIPTORS.  IF IOPT=2,
C CALCULATES ALSO THEIR DERIVATIVES WRT THE REFINABLE PARAMETERS.
C
C (LATER IT SHOULD USE THE FACT THAT IF LOGICAL REFUSE IS TRUE ON ENTRY, VALUES
C OF THE PEAK DESCRIPTORS SHOULD HAVE BEEN SAVED IN COMMON /PRSAVE, AND MAY NOW
C BE USED AGAIN.
C
/DGEOM/
/F4PARS/
/PHASE/
/POINTS/
/PRPKCN/
/PRPKFN/
/REFINE/
/REFIPR/
/REFLNS/
/SOURCE/
C
C.. SWITCH
      ATEM= PKFNSP(1,2,JPHASE,JSOURC) - 1./ALAMBD(1,JSOURC)
      BTEM= PKFNSP(1,1,JPHASE,JSOURC)*ATEM
      PKFNVA(1)= 0.5*ERFNC(BTEM)
C.. TAUF & TAUS
      PKFNVA(2)= PKFNSP(2,1,JPHASE,JSOURC) +
     & PKFNSP(2,2,JPHASE,JSOURC)*ALAMBD(1,JSOURC)
      PKFNVA(3)= PKFNSP(3,1,JPHASE,JSOURC) +
     & PKFNSP(3,2,JPHASE,JSOURC)*ALAMBD(1,JSOURC)
C.. C49: PKFNVA(4) IS SIGMA NOT SIGMA SQUARED
      WSQ=ALAMBD(1,JSOURC)*ALAMBD(1,JSOURC)
      SIGMA= SQRT(PKFNSP(4,1,JPHASE,JSOURC) + (PKFNSP(4,2,JPHASE,
     & JSOURC) +  PKFNSP(4,3,JPHASE,JSOURC)*WSQ)*WSQ)
      GAMMA=PKFNSP(5,1,JPHASE,JSOURC) + (PKFNSP(5,2,JPHASE,JSOURC) +
     & PKFNSP(5,3,JPHASE,JSOURC)*ALAMBD(1,JSOURC))*ALAMBD(1,JSOURC)
      PKFNVA(4)= SIGMA
      PKFNVA(5)= GAMMA
      F4VAL(2,KNOW)=SIGMA
      F4VAL(3,KNOW)=GAMMA
      IF (SAPS .OR. APES) THEN
        IF (PRECYC) THEN
          F4PAR(2,KNOW)=PKFNVA(4)
          F4PAR(3,KNOW)=PKFNVA(5)
        ELSE
          IF (KF4PAR(2,KNOW) .GT. 0) PKFNVA(4)=F4PAR(2,KNOW)
          IF (KF4PAR(3,KNOW) .GT. 0) PKFNVA(5)=F4PAR(3,KNOW)
        ENDIF
      ENDIF
C
C IOPT=1 EXIT HERE AS ONLY PEAK DESCRIPTORS ARE WANTED (NOT DERIVATIVES)
      IF (IOPT .EQ. 1) GO TO 100
      CTEM= -0.564189584*EXP((-BTEM)*BTEM)
      DERPFN(1,1)= ATEM*CTEM
      DERPFN(1,2)= CTEM*PKFNSP(1,1,JPHASE,JSOURC)
      DERPFN(2,1)= 1.
      DERPFN(2,2)= ALAMBD(1,JSOURC)
      DERPFN(3,1)= 1.
      DERPFN(3,2)= ALAMBD(1,JSOURC)
      D41= 0.5/SIGMA
      DERPFN(4,1)= D41
      DERPFN(4,2)= WSQ*D41
      DERPFN(4,3)= WSQ*WSQ*D41
      DERPFN(5,1)= 1.
      DERPFN(5,2)= ALAMBD(1,JSOURC)
      DERPFN(5,3)= WSQ
 100  RETURN
      END
C
C
C
C
C LEVEL 2      SUBROUTINE FDTF03(IOPT)
      SUBROUTINE FDTF03(IOPT)
C
C *** FDTF03 updated by WIFD/JCM 1 Jun 89 ***
C
C THIS SUBROUTINE EVALUATES THE PEAK FUNCTION DESCRIPTORS (PKFNVA)
C IN TERMS OF AND THEIR DERIVATIVES (DERPFN) WRT PKFNSP.
C
C EXPECTS ALAMBD(ILAMB,KSOURC) TO BE SET IN /DGEOM.
C
C IF IOPT=1, JUST CALCULATES THE VALUES OF THE PEAK DESCRIPTORS.  IF IOPT=2,
C CALCULATES ALSO THEIR DERIVATIVES WRT THE REFINABLE PARAMETERS.
C
C (LATER IT SHOULD USE THE FACT THAT IF LOGICAL REFUSE IS TRUE ON ENTRY, VALUES
C OF THE PEAK DESCRIPTORS SHOULD HAVE BEEN SAVED IN COMMON /PRSAVE, AND MAY NOW
C BE USED AGAIN.
C
      DIMENSION CDUMP(10)
/BRAGG/
/CELPAR/
/DGEOM/
/F4PARS/
/PHASE/
/POINTS/
/PRPKCN/
/PRPKFN/
/REFINE/
/REFIPR/
/REFLNS/
/SOURCE/
C
C.. SWITCH
      ATEM= PKFNSP(1,2,JPHASE,JSOURC) - 1./ALAMBD(1,JSOURC)
      BTEM= PKFNSP(1,1,JPHASE,JSOURC)*ATEM
      PKFNVA(1)= 0.5*ERFNC(BTEM)
C.. TAUF & TAUS
      PKFNVA(2)= PKFNSP(2,1,JPHASE,JSOURC) +
     & PKFNSP(2,2,JPHASE,JSOURC)*ALAMBD(1,JSOURC)
      PKFNVA(3)= PKFNSP(3,1,J PHASE,JSOURC) +
     & PKFNSP(3,2,JPHASE,JSOURC)*ALAMBD(1,JSOURC)
C.. C49: PKFNVA(4) IS SIGMA NOT SIGMA SQUARED
      WSQ=ALAMBD(1,JSOURC)*ALAMBD(1,JSOURC)
      SIGMA=SQRT(PKFNSP(4,1,JPHASE,JSOURC) + (PKFNSP(4,2,JPHASE,
     & JSOURC) +  PKFNSP(4,3,JPHASE,JSOURC)*WSQ)*WSQ)
      GAMMA=PKFNSP(5,1,JPHASE,JSOURC) + (PKFNSP(5,2,JPHASE,JSOURC) +
     & PKFNSP(5,3,JPHASE,JSOURC)*ALAMBD(1,JSOURC))*ALAMBD(1,JSOURC)
C.. C AXIS QUADRATIC TERM
      EL=REFH(3,KNOW)
      CALL CELDER(REFH(1,KNOW),CDUMP)
      D61=ARGK*CPARS(3,2)*EL*EL/DSTAR2
      PKFNVA(4)= SIGMA
      PKFNVA(5)= GAMMA
      PKFNVA(6)= D61*PKFNSP(6,1,JPHASE,JSOURC)
      F4VAL(2,KNOW)=SIGMA
      F4VAL(3,KNOW)=GAMMA
      IF (SAPS .OR. APES) THEN
        IF (PRECYC) THEN
          F4PAR(2,KNOW)=PKFNVA(4)
          F4PAR(3,KNOW)=PKFNVA(5)
        ELSE
          IF (KF4PAR(2,KNOW) .GT. 0) PKFNVA(4)=F4PAR(2,KNOW)
          IF (KF4PAR(3,KNOW) .GT. 0) PKFNVA(5)=F4PAR(3,KNOW)
        ENDIF
      ENDIF
C
C IOPT=1 EXIT HERE AS ONLY PEAK DESCRIPTORS ARE WANTED (NOT DERIVATIVES)
      IF (IOPT .EQ. 1) GO TO 100
      CTEM= -0.564189584*EXP((-BTEM)*BTEM)
      DERPFN(1,1)= ATEM*CTEM
      DERPFN(1,2)= CTEM*PKFNSP(1,1,JPHASE,JSOURC)
      DERPFN(2,1)= 1.
      DERPFN(2,2)= ALAMBD(1,JSOURC)
      DERPFN(3,1)= 1.
      DERPFN(3,2)= ALAMBD(1,JSOURC)
      D41= 0.5/SIGMA
      DERPFN(4,1)= D41
      DERPFN(4,2)= WSQ*D41
      DERPFN(4,3)= WSQ*WSQ*D41
      DERPFN(5,1)= 1.
      DERPFN(5,2)= ALAMBD(1,JSOURC)
      DERPFN(5,3)= WSQ
      DERPFN(6,1)= D61
 100  RETURN
      END
C
C
C
C
C LEVEL 2      SUBROUTINE FDTF04(IOPT)
      SUBROUTINE FDTF04(IOPT)
C
C *** FDTF04 updated by WIFD May 89 ***
C
CX
CC 19B
CH Forms Peak function descriptors & derivatives for POLARIS data.
C
CA On entry IOPT indicates the opion reuired:
CA If IOPT=1, just calculates the values of the peak descriptors.
CA If IOPT=2, calculates also their derivatives wrt the refinable parameters.
CP Expects ALAMBD(ILAMB) the wavelength, to be set in /DGEOM.
CD Evaluates the peak function descriptors (PKFNVA) in terms of PKFNSP,
CD the Peak Function Species, and the derivatives (DERPFN) of PKFNVA wrt PKFNSP.
C
C (LATER IT SHOULD USE THE FACT THAT IF LOGICAL REFUSE IS TRUE ON ENTRY, VALUES
C OF THE PEAK DESCRIPTORS SHOULD HAVE BEEN SAVED IN COMMON /PRSAVE, AND MAY NOW
C BE USED AGAIN.  I WILL INVESTIGATE THIS REMARK SOON - JUDY).
C
      DIMENSION CREFH(6)
/CELPAR/
/DGEOM/
/F4PARS/
/PHASE/
/POINTS/
/PRPKCN/
/PRPKFN/
/REFINE/
/REFIPR/
/REFLNS/
/SOURCE/
C
C.. SWITCH
C      ATEM= PKFNSP(1,2,JPHASE,JSOURC) - 1./ALAMBD(1,JSOURC)
C      BTEM= PKFNSP(1,1,JPHASE,JSOURC)*ATEM
C      PKFNVA(1)= 0.5*ERFNC(BTEM)
      WSQ=ALAMBD(1,JSOURC)*ALAMBD(1,JSOURC)
      SWITCH=EXP(-PKFNSP(1,1,JPHASE,JSOURC)/WSQ)
      PKFNVA(1)=SWITCH
C.. TAUF & TAUS
      PKFNVA(2)= PKFNSP(2,1,JPHASE,JSOURC) +
     & PKFNSP(2,2,JPHASE,JSOURC)*ALAMBD(1,JSOURC)
      PKFNVA(3)= PKFNSP(3,1,JPHASE,JSOURC) +
     & PKFNSP(3,2,JPHASE,JSOURC)*ALAMBD(1,JSOURC)
C.. C49: PKFNVA(4) IS SIGMA NOT SIGMA SQUARED
      SIGMA= SQRT(PKFNSP(4,1,JPHASE,JSOURC) + (PKFNSP(4,2,JPHASE,JSOURC)
     &  +  PKFNSP(4,3,JPHASE,JSOURC)*WSQ)*WSQ)
      GAMMA= PKFNSP(5,1,JPHASE,JSOURC) + (PKFNSP(5,2,JPHASE,JSOURC)
     &  +  PKFNSP(5,3,JPHASE,JSOURC)*ALAMBD(1,JSOURC))*ALAMBD(1,JSOURC)
      PKFNVA(4)= SIGMA
      PKFNVA(5)= GAMMA
      PKFNVA(6)= PKFNSP(6,1,JPHASE,JSOURC)
      F4VAL(3,KNOW)= SIGMA
      F4VAL(2,KNOW)= PKFNVA(1)
      IF (SAPS .OR. APES) THEN
        IF (PRECYC) THEN
          F4PAR(2,KNOW)=PKFNVA(1)
          F4PAR(3,KNOW)=PKFNVA(4)
        ELSE
          IF (KF4PAR(2,KNOW).GT.0) PKFNVA(1)=F4PAR(2,KNOW)
          IF (KF4PAR(3,KNOW).GT.0) PKFNVA(4)=F4PAR(3,KNOW)
        ENDIF
      ENDIF
C
C IOPT=1 EXIT HERE AS ONLY PEAK DESCRIPTORS ARE WANTED (NOT DERIVATIVES)
      IF (IOPT .EQ. 2) THEN
C      CTEM= -0.564189584*EXP((-BTEM)*BTEM)
C      DERPFN(1,1)= ATEM*CTEM
C      DERPFN(1,2)= CTEM*PKFNSP(1,1,JPHASE,JSOURC)
        DERPFN(1,1)= -SWITCH/WSQ
        DERPFN(2,1)= 1.
        DERPFN(2,2)= ALAMBD(1,JSOURC)
        DERPFN(3,1)= 1.
        DERPFN(3,2)= ALAMBD(1,JSOURC)
        D41= 0.5/SIGMA
        DERPFN(4,1)= D41
        DERPFN(4,2)= WSQ*D41
        DERPFN(4,3)= WSQ*WSQ*D41
        DERPFN(5,1)= 1.
        DERPFN(5,2)= ALAMBD(1,JSOURC)
        DERPFN(5,3)= WSQ
        DERPFN(6,1)= 1.
      ENDIF
      RETURN
      END
C
C
C
C
C LEVEL 2      SUBROUTINE FDTF05(IOPT)
      SUBROUTINE FDTF05(IOPT)
C
C *** FDTF05 updated by WIFD/JCM 7 Mar 89 ***
C
C THIS SUBROUTINE EVALUATES THE PEAK FUNCTION DESCRIPTORS (PKFNVA)
C IN TERMS OF AND THEIR DERIVATIVES (DERPFN) WRT PKFNSP.
C
C EXPECTS ALAMBD(ILAMB,KSOURC) TO BE SET IN /DGEOM.
C
C IF IOPT=1, JUST CALCULATES THE VALUES OF THE PEAK DESCRIPTORS.  IF IOPT=2,
C CALCULATES ALSO THEIR DERIVATIVES WRT THE REFINABLE PARAMETERS.
C
C (LATER IT SHOULD USE THE FACT THAT IF LOGICAL REFUSE IS TRUE ON ENTRY, VALUES
C OF THE PEAK DESCRIPTORS SHOULD HAVE BEEN SAVED IN COMMON /PRSAVE, AND MAY NOW
C BE USED AGAIN.
C
/BRAGG/
/CELPAR/
/DGEOM/
/F4PARS/
/PHASE/
/POINTS/
/PRPKCN/
/PRPKFN/
/REFINE/
/REFIPR/
/REFLNS/
/SOURCE/
C
C.. SWITCH
      ATEM= PKFNSP(1,2,JPHASE,JSOURC) - 1./ALAMBD(1,JSOURC)
      BTEM= PKFNSP(1,1,JPHASE,JSOURC)*ATEM
      PKFNVA(1)= 0.5*ERFNC(BTEM)
C.. TAUF & TAUS
      PKFNVA(2)= PKFNSP(2,1,JPHASE,JSOURC) +
     & PKFNSP(2,2,JPHASE,JSOURC)*ALAMBD(1,JSOURC)
      PKFNVA(3)= PKFNSP(3,1,JPHASE,JSOURC) +
     & PKFNSP(3,2,JPHASE,JSOURC)*ALAMBD(1,JSOURC)
C.. C49: PKFNVA(4) IS SIGMA NOT SIGMA SQUARED
      WSQ=ALAMBD(1,JSOURC)*ALAMBD(1,JSOURC)
      SIGMA= SQRT(PKFNSP(4,1,JPHASE,JSOURC) + (PKFNSP(4,2,JPHASE,
     & JSOURC) +  PKFNSP(4,3,JPHASE,JSOURC)*WSQ)*WSQ)
      GAMMA=PKFNSP(5,1,JPHASE,JSOURC) + (PKFNSP(5,2,JPHASE,JSOURC) +
     & PKFNSP(5,3,JPHASE,JSOURC)*ALAMBD(1,JSOURC))*ALAMBD(1,JSOURC)
      PKFNVA(4)= SIGMA
      PKFNVA(5)= GAMMA
C.. THIS IS SPECIFIC TO TETRAGONAL SYSTEMS!!!
      R1=REFH(1,KNOW)**2+REFH(2,KNOW)**2
      R2=REFH(3,KNOW)**2
      AV=CELL(1,1,1)
      CV=CELL(3,1,1)
      V1=SQRT(R1/AV**2+R2/CV**2)
      V2=SQRT(R1/(AV+0.001*PKFNSP(7,1,JPHASE,JSOURC))**2
     &       +R2/(CV+0.001*PKFNSP(7,2,JPHASE,JSOURC))**2)
      EFAC=(REFH(3,KNOW)/(CV*V1))**2
      ESIGM=EFAC*SQRT((PKFNSP(6,1,JPHASE,JSOURC) +
     &PKFNSP(6,2,JPHASE,JSOURC)*WSQ)*WSQ)
      PKFNVA(6)= ESIGM
      STTEM=252.777*PKCNSP(1,JPHASE,JSOURC)*TWSNTH(JSOURC)
      PKFNVA(7)= STTEM*(1./V2-1./V1)
      PKFNVA(8)= PKFNSP(8,1,JPHASE,JSOURC)
C
      F4VAL(2,KNOW)=SIGMA
      F4VAL(3,KNOW)=GAMMA
      IF (SAPS .OR. APES) THEN
        IF (PRECYC) THEN
          F4PAR(2,KNOW)=PKFNVA(4)
          F4PAR(3,KNOW)=PKFNVA(5)
        ELSE
          IF (KF4PAR(2,KNOW) .GT. 0) PKFNVA(4)=F4PAR(2,KNOW)
          IF (KF4PAR(3,KNOW) .GT. 0) PKFNVA(5)=F4PAR(3,KNOW)
      ENDIF
      ENDIF
C
C IOPT=1 EXIT HERE AS ONLY PEAK DESCRIPTORS ARE WANTED (NOT DERIVATIVES)
      IF (IOPT .EQ. 1) GO TO 100
      CTEM= -0.564189584*EXP((-BTEM)*BTEM)
      DERPFN(1,1)= ATEM*CTEM
      DERPFN(1,2)= CTEM*PKFNSP(1,1,JPHASE,JSOURC)
      DERPFN(2,1)= 1.
      DERPFN(2,2)= ALAMBD(1,JSOURC)
      DERPFN(3,1)= 1.
      DERPFN(3,2)= ALAMBD(1,JSOURC)
      D41= 0.5/SIGMA
      DERPFN(4,1)= D41
      DERPFN(4,2)= WSQ*D41
      DERPFN(4,3)= WSQ*WSQ*D41
      DERPFN(5,1)= 1.
      DERPFN(5,2)= ALAMBD(1,JSOURC)
      DERPFN(5,3)= WSQ
      IF (ESIGM .LE. 0.) THEN
        DERPFN(6,1)= 0.
        DERPFN(6,2)= 0.
      ELSE
        D61= 0.5/ESIGM
        D61=D61*EFAC**2
        DERPFN(6,1)= WSQ*D61
        DERPFN(6,2)= WSQ*WSQ*D61
      END IF
      DERPFN(7,1)= (0.001*STTEM*R1)/(AV*V2)**3
CCC     &((AV+0.001*PKFNSP(7,1,JPHASE,JSOURC))*V2)**3
      DERPFN(7,2)= (0.001*STTEM*R2)/(CV*V2)**3
CCC     &((CV+0.001*PKFNSP(7,2,JPHASE,JSOURC))*V2)**3
      DERPFN(8,1)= 1.
 100  RETURN
      END
C
C
C
C
C LEVEL 2      SUBROUTINE FDTF06(IOPT)
      SUBROUTINE FDTF06(IOPT)
C
C *** FDTF06 From FDTF06 - JPW/JBF 2/5/00 ***

C THIS SUBROUTINE EVALUATES THE PEAK FUNCTION DESCRIPTORS (PKFNVA)
C IN TERMS OF AND THEIR DERIVATIVES (DERPFN) WRT PKFNSP.
C
C Anisotropic broadening on gamm parameter
C
C EXPECTS ALAMBD(ILAMB,KSOURC) TO BE SET IN /DGEOM.
C
C IF IOPT=1, JUST CALCULATES THE VALUES OF THE PEAK DESCRIPTORS.  IF IOPT=2,
C CALCULATES ALSO THEIR DERIVATIVES WRT THE REFINABLE PARAMETERS.
C
C (LATER IT SHOULD USE THE FACT THAT IF LOGICAL REFUSE IS TRUE ON ENTRY, VALUES
C OF THE PEAK DESCRIPTORS SHOULD HAVE BEEN SAVED IN COMMON /PRSAVE, AND MAY NOW
C BE USED AGAIN.
C
      DIMENSION AREF(3)
/CELPAR/
/DGEOM/
/F4PARS/
/PHASE/
/POINTS/
/PRPKCN/
/PRPKFN/
/REFINE/
/REFIPR/
/REFLNS/
/SOURCE/
C
C.. SWITCH
      ATEM= PKFNSP(1,2,JPHASE,JSOURC) - 1./ALAMBD(1,JSOURC)
      BTEM= PKFNSP(1,1,JPHASE,JSOURC)*ATEM
      PKFNVA(1)= 0.5*ERFNC(BTEM)
C.. TAUF & TAUS
      PKFNVA(2)= PKFNSP(2,1,JPHASE,JSOURC) +
     & PKFNSP(2,2,JPHASE,JSOURC)*ALAMBD(1,JSOURC)
      PKFNVA(3)= PKFNSP(3,1,JPHASE,JSOURC) +
     & PKFNSP(3,2,JPHASE,JSOURC)*ALAMBD(1,JSOURC)
C.. C49: PKFNVA(4) IS SIGMA NOT SIGMA SQUARED
      WSQ=ALAMBD(1,JSOURC)*ALAMBD(1,JSOURC)
      SIGMA= PKFNSP(4,1,JPHASE,JSOURC) + (PKFNSP(4,2,JPHASE,
     & JSOURC) +  PKFNSP(4,3,JPHASE,JSOURC)*WSQ)*WSQ
      IF (SIGMA.GT.0.0) THEN
        SIGMA=SQRT(SIGMA)
      ELSE
        SIGMA=0.0
      ENDIF
C Turn hkl into HKL on CCSL orthogonal axes
      CALL GMPRD(ORTH(1:3,1:3,2),REFH(1:3,KNOW),AREF,3,3,1)
C Now normalise HKL to unit length
      CALL UNIVEC(AREF,DUMMY)
      GAMMA=ALAMBD(1,JSOURC)*(PKFNSP(5,1,JPHASE,JSOURC)*AREF(1)**2
     & + PKFNSP(5,2,JPHASE,JSOURC)*AREF(2)**2
     & + PKFNSP(5,3,JPHASE,JSOURC)*AREF(3)**2
     & + PKFNSP(5,4,JPHASE,JSOURC)*AREF(1)*AREF(2)
     & + PKFNSP(5,5,JPHASE,JSOURC)*AREF(2)*AREF(3)
     & + PKFNSP(5,6,JPHASE,JSOURC)*AREF(1)*AREF(3))
      PKFNVA(4)= SIGMA
      PKFNVA(5)= GAMMA
      F4VAL(2,KNOW)=SIGMA
      F4VAL(3,KNOW)=GAMMA
      IF (SAPS .OR. APES) THEN
        IF (PRECYC) THEN
          F4PAR(2,KNOW)=PKFNVA(4)
          F4PAR(3,KNOW)=PKFNVA(5)
        ELSE
          IF (KF4PAR(2,KNOW) .GT. 0) PKFNVA(4)=F4PAR(2,KNOW)
          IF (KF4PAR(3,KNOW) .GT. 0) PKFNVA(5)=F4PAR(3,KNOW)
        ENDIF
      ENDIF
C
C IOPT=1 EXIT HERE AS ONLY PEAK DESCRIPTORS ARE WANTED (NOT DERIVATIVES)
      IF (IOPT .EQ. 1) GO TO 100
      CTEM= -0.564189584*EXP((-BTEM)*BTEM)
      DERPFN(1,1)= ATEM*CTEM
      DERPFN(1,2)= CTEM*PKFNSP(1,1,JPHASE,JSOURC)
      DERPFN(2,1)= 1.
      DERPFN(2,2)= ALAMBD(1,JSOURC)
      DERPFN(3,1)= 1.
      DERPFN(3,2)= ALAMBD(1,JSOURC)
      D41= 0.5/SIGMA
      DERPFN(4,1)= D41
      DERPFN(4,2)= WSQ*D41
      DERPFN(4,3)= WSQ*WSQ*D41
      DERPFN(5,1)= ALAMBD(1,JSOURC)*AREF(1)**2
      DERPFN(5,2)= ALAMBD(1,JSOURC)*AREF(2)**2
      DERPFN(5,3)= ALAMBD(1,JSOURC)*AREF(3)**2
      DERPFN(5,4)= ALAMBD(1,JSOURC)*AREF(1)*AREF(2)
      DERPFN(5,5)= ALAMBD(1,JSOURC)*AREF(2)*AREF(3)
      DERPFN(5,6)= ALAMBD(1,JSOURC)*AREF(1)*AREF(3)
 100  RETURN
      END
C
C
C
C
C LEVEL 2      SUBROUTINE FDTF08(IOPT)
      SUBROUTINE FDTF08(IOPT)
C
C *** FDTF08 (formerly 04) updated by WIFD May 89 ***
C
C THIS SUBROUTINE EVALUATES THE PEAK FUNCTION DESCRIPTORS (PKFNVA)
C IN TERMS OF AND THEIR DERIVATIVES (DERPFN) WRT PKFNSP.
C
C EXPECTS ALAMBD(ILAMB,KSOURC) TO BE SET IN /DGEOM.
C
C IF IOPT=1, JUST CALCULATES THE VALUES OF THE PEAK DESCRIPTORS.  IF IOPT=2,
C CALCULATES ALSO THEIR DERIVATIVES WRT THE REFINABLE PARAMETERS.
C
C (LATER IT SHOULD USE THE FACT THAT IF LOGICAL REFUSE IS TRUE ON ENTRY, VALUES
C OF THE PEAK DESCRIPTORS SHOULD HAVE BEEN SAVED IN COMMON /PRSAVE, AND MAY NOW
C BE USED AGAIN.
C
      DIMENSION CREFH(6)
/CELPAR/
/DGEOM/
/F4PARS/
/PHASE/
/POINTS/
/PRPKCN/
/PRPKFN/
/REFINE/
/REFIPR/
/REFLNS/
/SOURCE/
C
C.. SWITCH
      ATEM= PKFNSP(1,2,JPHASE,JSOURC) - 1./ALAMBD(1,JSOURC)
      BTEM= PKFNSP(1,1,JPHASE,JSOURC)*ATEM
      PKFNVA(1)= 0.5*ERFNC(BTEM)
C.. TAUF & TAUS
      PKFNVA(2)= PKFNSP(2,1,JPHASE,JSOURC) +
     & PKFNSP(2,2,JPHASE,JSOURC)*ALAMBD(1,JSOURC)
      PKFNVA(3)= PKFNSP(3,1,JPHASE,JSOURC) +
     & PKFNSP(3,2,JPHASE,JSOURC)*ALAMBD(1,JSOURC)
C.. C49: PKFNVA(4) IS SIGMA NOT SIGMA SQUARED
      WSQ=ALAMBD(1,JSOURC)*ALAMBD(1,JSOURC)
      SIGMA=SQRT(PKFNSP(4,1,JPHASE,JSOURC) + (PKFNSP(4,2,JPHASE,
     & JSOURC) +  PKFNSP(4,3,JPHASE,JSOURC)*WSQ)*WSQ)
      PKFNVA(4)= SIGMA
      DSP= 1./DSTAR(KNOW)
      DSP2= DSP*DSP
      DSP3= DSP*DSP2
      ARGST= 0.
      ARGPS= 0.
      DO 3 I=1,3
        CREFH(I)=CPARS(I,2)*REFH(I,KNOW)**2
        I3=I+3
        IL=9-I3
        I1=(8-I3)/2
      I2=IL-I1
        CREFH(I3)=2.*CPARS(I3,2)*REFH(I1,KNOW)*REFH(I2,KNOW)
   3  CONTINUE
      DO 5 I=1,6
        ARGST=ARGST+PKFNSP(5,I,JPHASE,JSOURC)*CREFH(I)
        ARGPS=ARGPS+PKFNSP(6,I,JPHASE,JSOURC)*CREFH(I)
   5  CONTINUE
      ARGST=SQRT(AMAX1(0.,ARGST))
      ARGPS=SQRT(AMAX1(0.,ARGPS))
      GAMST= DSP2*ARGST
      GAMPS= DSP3*ARGPS
      PKFNVA(5)= GAMST
      PKFNVA(6)= GAMPS
      F4VAL(3,KNOW)= SIGMA
      F4VAL(2,KNOW)= GAMST+GAMPS
      IF (SAPS .OR. APES) THEN
        IF (PRECYC) THEN
          F4PAR(2,KNOW)=PKFNVA(5)+PKFNVA(6)
          F4PAR(3,KNOW)=PKFNVA(4)
        ELSE
          IF (KF4PAR(2,KNOW) .GT. 0) PKFNVA(5)=0.5*F4PAR(2,KNOW)
          IF (KF4PAR(2,KNOW) .GT. 0) PKFNVA(6)=0.5*F4PAR(2,KNOW)
          IF (KF4PAR(3,KNOW) .GT. 0) PKFNVA(4)=F4PAR(3,KNOW)
        ENDIF
      ENDIF
C
C IOPT=1 EXIT HERE AS ONLY PEAK DESCRIPTORS ARE WANTED (NOT DERIVATIVES)
      IF (IOPT .EQ. 1) GO TO 100
      CTEM= -0.564189584*EXP((-BTEM)*BTEM)
      DERPFN(1,1)= ATEM*CTEM
      DERPFN(1,2)= CTEM*PKFNSP(1,1,JPHASE,JSOURC)
      DERPFN(2,1)= 1.
      DERPFN(2,2)= ALAMBD(1,JSOURC)
      DERPFN(3,1)= 1.
      DERPFN(3,2)= ALAMBD(1,JSOURC)
      D41= 0.5/SIGMA
      DERPFN(4,1)= D41
      DERPFN(4,2)= WSQ*D41
      DERPFN(4,3)= WSQ*WSQ*D41
      IF (ARGST .EQ. 0.) THEN
        DO 51 I=1,6
        DERPFN(5,I)= 0.
  51    CONTINUE
      ELSE
        DO 52 I=1,6
        DERPFN(5,I)= 0.5*DSP2*CREFH(I)/ARGST
  52    CONTINUE
      ENDIF
C
      IF (ARGPS .EQ. 0.) THEN
        DO 61 I=1,6
        DERPFN(6,I)= 0.
  61    CONTINUE
      ELSE
        DO 62 I=1,6
        DERPFN(6,I)= 0.5*DSP3*CREFH(I)/ARGPS
  62    CONTINUE
      ENDIF
 100  RETURN
      END
C
C
C
C
C LEVEL 2      SUBROUTINE FDTF12(IOPT)
      SUBROUTINE FDTF12(IOPT)
C
C *** FDTF12 by JBF 2 March 94 ***
C
CX
CC 19B
CH Forms Peak function descriptors & derivatives as for FDTF02 but with
CH alternative SIGM and GAMM parameters for magnetic peaks data.
C
CA On entry IOPT indicates the opion required:
CA If IOPT=1, just calculates the values of the peak descriptors.
CA If IOPT=2, calculates also their derivatives wrt the refinable parameters.
CA
CP Expects ALAMBD(ILAMB,KSOURC) the wavelength, to be set in /DGEOM.
CD Evaluates the peak function descriptors (PKFNVA) in terms of PKFNSP,
CD the Peak Function Species, and the derivatives (DERPFN) of PKFNVA wrt PKFNSP.
C
C (LATER IT SHOULD USE THE FACT THAT IF LOGICAL REFUSE IS TRUE ON ENTRY, VALUES
C OF THE PEAK DESCRIPTORS SHOULD HAVE BEEN SAVED IN COMMON /PRSAVE, AND MAY NOW
C BE USED AGAIN.  I WILL INVESTIGATE THIS REMARK SOON - JUDY).
C
/DGEOM/
/F4PARS/
/PHASE/
/POINTS/
/PRPKCN/
/PRPKFN/
/REFINE/
/REFIPR/
/REFLNS/
/SOURCE/
C
C.. SWITCH
      ATEM= PKFNSP(1,2,JPHASE,JSOURC) - 1./ALAMBD(1,JSOURC)
      BTEM= PKFNSP(1,1,JPHASE,JSOURC)*ATEM
      PKFNVA(1)= 0.5*ERFNC(BTEM)
C.. TAUF & TAUS
      PKFNVA(2)= PKFNSP(2,1,JPHASE,JSOURC) +
     & PKFNSP(2,2,JPHASE,JSOURC)*ALAMBD(1,JSOURC)
      PKFNVA(3)= PKFNSP(3,1,JPHASE,JSOURC) +
     & PKFNSP(3,2,JPHASE,JSOURC)*ALAMBD(1,JSOURC)
C.. C49: PKFNVA(4) IS SIGMA NOT SIGMA SQUARED
      WSQ=ALAMBD(1,JSOURC)*ALAMBD(1,JSOURC)
      SIGMA= SQRT(PKFNSP(4,1,JPHASE,JSOURC) + (PKFNSP(4,2,JPHASE,JSOURC)
     &  +  PKFNSP(4,3,JPHASE,JSOURC)*WSQ)*WSQ)
      SIGMM= SQRT(PKFNSP(6,1,JPHASE,JSOURC) + (PKFNSP(6,2,JPHASE,JSOURC)
     &  +  PKFNSP(6,3,JPHASE,JSOURC)*WSQ)*WSQ)
      GAMMA= PKFNSP(5,1,JPHASE,JSOURC) + (PKFNSP(5,2,JPHASE,JSOURC)
     &  +  PKFNSP(5,3,JPHASE,JSOURC)*ALAMBD(1,JSOURC))*ALAMBD(1,JSOURC)
      GAMMM= PKFNSP(7,1,JPHASE,JSOURC) + (PKFNSP(7,2,JPHASE,JSOURC)
     &  +  PKFNSP(7,3,JPHASE,JSOURC)*ALAMBD(1,JSOURC))*ALAMBD(1,JSOURC)
      PKFNVA(4)= SIGMA
      PKFNVA(5)= GAMMA
      PKFNVA(6)= SIGMM
      PKFNVA(7)= GAMMM
C USE ISMAG TO SWITCH BETWEEN SIGMA/SIGMM AND GAMMA/GAMMM
      IF (ISMAG(KNOW).EQ.0) THEN
        F4VAL(2,KNOW)=SIGMA
        F4VAL(3,KNOW)=GAMMA
      ELSE
        F4VAL(2,KNOW)=SIGMM
        F4VAL(3,KNOW)=GAMMM
      ENDIF
      IF (SAPS .OR. APES) THEN
        IF (PRECYC) THEN
          IF (ISMAG(KNOW).EQ.0) THEN
            F4PAR(2,KNOW)=PKFNVA(4)
            F4PAR(3,KNOW)=PKFNVA(5)
          ELSE
            F4PAR(2,KNOW)=PKFNVA(6)
            F4PAR(3,KNOW)=PKFNVA(7)
          ENDIF
        ELSE
          IF (KF4PAR(2,KNOW) .GT. 0) THEN
            IF (ISMAG(KNOW).EQ.0) THEN
              PKFNVA(4)=F4PAR(2,KNOW)
            ELSE
              PKFNVA(6)=F4PAR(2,KNOW)
            ENDIF
          ENDIF
          IF (KF4PAR(3,KNOW) .GT. 0) THEN
            IF (ISMAG(KNOW).EQ.0) THEN
              PKFNVA(5)=F4PAR(3,KNOW)
            ELSE
              PKFNVA(7)=F4PAR(3,KNOW)
            ENDIF
          ENDIF
        ENDIF
      ENDIF
C
C IOPT=1 EXIT HERE AS ONLY PEAK DESCRIPTORS ARE WANTED (NOT DERIVATIVES)
      IF (IOPT .EQ. 1) GO TO 100
      CTEM= -0.564189584*EXP((-BTEM)*BTEM)
      DERPFN(1,1)= ATEM*CTEM
      DERPFN(1,2)= CTEM*PKFNSP(1,1,JPHASE,JSOURC)
      DERPFN(2,1)= 1.
      DERPFN(2,2)= ALAMBD(1,JSOURC)
      DERPFN(3,1)= 1.
      DERPFN(3,2)= ALAMBD(1,JSOURC)
      D41= 0.5/SIGMA
      DERPFN(4,1)= D41
      DERPFN(4,2)= WSQ*D41
      DERPFN(4,3)= WSQ*WSQ*D41
      DERPFN(5,1)= 1.
      DERPFN(5,2)= ALAMBD(1,JSOURC)
      DERPFN(5,3)= WSQ
      D61= 0.5/SIGMM
      DERPFN(6,1)= D61
      DERPFN(6,2)= WSQ*D61
      DERPFN(6,3)= WSQ*WSQ*D61
      DERPFN(7,1)= 1.
      DERPFN(7,2)= ALAMBD(1,JSOURC)
      DERPFN(7,3)= WSQ
 100  RETURN
      END
C
C
C
C
C LEVEL 2      SUBROUTINE FTSB12(MNS)
      SUBROUTINE FTSB12(MNS)
C
C *** FTSB12 by JBF MAR 94 For N and M peaks with different SIGM and GAMM ***
C
      COMPLEX CFFT,DFFT,DDT,CFE,CFT
/CONSTA/
/PHASE/
/PRPKFN/
/PRSAVF/
/REFLNS/
      COMMON /SCRAT/CFFT(8),DFFT(8),DDT(8),CFE,CFT,
%     1FR(%FFT2%,8),FI(%FFT2%,8),DR(%FFT2%,8),DI(%FFT2%,8),
%     & FRE(%FFT2%),FIE(%FFT2%),FRT(%FFT2%),FIT(%FFT2%)
/SOURCE/
C
      SW=PKFNVA(1)
      TAUF=PKFNVA(2)
      TAUS=PKFNVA(3)

      IF (ISMAG(KNOW).EQ.0) THEN
        SIG= PKFNVA(4)
        GAM= PKFNVA(5)
      ELSE
        SIG= PKFNVA(6)
        GAM= PKFNVA(7)
      ENDIF
      SW1=1.-SW
C
      C2TEM= PI/(FLOAT(MNS)*XPKDEL(KMOD))
      CTEM=  2.*C2TEM
      FTEMF= CTEM*TAUF
      FTEMS= CTEM*TAUS
      GTEM=  CTEM*SIG
      CLTEM= C2TEM*GAM
C
      MN2=MNS/2
      MN2M1= MN2-1
      MN2P1= MN2+1
      DO 1 I=1,MNS
        II=MOD(I+MN2,MNS)-MN2P1
C.. FAST EXPONENTIAL DECAY
        ARG=FTEMF*FLOAT(II)
        FR(I,2)= 1./(1.+ARG*ARG)
        FI(I,2)= ARG*FR(I,2)
        ATEMF= CTEM*FLOAT(II)*FR(I,2)**2
        DR(I,2)= -2.*ARG*ATEMF
        DI(I,2)= (1.-ARG*ARG)*ATEMF
C.. SLOW EXPONENTIAL DECAY
        ARG=FTEMS*FLOAT(II)
        FR(I,3)= 1./(1.+ARG*ARG)
        FI(I,3)= ARG*FR(I,3)
        ATEMS= CTEM*FLOAT(II)*FR(I,3)**2
        DR(I,3)= -2.*ARG*ATEMS
        DI(I,3)= (1.-ARG*ARG)*ATEMS
C.. GAUSSIAN
        ARG= GTEM*FLOAT(II)
        FR(I,4)= EXP((-0.5)*ARG*ARG)
        FI(I,4)= 0.
        DR(I,4)= -ARG*ARG*FR(I,4)/SIG
        DI(I,4)= 0.
C.. LORENTZIAN
        AFII= ABS(FLOAT(II))
        ARG= CLTEM*AFII
        FR(I,5)= EXP(-ARG)
        FI(I,5)= 0.
        DR(I,5)= -C2TEM*AFII*FR(I,5)
        DI(I,5)= 0.
   1  CONTINUE
C
C.. NOW FORM PRODUCTS IN FOURIER SPACE
      DO 2 I=1,MNS
C LIMITS ARE SPECIFIC TO THIS VERSION WHERE EITHER 4&5 OR 6&7 ARE APPROPRIATE
       DO 3 J=2,NPKGEN(JPHASE,JSOURC) - 2
        CFFT(J)=CMPLX(FR(I,J),FI(I,J))
        DFFT(J)=CMPLX(DR(I,J),DI(I,J))
   3  CONTINUE
        CFE= CFFT(2)*CFFT(4)*CFFT(5)
        CFT= CFFT(3)*CFFT(4)*CFFT(5)
        DDT(2)= SW*DFFT(2)*CFFT(4)*CFFT(5)
        DDT(3)= SW1*DFFT(3)*CFFT(4)*CFFT(5)
        DDT(4)= (SW*CFFT(2)+SW1*CFFT(3))*DFFT(4)*CFFT(5)
        DDT(5)= (SW*CFFT(2)+SW1*CFFT(3))*DFFT(5)*CFFT(4)
C LIMITS ARE SPECIFIC TO THIS VERSION WHERE EITHER 4&5 OR 6&7 ARE APPROPRIATE
         DO 4 J=2,NPKGEN(JPHASE,JSOURC) - 2
         DR(I,J)=REAL(DDT(J))
         DI(I,J)=AIMAG(DDT(J))
   4  CONTINUE
        FRE(I)=REAL(CFE)
        FIE(I)=AIMAG(CFE)
        FRT(I)=REAL(CFT)
        FIT(I)=AIMAG(CFT)
   2  CONTINUE
C
C.. DO INVERSE TRANSFORMS OF FUNCTION AND DERIVATIVES
      INV=1
      CALL FT01A(MNS,INV,FRE,FIE)
      CALL FT01A(MNS,INV,FRT,FIT)
C
C LIMITS ARE SPECIFIC TO THIS VERSION WHERE EITHER 4&5 OR 6&7 ARE APPROPRIATE
       DO 5 J=2,NPKGEN(JPHASE,JSOURC) - 2
   5   CALL FT01A(MNS,INV,DR(1,J),DI(1,J))
C.. WRITE FUNCTION AND DERIVATIVES TO ARRAY PKADD
      XTEM=1./XPKDEL(KMOD)
      DO 6 I=1,MNS
      II=MOD(I+MN2M1,MNS)+1
      PKADD(II,1)=(SW*FRE(I)+SW1*FRT(I))*XTEM
      PKADD(II,2)=(FRE(I)-FRT(I))*XTEM
C STORE IN PKADD AS APPROPRIATE
C      DO 7 J=2,NPKGEN(JPHASE,JSOURC)
C      JJ=J+1
C      PKADD(II,JJ)= DR(I,J)*XTEM
C   7  CONTINUE
C
      PKADD(II,3)= DR(I,2)*XTEM
      PKADD(II,4)= DR(I,3)*XTEM
      IF (ISMAG(KNOW).EQ.0) THEN
        PKADD(II,5)= DR(I,4)*XTEM
        PKADD(II,6)= DR(I,5)*XTEM
        PKADD(II,7)= 0.0
        PKADD(II,8)= 0.0
      ELSE
        PKADD(II,5)= 0.0
        PKADD(II,6)= 0.0
        PKADD(II,7)= DR(I,4)*XTEM
        PKADD(II,8)= DR(I,5)*XTEM
      ENDIF
   6  CONTINUE
C
      RETURN
      END
C
C
C
C
C LEVEL 2      SUBROUTINE FTSUB2(MNS)
      SUBROUTINE FTSUB2(MNS)
C
C *** FTSUB2 by WIFD Jun 88 ***
C
      COMPLEX CFFT,DFFT,DDT,CFE,CFT
/CONSTA/
/PHASE/
/PRPKFN/
/PRSAVF/
/REFLNS/
      COMMON /SCRAT/CFFT(8),DFFT(8),DDT(8),CFE,CFT,
%     1FR(%FFT2%,8),FI(%FFT2%,8),DR(%FFT2%,8),DI(%FFT2%,8),
%     & FRE(%FFT2%),FIE(%FFT2%),FRT(%FFT2%),FIT(%FFT2%)
/SOURCE/
C
      SW=PKFNVA(1)
      TAUF=PKFNVA(2)
      TAUS=PKFNVA(3)
      SIG= PKFNVA(4)
      GAM= PKFNVA(5)
      SW1=1.-SW
C
      C2TEM= PI/(FLOAT(MNS)*XPKDEL(KMOD))
      CTEM=  2.*C2TEM
      FTEMF= CTEM*TAUF
      FTEMS= CTEM*TAUS
      GTEM=  CTEM*SIG
      CLTEM= C2TEM*GAM
C
      MN2=MNS/2
      MN2M1= MN2-1
      MN2P1= MN2+1
      DO 1 I=1,MNS
        II=MOD(I+MN2,MNS)-MN2P1
C.. FAST EXPONENTIAL DECAY
        ARG=FTEMF*FLOAT(II)
        FR(I,2)= 1./(1.+ARG*ARG)
        FI(I,2)= ARG*FR(I,2)
        ATEMF= CTEM*FLOAT(II)*FR(I,2)**2
        DR(I,2)= -2.*ARG*ATEMF
        DI(I,2)= (1.-ARG*ARG)*ATEMF
C.. SLOW EXPONENTIAL DECAY
        ARG=FTEMS*FLOAT(II)
        FR(I,3)= 1./(1.+ARG*ARG)
        FI(I,3)= ARG*FR(I,3)
        ATEMS= CTEM*FLOAT(II)*FR(I,3)**2
        DR(I,3)= -2.*ARG*ATEMS
        DI(I,3)= (1.-ARG*ARG)*ATEMS
C.. GAUSSIAN
        ARG= GTEM*FLOAT(II)
        FR(I,4)= EXP((-0.5)*ARG*ARG)
        FI(I,4)= 0.
        DR(I,4)= -ARG*ARG*FR(I,4)/SIG
        DI(I,4)= 0.
C.. LORENTZIAN
        AFII= ABS(FLOAT(II))
        ARG= CLTEM*AFII
        FR(I,5)= EXP(-ARG)
        FI(I,5)= 0.
        DR(I,5)= -C2TEM*AFII*FR(I,5)
        DI(I,5)= 0.
   1  CONTINUE
C
C.. NOW FORM PRODUCTS IN FOURIER SPACE
      DO 2 I=1,MNS
       DO 3 J=2,NPKGEN(JPHASE,JSOURC)
        CFFT(J)=CMPLX(FR(I,J),FI(I,J))
        DFFT(J)=CMPLX(DR(I,J),DI(I,J))
   3  CONTINUE
        CFE= CFFT(2)*CFFT(4)*CFFT(5)
        CFT= CFFT(3)*CFFT(4)*CFFT(5)
        DDT(2)= SW*DFFT(2)*CFFT(4)*CFFT(5)
        DDT(3)= SW1*DFFT(3)*CFFT(4)*CFFT(5)
        DDT(4)= (SW*CFFT(2)+SW1*CFFT(3))*DFFT(4)*CFFT(5)
        DDT(5)= (SW*CFFT(2)+SW1*CFFT(3))*DFFT(5)*CFFT(4)
        DO 4 J=2,NPKGEN(JPHASE,JSOURC)
         DR(I,J)=REAL(DDT(J))
         DI(I,J)=AIMAG(DDT(J))
   4  CONTINUE
        FRE(I)=REAL(CFE)
        FIE(I)=AIMAG(CFE)
        FRT(I)=REAL(CFT)
        FIT(I)=AIMAG(CFT)
   2  CONTINUE
C
C.. DO INVERSE TRANSFORMS OF FUNCTION AND DERIVATIVES
      INV=1
      CALL FT01A(MNS,INV,FRE,FIE)
      CALL FT01A(MNS,INV,FRT,FIT)
C
      DO 5 J=2,NPKGEN(JPHASE,JSOURC)
   5   CALL FT01A(MNS,INV,DR(1,J),DI(1,J))
C.. WRITE FUNCTION AND DERIVATIVES TO ARRAY PKADD
      XTEM=1./XPKDEL(KMOD)
      DO 6 I=1,MNS
      II=MOD(I+MN2M1,MNS)+1
      PKADD(II,1)=(SW*FRE(I)+SW1*FRT(I))*XTEM
      PKADD(II,2)=(FRE(I)-FRT(I))*XTEM
      DO 7 J=2,NPKGEN(JPHASE,JSOURC)
      JJ=J+1
      PKADD(II,JJ)=DR(I,J)*XTEM
   7  CONTINUE
   6  CONTINUE
C
      RETURN
      END
C
C
C
C
C LEVEL 2      SUBROUTINE FTSUB3(MNS)
      SUBROUTINE FTSUB3(MNS)
C
C *** FTSUB2 by WIFD ***
C
      COMPLEX CFFT,DFFT,DDT,CFE,CFT
/CONSTA/
/PHASE/
/PRPKFN/
/PRSAVF/
/REFLNS/
      COMMON /SCRAT/CFFT(8),DFFT(8),DDT(8),CFE,CFT,
%     1FR(%FFT2%,8),FI(%FFT2%,8),DR(%FFT2%,8),DI(%FFT2%,8),
%     & FRE(%FFT2%),FIE(%FFT2%),FRT(%FFT2%),FIT(%FFT2%)
/SOURCE/
C
      LOGICAL CANSMA
C
      SW=PKFNVA(1)
      TAUF=PKFNVA(2)
      TAUS=PKFNVA(3)
      SIG= PKFNVA(4)
      GAM= PKFNVA(5)
      CAN= PKFNVA(6)
      CANSMA= PKFNVA(6).LT.0.01*XPKDEL(KMOD)
      SW1=1.-SW
C
      C2TEM= PI/(FLOAT(MNS)*XPKDEL(KMOD))
      CTEM=  2.*C2TEM
      FTEMF= CTEM*TAUF
      FTEMS= CTEM*TAUS
      GTEM=  CTEM*SIG
      CLTEM= C2TEM*GAM
      CATEM= CTEM*CAN
C
      MN2=MNS/2
      MN2M1= MN2-1
      MN2P1= MN2+1
      DO 1 I=1,MNS
      II=MOD(I+MN2,MNS)-MN2P1
C.. FAST EXPONENTIAL DECAY
      ARG=FTEMF*FLOAT(II)
      FR(I,2)= 1./(1.+ARG*ARG)
      FI(I,2)= ARG*FR(I,2)
      ATEMF= CTEM*FLOAT(II)*FR(I,2)**2
      DR(I,2)= -2.*ARG*ATEMF
      DI(I,2)= (1.-ARG*ARG)*ATEMF
C.. SLOW EXPONENTIAL DECAY
      ARG=FTEMS*FLOAT(II)
      FR(I,3)= 1./(1.+ARG*ARG)
      FI(I,3)= ARG*FR(I,3)
      ATEMS= CTEM*FLOAT(II)*FR(I,3)**2
      DR(I,3)= -2.*ARG*ATEMS
      DI(I,3)= (1.-ARG*ARG)*ATEMS
C.. GAUSSIAN
      ARG= GTEM*FLOAT(II)
      FR(I,4)= EXP((-0.5)*ARG*ARG)
      FI(I,4)= 0.
      DR(I,4)= -ARG*ARG*FR(I,4)/SIG
      DI(I,4)= 0.
C.. LORENTZIAN
      AFII= ABS(FLOAT(II))
      ARG= CLTEM*AFII
      FR(I,5)= EXP(-ARG)
      FI(I,5)= 0.
      DR(I,5)= -C2TEM*AFII*FR(I,5)
      DI(I,5)= 0.
C.. TRUNCATED QUADRATIC FUNCTION
      ARG= CATEM*FLOAT(II)
      IF (CANSMA .OR. II.EQ.0) THEN
        FR(I,6)=1.
        FI(I,6)=0.75*ARG
        DR(I,6)=0.
        DI(I,6)=0.75*CTEM*FLOAT(II)
      ELSE
        COSARG=COS(ARG)
        SINARG=SIN(ARG)
        OVARG=1./ARG
        CVT1=2.*OVARG*OVARG
        CVT2=OVARG*(1.-CVT1)
        FR(I,6)=3.*(CVT1*COSARG+CVT2*SINARG)
        FI(I,6)=3.*(CVT1*(SINARG-OVARG)-CVT2*COSARG)
        TCAN=3./CAN
        CVT3=1.-3.*CVT1
        CVT4=3.*CVT2
        DR(I,6)=TCAN*(CVT3*COSARG-CVT4*SINARG)
        DI(I,6)=TCAN*(CVT3*SINARG+CVT4*COSARG)
      ENDIF
   1  CONTINUE
C
C
C.. NOW FORM PRODUCTS IN FOURIER SPACE
      DO 2 I=1,MNS
       DO 3 J=2,NPKGEN(JPHASE,JSOURC)
        CFFT(J)=CMPLX(FR(I,J),FI(I,J))
        DFFT(J)=CMPLX(DR(I,J),DI(I,J))
   3  CONTINUE
        CFE= CFFT(2)*CFFT(4)*CFFT(5)*CFFT(6)
        CFT= CFFT(3)*CFFT(4)*CFFT(5)*CFFT(6)
        DDT(2)= SW*DFFT(2)*CFFT(4)*CFFT(5)*CFFT(6)
        DDT(3)= SW1*DFFT(3)*CFFT(4)*CFFT(5)*CFFT(6)
        DDT(4)= (SW*CFFT(2)+SW1*CFFT(3))*DFFT(4)*CFFT(5)*CFFT(6)
        DDT(5)= (SW*CFFT(2)+SW1*CFFT(3))*DFFT(5)*CFFT(4)*CFFT(6)
        DDT(6)= (SW*CFFT(2)+SW1*CFFT(3))*DFFT(6)*CFFT(4)*CFFT(5)
        DO 4 J=2,NPKGEN(JPHASE,JSOURC)
         DR(I,J)=REAL(DDT(J))
         DI(I,J)=AIMAG(DDT(J))
   4  CONTINUE
        FRE(I)=REAL(CFE)
        FIE(I)=AIMAG(CFE)
        FRT(I)=REAL(CFT)
        FIT(I)=AIMAG(CFT)
   2  CONTINUE
C
C.. DO INVERSE TRANSFORMS OF FUNCTION AND DERIVATIVES
      INV=1
      CALL FT01A(MNS,INV,FRE,FIE)
      CALL FT01A(MNS,INV,FRT,FIT)
C
      DO 5 J=2,NPKGEN(JPHASE,JSOURC)
   5   CALL FT01A(MNS,INV,DR(1,J),DI(1,J))
C.. WRITE FUNCTION AND DERIVATIVES TO ARRAY PKADD
      XTEM=1./XPKDEL(KMOD)
      DO 6 I=1,MNS
      II=MOD(I+MN2M1,MNS)+1
      PKADD(II,1)=(SW*FRE(I)+SW1*FRT(I))*XTEM
      PKADD(II,2)=(FRE(I)-FRT(I))*XTEM
      DO 7 J=2,NPKGEN(JPHASE,JSOURC)
      JJ=J+1
      PKADD(II,JJ)=DR(I,J)*XTEM
   7  CONTINUE
   6  CONTINUE
C
      RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE FTSUB4(MNS)
      SUBROUTINE FTSUB4(MNS)
C
C *** FTSUB4 BY WIFD MAY 89***
C
CX
CC 19B
CH
      COMPLEX CFFT,DFFT,DDT,CFE,CFT,CFED,CFEDI,DFED,CIARG,DPED
/CONSTA/
/PHASE/
/PRPKFN/
/PRSAVF/
/REFLNS/
/SOURCE/
      DIMENSION CFFT(8),DFFT(8),DDT(8),
%     1FR(%FFT2%,8),FI(%FFT2%,8),DR(%FFT2%,8),DI(%FFT2%,8),
%     2FRE(%FFT2%),FIE(%FFT2%),FRT(%FFT2%),FIT(%FFT2%)
C
      SW=PKFNVA(1)
      TAUF=PKFNVA(2)
      TAUS=PKFNVA(3)
      SIG= PKFNVA(4)
      GAM= PKFNVA(5)
      POW= PKFNVA(6)
      POW1=POW+1.
      SW1=1.-SW
C
      C2TEM= PI/(FLOAT(MNS)*XPKDEL(KMOD))
      CTEM=  2.*C2TEM
      FTEMF= CTEM*TAUF
      FTEMS= CTEM*TAUS
      GTEM=  CTEM*SIG
      CLTEM= C2TEM*GAM
C
      MN2=MNS/2
      MN2M1= MN2-1
      MN2P1= MN2+1
      DO 1 I=1,MNS
        II=MOD(I+MN2,MNS)-MN2P1
C.. FAST EXPONENTIAL DECAY
        ARG=FTEMF*FLOAT(II)
        CFEDI=CMPLX(1.,-ARG)
        CFED=CFEDI**(-POW1)
        FR(I,2)=REAL(CFED)
        FI(I,2)=AIMAG(CFED)
        CIARG=CMPLX(0.,CTEM*FLOAT(II))
        DFED=POW1*CIARG*CFED/CFEDI
        DR(I,2)=REAL(DFED)
        DI(I,2)=AIMAG(DFED)
        DPED=-CFED*CLOG(CFEDI)
        DR(I,6)=REAL(DPED)
        DI(I,6)=AIMAG(DPED)
C.. SLOW EXPONENTIAL DECAY
        ARG=FTEMS*FLOAT(II)
        FR(I,3)= 1./(1.+ARG*ARG)
        FI(I,3)= ARG*FR(I,3)
        ATEMS= CTEM*FLOAT(II)*FR(I,3)**2
        DR(I,3)= -2.*ARG*ATEMS
        DI(I,3)= (1.-ARG*ARG)*ATEMS
C.. GAUSSIAN
        ARG= GTEM*FLOAT(II)
        FR(I,4)= EXP((-0.5)*ARG*ARG)
        FI(I,4)= 0.
        DR(I,4)= -ARG*ARG*FR(I,4)/SIG
        DI(I,4)= 0.
C.. LORENTZIAN
        AFII= ABS(FLOAT(II))
        ARG= CLTEM*AFII
        FR(I,5)= EXP(-ARG)
        FI(I,5)= 0.
        DR(I,5)= -C2TEM*AFII*FR(I,5)
        DI(I,5)= 0.
   1  CONTINUE
C
C.. NOW FORM PRODUCTS IN FOURIER SPACE
      DO 2 I=1,MNS
       DO 3 J=2,NPKGEN(JPHASE,JSOURC)
        IF(J.NE.6) CFFT(J)=CMPLX(FR(I,J),FI(I,J))
        DFFT(J)=CMPLX(DR(I,J),DI(I,J))
   3  CONTINUE
        CFE= CFFT(2)*CFFT(4)*CFFT(5)
        CFT= CFFT(3)*CFE
        CFED= SW1+SW*CFFT(3)
        DDT(2)= CFED*DFFT(2)*CFFT(4)*CFFT(5)
        DDT(6)= CFED*DFFT(6)*CFFT(4)*CFFT(5)
        DDT(3)= SW*CFFT(2)*DFFT(3)*CFFT(4)*CFFT(5)
        CFED=CFED*CFFT(2)
        DDT(4)= CFED*DFFT(4)*CFFT(5)
        DDT(5)= CFED*CFFT(4)*DFFT(5)
        DO 4 J=2,NPKGEN(JPHASE,JSOURC)
         DR(I,J)=REAL(DDT(J))
         DI(I,J)=AIMAG(DDT(J))
   4  CONTINUE
        FRE(I)=REAL(CFE)
        FIE(I)=AIMAG(CFE)
        FRT(I)=REAL(CFT)
        FIT(I)=AIMAG(CFT)
   2  CONTINUE
C
C.. DO INVERSE TRANSFORMS OF FUNCTION AND DERIVATIVES
      INV=1
      CALL FT01A(MNS,INV,FRE,FIE)
      CALL FT01A(MNS,INV,FRT,FIT)
C
      DO 5 J=2,NPKGEN(JPHASE,JSOURC)
   5   CALL FT01A(MNS,INV,DR(1,J),DI(1,J))
C.. WRITE FUNCTION AND DERIVATIVES TO ARRAY PKADD
      XTEM=1./XPKDEL(KMOD)
      DO 6 I=1,MNS
      II=MOD(I+MN2M1,MNS)+1
      PKADD(II,1)=(SW1*FRE(I)+SW*FRT(I))*XTEM
      PKADD(II,2)=(FRT(I)-FRE(I))*XTEM
      DO 7 J=2,NPKGEN(JPHASE,JSOURC)
      JJ=J+1
      PKADD(II,JJ)=DR(I,J)*XTEM
   7  CONTINUE
   6  CONTINUE
C
      RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE FTSUB5(MNS)
      SUBROUTINE FTSUB5(MNS)
C
C *** FTSUB5 by WIFD Jun 88 ***
C
      COMPLEX CFFT,DFFT,DDT,CFE,CFT,CTM1,CTM2,CFE2,CFT2,CF67
/CONSTA/
/PHASE/
/PRPKFN/
/PRSAVF/
/REFLNS/
      COMMON /SCRAT/CFFT(8),DFFT(8),DDT(8),CFE,CFT,
%     & FR(%FFT2%,8),FI(%FFT2%,8),DR(%FFT2%,8),DI(%FFT2%,8),
%     & FRE(%FFT2%),FIE(%FFT2%),FRT(%FFT2%),FIT(%FFT2%),
%     & FRE2(%FFT2%),FIE2(%FFT2%),FRT2(%FFT2%),FIT2(%FFT2%)
/SOURCE/
C
      SW=PKFNVA(1)
      TAUF=PKFNVA(2)
      TAUS=PKFNVA(3)
      SIG= PKFNVA(4)
      GAM= PKFNVA(5)
      ESIG=PKFNVA(6)
      SHFT=PKFNVA(7)
      SZ=PKFNVA(8)
      SW1=1.-SW
      SZ1=1.-SZ
C
      C2TEM= PI/(FLOAT(MNS)*XPKDEL(KMOD))
      CTEM=  2.*C2TEM
      FTEMF= CTEM*TAUF
      FTEMS= CTEM*TAUS
      GTEM=  CTEM*SIG
      CLTEM= C2TEM*GAM
      EGTEM= CTEM*ESIG
      STEM=  CTEM*SHFT
C
      MN2=MNS/2
      MN2M1= MN2-1
      MN2P1= MN2+1
      DO 1 I=1,MNS
        II=MOD(I+MN2,MNS)-MN2P1
C.. FAST EXPONENTIAL DECAY
        ARG=FTEMF*FLOAT(II)
        FR(I,2)= 1./(1.+ARG*ARG)
        FI(I,2)= ARG*FR(I,2)
        ATEMF= CTEM*FLOAT(II)*FR(I,2)**2
        DR(I,2)= -2.*ARG*ATEMF
        DI(I,2)= (1.-ARG*ARG)*ATEMF
C.. SLOW EXPONENTIAL DECAY
        ARG=FTEMS*FLOAT(II)
        FR(I,3)= 1./(1.+ARG*ARG)
        FI(I,3)= ARG*FR(I,3)
        ATEMS= CTEM*FLOAT(II)*FR(I,3)**2
        DR(I,3)= -2.*ARG*ATEMS
        DI(I,3)= (1.-ARG*ARG)*ATEMS
C.. GAUSSIAN
        ARG= GTEM*FLOAT(II)
        FR(I,4)= EXP((-0.5)*ARG*ARG)
        FI(I,4)= 0.
        DR(I,4)= -ARG*ARG*FR(I,4)/SIG
        DI(I,4)= 0.
C.. LORENTZIAN
        AFII= ABS(FLOAT(II))
        ARG= CLTEM*AFII
        FR(I,5)= EXP(-ARG)
        FI(I,5)= 0.
        DR(I,5)= -C2TEM*AFII*FR(I,5)
        DI(I,5)= 0.
C.. EXTRA GAUSSIAN
        ARG= EGTEM*FLOAT(II)
        FR(I,6)= EXP((-0.5)*ARG*ARG)
        FI(I,6)= 0.
        IF (ESIG .EQ. 0.) THEN
          DR(I,6)=0.
        ELSE
          DR(I,6)= -ARG*ARG*FR(I,6)/ESIG
        END IF
        DI(I,6)= 0.
C.. SHIFT
        ARG= STEM*FLOAT(II)
        FR(I,7)= COS(ARG)
        FI(I,7)= SIN(ARG)
        DR(I,7)=-CTEM*FI(I,7)
        DI(I,7)= CTEM*FR(I,7)
   1  CONTINUE
C
C.. NOW FORM PRODUCTS IN FOURIER SPACE
      DO 2 I=1,MNS
       DO 3 J=2,NPKGEN(JPHASE,JSOURC)-1
        CFFT(J)=CMPLX(FR(I,J),FI(I,J))
        DFFT(J)=CMPLX(DR(I,J),DI(I,J))
   3  CONTINUE
        CF67=CFFT(6)*CFFT(7)
        CTM1=SZ+SZ1*CF67
        CFE= CFFT(2)*CFFT(4)*CFFT(5)
        CFT= CFFT(3)*CFFT(4)*CFFT(5)
        CFE2= CFE*CF67
        CFT2= CFT*CF67
        DDT(2)= SW*DFFT(2)*CFFT(4)*CFFT(5)*CTM1
        DDT(3)= SW1*DFFT(3)*CFFT(4)*CFFT(5)*CTM1
        DDT(4)= (SW*CFFT(2)+SW1*CFFT(3))*DFFT(4)*CFFT(5)*CTM1
        DDT(5)= (SW*CFFT(2)+SW1*CFFT(3))*DFFT(5)*CFFT(4)*CTM1
        CTM2= SZ1*(SW*CFFT(2)+SW1*CFFT(3))*CFFT(4)*CFFT(5)
        DDT(6)= CTM2*DFFT(6)*CFFT(7)
        DDT(7)= CTM2*CFFT(6)*DFFT(7)
        DO 4 J=2,NPKGEN(JPHASE,JSOURC)-1
         DR(I,J)=REAL(DDT(J))
         DI(I,J)=AIMAG(DDT(J))
   4  CONTINUE
        FRE(I)=REAL(CFE)
        FIE(I)=AIMAG(CFE)
        FRT(I)=REAL(CFT)
        FIT(I)=AIMAG(CFT)
        FRE2(I)=REAL(CFE2)
        FIE2(I)=AIMAG(CFE2)
        FRT2(I)=REAL(CFT2)
        FIT2(I)=AIMAG(CFT2)
   2  CONTINUE
C
C.. DO INVERSE TRANSFORMS OF FUNCTION AND DERIVATIVES
      INV=1
      CALL FT01A(MNS,INV,FRE,FIE)
      CALL FT01A(MNS,INV,FRT,FIT)
      CALL FT01A(MNS,INV,FRE2,FIE2)
      CALL FT01A(MNS,INV,FRT2,FIT2)
C
      DO 5 J=2,NPKGEN(JPHASE,JSOURC)-1
   5   CALL FT01A(MNS,INV,DR(1,J),DI(1,J))
C.. WRITE FUNCTION AND DERIVATIVES TO ARRAY PKADD
      XTEM=1./XPKDEL(KMOD)
      DO 6 I=1,MNS
      II=MOD(I+MN2M1,MNS)+1
      SFE=SZ*FRE(I)+SZ1*FRE2(I)
      SFT=SZ*FRT(I)+SZ1*FRT2(I)
      PKADD(II,1)=(SW*SFE+SW1*SFT)*XTEM
      PKADD(II,2)=(SFE-SFT)*XTEM
      DO 7 J=2,NPKGEN(JPHASE,JSOURC)-1
      JJ=J+1
      PKADD(II,JJ)=DR(I,J)*XTEM
   7  CONTINUE
      PKADD(II,NPKGEN(JPHASE,JSOURC)+1)=
     &((SW*FRE(I)+SW1*FRT(I))-(SW*FRE2(I)+SW1*FRT2(I)))*XTEM
   6  CONTINUE
C
      RETURN
      END
C
C
C
C
C LEVEL 2      SUBROUTINE FTSUB8(MNS)
      SUBROUTINE FTSUB8(MNS)
C
C *** FTSUB8 (formerly 4) by WIFD May 89 ***
C
      COMPLEX CFFT,DFFT,DDT,CFE,CFT
/CONSTA/
/PHASE/
/PRPKFN/
/PRSAVF/
/REFLNS/
      COMMON /SCRAT/CFFT(8),DFFT(8),DDT(8),CFE,CFT,
%     1FR(%FFT2%,8),FI(%FFT2%,8),DR(%FFT2%,8),DI(%FFT2%,8),
%     & FRE(%FFT2%),FIE(%FFT2%),FRT(%FFT2%),FIT(%FFT2%)
/SOURCE/
C
      SW=PKFNVA(1)
      TAUF=PKFNVA(2)
      TAUS=PKFNVA(3)
      SIG= PKFNVA(4)
      GAM1= PKFNVA(5)
      GAM2= PKFNVA(6)
      SW1=1.-SW
C
      C2TEM= PI/(FLOAT(MNS)*XPKDEL(KMOD))
      CTEM=  2.*C2TEM
      FTEMF= CTEM*TAUF
      FTEMS= CTEM*TAUS
      GTEM=  CTEM*SIG
      CLTEM1= C2TEM*GAM1
      CLTEM2= C2TEM*GAM2
C
      MN2=MNS/2
      MN2M1= MN2-1
      MN2P1= MN2+1
      DO 1 I=1,MNS
        II=MOD(I+MN2,MNS)-MN2P1
C.. FAST EXPONENTIAL DECAY
        ARG=FTEMF*FLOAT(II)
        FR(I,2)= 1./(1.+ARG*ARG)
        FI(I,2)= ARG*FR(I,2)
        ATEMF= CTEM*FLOAT(II)*FR(I,2)**2
        DR(I,2)= -2.*ARG*ATEMF
        DI(I,2)= (1.-ARG*ARG)*ATEMF
C.. SLOW EXPONENTIAL DECAY
        ARG=FTEMS*FLOAT(II)
        FR(I,3)= 1./(1.+ARG*ARG)
        FI(I,3)= ARG*FR(I,3)
        ATEMS= CTEM*FLOAT(II)*FR(I,3)**2
        DR(I,3)= -2.*ARG*ATEMS
        DI(I,3)= (1.-ARG*ARG)*ATEMS
C.. GAUSSIAN
        ARG= GTEM*FLOAT(II)
        FR(I,4)= EXP((-0.5)*ARG*ARG)
        FI(I,4)= 0.
        DR(I,4)= -ARG*ARG*FR(I,4)/SIG
        DI(I,4)= 0.
C.. LORENTZIAN - STRAIN
        AFII= ABS(FLOAT(II))
        ARG= CLTEM1*AFII
        FR(I,5)= EXP(-ARG)
        FI(I,5)= 0.
        DR(I,5)= -C2TEM*AFII*FR(I,5)
        DI(I,5)= 0.
C.. LORENTZIAN - PARTICLE SIZE
        AFII= ABS(FLOAT(II))
        ARG= CLTEM2*AFII
        FR(I,6)= EXP(-ARG)
        FI(I,6)= 0.
        DR(I,6)= -C2TEM*AFII*FR(I,6)
        DI(I,6)= 0.
   1  CONTINUE
C
C.. NOW FORM PRODUCTS IN FOURIER SPACE
      DO 2 I=1,MNS
       DO 3 J=2,NPKGEN(JPHASE,JSOURC)
        CFFT(J)=CMPLX(FR(I,J),FI(I,J))
        DFFT(J)=CMPLX(DR(I,J),DI(I,J))
   3  CONTINUE
        CFE= CFFT(2)*CFFT(4)*CFFT(5)*CFFT(6)
        CFT= CFFT(3)*CFFT(4)*CFFT(5)*CFFT(6)
        DDT(2)= SW*DFFT(2)*CFFT(4)*CFFT(5)*CFFT(6)
        DDT(3)= SW1*DFFT(3)*CFFT(4)*CFFT(5)*CFFT(6)
        DDT(4)= (SW*CFFT(2)+SW1*CFFT(3))*DFFT(4)*CFFT(5)*CFFT(6)
        DDT(5)= (SW*CFFT(2)+SW1*CFFT(3))*DFFT(5)*CFFT(4)*CFFT(6)
        DDT(6)= (SW*CFFT(2)+SW1*CFFT(3))*DFFT(6)*CFFT(4)*CFFT(5)
        DO 4 J=2,NPKGEN(JPHASE,JSOURC)
         DR(I,J)=REAL(DDT(J))
         DI(I,J)=AIMAG(DDT(J))
   4  CONTINUE
        FRE(I)=REAL(CFE)
        FIE(I)=AIMAG(CFE)
        FRT(I)=REAL(CFT)
        FIT(I)=AIMAG(CFT)
   2  CONTINUE
C
C.. DO INVERSE TRANSFORMS OF FUNCTION AND DERIVATIVES
      INV=1
      CALL FT01A(MNS,INV,FRE,FIE)
      CALL FT01A(MNS,INV,FRT,FIT)
C
      DO 5 J=2,NPKGEN(JPHASE,JSOURC)
   5   CALL FT01A(MNS,INV,DR(1,J),DI(1,J))
C.. WRITE FUNCTION AND DERIVATIVES TO ARRAY PKADD
      XTEM=1./XPKDEL(KMOD)
      DO 6 I=1,MNS
      II=MOD(I+MN2M1,MNS)+1
      PKADD(II,1)=(SW*FRE(I)+SW1*FRT(I))*XTEM
      PKADD(II,2)=(FRE(I)-FRT(I))*XTEM
      DO 7 J=2,NPKGEN(JPHASE,JSOURC)
      JJ=J+1
      PKADD(II,JJ)=DR(I,J)*XTEM
   7  CONTINUE
   6  CONTINUE
C
      RETURN
      END
C
C
C
C
C LEVEL 3      SUBROUTINE PCCN01(N)
      SUBROUTINE PCCN01(N)
C
C *** PCCN01 updated by JCM 28 Feb 88 ***
C
CH Multiple entry routine to deal with the Peak centre for Constant Wavelength
CA On entry N requests one of the following:
CA N=1: (Not used yet) read L PKCN card
CA N=2: Calculate Peak Centre in ARGK, and its derivatives
CA N=3: (Not used yet) apply shifts
CA N=4: (Not used yet) write new card
CA N=5: Calculate Peak Centre in ARGK alone
CA N=6: Set SRGK=maximum sin theta/lambda, given ARGMAX(JSOURC) = max 2theta.
CA N=7: (Not used yet) set up to use PFXX(7)
CP For entries 2,5, ALAMBD(1,JSOURC) must hold lambda, and DSTAR(KNOW) d*
C
/BRAGG/
/CONSTA/
/DGEOM/
/F4PARS/
/IOUNIT/
/NEWOLD/
/PHASE/
/PRPKCN/
/PRZERO/
/REFLNS/
/SOURCE/
C
      GO TO(1,2,100,100,2,6,100) , N
   1  CALL RDREAL(ALAMBD(1,KSOURC),7,IPT,80,IER)
      WRITE(LPT,2002) 1,(ALAMBD(I,KSOURC),I=1,NLAMB)
2002  FORMAT (' ',I3,' Wavelength(s): ',5(1X,F9.6))
      DO 11 I=1,NPHASE
       PKCNSP(1,I,KSOURC)=ALAMBD(1,KSOURC)
       NPKCSP(I,KSOURC)=1
  11  CONTINUE
      GO TO 100
C N=2OR 5:
C ARGK=ZERO+ARCSIN(......)
   2  TEM=0.5*ALAMBD(1,JSOURC)*DSTAR(KNOW)
C REMEMBER, 2THETA:
      ARGK=ZEROSP(1,JPHASE,JSOURC)+2.*DEG*ASIN(TEM)
      IF (N .EQ. 5) GO TO 100
C CHAIN RULE: D(ARGK)/D(D*)SQ = D(ARGK)/D(D*) * D(D*)/D(D*)SQ
      DKDDS=0.5*ALAMBD(1,JSOURC)/(DSTAR(KNOW)*SQRT(1.-TEM*TEM))
C      DKDDS=0.5*ALAMBD(1,JSOURC)*ALAMBD(1,JSOURC)/SIN(RAD*ARGK)
C CONVERSION FACTOR...
      DKDDS=DEGREE(DKDDS)
      DKDZER(1)=1.
      GO TO 100
C
C MAX SIN THETA/LAMBDA:
   6  STHMXX(JSOURC)=SIN(RADIAN(ARGMAX(JSOURC)/2.))/ALAMBD(1,JSOURC)
  100 RETURN
      END
C
C
C
C
C LEVEL 3      SUBROUTINE PCCN02(N)
      SUBROUTINE PCCN02(N)
C
C *** PCCN02 based on PCCN01 with the ability to refine
C the wavelength (PKCN 1) JPW MARCH 2001
C
CH Multiple entry routine to deal with the Peak centre for Constant Wavelength
CA On entry N requests one of the following:
CA N=1: read L WVLN card
CA N=2: Calculate Peak Centre in ARGK, and its derivatives
CA N=3: (Not used yet) apply shifts
CA N=4: write new card
CA N=5: Calculate Peak Centre in ARGK alone
CA N=6: Set SRGK=maximum sin theta/lambda, given ARGMAX(JSOURC) = max 2theta.
CA N=7: (Not used yet) set up to use PFXX(7)
CP For entries 2,5, ALAMBD(1,JSOURC) must hold lambda, and DSTAR(KNOW) d*
C
/BRAGG/
/CONSTA/
/DGEOM/
/F4PARS/
/IOUNIT/
/NEWOLD/
/PHASE/
/PRPKCN/
/PRZERO/
/REFLNS/
/SOURCE/
C
      GO TO(1,2,3,4,2,6,100) , N
C
   1  CALL RDREAL(ALAMBD(1,KSOURC),7,IPT,80,IER)
C   1  CALL RDREAL(ALAMBD(1,KSOURC),7,IPT,NLAMB,IER)
      WRITE(LPT,2002) NLAMB,(ALAMBD(I,KSOURC),I=1,NLAMB)
2002  FORMAT (' ',I3,' Wavelength(s): ',5(1X,F9.6))
      DO 11 I=1,NPHASE
       PKCNSP(1,I,KSOURC)=ALAMBD(1,KSOURC)
       NPKCSP(I,KSOURC)=1
  11  CONTINUE
      GO TO 100
C N=2 OR 5:
C ARGK=ZERO+ARCSIN(......)
   2  TEM=0.5*ALAMBD(1,JSOURC)*DSTAR(KNOW)
C REMEMBER, 2THETA:
      ARGK=ZEROSP(1,JPHASE,JSOURC)+2.*DEG*ASIN(TEM)
      IF (N .EQ. 5) GO TO 100
C CHAIN RULE: D(ARGK)/D(D*)SQ = D(ARGK)/D(D*) * D(D*)/D(D*)SQ
      DKDDS=0.5*ALAMBD(1,JSOURC)/(DSTAR(KNOW)*SQRT(1.-TEM*TEM))
C      DKDDS=0.5*ALAMBD(1,JSOURC)*ALAMBD(1,JSOURC)/SIN(RAD*ARGK)
C CONVERSION FACTOR...
      DKDDS=DEGREE(DKDDS)
      DTDPCN(1)=DSTAR(KNOW)/SQRT(1-TEM*TEM)
      DTDPCN(1)=DEGREE(DTDPCN(1))
      DKDZER(1)=1.
      GO TO 100
   3  CALL ADJUST(PKCNSP(ISPC,JPHASE,JSOURC))
      ALAMBD(1,JSOURC)=PKCNSP(1,JPHASE,JSOURC)
      IF(NPHASE.GT.1) THEN
        DO 33 I=2,NPHASE
          PKCNSP(1,I,JSOURC)=ALAMBD(1,JSOURC)
  33    CONTINUE
      ENDIF
      GO TO 100
C
   4  WRITE (NEWIN,2001) PKCNSP(1,JPHASE,JSOURC)
2001  FORMAT ('L WVLN',F11.7)
      GO TO 100
C
C MAX SIN THETA/LAMBDA:
   6  STHMXX(JSOURC)=SIN(RADIAN(ARGMAX(JSOURC)/2.))/ALAMBD(1,JSOURC)
  100 RETURN
      END
C
C
C
C
C LEVEL 3      SUBROUTINE PCLX01(N)
      SUBROUTINE PCLX01(N)
C
C *** PCLX01 updated by WIFD/JCM 28 Feb 88 ***
C
CH Multiple entry routine to deal with Peak centres for X-Ray:
CA On entry N requests one of the following:
CA N=1: (Not yet used) read L PKCN card
CA N=2: calculate Peak Centre, ARGK, and its derivative wrt ZERO
CA N=3: (Not yet used) apply shifts
CA N=4: (Not yet used) write new card
CA N=5: calculate Peak Centre, ARGK
CA N=6: Calculate maximum sin theta/lambda from maximum 2theta
CA N=7: (Not yet used) prepare to call PFXX(7)
C
/BRAGG/
/DGEOM/
/IOUNIT/
/NEWOLD/
/PHASE/
/PRPKCN/
/PRZERO/
/REFLNS/
/SOURCE/
      COMMON /XRAYC/ ARGK2
C
      GO TO (100,2,100,100,2,6,100) , N
C
C N=2 OR 5:
C ARGK=ZERO+ARCSIN(......)
   2  TEM1=0.5*ALAMBD(1,JSOURC)*DSTAR(KNOW)
      TEM2=0.5*ALAMBD(2,JSOURC)*DSTAR(KNOW)
C REMEMBER, 2THETA:
      ARGK=ZEROSP(1,JPHASE,JSOURC)+2.*DEGREE(ASIN(TEM1))
      ARGK2=ZEROSP(1,JPHASE,JSOURC)+2.*DEGREE(ASIN(TEM2))
      IF (N .EQ. 5) GO TO 100
C CHAIN RULE: D(ARGK)/D(D*)SQ = D(ARGK)/D(D*) * D(D*)/D(D*)SQ
      DKDDS=DEGREE(0.5*ALAMBD(1,JSOURC)
     & /(DSTAR(KNOW)*SQRT(1.-TEM1*TEM2)))
      DKDZER(1)=1.
      GO TO 100
C
C MAX SIN THETA/LAMBDA:
   6  STHMXX(JSOURC)=SIN(RADIAN(ARGMAX(JSOURC)/2.))/ALAMBD(1,JSOURC)
  100 RETURN
      END
C
C
C
C
C LEVEL 6      SUBROUTINE PCTF01(N)
      SUBROUTINE PCTF01(N)
C
C *** PCTF01 updated by JCM 28 Feb 88 ***
C
CH Multiple entry routine dealing with all aspects of peak centre parameters
CA On entry N requests one of the following:
CA N=1: Read 2 peak centre parameters from an L PKCN card
CA N=2: Calculate Peak Centre, ARGK, i.e. time of flight k, and its
CA      derivatives wrt ZERO, the Peak Centre parameters and the wavelength.
CA N=3: Apply shift to parameter ISPC
CA N=4:Write out new L PKCN card
CA N=5: Calculate Peak Centre, ARGK, i.e. time of flight k
CA N=6: Calculate STHLMX, max sin theta/lambda, from the minimum tof
CA N=7: Calculate ALAMBD(1,JSOURC) = lambda given d* in DSTAR(KNOW)
C
CP Entries 2,5 and 7 require DSTAR(KNOW)=d*
CP Entry 6 requires ARGK=minimum tof
C
/BRAGG/
/DGEOM/
/IOUNIT/
/NEWOLD/
/PHASE/
/PRPKCN/
/PRZERO/
/REFLNS/
/SOURCE/
C
      GO TO (1,2,3,4,2,6,2) , N
C
C GIVEN AN 'L PKCN' CARD IN COMMON /SCRACH/, READ REST OF IT:
C 90.60 make this read into phase 1 and copy to other phases if necessary.
C All phases will have same pkcn, like it or not for now!
   1  CALL RDREAL(PKCNSP(1,1,KSOURC),7,IPT,80,IER)
      CALL RDREAL(PKCNSP(2,1,KSOURC),IPT,IPT,80,IER)
      WRITE (LPT,2000) PKCNSP(1,1,KSOURC),PKCNSP(2,1,KSOURC)
2000  FORMAT (/' Total flightpath = ',F12.5,' metres '/
     & ' Apparent flightpath/wavelength variation equivalent to '/
     & '  ',F12.5,' microseconds (T-o-f) per Angstrom squared ')
      NPKCSP(1,KSOURC)=2
      IF (NPHASE.GT.1) THEN
      DO 11 I=2,NPHASE
       PKCNSP(1,I,KSOURC)=PKCNSP(1,1,KSOURC)
       PKCNSP(2,I,KSOURC)=PKCNSP(2,1,KSOURC)
       NPKCSP(I,KSOURC)=2
  11  CONTINUE
      ENDIF
      PCON=252.777
      GO TO 100
C
C ENTRIES 2,5,7:
   2  ALAMBD(1,JSOURC)=TWSNTH(JSOURC)/DSTAR(KNOW)
      IF (N .EQ. 7) GO TO 100
      IF (N .EQ. 5) GO TO 5
C DERIVATIVE OF T (ARGK) WRT ZERO POINT:
      DKDZER(1)= 1.
C DERIVATIVE OF T (ARGK) WRT FIRST PEAK CENTRE PARAMETER:
      DTDPCN(1)= ALAMBD(1,JSOURC)*PCON
C DERIVATIVE OF T (ARGK) WRT SECOND PEAK CENTRE PARAMETER:
      DTDPCN(2)= ALAMBD(1,JSOURC)*ALAMBD(1,JSOURC)
C DERIVATIVE OF T (ARGK) WRT WAVELENGTH:
      DTDWL=PKCNSP(1,JPHASE,JSOURC)*PCON +
     & 2.*ALAMBD(1,JSOURC)*PKCNSP(2,JPHASE,JSOURC)
C ENTRY 5: CALCULATE ARGK
   5  ARGK= ZEROSP(1,JPHASE,JSOURC) + PCON*PKCNSP(1,JPHASE,JSOURC)*
     & ALAMBD(1,JSOURC) +
     & PKCNSP(2,JPHASE,JSOURC)*ALAMBD(1,JSOURC)*ALAMBD(1,JSOURC)
      GO TO 100
C
C APPLY SHIFT IN COEFFICIENT:
   3  CALL ADJUST(PKCNSP(ISPC,JPHASE,JSOURC))
      GO TO 100
C
C WRITE OUT NEW 'L PKCN' CARD FOR TOF:
   4  WRITE (NEWIN,2001) PKCNSP(1,JPHASE,JSOURC),PKCNSP(2,JPHASE,JSOURC)
2001  FORMAT ('L PKCN',2F10.4)
      GO TO 100
C
C MAKE STHLMX FROM TMIN (IN ARGK)
   6  STHMXX(JSOURC)=SINTH*PKCNSP(1,JPHASE,JSOURC)*PCON/(ARGMIN(JSOURC)
     & -ZEROSP(1,JPHASE,JSOURC))
 100  RETURN
      END
C
C
C
C
C LEVEL 6      SUBROUTINE PCTF91(N)
      SUBROUTINE PCTF91(N)
C
C *** PCTF91 updated by JCM 28 Feb 88 ***
C
CH Multiple entry routine dealing with all aspects of peak centre parameters
CA On entry N requests one of the following:
CA N=1: Read 2 peak centre parameters from an L PKCN card
CA N=2: Calculate Peak Centre, ARGK, i.e. time of flight k, and its
CA      derivatives wrt ZERO, the Peak Centre parameters and the wavelength.
CA N=3: Apply shift to parameter ISPC
CA N=4:Write out new L PKCN card
CA N=5: Calculate Peak Centre, ARGK, i.e. time of flight k
CA N=6: Calculate STHLMX, max sin theta/lambda, from the minimum tof
CA N=7: Calculate ALAMBD(1,JSOURC) = lambda given d* in DSTAR(KNOW)
CA N=8: Calculate ALAMBD(1,JSOURC) = lambda given ARGK
C
CP Entries 2,5 and 7 require DSTAR(KNOW)=d*
CP Entry 6 requires ARGK=minimum tof
C
/BRAGG/
/DGEOM/
/IOUNIT/
/NEWOLD/
/PHASE/
/PRPKCN/
/PRZERO/
/REFLNS/
/SOURCE/
C
      GO TO (1,2,3,4,2,6,2,8) , N
C
C GIVEN AN 'L PKCN' CARD IN COMMON /SCRACH/, READ REST OF IT:
   1  CALL RDREAL(PKCNSP(1,JPHASE,JSOURC),7,IPT,80,IER)
      CALL RDREAL(PKCNSP(2,JPHASE,JSOURC),IPT,IPT,80,IER)
      WRITE (LPT,2000) PKCNSP(1,JPHASE,JSOURC),PKCNSP(2,JPHASE,JSOURC)
2000  FORMAT (/' Peak Centre Parameters =',2F10.4)
      NPKCSP(JPHASE,JSOURC)=2
      PCON=252.777
      GO TO 100
C
C ENTRIES 2,5,7:
   2  ALAMBD(1,JSOURC)=TWSNTH(JSOURC)/DSTAR(KNOW)
      IF (N .EQ. 7) GO TO 100
      IF (N .EQ. 5) GO TO 5
C DERIVATIVE OF T (ARGK) WRT ZERO POINT:
      DKDZER(1)= 1.
C DERIVATIVE OF T (ARGK) WRT FIRST PEAK CENTRE PARAMETER:
      DTDPCN(1)= ALAMBD(1,JSOURC)*PCON
C DERIVATIVE OF T (ARGK) WRT SECOND PEAK CENTRE PARAMETER:
      DTDPCN(2)= ALAMBD(1,JSOURC)*ALAMBD(1,JSOURC)
C DERIVATIVE OF T (ARGK) WRT WAVELENGTH:
      DTDWL=PKCNSP(1,JPHASE,JSOURC)*PCON +
     & 2.*ALAMBD(1,JSOURC)*PKCNSP(2,JPHASE,JSOURC)
C ENTRY 5: CALCULATE ARGK
   5  ARGK= ZEROSP(1,JPHASE,JSOURC) + PCON*PKCNSP(1,JPHASE,JSOURC)*
     & ALAMBD(1,JSOURC) +
     & PKCNSP(2,JPHASE,JSOURC)*ALAMBD(1,JSOURC)*ALAMBD(1,JSOURC)
      GO TO 100
C
C APPLY SHIFT IN COEFFICIENT:
   3  CALL ADJUST(PKCNSP(ISPC,JPHASE,JSOURC))
      GO TO 100
C
C WRITE OUT NEW 'L PKCN' CARD FOR TOF:
   4  WRITE (NEWIN,2001) PKCNSP(1,JPHASE,JSOURC),PKCNSP(2,JPHASE,JSOURC)
2001  FORMAT ('L PKCN',2F10.4)
      GO TO 100
C
C MAKE STHLMX FROM TMIN (IN ARGK)
   6  STHMXX(JSOURC)=SINTH*PKCNSP(1,JPHASE,JSOURC)*PCON/(ARGMIN(JSOURC)
     & -ZEROSP(1,JPHASE,JSOURC))
      GO TO 100
C
C CALCULATES ALAMBD(1,JSOURC) GIVEN ARGK : USED IN INITIAL CALCULATION OF
C PEAKSHAPE FOR SUBSEQUENT INTERPOLATION
   8  BTEM=PKCNSP(1,JPHASE,JSOURC)*PCON
      RAT1=(ARGK-ZEROSP(1,JPHASE,JSOURC))/BTEM
      RAT2=PKCNSP(2,JPHASE,JSOURC)/BTEM
      ALAMBD(1,JSOURC)=RAT1*(1.-RAT1*RAT2)
      GO TO 100
C
 100  RETURN
      END
C
C
C
C
C LEVEL 6      SUBROUTINE PFCN01(N)
      SUBROUTINE PFCN01(N)
C
C *** PFCN01 updated by JCM 27 May 89 ***
C
CH Multiple entry routine to do various calculations for constant
CH wavelength data, Gaussian peak
CA On entry N=1,2,5,6, or 7
CA N=1 asks to initialise the program to do CN, peak function 01
CA N=2 form peak function in YNORM, and its derivatives wrt parameters
CA N=5: Sets LOGICAL REFUSE to determine if reflection makes a significant
CA      contribution to the profile at ARGI
CA N=6: CAILS entry to determine whether near reflections should be related
CA      by a strict or slack relationship.
CA N=7: SAPS entry to obey FDXXXX to set up a value(s) for PKFNVA
C
/F4PARS/
/PAWLPR/
/PHASE/
/PRBLEM/
/PRPKCN/
/PRPKFN/
/PWORDS/
/REFLNS/
/SOURCE/
C
      PARAMETER (NW=4)
      CHARACTER *4 WDCN01(NW)
      DIMENSION IWCN01(3,NW)
      DATA WDCN01/'SIGM','U','V','W'/
      DATA IWCN01/3,3,0, 3,3,1, 3,3,2, 3,3,3/
C
      GO TO (10,1,2,100,100,5,6,7) , N+1
C
C N=0: SET UP "DATA SOURCE CN, PEAK TYPE 01"
  10  NPKGEN(JPHASE,JSOURC)=1
**?? SORT OUT NGEN4
      NGEN4(JPHASE,JSOURC)=2
      LF3SP(3,JPHASE,JSOURC)=3
      LF6SP(1,JSOURC)=1
      DO 11 I=1,NPKGEN(JPHASE,JSOURC)
  11  PWD(I,JPHASE,JSOURC)=WDCN01(I)
      GO TO 100
C
C N=1: ADD PACKED VOCABULARY FOR THIS SOURCE, THIS PHASE, TO THE MAIN LIST:
   1  CALL VOCAB(WDCN01,IWCN01,NW)
      GO TO 100
C
C N=2: PROFILE REFINEMENT STAGE
    2 CALL FDCN01(2)
      DEL=ARGI-ARGK
      SIGDSQ=1./PKFNVA(1)
C 90.40
      IF (SIGDSQ .LT. 0.)
     & CALL ERRRE2(ARGI,-1,'Error ** SIGDSQ < 0.0 for ARGI',' Exiting')
      DELSQ=DEL*DEL
      ARGTEM=DELSQ*SIGDSQ
      ANORM=SQRT(SIGDSQ*0.159154943)
      YNORM=ANORM*EXP((-0.5)*ARGTEM)
C
C DYNDKQ IS THE DERIVATIVE OF YNORM WRT TK (ARGK), DIVIDED BY YNORM.  THE 6
C LETTER NAME DOES NOT ALLOW US TO EXPRESS ALL THIS, BUT THE Q IS IMPORTANT
C BECAUSE IT INDICATES 'QUOTIENT', IE THE DERIVATIVE IS DIVIDED BY THE FUNCTION
C
C FIRST, (1/Y)(DY/D(ARGK))  K MEANS WRT ARGK
C THIS COMES FROM (1/Y)*(DY/D(DEL))*(D(DEL)/(D(ARGK))
C THUS, NO NEGATIVE SIGN
      DYNDKQ=DEL*SIGDSQ
C THEN, (1/Y)(DY/D(SIGMA-SQUARED))
      DYNDVQ(1)=0.5*SIGDSQ*(ARGTEM-1.)
      GO TO 100
C
C N=5: IS REFLECTION IN RANGE?
    5 CALL FDCN01(1)
      DEL=ARGI-ARGK
      TEMSQ=TOLER(1,JPHASE,JSOURC)*PKFNVA(1)
      REFUSE=DEL*DEL.GT.TEMSQ
      GO TO 100
C
C N=6 *** CAILS *** SETTING UP SLACK AND STRICT CONSTRAINTS
C
    6 CALL FDCN01(1)
      DELT=ABS(AKLO-AKHI)
      STRKT = DELT .LE. STRTOL*PKFNVA(1)
      SLACK=0.
      IF (DELT .GE. SLKTOL*PKFNVA(1)) GO TO 100
      SLACK=EXP(1.-(DELT/(SLKTOL*PKFNVA(1)))**2)
      GO TO 100
C
   7  CALL FDCN01(1)
      F4PAR(2,KNOW)=PKFNVA(1)
      GO TO 100
C
  100 RETURN
      END
C
C
C
C
C LEVEL 6      SUBROUTINE PFCN03(N)
      SUBROUTINE PFCN03(N)
C
C *** PFCN03 from updated PFCN01 by WIFD/JCM 19 Jul 88 ***
C
CX
CC 19B
CH Multiple entry asymmetric Voigt profile for neutron/synchrotron
CH radiation (type 01) routine with FFT.
CA second word, one of a vocabulary of:
CA     SIGM
CA     GAMM
CA     HPSL
CA     HMSL
CA followed by the width parameters involved in this particular peak
CA descriptor.
CA
CA Entry N=2 forms the normalised peak function, and puts it in YNORM.  It also
CA gives all necessary derivatives of YNORM with respect to anything that could
CA be a parameter.
CA
CA Entry N=3 applies a shift to genus IGEN, species ISPC.
CA
CA Entry N=4 outputs a new L PKFN card.
CA
CA Entry N=5 sets LOGICAL REFUSE to say whether or not reflection to be used,
CA i.e. whether this reflection is near enough to this intensity to contribute
CA to it.
C
      PARAMETER (NW=4)
      CHARACTER *4 WORD,WDCN03(NW)
      COMPLEX CFFT,DFFT,DDT,CFE,CFT
      LOGICAL TESTOV
      DIMENSION C3FN(3),C3DN(3),IWCN03(3,NW)
/CARDRC/
/CONSTA/
/F4PARS/
/IOUNIT/
/NEWOLD/
/PAWLPR/
/PHASE/
/PRBLEM/
/PRPKCN/
/PRPKFN/
/PRSAVF/
/PWORDS/
/REFLNS/
/SOURCE/
C
      DATA WDCN03/'SIGM','GAMM','HPSL','HMSL'/
      DATA IWCN03/3,3,0, 3,4,0, 3,5,0, 3,6,0/
C
      GO TO (10,1,2,100,100,5,6,7) , N+1
C
C N=0: SET UP "DATA SOURCE CN/SR, PEAK TYPE 01"
  10  NPKGEN(JPHASE,JSOURC)=4
      NGEN4(JPHASE,JSOURC)=3
      LF3SP(3,JPHASE,JSOURC)=-3
      LF3SP(4,JPHASE,JSOURC)=-2
      LF3SP(5,JPHASE,JSOURC)=-1
      LF3SP(6,JPHASE,JSOURC)=-1
      LF6SP(1,JSOURC)=1
      DO 49 I=1,NPKGEN(JPHASE,JSOURC)
  49  PWD(I,JPHASE,JSOURC)=WDCN03(I)
      GO TO 100
C
C N=1: ADD PACKED VOCABULARY FOR THIS SOURCE, THIS PHASE, TO THE MAIN LIST:
   1  CALL VOCAB(WDCN03,IWCN03,NW)
      GO TO 100
C
C PROFILE REFINEMENT STAGE:
 2    CALL FDCN03(2)
C
C.. FIRSTLY DECIDE WHETHER THE KTH PEAK IS ALREADY STORED IN THE
C.. ARRAY PKLIST. AT THIS POINT REFUSE = (K .EQ. KPOINT(KMOD))
C.. DETERMINED IN SUBROUTINE CALTF1 WHICH CALLS THIS ENTRY (IOPT=2)
      IF (REFUSE) GO TO 26
C
C.. THE PEAK HAS NOT OCCURRED ALREADY - CALCULATE THE COMPLETE PEAK
C.. SHAPE OF THE KTH PEAK BY FFT.
C
C.. FFT CALCULATION STAGE IN PROFILE REFINEMENT
C
C.. FIRST DETERMINE FFT LIMITS FOR PEAK SHAPE
%      MN=%FFT1%
      MN2=MN/2
      SIGLIM= TOLER(1,JPHASE,JSOURC)*PKFNVA(1)
      CAULIM= TOLER(2,JPHASE,JSOURC)*PKFNVA(2)
      ASYLIM= 0.5*DEG*TOLER(3,JPHASE,JSOURC)*PKFNVA(3)**2/TAN(RAD*ARGK)
      DIST=AMAX1((SIGLIM+CAULIM+ASYLIM),0.2)
      XPKDEL(KMOD)=DIST/FLOAT(MN2)
C
C.. NOW SET UP FAST FOURIER TRANSFORM
C.. THE INDIVIDUAL COMPONENTS FOR CONVOLUTION ARE IMMEDIATELY
C.. DESCRIBED IN FOURIER SPACE (GETS RID OF DISCONTINUITY PROBLEMS)
C
      IEAGLE=JFIX(TOLER(1,JPHASE,JSOURC))
      IF (IEAGLE.EQ.3) THEN
        MNS=MN
        CALL FCSUB3(MNS)
        II=MNS/2-MN2
        DO 12 I=1,MN
          II=II+1
      DO 11 J=1,NPKGEN(JPHASE,JSOURC)+1
        PKLIST(I,J,KMOD)= (1./45.)*PKADD(II,J)
  11  CONTINUE
  12  CONTINUE
        MNS=2*MN
        CALL FCSUB3(MNS)
        II=MNS/2-MN2
      DO 14 I=1,MN
      II=II+1
      DO 13 J=1,NPKGEN(JPHASE,JSOURC)+1
      PKLIST(I,J,KMOD)= PKLIST(I,J,KMOD)-(20./45.)*PKADD(II,J)
  13  CONTINUE
  14  CONTINUE
      MNS=4*MN
      CALL FCSUB3(MNS)
      II=MNS/2-MN2
      DO 15 I=1,MN
      II=II+1
      DO 16 J=1,NPKGEN(JPHASE,JSOURC)+1
      PKLIST(I,J,KMOD)= PKLIST(I,J,KMOD)+(64./45.)*PKADD(II,J)
  16  CONTINUE
  15  CONTINUE
      ELSE IF (IEAGLE.EQ.2) THEN
        MNS=MN
        CALL FCSUB3(MNS)
        II=MNS/2-MN2
      DO 18 I=1,MN
      II=II+1
      DO 17  J=1,NPKGEN(JPHASE,JSOURC)+1
        PKLIST(I,J,KMOD)= -(1./3.)*PKADD(II,J)
  17  CONTINUE
  18  CONTINUE
      MNS=2*MN
      CALL FCSUB3(MNS)
      II=MNS/2-MN2
      DO 19 I=1,MN
      II=II+1
      DO 20 J=1,NPKGEN(JPHASE,JSOURC)+1
      PKLIST(I,J,KMOD)= PKLIST(I,J,KMOD)+(4./3.)*PKADD(II,J)
  20  CONTINUE
  19  CONTINUE
      ELSE
      MNS=MN
      CALL FCSUB3(MNS)
      II=MNS/2-MN2
      DO 9 I=1,MN
      II=II+1
      DO 8 J=1,NPKGEN(JPHASE,JSOURC)+1
      PKLIST(I,J,KMOD)= PKADD(II,J)
   8  CONTINUE
   9  CONTINUE
      END IF
C
C
C.. FFT OVER
C... DO THE INTERPOLATIONS FOR YNORM AND DERIVATIVES FROM PKLIST
C 88.03  26  JARGI=JNINT((ARGI-ARGK)/XPKDEL(KMOD))
C 88.03 JNINT to NINT in pfcn03. From KS diff
  26  JARGI=NINT((ARGI-ARGK)/XPKDEL(KMOD))
      IARGI=JARGI+MN2+1
C.. WORK OUT ARGI OFFSET FROM "X(JARGI)" FOR INTERPOLATION
      POFF= (ARGI-ARGK)/XPKDEL(KMOD) - FLOAT(JARGI)
C.. WORK OUT INTERPOLATION COEFFICIENTS FOR FUNCTIONS AND ARGK DERIVATIVE
      C3FN(1)= 0.5*POFF*(POFF-1.)
      C3FN(2)= 1.-POFF**2
      C3FN(3)= 0.5*POFF*(POFF+1.)
      C3DN(1)= POFF-0.5
      C3DN(2)= -2.*POFF
      C3DN(3)= POFF+0.5
C
      YNORM=0.
      DYNDKQ=0.
      CALL GMZER(DYNDVQ,1,NPKGEN(JPHASE,JSOURC))
C
      DO 41 I=1,3
      II=IARGI+I-2
      PKTEM=PKLIST(II,1,KMOD)
      YNORM=YNORM+C3FN(I)*PKTEM
      DYNDKQ=DYNDKQ-C3DN(I)*PKTEM
      DO 42 NPKD=1,NPKGEN(JPHASE,JSOURC)
      NPKD1=NPKD+1
      DYNDVQ(NPKD)=DYNDVQ(NPKD)+C3FN(I)*PKLIST(II,NPKD1,KMOD)
  42  CONTINUE
  41  CONTINUE
C
C.. NOW CHECK IF YNORM IS ZERO BEFORE EVALUATING QUOTIENT DERIVATIVES
      IF(TESTOV(2.,YNORM)) THEN
      DYNDKQ=0.
      CALL GMZER(DYNDVQ,1,NPKGEN(JPHASE,JSOURC))
      ELSE
      DYNDKQ=DYNDKQ/(YNORM*XPKDEL(KMOD))
      CALL GMSCA(DYNDVQ,DYNDVQ,1./YNORM,1,NPKGEN(JPHASE,JSOURC))
      ENDIF
      GO TO 100
C
C PRE-PROFILE REFINEMENT STAGE
   5  CALL FDCN03(1)
      DEL= ARGI-ARGK
      SIGLIM= TOLER(1,JPHASE,JSOURC)*PKFNVA(1)
      CAULIM= TOLER(2,JPHASE,JSOURC)*PKFNVA(2)
      ASYLIM= 0.5*DEG*TOLER(3,JPHASE,JSOURC)*PKFNVA(3)**2/TAN(RAD*ARGK)
C
      TEMLIM= ASYLIM
      IF (DEL) 510,510,520
 510  TEMLIM= ASYLIM
 520  TEMLIM= TEMLIM+0.5*(SIGLIM+CAULIM)
      REFUSE= ABS(DEL) .GT. TEMLIM
      GO TO 100
C
C N=6 *** CAILS *** SETTING UP SLACK AND STRICT CONSTRAINTS
C
    6 CALL FDCN03(1)
      DELT=ABS(AKLO-AKHI)
      SIGLIM= TOLER(1,JPHASE,JSOURC)*PKFNVA(1)
      CAULIM= TOLER(2,JPHASE,JSOURC)*PKFNVA(2)
      ASYLIM= 0.5*DEG*PKFNVA(3)**2/TAN(RAD*ARGK)
C
      AVTAU= TOLER(2,JPHASE,JSOURC)*PKFNVA(2) +
     & PKFNVA(1)*TOLER(3,JPHASE,JSOURC)*PKFNVA(3)
       FWHME=SQL2X8*PKFNVA(4) + PKFNVA(5) + ALOG2*AVTAU
      FWHME= 2.35*PKFNVA(1)+1.57*PKFNVA(2)+ASYLIM
C
      STRKT=DELT .LT. STRTOL*FWHME
      SLACK=0.
      IF (DELT .GE. SLKTOL*FWHME) GO TO 100
      SLACK=EXP(1.-(DELT/(SLKTOL*FWHME))**2)
      GO TO 100
C
   7  CALL FDCN03(1)
      F4PAR(2,KNOW)=PKFNVA(1)
      F4PAR(3,KNOW)=PKFNVA(2)
C      F4PAR(4,KNOW)=PKFNVA(3)
C      F4PAR(5,KNOW)=PKFNVA(4)
      GO TO 100
 100  RETURN
      END
C
C
C
C
C LEVEL 6      SUBROUTINE PFCN04(N)
      SUBROUTINE PFCN04(N)
C
C *** PFCN04 from PFCN01 to use L.Fingers profval peak shape ***
C
C (PROBABLY) Won't work with SAPS or APES for now - JPW 21/11/99
C
CH Multiple entry routine to do various calculations for constant
CH wavelength data, Pseudo voight peak shape, with asymetry correction
CA On entry N=1,2,5,6, or 7
CA N=1 asks to initialise the program to do CN, peak function 01
CA N=2 form peak function in YNORM, and its derivatives wrt parameters
CA N=5: Sets LOGICAL REFUSE to determine if reflection makes a significant
CA      contribution to the profile at ARGI
CA N=6: CAILS entry to determine whether near reflections should be related
CA      by a strict or slack relationship.
CA N=7: SAPS entry to obey FDXXXX to set up a value(s) for PKFNVA
C
      LOGICAL USE_ASYM
      REAL*4 GAMMA,P,ETA,S_L,D_L,TWOTH,TWOTH0,PROFVAL,dPRdT,dPRdG,
     & dPRdE, dPRdS,dPRdD
      EXTERNAL PROFVAL
/CONSTA/
/F4PARS/
/PAWLPR/
/PHASE/
/PRBLEM/
/PRPKCN/
/PRPKFN/
/PWORDS/
/REFLNS/
/SOURCE/
C
      PARAMETER (NW=9)
      CHARACTER *4 WDCN04(NW)
      DIMENSION IWCN04(3,NW)
      DATA WDCN04/'SIGM','GAMM','SOVL','DOVL','U','V','W','X','Y'/
      DATA IWCN04/3,3,0, 3,4,0, 3,5,0, 3,6,0, 3,3,1, 3,3,2, 3,3,3,
     & 3,4,1, 3,4,2/
C
      GO TO (10,1,2,100,100,5,6,7) , N+1
C
C N=0: SET UP "DATA SOURCE CN, PEAK TYPE 04"
  10  NPKGEN(JPHASE,JSOURC)=4
**?? SORT OUT NGEN4
      NGEN4(JPHASE,JSOURC)=4
      LF3SP(3,JPHASE,JSOURC)=3
      LF3SP(4,JPHASE,JSOURC)=2
      LF3SP(5,JPHASE,JSOURC)=-1
      LF3SP(6,JPHASE,JSOURC)=-1
      LF6SP(1,JSOURC)=1
      DO 11 I=1,NPKGEN(JPHASE,JSOURC)
  11  PWD(I,JPHASE,JSOURC)=WDCN04(I)
      GO TO 100
C
C N=1: ADD PACKED VOCABULARY FOR THIS SOURCE, THIS PHASE, TO THE MAIN LIST:
   1  CALL VOCAB(WDCN04,IWCN04,NW)
      GO TO 100
C
C N=2: PROFILE REFINEMENT STAGE
C Set up call to Finger's function, fdcn04 gets back the lorentz and gauss
C FWHM of the voigt.
    2 CALL FDCN04(2)
C Use the formulae from J.Appl.Cryst (1987) 20 79-83 to get the
C fwhm and eta coefficient of the pseudo-voigt. (ie we are using a
C pseudo voigt parameterised as a voigt.)
C
      GAMMA=(PKFNVA(1)**5 + 2.69269*PKFNVA(1)**4*PKFNVA(2) +
     & 2.42843*PKFNVA(1)**3*PKFNVA(2)**2
     & + 4.47163*PKFNVA(1)**2*PKFNVA(2)**3
     & 0.07842*PKFNVA(1)*PKFNVA(2)**4 + PKFNVA(2)**5)**0.2
      P=PKFNVA(2)/GAMMA
      Eta=1.36603*P - 0.47719*P*P + 0.11116*P*P*P
      S_L=PKFNVA(3)
      D_L=PKFNVA(4)
      TwoTH=ARGI
      TwoTH0=ARGK
      IF( (S_L.GT.0.0) .AND. (D_L.GT.0.0) ) THEN
        Use_Asym=.TRUE.
      ELSE
        Use_Asym=.FALSE.
      ENDIF
      YNORM=Profval( Eta , Gamma , S_L , D_L , TwoTH ,
     1   TwoTH0 , dPRdT, dPRdG, dPRdE , dPRdS , dPRdD , Use_Asym )
C
C DYNDKQ IS THE DERIVATIVE OF YNORM WRT TK (ARGK), DIVIDED BY YNORM.  THE 6
C LETTER NAME DOES NOT ALLOW US TO EXPRESS ALL THIS, BUT THE Q IS IMPORTANT
C BECAUSE IT INDICATES 'QUOTIENT', IE THE DERIVATIVE IS DIVIDED BY THE FUNCTION
C
C Need to convert these to derivatives w.r.t pkfnva(1) and pkfnva(2)
C Have YNORM=f(gamma(a,b),eta(a,b)) get back df/dgamma and df/deta want df/da and df/db
C (a and b are the fwhm of the gauss and lorentz components of the voigt)
C Using df/da = df/dg * dg/da + df/dg * de/da ; hoping it is correct (!)
C d_gamma/d_pkfnva(1)
      DGD1 = (5*PKFNVA(1)**4 + 4.*2.69269*PKFNVA(1)**3*PKFNVA(2) +
     & + 3.*2.42843*PKFNVA(1)**2*PKFNVA(2)**2
     & + 2.*4.47163*PKFNVA(1)*PKFNVA(2)**3 + 0.07842*PKFNVA(2)**4)
     & * 0.2/GAMMA**4
C d_gamma/d_pkfnva(2)
      DGD2 = (2.69269*PKFNVA(1)**4 + 2.*2.42843*PKFNVA(1)**3*PKFNVA(2)
     & + 3.*4.47163*PKFNVA(1)**2*PKFNVA(2)**2
     & 4.*0.07842*PKFNVA(1)*PKFNVA(2)**3 + 5.*PKFNVA(2)**4)
     & * 0.2/GAMMA**4
C d_eta/d_pkfnva(1)
      DED1 = DGD1*(-1.36603*PKFNVA(2)/GAMMA**2
     & + 0.47719*PKFNVA(2)**2/GAMMA**3 - 0.11116*PKFNVA(2)**3/GAMMA**4)
C d_eta/d_pkfnva(2)
      DED2 = DED1*DGD2/DGD1 + 1.36603/GAMMA
     & + 2.*0.47719*PKFNVA(2)/GAMMA**2
     & + 3.*0.11116*PKFNVA(2)**2/GAMMA**3
      DYNDVQ(1)=dPRdG/YNORM * DGD1
     &         + dPRdE/YNORM * DED1
      DYNDVQ(2)=dPRdG/YNORM * DGD2
     &         + dPRdE/YNORM * DED2
C
      DYNDKQ=DPrDT/YNORM
      DYNDVQ(3)=dPRdS/YNORM
      DYNDVQ(4)=dPRdD/YNORM
      GO TO 100
C
C N=5: IS REFLECTION IN RANGE?
    5 DEL=ARGI-ARGK
      TANTH=TAN(RAD*ARGK/2.)
      SECTH=SQRT(1.+TANTH*TANTH)
      SIGU=PKFNSP(1,1,JPHASE,JSOURC)
      SIGV=PKFNSP(1,2,JPHASE,JSOURC)
      SIGW=PKFNSP(1,3,JPHASE,JSOURC)
      GAMMA1 = (SIGU*TANTH + SIGV)*TANTH + SIGW
      TEMSQ1=TOLER(1,JPHASE,JSOURC)*GAMMA1
      GAMMA2=PKFNSP(2,1,JPHASE,JSOURC)*SECTH +
     &  PKFNSP(2,2,JPHASE,JSOURC)*TANTH
      TEMSQ2=TOLER(2,JPHASE,JSOURC)*GAMMA2
      REFUSE=DEL*DEL.GT.(TEMSQ1+TEMSQ2*TEMSQ2)
      GO TO 100
C
C N=6 *** CAILS *** SETTING UP SLACK AND STRICT CONSTRAINTS
C
    6 CALL FDCN04(1)
      DELT=ABS(AKLO-AKHI)
      STRKT = DELT .LE. STRTOL*PKFNVA(1)
      SLACK=0.
      IF (DELT .GE. SLKTOL*PKFNVA(1)) GO TO 100
      SLACK=EXP(1.-(DELT/(SLKTOL*PKFNVA(1)))**2)
      GO TO 100
C
   7  CALL FDCN04(1)
      F4PAR(2,KNOW)=PKFNVA(1)
      GO TO 100
C
  100 RETURN
      END
C
C
C
C
C LEVEL 6      SUBROUTINE PFCN05(N)
      SUBROUTINE PFCN05(N)
C
C *** PFCN05 from PFCN04 to use a double lorentzian for Fe3O4 ESRF ***
C
C (PROBABLY) Won't work with SAPS or APES for now - JPW 31/3/00
C
CH Multiple entry routine to do various calculations for constant
CH wavelength data, Pseudo voigt (lorentz only) peak shape, with asymetry correction
CA On entry N=1,2,5,6, or 7
CA N=1 asks to initialise the program to do CN, peak function 01
CA N=2 form peak function in YNORM, and its derivatives wrt parameters
CA N=3 Set up peak interpolation for speed
CA N=5: Sets LOGICAL REFUSE to determine if reflection makes a significant
CA      contribution to the profile at ARGI
CA N=6: CAILS entry to determine whether near reflections should be related
CA      by a strict or slack relationship.
CA N=7: SAPS entry to obey FDXXXX to set up a value(s) for PKFNVA
C
      LOGICAL USE_ASYM
/CONSTA/
/F4PARS/
/PAWLPR/
/PHASE/
/PRBLEM/
/PRPKCN/
/PRPKFN/
/PWORDS/
/REFLNS/
/SOURCE/
/SPEED/
C
      LOGICAL INTERP
      DATA INTERP /.FALSE./
      SAVE INTERP
      PARAMETER (NW=5)
      CHARACTER *4 WDCN05(NW)
      DIMENSION IWCN05(3,NW)
      DATA WDCN05/'GAM1','GAM2','SOVL','DOVL','MULT'/
      DATA IWCN05/3,3,0, 3,4,0, 3,5,0 ,3,6,0, 3,7,0/
C
      GO TO (10,1,2,3,100,5,6,7) , N+1
C
C N=0: SET UP "DATA SOURCE CN, PEAK TYPE 05"
  10  NPKGEN(JPHASE,JSOURC)=5
**?? SORT OUT NGEN4
      NGEN4(JPHASE,JSOURC)=3
      LF3SP(3,JPHASE,JSOURC)=-2
      LF3SP(4,JPHASE,JSOURC)=-2
      LF3SP(5,JPHASE,JSOURC)=-1
      LF3SP(6,JPHASE,JSOURC)=-1
      LF3SP(7,JPHASE,JSOURC)=-1
      LF6SP(1,JSOURC)=1
      DO 11 I=1,NPKGEN(JPHASE,JSOURC)
  11  PWD(I,JPHASE,JSOURC)=WDCN05(I)
      GO TO 100
C
C N=1: ADD PACKED VOCABULARY FOR THIS SOURCE, THIS PHASE, TO THE MAIN LIST:
   1  CALL VOCAB(WDCN05,IWCN05,NW)
      GO TO 100
C
C N=2: PROFILE REFINEMENT STAGE
C Set up call to Finger's function.
    2 IF(INTERP) THEN
        CALL PICN05(2)
        GO TO 100
      ENDIF
      TANTH=TAN(RAD*ARGK/2.)
      SECTH=SQRT(1+TANTH*TANTH)
      PKFNVA(1)=PKFNSP(1,1,JPHASE,JSOURC)*SECTH
     & + PKFNSP(1,2,JPHASE,JSOURC)*TANTH
      PKFNVA(2)=PKFNSP(2,1,JPHASE,JSOURC)*SECTH
     & + PKFNSP(2,2,JPHASE,JSOURC)*TANTH
      PKFNVA(3)=PKFNSP(3,1,JPHASE,JSOURC)
      PKFNVA(4)=PKFNSP(4,1,JPHASE,JSOURC)
C Check to see if it is worth calculating the peakshape here.
C      W1=PKFNVA(1)**2
C      W2=PKFNVA(2)**2
C      DIST=(ARGI-ARGK)**2
C      denom  = 4.0 * DIST + W1
C      speed1 =          0.636619772 * PKFNVA(1) / denom
C      denom  = 4.0 * DIST + W2
C      speed1 = speed1 + 0.636619772 * PKFNVA(2) / denom
C      IF(CURFAC*SPEED1.LT.CURESD*TOLER(5,JPHASE,JSOURC) .AND.
C     & ((W1*100.).LT.DIST) .AND. ((W2*100.).LT.DIST)) THEN
C     SKIPRF=.TRUE.
C      GOTO 100
C      ENDIF
C
      DERPFN(1,1)=SECTH
      DERPFN(1,2)=TANTH
      DERPFN(2,1)=SECTH
      DERPFN(2,2)=TANTH
      DERPFN(3,1)=1.0
      DERPFN(4,1)=1.0
      S_L=PKFNVA(3)
      D_L=PKFNVA(4)
      AM1=PKFNSP(5,1,JPHASE,JSOURC)
      DERPFN(5,1)=1.0
      AM2=1.-AM1
      TwoTH=ARGI
      TwoTH0=ARGK
      IF( (S_L.GT.0.0) .AND. (D_L.GT.0.0) ) THEN
         Use_Asym=.TRUE.
      ELSE
         Use_Asym=.FALSE.
      ENDIF
C
C fwhm and eta coefficient of the pseudo-voigt
C
      Eta=1.0
      YNORM1=Profval( Eta , PKFNVA(1) , S_L , D_L , TwoTH ,
     1   TwoTH0 , dPRdT1, dPRdG1, dPRdE1 , dPRdS1 , dPRdD1 , Use_Asym )
      YNORM2=Profval( Eta , PKFNVA(2) , S_L , D_L , TwoTH ,
     1   TwoTH0 , dPRdT2, dPRdG2, dPRdE2 , dPRdS2 , dPRdD2 , Use_Asym )
      YNORM=AM1*YNORM1+AM2*YNORM2
      DYNDVQ(1)=AM1*dPRdG1/YNORM
      DYNDVQ(2)=AM2*dPRdG2/YNORM
      DYNDKQ=(AM1*dPRdT1 + AM2*dPRdT2)/YNORM
      DYNDVQ(3)=(AM1*dPRdS1 + AM2*dPRdS2)/YNORM
      DYNDVQ(4)=(AM1*dPRdD1 + AM2*dPRdD2)/YNORM
      DYNDVQ(5)=(YNORM1-YNORM2)/YNORM
C
C DYNDKQ IS THE DERIVATIVE OF YNORM WRT TK (ARGK), DIVIDED BY YNORM.  THE 6
C LETTER NAME DOES NOT ALLOW US TO EXPRESS ALL THIS, BUT THE Q IS IMPORTANT
C BECAUSE IT INDICATES 'QUOTIENT', IE THE DERIVATIVE IS DIVIDED BY THE FUNCTION
      GO TO 100
C
C N=3 Set up interpolation for speed
    3 INTERP=.FALSE.
      CALL PICN05(1)
      INTERP=.TRUE.
      GOTO 100
C
C N=5: IS REFLECTION IN RANGE?
    5 DEL=ARGI-ARGK
      TANTH=TAN(RAD*ARGK/2.)
      SECTH=SQRT(1.+TANTH*TANTH)
      GAMMA1=PKFNSP(1,1,JPHASE,JSOURC)*SECTH +
     &  PKFNSP(1,2,JPHASE,JSOURC)*TANTH
      GAMMA2=PKFNSP(2,1,JPHASE,JSOURC)*SECTH +
     &  PKFNSP(2,2,JPHASE,JSOURC)*TANTH
      TEMSQ1=TOLER(1,JPHASE,JSOURC)*GAMMA1
      TEMSQ2=TOLER(2,JPHASE,JSOURC)*GAMMA2
      IF(TEMSQ1.GT.TEMSQ2) TEMSQ2=TEMSQ1
      REFUSE=DEL*DEL.GT.(TEMSQ2*TEMSQ2)
      GO TO 100
C
C N=6 *** CAILS *** SETTING UP SLACK AND STRICT CONSTRAINTS
C
    6 CALL FDCN01(1)
      DELT=ABS(AKLO-AKHI)
      STRKT = DELT .LE. STRTOL*PKFNVA(1)
      SLACK=0.
      IF (DELT .GE. SLKTOL*PKFNVA(1)) GO TO 100
      SLACK=EXP(1.-(DELT/(SLKTOL*PKFNVA(1)))**2)
      GO TO 100
C
   7  CALL FDCN01(1)
      F4PAR(2,KNOW)=PKFNVA(1)
      GO TO 100
C
  100 RETURN
      END
C
C
C
C
C LEVEL 6      SUBROUTINE PFLX01(N)
      SUBROUTINE PFLX01(N)
C
C *** PFLX01 updated by JCM 27 May 89 ***
C
CH Multiple entry routine to do various calculations for X-ray data,
CH Gaussian peak
C
CA On entry N=1,2,5,6, or 7
CA N=1: Initialise program to do data source LX, peak function 01
CA N=2 form peak function in YNORM, and its derivatives wrt paramet ers
CA N=5: Sets LOGICAL REFUSE to determine if reflection makes a sign ificant
CA      contribution to the profile at ARGI
CA N=6: CAILS entry to determine whether near reflections should be related
CA      by a strict or slack relationship.
CA N=7: SAPS entry to obey FDXXXX to set up a value(s) for PKFNVA
C
/DGEOM/
/F4PARS/
/PAWLPR/
/PHASE/
/PRBLEM/
/PRPKCN/
/PRPKFN/
/PRZERO/
/PWORDS/
/REFLNS/
/SOURCE/
      COMMON /XRAYC/ ARGK2
      PARAMETER (NW=5)
      CHARACTER *4 WDLX01(NW)
      DIMENSION IWLX01(3,NW)
      DATA WDLX01/'SIGM','U','V','W','TTHM'/
      DATA IWLX01/3,3,0, 3,3,1, 3,3,2, 3,3,3, 6,1,2/
C
      GO TO (10,1,2,100,100,5,6,7) , N+1
C
C N=0: SET UP "DATA SOURCE LX, PEAK TYPE 01"
  10  NPKGEN(JPHASE,JSOURC)=1
      NGEN4(JPHASE,JSOURC)=2
      LF3SP(3,JPHASE,JSOURC)=3
      LF6SP(1,JSOURC)=2
      DO 11 I=1,NPKGEN(JPHASE,JSOURC)
  11  PWD(I,JPHASE,JSOURC)=WDLX01(I)
      GO TO 100
C
C N=1: ADD PACKED VOCABULARY FOR THIS SOURCE, THIS PHASE, TO THE MAIN LIST:
   1  CALL VOCAB(WDLX01,IWLX01,NW)
      GO TO 100
C
C N=2: PROFILE REFINEMENT STAGE
    2 CALL FDLX01(2)
      DEL=ARGI-ARGK
      SIGDSQ=1./PKFNVA(1)
      DELSQ=DEL*DEL
      ARGTEM=DELSQ*SIGDSQ
      DEL2=ARGI-ARGK2
      DELSQ2=DEL2*DEL2
      ARGTM2=DELSQ2*SIGDSQ
      EXPON=EXP((-0.5)*ARGTEM)
      EXPON2=EXP((-0.5)*ARGTM2)
      ANORM=SQRT(SIGDSQ*0.159154943)
      YNORM=ANORM*(EXPON+0.5*EXPON2)
C
C DYNDKQ IS THE DERIVATIVE OF YNORM WRT TK (ARGK), DIVIDED BY YNORM.  THE 6
C LETTER NAME DOES NOT ALLOW US TO EXPRESS ALL THIS, BUT THE Q IS IMPORTANT
C BECAUSE IT INDICATES 'QUOTIENT', IE THE DERIVATIVE IS DIVIDED BY THE FUNCTION
C BUT BE CAREFUL FOR ZERO YNORM
      IF (YNORM.EQ.0.) THEN
        DYNDKQ=0.
        DYNDVQ(1)=0.
      ELSE
C FIRST, (1/Y)(DY/D(ARGK))  K MEANS WRT ARGK
C THIS COMES FROM (1/Y)*(DY/D(DEL))*(D(DEL)/(D(ARGK))
C THUS, NO NEGATIVE SIGN
        ATEM=0.5*RADIAN(ARGK-ZEROSP(1,JPHASE,JSOURC))
        RTEM=ALAMBD(2,JSOURC)/ALAMBD(1,JSOURC)
        UTEM=RTEM*SIN(ATEM)
        DX2DXK=RTEM*COS(ATEM)/SQRT(1.-UTEM*UTEM)
        DYNDKQ=(ANORM*SIGDSQ*(DEL*EXPON+0.5*DEL2*EXPON2*DX2DXK))/YNORM
C THEN, (1/Y)(DY/D(SIGMA-SQUARED))
        BTEM=(ANORM*(ARGTEM*EXPON+0.5*ARGTM2*EXPON2))/YNORM
        DYNDVQ(1)=0.5*SIGDSQ*(BTEM-1.)
      ENDIF
      GO TO 100
C
C N=5: IS REFLECTION IN RANGE?
C
    5 CALL FDLX01(1)
      DEL=ARGI-ARGK
      DEL2=ARGI-ARGK2
      TEMSQ=TOLER(1,JPHASE,JSOURC)*PKFNVA(1)
      IF (DEL.LE.0.) THEN
        REFUSE=DEL*DEL.GT.TEMSQ
      ELSE
        IF (DEL2.LE.0.) THEN
          REFUSE=.FALSE.
        ELSE
          REFUSE=DEL2*DEL2.GT.TEMSQ
        ENDIF
      ENDIF
C
      GO TO 100
C
C N=6 *** CAILS *** SETTING UP SLACK AND STRICT CONSTRAINTS
C
    6 CALL FDLX01(1)
      DELT=ABS(AKLO-AKHI)
      STRKT = DELT .LE. STRTOL*PKFNVA(1)
      SLACK=0.
      IF (DELT .GE. SLKTOL*PKFNVA(1)) GO TO 100
      SLACK=EXP(1.-(DELT/(SLKTOL*PKFNVA(1)))**2)
      GO TO 100
C
   7  CALL FDLX01(1)
      F4PAR(2,KNOW)=PKFNVA(1)
      GO TO 100
C
  100 RETURN
      END
C
C
C
C
C LEVEL 6      SUBROUTINE PFLX02(N)
      SUBROUTINE PFLX02(N)
C
C *** PFLX02 updated by JCM 27 May 89 ***
C
CH Multiple entry routine for various calculations for X-Ray data,
CH Voigt peak function
C
CA On entry N=1,2,5,6, or 7
CA N=1: Set up program for data source LX, peak function 02
CA N=2: form peak function in YNORM, and its derivatives wrt paramet ers
CA N=5: Sets LOGICAL REFUSE to determine if reflection makes a sign ificant
CA      contribution to the profile at ARGI
CA N=6: CAILS entry to determine whether near reflections should be related
CA      by a strict or slack relationship.
CA N=7: SAPS entry to obey FDXXXX to set up a value(s) for PKFNVA
C
/DGEOM/
/F4PARS/
/PAWLPR/
/PHASE/
/PRBLEM/
/PRPKCN/
/PRPKFN/
/PRZERO/
/PWORDS/
/REFLNS/
/SOURCE/
      COMMON /XRAYC/ ARGK2
      PARAMETER (NW=6)
      CHARACTER *4 WDLX02(NW)
      DIMENSION IWLX02(3,NW)
      DATA WDLX02/'SIGM','GAMM','U','V','W','TTHM'/
      DATA IWLX02/3,3,0, 3,4,0, 3,3,1, 3,3,2, 3,3,3, 6,1,2/
C
C
      GO TO (10,1,2,100,100,5,6,7) , N+1
C
C N=0: SET UP "DATA SOURCE LX, PEAK TYPE 02"
  10  NPKGEN(JPHASE,JSOURC)=2
      NGEN4(JPHASE,JSOURC)=2
      LF3SP(3,JPHASE,JSOURC)=3
      LF3SP(4,JPHASE,JSOURC)=-2
      LF6SP(1,JSOURC)=2
      DO 11 I=1,NPKGEN(JPHASE,JSOURC)
  11  PWD(I,JPHASE,JSOURC)=WDLX02(I)
      GO TO 100
C
C N=1: ADD PACKED VOCABULARY FOR THIS SOURCE, THIS PHASE, TO THE MAIN LIST:
   1  CALL VOCAB(WDLX02,IWLX02,NW)
      GO TO 100
C
C N=2: PROFILE REFINEMENT STAGE
    2 CALL FDLX02(2)
      DEL1=ARGI-ARGK
      DEL2=ARGI-ARGK2
      SIGMA=SQRT(PKFNVA(1))
      GAMMA=PKFNVA(2)
      CALL VOIGT(DEL1,SIGMA,GAMMA,YVAL1,DERX1,DERS1,DERG1)
      CALL VOIGT(DEL2,SIGMA,GAMMA,YVAL2,DERX2,DERS2,DERG2)
      YNORM=YVAL1+0.5*YVAL2
C
C DYNDKQ IS THE DERIVATIVE OF YNORM WRT TK (ARGK), DIVIDED BY YNORM.  THE 6
C LETTER NAME DOES NOT ALLOW US TO EXPRESS ALL THIS, BUT THE Q IS IMPORTANT
C BECAUSE IT INDICATES 'QUOTIENT', IE THE DERIVATIVE IS DIVIDED BY THE FUNCTION
C BUT BE CAREFUL FOR ZERO YNORM
      IF (YNORM.EQ.0.) THEN
        DYNDKQ=0.
        DYNDVQ(1)=0.
        DYNDVQ(2)=0.
      ELSE
C FIRST, (1/Y)(DY/D(ARGK))  K MEANS WRT ARGK
C THIS COMES FROM (1/Y)*(DY/D(DEL))*(D(DEL)/(D(ARGK))
C THUS, NO NEGATIVE SIGN
        ATEM=0.5*RADIAN(ARGK-ZEROSP(1,JPHASE,JSOURC))
        RTEM=ALAMBD(2,JSOURC)/ALAMBD(1,JSOURC)
        UTEM=RTEM*SIN(ATEM)
        DX2DXK=RTEM*COS(ATEM)/SQRT(1.-UTEM*UTEM)
        DYNDKQ=-(DERX1+0.5*DX2DXK*DERX2)/YNORM
C THEN, (1/Y)(DY/D(SIGMA-SQUARED))
        DYNDVQ(1)=(DERS1+0.5*DERS2)/(2.*SIGMA*YNORM)
        DYNDVQ(2)=(DERG1+0.5*DERG2)/YNORM
      ENDIF
      GO TO 100
C
C N=5: IS REFLECTION IN RANGE?
C
    5 CALL FDLX02(1)
      DEL1=ARGI-ARGK
      DEL2=ARGI-ARGK2
      TEMSQ=TOLER(1,JPHASE,JSOURC)*PKFNVA(1)
      TEMGA=(TOLER(2,JPHASE,JSOURC)*PKFNVA(2))**2
      IF (DEL1.LE.0.) THEN
        REFUSE=DEL1*DEL1.GT.(TEMSQ+TEMGA)
      ELSE
        IF (DEL2.LE.0.) THEN
          REFUSE=.FALSE.
        ELSE
          REFUSE=DEL2*DEL2.GT.(TEMSQ+TEMGA)
        ENDIF
      ENDIF
C
      GO TO 100
C
C
    6 CALL FDLX02(1)
      DELT=ABS(AKLO-AKHI)
      STRKT = DELT .LE. STRTOL*PKFNVA(1)
      SLACK=0.
      IF (DELT .GE. SLKTOL*PKFNVA(1)) GO TO 100
      SLACK=EXP(1.-(DELT/(SLKTOL*PKFNVA(1)))**2)
      GO TO 100
C
   7  CALL FDLX02(1)
      F4PAR(2,KNOW)=PKFNVA(1)
      GO TO 100
C
  100 RETURN
      END
C
C
C
C
C
C
C LEVEL 6      SUBROUTINE PFTF01(N)
      SUBROUTINE PFTF01(N)
C
C *** PFTF01 updated by JCM 27 May 89 ***
C
CH Multiple entry Time of Flight Peak Function routine with FFT
CH With Gaussian double exponential Peak Function
CA Multiple entry, dependent on N:
CA N=1: Set up program for data source TOF, peak function type 01
CA N=2: Calculate normalised peak function to YNORM, and its derivatives wrt
CA      anything which could be a parameter.
C
CA N=5: Sets REFUSE to say whether or not given reflection is to be used
CA      i.e. whether this reflection is near enough to this intensity to
CA      contribute to it.
C
CA N=6: CAILS entry to select slack or strict
C
CA N=7: SAPS entry to obey FDTFXX to set up a value for PFFNVA
CA      to hold SIGM
C
      COMPLEX CFFT,DFFT,DDT,CFE,CFT
      LOGICAL TESTOV
/CONSTA/
/F4PARS/
/PAWLPR/
/PHASE/
/PRBLEM/
/PRPKCN/
/PRPKFN/
/PRSAVF/
/PWORDS/
/REFLNS/
/SOURCE/
      COMMON /SCRAT/CFFT(8),DFFT(8),DDT(8),CFE,CFT,
%     & FR(%FFT2%,8),FI(%FFT2%,8),DR(%FFT2%,8),DI(%FFT2%,8),
%     & FRE(%FFT2%),FIE(%FFT2%),FRT(%FFT2%),FIT(%FFT2%),
     & C3FN(3),C3DN(3)
      PARAMETER (NW=4)
      CHARACTER *4 WDTF01(NW)
      DIMENSION IWTF01(3,NW)
      DATA WDTF01/'SWCH','TAUF','TAUS','SIGM'/
      DATA IWTF01/3,3,0, 3,4,0, 3,5,0, 3,6,0/
C
      GO TO (10,1,2,100,100,5,6,7) , N+1
C
C N=0: SET UP "DATA SOURCE TOF, PEAK TYPE 01"
  10  NPKGEN(JPHASE,JSOURC)=4
      NGEN4(JPHASE,JSOURC)=2
      LF3SP(3,JPHASE,JSOURC)=-2
      LF3SP(4,JPHASE,JSOURC)=-2
      LF3SP(5,JPHASE,JSOURC)=-2
      LF3SP(6,JPHASE,JSOURC)=-3
      LF6SP(1,JSOURC)=1
      DO 11 I=1,NPKGEN(JPHASE,JSOURC)
  11  PWD(I,JPHASE,JSOURC)=WDTF01(I)
      GO TO 100
C
C N=1: ADD PACKED VOCABULARY FOR THIS SOURCE, THIS PHASE, TO THE MAIN LIST:
   1  CALL VOCAB(WDTF01,IWTF01,NW)
      GO TO 100
C
C PROFILE REFINEMENT STAGE:
 2    CALL FDTF01(2)
%      MN=%FFT1%
      MN2=MN/2
C
C.. FIRSTLY DECIDE WHETHER THE KTH PEAK IS ALREADY STORED IN THE
C.. ARRAY PKLIST. AT THIS POINT REFUSE = (K .EQ. KPOINT(KMOD))
C.. DETERMINED IN SUBROUTINE CALTF1 WHICH CALLS THIS ENTRY (IOPT=2)
      IF (REFUSE) GO TO 26
C
C.. THE PEAK HAS NOT OCCURRED ALREADY - CALCULATE THE COMPLETE PEAK
C.. SHAPE OF THE KTH PEAK BY FFT.
C
C.. FFT CALCULATION STAGE IN PROFILE REFINEMENT
C
C.. FIRST DETERMINE FFT LIMITS FOR PEAK SHAPE
      TEMSQ= (TOLER(4,JPHASE,JSOURC)*PKFNVA(4))**2
      AVTAU= PKFNVA(1)*TOLER(2,JPHASE,JSOURC)*PKFNVA(2) +
     & (1.-PKFNVA(1))*TOLER(3,JPHASE,JSOURC)*PKFNVA(3)
      TEMSQ= TEMSQ + AVTAU*AVTAU
      XPKDEL(KMOD)=SQRT(TEMSQ)/FLOAT(MN2)
C
C.. NOW SET UP FAST FOURIER TRANSFORM
C.. THE INDIVIDUAL COMPONENTS FOR CONVOLUTION ARE IMMEDIATELY
C.. DESCRIBED IN FOURIER SPACE (GETS RID OF DISCONTINUITY PROBLEMS)
C
      SW=PKFNVA(1)
      TAUF=PKFNVA(2)
      TAUS=PKFNVA(3)
      SIG= PKFNVA(4)
      SW1=1.-SW
C
      CTEM= TWOPI/(FLOAT(MN)*XPKDEL(KMOD))
      FTEMF= CTEM*TAUF
      FTEMS= CTEM*TAUS
      GTEM=  CTEM*SIG
C
      MN2P1= MN2+1
      DO 31 I=1,MN
        II=MOD(I+MN2,MN)-MN2P1
C.. FAST EXPONENTIAL DECAY
        ARG=FTEMF*FLOAT(II)
        FR(I,2)= 1./(1.+ARG*ARG)
        FI(I,2)= ARG*FR(I,2)
        ATEMF= CTEM*FLOAT(II)*FR(I,2)**2
        DR(I,2)= -2.*ARG*ATEMF
        DI(I,2)= (1.-ARG*ARG)*ATEMF
C.. SLOW EXPONENTIAL DECAY
        ARG=FTEMS*FLOAT(II)
        FR(I,3)= 1./(1.+ARG*ARG)
        FI(I,3)= ARG*FR(I,3)
        ATEMS= CTEM*FLOAT(II)*FR(I,3)**2
        DR(I,3)= -2.*ARG*ATEMS
        DI(I,3)= (1.-ARG*ARG)*ATEMS
C.. GAUSSIAN
        ARG= GTEM*FLOAT(II)
        FR(I,4)= EXP((-0.5)*ARG*ARG)
        FI(I,4)= 0.
        DR(I,4)= -ARG*ARG*FR(I,4)/SIG
        DI(I,4)= 0.
  31  CONTINUE
C
C.. NOW FORM PRODUCTS IN FOURIER SPACE
      DO 32 I=1,MN
       DO 33 J=2,NPKGEN(JPHASE,JSOURC)
        CFFT(J)=CMPLX(FR(I,J),FI(I,J))
        DFFT(J)=CMPLX(DR(I,J),DI(I,J))
  33  CONTINUE
        CFE= CFFT(2)*CFFT(4)
        CFT= CFFT(3)*CFFT(4)
        DDT(2)= SW*DFFT(2)*CFFT(4)
        DDT(3)= SW1*DFFT(3)*CFFT(4)
        DDT(4)= (SW*CFFT(2)+SW1*CFFT(3))*DFFT(4)
        DO 34 J=2,NPKGEN(JPHASE,JSOURC)
         DR(I,J)=REAL(DDT(J))
         DI(I,J)=AIMAG(DDT(J))
  34    CONTINUE
        FRE(I)=REAL(CFE)
        FIE(I)=AIMAG(CFE)
        FRT(I)=REAL(CFT)
        FIT(I)=AIMAG(CFT)
  32  CONTINUE
C
C.. DO INVERSE TRANSFORMS OF FUNCTION AND DERIVATIVES
      INV=1
      CALL FT01A(MN,INV,FRE,FIE)
      CALL FT01A(MN,INV,FRT,FIT)
C
      DO 35 J=2,NPKGEN(JPHASE,JSOURC)
       CALL FT01A(MN,INV,DR(1,J),DI(1,J))
  35  CONTINUE
C.. WRITE FUNCTION AND DERIVATIVES TO ARRAY PKLIST
      XTEM=1./XPKDEL(KMOD)
      DO 36 I=1,MN
      II=MOD(I+MN2,MN)
      PKLIST(II,1,KMOD)=(SW*FRE(I)+SW1*FRT(I))*XTEM
      PKLIST(II,2,KMOD)=(FRE(I)-FRT(I))*XTEM
      DO 37 J=2,NPKGEN(JPHASE,JSOURC)
      JJ=J+1
      PKLIST(II,JJ,KMOD)=DR(I,J)*XTEM
  37  CONTINUE
  36  CONTINUE
C
C.. FFT OVER
C
C... DO THE INTERPOLATIONS FOR YNORM AND DERIVATIVES FROM PKLIST
  26  JARGI=JFIX((ARGI-ARGK)/XPKDEL(KMOD))
      IARGI=JARGI+MN2+1
C.. WORK OUT ARGI OFFSET FROM "X(JARGI)" FOR INTERPOLATION
      POFF= (ARGI-ARGK)/XPKDEL(KMOD) - FLOAT(JARGI)
C.. WORK OUT INTERPOLATION COEFFICIENTS FOR FUNCTIONS AND ARGK DERIVATIVE
      C3FN(1)= 0.5*POFF*(POFF-1.)
      C3FN(2)= 1.-POFF**2
      C3FN(3)= 0.5*POFF*(POFF+1.)
      C3DN(1)= POFF-0.5
      C3DN(2)= -2.*POFF
      C3DN(3)= POFF+0.5
C
      YNORM=0.
      DYNDKQ=0.
      CALL GMZER(DYNDVQ,1,NPKGEN(JPHASE,JSOURC))
C
      DO 41 I=1,3
      II=IARGI+I-2
      PKTEM=PKLIST(II,1,KMOD)
      YNORM=YNORM+C3FN(I)*PKTEM
      DYNDKQ=DYNDKQ-C3DN(I)*PKTEM
      DO 42 NPKD=1,NPKGEN(JPHASE,JSOURC)
      NPKD1=NPKD+1
      DYNDVQ(NPKD)=DYNDVQ(NPKD)+C3FN(I)*PKLIST(II,NPKD1,KMOD)
  42  CONTINUE
  41  CONTINUE
C
C.. NOW CHECK IF YNORM IS ZERO BEFORE EVALUATING QUOTIENT DERIVATIVES
      IF(TESTOV(2.,YNORM)) THEN
        DYNDKQ=0.
        CALL GMZER(DYNDVQ,1,NPKGEN(JPHASE,JSOURC))
      ELSE
        DYNDKQ=DYNDKQ/(YNORM*XPKDEL(KMOD))
        CALL GMSCA(DYNDVQ,DYNDVQ,1./YNORM,1,NPKGEN(JPHASE,JSOURC))
      ENDIF
      GO TO 100
C
C PRE-PROFILE REFINEMENT STAGE
   5  CALL FDTF01(1)
      DEL= ARGI-ARGK
      TEMSQ= (TOLER(4,JPHASE,JSOURC)*PKFNVA(4))**2
      IF (DEL) 510,510,520
 520  AVTAU= PKFNVA(1)*TOLER(2,JPHASE,JSOURC)*PKFNVA(2) +
     & (1.-PKFNVA(1))*TOLER(3,JPHASE,JSOURC)*PKFNVA(3)
      TEMSQ= TEMSQ + AVTAU*AVTAU
 510  REFUSE= DEL*DEL .GT. TEMSQ
      GO TO 100
C
C N=6 *** CAILS *** SETTING UP SLACK AND STRICT CONSTRAINTS
C
    6 CALL FDTF01(1)
      DELT=ABS(AKLO-AKHI)
      AVTAU= PKFNVA(1)*PKFNVA(2) + (1.-PKFNVA(1))*PKFNVA(3)
C SQRT 8 LOG 2 AND LOG 2:
       FWHME=SQL2X8*PKFNVA(4) + ALOG2*AVTAU
       STRKT=DELT .LT. STRTOL*FWHME
       SLACK=0.
       IF (DELT .GE. SLKTOL*FWHME) GO TO 100
      SLACK=EXP(1.-(DELT/(SLKTOL*FWHME))**2)
      GO TO 100
C
C ENTRY 7 IS A WAY OF CALLING A SPECIFIC FDXX MATCHING PFXX.  ITS
C CALL IS PRECEDED BY A CALL TO PCXX(5) TO GET ALAMBD(1,JSOURC) FOR TOF,
C AND IT EXPECTS KNOW TO HOLD A CURRENT K:
   7  CALL FDTF01(1)
      F4PAR(2,KNOW)=PKFNVA(4)
      GO TO 100
 100  RETURN
      END
C
C
C
C
C
C
C LEVEL 6      SUBROUTINE PFTF02(N)
      SUBROUTINE PFTF02(N)
C
C *** PFTF02 updated by JCM 27 May 89 ***
C
CH Multiple entry Time of Flight Peak Function routine with FFT
CH and Voigt double exponential peak function
CA On entry N=1,2,5,6 or 7:
CA N=1: Set up program for data source TOF, peak function 02:
CA N=2: form peak function in YNORM, and its derivatives wrt paramet ers
CA N=5: Sets LOGICAL REFUSE to determine if reflection makes a sign ificant
CA      contribution to the profile at ARGI
CA N=6: CAILS entry to determine whether near reflections should be related
CA      by a strict or slack relationship.
CA N=7: SAPS entry to obey FDXXXX to set up a value(s) for PKFNVA
C
      COMPLEX CFFT,DFFT,DDT,CFE,CFT
      LOGICAL TESTOV
/CONSTA/
/F4PARS/
      COMMON /FFCONS/C1D45,C20D45,C64D45,C1D3,C4D3
/PAWLPR/
/PHASE/
/PRBLEM/
/PRPKCN/
/PRPKFN/
/PRSAVF/
/PWORDS/
/REFLNS/
/SOURCE/
      COMMON /SCRAT/C3FN(3),C3DN(3)
      PARAMETER (NW=5)
      CHARACTER *4 WDTF02(NW)
      DIMENSION IWTF02(3,NW)
      DATA WDTF02/'SWCH','TAUF','TAUS','SIGM','GAMM'/
      DATA IWTF02/3,3,0, 3,4,0, 3,5,0, 3,6,0, 3,7,0/
C
      GO TO (10,1,2,100,100,5,6,7) , N+1
C
C N=0: SET UP "DATA SOURCE TOF, PEAK TYPE 02"
  10  NPKGEN(JPHASE,JSOURC)=5
      NGEN4(JPHASE,JSOURC)=3
      LF3SP(3,JPHASE,JSOURC)=-2
      LF3SP(4,JPHASE,JSOURC)=-2
      LF3SP(5,JPHASE,JSOURC)=-2
      LF3SP(6,JPHASE,JSOURC)=-3
      LF3SP(7,JPHASE,JSOURC)=-3
      LF6SP(1,JSOURC)=1
      DO 9 I=1,NPKGEN(JPHASE,JSOURC)
   9  PWD(I,JPHASE,JSOURC)=WDTF02(I)
      C1D45 =1./45.
      C20D45=20./45.
      C64D45=64./45.
      C1D3=1./3.
      C4D3=4./3.
      GO TO 100
C
C N=1: ADD PACKED VOCABULARY FOR THIS SOURCE, THIS PHASE, TO THE MAIN LIST:
   1  CALL VOCAB(WDTF02,IWTF02,NW)
      GO TO 100
C
C PROFILE REFINEMENT STAGE:
 2    CALL FDTF02(2)
C.. FIRSTLY DECIDE WHETHER THE KTH PEAK IS ALREADY STORED IN THE
C.. ARRAY PKLIST. AT THIS POINT REFUSE = (K .EQ. KPOINT(KMOD))
C.. DETERMINED IN SUBROUTINE CALTF1 WHICH CALLS THIS ENTRY (IOPT=2)
      IF (REFUSE) GO TO 26
C
C.. THE PEAK HAS NOT OCCURRED ALREADY - CALCULATE THE COMPLETE PEAK
C.. SHAPE OF THE KTH PEAK BY FFT.
C
C.. FFT CALCULATION STAGE IN PROFILE REFINEMENT
C
C.. FIRST DETERMINE FFT LIMITS FOR PEAK SHAPE
%      MN=%FFT1%
      MN2=MN/2
      TEMSQ= (TOLER(4,JPHASE,JSOURC)*PKFNVA(4))**2
      AVTAU= PKFNVA(1)*TOLER(2,JPHASE,JSOURC)*PKFNVA(2) +
     & (1.-PKFNVA(1))*TOLER(3,JPHASE,JSOURC)*PKFNVA(3)
      TEMSQ= TEMSQ + AVTAU*AVTAU
      CAULIM= TOLER(5,JPHASE,JSOURC)*PKFNVA(5)
      XPKDEL(KMOD)=(SQRT(TEMSQ)+CAULIM)/FLOAT(MN2)
C
C.. NOW SET UP FAST FOURIER TRANSFORM
C.. THE INDIVIDUAL COMPONENTS FOR CONVOLUTION ARE IMMEDIATELY
C.. DESCRIBED IN FOURIER SPACE (GETS RID OF DISCONTINUITY PROBLEMS)
C
**      IEAGLE=NFFT
**      IF (IEAGLE .EQ. 0) IEAGLE=JFIX(TOLER(1,JPHASE,JSOURC))
      IEAGLE=JFIX(TOLER(1,JPHASE,JSOURC))
      IF (IEAGLE.EQ.3) THEN
        MNS=MN
        CALL FTSUB2(MNS)
        II=MNS/2-MN2
        DO 12 I=1,MN
        II=II+1
        DO 11 J=1,NPKGEN(JPHASE,JSOURC)+1
        PKLIST(I,J,KMOD)= (C1D45)*PKADD(II,J)
  11    CONTINUE
  12    CONTINUE
        MNS=2*MN
        CALL FTSUB2(MNS)
        II=MNS/2-MN2
        DO 14 I=1,MN
        II=II+1
        DO 13 J=1,NPKGEN(JPHASE,JSOURC)+1
        PKLIST(I,J,KMOD)= PKLIST(I,J,KMOD)-(C20D45)*PKADD(II,J)
  13    CONTINUE
  14    CONTINUE
        MNS=4*MN
        CALL FTSUB2(MNS)
        II=MNS/2-MN2
        DO 15 I=1,MN
        II=II+1
        DO 16 J=1,NPKGEN(JPHASE,JSOURC)+1
        PKLIST(I,J,KMOD)= PKLIST(I,J,KMOD)+(C64D45)*PKADD(II,J)
  16    CONTINUE
  15    CONTINUE
      ELSE IF (IEAGLE.EQ.2) THEN
        MNS=MN
        CALL FTSUB2(MNS)
        II=MNS/2-MN2
        DO 18 I=1,MN
        II=II+1
        DO 17  J=1,NPKGEN(JPHASE,JSOURC)+1
        PKLIST(I,J,KMOD)= -(C1D3)*PKADD(II,J)
  17    CONTINUE
  18    CONTINUE
        MNS=2*MN
        CALL FTSUB2(MNS)
        II=MNS/2-MN2
        DO 19 I=1,MN
        II=II+1
        DO 20 J=1,NPKGEN(JPHASE,JSOURC)+1
        PKLIST(I,J,KMOD)= PKLIST(I,J,KMOD)+(C4D3)*PKADD(II,J)
  20    CONTINUE
  19    CONTINUE
      ELSE
        MNS=MN
        CALL FTSUB2(MNS)
        II=MNS/2-MN2
        DO 39 I=1,MN
        II=II+1
        DO 38 J=1,NPKGEN(JPHASE,JSOURC)+1
        PKLIST(I,J,KMOD)= PKADD(II,J)
  38    CONTINUE
  39    CONTINUE
      ENDIF
C
C
C.. FFT OVER
C... DO THE INTERPOLATIONS FOR YNORM AND DERIVATIVES FROM PKLIST
  26  JARGI=JFIX((ARGI-ARGK)/XPKDEL(KMOD))
      IARGI=JARGI+MN2+1
C.. WORK OUT ARGI OFFSET FROM "X(JARGI)" FOR INTERPOLATION
      POFF= (ARGI-ARGK)/XPKDEL(KMOD) - FLOAT(JARGI)
C.. WORK OUT INTERPOLATION COEFFICIENTS FOR FUNCTIONS AND ARGK DERIVATIVE
      C3FN(1)= 0.5*POFF*(POFF-1.)
      C3FN(2)= 1.-POFF**2
      C3FN(3)= 0.5*POFF*(POFF+1.)
      C3DN(1)= POFF-0.5
      C3DN(2)= -2.*POFF
      C3DN(3)= POFF+0.5
C
      YNORM=0.
      DYNDKQ=0.
      CALL GMZER(DYNDVQ,1,NPKGEN(JPHASE,JSOURC))
C
      DO 41 I=1,3
      II=IARGI+I-2
      PKTEM=PKLIST(II,1,KMOD)
      YNORM=YNORM+C3FN(I)*PKTEM
      DYNDKQ=DYNDKQ-C3DN(I)*PKTEM
      DO 42 NPKD=1,NPKGEN(JPHASE,JSOURC)
      NPKD1=NPKD+1
      DYNDVQ(NPKD)=DYNDVQ(NPKD)+C3FN(I)*PKLIST(II,NPKD1,KMOD)
  42  CONTINUE
  41  CONTINUE
C
C.. NOW CHECK IF YNORM IS ZERO BEFORE EVALUATING QUOTIENT DERIVATIVES
      IF(TESTOV(2.,YNORM)) THEN
        DYNDKQ=0.
        CALL GMZER(DYNDVQ,1,NPKGEN(JPHASE,JSOURC))
      ELSE
        DYNDKQ=DYNDKQ/(YNORM*XPKDEL(KMOD))
        CALL GMSCA(DYNDVQ,DYNDVQ,1./YNORM,1,NPKGEN(JPHASE,JSOURC))
      ENDIF
      GO TO 100
C
C PRE-PROFILE REFINEMENT STAGE
   5  CALL FDTF02(1)
      DEL= ARGI-ARGK
      TEMSQ= (TOLER(4,JPHASE,JSOURC)*PKFNVA(4))**2
      CAULIM= TOLER(5,JPHASE,JSOURC)*PKFNVA(5)
      IF (DEL) 510,510,520
 520  AVTAU= PKFNVA(1)*TOLER(2,JPHASE,JSOURC)*PKFNVA(2) +
     & (1.-PKFNVA(1))*TOLER(3,JPHASE,JSOURC)*PKFNVA(3)
      TEMSQ= TEMSQ + AVTAU*AVTAU
 510  TEMLIM= CAULIM+SQRT(TEMSQ)
      REFUSE= ABS(DEL) .GT. TEMLIM
      GO TO 100
C
C N=6 *** CAILS *** SETTING UP SLACK AND STRICT CONSTRAINTS
C
    6 CALL FDTF02(1)
      DELT=ABS(AKLO-AKHI)
      AVTAU= PKFNVA(1)*PKFNVA(2) + (1.-PKFNVA(1))*PKFNVA(3)
C SQRT 8 LOG 2 AND LOG 2:
       FWHME=SQL2X8*PKFNVA(4) + ALOG2*AVTAU
       STRKT=DELT .LT. STRTOL*FWHME
      SLACK=0.
      IF (DELT .GE. SLKTOL*FWHME) GO TO 100
      SLACK=EXP(1.-(DELT/(SLKTOL*FWHME))**2)
      GO TO 100
C
   7  CALL FDTF02(1)
      F4PAR(2,KNOW)=PKFNVA(4)
      GO TO 100
 100  RETURN
      END
C
C
C
C
C LEVEL 6      SUBROUTINE PFTF03(N)
      SUBROUTINE PFTF03(N)
C
C *** PFTF03 updated by JCM 29 May 89 ***
C
CH Multiple entry Time of Flight Peak Function routine with FFT
CH and Peak Function with Voigt/double exponential/truncated quadratic
CH convolution
CA On entry N=1,2,5,6 or 7:
CA N=1: Set up program for data source TOF, peak function 03:
CA N=2: form peak function in YNORM, and its derivatives wrt paramet ers
CA N=5: Sets LOGICAL REFUSE to determine if reflection makes a sign ificant
CA      contribution to the profile at ARGI
CA N=6: CAILS entry to determine whether near reflections should be related
CA      by a strict or slack relationship.
CA N=7: SAPS entry to obey FDXXXX to set up a value(s) for PKFNVA
C
      COMPLEX CFFT,DFFT,DDT,CFE,CFT
      LOGICAL TESTOV
/CONSTA/
/F4PARS/
/PAWLPR/
/PHASE/
/PRBLEM/
/PRPKCN/
/PRPKFN/
/PRSAVF/
/PWORDS/
/REFLNS/
/SOURCE/
      PARAMETER (NW=6)
      COMMON /SCRAT/C3FN(3),C3DN(3)
      CHARACTER *4 WDTF03(NW)
      DIMENSION IWTF03(3,NW)
      DATA WDTF03/'SWCH','TAUF','TAUS','SIGM','GAMM', 'CANI'/
      DATA IWTF03/3,3,0, 3,4,0, 3,5,0, 3,6,0, 3,7,0, 3,8,0/
C
      GO TO (10,1,2,100,100,5,6,7) , N+1
C
C N=0: SET UP "DATA SOURCE TOF, PEAK TYPE 03"
  10  NPKGEN(JPHASE,JSOURC)=6
      NGEN4(JPHASE,JSOURC)=2
      LF3SP(3,JPHASE,JSOURC)=-2
      LF3SP(4,JPHASE,JSOURC)=-2
      LF3SP(5,JPHASE,JSOURC)=-2
      LF3SP(6,JPHASE,JSOURC)=-3
      LF3SP(7,JPHASE,JSOURC)=-3
      LF3SP(8,JPHASE,JSOURC)=-1
      LF6SP(1,JSOURC)=1
      DO 9 I=1,NPKGEN(JPHASE,JSOURC)
   9  PWD(I,JPHASE,JSOURC)=WDTF03(I)
      GO TO 100
C
C N=1: ADD PACKED VOCABULARY FOR THIS SOURCE, THIS PHASE, TO THE MAIN LIST:
   1  CALL VOCAB(WDTF03,IWTF03,NW)
      GO TO 100
C
C PROFILE REFINEMENT STAGE:
 2    CALL FDTF03(2)
C.. FIRSTLY DECIDE WHETHER THE KTH PEAK IS ALREADY STORED IN THE
C.. ARRAY PKLIST. AT THIS POINT REFUSE = (K .EQ. KPOINT(KMOD))
C.. DETERMINED IN SUBROUTINE CALTF1 WHICH CALLS THIS ENTRY (IOPT=2)
      IF (REFUSE) GO TO 26
C
C.. THE PEAK HAS NOT OCCURRED ALREADY - CALCULATE THE COMPLETE PEAK
C.. SHAPE OF THE KTH PEAK BY FFT.
C
C.. FFT CALCULATION STAGE IN PROFILE REFINEMENT
C
C.. FIRST DETERMINE FFT LIMITS FOR PEAK SHAPE
%      MN=%FFT1%
      MN2=MN/2
      TEMSQ= (TOLER(4,JPHASE,JSOURC)*PKFNVA(4))**2
      AVTAU= PKFNVA(1)*TOLER(2,JPHASE,JSOURC)*PKFNVA(2) +
     & (1.-PKFNVA(1))*TOLER(3,JPHASE,JSOURC)*PKFNVA(3)
      TEMSQ= TEMSQ + AVTAU*AVTAU
      CAULIM= TOLER(5,JPHASE,JSOURC)*PKFNVA(5)+
     & TOLER(6,JPHASE,JSOURC)*PKFNVA(6)
      XPKDEL(KMOD)=(SQRT(TEMSQ)+CAULIM)/FLOAT(MN2)
C
C.. NOW SET UP FAST FOURIER TRANSFORM
C.. THE INDIVIDUAL COMPONENTS FOR CONVOLUTION ARE IMMEDIATELY
C.. DESCRIBED IN FOURIER SPACE (GETS RID OF DISCONTINUITY PROBLEMS)
C
      IEAGLE=NFFT
      IF (IEAGLE .EQ. 0) IEAGLE=JFIX(TOLER(1,JPHASE,JSOURC))
      IF (IEAGLE.EQ.3) THEN
        MNS=MN
        CALL FTSUB3(MNS)
        II=MNS/2-MN2
        DO 12 I=1,MN
        II=II+1
        DO 11 J=1,NPKGEN(JPHASE,JSOURC)+1
        PKLIST(I,J,KMOD)= (1./45.)*PKADD(II,J)
  11    CONTINUE
  12    CONTINUE
        MNS=2*MN
        CALL FTSUB3(MNS)
        II=MNS/2-MN2
        DO 14 I=1,MN
        II=II+1
        DO 13 J=1,NPKGEN(JPHASE,JSOURC)+1
        PKLIST(I,J,KMOD)= PKLIST(I,J,KMOD)-(20./45.)*PKADD(II,J)
  13    CONTINUE
  14    CONTINUE
        MNS=4*MN
        CALL FTSUB3(MNS)
        II=MNS/2-MN2
        DO 15 I=1,MN
        II=II+1
        DO 16 J=1,NPKGEN(JPHASE,JSOURC)+1
        PKLIST(I,J,KMOD)= PKLIST(I,J,KMOD)+(64./45.)*PKADD(II,J)
  16    CONTINUE
  15    CONTINUE
      ELSE IF (IEAGLE.EQ.2) THEN
        MNS=MN
        CALL FTSUB3(MNS)
        II=MNS/2-MN2
        DO 18 I=1,MN
        II=II+1
        DO 17 J=1,NPKGEN(JPHASE,JSOURC)+1
        PKLIST(I,J,KMOD)= -(1./3.)*PKADD(II,J)
  17    CONTINUE
  18    CONTINUE
        MNS=2*MN
        CALL FTSUB3(MNS)
        II=MNS/2-MN2
        DO 19 I=1,MN
        II=II+1
        DO 20 J=1,NPKGEN(JPHASE,JSOURC)+1
        PKLIST(I,J,KMOD)= PKLIST(I,J,KMOD)+(4./3.)*PKADD(II,J)
  20    CONTINUE
  19    CONTINUE
      ELSE
        MNS=MN
        CALL FTSUB3(MNS)
        II=MNS/2-MN2
        DO 39  I=1,MN
        II=II+1
        DO 38 J=1,NPKGEN(JPHASE,JSOURC)+1
        PKLIST(I,J,KMOD)= PKADD(II,J)
  38    CONTINUE
  39    CONTINUE
      ENDIF
C
C
C
C.. FFT OVER
C... DO THE INTERPOLATIONS FOR YNORM AND DERIVATIVES FROM PKLIST
  26  JARGI=JFIX((ARGI-ARGK)/XPKDEL(KMOD))
      IARGI=JARGI+MN2+1
C.. WORK OUT ARGI OFFSET FROM "X(JARGI)" FOR INTERPOLATION
      POFF= (ARGI-ARGK)/XPKDEL(KMOD) - FLOAT(JARGI)
C.. WORK OUT INTERPOLATION COEFFICIENTS FOR FUNCTIONS AND ARGK DERIVATIVE
      C3FN(1)= 0.5*POFF*(POFF-1.)
      C3FN(2)= 1.-POFF**2
      C3FN(3)= 0.5*POFF*(POFF+1.)
      C3DN(1)= POFF-0.5
      C3DN(2)= -2.*POFF
      C3DN(3)= POFF+0.5
C
      YNORM=0.
      DYNDKQ=0.
      CALL GMZER(DYNDVQ,1,NPKGEN(JPHASE,JSOURC))
C
      DO 41 I=1,3
      II=IARGI+I-2
      PKTEM=PKLIST(II,1,KMOD)
      YNORM=YNORM+C3FN(I)*PKTEM
      DYNDKQ=DYNDKQ-C3DN(I)*PKTEM
      DO 42 NPKD=1,NPKGEN(JPHASE,JSOURC)
      NPKD1=NPKD+1
      DYNDVQ(NPKD)=DYNDVQ(NPKD)+C3FN(I)*PKLIST(II,NPKD1,KMOD)
  42  CONTINUE
  41  CONTINUE
C
C.. NOW CHECK IF YNORM IS ZERO BEFORE EVALUATING QUOTIENT DERIVATIVES
      IF (TESTOV(2.,YNORM)) THEN
        DYNDKQ=0.
        CALL GMZER(DYNDVQ,1,NPKGEN(JPHASE,JSOURC))
      ELSE
        DYNDKQ=DYNDKQ/(YNORM*XPKDEL(KMOD))
        CALL GMSCA(DYNDVQ,DYNDVQ,1./YNORM,1,NPKGEN(JPHASE,JSOURC))
      ENDIF
      GO TO 100
C
C PRE-PROFILE REFINEMENT STAGE
   5  CALL FDTF03(1)
      DEL= ARGI-ARGK
      TEMSQ= (TOLER(4,JPHASE,JSOURC)*PKFNVA(4))**2
      CAULIM= TOLER(5,JPHASE,JSOURC)*PKFNVA(5)+
     & TOLER(6,JPHASE,JSOURC)*PKFNVA(6)
      IF (DEL) 510,510,520
 520  AVTAU= PKFNVA(1)*TOLER(2,JPHASE,JSOURC)*PKFNVA(2) +
     & (1.-PKFNVA(1))*TOLER(3,JPHASE,JSOURC)*PKFNVA(3)
      TEMSQ= TEMSQ + AVTAU*AVTAU
 510  TEMLIM= CAULIM+SQRT(TEMSQ)
      REFUSE= ABS(DEL) .GT. TEMLIM
      GO TO 100
C
C N=6 *** CAILS *** SETTING UP SLACK AND STRICT CONSTRAINTS
C
    6 CALL FDTF03(1)
      DELT=ABS(AKLO-AKHI)
      AVTAU= PKFNVA(1)*PKFNVA(2) + (1.-PKFNVA(1))*PKFNVA(3)
C SQRT 8 LOG 2 AND LOG 2:
       FWHME=SQL2X8*PKFNVA(4) + ALOG2*AVTAU
       STRKT=DELT .LT. STRTOL*FWHME
      SLACK=0.
      IF (DELT .GE. SLKTOL*FWHME) GO TO 100
      SLACK=EXP(1.-(DELT/(SLKTOL*FWHME))**2)
      GO TO 100
C
   7  CALL FDTF03(1)
      F4PAR(2,KNOW)=PKFNVA(4)
      GO TO 100
 100  RETURN
      END
C
C
C
C
C LEVEL 4      SUBROUTINE PFTF04(N)
      SUBROUTINE PFTF04(N)
C
C *** PFTF04 updated by WIFD/JCM 19 Jul 88 ***
C
CX
CC 19B
CH Multiple entry Time of Flight Peak Function (type 04) routine with FFT.
CA On entry N=1 means read and interpret a L PKFN card.  These cards have a
CA second word, one of a vocabulary of:
CA     SWCH
CA     TAUF
CA     TAUS
CA     SIGM
CA     GAMM
CA     POWR
CA followed by the width parameters involved in this particular peak
CA descriptor.
CA
CA Entry N=2 forms the normalised peak function, and puts it in YNORM.  It also
CA gives all necessary derivatives of YNORM with respect to anything that could
CA be a parameter.
CA
CA Entry N=3 applies a shift to genus IGEN, species ISPC.
CA
CA Entry N=4 outputs a new L PKFN card.
CA
CA Entry N=5 sets LOGICAL REFUSE to say whether or not reflection to be used,
CA i.e. whether this reflection is near enough to this intensity to contribute
CA to it.
C
      PARAMETER (NW=6)
      CHARACTER *4 WORD,WDTF04(NW)
      COMPLEX CFFT,DFFT,DDT,CFE,CFT
      LOGICAL TESTOV
      DIMENSION C3FN(3),C3DN(3),IWTF04(3,NW)
/CARDRC/
/CONSTA/
/F4PARS/
/IOUNIT/
/NEWOLD/
/PAWLPR/
/PHASE/
/PRBLEM/
/PRPKCN/
/PRPKFN/
/PRSAVF/
/PWORDS/
/REFLNS/
/SOURCE/
      DATA WDTF04/'SWCH','TAUF','TAUS','SIGM','GAMM','POWR'/
      DATA IWTF04/3,3,0, 3,4,0, 3,5,0, 3,6,0, 3,7,0, 3,8,0/
C
      GO TO (10,1,2,100,100,5,6,7) , N+1
C
C N=0: SET UP "DATA SOURCE TOF, PEAK TYPE 04"
  10  NPKGEN(JPHASE,JSOURC)=6
      NGEN4(JPHASE,JSOURC)=3
      LF3SP(3,JPHASE,JSOURC)=-1
      LF3SP(4,JPHASE,JSOURC)=-2
      LF3SP(5,JPHASE,JSOURC)=-2
      LF3SP(6,JPHASE,JSOURC)=-3
      LF3SP(7,JPHASE,JSOURC)=-3
      LF3SP(8,JPHASE,JSOURC)=-1
      LF6SP(1,JSOURC)=1
      DO 49 I=1,NPKGEN(JPHASE,JSOURC)
  49  PWD(I,JPHASE,JSOURC)=WDTF04(I)
      GO TO 100
C
C N=1: ADD PACKED VOCABULARY FOR THIS SOURCE, THIS PHASE, TO THE MAIN LIST:
   1  CALL VOCAB(WDTF04,IWTF04,NW)
      GO TO 100
C
C PROFILE REFINEMENT STAGE:
 2    CALL FDTF04(2)
C
C.. FIRSTLY DECIDE WHETHER THE KTH PEAK IS ALREADY STORED IN THE
C.. ARRAY PKLIST. AT THIS POINT REFUSE = (K .EQ. KPOINT(KMOD))
C.. DETERMINED IN SUBROUTINE CALTF1 WHICH CALLS THIS ENTRY (IOPT=2)
      IF (REFUSE) GO TO 26
C
C.. THE PEAK HAS NOT OCCURRED ALREADY - CALCULATE THE COMPLETE PEAK
C.. SHAPE OF THE KTH PEAK BY FFT.
C
C.. FFT CALCULATION STAGE IN PROFILE REFINEMENT
C
C.. FIRST DETERMINE FFT LIMITS FOR PEAK SHAPE
%      MN=%FFT1%
      MN=64
      MN2=MN/2
      TEMSQ= (TOLER(4,JPHASE,JSOURC)*PKFNVA(4))**2
      AVTAU= TOLER(2,JPHASE,JSOURC)*PKFNVA(2) +
     & PKFNVA(1)*TOLER(3,JPHASE,JSOURC)*PKFNVA(3)
      TEMSQ= TEMSQ + AVTAU*AVTAU
      CAULIM= TOLER(5,JPHASE,JSOURC)*PKFNVA(5)
      XPKDEL(KMOD)=(SQRT(TEMSQ)+CAULIM)/FLOAT(MN2)
C
C.. NOW SET UP FAST FOURIER TRANSFORM
C.. THE INDIVIDUAL COMPONENTS FOR CONVOLUTION ARE IMMEDIATELY
C.. DESCRIBED IN FOURIER SPACE (GETS RID OF DISCONTINUITY PROBLEMS)
C
      IEAGLE=JFIX(TOLER(1,JPHASE,JSOURC))
      IF (IEAGLE.EQ.3) THEN
        MNS=MN
        CALL FTSUB4(MNS)
        II=MNS/2-MN2
        DO 12 I=1,MN
          II=II+1
      DO 11 J=1,NPKGEN(JPHASE,JSOURC)+1
        PKLIST(I,J,KMOD)= (1./45.)*PKADD(II,J)
  11  CONTINUE
  12  CONTINUE
        MNS=2*MN
        CALL FTSUB4(MNS)
        II=MNS/2-MN2
      DO 14 I=1,MN
      II=II+1
      DO 13 J=1,NPKGEN(JPHASE,JSOURC)+1
      PKLIST(I,J,KMOD)= PKLIST(I,J,KMOD)-(20./45.)*PKADD(II,J)
  13  CONTINUE
  14  CONTINUE
      MNS=4*MN
      CALL FTSUB4(MNS)
      II=MNS/2-MN2
      DO 15 I=1,MN
      II=II+1
      DO 16 J=1,NPKGEN(JPHASE,JSOURC)+1
      PKLIST(I,J,KMOD)= PKLIST(I,J,KMOD)+(64./45.)*PKADD(II,J)
  16  CONTINUE
  15  CONTINUE
      ELSE IF (IEAGLE.EQ.2) THEN
        MNS=MN
        CALL FTSUB4(MNS)
        II=MNS/2-MN2
      DO 18 I=1,MN
      II=II+1
      DO 17  J=1,NPKGEN(JPHASE,JSOURC)+1
        PKLIST(I,J,KMOD)= -(1./3.)*PKADD(II,J)
  17  CONTINUE
  18  CONTINUE
      MNS=2*MN
      CALL FTSUB4(MNS)
      II=MNS/2-MN2
      DO 19 I=1,MN
      II=II+1
      DO 20 J=1,NPKGEN(JPHASE,JSOURC)+1
      PKLIST(I,J,KMOD)= PKLIST(I,J,KMOD)+(4./3.)*PKADD(II,J)
  20  CONTINUE
  19  CONTINUE
      ELSE
      MNS=MN
      CALL FTSUB4(MNS)
      II=MNS/2-MN2
      DO 9 I=1,MN
      II=II+1
      DO 8 J=1,NPKGEN(JPHASE,JSOURC)+1
      PKLIST(I,J,KMOD)= PKADD(II,J)
   8  CONTINUE
   9  CONTINUE
      END IF
C
C
C.. FFT OVER
C... DO THE INTERPOLATIONS FOR YNORM AND DERIVATIVES FROM PKLIST
C 88.04  26  JARGI=JNINT((ARGI-ARGK)/XPKDEL(KMOD))
C 88.04 JNINT to NINT in pftf04. From KS diff
  26  JARGI=NINT((ARGI-ARGK)/XPKDEL(KMOD))
      IARGI=JARGI+MN2+1
C.. WORK OUT ARGI OFFSET FROM "X(JARGI)" FOR INTERPOLATION
      POFF= (ARGI-ARGK)/XPKDEL(KMOD) - FLOAT(JARGI)
C.. WORK OUT INTERPOLATION COEFFICIENTS FOR FUNCTIONS AND ARGK DERIVATIVE
      C3FN(1)= 0.5*POFF*(POFF-1.)
      C3FN(2)= 1.-POFF**2
      C3FN(3)= 0.5*POFF*(POFF+1.)
      C3DN(1)= POFF-0.5
      C3DN(2)= -2.*POFF
      C3DN(3)= POFF+0.5
C
      YNORM=0.
      DYNDKQ=0.
      CALL GMZER(DYNDVQ,1,NPKGEN(JPHASE,JSOURC))
C
      DO 41 I=1,3
      II=IARGI+I-2
      PKTEM=PKLIST(II,1,KMOD)
      YNORM=YNORM+C3FN(I)*PKTEM
      DYNDKQ=DYNDKQ-C3DN(I)*PKTEM
      DO 42 NPKD=1,NPKGEN(JPHASE,JSOURC)
      NPKD1=NPKD+1
      DYNDVQ(NPKD)=DYNDVQ(NPKD)+C3FN(I)*PKLIST(II,NPKD1,KMOD)
  42  CONTINUE
  41  CONTINUE
C
C.. NOW CHECK IF YNORM IS ZERO BEFORE EVALUATING QUOTIENT DERIVATIVES
      IF(TESTOV(2.,YNORM)) THEN
      DYNDKQ=0.
      CALL GMZER(DYNDVQ,1,NPKGEN(JPHASE,JSOURC))
      ELSE
      DYNDKQ=DYNDKQ/(YNORM*XPKDEL(KMOD))
      CALL GMSCA(DYNDVQ,DYNDVQ,1./YNORM,1,NPKGEN(JPHASE,JSOURC))
      ENDIF
      GO TO 100
C
C PRE-PROFILE REFINEMENT STAGE
   5  CALL FDTF04(1)
      DEL= ARGI-ARGK
      TEMSQ= (TOLER(4,JPHASE,JSOURC)*PKFNVA(4))**2
      CAULIM= TOLER(5,JPHASE,JSOURC)*PKFNVA(5)
      IF (DEL) 510,510,520
 520  AVTAU= TOLER(2,JPHASE,JSOURC)*PKFNVA(2) +
     & PKFNVA(1)*TOLER(3,JPHASE,JSOURC)*PKFNVA(3)
C 520  AVTAU= PKFNVA(1)*TOLER(2,JPHASE,JSOURC)*PKFNVA(2) + (1.-PKFNVA(1))*
C     +       TOLER(3,JPHASE,JSOURC)*PKFNVA(3)
      TEMSQ= TEMSQ + AVTAU*AVTAU
 510  TEMLIM= CAULIM+SQRT(TEMSQ)
      REFUSE= ABS(DEL) .GT. TEMLIM
      GO TO 100
C
C N=6 *** CAILS *** SETTING UP SLACK AND STRICT CONSTRAINTS
C
    6 CALL FDTF04(1)
      DELT=ABS(AKLO-AKHI)
      AVTAU= TOLER(2,JPHASE,JSOURC)*PKFNVA(2) +
     & PKFNVA(1)*TOLER(3,JPHASE,JSOURC)*PKFNVA(3)
C      AVTAU= PKFNVA(1)*PKFNVA(2) + (1.-PKFNVA(1))*PKFNVA(3)
C SQRT 8 LOG 2 AND LOG 2:
       FWHME=SQL2X8*PKFNVA(4) + PKFNVA(5) + ALOG2*AVTAU
       STRKT=DELT .LT. STRTOL*FWHME
      SLACK=0.
      IF (DELT .GE. SLKTOL*FWHME) GO TO 100
      SLACK=EXP(1.-(DELT/(SLKTOL*FWHME))**2)
      GO TO 100
C
   7  CALL FDTF04(1)
      F4PAR(2,KNOW)=PKFNVA(1)
      F4PAR(3,KNOW)=PKFNVA(4)
      GO TO 100
 100  RETURN
      END
C
*** NB DIFFERENT NAMES FOR GENERA OF FAMILY 4 - SETTLE THIS WITH STEVE & BILL
***     A'INTS','SWHS','SIGS',
***     A4,1,0, 4,2,0, 4,3,0,
C
C
C
C
C LEVEL 4      SUBROUTINE PFTF05(N)
      SUBROUTINE PFTF05(N)
C
C *** PFTF05 updated by JCM 27 May 89 ***
C
CH Multiple entry Time of Flight Peak Function routine with FFT
CH and Voigt double exponential peak function
CA On entry N=1,2,5,6 or 7:
CA N=1: Set up program for data source TOF, peak function 05:
CA N=2: form peak function in YNORM, and its derivatives wrt paramet ers
CA N=5: Sets LOGICAL REFUSE to determine if reflection makes a sign ificant
CA      contribution to the profile at ARGI
CA N=6: CAILS entry to determine whether near reflections should be related
CA      by a strict or slack relationship.
CA N=7: SAPS entry to obey FDXXXX to set up a value(s) for PKFNVA
C
      COMPLEX CFFT,DFFT,DDT,CFE,CFT
      LOGICAL TESTOV
/CONSTA/
/F4PARS/
      COMMON /FFCONS/C1D45,C20D45,C64D45,C1D3,C4D3
/PAWLPR/
/PHASE/
/PRBLEM/
/PRPKCN/
/PRPKFN/
/PRSAVF/
/PWORDS/
/REFLNS/
/SOURCE/
      COMMON /SCRAT/C3FN(3),C3DN(3)
      PARAMETER (NW=8)
      CHARACTER *4 WDTF05(NW)
      DIMENSION IWTF05(3,NW)
      DATA WDTF05/'SWCH','TAUF','TAUS','SIGM','GAMM',
     &'ESIG','SHFT','SIZE'/
      DATA IWTF05/3,3,0, 3,4,0, 3,5,0, 3,6,0, 3,7,0,
     &3,8,0, 3,9,0, 3,10,0 /
C
      GO TO (10,1,2,100,100,5,6,7) , N+1
C
C N=0: SET UP "DATA SOURCE TOF, PEAK TYPE 05"
  10  NPKGEN(JPHASE,JSOURC)=8
      NGEN4(JPHASE,JSOURC)=3
      LF3SP(3,JPHASE,JSOURC)=-2
      LF3SP(4,JPHASE,JSOURC)=-2
      LF3SP(5,JPHASE,JSOURC)=-2
      LF3SP(6,JPHASE,JSOURC)=-3
      LF3SP(7,JPHASE,JSOURC)=-3
      LF3SP(8,JPHASE,JSOURC)=-2
      LF3SP(9,JPHASE,JSOURC)=-2
      LF3SP(10,JPHASE,JSOURC)=-1
      LF6SP(1,JSOURC)=1
      DO 9 I=1,NPKGEN(JPHASE,JSOURC)
   9  PWD(I,JPHASE,JSOURC)=WDTF05(I)
      C1D45 =1./45.
      C20D45=20./45.
      C64D45=64./45.
      C1D3=1./3.
      C4D3=4./3.
      GO TO 100
C
C N=1: ADD PACKED VOCABULARY FOR THIS SOURCE, THIS PHASE, TO THE MAIN LIST:
   1  CALL VOCAB(WDTF05,IWTF05,NW)
      GO TO 100
C
C PROFILE REFINEMENT STAGE:
 2    CALL FDTF05(2)
C.. FIRSTLY DECIDE WHETHER THE KTH PEAK IS ALREADY STORED IN THE
C.. ARRAY PKLIST. AT THIS POINT REFUSE = (K .EQ. KPOINT(KMOD))
C.. DETERMINED IN SUBROUTINE CALTF1 WHICH CALLS THIS ENTRY (IOPT=2)
      IF (REFUSE) GO TO 26
C
C.. THE PEAK HAS NOT OCCURRED ALREADY - CALCULATE THE COMPLETE PEAK
C.. SHAPE OF THE KTH PEAK BY FFT.
C
C.. FFT CALCULATION STAGE IN PROFILE REFINEMENT
C
C.. FIRST DETERMINE FFT LIMITS FOR PEAK SHAPE
%      MN=%FFT1%
      MN2=MN/2
      TEMSQ= (TOLER(4,JPHASE,JSOURC)*PKFNVA(4))**2
      AVTAU= PKFNVA(1)*TOLER(2,JPHASE,JSOURC)*PKFNVA(2) +
     & (1.-PKFNVA(1))*TOLER(3,JPHASE,JSOURC)*PKFNVA(3)
      TEMSQ= TEMSQ + AVTAU*AVTAU
      CAULIM= TOLER(5,JPHASE,JSOURC)*PKFNVA(5)
      XPKDEL(KMOD)=(SQRT(TEMSQ)+CAULIM+ABS(PKFNVA(7)))/FLOAT(MN2)
C
C.. NOW SET UP FAST FOURIER TRANSFORM
C.. THE INDIVIDUAL COMPONENTS FOR CONVOLUTION ARE IMMEDIATELY
C.. DESCRIBED IN FOURIER SPACE (GETS RID OF DISCONTINUITY PROBLEMS)
C
**      IEAGLE=NFFT
**      IF (IEAGLE .EQ. 0) IEAGLE=JFIX(TOLER(1,JPHASE,JSOURC))
      IEAGLE=JFIX(TOLER(1,JPHASE,JSOURC))
      IF (IEAGLE.EQ.3) THEN
        MNS=MN
        CALL FTSUB5(MNS)
        II=MNS/2-MN2
        DO 12 I=1,MN
        II=II+1
        DO 11 J=1,NPKGEN(JPHASE,JSOURC)+1
        PKLIST(I,J,KMOD)= (C1D45)*PKADD(II,J)
  11    CONTINUE
  12    CONTINUE
        MNS=2*MN
        CALL FTSUB5(MNS)
        II=MNS/2-MN2
        DO 14 I=1,MN
        II=II+1
        DO 13 J=1,NPKGEN(JPHASE,JSOURC)+1
        PKLIST(I,J,KMOD)= PKLIST(I,J,KMOD)-(C20D45)*PKADD(II,J)
  13    CONTINUE
  14    CONTINUE
        MNS=4*MN
        CALL FTSUB5(MNS)
        II=MNS/2-MN2
        DO 15 I=1,MN
        II=II+1
        DO 16 J=1,NPKGEN(JPHASE,JSOURC)+1
        PKLIST(I,J,KMOD)= PKLIST(I,J,KMOD)+(C64D45)*PKADD(II,J)
  16    CONTINUE
  15    CONTINUE
      ELSE IF (IEAGLE.EQ.2) THEN
        MNS=MN
        CALL FTSUB5(MNS)
        II=MNS/2-MN2
        DO 18 I=1,MN
        II=II+1
        DO 17  J=1,NPKGEN(JPHASE,JSOURC)+1
        PKLIST(I,J,KMOD)= -(C1D3)*PKADD(II,J)
  17    CONTINUE
  18    CONTINUE
        MNS=2*MN
        CALL FTSUB5(MNS)
        II=MNS/2-MN2
        DO 19 I=1,MN
        II=II+1
        DO 20 J=1,NPKGEN(JPHASE,JSOURC)+1
        PKLIST(I,J,KMOD)= PKLIST(I,J,KMOD)+(C4D3)*PKADD(II,J)
  20    CONTINUE
  19    CONTINUE
      ELSE
        MNS=MN
        CALL FTSUB5(MNS)
        II=MNS/2-MN2
        DO 39 I=1,MN
        II=II+1
        DO 38 J=1,NPKGEN(JPHASE,JSOURC)+1
        PKLIST(I,J,KMOD)= PKADD(II,J)
  38    CONTINUE
  39    CONTINUE
      ENDIF
C
C
C.. FFT OVER
C... DO THE INTERPOLATIONS FOR YNORM AND DERIVATIVES FROM PKLIST
  26  JARGI=JFIX((ARGI-ARGK)/XPKDEL(KMOD))
      IARGI=JARGI+MN2+1
C.. WORK OUT ARGI OFFSET FROM "X(JARGI)" FOR INTERPOLATION
      POFF= (ARGI-ARGK)/XPKDEL(KMOD) - FLOAT(JARGI)
C.. WORK OUT INTERPOLATION COEFFICIENTS FOR FUNCTIONS AND ARGK DERIVATIVE
      C3FN(1)= 0.5*POFF*(POFF-1.)
      C3FN(2)= 1.-POFF**2
      C3FN(3)= 0.5*POFF*(POFF+1.)
      C3DN(1)= POFF-0.5
      C3DN(2)= -2.*POFF
      C3DN(3)= POFF+0.5
C
      YNORM=0.
      DYNDKQ=0.
      CALL GMZER(DYNDVQ,1,NPKGEN(JPHASE,JSOURC))
C
      DO 41 I=1,3
      II=IARGI+I-2
      PKTEM=PKLIST(II,1,KMOD)
      YNORM=YNORM+C3FN(I)*PKTEM
      DYNDKQ=DYNDKQ-C3DN(I)*PKTEM
      DO 42 NPKD=1,NPKGEN(JPHASE,JSOURC)
      NPKD1=NPKD+1
      DYNDVQ(NPKD)=DYNDVQ(NPKD)+C3FN(I)*PKLIST(II,NPKD1,KMOD)
  42  CONTINUE
  41  CONTINUE
C
C.. NOW CHECK IF YNORM IS ZERO BEFORE EVALUATING QUOTIENT DERIVATIVES
      IF(TESTOV(2.,YNORM)) THEN
        DYNDKQ=0.
        CALL GMZER(DYNDVQ,1,NPKGEN(JPHASE,JSOURC))
      ELSE
        DYNDKQ=DYNDKQ/(YNORM*XPKDEL(KMOD))
        CALL GMSCA(DYNDVQ,DYNDVQ,1./YNORM,1,NPKGEN(JPHASE,JSOURC))
      ENDIF
      GO TO 100
C
C PRE-PROFILE REFINEMENT STAGE
   5  CALL FDTF05(1)
      DEL= ARGI-ARGK
      TEMSQ= (TOLER(4,JPHASE,JSOURC)*PKFNVA(4))**2
      TEMSQ2= TEMSQ+(TOLER(6,JPHASE,JSOURC)*PKFNVA(6))**2
      CAULIM= TOLER(5,JPHASE,JSOURC)*PKFNVA(5)
      IF (DEL) 510,510,520
 520  AVTAU= PKFNVA(1)*TOLER(2,JPHASE,JSOURC)*PKFNVA(2) +
     & (1.-PKFNVA(1))*TOLER(3,JPHASE,JSOURC)*PKFNVA(3)
      TEMSQ= TEMSQ + AVTAU*AVTAU
      IF (PKFNVA(7).GT.0.) CAULIM=CAULIM+PKFNVA(7)
 510  IF (PKFNVA(7).LE.0.) CAULIM=CAULIM-PKFNVA(7)
      TEMLIM= CAULIM+SQRT(TEMSQ)
      REFUSE= ABS(DEL) .GT. TEMLIM
      GO TO 100
C
C N=6 *** CAILS *** SETTING UP SLACK AND STRICT CONSTRAINTS
C
    6 CALL FDTF05(1)
      DELT=ABS(AKLO-AKHI)
      AVTAU= PKFNVA(1)*PKFNVA(2) + (1.-PKFNVA(1))*PKFNVA(3)
C SQRT 8 LOG 2 AND LOG 2:
       FWHME=SQL2X8*PKFNVA(4) + ALOG2*AVTAU
       STRKT=DELT .LT. STRTOL*FWHME
      SLACK=0.
      IF (DELT .GE. SLKTOL*FWHME) GO TO 100
      SLACK=EXP(1.-(DELT/(SLKTOL*FWHME))**2)
      GO TO 100
C
   7  CALL FDTF05(1)
      F4PAR(2,KNOW)=PKFNVA(4)
      GO TO 100
 100  RETURN
      END
C
C
C
C
C LEVEL 6      SUBROUTINE PFTF06(N)
      SUBROUTINE PFTF06(N)
C
C *** PFTF06 from PFTF02 - JPW/JBF 2/5/00  ***
C
C Add hkl dependent line broadening in the gamm 2 parameter as:
C
C GAMM = H^2*G11 + K^2*G22 + L^2*G33 + HK*G12 + KL*G23 + HL*G13
C
C See ... GSAS TOF peakshape 3, ref in CrPO4 paper (Line, epdic abstracts)
C
CH Multiple entry Time of Flight Peak Function routine with FFT
CH and Voigt double exponential peak function
CA On entry N=1,2,5,6 or 7:
CA N=1: Set up program for data source TOF, peak function 02:
CA N=2: form peak function in YNORM, and its derivatives wrt paramet ers
CA N=5: Sets LOGICAL REFUSE to determine if reflection makes a sign ificant
CA      contribution to the profile at ARGI
CA N=6: CAILS entry to determine whether near reflections should be related
CA      by a strict or slack relationship.
CA N=7: SAPS entry to obey FDXXXX to set up a value(s) for PKFNVA
C
      COMPLEX CFFT,DFFT,DDT,CFE,CFT
      LOGICAL TESTOV
/CONSTA/
/F4PARS/
/FFCONS/
/PAWLPR/
/PHASE/
/PRBLEM/
/PRPKCN/
/PRPKFN/
/PRSAVF/
/PWORDS/
/REFLNS/
/SOURCE/
      COMMON /SCRAT/C3FN(3),C3DN(3)
      PARAMETER (NW=5)
      CHARACTER *4 WDTF06(NW)
      DIMENSION IWTF06(3,NW)
      DATA WDTF06/'SWCH','TAUF','TAUS','SIGM','GAMM'/
      DATA IWTF06/3,3,0, 3,4,0, 3,5,0, 3,6,0, 3,7,0/
C
      GO TO (10,1,2,100,100,5,6,7) , N+1
C
C N=0: SET UP "DATA SOURCE TOF, PEAK TYPE 02"
  10  NPKGEN(JPHASE,JSOURC)=5
      NGEN4(JPHASE,JSOURC)=3
      LF3SP(3,JPHASE,JSOURC)=-2
      LF3SP(4,JPHASE,JSOURC)=-2
      LF3SP(5,JPHASE,JSOURC)=-2
      LF3SP(6,JPHASE,JSOURC)=-3
C Make gamm now have six species
      LF3SP(7,JPHASE,JSOURC)=-6
      LF6SP(1,JSOURC)=1
      DO 9 I=1,NPKGEN(JPHASE,JSOURC)
   9  PWD(I,JPHASE,JSOURC)=WDTF06(I)
      C1D45 =1./45.
      C20D45=20./45.
      C64D45=64./45.
      C1D3=1./3.
      C4D3=4./3.
      GO TO 100
C
C N=1: ADD PACKED VOCABULARY FOR THIS SOURCE, THIS PHASE, TO THE MAIN LIST:
   1  CALL VOCAB(WDTF06,IWTF06,NW)
      GO TO 100
C
C PROFILE REFINEMENT STAGE:
 2    CALL FDTF06(2)
C.. FIRSTLY DECIDE WHETHER THE KTH PEAK IS ALREADY STORED IN THE
C.. ARRAY PKLIST. AT THIS POINT REFUSE = (K .EQ. KPOINT(KMOD))
C.. DETERMINED IN SUBROUTINE CALTF1 WHICH CALLS THIS ENTRY (IOPT=2)
      IF (REFUSE) GO TO 26
C
C.. THE PEAK HAS NOT OCCURRED ALREADY - CALCULATE THE COMPLETE PEAK
C.. SHAPE OF THE KTH PEAK BY FFT.
C
C.. FFT CALCULATION STAGE IN PROFILE REFINEMENT
C
C.. FIRST DETERMINE FFT LIMITS FOR PEAK SHAPE
%      MN=%FFT1%
      MN2=MN/2
      TEMSQ= (TOLER(4,JPHASE,JSOURC)*PKFNVA(4))**2
      AVTAU= PKFNVA(1)*TOLER(2,JPHASE,JSOURC)*PKFNVA(2) +
     & (1.-PKFNVA(1))*TOLER(3,JPHASE,JSOURC)*PKFNVA(3)
      TEMSQ= TEMSQ + AVTAU*AVTAU
      CAULIM= TOLER(5,JPHASE,JSOURC)*PKFNVA(5)
      XPKDEL(KMOD)=(SQRT(TEMSQ)+CAULIM)/FLOAT(MN2)
C
C.. NOW SET UP FAST FOURIER TRANSFORM
C.. THE INDIVIDUAL COMPONENTS FOR CONVOLUTION ARE IMMEDIATELY
C.. DESCRIBED IN FOURIER SPACE (GETS RID OF DISCONTINUITY PROBLEMS)
C
**      IEAGLE=NFFT
**      IF (IEAGLE .EQ. 0) IEAGLE=JFIX(TOLER(1,JPHASE,JSOURC))
      IEAGLE=JFIX(TOLER(1,JPHASE,JSOURC))
      IF (IEAGLE.EQ.3) THEN
        MNS=MN
        CALL FTSUB2(MNS)
        II=MNS/2-MN2
        DO 12 I=1,MN
        II=II+1
        DO 11 J=1,NPKGEN(JPHASE,JSOURC)+1
        PKLIST(I,J,KMOD)= (C1D45)*PKADD(II,J)
  11    CONTINUE
  12    CONTINUE
        MNS=2*MN
        CALL FTSUB2(MNS)
        II=MNS/2-MN2
        DO 14 I=1,MN
        II=II+1
        DO 13 J=1,NPKGEN(JPHASE,JSOURC)+1
        PKLIST(I,J,KMOD)= PKLIST(I,J,KMOD)-(C20D45)*PKADD(II,J)
  13    CONTINUE
  14    CONTINUE
        MNS=4*MN
        CALL FTSUB2(MNS)
        II=MNS/2-MN2
        DO 15 I=1,MN
        II=II+1
        DO 16 J=1,NPKGEN(JPHASE,JSOURC)+1
        PKLIST(I,J,KMOD)= PKLIST(I,J,KMOD)+(C64D45)*PKADD(II,J)
  16    CONTINUE
  15    CONTINUE
      ELSE IF (IEAGLE.EQ.2) THEN
        MNS=MN
        CALL FTSUB2(MNS)
        II=MNS/2-MN2
        DO 18 I=1,MN
        II=II+1
        DO 17  J=1,NPKGEN(JPHASE,JSOURC)+1
        PKLIST(I,J,KMOD)= -(C1D3)*PKADD(II,J)
  17    CONTINUE
  18    CONTINUE
        MNS=2*MN
        CALL FTSUB2(MNS)
        II=MNS/2-MN2
        DO 19 I=1,MN
        II=II+1
        DO 20 J=1,NPKGEN(JPHASE,JSOURC)+1
        PKLIST(I,J,KMOD)= PKLIST(I,J,KMOD)+(C4D3)*PKADD(II,J)
  20    CONTINUE
  19    CONTINUE
      ELSE
        MNS=MN
        CALL FTSUB2(MNS)
        II=MNS/2-MN2
        DO 39 I=1,MN
        II=II+1
        DO 38 J=1,NPKGEN(JPHASE,JSOURC)+1
        PKLIST(I,J,KMOD)= PKADD(II,J)
  38    CONTINUE
  39    CONTINUE
      ENDIF
C
C
C.. FFT OVER
C... DO THE INTERPOLATIONS FOR YNORM AND DERIVATIVES FROM PKLIST
  26  JARGI=JFIX((ARGI-ARGK)/XPKDEL(KMOD))
      IARGI=JARGI+MN2+1
C.. WORK OUT ARGI OFFSET FROM "X(JARGI)" FOR INTERPOLATION
      POFF= (ARGI-ARGK)/XPKDEL(KMOD) - FLOAT(JARGI)
C.. WORK OUT INTERPOLATION COEFFICIENTS FOR FUNCTIONS AND ARGK DERIVATIVE
      C3FN(1)= 0.5*POFF*(POFF-1.)
      C3FN(2)= 1.-POFF**2
      C3FN(3)= 0.5*POFF*(POFF+1.)
      C3DN(1)= POFF-0.5
      C3DN(2)= -2.*POFF
      C3DN(3)= POFF+0.5
C
      YNORM=0.
      DYNDKQ=0.
      CALL GMZER(DYNDVQ,1,NPKGEN(JPHASE,JSOURC))
C
      DO 41 I=1,3
      II=IARGI+I-2
      PKTEM=PKLIST(II,1,KMOD)
      YNORM=YNORM+C3FN(I)*PKTEM
      DYNDKQ=DYNDKQ-C3DN(I)*PKTEM
      DO 42 NPKD=1,NPKGEN(JPHASE,JSOURC)
      NPKD1=NPKD+1
      DYNDVQ(NPKD)=DYNDVQ(NPKD)+C3FN(I)*PKLIST(II,NPKD1,KMOD)
  42  CONTINUE
  41  CONTINUE
C
C.. NOW CHECK IF YNORM IS ZERO BEFORE EVALUATING QUOTIENT DERIVATIVES
      IF(TESTOV(2.,YNORM)) THEN
        DYNDKQ=0.
        CALL GMZER(DYNDVQ,1,NPKGEN(JPHASE,JSOURC))
      ELSE
        DYNDKQ=DYNDKQ/(YNORM*XPKDEL(KMOD))
        CALL GMSCA(DYNDVQ,DYNDVQ,1./YNORM,1,NPKGEN(JPHASE,JSOURC))
      ENDIF
      GO TO 100
C
C PRE-PROFILE REFINEMENT STAGE
   5  CALL FDTF06(1)
      DEL= ARGI-ARGK
      TEMSQ= (TOLER(4,JPHASE,JSOURC)*PKFNVA(4))**2
      CAULIM= TOLER(5,JPHASE,JSOURC)*PKFNVA(5)
      IF (DEL) 510,510,520
 520  AVTAU= PKFNVA(1)*TOLER(2,JPHASE,JSOURC)*PKFNVA(2) +
     & (1.-PKFNVA(1))*TOLER(3,JPHASE,JSOURC)*PKFNVA(3)
      TEMSQ= TEMSQ + AVTAU*AVTAU
 510  TEMLIM= CAULIM+SQRT(TEMSQ)
      REFUSE= ABS(DEL) .GT. TEMLIM
      GO TO 100
C
C N=6 *** CAILS *** SETTING UP SLACK AND STRICT CONSTRAINTS
C
    6 CALL FDTF06(1)
      DELT=ABS(AKLO-AKHI)
      AVTAU= PKFNVA(1)*PKFNVA(2) + (1.-PKFNVA(1))*PKFNVA(3)
C SQRT 8 LOG 2 AND LOG 2:
       FWHME=SQL2X8*PKFNVA(4) + ALOG2*AVTAU
       STRKT=DELT .LT. STRTOL*FWHME
      SLACK=0.
      IF (DELT .GE. SLKTOL*FWHME) GO TO 100
      SLACK=EXP(1.-(DELT/(SLKTOL*FWHME))**2)
      GO TO 100
C
   7  CALL FDTF06(1)
      F4PAR(2,KNOW)=PKFNVA(4)
      GO TO 100
 100  RETURN
      END
C
C
C
C
C LEVEL 6      SUBROUTINE PFTF08(N)
      SUBROUTINE PFTF08(N)
C
C *** PFTF08 (formerly 04) updated by JCM 29 May 89 ***
C
CH Multiple entry Time of Flight Peak Function routine with FFT
CH and peak function with Voigt/double exponential convolution where the
CH Lorentzian contribution ofthe Voigt has the facility for refining
CH anisotropic strain and particle size effects
CA On entry N=1,2,5,6 or 7:
CA N=1: Set up program for data source TOF, peak function 08
CA N=2: form peak function in YNORM, and its derivatives wrt paramet ers
CA N=5: Sets LOGICAL REFUSE to determine if reflection makes a sign ificant
CA      contribution to the profile at ARGI
CA N=6: CAILS entry to determine whether near reflections should be related
CA      by a strict or slack relationship.
CA N=7: SAPS entry to obey FDXXXX to set up a value(s) for PKFNVA
C
      COMPLEX CFFT,DFFT,DDT,CFE,CFT
      LOGICAL TESTOV
/CONSTA/
/F4PARS/
/PAWLPR/
/PHASE/
/PRBLEM/
/PRPKCN/
/PRPKFN/
/PRSAVF/
/PWORDS/
/REFLNS/
/SOURCE/
      COMMON /SCRAT/C3FN(3),C3DN(3)
      PARAMETER (NW=6)
      CHARACTER *4 WDTF08(NW)
      DIMENSION IWTF08(3,NW)
      DATA WDTF08/'SWCH','TAUF','TAUS','SIGM','GSTR','GPSZ'/
      DATA IWTF08/3,3,0, 3,4,0, 3,5,0, 3,6,0, 3,7,0, 3,8,0/
C
      GO TO (10,1,2,100,100,5,6,7) , N+1
C
C N=0: SET UP "DATA SOURCE TOF, PEAK TYPE 08"
  10  NPKGEN(JPHASE,JSOURC)=6
      NGEN4(JPHASE,JSOURC)=3
      LF3SP(3,JPHASE,JSOURC)=-2
      LF3SP(4,JPHASE,JSOURC)=-2
      LF3SP(5,JPHASE,JSOURC)=-2
      LF3SP(6,JPHASE,JSOURC)=-3
      LF3SP(7,JPHASE,JSOURC)=-6
      LF3SP(8,JPHASE,JSOURC)=-6
      LF6SP(1,JSOURC)=1
      DO 9 I=1,NPKGEN(JPHASE,JSOURC)
   9  PWD(I,JPHASE,JSOURC)=WDTF08(I)
      GO TO 100
C
C N=1: ADD PACKED VOCABULARY FOR THIS SOURCE, THIS PHASE, TO THE MAIN LIST:
   1  CALL VOCAB(WDTF08,IWTF08,NW)
      GO TO 100
C
C PROFILE REFINEMENT STAGE:
 2    CALL FDTF08(2)
C.. FIRSTLY DECIDE WHETHER THE KTH PEAK IS ALREADY STORED IN THE
C.. ARRAY PKLIST. AT THIS POINT REFUSE = (K .EQ. KPOINT(KMOD))
C.. DETERMINED IN SUBROUTINE CALTF1 WHICH CALLS THIS ENTRY (IOPT=2)
      IF (REFUSE) GO TO 26
C
C.. THE PEAK HAS NOT OCCURRED ALREADY - CALCULATE THE COMPLETE PEAK
C.. SHAPE OF THE KTH PEAK BY FFT.
C
C.. FFT CALCULATION STAGE IN PROFILE REFINEMENT
C
C.. FIRST DETERMINE FFT LIMITS FOR PEAK SHAPE
%      MN=%FFT1%
      MN2=MN/2
      TEMSQ= (TOLER(4,JPHASE,JSOURC)*PKFNVA(4))**2
      AVTAU= PKFNVA(1)*TOLER(2,JPHASE,JSOURC)*PKFNVA(2) +
     & (1.-PKFNVA(1))*TOLER(3,JPHASE,JSOURC)*PKFNVA(3)
      TEMSQ= TEMSQ + AVTAU*AVTAU
      CAULIM= TOLER(5,JPHASE,JSOURC)*PKFNVA(5)+
     & TOLER(6,JPHASE,JSOURC)*PKFNVA(6)
      XPKDEL(KMOD)=(SQRT(TEMSQ)+CAULIM)/FLOAT(MN2)
C
C.. NOW SET UP FAST FOURIER TRANSFORM
C.. THE INDIVIDUAL COMPONENTS FOR CONVOLUTION ARE IMMEDIATELY
C.. DESCRIBED IN FOURIER SPACE (GETS RID OF DISCONTINUITY PROBLEMS)
C
      IEAGLE=NFFT
      IF (IEAGLE .EQ. 0) IEAGLE=JFIX(TOLER(1,JPHASE,JSOURC))
      IF (IEAGLE.EQ.3) THEN
        MNS=MN
        CALL FTSUB8(MNS)
        II=MNS/2-MN2
        DO 12 I=1,MN
        II=II+1
        DO 11 J=1,NPKGEN(JPHASE,JSOURC)+1
        PKLIST(I,J,KMOD)= (1./45.)*PKADD(II,J)
  11    CONTINUE
  12    CONTINUE
        MNS=2*MN
        CALL FTSUB8(MNS)
        II=MNS/2-MN2
        DO 14 I=1,MN
        II=II+1
        DO 13 J=1,NPKGEN(JPHASE,JSOURC)+1
        PKLIST(I,J,KMOD)= PKLIST(I,J,KMOD)-(20./45.)*PKADD(II,J)
  13    CONTINUE
  14    CONTINUE
        MNS=4*MN
        CALL FTSUB8(MNS)
        II=MNS/2-MN2
        DO 15 I=1,MN
        II=II+1
        DO 16 J=1,NPKGEN(JPHASE,JSOURC)+1
        PKLIST(I,J,KMOD)= PKLIST(I,J,KMOD)+(64./45.)*PKADD(II,J)
  16    CONTINUE
  15    CONTINUE
      ELSE IF (IEAGLE.EQ.2) THEN
        MNS=MN
        CALL FTSUB8(MNS)
        II=MNS/2-MN2
        DO 18 I=1,MN
        II=II+1
        DO 17  J=1,NPKGEN(JPHASE,JSOURC)+1
        PKLIST(I,J,KMOD)= -(1./3.)*PKADD(II,J)
  17    CONTINUE
  18    CONTINUE
        MNS=2*MN
        CALL FTSUB8(MNS)
        II=MNS/2-MN2
        DO 19 I=1,MN
        II=II+1
        DO 20 J=1,NPKGEN(JPHASE,JSOURC)+1
        PKLIST(I,J,KMOD)= PKLIST(I,J,KMOD)+(4./3.)*PKADD(II,J)
  20    CONTINUE
  19    CONTINUE
      ELSE
        MNS=MN
        CALL FTSUB8(MNS)
        II=MNS/2-MN2
        DO 39 I=1,MN
        II=II+1
        DO 38 J=1,NPKGEN(JPHASE,JSOURC)+1
        PKLIST(I,J,KMOD)= PKADD(II,J)
  38    CONTINUE
  39    CONTINUE
      ENDIF
C
C.. FFT OVER
C... DO THE INTERPOLATIONS FOR YNORM AND DERIVATIVES FROM PKLIST
  26  JARGI=JFIX((ARGI-ARGK)/XPKDEL(KMOD))
      IARGI=JARGI+MN2+1
C.. WORK OUT ARGI OFFSET FROM "X(JARGI)" FOR INTERPOLATION
      POFF= (ARGI-ARGK)/XPKDEL(KMOD) - FLOAT(JARGI)
C.. WORK OUT INTERPOLATION COEFFICIENTS FOR FUNCTIONS AND ARGK DERIVATIVE
      C3FN(1)= 0.5*POFF*(POFF-1.)
      C3FN(2)= 1.-POFF**2
      C3FN(3)= 0.5*POFF*(POFF+1.)
      C3DN(1)= POFF-0.5
      C3DN(2)= -2.*POFF
      C3DN(3)= POFF+0.5
C
      YNORM=0.
      DYNDKQ=0.
      CALL GMZER(DYNDVQ,1,NPKGEN(JPHASE,JSOURC))
C
      DO 41 I=1,3
      II=IARGI+I-2
      PKTEM=PKLIST(II,1,KMOD)
      YNORM=YNORM+C3FN(I)*PKTEM
      DYNDKQ=DYNDKQ-C3DN(I)*PKTEM
      DO 42 NPKD=1,NPKGEN(JPHASE,JSOURC)
      NPKD1=NPKD+1
      DYNDVQ(NPKD)=DYNDVQ(NPKD)+C3FN(I)*PKLIST(II,NPKD1,KMOD)
  42  CONTINUE
  41  CONTINUE
C
C.. NOW CHECK IF YNORM IS ZERO BEFORE EVALUATING QUOTIENT DERIVATIVES
      IF (TESTOV(2.,YNORM)) THEN
        DYNDKQ=0.
        CALL GMZER(DYNDVQ,1,NPKGEN(JPHASE,JSOURC))
      ELSE
        DYNDKQ=DYNDKQ/(YNORM*XPKDEL(KMOD))
        CALL GMSCA(DYNDVQ,DYNDVQ,1./YNORM,1,NPKGEN(JPHASE,JSOURC))
      ENDIF
      GO TO 100
C
C PRE-PROFILE REFINEMENT STAGE
   5  CALL FDTF08(1)
      DEL= ARGI-ARGK
      TEMSQ= (TOLER(4,JPHASE,JSOURC)*PKFNVA(4))**2
      CAULIM= TOLER(5,JPHASE,JSOURC)*PKFNVA(5)+
     & TOLER(6,JPHASE,JSOURC)*PKFNVA(6)
      IF (DEL) 510,510,520
 520  AVTAU= PKFNVA(1)*TOLER(2,JPHASE,JSOURC)*PKFNVA(2) +
     & (1.-PKFNVA(1))*TOLER(3,JPHASE,JSOURC)*PKFNVA(3)
      TEMSQ= TEMSQ + AVTAU*AVTAU
 510  TEMLIM= CAULIM+SQRT(TEMSQ)
      REFUSE= ABS(DEL) .GT. TEMLIM
      GO TO 100
C
C N=6 *** CAILS *** SETTING UP SLACK AND STRICT CONSTRAINTS
C
    6 CALL FDTF08(1)
      DELT=ABS(AKLO-AKHI)
      AVTAU= PKFNVA(1)*PKFNVA(2) + (1.-PKFNVA(1))*PKFNVA(3)
C SQRT 8 LOG 2 AND LOG 2:
       FWHME=SQL2X8*PKFNVA(4) + PKFNVA(5) + PKFNVA(6) + ALOG2*AVTAU
       STRKT=DELT .LT. STRTOL*FWHME
      SLACK=0.
      IF (DELT .GE. SLKTOL*FWHME) GO TO 100
      SLACK=EXP(1.-(DELT/(SLKTOL*FWHME))**2)
      GO TO 100
C
   7  CALL FDTF08(1)
      F4PAR(2,KNOW)=PKFNVA(5)+PKFNVA(6)
      F4PAR(3,KNOW)=PKFNVA(4)
      GO TO 100
 100  RETURN
      END
C
C
C
C
C LEVEL 6      SUBROUTINE PFTF12(N)
      SUBROUTINE PFTF12(N)
C
C *** PFTF12 by JBF March 94 ***
C
CH Multiple entry Time of Flight Peak Function (type 12) routine with FFT
CH and Voigt double exponential peak function
CA On entry N=0,1,2,5,6 or 7:
CA On entry N=0 sets up DATA SOURCE TOF, PEAK TYPE 12
CA Entry N=1 adds packed vocabulary for this source and phase to the main list
CA and reads and interprets the L PKFN cards.  These cards have a second word:
CA     SWCH
CA     TAUF
CA     TAUS
CA     SIGM    For nuclear peaks
CA     GAMM    For nuclear peaks
CA     MSIG    SIGM for magnetic peaks
CA     MGAM    GAMM for magnetic peaks
CA followed by the width parameters involved in this particular peak
CA descriptor.
CA
CA COMMON/REFLNS/ISMAG=0 are for nuclear peaks (SIGM); entries with ISMAG =1
CA are for magnetic peaks and use SMIG parameters for SIGM. EXTEND VALUES OF
CA THIS SEMAPHORE AT A LATER DATE!
CA
CA Entry N=2 forms the normalised peak function, and puts it in YNORM.  It also
CA gives all necessary derivatives of YNORM with respect to anything that could
CA be a parameter.
CA
CA Entry N=5 sets LOGICAL REFUSE to say whether or not reflection to be used,
CA i.e. whether this reflection is near enough to this intensity to contribute
CA to it.
CA
CA Entry N=6: CAILS entry to determine whether near reflections should be
CA related by a strict or slack relationship.
CA
CA Entry N=7: SAPS entry to obey FDXXXX to set up a value(s) for PKFNVA
C
      COMPLEX CFFT,DFFT,DDT,CFE,CFT
      LOGICAL TESTOV
/CONSTA/
/F4PARS/
      COMMON /FFCONS/C1D45,C20D45,C64D45,C1D3,C4D3
/PAWLPR/
/PHASE/
/PRBLEM/
/PRPKCN/
/PRPKFN/
/PRSAVF/
/PWORDS/
/REFLNS/
/SOURCE/
      COMMON /SCRAT/C3FN(3),C3DN(3)
C
      PARAMETER (NW=7)
      CHARACTER *4 WORD,WDTF12(NW)
      DIMENSION IWTF12(3,NW)
      DATA WDTF12/'SWCH','TAUF','TAUS','SIGM','GAMM','MSIG','MGAM'/
      DATA IWTF12/3,3,0, 3,4,0, 3,5,0, 3,6,0, 3,7,0, 3,8,0, 3,9,0/
C
      GO TO (10,1,2,100,100,5,6,7) , N+1
C
C N=0: SET UP "DATA SOURCE TOF, PEAK TYPE 12 NUCLEAR & MAGNETIC"
  10  NPKGEN(JPHASE,JSOURC)=7
      NGEN4(JPHASE,JSOURC)=3
      LF3SP(3,JPHASE,JSOURC)=-2
      LF3SP(4,JPHASE,JSOURC)=-2
      LF3SP(5,JPHASE,JSOURC)=-2
      LF3SP(6,JPHASE,JSOURC)=-3
      LF3SP(7,JPHASE,JSOURC)=-3
      LF3SP(8,JPHASE,JSOURC)=-3
      LF3SP(9,JPHASE,JSOURC)=-3
      LF6SP(1,JSOURC)=1
      DO 49 I=1,NPKGEN(JPHASE,JSOURC)
  49  PWD(I,JPHASE,JSOURC)=WDTF12(I)
      C1D45 =1./45.
      C20D45=20./45.
      C64D45=64./45.
      C1D3=1./3.
      C4D3=4./3.
      GO TO 100
C
C N=1: ADD PACKED VOCABULARY FOR THIS SOURCE, THIS PHASE, TO THE MAIN LIST:
   1  CALL VOCAB(WDTF12,IWTF12,NW)
      GO TO 100
C
C PROFILE REFINEMENT STAGE:
 2    CALL FDTF12(2)
C.. FIRSTLY DECIDE WHETHER THE KTH PEAK IS ALREADY STORED IN THE
C.. ARRAY PKLIST. AT THIS POINT REFUSE = (K .EQ. KPOINT(KMOD))
C.. DETERMINED IN SUBROUTINE CALTF1 WHICH CALLS THIS ENTRY (IOPT=2)
      IF (REFUSE) GO TO 26
C
C.. THE PEAK HAS NOT OCCURRED ALREADY - CALCULATE THE COMPLETE PEAK
C.. SHAPE OF THE KTH PEAK BY FFT.
C
C.. FFT CALCULATION STAGE IN PROFILE REFINEMENT
C
C.. FIRST DETERMINE FFT LIMITS FOR PEAK SHAPE
%      MN=%FFT1%
      MN2=MN/2
C THIS WILL BE MADE MORE GENERAL IN FUTURE - AT MOMENT WILL DEAL WITH HELI
C STRUCTURES
C 88.05      IF(ISMAG(KNOW).EQ.O) THEN
      IF(ISMAG(KNOW).EQ.0) THEN
        TEMSQ= (TOLER(4,JPHASE,JSOURC)*PKFNVA(4))**2
        CAULIM= TOLER(5,JPHASE,JSOURC)*PKFNVA(5)
      ELSE
        TEMSQ= (TOLER(6,JPHASE,JSOURC)*PKFNVA(6))**2
        CAULIM= TOLER(7,JPHASE,JSOURC)*PKFNVA(7)
      ENDIF
      AVTAU= TOLER(2,JPHASE,JSOURC)*PKFNVA(2) +
     & PKFNVA(1)*TOLER(3,JPHASE,JSOURC)*PKFNVA(3)
      TEMSQ= TEMSQ + AVTAU*AVTAU
      XPKDEL(KMOD)=(SQRT(TEMSQ)+CAULIM)/FLOAT(MN2)
C
C.. NOW SET UP FAST FOURIER TRANSFORM
C.. THE INDIVIDUAL COMPONENTS FOR CONVOLUTION ARE IMMEDIATELY
C.. DESCRIBED IN FOURIER SPACE (GETS RID OF DISCONTINUITY PROBLEMS)
C
**      IEAGLE=NFFT
**      IF (IEAGLE .EQ. 0) IEAGLE=JFIX(TOLER(1,JPHASE,JSOURC))
      IEAGLE=JFIX(TOLER(1,JPHASE,JSOURC))
      IF (IEAGLE.EQ.3) THEN
        MNS=MN
        CALL FTSB12(MNS)
        II=MNS/2-MN2
        DO 12 I=1,MN
        II=II+1
        DO 11 J=1,NPKGEN(JPHASE,JSOURC)+1
        PKLIST(I,J,KMOD)= (C1D45)*PKADD(II,J)
  11    CONTINUE
  12    CONTINUE
        MNS=2*MN
        CALL FTSB12(MNS)
        II=MNS/2-MN2
        DO 14 I=1,MN
        II=II+1
        DO 13 J=1,NPKGEN(JPHASE,JSOURC)+1
        PKLIST(I,J,KMOD)= PKLIST(I,J,KMOD)-(C20D45)*PKADD(II,J)
  13    CONTINUE
  14    CONTINUE
        MNS=4*MN
        CALL FTSB12(MNS)
        II=MNS/2-MN2
        DO 15 I=1,MN
        II=II+1
        DO 16 J=1,NPKGEN(JPHASE,JSOURC)+1
        PKLIST(I,J,KMOD)= PKLIST(I,J,KMOD)+(C64D45)*PKADD(II,J)
  16    CONTINUE
  15    CONTINUE
      ELSE IF (IEAGLE.EQ.2) THEN
        MNS=MN
        CALL FTSB12(MNS)
        II=MNS/2-MN2
        DO 18 I=1,MN
        II=II+1
        DO 17  J=1,NPKGEN(JPHASE,JSOURC)+1
        PKLIST(I,J,KMOD)= -(C1D3)*PKADD(II,J)
  17    CONTINUE
  18    CONTINUE
        MNS=2*MN
        CALL FTSB12(MNS)
        II=MNS/2-MN2
        DO 19 I=1,MN
        II=II+1
        DO 20 J=1,NPKGEN(JPHASE,JSOURC)+1
        PKLIST(I,J,KMOD)= PKLIST(I,J,KMOD)+(C4D3)*PKADD(II,J)
  20    CONTINUE
  19    CONTINUE
      ELSE
        MNS=MN
        CALL FTSB12(MNS)
        II=MNS/2-MN2
        DO 39 I=1,MN
        II=II+1
        DO 38 J=1,NPKGEN(JPHASE,JSOURC)+1
        PKLIST(I,J,KMOD)= PKADD(II,J)
  38    CONTINUE
  39    CONTINUE
      ENDIF
C
C
C.. FFT OVER
C... DO THE INTERPOLATIONS FOR YNORM AND DERIVATIVES FROM PKLIST
  26  JARGI=JFIX((ARGI-ARGK)/XPKDEL(KMOD))
      IARGI=JARGI+MN2+1
C.. WORK OUT ARGI OFFSET FROM "X(JARGI)" FOR INTERPOLATION
      POFF= (ARGI-ARGK)/XPKDEL(KMOD) - FLOAT(JARGI)
C.. WORK OUT INTERPOLATION COEFFICIENTS FOR FUNCTIONS AND ARGK DERIVATIVE
      C3FN(1)= 0.5*POFF*(POFF-1.)
      C3FN(2)= 1.-POFF**2
      C3FN(3)= 0.5*POFF*(POFF+1.)
      C3DN(1)= POFF-0.5
      C3DN(2)= -2.*POFF
      C3DN(3)= POFF+0.5
C
      YNORM=0.
      DYNDKQ=0.
      CALL GMZER(DYNDVQ,1,NPKGEN(JPHASE,JSOURC))
C
      DO 41 I=1,3
      II=IARGI+I-2
      PKTEM=PKLIST(II,1,KMOD)
      YNORM=YNORM+C3FN(I)*PKTEM
      DYNDKQ=DYNDKQ-C3DN(I)*PKTEM
      DO 42 NPKD=1,NPKGEN(JPHASE,JSOURC)
      NPKD1=NPKD+1
      DYNDVQ(NPKD)=DYNDVQ(NPKD)+C3FN(I)*PKLIST(II,NPKD1,KMOD)
  42  CONTINUE
  41  CONTINUE
C
C.. NOW CHECK IF YNORM IS ZERO BEFORE EVALUATING QUOTIENT DERIVATIVES
      IF(TESTOV(2.,YNORM)) THEN
        DYNDKQ=0.
        CALL GMZER(DYNDVQ,1,NPKGEN(JPHASE,JSOURC))
      ELSE
        DYNDKQ=DYNDKQ/(YNORM*XPKDEL(KMOD))
        CALL GMSCA(DYNDVQ,DYNDVQ,1./YNORM,1,NPKGEN(JPHASE,JSOURC))
      ENDIF
      GO TO 100
C
C PRE-PROFILE REFINEMENT STAGE
   5  CALL FDTF12(1)
      DEL= ARGI-ARGK
C THIS WILL BE MADE MORE GENERAL IN FUTURE - AT MOMENT WILL DEAL WITH HELI
C STRUCTURES
      IF (ISMAG(KNOW).EQ.0) THEN
        TEMSQ= (TOLER(4,JPHASE,JSOURC)*PKFNVA(4))**2
        CAULIM= TOLER(5,JPHASE,JSOURC)*PKFNVA(5)
      ELSE
        TEMSQ= (TOLER(6,JPHASE,JSOURC)*PKFNVA(6))**2
        CAULIM= TOLER(7,JPHASE,JSOURC)*PKFNVA(5)
      ENDIF
      IF (DEL) 510,510,520
 520  AVTAU= PKFNVA(1)*TOLER(2,JPHASE,JSOURC)*PKFNVA(2) +
     & (1.-PKFNVA(1))*TOLER(3,JPHASE,JSOURC)*PKFNVA(3)
      TEMSQ= TEMSQ + AVTAU*AVTAU
 510  TEMLIM= CAULIM+SQRT(TEMSQ)
      REFUSE= ABS(DEL) .GT. TEMLIM
      GO TO 100
C
C N=6 *** CAILS *** SETTING UP SLACK AND STRICT CONSTRAINTS
C
    6 CALL FDTF12(1)
      DELT=ABS(AKLO-AKHI)
      AVTAU= PKFNVA(1)*PKFNVA(2) + (1.-PKFNVA(1))*PKFNVA(3)
C SQRT 8 LOG 2 AND LOG 2:
      IF (ISMAG(KNOW).EQ.0) THEN
        FWHME=SQL2X8*PKFNVA(4) + ALOG2*AVTAU
      ELSE
        FWHME=SQL2X8*PKFNVA(6) + ALOG2*AVTAU
      ENDIF
      STRKT=DELT .LT. STRTOL*FWHME
      SLACK=0.
      IF (DELT .GE. SLKTOL*FWHME) GO TO 100
      SLACK=EXP(1.-(DELT/(SLKTOL*FWHME))**2)
      GO TO 100
C
   7  CALL FDTF12(1)
      F4PAR(2,KNOW)=PKFNVA(4)
      GO TO 100
 100  RETURN
      END
C
C
C
C
C LEVEL 7      SUBROUTINE PFTF92(N)
      SUBROUTINE PFTF92(N)
C
C *** PFTF92 updated by JCM 27 May 89 ***
C
CH Multiple entry Time of Flight Peak Function routine with FFT
CH and Voigt double exponential peak function
CA On entry N=1,2,3,5,6 or 7:
CA N=1: Set up program for data source TOF, peak function 02:
CA N=2: form peak function in YNORM, and its derivatives wrt paramet ers
CA N=3: form peak function for reference positions for future interpolation
CA      if appropriate.
CA N=5: Sets LOGICAL REFUSE to determine if reflection makes a sign ificant
CA      contribution to the profile at ARGI
CA N=6: CAILS entry to determine whether near reflections should be related
CA      by a strict or slack relationship.
CA N=7: SAPS entry to obey FDXXXX to set up a value(s) for PKFNVA
C
      COMPLEX CFFT,DFFT,DDT,CFE,CFT
      LOGICAL TESTOV
/CONSTA/
/F4PARS/
/PAWLPR/
/PHASE/
/PRBLEM/
/PRPKCN/
/PRPKFN/
/PRSAVF/
/PWORDS/
/REFLNS/
/SOURCE/
      COMMON /SCRAT/C3FN(3),C3DN(3)
      PARAMETER (NW=5)
      CHARACTER *4 WDTF02(NW)
      DIMENSION IWTF02(3,NW)
      DATA WDTF02/'SWCH','TAUF','TAUS','SIGM','GAMM'/
      DATA IWTF02/3,3,0, 3,4,0, 3,5,0, 3,6,0, 3,7,0/
C
      GO TO (10,1,2,3,100,5,6,7) , N+1
C
C N=1: SET UP "DATA SOURCE TOF, PEAK TYPE 02"
  10  NPKGEN(JPHASE,JSOURC)=5
      NGEN4(JPHASE,JSOURC)=3
      LF3SP(3,JPHASE,JSOURC)=-2
      LF3SP(4,JPHASE,JSOURC)=-2
      LF3SP(5,JPHASE,JSOURC)=-2
      LF3SP(6,JPHASE,JSOURC)=-3
      LF3SP(7,JPHASE,JSOURC)=-3
      LF6SP(1,JSOURC)=1
      DO 9 I=1,NPKGEN(JPHASE,JSOURC)
   9  PWD(I,JPHASE,JSOURC)=WDTF02(I)
      GO TO 100
C
C N=1: ADD PACKED VOCABULARY FOR THIS SOURCE, THIS PHASE, TO THE MAIN LIST:
   1  CALL VOCAB(WDTF02,IWTF02,NW)
      GO TO 100
C
C PROFILE REFINEMENT STAGE:
C SELECTED PEAK SHAPE CALCULATION
C.. FIRSTLY DECIDE WHETHER THE KTH PEAK IS ALREADY STORED IN THE
C.. ARRAY PKLIST. AT THIS POINT REFUSE = (K .EQ. KPOINT(KMOD))
C.. DETERMINED IN SUBROUTINE CALTF1 WHICH CALLS THIS ENTRY (IOPT=2)
   2  IF (REFUSE) GO TO 26
%      MN=%FFT1%
      MN2=MN/2
C... THE KTH PEAK HAS NOT BEEN CALCULATED - DO SO BY INTERPOLATION
C... DO THE INTERPOLATIONS FOR YNORM AND DERIVATIVES FROM PKLIST
C
      KNTH1=KNTHIS+1
      IF (ARGK.GE.ARGNOT(KNTH1)) KNTHIS=KNTH1
C.. WORK OUT ARGK OFFSET FROM NEAREST KNOTS FOR INTERPOLATION
      POFF= POFMUL*ALOG(ARGK/ARGNOT(KNTHIS))
C.. WORK OUT INTERPOLATION COEFFICIENTS FOR FUNCTIONS
      C3FN(1)= 0.5*POFF*(POFF-1.)
      C3FN(2)= 1.-POFF**2
      C3FN(3)= 0.5*POFF*(POFF+1.)
C
      XPKDEL(KMOD)=0.
      DO 610 I=1,3
      INOT=KNTHIS+I-2
      XPKDEL(KMOD)=XPKDEL(KMOD)+C3FN(I)*XPDKNT(INOT)
 610  CONTINUE
      DO 620 JG=1,NPKGEN(JPHASE,JSOURC)+1
      DO 630 IMN=1,MN
      PKLIST(IMN,JG,KMOD)=0.
      DO 640 I=1,3
      INOT=KNTHIS+I-2
      PKLIST(IMN,JG,KMOD)=PKLIST(IMN,JG,KMOD)+C3FN(I)*PKNOT(IMN,JG,INOT)
 640  CONTINUE
 630  CONTINUE
 620  CONTINUE
C
  26  ARGIMK=(ARGI-ARGK)/XPKDEL(KMOD)
      JARGI=JFIX(ARGIMK)
      IARGI=JARGI+MN2+1
C.. WORK OUT ARGI OFFSET FROM "X(JARGI)" FOR INTERPOLATION
      POFF= ARGIMK - FLOAT(JARGI)
C.. WORK OUT INTERPOLATION COEFFICIENTS FOR FUNCTIONS AND ARGK DERIVATIVE
      C3FN(1)= 0.5*POFF*(POFF-1.)
      C3FN(2)= 1.-POFF**2
      C3FN(3)= 0.5*POFF*(POFF+1.)
      C3DN(1)= POFF-0.5
      C3DN(2)= -2.*POFF
      C3DN(3)= POFF+0.5
C
      YNORM=0.
      DYNDKQ=0.
C      CALL GMZER(DYNDVQ,1,NPKGEN(JPHASE,JSOURC))
      DO 410 I=1,NPKGEN(JPHASE,JSOURC)
 410  DYNDVQ(I)=0
C
      DO 41 I=1,3
      II=IARGI+I-2
      PKTEM=PKLIST(II,1,KMOD)
      YNORM=YNORM+C3FN(I)*PKTEM
      DYNDKQ=DYNDKQ-C3DN(I)*PKTEM
      DO 42 NPKD=1,NPKGEN(JPHASE,JSOURC)
      NPKD1=NPKD+1
      DYNDVQ(NPKD)=DYNDVQ(NPKD)+C3FN(I)*PKLIST(II,NPKD1,KMOD)
  42  CONTINUE
  41  CONTINUE
C
C.. NOW CHECK IF YNORM IS ZERO BEFORE EVALUATING QUOTIENT DERIVATIVES
      IF (TESTOV(2.,YNORM)) THEN
        DYNDKQ=0.
C        CALL GMZER(DYNDVQ,1,NPKGEN(JPHASE,JSOURC))
      DO 420 I=1,NPKGEN(JPHASE,JSOURC)
 420  DYNDVQ(I)=0
      ELSE
        DYNDKQ=DYNDKQ/(YNORM*XPKDEL(KMOD))
        IF (.NOT.NOPKRF) THEN
          DO 430 I=1,NPKGEN(JPHASE,JSOURC)
 430      DYNDVQ(I)=DYNDVQ(I)/YNORM
C         CALL GMSCA(DYNDVQ,DYNDVQ,1./YNORM,1,NPKGEN(JPHASE,JSOURC))
        ENDIF
      ENDIF
      GO TO 100
C
C.. CALCULATE THE COMPLETE PEAK SHAPE OF THE SELECTED PEAK BY FFT.
C
C.. FFT CALCULATION STAGE IN PROFILE REFINEMENT
C
C.. FIRST DETERMINE FFT LIMITS FOR PEAK SHAPE
 3    KNOTS=10
      RKNOT=1./FLOAT(KNOTS)
      RATN=(ARGMAX(JSOURC)/ARGMIN(JSOURC))**RKNOT
      POFMUL=FLOAT(KNOTS)/ALOG(ARGMAX(JSOURC)/ARGMIN(JSOURC))
%      MN=%FFT1%
      MN2=MN/2
C.. MUST DO THIS EVERY TIME IF SIGS ETC NOT CHANGED
      KNTHIS=2
      DO 500 KNOT=1,KNOTS+3
       KNOT2=KNOT-2
       ARGK=ARGMIN(JSOURC)*RATN**KNOT2
       ARGNOT(KNOT)=ARGK
       CALL PCTF91(8)
       CALL FDTF02(2)
       TEMSQ= (TOLER(4,JPHASE,JSOURC)*PKFNVA(4))**2
       AVTAU= PKFNVA(1)*TOLER(2,JPHASE,JSOURC)*PKFNVA(2) +
     & (1.-PKFNVA(1))*TOLER(3,JPHASE,JSOURC)*PKFNVA(3)
       TEMSQ= TEMSQ + AVTAU*AVTAU
       CAULIM= TOLER(5,JPHASE,JSOURC)*PKFNVA(5)
       XPDKNT(KNOT)=(SQRT(TEMSQ)+CAULIM)/FLOAT(MN2)
       KMOD=1
       XPKDEL(KMOD)=XPDKNT(KNOT)
C
C.. NOW SET UP FAST FOURIER TRANSFORM
C.. THE INDIVIDUAL COMPONENTS FOR CONVOLUTION ARE IMMEDIATELY
C.. DESCRIBED IN FOURIER SPACE (GETS RID OF DISCONTINUITY PROBLEMS)
C
      IEAGLE=NFFT
      IF (IEAGLE .EQ. 0) IEAGLE=JFIX(TOLER(1,JPHASE,JSOURC))
      IF (IEAGLE.EQ.3) THEN
        MNS=MN
        CALL FTSUB2(MNS)
        II=MNS/2-MN2
        DO 12 I=1,MN
        II=II+1
        DO 11 J=1,NPKGEN(JPHASE,JSOURC)+1
        PKNOT(I,J,KNOT)= (1./45.)*PKADD(II,J)
  11    CONTINUE
  12    CONTINUE
        MNS=2*MN
        CALL FTSUB2(MNS)
        II=MNS/2-MN2
        DO 14 I=1,MN
        II=II+1
        DO 13 J=1,NPKGEN(JPHASE,JSOURC)+1
        PKNOT(I,J,KNOT)= PKNOT(I,J,KNOT)-(20./45.)*PKADD(II,J)
  13    CONTINUE
  14    CONTINUE
        MNS=4*MN
        CALL FTSUB2(MNS)
        II=MNS/2-MN2
        DO 15 I=1,MN
        II=II+1
        DO 16 J=1,NPKGEN(JPHASE,JSOURC)+1
        PKNOT(I,J,KNOT)= PKNOT(I,J,KNOT)+(64./45.)*PKADD(II,J)
  16    CONTINUE
  15    CONTINUE
      ELSE IF (IEAGLE.EQ.2) THEN
        MNS=MN
        CALL FTSUB2(MNS)
        II=MNS/2-MN2
        DO 18 I=1,MN
        II=II+1
        DO 17  J=1,NPKGEN(JPHASE,JSOURC)+1
        PKNOT(I,J,KNOT)= -(1./3.)*PKADD(II,J)
  17    CONTINUE
  18    CONTINUE
        MNS=2*MN
        CALL FTSUB2(MNS)
        II=MNS/2-MN2
        DO 19 I=1,MN
        II=II+1
        DO 20 J=1,NPKGEN(JPHASE,JSOURC)+1
        PKNOT(I,J,KNOT)= PKNOT(I,J,KNOT)+(4./3.)*PKADD(II,J)
  20    CONTINUE
  19    CONTINUE
      ELSE
        MNS=MN
        CALL FTSUB2(MNS)
        II=MNS/2-MN2
        DO 39 I=1,MN
        II=II+1
        DO 38 J=1,NPKGEN(JPHASE,JSOURC)+1
        PKNOT(I,J,KNOT)= PKADD(II,J)
  38    CONTINUE
  39    CONTINUE
       ENDIF
  500 CONTINUE
C
C.. FFT OVER
      GO TO 100
C
C PRE-PROFILE REFINEMENT STAGE
   5  CALL FDTF02(1)
      DEL= ARGI-ARGK
      TEMSQ= (TOLER(4,JPHASE,JSOURC)*PKFNVA(4))**2
      CAULIM= TOLER(5,JPHASE,JSOURC)*PKFNVA(5)
      IF (DEL) 510,510,520
 520  AVTAU= PKFNVA(1)*TOLER(2,JPHASE,JSOURC)*PKFNVA(2) +
     & (1.-PKFNVA(1))*TOLER(3,JPHASE,JSOURC)*PKFNVA(3)
      TEMSQ= TEMSQ + AVTAU*AVTAU
 510  TEMLIM= CAULIM+SQRT(TEMSQ)
      REFUSE= ABS(DEL) .GT. TEMLIM
      GO TO 100
C
C N=6 *** CAILS *** SETTING UP SLACK AND STRICT CONSTRAINTS
C
    6 CALL FDTF02(1)
      DELT=ABS(AKLO-AKHI)
      AVTAU= PKFNVA(1)*PKFNVA(2) + (1.-PKFNVA(1))*PKFNVA(3)
C SQRT 8 LOG 2 AND LOG 2:
       FWHME=SQL2X8*PKFNVA(4) + ALOG2*AVTAU
       STRKT=DELT .LT. STRTOL*FWHME
      SLACK=0.
      IF (DELT .GE. SLKTOL*FWHME) GO TO 100
      SLACK=EXP(1.-(DELT/(SLKTOL*FWHME))**2)
      GO TO 100
C
   7  CALL FDTF02(1)
      F4PAR(2,KNOW)=PKFNVA(4)
      GO TO 100
 100  RETURN
      END
C
C
C
C
C LEVEL   7    SUBROUTINE PICN05(N)
      SUBROUTINE PICN05(N)
C
C Added by JPW for Fe3O4 esrf data 10-Apr-2000
C
C Sets up interpolation for speed principally for Fe3O4 esrf problem
C Needs to know upper and lower bounds on reflection positions in pattern
C Calculates YNORM and derivatives at PAR equally spaced points
C Saves them and uses linear interpolation to evaluate them in between
C
C N=1 Set up
C N=2 return YNORM and derivs
C
C
C Uses:
C /CONSTA/ for two pi to get tan(theta)
C /PKCNSP/ for ARGMIN and ARGMAX
C /PRPKFN/ for ARGI, YNORM, DYNDVQ, DYNDKQ, DERPFN
C /SOURC/ for JSOURC
C /PHASE/ for jphase
C
      INTEGER I,J,K,L,N,NPOINT,KPOINT
      PARAMETER (NPOINT=500,KPOINT=100)
      REAL STEP,YN(KPOINT,NPOINT),DYK(KPOINT,NPOINT),
     & DYV(KPOINT,NPOINT,8),DPF(KPOINT,NPOINT,8,6),
     & POS,POSK,DIFF,PSTEP,WIDTH(KPOINT)
      SAVE STEP,YN,DYK,DYV,DPF,PSTEP,WIDTH
C
/CONSTA/
/PHASE/
/PRPKCN/
/PRPKFN/
/SOURCE/
C
      GO TO (1,2) N
C Loop over data range
    1 WRITE (*,*) 'Arranging peak interpolation...'
      STEP=(ARGMAX(JSOURC)-ARGMIN(JSOURC))/FLOAT(KPOINT)
      DO 10 I=1,KPOINT
       ARGK=ARGMIN(JSOURC)+FLOAT(I)*STEP
C Work out a width for each reflection
       TANTH=TAN(RAD*ARGK/2.)
       SECTH=SQRT(1+TANTH*TANTH)
       WIDTH1=PKFNSP(1,1,JPHASE,JSOURC)*SECTH
     & +  PKFNSP(1,2,JPHASE,JSOURC)*TANTH
       WIDTH2=PKFNSP(2,1,JPHASE,JSOURC)*SECTH
     & +  PKFNSP(2,2,JPHASE,JSOURC)*TANTH
       TEMSQ1=TOLER(1,JPHASE,JSOURC)*WIDTH1
       TEMSQ2=TOLER(2,JPHASE,JSOURC)*WIDTH2
       IF(TEMSQ1.GT.TEMSQ2) TEMSQ2=TEMSQ1
C Add a safety factor to prevent accidental overspill
       WIDTH(I)=TEMSQ2*1.25
       PSTEP=WIDTH(I)/FLOAT(NPOINT)
C Now calculate the peakshape at this angle
       DO 11 L=1,NPOINT
         ARGI=ARGK+PSTEP*(FLOAT(L)-FLOAT(NPOINT)/2.)
C Call conventional pfcn05 - hope this isn't a recursive problem?
         CALL PFCN05(2)
C Save results
         YN(I,L)=YNORM
         DYK(I,L)=DYNDKQ
C       DO 11 J=1,%PKGN%
         DO 11 J=1,8
           DYV(I,L,J)=DYNDVQ(J)
C          DO 11 K=1,%PKSP%
           DO 11 K=1,6
             DPF(I,L,J,K)=DERPFN(J,K)
   11 CONTINUE
   10 CONTINUE
      WRITE(*,*) 'Done!'
      GOTO 100
C
C Now get back the values for a given argi.
    2 POSK=(ARGK-ARGMIN(JSOURC))/STEP
C This will always be the lower index as fortran rounds down
      I=INT(POSK)
C DIFF ranges between 0 and 1 for whichever peak we are nearer
      DIFF=POSK-FLOAT(I)
      DEL=ARGI-ARGK
      IF(DEL*DEL.GT.WIDTH(I)*WIDTH(I)) THEN
        SKIPRF=.TRUE.
        GOTO 100
      ENDIF
      PSTEP=WIDTH(I)/FLOAT(NPOINT)
      POS=DEL/PSTEP/2. + FLOAT(NPOINT)/2
      IF(POS.LT.0.)POS=POS-1.
      L=ABS(INT(POS))
      PDIFF=POS-FLOAT(L)
C Fill in the values
      YNORM =(YN(I,L)*(1.-PDIFF)+YN(I,L+1)*PDIFF)*(1.-DIFF)
     & +   (YN(I+1,L)*(1.-PDIFF)+YN(I+1,L+1)*PDIFF)*DIFF
      DYNDKQ=(DYK(I,L)*(1.-PDIFF)+DYK(I,L+1)*PDIFF)*(1.-DIFF)
     & +  (DYK(I+1,L)*(1.-PDIFF)+DYK(I+1,L+1)*PDIFF)*DIFF
      DO 21 J=1,5
        DYNDVQ(J)=(DYV(I,L,J)*(1.-PDIFF)+DYV(I,L+1,J)*PDIFF)*(1.-DIFF)
     & +        (DYV(I+1,L,J)*(1.-PDIFF)+DYV(I+1,L+1,J)*PDIFF)*DIFF
        DO 21 K=1,2
         DERPFN(J,K)=(DPF(I,L,J,K)*(1.-PDIFF)
     &                      + DPF(I,L+1,J,K)*PDIFF)*(1.-DIFF)
     & +(DPF(I+1,L,J,K)*(1.-PDIFF)+DPF(I+1,L+1,J,K)*PDIFF)*DIFF
   21 CONTINUE
  100 CONTINUE
      RETURN
      END
C
C
C
C
C LEVEL 7      SUBROUTINE PROFVAL()
        real*4 function Profval( Eta , Gamma , S_L , D_L , TwoTH ,
     1   TwoTH0 , dPRdT, dPRdG, dPRdE , dPRdS , dPRdD , Use_Asym )
c
c Returns value of Profile
c   Eta is the mixing coefficient between Gaussian and Lorentzian
c   Gamma is the FWHM
c   S_L is source width/detector distance
c   D_L is detector width/detector distance
c   TwoTH is point at which to evaluate the profile
c   TwoTH0 is two theta value for peak
c   dPRdT is derivative of profile wrt TwoTH0
c   dPRdG is derivative of profile wrt Gamma
c   dPRdE is derivative of profile wrt Eta
c   dPRdS is derivative of profile wrt S_L
c   dPRdD is derivative of profile wrt D_L
c   Use_Asym is true if asymmetry to be used
c
c
c Asymmetry due to axial divergence using the method of Finger, Cox and
c    Jephcoat, J. Appl. Cryst. 27, 892, 1992.

      implicit none
      real*4 Eta , Gamma , S_L , D_L , TwoTH
      real*4 TwoTH0 , dPRdT, dPRdG, dPRdE , dPRdS , dPRdD
      logical Use_Asym
      integer*4 NTERMS(14)/6,10,20,40,60,80,100,150,200,300,400,
     1   600,800,1000/
      integer*4 Fstterm(14)/0,3,8,18,38,68,108,158,233,333,483,
     1   683,983,1383/
      real*4 RAD/57.2957795/

      integer*4 ArrayNum , K , NGT, ngt2 , it, i
      real*4 CsTH                   ! cos(theta)
      real*4 TTH            ! tan(theta)
      real*4 SnTwoTH            ! sin(twoth)
      real*4 CsTwoTH             ! cos(twoth)
      real*4 ApB            ! (S + H)/L
      real*4 AmB            ! (S - H)/L
      real*4 ApB2             ! (ApB) **2
      real*4 Einfl              ! 2phi value for inflection point
      real*4 Emin               ! 2phi value for minimum
      real*4 dEmindA            ! derivative of Emin wrt A
      real*4 tmp , tmp1 , tmp2  ! intermediate values
      real*4 WP(1883) , XP(1883)! Storage for Gauss-Legendre weights and intervals
      real*4 Delta              ! Angle of integration for comvolution
      real*4 dDELTAdA           ! derivative of DELTA wrt A (S/L)
      real*4 sinDELTA           ! sine of DELTA
      real*4 cosDELTA           ! cosine of DELTA
      real*4 tanDELTA           ! tangent of DELTA
      real*4 RcosDELTA          ! 1/cos(DELTA)
      real*4 F , dFdA
      real*4 G , dGdA , dGdB , PsVoigt
      real*4 sumWG , sumWRG , sumWdGdA , sumWRdGdA ,sumWdGdB , sumWRdGdB
      real*4 sumWGdRdG , sumWGdRdE , sumWGdRdA , sumWGdRdB , sumWGdRd2t
      real*4 stepsize
!
! Values for the abscissas and weights of the Gauss-Legendre
!  N-point quadrature formula have been precomputed using routine
!  Gauleg from "Numerical Recipes" (Press, Flannery, Teukolsky
!  and Vetterling, 1986, Cambridge University Press,
!  ISBN 0 521 30811 9), and are stored in the DATA statements
!  for XP and WP below.
!
      data (xp(i),i=   1,  40)/
     $.2386192E+00,.6612094E+00,.9324695E+00,.1488743E+00,.4333954E+00,
     $.6794096E+00,.8650634E+00,.9739065E+00,.7652652E-01,.2277859E+00,
     $.3737061E+00,.5108670E+00,.6360537E+00,.7463319E+00,.8391170E+00,
     $.9122344E+00,.9639719E+00,.9931286E+00,.3877242E-01,.1160841E+00,
     $.1926976E+00,.2681522E+00,.3419941E+00,.4137792E+00,.4830758E+00,
     $.5494671E+00,.6125539E+00,.6719567E+00,.7273183E+00,.7783057E+00,
     $.8246122E+00,.8659595E+00,.9020988E+00,.9328128E+00,.9579168E+00,
     $.9772599E+00,.9907262E+00,.9982377E+00,.2595977E-01,.7780933E-01/
      data (xp(i),i=  41,  80)/
     $.1294491E+00,.1807400E+00,.2315436E+00,.2817229E+00,.3311428E+00,
     $.3796701E+00,.4271737E+00,.4735258E+00,.5186014E+00,.5622789E+00,
     $.6044406E+00,.6449728E+00,.6837663E+00,.7207165E+00,.7557238E+00,
     $.7886937E+00,.8195375E+00,.8481720E+00,.8745199E+00,.8985103E+00,
     $.9200785E+00,.9391663E+00,.9557223E+00,.9697018E+00,.9810672E+00,
     $.9897879E+00,.9958405E+00,.9992101E+00,.1951138E-01,.5850444E-01,
     $.9740840E-01,.1361640E+00,.1747123E+00,.2129945E+00,.2509524E+00,
     $.2885281E+00,.3256644E+00,.3623048E+00,.3983934E+00,.4338754E+00/
      data (xp(i),i=  81, 120)/
     $.4686966E+00,.5028041E+00,.5361459E+00,.5686713E+00,.6003306E+00,
     $.6310758E+00,.6608599E+00,.6896376E+00,.7173652E+00,.7440003E+00,
     $.7695024E+00,.7938327E+00,.8169541E+00,.8388315E+00,.8594314E+00,
     $.8787226E+00,.8966756E+00,.9132631E+00,.9284599E+00,.9422428E+00,
     $.9545908E+00,.9654851E+00,.9749091E+00,.9828486E+00,.9892913E+00,
     $.9942275E+00,.9976499E+00,.9995538E+00,.1562898E-01,.4687168E-01,
     $.7806858E-01,.1091892E+00,.1402031E+00,.1710801E+00,.2017899E+00,
     $.2323025E+00,.2625881E+00,.2926172E+00,.3223603E+00,.3517885E+00/
      data (xp(i),i= 121, 160)/
     $.3808730E+00,.4095853E+00,.4378974E+00,.4657816E+00,.4932108E+00,
     $.5201580E+00,.5465970E+00,.5725019E+00,.5978475E+00,.6226089E+00,
     $.6467619E+00,.6702830E+00,.6931492E+00,.7153381E+00,.7368281E+00,
     $.7575981E+00,.7776279E+00,.7968979E+00,.8153892E+00,.8330839E+00,
     $.8499645E+00,.8660147E+00,.8812187E+00,.8955616E+00,.9090296E+00,
     $.9216093E+00,.9332885E+00,.9440559E+00,.9539008E+00,.9628137E+00,
     $.9707858E+00,.9778094E+00,.9838775E+00,.9889844E+00,.9931249E+00,
     $.9962951E+00,.9984920E+00,.9997137E+00,.1043694E-01,.3130627E-01/
      data (xp(i),i= 161, 200)/
     $.5216195E-01,.7299491E-01,.9379607E-01,.1145563E+00,.1352667E+00,
     $.1559181E+00,.1765016E+00,.1970082E+00,.2174290E+00,.2377550E+00,
     $.2579774E+00,.2780874E+00,.2980762E+00,.3179352E+00,.3376556E+00,
     $.3572289E+00,.3766466E+00,.3959001E+00,.4149811E+00,.4338813E+00,
     $.4525925E+00,.4711065E+00,.4894151E+00,.5075106E+00,.5253849E+00,
     $.5430303E+00,.5604390E+00,.5776036E+00,.5945165E+00,.6111703E+00,
     $.6275579E+00,.6436720E+00,.6595056E+00,.6750519E+00,.6903041E+00,
     $.7052554E+00,.7198995E+00,.7342299E+00,.7482404E+00,.7619248E+00/
      data (xp(i),i= 201, 240)/
     $.7752773E+00,.7882919E+00,.8009631E+00,.8132853E+00,.8252531E+00,
     $.8368613E+00,.8481049E+00,.8589789E+00,.8694787E+00,.8795996E+00,
     $.8893372E+00,.8986874E+00,.9076460E+00,.9162090E+00,.9243729E+00,
     $.9321340E+00,.9394890E+00,.9464346E+00,.9529678E+00,.9590857E+00,
     $.9647858E+00,.9700655E+00,.9749225E+00,.9793548E+00,.9833603E+00,
     $.9869373E+00,.9900843E+00,.9927999E+00,.9950829E+00,.9969323E+00,
     $.9983473E+00,.9993274E+00,.9998723E+00,.7834291E-02,.2350095E-01,
     $.3916184E-01,.5481311E-01,.7045093E-01,.8607145E-01,.1016708E+00/
      data (xp(i),i= 241, 280)/
     $.1172453E+00,.1327909E+00,.1483040E+00,.1637806E+00,.1792170E+00,
     $.1946095E+00,.2099541E+00,.2252472E+00,.2404850E+00,.2556638E+00,
     $.2707798E+00,.2858293E+00,.3008086E+00,.3157141E+00,.3305421E+00,
     $.3452890E+00,.3599510E+00,.3745247E+00,.3890065E+00,.4033927E+00,
     $.4176799E+00,.4318646E+00,.4459432E+00,.4599124E+00,.4737686E+00,
     $.4875086E+00,.5011288E+00,.5146260E+00,.5279969E+00,.5412382E+00,
     $.5543465E+00,.5673188E+00,.5801518E+00,.5928424E+00,.6053874E+00,
     $.6177838E+00,.6300285E+00,.6421185E+00,.6540509E+00,.6658228E+00/
      data (xp(i),i= 281, 320)/
     $.6774311E+00,.6888732E+00,.7001461E+00,.7112472E+00,.7221736E+00,
     $.7329227E+00,.7434919E+00,.7538786E+00,.7640801E+00,.7740941E+00,
     $.7839181E+00,.7935496E+00,.8029862E+00,.8122257E+00,.8212659E+00,
     $.8301044E+00,.8387391E+00,.8471679E+00,.8553887E+00,.8633995E+00,
     $.8711983E+00,.8787832E+00,.8861524E+00,.8933041E+00,.9002364E+00,
     $.9069477E+00,.9134364E+00,.9197008E+00,.9257394E+00,.9315507E+00,
     $.9371333E+00,.9424859E+00,.9476071E+00,.9524956E+00,.9571503E+00,
     $.9615700E+00,.9657536E+00,.9697002E+00,.9734086E+00,.9768781E+00/
      data (xp(i),i= 321, 360)/
     $.9801078E+00,.9830968E+00,.9858445E+00,.9883502E+00,.9906132E+00,
     $.9926330E+00,.9944091E+00,.9959410E+00,.9972285E+00,.9982712E+00,
     $.9990687E+00,.9996210E+00,.9999281E+00,.5227245E-02,.1568116E-01,
     $.2613337E-01,.3658271E-01,.4702806E-01,.5746827E-01,.6790220E-01,
     $.7832871E-01,.8874665E-01,.9915490E-01,.1095523E+00,.1199377E+00,
     $.1303101E+00,.1406682E+00,.1510109E+00,.1613371E+00,.1716456E+00,
     $.1819354E+00,.1922054E+00,.2024543E+00,.2126811E+00,.2228846E+00,
     $.2330638E+00,.2432175E+00,.2533446E+00,.2634441E+00,.2735147E+00/
      data (xp(i),i= 361, 400)/
     $.2835555E+00,.2935652E+00,.3035429E+00,.3134874E+00,.3233976E+00,
     $.3332725E+00,.3431110E+00,.3529120E+00,.3626744E+00,.3723971E+00,
     $.3820792E+00,.3917194E+00,.4013169E+00,.4108705E+00,.4203792E+00,
     $.4298420E+00,.4392578E+00,.4486255E+00,.4579443E+00,.4672130E+00,
     $.4764306E+00,.4855961E+00,.4947086E+00,.5037670E+00,.5127704E+00,
     $.5217177E+00,.5306079E+00,.5394402E+00,.5482135E+00,.5569269E+00,
     $.5655795E+00,.5741702E+00,.5826982E+00,.5911624E+00,.5995621E+00,
     $.6078963E+00,.6161639E+00,.6243643E+00,.6324964E+00,.6405594E+00/
      data (xp(i),i= 401, 440)/
     $.6485524E+00,.6564744E+00,.6643248E+00,.6721025E+00,.6798068E+00,
     $.6874367E+00,.6949916E+00,.7024704E+00,.7098725E+00,.7171970E+00,
     $.7244432E+00,.7316101E+00,.7386971E+00,.7457033E+00,.7526281E+00,
     $.7594705E+00,.7662300E+00,.7729057E+00,.7794970E+00,.7860030E+00,
     $.7924232E+00,.7987567E+00,.8050030E+00,.8111612E+00,.8172308E+00,
     $.8232111E+00,.8291014E+00,.8349011E+00,.8406095E+00,.8462260E+00,
     $.8517501E+00,.8571811E+00,.8625184E+00,.8677614E+00,.8729095E+00,
     $.8779623E+00,.8829191E+00,.8877794E+00,.8925427E+00,.8972084E+00/
      data (xp(i),i= 441, 480)/
     $.9017761E+00,.9062452E+00,.9106152E+00,.9148857E+00,.9190563E+00,
     $.9231263E+00,.9270955E+00,.9309634E+00,.9347295E+00,.9383934E+00,
     $.9419548E+00,.9454132E+00,.9487683E+00,.9520197E+00,.9551671E+00,
     $.9582100E+00,.9611482E+00,.9639814E+00,.9667092E+00,.9693313E+00,
     $.9718476E+00,.9742575E+00,.9765610E+00,.9787578E+00,.9808476E+00,
     $.9828302E+00,.9847054E+00,.9864729E+00,.9881326E+00,.9896844E+00,
     $.9911279E+00,.9924632E+00,.9936899E+00,.9948081E+00,.9958175E+00,
     $.9967181E+00,.9975097E+00,.9981923E+00,.9987659E+00,.9992302E+00/
      data (xp(i),i= 481, 520)/
     $.9995854E+00,.9998313E+00,.9999680E+00,.3922075E-02,.1176598E-01,
     $.1960917E-01,.2745115E-01,.3529144E-01,.4312955E-01,.5096502E-01,
     $.5879735E-01,.6662606E-01,.7445067E-01,.8227070E-01,.9008566E-01,
     $.9789509E-01,.1056985E+00,.1134954E+00,.1212853E+00,.1290678E+00,
     $.1368423E+00,.1446083E+00,.1523655E+00,.1601134E+00,.1678513E+00,
     $.1755790E+00,.1832958E+00,.1910013E+00,.1986951E+00,.2063767E+00,
     $.2140456E+00,.2217013E+00,.2293434E+00,.2369713E+00,.2445847E+00,
     $.2521830E+00,.2597658E+00,.2673327E+00,.2748830E+00,.2824165E+00/
      data (xp(i),i= 521, 560)/
     $.2899326E+00,.2974308E+00,.3049108E+00,.3123719E+00,.3198139E+00,
     $.3272362E+00,.3346383E+00,.3420199E+00,.3493804E+00,.3567194E+00,
     $.3640365E+00,.3713311E+00,.3786029E+00,.3858515E+00,.3930762E+00,
     $.4002768E+00,.4074528E+00,.4146037E+00,.4217291E+00,.4288285E+00,
     $.4359016E+00,.4429478E+00,.4499667E+00,.4569580E+00,.4639212E+00,
     $.4708558E+00,.4777615E+00,.4846377E+00,.4914841E+00,.4983003E+00,
     $.5050859E+00,.5118403E+00,.5185633E+00,.5252543E+00,.5319131E+00,
     $.5385391E+00,.5451319E+00,.5516912E+00,.5582166E+00,.5647076E+00/
      data (xp(i),i= 561, 600)/
     $.5711639E+00,.5775851E+00,.5839707E+00,.5903203E+00,.5966337E+00,
     $.6029103E+00,.6091498E+00,.6153519E+00,.6215161E+00,.6276420E+00,
     $.6337293E+00,.6397777E+00,.6457866E+00,.6517559E+00,.6576850E+00,
     $.6635737E+00,.6694215E+00,.6752281E+00,.6809932E+00,.6867164E+00,
     $.6923974E+00,.6980357E+00,.7036311E+00,.7091832E+00,.7146916E+00,
     $.7201561E+00,.7255763E+00,.7309518E+00,.7362823E+00,.7415676E+00,
     $.7468072E+00,.7520008E+00,.7571482E+00,.7622490E+00,.7673029E+00,
     $.7723096E+00,.7772688E+00,.7821801E+00,.7870433E+00,.7918581E+00/
      data (xp(i),i= 601, 640)/
     $.7966241E+00,.8013412E+00,.8060089E+00,.8106271E+00,.8151953E+00,
     $.8197134E+00,.8241811E+00,.8285980E+00,.8329640E+00,.8372787E+00,
     $.8415419E+00,.8457533E+00,.8499127E+00,.8540198E+00,.8580743E+00,
     $.8620760E+00,.8660247E+00,.8699201E+00,.8737620E+00,.8775501E+00,
     $.8812842E+00,.8849641E+00,.8885896E+00,.8921603E+00,.8956762E+00,
     $.8991369E+00,.9025424E+00,.9058923E+00,.9091864E+00,.9124246E+00,
     $.9156067E+00,.9187324E+00,.9218016E+00,.9248141E+00,.9277697E+00,
     $.9306682E+00,.9335094E+00,.9362932E+00,.9390194E+00,.9416878E+00/
      data (xp(i),i= 641, 680)/
     $.9442982E+00,.9468506E+00,.9493447E+00,.9517803E+00,.9541574E+00,
     $.9564759E+00,.9587354E+00,.9609360E+00,.9630774E+00,.9651596E+00,
     $.9671823E+00,.9691456E+00,.9710493E+00,.9728932E+00,.9746772E+00,
     $.9764012E+00,.9780652E+00,.9796690E+00,.9812125E+00,.9826957E+00,
     $.9841183E+00,.9854805E+00,.9867820E+00,.9880227E+00,.9892027E+00,
     $.9903218E+00,.9913800E+00,.9923771E+00,.9933133E+00,.9941882E+00,
     $.9950021E+00,.9957547E+00,.9964460E+00,.9970760E+00,.9976447E+00,
     $.9981519E+00,.9985978E+00,.9989822E+00,.9993052E+00,.9995666E+00/
      data (xp(i),i= 681, 720)/
     $.9997666E+00,.9999050E+00,.9999820E+00,.2615810E-02,.7847359E-02,
     $.1307869E-01,.1830967E-01,.2354014E-01,.2876997E-01,.3399902E-01,
     $.3922713E-01,.4445417E-01,.4967999E-01,.5490445E-01,.6012741E-01,
     $.6534873E-01,.7056825E-01,.7578585E-01,.8100137E-01,.8621467E-01,
     $.9142561E-01,.9663405E-01,.1018398E+00,.1070429E+00,.1122429E+00,
     $.1174399E+00,.1226337E+00,.1278242E+00,.1330111E+00,.1381944E+00,
     $.1433739E+00,.1485495E+00,.1537210E+00,.1588884E+00,.1640513E+00,
     $.1692098E+00,.1743636E+00,.1795127E+00,.1846569E+00,.1897960E+00/
      data (xp(i),i= 721, 760)/
     $.1949299E+00,.2000585E+00,.2051816E+00,.2102991E+00,.2154108E+00,
     $.2205166E+00,.2256164E+00,.2307101E+00,.2357974E+00,.2408782E+00,
     $.2459525E+00,.2510200E+00,.2560807E+00,.2611343E+00,.2661808E+00,
     $.2712201E+00,.2762519E+00,.2812761E+00,.2862926E+00,.2913013E+00,
     $.2963021E+00,.3012947E+00,.3062790E+00,.3112550E+00,.3162225E+00,
     $.3211813E+00,.3261313E+00,.3310724E+00,.3360045E+00,.3409273E+00,
     $.3458408E+00,.3507449E+00,.3556393E+00,.3605240E+00,.3653989E+00,
     $.3702637E+00,.3751184E+00,.3799629E+00,.3847969E+00,.3896204E+00/
      data (xp(i),i= 761, 800)/
     $.3944333E+00,.3992353E+00,.4040264E+00,.4088065E+00,.4135754E+00,
     $.4183329E+00,.4230790E+00,.4278136E+00,.4325364E+00,.4372474E+00,
     $.4419464E+00,.4466333E+00,.4513080E+00,.4559703E+00,.4606202E+00,
     $.4652574E+00,.4698819E+00,.4744936E+00,.4790923E+00,.4836778E+00,
     $.4882502E+00,.4928091E+00,.4973546E+00,.5018864E+00,.5064046E+00,
     $.5109088E+00,.5153991E+00,.5198753E+00,.5243372E+00,.5287848E+00,
     $.5332179E+00,.5376364E+00,.5420402E+00,.5464292E+00,.5508032E+00,
     $.5551622E+00,.5595059E+00,.5638343E+00,.5681473E+00,.5724448E+00/
      data (xp(i),i= 801, 840)/
     $.5767266E+00,.5809926E+00,.5852427E+00,.5894768E+00,.5936947E+00,
     $.5978964E+00,.6020817E+00,.6062506E+00,.6104028E+00,.6145384E+00,
     $.6186571E+00,.6227589E+00,.6268437E+00,.6309113E+00,.6349616E+00,
     $.6389945E+00,.6430100E+00,.6470079E+00,.6509880E+00,.6549504E+00,
     $.6588948E+00,.6628211E+00,.6667294E+00,.6706194E+00,.6744910E+00,
     $.6783442E+00,.6821788E+00,.6859947E+00,.6897919E+00,.6935702E+00,
     $.6973295E+00,.7010697E+00,.7047907E+00,.7084924E+00,.7121748E+00,
     $.7158376E+00,.7194809E+00,.7231044E+00,.7267082E+00,.7302921E+00/
      data (xp(i),i= 841, 880)/
     $.7338560E+00,.7373998E+00,.7409234E+00,.7444268E+00,.7479097E+00,
     $.7513722E+00,.7548142E+00,.7582355E+00,.7616360E+00,.7650157E+00,
     $.7683744E+00,.7717121E+00,.7750287E+00,.7783241E+00,.7815982E+00,
     $.7848508E+00,.7880821E+00,.7912917E+00,.7944797E+00,.7976459E+00,
     $.8007903E+00,.8039128E+00,.8070132E+00,.8100916E+00,.8131479E+00,
     $.8161818E+00,.8191934E+00,.8221826E+00,.8251493E+00,.8280935E+00,
     $.8310149E+00,.8339136E+00,.8367895E+00,.8396425E+00,.8424725E+00,
     $.8452794E+00,.8480632E+00,.8508238E+00,.8535611E+00,.8562750E+00/
      data (xp(i),i= 881, 920)/
     $.8589656E+00,.8616325E+00,.8642760E+00,.8668957E+00,.8694918E+00,
     $.8720640E+00,.8746124E+00,.8771368E+00,.8796372E+00,.8821136E+00,
     $.8845658E+00,.8869937E+00,.8893975E+00,.8917768E+00,.8941318E+00,
     $.8964623E+00,.8987683E+00,.9010496E+00,.9033063E+00,.9055383E+00,
     $.9077455E+00,.9099278E+00,.9120852E+00,.9142177E+00,.9163252E+00,
     $.9184075E+00,.9204648E+00,.9224968E+00,.9245036E+00,.9264851E+00,
     $.9284412E+00,.9303720E+00,.9322772E+00,.9341570E+00,.9360111E+00,
     $.9378397E+00,.9396426E+00,.9414198E+00,.9431712E+00,.9448967E+00/
      data (xp(i),i= 921, 960)/
     $.9465965E+00,.9482703E+00,.9499181E+00,.9515400E+00,.9531358E+00,
     $.9547056E+00,.9562492E+00,.9577666E+00,.9592578E+00,.9607228E+00,
     $.9621615E+00,.9635738E+00,.9649597E+00,.9663193E+00,.9676524E+00,
     $.9689590E+00,.9702391E+00,.9714927E+00,.9727196E+00,.9739199E+00,
     $.9750936E+00,.9762406E+00,.9773609E+00,.9784544E+00,.9795211E+00,
     $.9805610E+00,.9815741E+00,.9825603E+00,.9835197E+00,.9844521E+00,
     $.9853575E+00,.9862360E+00,.9870876E+00,.9879120E+00,.9887095E+00,
     $.9894799E+00,.9902232E+00,.9909394E+00,.9916285E+00,.9922904E+00/
      data (xp(i),i= 961,1000)/
     $.9929252E+00,.9935328E+00,.9941132E+00,.9946664E+00,.9951924E+00,
     $.9956911E+00,.9961626E+00,.9966068E+00,.9970238E+00,.9974135E+00,
     $.9977758E+00,.9981109E+00,.9984186E+00,.9986990E+00,.9989521E+00,
     $.9991778E+00,.9993762E+00,.9995472E+00,.9996909E+00,.9998072E+00,
     $.9998962E+00,.9999577E+00,.9999920E+00,.1962267E-02,.5886772E-02,
     $.9811186E-02,.1373545E-01,.1765950E-01,.2158328E-01,.2550673E-01,
     $.2942978E-01,.3335238E-01,.3727447E-01,.4119598E-01,.4511686E-01,
     $.4903704E-01,.5295647E-01,.5687508E-01,.6079282E-01,.6470962E-01/
      data (xp(i),i=1001,1040)/
     $.6862542E-01,.7254017E-01,.7645380E-01,.8036625E-01,.8427746E-01,
     $.8818738E-01,.9209594E-01,.9600308E-01,.9990874E-01,.1038129E+00,
     $.1077154E+00,.1116162E+00,.1155154E+00,.1194128E+00,.1233083E+00,
     $.1272019E+00,.1310936E+00,.1349832E+00,.1388708E+00,.1427562E+00,
     $.1466395E+00,.1505204E+00,.1543991E+00,.1582754E+00,.1621492E+00,
     $.1660205E+00,.1698893E+00,.1737555E+00,.1776190E+00,.1814798E+00,
     $.1853377E+00,.1891928E+00,.1930450E+00,.1968942E+00,.2007404E+00,
     $.2045835E+00,.2084235E+00,.2122602E+00,.2160937E+00,.2199238E+00/
      data (xp(i),i=1041,1080)/
     $.2237505E+00,.2275738E+00,.2313936E+00,.2352099E+00,.2390225E+00,
     $.2428314E+00,.2466366E+00,.2504380E+00,.2542355E+00,.2580292E+00,
     $.2618188E+00,.2656044E+00,.2693859E+00,.2731633E+00,.2769365E+00,
     $.2807054E+00,.2844699E+00,.2882301E+00,.2919859E+00,.2957372E+00,
     $.2994839E+00,.3032259E+00,.3069634E+00,.3106961E+00,.3144240E+00,
     $.3181470E+00,.3218652E+00,.3255784E+00,.3292866E+00,.3329897E+00,
     $.3366877E+00,.3403805E+00,.3440681E+00,.3477503E+00,.3514272E+00,
     $.3550987E+00,.3587648E+00,.3624253E+00,.3660802E+00,.3697295E+00/
      data (xp(i),i=1081,1120)/
     $.3733731E+00,.3770109E+00,.3806429E+00,.3842691E+00,.3878893E+00,
     $.3915036E+00,.3951118E+00,.3987140E+00,.4023100E+00,.4058998E+00,
     $.4094834E+00,.4130607E+00,.4166316E+00,.4201960E+00,.4237541E+00,
     $.4273055E+00,.4308504E+00,.4343887E+00,.4379203E+00,.4414451E+00,
     $.4449632E+00,.4484743E+00,.4519786E+00,.4554759E+00,.4589662E+00,
     $.4624494E+00,.4659255E+00,.4693945E+00,.4728562E+00,.4763106E+00,
     $.4797577E+00,.4831973E+00,.4866296E+00,.4900543E+00,.4934715E+00,
     $.4968812E+00,.5002831E+00,.5036774E+00,.5070638E+00,.5104425E+00/
      data (xp(i),i=1121,1160)/
     $.5138133E+00,.5171762E+00,.5205312E+00,.5238781E+00,.5272169E+00,
     $.5305477E+00,.5338702E+00,.5371846E+00,.5404906E+00,.5437884E+00,
     $.5470777E+00,.5503587E+00,.5536311E+00,.5568951E+00,.5601504E+00,
     $.5633972E+00,.5666352E+00,.5698645E+00,.5730851E+00,.5762968E+00,
     $.5794996E+00,.5826936E+00,.5858785E+00,.5890544E+00,.5922213E+00,
     $.5953790E+00,.5985276E+00,.6016669E+00,.6047970E+00,.6079177E+00,
     $.6110291E+00,.6141311E+00,.6172236E+00,.6203066E+00,.6233801E+00,
     $.6264440E+00,.6294982E+00,.6325427E+00,.6355775E+00,.6386024E+00/
      data (xp(i),i=1161,1200)/
     $.6416176E+00,.6446229E+00,.6476182E+00,.6506036E+00,.6535789E+00,
     $.6565442E+00,.6594994E+00,.6624444E+00,.6653792E+00,.6683037E+00,
     $.6712180E+00,.6741219E+00,.6770155E+00,.6798986E+00,.6827712E+00,
     $.6856333E+00,.6884849E+00,.6913259E+00,.6941562E+00,.6969758E+00,
     $.6997847E+00,.7025828E+00,.7053701E+00,.7081465E+00,.7109120E+00,
     $.7136666E+00,.7164102E+00,.7191427E+00,.7218642E+00,.7245746E+00,
     $.7272737E+00,.7299617E+00,.7326385E+00,.7353039E+00,.7379581E+00,
     $.7406008E+00,.7432322E+00,.7458521E+00,.7484606E+00,.7510575E+00/
      data (xp(i),i=1201,1240)/
     $.7536428E+00,.7562165E+00,.7587786E+00,.7613290E+00,.7638676E+00,
     $.7663945E+00,.7689096E+00,.7714129E+00,.7739043E+00,.7763837E+00,
     $.7788512E+00,.7813067E+00,.7837502E+00,.7861816E+00,.7886009E+00,
     $.7910080E+00,.7934030E+00,.7957857E+00,.7981562E+00,.8005144E+00,
     $.8028602E+00,.8051937E+00,.8075148E+00,.8098234E+00,.8121196E+00,
     $.8144033E+00,.8166744E+00,.8189330E+00,.8211789E+00,.8234122E+00,
     $.8256328E+00,.8278407E+00,.8300358E+00,.8322182E+00,.8343877E+00,
     $.8365444E+00,.8386882E+00,.8408191E+00,.8429370E+00,.8450420E+00/
      data (xp(i),i=1241,1280)/
     $.8471339E+00,.8492128E+00,.8512786E+00,.8533313E+00,.8553709E+00,
     $.8573972E+00,.8594104E+00,.8614104E+00,.8633970E+00,.8653704E+00,
     $.8673304E+00,.8692771E+00,.8712104E+00,.8731303E+00,.8750367E+00,
     $.8769297E+00,.8788091E+00,.8806750E+00,.8825274E+00,.8843662E+00,
     $.8861913E+00,.8880028E+00,.8898006E+00,.8915847E+00,.8933550E+00,
     $.8951117E+00,.8968545E+00,.8985835E+00,.9002987E+00,.9020000E+00,
     $.9036874E+00,.9053609E+00,.9070204E+00,.9086660E+00,.9102976E+00,
     $.9119152E+00,.9135187E+00,.9151081E+00,.9166835E+00,.9182447E+00/
      data (xp(i),i=1281,1320)/
     $.9197918E+00,.9213247E+00,.9228435E+00,.9243480E+00,.9258383E+00,
     $.9273143E+00,.9287760E+00,.9302235E+00,.9316566E+00,.9330754E+00,
     $.9344797E+00,.9358697E+00,.9372453E+00,.9386065E+00,.9399532E+00,
     $.9412854E+00,.9426031E+00,.9439063E+00,.9451950E+00,.9464691E+00,
     $.9477286E+00,.9489735E+00,.9502038E+00,.9514195E+00,.9526205E+00,
     $.9538069E+00,.9549785E+00,.9561355E+00,.9572777E+00,.9584052E+00,
     $.9595179E+00,.9606159E+00,.9616990E+00,.9627673E+00,.9638208E+00,
     $.9648595E+00,.9658833E+00,.9668922E+00,.9678863E+00,.9688654E+00/
      data (xp(i),i=1321,1360)/
     $.9698296E+00,.9707788E+00,.9717132E+00,.9726325E+00,.9735369E+00,
     $.9744262E+00,.9753006E+00,.9761600E+00,.9770043E+00,.9778335E+00,
     $.9786477E+00,.9794468E+00,.9802309E+00,.9809998E+00,.9817537E+00,
     $.9824924E+00,.9832160E+00,.9839244E+00,.9846177E+00,.9852958E+00,
     $.9859587E+00,.9866065E+00,.9872390E+00,.9878564E+00,.9884585E+00,
     $.9890455E+00,.9896171E+00,.9901736E+00,.9907148E+00,.9912407E+00,
     $.9917514E+00,.9922468E+00,.9927269E+00,.9931917E+00,.9936412E+00,
     $.9940754E+00,.9944943E+00,.9948979E+00,.9952862E+00,.9956591E+00/
      data (xp(i),i=1361,1400)/
     $.9960167E+00,.9963590E+00,.9966859E+00,.9969974E+00,.9972936E+00,
     $.9975745E+00,.9978400E+00,.9980901E+00,.9983248E+00,.9985442E+00,
     $.9987482E+00,.9989368E+00,.9991100E+00,.9992678E+00,.9994103E+00,
     $.9995373E+00,.9996489E+00,.9997452E+00,.9998261E+00,.9998915E+00,
     $.9999416E+00,.9999762E+00,.9999955E+00,.1570010E-02,.4710016E-02,
     $.7849975E-02,.1098986E-01,.1412963E-01,.1726926E-01,.2040873E-01,
     $.2354799E-01,.2668702E-01,.2982579E-01,.3296426E-01,.3610241E-01,
     $.3924020E-01,.4237761E-01,.4551459E-01,.4865113E-01,.5178719E-01/
      data (xp(i),i=1401,1440)/
     $.5492274E-01,.5805775E-01,.6119218E-01,.6432601E-01,.6745921E-01,
     $.7059174E-01,.7372358E-01,.7685468E-01,.7998504E-01,.8311460E-01,
     $.8624334E-01,.8937123E-01,.9249824E-01,.9562434E-01,.9874950E-01,
     $.1018737E+00,.1049969E+00,.1081190E+00,.1112401E+00,.1143601E+00,
     $.1174789E+00,.1205966E+00,.1237131E+00,.1268284E+00,.1299424E+00,
     $.1330552E+00,.1361666E+00,.1392767E+00,.1423855E+00,.1454928E+00,
     $.1485987E+00,.1517031E+00,.1548060E+00,.1579074E+00,.1610073E+00,
     $.1641055E+00,.1672022E+00,.1702971E+00,.1733905E+00,.1764821E+00/
      data (xp(i),i=1441,1480)/
     $.1795719E+00,.1826600E+00,.1857463E+00,.1888308E+00,.1919134E+00,
     $.1949941E+00,.1980728E+00,.2011497E+00,.2042245E+00,.2072973E+00,
     $.2103681E+00,.2134368E+00,.2165035E+00,.2195679E+00,.2226302E+00,
     $.2256904E+00,.2287482E+00,.2318039E+00,.2348572E+00,.2379083E+00,
     $.2409569E+00,.2440033E+00,.2470472E+00,.2500886E+00,.2531276E+00,
     $.2561641E+00,.2591981E+00,.2622295E+00,.2652584E+00,.2682846E+00,
     $.2713082E+00,.2743291E+00,.2773473E+00,.2803628E+00,.2833755E+00,
     $.2863854E+00,.2893925E+00,.2923967E+00,.2953980E+00,.2983965E+00/
      data (xp(i),i=1481,1520)/
     $.3013920E+00,.3043845E+00,.3073740E+00,.3103605E+00,.3133439E+00,
     $.3163243E+00,.3193015E+00,.3222756E+00,.3252465E+00,.3282141E+00,
     $.3311786E+00,.3341398E+00,.3370977E+00,.3400522E+00,.3430035E+00,
     $.3459513E+00,.3488957E+00,.3518367E+00,.3547742E+00,.3577082E+00,
     $.3606387E+00,.3635657E+00,.3664890E+00,.3694087E+00,.3723248E+00,
     $.3752373E+00,.3781460E+00,.3810510E+00,.3839522E+00,.3868497E+00,
     $.3897433E+00,.3926331E+00,.3955190E+00,.3984010E+00,.4012791E+00,
     $.4041533E+00,.4070234E+00,.4098896E+00,.4127517E+00,.4156097E+00/
      data (xp(i),i=1521,1560)/
     $.4184636E+00,.4213134E+00,.4241591E+00,.4270006E+00,.4298378E+00,
     $.4326708E+00,.4354996E+00,.4383241E+00,.4411442E+00,.4439600E+00,
     $.4467714E+00,.4495784E+00,.4523810E+00,.4551791E+00,.4579727E+00,
     $.4607618E+00,.4635464E+00,.4663264E+00,.4691018E+00,.4718726E+00,
     $.4746387E+00,.4774001E+00,.4801569E+00,.4829089E+00,.4856561E+00,
     $.4883986E+00,.4911362E+00,.4938690E+00,.4965969E+00,.4993199E+00,
     $.5020381E+00,.5047512E+00,.5074594E+00,.5101626E+00,.5128607E+00,
     $.5155538E+00,.5182418E+00,.5209247E+00,.5236025E+00,.5262750E+00/
      data (xp(i),i=1561,1600)/
     $.5289425E+00,.5316046E+00,.5342616E+00,.5369133E+00,.5395597E+00,
     $.5422007E+00,.5448365E+00,.5474668E+00,.5500918E+00,.5527113E+00,
     $.5553254E+00,.5579340E+00,.5605371E+00,.5631347E+00,.5657267E+00,
     $.5683131E+00,.5708940E+00,.5734692E+00,.5760387E+00,.5786026E+00,
     $.5811608E+00,.5837132E+00,.5862599E+00,.5888008E+00,.5913360E+00,
     $.5938652E+00,.5963886E+00,.5989062E+00,.6014178E+00,.6039235E+00,
     $.6064233E+00,.6089170E+00,.6114048E+00,.6138865E+00,.6163622E+00,
     $.6188318E+00,.6212953E+00,.6237527E+00,.6262040E+00,.6286490E+00/
      data (xp(i),i=1601,1640)/
     $.6310879E+00,.6335205E+00,.6359469E+00,.6383670E+00,.6407808E+00,
     $.6431883E+00,.6455895E+00,.6479843E+00,.6503727E+00,.6527547E+00,
     $.6551303E+00,.6574994E+00,.6598620E+00,.6622181E+00,.6645677E+00,
     $.6669107E+00,.6692472E+00,.6715770E+00,.6739003E+00,.6762169E+00,
     $.6785268E+00,.6808300E+00,.6831266E+00,.6854163E+00,.6876994E+00,
     $.6899756E+00,.6922451E+00,.6945077E+00,.6967635E+00,.6990124E+00,
     $.7012544E+00,.7034895E+00,.7057176E+00,.7079388E+00,.7101530E+00,
     $.7123603E+00,.7145605E+00,.7167536E+00,.7189397E+00,.7211187E+00/
      data (xp(i),i=1641,1680)/
     $.7232906E+00,.7254553E+00,.7276129E+00,.7297634E+00,.7319066E+00,
     $.7340426E+00,.7361714E+00,.7382929E+00,.7404071E+00,.7425141E+00,
     $.7446137E+00,.7467060E+00,.7487909E+00,.7508684E+00,.7529385E+00,
     $.7550013E+00,.7570565E+00,.7591043E+00,.7611446E+00,.7631774E+00,
     $.7652027E+00,.7672204E+00,.7692306E+00,.7712332E+00,.7732282E+00,
     $.7752155E+00,.7771953E+00,.7791673E+00,.7811317E+00,.7830884E+00,
     $.7850373E+00,.7869785E+00,.7889120E+00,.7908376E+00,.7927555E+00,
     $.7946656E+00,.7965678E+00,.7984622E+00,.8003486E+00,.8022273E+00/
      data (xp(i),i=1681,1720)/
     $.8040979E+00,.8059607E+00,.8078155E+00,.8096624E+00,.8115013E+00,
     $.8133321E+00,.8151550E+00,.8169698E+00,.8187765E+00,.8205752E+00,
     $.8223658E+00,.8241483E+00,.8259227E+00,.8276889E+00,.8294470E+00,
     $.8311968E+00,.8329385E+00,.8346720E+00,.8363972E+00,.8381142E+00,
     $.8398229E+00,.8415234E+00,.8432156E+00,.8448994E+00,.8465749E+00,
     $.8482421E+00,.8499009E+00,.8515513E+00,.8531933E+00,.8548269E+00,
     $.8564521E+00,.8580688E+00,.8596771E+00,.8612769E+00,.8628682E+00,
     $.8644510E+00,.8660253E+00,.8675910E+00,.8691482E+00,.8706968E+00/
      data (xp(i),i=1721,1760)/
     $.8722369E+00,.8737683E+00,.8752911E+00,.8768053E+00,.8783108E+00,
     $.8798077E+00,.8812959E+00,.8827754E+00,.8842463E+00,.8857083E+00,
     $.8871617E+00,.8886063E+00,.8900422E+00,.8914692E+00,.8928875E+00,
     $.8942970E+00,.8956977E+00,.8970895E+00,.8984725E+00,.8998466E+00,
     $.9012119E+00,.9025683E+00,.9039157E+00,.9052543E+00,.9065839E+00,
     $.9079046E+00,.9092164E+00,.9105192E+00,.9118130E+00,.9130978E+00,
     $.9143736E+00,.9156404E+00,.9168982E+00,.9181469E+00,.9193866E+00,
     $.9206172E+00,.9218387E+00,.9230511E+00,.9242545E+00,.9254487E+00/
      data (xp(i),i=1761,1800)/
     $.9266338E+00,.9278098E+00,.9289766E+00,.9301343E+00,.9312828E+00,
     $.9324221E+00,.9335522E+00,.9346731E+00,.9357848E+00,.9368872E+00,
     $.9379805E+00,.9390645E+00,.9401392E+00,.9412046E+00,.9422608E+00,
     $.9433077E+00,.9443453E+00,.9453735E+00,.9463925E+00,.9474021E+00,
     $.9484024E+00,.9493933E+00,.9503749E+00,.9513471E+00,.9523099E+00,
     $.9532633E+00,.9542073E+00,.9551420E+00,.9560672E+00,.9569829E+00,
     $.9578893E+00,.9587862E+00,.9596736E+00,.9605516E+00,.9614201E+00,
     $.9622791E+00,.9631287E+00,.9639687E+00,.9647992E+00,.9656203E+00/
      data (xp(i),i=1801,1840)/
     $.9664318E+00,.9672338E+00,.9680262E+00,.9688091E+00,.9695824E+00,
     $.9703462E+00,.9711004E+00,.9718451E+00,.9725801E+00,.9733056E+00,
     $.9740215E+00,.9747278E+00,.9754244E+00,.9761115E+00,.9767889E+00,
     $.9774567E+00,.9781148E+00,.9787633E+00,.9794022E+00,.9800314E+00,
     $.9806509E+00,.9812608E+00,.9818610E+00,.9824515E+00,.9830323E+00,
     $.9836035E+00,.9841649E+00,.9847166E+00,.9852586E+00,.9857909E+00,
     $.9863135E+00,.9868264E+00,.9873295E+00,.9878229E+00,.9883066E+00,
     $.9887805E+00,.9892447E+00,.9896991E+00,.9901437E+00,.9905786E+00/
      data (xp(i),i=1841,1880)/
     $.9910037E+00,.9914191E+00,.9918247E+00,.9922205E+00,.9926065E+00,
     $.9929827E+00,.9933492E+00,.9937058E+00,.9940527E+00,.9943897E+00,
     $.9947169E+00,.9950344E+00,.9953420E+00,.9956398E+00,.9959278E+00,
     $.9962060E+00,.9964743E+00,.9967328E+00,.9969815E+00,.9972204E+00,
     $.9974494E+00,.9976686E+00,.9978780E+00,.9980775E+00,.9982672E+00,
     $.9984471E+00,.9986171E+00,.9987772E+00,.9989275E+00,.9990680E+00,
     $.9991986E+00,.9993193E+00,.9994302E+00,.9995313E+00,.9996225E+00,
     $.9997038E+00,.9997753E+00,.9998369E+00,.9998886E+00,.9999306E+00/
      data (xp(i),i=1881,1883)/
     $.9999626E+00,.9999848E+00,.9999971E+00/
      data (wp(i),i=   1,  40)/
     $.4679139E+00,.3607616E+00,.1713245E+00,.2955242E+00,.2692667E+00,
     $.2190864E+00,.1494513E+00,.6667134E-01,.1527534E+00,.1491730E+00,
     $.1420961E+00,.1316886E+00,.1181945E+00,.1019301E+00,.8327674E-01,
     $.6267205E-01,.4060143E-01,.1761401E-01,.7750595E-01,.7703982E-01,
     $.7611036E-01,.7472317E-01,.7288658E-01,.7061165E-01,.6791205E-01,
     $.6480401E-01,.6130624E-01,.5743977E-01,.5322785E-01,.4869581E-01,
     $.4387091E-01,.3878217E-01,.3346020E-01,.2793701E-01,.2224585E-01,
     $.1642106E-01,.1049828E-01,.4521277E-02,.5190788E-01,.5176794E-01/
      data (wp(i),i=  41,  80)/
     $.5148845E-01,.5107016E-01,.5051418E-01,.4982204E-01,.4899558E-01,
     $.4803703E-01,.4694899E-01,.4573438E-01,.4439648E-01,.4293889E-01,
     $.4136555E-01,.3968070E-01,.3788887E-01,.3599490E-01,.3400389E-01,
     $.3192122E-01,.2975249E-01,.2750356E-01,.2518048E-01,.2278952E-01,
     $.2033712E-01,.1782990E-01,.1527462E-01,.1267817E-01,.1004756E-01,
     $.7389931E-02,.4712730E-02,.2026812E-02,.3901781E-01,.3895840E-01,
     $.3883965E-01,.3866176E-01,.3842499E-01,.3812971E-01,.3777636E-01,
     $.3736549E-01,.3689771E-01,.3637375E-01,.3579439E-01,.3516053E-01/
      data (wp(i),i=  81, 120)/
     $.3447312E-01,.3373321E-01,.3294194E-01,.3210050E-01,.3121017E-01,
     $.3027232E-01,.2928837E-01,.2825982E-01,.2718823E-01,.2607524E-01,
     $.2492254E-01,.2373188E-01,.2250509E-01,.2124403E-01,.1995061E-01,
     $.1862681E-01,.1727465E-01,.1589618E-01,.1449351E-01,.1306876E-01,
     $.1162411E-01,.1016177E-01,.8683945E-02,.7192905E-02,.5690922E-02,
     $.4180313E-02,.2663534E-02,.1144950E-02,.3125542E-01,.3122488E-01,
     $.3116384E-01,.3107234E-01,.3095048E-01,.3079838E-01,.3061619E-01,
     $.3040408E-01,.3016227E-01,.2989098E-01,.2959049E-01,.2926108E-01/
      data (wp(i),i= 121, 160)/
     $.2890309E-01,.2851685E-01,.2810276E-01,.2766120E-01,.2719261E-01,
     $.2669746E-01,.2617622E-01,.2562940E-01,.2505754E-01,.2446120E-01,
     $.2384096E-01,.2319742E-01,.2253122E-01,.2184300E-01,.2113344E-01,
     $.2040323E-01,.1965309E-01,.1888374E-01,.1809594E-01,.1729046E-01,
     $.1646809E-01,.1562962E-01,.1477588E-01,.1390771E-01,.1302595E-01,
     $.1213146E-01,.1122511E-01,.1030780E-01,.9380420E-02,.8443871E-02,
     $.7499073E-02,.6546948E-02,.5588428E-02,.4624450E-02,.3655961E-02,
     $.2683925E-02,.1709393E-02,.7346345E-03,.2087312E-01,.2086402E-01/
      data (wp(i),i= 161, 200)/
     $.2084584E-01,.2081857E-01,.2078223E-01,.2073683E-01,.2068240E-01,
     $.2061896E-01,.2054653E-01,.2046515E-01,.2037486E-01,.2027568E-01,
     $.2016767E-01,.2005088E-01,.1992534E-01,.1979113E-01,.1964829E-01,
     $.1949689E-01,.1933700E-01,.1916867E-01,.1899200E-01,.1880705E-01,
     $.1861391E-01,.1841266E-01,.1820338E-01,.1798617E-01,.1776113E-01,
     $.1752835E-01,.1728792E-01,.1703997E-01,.1678459E-01,.1652190E-01,
     $.1625201E-01,.1597504E-01,.1569110E-01,.1540033E-01,.1510285E-01,
     $.1479879E-01,.1448828E-01,.1417146E-01,.1384846E-01,.1351943E-01/
      data (wp(i),i= 201, 240)/
     $.1318451E-01,.1284384E-01,.1249758E-01,.1214587E-01,.1178887E-01,
     $.1142673E-01,.1105962E-01,.1068768E-01,.1031109E-01,.9930004E-02,
     $.9544593E-02,.9155022E-02,.8761463E-02,.8364086E-02,.7963064E-02,
     $.7558573E-02,.7150788E-02,.6739888E-02,.6326051E-02,.5909457E-02,
     $.5490289E-02,.5068728E-02,.4644959E-02,.4219166E-02,.3791535E-02,
     $.3362252E-02,.2931504E-02,.2499479E-02,.2066366E-02,.1632357E-02,
     $.1197647E-02,.7624721E-03,.3276087E-03,.1566826E-01,.1566442E-01,
     $.1565672E-01,.1564519E-01,.1562981E-01,.1561059E-01,.1558755E-01/
      data (wp(i),i= 241, 280)/
     $.1556067E-01,.1552998E-01,.1549547E-01,.1545716E-01,.1541506E-01,
     $.1536917E-01,.1531950E-01,.1526608E-01,.1520891E-01,.1514800E-01,
     $.1508338E-01,.1501505E-01,.1494303E-01,.1486735E-01,.1478802E-01,
     $.1470505E-01,.1461848E-01,.1452832E-01,.1443459E-01,.1433731E-01,
     $.1423652E-01,.1413223E-01,.1402447E-01,.1391327E-01,.1379866E-01,
     $.1368065E-01,.1355929E-01,.1343460E-01,.1330661E-01,.1317535E-01,
     $.1304086E-01,.1290316E-01,.1276230E-01,.1261831E-01,.1247122E-01,
     $.1232106E-01,.1216788E-01,.1201172E-01,.1185260E-01,.1169058E-01/
      data (wp(i),i= 281, 320)/
     $.1152568E-01,.1135796E-01,.1118744E-01,.1101418E-01,.1083822E-01,
     $.1065959E-01,.1047835E-01,.1029454E-01,.1010820E-01,.9919373E-02,
     $.9728115E-02,.9534468E-02,.9338480E-02,.9140200E-02,.8939676E-02,
     $.8736957E-02,.8532093E-02,.8325134E-02,.8116132E-02,.7905137E-02,
     $.7692201E-02,.7477377E-02,.7260717E-02,.7042274E-02,.6822103E-02,
     $.6600256E-02,.6376790E-02,.6151757E-02,.5925215E-02,.5697218E-02,
     $.5467822E-02,.5237083E-02,.5005059E-02,.4771806E-02,.4537382E-02,
     $.4301844E-02,.4065249E-02,.3827657E-02,.3589125E-02,.3349711E-02/
      data (wp(i),i= 321, 360)/
     $.3109476E-02,.2868477E-02,.2626773E-02,.2384425E-02,.2141492E-02,
     $.1898033E-02,.1654108E-02,.1409777E-02,.1165101E-02,.9201405E-03,
     $.6749606E-03,.4296466E-03,.1845901E-03,.1045439E-01,.1045325E-01,
     $.1045097E-01,.1044754E-01,.1044297E-01,.1043726E-01,.1043041E-01,
     $.1042242E-01,.1041329E-01,.1040302E-01,.1039161E-01,.1037907E-01,
     $.1036539E-01,.1035058E-01,.1033464E-01,.1031758E-01,.1029938E-01,
     $.1028006E-01,.1025961E-01,.1023804E-01,.1021535E-01,.1019155E-01,
     $.1016663E-01,.1014060E-01,.1011347E-01,.1008523E-01,.1005588E-01/
      data (wp(i),i= 361, 400)/
     $.1002544E-01,.9993899E-02,.9961267E-02,.9927547E-02,.9892741E-02,
     $.9856855E-02,.9819891E-02,.9781854E-02,.9742747E-02,.9702576E-02,
     $.9661345E-02,.9619057E-02,.9575718E-02,.9531333E-02,.9485905E-02,
     $.9439441E-02,.9391946E-02,.9343424E-02,.9293880E-02,.9243321E-02,
     $.9191751E-02,.9139177E-02,.9085604E-02,.9031038E-02,.8975485E-02,
     $.8918951E-02,.8861442E-02,.8802965E-02,.8743525E-02,.8683130E-02,
     $.8621786E-02,.8559499E-02,.8496277E-02,.8432127E-02,.8367054E-02,
     $.8301068E-02,.8234174E-02,.8166380E-02,.8097693E-02,.8028121E-02/
      data (wp(i),i= 401, 440)/
     $.7957672E-02,.7886353E-02,.7814173E-02,.7741138E-02,.7667257E-02,
     $.7592538E-02,.7516989E-02,.7440619E-02,.7363435E-02,.7285447E-02,
     $.7206662E-02,.7127090E-02,.7046739E-02,.6965617E-02,.6883734E-02,
     $.6801099E-02,.6717721E-02,.6633608E-02,.6548770E-02,.6463217E-02,
     $.6376957E-02,.6290000E-02,.6202356E-02,.6114033E-02,.6025043E-02,
     $.5935394E-02,.5845096E-02,.5754159E-02,.5662594E-02,.5570409E-02,
     $.5477616E-02,.5384224E-02,.5290244E-02,.5195685E-02,.5100559E-02,
     $.5004875E-02,.4908644E-02,.4811876E-02,.4714583E-02,.4616774E-02/
      data (wp(i),i= 441, 480)/
     $.4518461E-02,.4419654E-02,.4320364E-02,.4220601E-02,.4120378E-02,
     $.4019704E-02,.3918590E-02,.3817049E-02,.3715090E-02,.3612725E-02,
     $.3509965E-02,.3406822E-02,.3303306E-02,.3199429E-02,.3095203E-02,
     $.2990638E-02,.2885746E-02,.2780539E-02,.2675029E-02,.2569225E-02,
     $.2463141E-02,.2356788E-02,.2250177E-02,.2143320E-02,.2036229E-02,
     $.1928915E-02,.1821391E-02,.1713667E-02,.1605756E-02,.1497670E-02,
     $.1389420E-02,.1281018E-02,.1172476E-02,.1063806E-02,.9550200E-03,
     $.8461294E-03,.7371464E-03,.6280830E-03,.5189512E-03,.4097636E-03/
      data (wp(i),i= 481, 520)/
     $.3005340E-03,.1912855E-03,.8217779E-04,.7844110E-02,.7843627E-02,
     $.7842662E-02,.7841214E-02,.7839284E-02,.7836871E-02,.7833976E-02,
     $.7830599E-02,.7826741E-02,.7822400E-02,.7817579E-02,.7812276E-02,
     $.7806493E-02,.7800229E-02,.7793485E-02,.7786262E-02,.7778560E-02,
     $.7770379E-02,.7761720E-02,.7752583E-02,.7742970E-02,.7732880E-02,
     $.7722314E-02,.7711273E-02,.7699757E-02,.7687768E-02,.7675306E-02,
     $.7662371E-02,.7648965E-02,.7635088E-02,.7620742E-02,.7605926E-02,
     $.7590643E-02,.7574892E-02,.7558676E-02,.7541994E-02,.7524848E-02/
      data (wp(i),i= 521, 560)/
     $.7507240E-02,.7489169E-02,.7470638E-02,.7451646E-02,.7432197E-02,
     $.7412290E-02,.7391927E-02,.7371109E-02,.7349838E-02,.7328114E-02,
     $.7305939E-02,.7283315E-02,.7260243E-02,.7236724E-02,.7212760E-02,
     $.7188352E-02,.7163501E-02,.7138210E-02,.7112480E-02,.7086312E-02,
     $.7059708E-02,.7032669E-02,.7005198E-02,.6977296E-02,.6948964E-02,
     $.6920205E-02,.6891020E-02,.6861412E-02,.6831380E-02,.6800929E-02,
     $.6770059E-02,.6738773E-02,.6707072E-02,.6674958E-02,.6642433E-02,
     $.6609500E-02,.6576160E-02,.6542416E-02,.6508269E-02,.6473721E-02/
      data (wp(i),i= 561, 600)/
     $.6438775E-02,.6403433E-02,.6367697E-02,.6331569E-02,.6295052E-02,
     $.6258147E-02,.6220857E-02,.6183184E-02,.6145131E-02,.6106700E-02,
     $.6067893E-02,.6028713E-02,.5989161E-02,.5949241E-02,.5908956E-02,
     $.5868306E-02,.5827296E-02,.5785926E-02,.5744201E-02,.5702123E-02,
     $.5659693E-02,.5616916E-02,.5573792E-02,.5530326E-02,.5486520E-02,
     $.5442376E-02,.5397897E-02,.5353085E-02,.5307945E-02,.5262478E-02,
     $.5216687E-02,.5170575E-02,.5124145E-02,.5077400E-02,.5030342E-02,
     $.4982975E-02,.4935301E-02,.4887323E-02,.4839045E-02,.4790469E-02/
      data (wp(i),i= 601, 640)/
     $.4741598E-02,.4692436E-02,.4642984E-02,.4593247E-02,.4543228E-02,
     $.4492929E-02,.4442353E-02,.4391504E-02,.4340385E-02,.4288999E-02,
     $.4237349E-02,.4185438E-02,.4133270E-02,.4080847E-02,.4028173E-02,
     $.3975251E-02,.3922085E-02,.3868678E-02,.3815032E-02,.3761152E-02,
     $.3707040E-02,.3652700E-02,.3598135E-02,.3543349E-02,.3488345E-02,
     $.3433126E-02,.3377697E-02,.3322059E-02,.3266217E-02,.3210173E-02,
     $.3153933E-02,.3097498E-02,.3040873E-02,.2984060E-02,.2927064E-02,
     $.2869888E-02,.2812535E-02,.2755009E-02,.2697314E-02,.2639453E-02/
      data (wp(i),i= 641, 680)/
     $.2581429E-02,.2523247E-02,.2464909E-02,.2406419E-02,.2347782E-02,
     $.2289000E-02,.2230077E-02,.2171017E-02,.2111823E-02,.2052500E-02,
     $.1993050E-02,.1933477E-02,.1873786E-02,.1813979E-02,.1754061E-02,
     $.1694034E-02,.1633904E-02,.1573673E-02,.1513345E-02,.1452924E-02,
     $.1392413E-02,.1331817E-02,.1271139E-02,.1210383E-02,.1149552E-02,
     $.1088651E-02,.1027682E-02,.9666507E-03,.9055595E-03,.8444126E-03,
     $.7832138E-03,.7219667E-03,.6606753E-03,.5993432E-03,.5379742E-03,
     $.4765722E-03,.4151409E-03,.3536841E-03,.2922057E-03,.2307099E-03/
      data (wp(i),i= 681, 720)/
     $.1692014E-03,.1076904E-03,.4626372E-04,.5231608E-02,.5231465E-02,
     $.5231179E-02,.5230749E-02,.5230177E-02,.5229461E-02,.5228602E-02,
     $.5227600E-02,.5226454E-02,.5225166E-02,.5223735E-02,.5222161E-02,
     $.5220444E-02,.5218584E-02,.5216581E-02,.5214435E-02,.5212147E-02,
     $.5209716E-02,.5207142E-02,.5204426E-02,.5201567E-02,.5198567E-02,
     $.5195423E-02,.5192138E-02,.5188710E-02,.5185141E-02,.5181429E-02,
     $.5177576E-02,.5173581E-02,.5169445E-02,.5165167E-02,.5160747E-02,
     $.5156186E-02,.5151485E-02,.5146642E-02,.5141658E-02,.5136534E-02/
      data (wp(i),i= 721, 760)/
     $.5131269E-02,.5125863E-02,.5120318E-02,.5114632E-02,.5108806E-02,
     $.5102840E-02,.5096735E-02,.5090490E-02,.5084106E-02,.5077583E-02,
     $.5070920E-02,.5064119E-02,.5057180E-02,.5050102E-02,.5042885E-02,
     $.5035531E-02,.5028039E-02,.5020409E-02,.5012642E-02,.5004738E-02,
     $.4996696E-02,.4988518E-02,.4980203E-02,.4971752E-02,.4963165E-02,
     $.4954443E-02,.4945584E-02,.4936590E-02,.4927461E-02,.4918197E-02,
     $.4908799E-02,.4899266E-02,.4889599E-02,.4879799E-02,.4869864E-02,
     $.4859797E-02,.4849596E-02,.4839263E-02,.4828797E-02,.4818199E-02/
      data (wp(i),i= 761, 800)/
     $.4807470E-02,.4796608E-02,.4785616E-02,.4774492E-02,.4763238E-02,
     $.4751853E-02,.4740338E-02,.4728694E-02,.4716920E-02,.4705017E-02,
     $.4692985E-02,.4680825E-02,.4668537E-02,.4656121E-02,.4643577E-02,
     $.4630907E-02,.4618109E-02,.4605185E-02,.4592136E-02,.4578960E-02,
     $.4565659E-02,.4552233E-02,.4538683E-02,.4525008E-02,.4511210E-02,
     $.4497288E-02,.4483243E-02,.4469075E-02,.4454785E-02,.4440373E-02,
     $.4425840E-02,.4411185E-02,.4396410E-02,.4381514E-02,.4366498E-02,
     $.4351363E-02,.4336109E-02,.4320736E-02,.4305245E-02,.4289636E-02/
      data (wp(i),i= 801, 840)/
     $.4273910E-02,.4258066E-02,.4242106E-02,.4226030E-02,.4209839E-02,
     $.4193532E-02,.4177110E-02,.4160574E-02,.4143924E-02,.4127161E-02,
     $.4110284E-02,.4093296E-02,.4076195E-02,.4058982E-02,.4041659E-02,
     $.4024225E-02,.4006681E-02,.3989027E-02,.3971264E-02,.3953392E-02,
     $.3935412E-02,.3917324E-02,.3899129E-02,.3880828E-02,.3862420E-02,
     $.3843906E-02,.3825288E-02,.3806564E-02,.3787737E-02,.3768805E-02,
     $.3749771E-02,.3730634E-02,.3711395E-02,.3692054E-02,.3672612E-02,
     $.3653070E-02,.3633427E-02,.3613685E-02,.3593845E-02,.3573906E-02/
      data (wp(i),i= 841, 880)/
     $.3553869E-02,.3533735E-02,.3513504E-02,.3493177E-02,.3472754E-02,
     $.3452237E-02,.3431624E-02,.3410918E-02,.3390119E-02,.3369227E-02,
     $.3348242E-02,.3327166E-02,.3305999E-02,.3284741E-02,.3263394E-02,
     $.3241957E-02,.3220431E-02,.3198818E-02,.3177116E-02,.3155328E-02,
     $.3133454E-02,.3111493E-02,.3089448E-02,.3067318E-02,.3045104E-02,
     $.3022806E-02,.3000426E-02,.2977964E-02,.2955420E-02,.2932796E-02,
     $.2910091E-02,.2887306E-02,.2864443E-02,.2841501E-02,.2818481E-02,
     $.2795384E-02,.2772211E-02,.2748961E-02,.2725637E-02,.2702238E-02/
      data (wp(i),i= 881, 920)/
     $.2678765E-02,.2655218E-02,.2631599E-02,.2607908E-02,.2584146E-02,
     $.2560312E-02,.2536409E-02,.2512437E-02,.2488395E-02,.2464286E-02,
     $.2440109E-02,.2415865E-02,.2391555E-02,.2367179E-02,.2342739E-02,
     $.2318235E-02,.2293667E-02,.2269037E-02,.2244344E-02,.2219590E-02,
     $.2194775E-02,.2169901E-02,.2144966E-02,.2119973E-02,.2094922E-02,
     $.2069814E-02,.2044649E-02,.2019428E-02,.1994152E-02,.1968821E-02,
     $.1943437E-02,.1917999E-02,.1892508E-02,.1866966E-02,.1841373E-02,
     $.1815729E-02,.1790036E-02,.1764294E-02,.1738503E-02,.1712665E-02/
      data (wp(i),i= 921, 960)/
     $.1686780E-02,.1660848E-02,.1634872E-02,.1608850E-02,.1582785E-02,
     $.1556676E-02,.1530525E-02,.1504331E-02,.1478097E-02,.1451822E-02,
     $.1425507E-02,.1399154E-02,.1372762E-02,.1346332E-02,.1319866E-02,
     $.1293363E-02,.1266825E-02,.1240253E-02,.1213646E-02,.1187006E-02,
     $.1160334E-02,.1133630E-02,.1106895E-02,.1080130E-02,.1053335E-02,
     $.1026511E-02,.9996593E-03,.9727801E-03,.9458743E-03,.9189426E-03,
     $.8919858E-03,.8650045E-03,.8379996E-03,.8109717E-03,.7839217E-03,
     $.7568502E-03,.7297579E-03,.7026457E-03,.6755143E-03,.6483644E-03/
      data (wp(i),i= 961,1000)/
     $.6211967E-03,.5940120E-03,.5668111E-03,.5395947E-03,.5123635E-03,
     $.4851182E-03,.4578597E-03,.4305887E-03,.4033058E-03,.3760120E-03,
     $.3487078E-03,.3213941E-03,.2940716E-03,.2667411E-03,.2394033E-03,
     $.2120589E-03,.1847087E-03,.1573535E-03,.1299941E-03,.1026314E-03,
     $.7526651E-04,.4790311E-04,.2057885E-04,.3924530E-02,.3924469E-02,
     $.3924348E-02,.3924167E-02,.3923925E-02,.3923623E-02,.3923260E-02,
     $.3922837E-02,.3922354E-02,.3921810E-02,.3921206E-02,.3920541E-02,
     $.3919816E-02,.3919030E-02,.3918185E-02,.3917278E-02,.3916312E-02/
      data (wp(i),i=1001,1040)/
     $.3915285E-02,.3914198E-02,.3913051E-02,.3911843E-02,.3910575E-02,
     $.3909247E-02,.3907858E-02,.3906410E-02,.3904901E-02,.3903332E-02,
     $.3901703E-02,.3900014E-02,.3898265E-02,.3896456E-02,.3894587E-02,
     $.3892658E-02,.3890668E-02,.3888619E-02,.3886510E-02,.3884342E-02,
     $.3882113E-02,.3879825E-02,.3877476E-02,.3875068E-02,.3872601E-02,
     $.3870074E-02,.3867487E-02,.3864840E-02,.3862134E-02,.3859369E-02,
     $.3856544E-02,.3853660E-02,.3850716E-02,.3847713E-02,.3844651E-02,
     $.3841530E-02,.3838349E-02,.3835109E-02,.3831811E-02,.3828453E-02/
      data (wp(i),i=1041,1080)/
     $.3825036E-02,.3821561E-02,.3818026E-02,.3814433E-02,.3810781E-02,
     $.3807070E-02,.3803300E-02,.3799473E-02,.3795586E-02,.3791641E-02,
     $.3787638E-02,.3783576E-02,.3779456E-02,.3775278E-02,.3771042E-02,
     $.3766747E-02,.3762395E-02,.3757984E-02,.3753516E-02,.3748990E-02,
     $.3744406E-02,.3739765E-02,.3735066E-02,.3730309E-02,.3725495E-02,
     $.3720624E-02,.3715695E-02,.3710709E-02,.3705666E-02,.3700566E-02,
     $.3695408E-02,.3690194E-02,.3684923E-02,.3679596E-02,.3674211E-02,
     $.3668770E-02,.3663273E-02,.3657719E-02,.3652109E-02,.3646442E-02/
      data (wp(i),i=1081,1120)/
     $.3640720E-02,.3634941E-02,.3629106E-02,.3623216E-02,.3617269E-02,
     $.3611267E-02,.3605209E-02,.3599096E-02,.3592927E-02,.3586703E-02,
     $.3580424E-02,.3574090E-02,.3567700E-02,.3561256E-02,.3554757E-02,
     $.3548203E-02,.3541594E-02,.3534931E-02,.3528213E-02,.3521441E-02,
     $.3514615E-02,.3507734E-02,.3500800E-02,.3493812E-02,.3486770E-02,
     $.3479674E-02,.3472524E-02,.3465321E-02,.3458065E-02,.3450756E-02,
     $.3443393E-02,.3435977E-02,.3428508E-02,.3420987E-02,.3413413E-02,
     $.3405786E-02,.3398107E-02,.3390375E-02,.3382592E-02,.3374756E-02/
      data (wp(i),i=1121,1160)/
     $.3366868E-02,.3358928E-02,.3350937E-02,.3342894E-02,.3334800E-02,
     $.3326654E-02,.3318457E-02,.3310208E-02,.3301909E-02,.3293559E-02,
     $.3285158E-02,.3276707E-02,.3268205E-02,.3259653E-02,.3251051E-02,
     $.3242398E-02,.3233696E-02,.3224944E-02,.3216142E-02,.3207290E-02,
     $.3198390E-02,.3189440E-02,.3180440E-02,.3171392E-02,.3162295E-02,
     $.3153149E-02,.3143955E-02,.3134712E-02,.3125421E-02,.3116082E-02,
     $.3106695E-02,.3097260E-02,.3087778E-02,.3078247E-02,.3068670E-02,
     $.3059045E-02,.3049373E-02,.3039654E-02,.3029888E-02,.3020075E-02/
      data (wp(i),i=1161,1200)/
     $.3010217E-02,.3000311E-02,.2990360E-02,.2980362E-02,.2970318E-02,
     $.2960229E-02,.2950094E-02,.2939914E-02,.2929688E-02,.2919418E-02,
     $.2909102E-02,.2898742E-02,.2888336E-02,.2877887E-02,.2867393E-02,
     $.2856855E-02,.2846273E-02,.2835647E-02,.2824977E-02,.2814264E-02,
     $.2803508E-02,.2792708E-02,.2781865E-02,.2770980E-02,.2760052E-02,
     $.2749081E-02,.2738068E-02,.2727013E-02,.2715915E-02,.2704776E-02,
     $.2693596E-02,.2682374E-02,.2671110E-02,.2659805E-02,.2648460E-02,
     $.2637073E-02,.2625646E-02,.2614179E-02,.2602671E-02,.2591123E-02/
      data (wp(i),i=1201,1240)/
     $.2579536E-02,.2567908E-02,.2556241E-02,.2544535E-02,.2532789E-02,
     $.2521005E-02,.2509181E-02,.2497319E-02,.2485419E-02,.2473480E-02,
     $.2461503E-02,.2449488E-02,.2437436E-02,.2425346E-02,.2413218E-02,
     $.2401054E-02,.2388852E-02,.2376614E-02,.2364339E-02,.2352028E-02,
     $.2339680E-02,.2327296E-02,.2314877E-02,.2302422E-02,.2289931E-02,
     $.2277405E-02,.2264844E-02,.2252249E-02,.2239618E-02,.2226953E-02,
     $.2214254E-02,.2201520E-02,.2188753E-02,.2175952E-02,.2163117E-02,
     $.2150249E-02,.2137349E-02,.2124415E-02,.2111448E-02,.2098449E-02/
      data (wp(i),i=1241,1280)/
     $.2085417E-02,.2072354E-02,.2059258E-02,.2046131E-02,.2032972E-02,
     $.2019782E-02,.2006561E-02,.1993309E-02,.1980026E-02,.1966713E-02,
     $.1953370E-02,.1939996E-02,.1926592E-02,.1913159E-02,.1899697E-02,
     $.1886205E-02,.1872684E-02,.1859134E-02,.1845555E-02,.1831949E-02,
     $.1818314E-02,.1804650E-02,.1790960E-02,.1777241E-02,.1763495E-02,
     $.1749722E-02,.1735922E-02,.1722096E-02,.1708242E-02,.1694363E-02,
     $.1680457E-02,.1666526E-02,.1652569E-02,.1638586E-02,.1624578E-02,
     $.1610545E-02,.1596488E-02,.1582405E-02,.1568299E-02,.1554168E-02/
      data (wp(i),i=1281,1320)/
     $.1540013E-02,.1525835E-02,.1511633E-02,.1497407E-02,.1483159E-02,
     $.1468888E-02,.1454594E-02,.1440278E-02,.1425940E-02,.1411579E-02,
     $.1397197E-02,.1382794E-02,.1368369E-02,.1353923E-02,.1339456E-02,
     $.1324969E-02,.1310461E-02,.1295933E-02,.1281385E-02,.1266817E-02,
     $.1252230E-02,.1237623E-02,.1222998E-02,.1208353E-02,.1193690E-02,
     $.1179009E-02,.1164309E-02,.1149592E-02,.1134857E-02,.1120104E-02,
     $.1105334E-02,.1090547E-02,.1075743E-02,.1060923E-02,.1046086E-02,
     $.1031234E-02,.1016365E-02,.1001481E-02,.9865808E-03,.9716658E-03/
      data (wp(i),i=1321,1360)/
     $.9567359E-03,.9417913E-03,.9268321E-03,.9118587E-03,.8968712E-03,
     $.8818700E-03,.8668551E-03,.8518269E-03,.8367855E-03,.8217313E-03,
     $.8066644E-03,.7915851E-03,.7764936E-03,.7613902E-03,.7462750E-03,
     $.7311483E-03,.7160104E-03,.7008614E-03,.6857017E-03,.6705313E-03,
     $.6553507E-03,.6401600E-03,.6249593E-03,.6097491E-03,.5945295E-03,
     $.5793007E-03,.5640630E-03,.5488166E-03,.5335618E-03,.5182987E-03,
     $.5030277E-03,.4877489E-03,.4724626E-03,.4571690E-03,.4418684E-03,
     $.4265610E-03,.4112470E-03,.3959267E-03,.3806003E-03,.3652680E-03/
      data (wp(i),i=1361,1400)/
     $.3499301E-03,.3345867E-03,.3192383E-03,.3038849E-03,.2885269E-03,
     $.2731644E-03,.2577977E-03,.2424270E-03,.2270526E-03,.2116747E-03,
     $.1962935E-03,.1809093E-03,.1655224E-03,.1501328E-03,.1347410E-03,
     $.1193471E-03,.1039514E-03,.8855408E-04,.7315545E-04,.5775582E-04,
     $.4235569E-04,.2695689E-04,.1158044E-04,.3140018E-02,.3139987E-02,
     $.3139926E-02,.3139833E-02,.3139709E-02,.3139554E-02,.3139368E-02,
     $.3139152E-02,.3138904E-02,.3138625E-02,.3138316E-02,.3137975E-02,
     $.3137604E-02,.3137201E-02,.3136768E-02,.3136304E-02,.3135809E-02/
      data (wp(i),i=1401,1440)/
     $.3135283E-02,.3134726E-02,.3134138E-02,.3133519E-02,.3132869E-02,
     $.3132189E-02,.3131477E-02,.3130735E-02,.3129962E-02,.3129158E-02,
     $.3128323E-02,.3127457E-02,.3126560E-02,.3125633E-02,.3124675E-02,
     $.3123686E-02,.3122666E-02,.3121615E-02,.3120534E-02,.3119422E-02,
     $.3118279E-02,.3117105E-02,.3115901E-02,.3114666E-02,.3113400E-02,
     $.3112103E-02,.3110776E-02,.3109418E-02,.3108029E-02,.3106610E-02,
     $.3105160E-02,.3103680E-02,.3102169E-02,.3100627E-02,.3099055E-02,
     $.3097452E-02,.3095819E-02,.3094155E-02,.3092461E-02,.3090736E-02/
      data (wp(i),i=1441,1480)/
     $.3088981E-02,.3087195E-02,.3085379E-02,.3083532E-02,.3081655E-02,
     $.3079748E-02,.3077810E-02,.3075842E-02,.3073843E-02,.3071815E-02,
     $.3069756E-02,.3067666E-02,.3065547E-02,.3063397E-02,.3061217E-02,
     $.3059007E-02,.3056766E-02,.3054496E-02,.3052195E-02,.3049865E-02,
     $.3047504E-02,.3045113E-02,.3042692E-02,.3040242E-02,.3037761E-02,
     $.3035250E-02,.3032709E-02,.3030139E-02,.3027538E-02,.3024908E-02,
     $.3022248E-02,.3019558E-02,.3016838E-02,.3014089E-02,.3011310E-02,
     $.3008501E-02,.3005662E-02,.3002794E-02,.2999896E-02,.2996969E-02/
      data (wp(i),i=1481,1520)/
     $.2994012E-02,.2991026E-02,.2988010E-02,.2984965E-02,.2981890E-02,
     $.2978786E-02,.2975652E-02,.2972489E-02,.2969297E-02,.2966075E-02,
     $.2962825E-02,.2959545E-02,.2956236E-02,.2952897E-02,.2949530E-02,
     $.2946134E-02,.2942708E-02,.2939254E-02,.2935770E-02,.2932258E-02,
     $.2928716E-02,.2925146E-02,.2921547E-02,.2917919E-02,.2914262E-02,
     $.2910577E-02,.2906863E-02,.2903120E-02,.2899349E-02,.2895549E-02,
     $.2891720E-02,.2887863E-02,.2883978E-02,.2880064E-02,.2876122E-02,
     $.2872151E-02,.2868152E-02,.2864125E-02,.2860069E-02,.2855985E-02/
      data (wp(i),i=1521,1560)/
     $.2851873E-02,.2847734E-02,.2843565E-02,.2839369E-02,.2835145E-02,
     $.2830893E-02,.2826613E-02,.2822305E-02,.2817970E-02,.2813606E-02,
     $.2809215E-02,.2804796E-02,.2800350E-02,.2795875E-02,.2791374E-02,
     $.2786844E-02,.2782288E-02,.2777704E-02,.2773092E-02,.2768453E-02,
     $.2763787E-02,.2759094E-02,.2754373E-02,.2749625E-02,.2744850E-02,
     $.2740048E-02,.2735219E-02,.2730363E-02,.2725480E-02,.2720571E-02,
     $.2715634E-02,.2710671E-02,.2705681E-02,.2700664E-02,.2695621E-02,
     $.2690551E-02,.2685454E-02,.2680331E-02,.2675182E-02,.2670006E-02/
      data (wp(i),i=1561,1600)/
     $.2664804E-02,.2659576E-02,.2654321E-02,.2649040E-02,.2643733E-02,
     $.2638400E-02,.2633041E-02,.2627657E-02,.2622246E-02,.2616809E-02,
     $.2611347E-02,.2605858E-02,.2600344E-02,.2594805E-02,.2589240E-02,
     $.2583649E-02,.2578033E-02,.2572391E-02,.2566724E-02,.2561032E-02,
     $.2555315E-02,.2549572E-02,.2543804E-02,.2538011E-02,.2532193E-02,
     $.2526350E-02,.2520483E-02,.2514590E-02,.2508672E-02,.2502730E-02,
     $.2496763E-02,.2490772E-02,.2484756E-02,.2478715E-02,.2472650E-02,
     $.2466561E-02,.2460447E-02,.2454309E-02,.2448147E-02,.2441961E-02/
      data (wp(i),i=1601,1640)/
     $.2435751E-02,.2429516E-02,.2423258E-02,.2416976E-02,.2410670E-02,
     $.2404340E-02,.2397986E-02,.2391609E-02,.2385209E-02,.2378784E-02,
     $.2372337E-02,.2365866E-02,.2359371E-02,.2352853E-02,.2346312E-02,
     $.2339748E-02,.2333161E-02,.2326551E-02,.2319918E-02,.2313262E-02,
     $.2306584E-02,.2299882E-02,.2293158E-02,.2286411E-02,.2279642E-02,
     $.2272850E-02,.2266036E-02,.2259200E-02,.2252341E-02,.2245460E-02,
     $.2238557E-02,.2231631E-02,.2224684E-02,.2217715E-02,.2210724E-02,
     $.2203711E-02,.2196677E-02,.2189620E-02,.2182543E-02,.2175443E-02/
      data (wp(i),i=1641,1680)/
     $.2168323E-02,.2161180E-02,.2154017E-02,.2146832E-02,.2139626E-02,
     $.2132400E-02,.2125152E-02,.2117883E-02,.2110593E-02,.2103282E-02,
     $.2095951E-02,.2088599E-02,.2081226E-02,.2073833E-02,.2066420E-02,
     $.2058986E-02,.2051531E-02,.2044057E-02,.2036562E-02,.2029047E-02,
     $.2021513E-02,.2013958E-02,.2006384E-02,.1998789E-02,.1991175E-02,
     $.1983542E-02,.1975888E-02,.1968216E-02,.1960524E-02,.1952812E-02,
     $.1945082E-02,.1937332E-02,.1929563E-02,.1921775E-02,.1913968E-02,
     $.1906142E-02,.1898298E-02,.1890434E-02,.1882552E-02,.1874652E-02/
      data (wp(i),i=1681,1720)/
     $.1866733E-02,.1858795E-02,.1850840E-02,.1842866E-02,.1834874E-02,
     $.1826863E-02,.1818835E-02,.1810789E-02,.1802725E-02,.1794643E-02,
     $.1786544E-02,.1778427E-02,.1770292E-02,.1762140E-02,.1753970E-02,
     $.1745784E-02,.1737580E-02,.1729359E-02,.1721120E-02,.1712865E-02,
     $.1704593E-02,.1696304E-02,.1687999E-02,.1679677E-02,.1671338E-02,
     $.1662983E-02,.1654611E-02,.1646223E-02,.1637819E-02,.1629399E-02,
     $.1620962E-02,.1612510E-02,.1604042E-02,.1595557E-02,.1587058E-02,
     $.1578542E-02,.1570011E-02,.1561465E-02,.1552903E-02,.1544325E-02/
      data (wp(i),i=1721,1760)/
     $.1535733E-02,.1527125E-02,.1518503E-02,.1509865E-02,.1501213E-02,
     $.1492545E-02,.1483863E-02,.1475167E-02,.1466456E-02,.1457730E-02,
     $.1448990E-02,.1440236E-02,.1431467E-02,.1422684E-02,.1413888E-02,
     $.1405077E-02,.1396253E-02,.1387414E-02,.1378563E-02,.1369697E-02,
     $.1360818E-02,.1351926E-02,.1343020E-02,.1334101E-02,.1325169E-02,
     $.1316224E-02,.1307265E-02,.1298294E-02,.1289310E-02,.1280314E-02,
     $.1271305E-02,.1262283E-02,.1253249E-02,.1244202E-02,.1235143E-02,
     $.1226072E-02,.1216989E-02,.1207894E-02,.1198787E-02,.1189668E-02/
      data (wp(i),i=1761,1800)/
     $.1180538E-02,.1171396E-02,.1162242E-02,.1153077E-02,.1143900E-02,
     $.1134712E-02,.1125513E-02,.1116303E-02,.1107082E-02,.1097850E-02,
     $.1088607E-02,.1079354E-02,.1070089E-02,.1060815E-02,.1051529E-02,
     $.1042234E-02,.1032928E-02,.1023612E-02,.1014286E-02,.1004950E-02,
     $.9956034E-03,.9862475E-03,.9768819E-03,.9675067E-03,.9581219E-03,
     $.9487276E-03,.9393240E-03,.9299112E-03,.9204892E-03,.9110581E-03,
     $.9016180E-03,.8921690E-03,.8827112E-03,.8732448E-03,.8637697E-03,
     $.8542861E-03,.8447941E-03,.8352937E-03,.8257851E-03,.8162684E-03/
      data (wp(i),i=1801,1840)/
     $.8067436E-03,.7972109E-03,.7876703E-03,.7781220E-03,.7685659E-03,
     $.7590023E-03,.7494312E-03,.7398528E-03,.7302670E-03,.7206740E-03,
     $.7110739E-03,.7014668E-03,.6918528E-03,.6822320E-03,.6726045E-03,
     $.6629703E-03,.6533295E-03,.6436824E-03,.6340289E-03,.6243691E-03,
     $.6147032E-03,.6050312E-03,.5953533E-03,.5856694E-03,.5759799E-03,
     $.5662846E-03,.5565837E-03,.5468774E-03,.5371657E-03,.5274486E-03,
     $.5177264E-03,.5079991E-03,.4982667E-03,.4885295E-03,.4787874E-03,
     $.4690406E-03,.4592892E-03,.4495332E-03,.4397729E-03,.4300082E-03/
      data (wp(i),i=1841,1880)/
     $.4202392E-03,.4104661E-03,.4006890E-03,.3909079E-03,.3811229E-03,
     $.3713342E-03,.3615418E-03,.3517459E-03,.3419465E-03,.3321437E-03,
     $.3223377E-03,.3125285E-03,.3027162E-03,.2929009E-03,.2830827E-03,
     $.2732617E-03,.2634380E-03,.2536118E-03,.2437830E-03,.2339519E-03,
     $.2241184E-03,.2142827E-03,.2044449E-03,.1946051E-03,.1847634E-03,
     $.1749198E-03,.1650745E-03,.1552276E-03,.1453792E-03,.1355293E-03,
     $.1256781E-03,.1158257E-03,.1059721E-03,.9611747E-04,.8626190E-04,
     $.7640548E-04,.6654832E-04,.5669051E-04,.4683217E-04,.3697344E-04/
      data (wp(i),i=1881,1883)/
     $.2711461E-04,.1725677E-04,.7413338E-05/

      CsTH = cos(TwoTH0 * 0.5/RAD)
      if (abs(CsTH) .lt. 1.0e-15) CsTH = 1.0e-15
      TTH = sin(TwoTH0 * 0.5/RAD)/CsTH
      CsTwoTH = cos(TwoTH0/RAD)
      SnTwoTH = sin(TwoTH0/RAD)
      ApB = S_L + D_L
      AmB = S_L - D_L
      ApB2 = ApB**2
      if (((S_L .ne. 0.0) .or. (D_L .ne. 0.0)) .and. Use_Asym) then
        tmp = sqrt(1.0 + AmB**2)*CsTwoTH
        if (abs(tmp) .gt. 1.0) then
          Einfl = acos(CsTwoTH)*RAD
        else
          Einfl = acos(tmp)*RAD
        endif
        tmp2 = 1.0 + ApB2
        tmp = sqrt(tmp2 ) * CsTwoTH

c If S_L or D_L are zero, set Einfl = 2theta

        if ((S_L .eq. 0.0) .or. (D_L .eq. 0.0)) Einfl = TwoTH0
        if (abs(tmp) .le. 1.0) then
          Emin = acos(tmp) * RAD
          tmp1 = tmp2 * (1.0 - tmp2 * CsTwoTH**2)
        else
          tmp1 = 0.0
          if (tmp .gt. 0.0) then
            Emin = 0.0
          else
            Emin = 180.0
          endif
        endif
        if ((tmp1 .gt. 0.0) .and. (abs(tmp) .le. 1.0)) then
          dEmindA = -(ApB * CsTwoTH/sqrt(tmp1))
        else
          dEmindA = 0.0
        endif
        ArrayNum = 1
        K = 400.0 * (TwoTH0 - Emin)   ! Calculate number of terms needed
C From LWF - number of terms must be such that the interval between 2phi(min) and 2theta
C is in steps no larger than 0.005
        stepsize = (twoth0-emin)/float(K)
        if(stepsize .gt. gamma/10.0) then
           stepsize = gamma/10.0
           K = (twoth0-emin)/stepsize
        endif
        do while ((ArrayNum .lt. 14) .and. (K .gt. NTERMS(ArrayNum)))
          ArrayNum = ArrayNum + 1
        enddo
        NGT = nterms(ArrayNum)              ! Save number of terms
        ngt2 = ngt / 2
c Clear terms needed for summations
        sumWG = 0.0
        sumWRG = 0.0
        sumWdGdA = 0.0
        sumWRdGdA = 0.0
        sumWdGdB = 0.0
        sumWRdGdB = 0.0
        sumWGdRd2t = 0.0
        sumWGdRdG = 0.0
        sumWGdRdE = 0.0
        sumWGdRdA = 0.0
        sumWGdRdB = 0.0
c Compute the convolution integral
        it = fstterm(arraynum)-ngt2
        do K = ngt2 , NGT
          delta = Emin + (TwoTH0 - Emin) * xp(K + it)
          dDeltadA = (1.0 - xp(k+it) ) * dEmindA
          sinDELTA = sin(Delta/RAD)
          cosDELTA = cos(Delta/RAD)
          if (abs(cosDELTA) .lt. 1.0e-15) cosDELTA = 1.0e-15
          RcosDELTA = 1.0 / cosDELTA
          tanDELTA = tan(Delta/RAD)
          tmp = cosDELTA**2 - CsTwoTH**2
          if (tmp .gt. 0.0) then
            tmp1 = sqrt(tmp)
            F = abs(CsTwoTH) / tmp1
            dFdA = cosDELTA * CsTwoTH * sinDELTA * dDELTAdA
     1         / (tmp1 * tmp1 * tmp1)
          else
            F = 0.0
            dFdA = 0.0
          endif
c  calculate G(Delta,2theta) , FCJ eq. 7a and 7b
          if ( abs(Delta - Emin) .gt. abs(Einfl - Emin)) then
            if (S_L .gt. D_L) then
!
! N.B. this is the only place where d()/dA <> d()/dB
!
              G = 2.0 * D_L * F * RcosDELTA
              dGdA = 2.0 * D_L * RcosDELTA * (dFdA +
     1                F*tanDELTA*dDELTAdA)
              dGdB = dGdA + 2.0 * F * RcosDELTA
            else
              G = 2.0 * S_L * F * RcosDELTA
              dGdB = 2.0 * S_L * RcosDELTA
     1                  *(dFdA + F * tanDELTA * dDELTAdA)
              dGdA = dGdB + 2.0 * F * RcosDELTA
            endif
          else
            G = (-1.0 + ApB * F) * RcosDELTA
            dGdA = RcosDELTA * (F - tanDELTA * dDELTAdA + ApB * dFdA
     1               + ApB * F * tanDELTA * dDELTAdA)
            dGdB = dGdA
          endif
          tmp = PsVoigt(TwoTh-DELTA+TwoTH0,TwoTH0,eta,Gamma,dPRdT
     1          ,dPRdG,dPRdE)
          sumWG = sumWG + wp(k+it) * G
          sumWRG = sumWRG + wp(k+it) * G * tmp
          sumWdGdA = sumWdGdA + wp(k+it) * dGdA
          sumWdGdB = sumWdGdB + wp(k+it) * dGdB
          sumWRdGdA = sumWRdGdA + wp(k+it) * dGdA * tmp
          sumWRdGdB = sumWRdGdB + wp(k+it) * dGdB * tmp
          sumWGdRd2t = sumWGdRd2t + wp(k+it) * G * dPRdT
          sumWGdRdG = sumWGdRdG + wp(k+it) * G * dPRdG
          sumWGdRdE = sumWGdRdE + wp(k+it) * G * dPRdE
          sumWGdRdA = sumWGdRdA + wp(k+it) * G * dPRdT * dDELTAdA * RAD
        enddo
        if (sumWG .eq. 0.0) sumWG = 1.0
        Profval = sumWRG / sumWG
        dPRdT = sumWGdRd2t/ sumWG
        dPRdG = sumWGdRdG / sumWG
        dPRdE = sumWGdRdE / sumWG
        dPRdS = (sumWRdGdA + sumWGdRdA) / sumWG - sumWRG *
     1          sumWdGdA / sumWG**2

        dPRdD = (sumWRdGdB + sumWGdRdA) / sumWG - sumWRG *
     1          sumWdGdB / sumWG**2
      else   ! here for no asymmetry }
        tmp = PsVoigt(TwoTH,TwoTH0,eta,Gamma,dPRdT,dPRdG,dPRdE)
        Profval = tmp
        dPRdS = 0.0
        dPRdD = 0.0
      endif
      return
      end


      real*4 function Gauss(Pos , Pos0 , Gamma , dGdT , dGdG )

c  Return value of Gaussian at 'Pos' for peak at 'Pos0' and 'Gamma'.
c  dGdT is derivative of G wrt Pos0.
c  dGdG is derivative of G wrt Gamma.

      implicit none
      real*4 Pos , Pos0 , Gamma , dGdT , dGdG
      real*4   c / 1.6651092/
      real*4  cg / 0.939437279/
      real*4  delp , temp

      delp = Pos - Pos0
      if (abs(delp)/Gamma .gt. 6) then
        Gauss = 0.0
        dGdT = 0.0
        dGdG = 0.0
      else
        temp = cg * exp(-(delp * c /Gamma)**2)/Gamma
        Gauss = temp
        dGdG = temp * ( -1.0 + 2.0 * (delp * c/Gamma)**2) / Gamma
        dGdT = 2.0 * c**2 * delp * temp/Gamma**2
      endif
      return
      end

      real*4 function Lorentz(Pos , Pos0 , Gamma , dLdT , dLdG )

c  Return value of Lorentzian at 'Pos' for peak at 'Pos0' and 'Gamma'.
c  dLdT is derivative of L wrt Pos0.
c  dLdG is derivative of L wrt Gamma.
      implicit none
      real*4 Pos , Pos0 , Gamma , dLdT , dLdG
      real*4 cl / 0.636619772/

      real*4  delp , denom

      delp = Pos - Pos0
      denom = 4.0 * delp**2 + Gamma**2
      Lorentz = cl * Gamma / denom
      dLdT = 8.0 * cl * Gamma * delp / denom**2
      dLdG = cl * (4.0 * delp**2 - Gamma**2) / denom**2
      return
      end
C
      real*4 function PsVoigt(TwoTH , TwoTH0 , eta , Gamma,
     1         dPRdT , dPRdG , dPRdE )
c
c   Returns value of Pseudo Voigt
c   Eta is the mixing coefficient between Gaussian and Lorentzian
c   Gamma is the FWHM
c   TwoTH is point at which to evaluate the profile
c   TwoTH0 is two theta value for peak
c   dPRdT is derivative of profile wrt TwoTH0
c   dPRdG is derivative of profile wrt Gamma
c   dPRdE is derivative of profile wrt Eta
      implicit none
      real*4 TwoTH , TwoTH0 , eta , Gamma
      real*4 dPRdT , dPRdG , dPRdE
      real*4  G,Gauss            ! Gaussian part
      real*4  L,Lorentz            ! Lorentzian part
      real*4 dGdT , dGdG , dLdT , dLdG
      G = Gauss(TwoTH , TwoTH0 , Gamma , dGdT , dGdG )
      L = Lorentz(TwoTH , TwoTH0 , Gamma , dLdT , dLdG )
      PsVoigt = Eta * L + (1.0 - Eta) * G
      dPRdT = Eta * dLdT + (1.0 - Eta) * dGdT
      dPRdG = Eta * dLdG + (1.0 - Eta) * dGdG
      dPRdE = L - G
      return
      end
C
C
C
C
##ENDPF
##PMA
C *** Version from JPW and JBF 21-Mar-2001  ***
C
C              P R O F I L E   R E F I N E M E N T   M A I N
C
C
C
C LEVEL 50      PROGRAM CELLSQ
      PROGRAM CELLSQ
C
C *** CELLSQ updated by JCM 4 Mar 92 ***
C
C ******************************************************************************
C
C                              C E L L S Q
C
C MAIN PROGRAM CELLSQ FOR AN EXAMPLE OF SIMPLE LEAST SQUARES REFINEMENT
C OF THE 6 CELL PARAMETER QUADRATIC PRODUCTS IN RECIPROCAL SPACE,
C A* B* C* D* E* F* AS IN RIETVELD PR, 2 THETA, (UP TO) 3 PARAMETERS IN THE
C EXPRESSION FOR THE TIME OF FLIGHT, TOF, BEING PKCN(1) AND PKCN(2) AND ZERO
C WHERE TOF = lambda*PCON*PKCN(1) + lambda squared*PKCN(2) + ZERO
C WHERE PCON = 252.777.
C This is a change from the original program which had d squared NOT lambda
C squared.  As no-one seemed ever to refine PKCN2 in CELLSQ, I am not changing
C the program to compensate for the new definition.  In the newer program,
C PKCN(1), PKCN(2), 2 THETA and ZERO have the same meanings as in PRofile LSQ.
C
C                      THE OBSERVATIONS ARE VALUES OF TOF.
C
C ******************************************************************************
C PROBLEM HAS 1 FAMILY, 3 GENERA.
C   GENUS 1 HAS (AS USUAL) NO NAME, AND 7 SPECIES, A*-F* AND THE2
C   GENUS 2 HAS PEAK CENTRE PARAMETERS
C   GENUS 3 HAS ZERO POINT PARAMETERS, IN FACT ONLY 1
C
C CALLS VARIOUS SPECIAL SUBROUTINES WITH "D2" IN NAME:
C         APSHD2   (APPLY SHIFTS)
C         NWIND2   (NEW INPUT CRYSTAL DATA)
C         CALCD2   (CALCULATE FUNCTION AND ITS DERIVATIVES)
C         PARSDS   (SET UP INITIAL PARAMETER FIX AND VARY INFO)
C         VARSD2   (RECORD WHICH PARAMETERS ARE ACTUALLY VARIED)
C         LDUMMY   DUMMY LOGICAL FUNCTION
C
C
C THE TRIAL CELL PARAMETERS ARE ON A C CARD.
C THE (USUALLY FIXED) VALUES OF THE 2 TIME PARAMETERS ARE ON AN L PKCN CARD.
C THE REFINABLE ZEROPOINT IS IN AN L ZERO CARD
C 2THETA IS ON AN L THE2 CARD
C AN L WGHT CARD DEFINES HOW THE DATA ARE WEIGHTED (C.F. TFLSQ ETC)
C THERE IS THE POSSIBILITY OF DRIVING IT USING I CARDS.
C ACCEPTABLE WORDS ON THE I CARD ARE:
C   NCYC    NO. OF CYCLES
C   CYC1    SERIAL NO OF FIRST CYCLE
C   MCOR    MAXIMUM PERCENTAGE CORRELATION TO PRINT
C   PRIN    HOW OFTEN TO PRINT OBS/CALC LIST
C
      CHARACTER *4 ID2WRD(10)
      LOGICAL DFLTD2,ONCARD,PRINT,PRNCYC,ISPABS
      EXTERNAL DFLTD2,PARRUN,VARSD2
      DIMENSION ALSQ(70),ID2SPC(3,10),K(3),H(3)
C
/CARDRC/
/NEWOLD/
/IOUNIT/
/PHASE/
/OBSCAL/
/PRBLEM/
/PRZERO/
/REFINE/
/SCRACH/
/SOURCE/
C
      DATA ID2WRD/'A*','B*','C*','D*','E*','F*',
     & 'PKCN','ZERO','THE2','CELL'/
      DATA ID2SPC/1,1,1,  1,1,2,  1,1,3,  1,1,4,  1,1,5,
     & 1,1,6, 1,2,0, 1,3,0, 1,1,7, -4,0,0/
C
C IF MAKE MORE PARAMETERS, INCREASE DIMENSION OF ALSQ AND MATSZ
      MATSZ=70
C
      CALL PREFIN('CELLSQ')
C
C SET UP PROBLEM:
C JUST ONE FAMILY
      NFAM=1
C THREE GENERA IN FAMILY 1
      NGENS(1)=3
C (UP TO) 7 SPECIES PER GENUS IN FAM 1
      NSPC(1)=7
C SPECIES TYPES OF GENERA IN F1 (0=NONE, -VE=INTEGERS, +VE=NAMES)
C I.E., WHAT WE ACTUALLY CALL THE SPECIES MEMBERS ON L VARY CARDS ETC.
      LF1SP(1)=7
      LF1SP(2)=-2
      LF1SP(3)=-1
C
C WORDS RELEVANT TO THIS PROBLEM FROM DATA INTO COMMON:
      CALL LSETUP(11,ID2SPC,ID2WRD)
C
C REQUEST OBSERVATIONS FILE:
      MESSAG='Time of flight observations'
      LUNI=NOPFIL(11)
C
C READ SYMMETRY AND CELL:
      CALL SYMOP
      CALL OPSYM(1)
      CALL RECIP
C
      CALL MESS(LPT,3,
     & ' LSQ Refinement of cell and instrument parameters - TOF data')
C
C READ I CARD IF PRESENT:
      IF (INREAD(9) .GT. 0) CALL INPUTI
      CALL IICD1
C
C READ "L THE2" CARD FOR 2 THETA IN DEGREES:
      CALL THETA2(1)
C
C READ L PKCN CARD WITH 2 COEFFICIENTS:
      CALL FINDCD('L','PKCN',4,K,L)
      IF (L .LE. 0) THEN
        CALL ERRMES(2,0,
     & 'L PKCN card with initial values for tof parameters')
      ELSE
        CALL PCTF01(1)
      ENDIF
C
C READ L ZERO CARD
      CALL FINDCD('L','ZERO',4,0,L)
      IF (L .EQ. 0) THEN
        CALL MESS(LPT,0,
     &  ' No L ZERO card - zeropoint set to 0 microseconds ')
        ZEROSP(1,JPHASE,JSOURC)=0.
      ELSE
        CALL ZEROPR(1)
      ENDIF
C
C READ L WGHT CARD
      CALL WGHTLS(1,0.)
C
C COLLECT FIX AND VARY INFO:
      CALL PARSDS
C
C MAKE VARIABLES AND BASIC VARIABLES, ONCE FOR WHOLE JOB:
      CALL VARMAK(DFLTD2,PARRUN,VARSD2,LDUMMY)
C
C CYCLE:
      DONE=.FALSE.
      DO 1 ICYC=NCYC1,LASTCY
C IS PRINTING OF OBS AND CALC LIST REQUESTED THIS CYCLE?
      PRINT=PRNCYC(1)
      IF (PRINT) THEN
        CALL MESS(LPT,2,'Observed and calculated values :')
        CALL MESS(LPT,0,'   h   k   l       Obs TOF          Calc TOF'//
     &  '     Diff        Error')
        CALL NEWLIN(LPT)
      ENDIF
C
C INITIALISE R FACTOR SUMS:
      CALL RFACS(1)
C
C SET UP TRIANGULAR MATRIX POINTERS, CLEAR OUT LSQ MATRIX AND RHS:
      CALL MATSET(ALSQ,MATSZ)
C
C COUNT USED OBSERVATIONS (THERE IS NOT AT PRESENT ANY WAY OF NOT USING ONE)
      NOBS=0
   5  READ(LUNI,1000,END=3) ICARD
1000  FORMAT (A80)
C READ H,K,L
      IPT=1
      DO 19 I=1,3
  19  CALL RDINTG(K(I),IPT,IPT,80,IER)
C READ OBS, DOBS
      CALL RDREAL(OBS,IPT,IPT,80,IER)
      CALL RDREAL(DOBS,IPT,IPT,80,IER)
C
      CALL WGHTLS(2,OBS)
C
      CALL INDFLO(H,K)
      IF (ISPABS(H)) WRITE(LPT,3000) K
3000  FORMAT(/' WARNING ** reflection',3I5,' is a space group absence')
C
      CALL CALCD2(H)
C CALCD2 FORMS GCALC,  PUTS DG/DV INTO DERIVV FOR ALL VARIABLES, AND SETS UP
C ALL REQUIRED QUANTITIES IN OBSCAL FOR SUBSEQUENT CALLS OF MATTOT AND RFACS
C
C MAKE BASIC VARIABLE DERIVATIVES FROM VARIABLE DERIVATIVES:
      CALL RELATE
C
      DIFF = OBS - GCALC
      SQRTWT=SQRT(WT)
      WDIFF=SQRTWT*DIFF
C
      IF (PRINT) WRITE (LPT,2003) K,OBS,GCALC,DIFF,DOBS
2003  FORMAT (' ',3I4,2(5X,F12.2),F12.2,F11.5)
C
C ADD IN TO R FACTORS:
      CALL RFACS(2)
C
C ADD DERIVATIVES IN TO LSQ MATRIX:
      CALL MATTOT(ALSQ,MATSZ)
      NOBS=NOBS+1
C NEXT OBSERVATION:
      GO TO 5
C
C HERE ON NO MORE OBSERVATIONS - REWIND OBSERVATIONS FILE AND PRINT R FACTORS:
   3  REWIND LUNI
      CALL RFACS(3)
C
C INVERT MATRIX, CALCULATE SHIFTS AND ESD'S; APPLY AND PRINT:
      CALL MATINV(ALSQ,MATSZ)
      CALL MATSHF(ALSQ,MATSZ)
      CALL APSHD2
C PRODUCE NEW INPUT DATA FILE ON PENULTIMATE CYCLE:
      IF (DONE) GO TO 39
      DONE=(AMAXSH.LT.CONV .OR. ICYC.EQ.LASTCY-1 .OR. NCYC.EQ.1)
C REQUEST NAME FOR NEW CRYSTAL DATA:
      IF (DONE) CALL NWIND2
   1  CONTINUE
C
  39  CALL CELSDP(ALSQ,MATSZ)
C PRINT CORRELATION MATRIX:
      CALL MATCOR(ALSQ,MATSZ)
      STOP
      END
C
C
C
C
C LEVEL 50      PROGRAM FORTY1
      PROGRAM FORTY1
C
C *** FORTY1 mods by PJB C105 Apr-2001 ***
C
CX
CC 19B
CH Multi-phase, multi-source control of LSQ for non-magnetic applications
C
      LOGICAL DFLTPR,ONCARD
      EXTERNAL PCXX,PFXX,DUMMY,LDUMMY,RUNPAR,DFLTPR,VARSPR
%      DIMENSION ALSQ(%MATS%)
%      DIMENSION ISCR(2),DETEMP(%VVAR%),YCALPH(%PHAS%)
/CARDRC/
/DERVAR/
/GLOBAL/
/GRDBCK/
/IOUNIT/
/NEWOLD/
/OBSCAL/
/PHASE/
/PRPKFN/
/PRSAVE/
/PRSTAT/
/REFINE/
/REFIPR/
/REFLNS/
/SLAKDA/
/SLKGEO/
/SOURCE/
C
%      MATSZ=%MATS%
      CALL PREFAS('FORTY1')
** DO THIS FOR EACH PHASE:
C DISCOVER WHETHER SLACK CONSTRAINTS:
      CALL GEOMIN(0)
      MAG=.FALSE.
      MULFAS=.TRUE.
C
C INITIALISE AND READ IN PHASE 0 L CARDS:
      CALL RDPHA0(PCXX,PFXX)
C
C CYCLE OVER PHASES READING STRUCTURE PARAMETERS THEN PROFILE PARS:
      DO 13 JPHASE =1,NPHASE
      CALL LOGPHA(JPHASE)
C ARRANGE TO ADDRESS THE CORRECT CRYSTAL DATA FILE:
      IF (JPHASE .NE. 1) THEN
        CALL VCSWOP(INREA(1,JPHASE),INREA(1,1),26)
        CALL VCSWOP(ICDN(1,JPHASE),ICDN(1,1),26)
      ENDIF
C THE STRUCTURE COMMON IS ASSUMED TO BE OVERWRITTEN EACH TIME
C SO DOES NOT NEED SPECIAL CLEARING:
      IF (MULFAS) THEN
        CALL WRLINE(2,60,'*',0)
        WRITE (LPT,2001) JPHASE
2001    FORMAT (//21X,'*** READING PHASE ',I3,' ***')
      ENDIF
      IPHASE=JPHASE
      PHMAG(JPHASE)= .FALSE.
      CALL SETPR(PCXX,PFXX,DUMMY)
C MAKE LIST OF REFLECTION INDICES:
      CALL INRFPR(PCXX,PFXX)
C
C WRITE OUT STRUCTURE - A SPECIAL INITIAL ENTRY:
      CALL PHMOVE(-2,JPHASE)
  13  CONTINUE
C
C SCAN BACK THROUGH CDFS SETTING UP PARAMETERS:
      DO 12 JPHASE=NPHASE,1,-1
C GET RELEVANT STRUCTURE AND PROFILE PARS BACK:
      CALL PHMOVE(1,JPHASE)
      CALL PARSPR(LDUMMY)
      IF (JPHASE .GT. 1) THEN
        CALL VCSWOP(INREA(1,JPHASE),INREA(1,1),26)
        CALL VCSWOP(ICDN(1,JPHASE),ICDN(1,1),26)
      ENDIF
  12  CONTINUE
C
C READ OBS DATA AND SEND OUT TO TEMPORARY UNIT FOR REINPUT EACH CYCLE
      CALL INOBPR(ISCR,NSTART,PCXX,PFXX)
C
      DONE=.FALSE.
      DO 1 ICYC=NCYC1,LASTCY
      WRITE(ITO,2000) ICYC
2000  FORMAT(' >>> Starting cycle ',I4)
      IF (PRECYC .AND. ICYC .NE. NCYC1) THEN
        SIMUL=.FALSE.
        PRECYC=.FALSE.
      ENDIF
C
C IF NEEDED, CAIL/SAPS/APES PROCESSING ON EACH CYCLE:
C TRY TO GET AWAY WITHOUT A PHASE SWOP? - AND SORT OUT SOURCES LATER:
      DO 11 JSOURC=1,NSOURC
      DO 11 JPHASE=1,NPHASE
      CALL LOGPHA(JPHASE)
      IF (.NOT. RIET) CALL FAM4PR(2,PCXX,PFXX)
  11  CONTINUE
C
      CALL VARMAK(DFLTPR,RUNPAR,VARSPR,LDUMMY)
** this won't do - need varsmg if magnetic
** AND AN ALL PHASE LOOP HERE:
C IF ANY SLACK CONSTRAINTS, SET UP:
      CALL GEOMCO(1)
      CALL LOGSET
C
C INITIALISE R FACTOR SUMS:
      CALL RFACS(1)
      CALL RFACPR(1,PCXX)
C
C SET UP POINTERS IN TRIANGULAR MATRIX AND CLEAR OUT LSQ MATRIX AND RHS
      CALL MATSET(ALSQ,MATSZ)
C
C NSTART=THE UNIT ON WHICH TO FIND OBS DATA
      NIN=NSTART
      NOUT=3-NIN
      REWIND ISCR(NIN)
      IF (MULFAS) REWIND ISCR(NOUT)
C
C START A CYCLE OVER PHASES, GETTING REQUIRED STRUCTURE & PROFILE
C INTO STORE:
C
      JPHASE=0
  20  JPHASE=JPHASE+1
      CALL PHMOVE(1,JPHASE)
C
C INITIALISE R FACTOR QUANTITIES DEPENDING ON PHASE:
      CALL RFACPR(11,PCXX)
C
C CLEAR POINTERS INDICATING SAVED FC CALCULATIONS FROM ONE INTENSITY TO THE
C NEXT:
%      CALL JGMZER(KPOINT,1,%OLAP%)
C
C START READING OBS:
      NOBS=0
      JSOURC=1
      CALL LOGSOU(1)
      NOBTOT=0
C INOBPR HAS TURNED THE VARIOUS FORMATS FOR INPUT INTO ONE, AND DECIDED WHICH
C REFLECTIONS CONTRIBUTE.
C
C NEW ENTRY TO ARRANGE INTERPOLATION FOR SPEED IF APPROPRIATE:
      CALL PFXX(3)
   2  NOBTOT=NOBTOT+1
      IF (NOBTOT .GE. NSOBS(JSOURC)) THEN
C IF NECESSARY MOVE TO NEXT SOURCE:
        IF (JSOURC .GE. NSOURC) GO TO 3
        JSOURC=JSOURC+1
        CALL LOGSOU(JSOURC)
      ENDIF
C
C THIS READS FROM ISCR(1) OR (2), AND WRITES TO THE OTHER ONE:
      IF (JPHASE .EQ. 1) THEN
        READ (ISCR(NIN),END=3) ARGI,OBS,DOBS,WT,ICODE,(KMI(I),
     &  KMA(I),I=1,NPHASE)
      ELSE
        READ (ISCR(NIN),END=3) ARGI,OBS,DOBS,WT,ICODE,(KMI(I),
     &  KMA(I),I=1,NPHASE),YCALC,(DETEMP(I),I=1,LVARV)
      ENDIF
      KMIN=KMI(JPHASE)
      KMAX=KMA(JPHASE)
C
C NK REMAINS ZERO IF NONE OF THE PHASES HAS CONTRIBUTIONG REFLECTIONS:
      NK=0
      DO 42 I=1,NPHASE
  42  NK=NK+KMA(I)
C
C CLEAR ALL PARTS OF YCALC, AND DERIVV FOR DERIVATIVES OF YPEAK:
C (DONE HERE IN CASE NO CONTRIBUTING REFLNS)
      YPEAK=0.
      YBACK=0.
      IF (LVARV .GT. 0 .AND. .NOT. SIMUL) CALL GMZER(DERIVV,1,LVARV)
C
C DEAL WITH CASE YCALC=0 (EITHER BY BEING EXCLUDED OR BY HAVING NO CONTRIBUTING
C REFLECTIONS) - NB ICODE IS NON-ZERO FOR DO **NOT** USE:
      IF ((NK.EQ.0 .AND. .NOT.ZBAKIN) .OR. ICODE.NE.0) THEN
        YCALC=0.
        IF (JPHASE .EQ. NPHASE) THEN
          CALL RFACPR(5,PCXX)
        ELSE
C WRITE RECORD BACK TO OTHER SCRATCH UNIT:
          YCALPH(JPHASE)=YCALC
          WRITE (ISCR(NOUT)) ARGI,OBS,DOBS,WT,
     &    ICODE,(KMI(I),KMA(I),I=1,NPHASE),YCALC,(DERIVV(I),I=1,LVARV)
        ENDIF
        GO TO 2
      ENDIF
C
C CALCULATE FUNCTI0N TO MATCH OBSERVED, AND ITS DERIVATIVES, AND DO SOME
C STATISTICS:
      IF (KMAX .NE. 0) CALL CALPR(PCXX,PFXX)
C
C RFACTOR QUANTITIES NEEDING YPEAK:
      CALL RFACPR(12,PCXX)
      IF (JPHASE .EQ. 1) THEN
        YCALC=YPEAK
      ELSE
        YCALC=YCALC+YPEAK
        CALL GMADD(DERIVV,DETEMP,DERIVV,1,LVARV)
      ENDIF
C
      IF (JPHASE .NE. NPHASE) THEN
C NOW WRITE RECORD BACK TO OTHER SCRATCH UNIT:
        YCALPH(JPHASE)=YCALC
        WRITE (ISCR(NOUT)) ARGI,OBS,DOBS,WT,ICODE,(KMI(I),
     &  KMA(I),I=1,NPHASE),YCALC,(DERIVV(I),I=1,LVARV)
      ELSE
C IF LAST PHASE GET BACKGROUND VALUE AND DERIVATIVES:
        CALL BACKPR(2)
        YCALC=YCALC+YBACK
C YCALC, YPEAK, YBACK AND DERIVV ARE NOW READY TO BEHAVE AS SINGLE PHASE:
C
C MAKE DERIVATIVES WRT BASIC VARIABLES FROM THOSE WRT VARIABLES:
        CALL RELATE
C
C DIFFERENCE:
        IF (SIMUL) OBS=YCALC
        DIFF = OBS - YCALC
C FROM WEIGHT GET SQRTWT AND WDIFF INTO COMMON:
        CALL WGHTLS(3,ARGI)
C
C ADD IN TO R FACTORS:
        CALL RFACPR(2,PCXX)
C
C ADD DERIVATIVES IN TO LSQ MATRIX:
        IF (CAIL) THEN
          CALL MATTOS(ALSQ,MATSZ)
         ELSE
          CALL MATTOT(ALSQ,MATSZ)
        ENDIF
        NOBS=NOBS+1
      ENDIF
C NEXT OBSERVATION FOR THIS PHASE:
      GO TO 2
C
C END OF ONE PHASE - REWIND UNITS AND FLIP:
   3  REWIND ISCR(NIN)
      IF (MULFAS) REWIND ISCR(NOUT)
      CALL FLIP(NIN,NOUT)
C RFACTORS FOR PHASE DEPENDENT PARTS:
      CALL RFACPR(13,PCXX)
C
C SLACK CONSTRAINTS - FIRST GEOMETRICAL:
      CALL GEOMLS(ALSQ,MATSZ)
C THEN PAWLEY-TYPE:
      CALL PAWLS(ALSQ,MATSZ,3)
C COMBINED CHI-SQUARED:
      CALL RFACS(6)
C NEXT PHASE:
      IF (JPHASE .LT. NPHASE) GO TO 20
C
C HERE ON ALL PHASES DEALT WITH - PRINT R FACTORS:
      CALL RFACPR(3,PCXX)
C
C INVERT MATRIX:
      CALL MATINV(ALSQ,MATSZ)
C CALCULATE SHIFTS AND ESD'S:
      CALL MATSHF(ALSQ,MATSZ)
C APPLY SHIFTS AND PRINT:
      CALL APSHPR(ALSQ,MATSZ,PCXX,PFXX,LDUMMY)
C
C OUTPUT NEW CRYSTAL DATA FOR PENULTIMATE CYCLE:
      IF (DONE) GO TO 39
      DONE=(AMAXSH.LT.CONV .OR. ICYC.EQ.LASTCY-1 .OR. NCYC.EQ.1)
      IF (DONE) CALL NWINPR(PCXX,PFXX,L)
   1  CONTINUE
C
C PRINT CORRELATION MATRIX:
  39  CALL MATCOR(ALSQ,MATSZ)
C
C OUTPUT H,K,L LIST IF REQUIRED:
      CALL HKLOUT(ALSQ,MATSZ)
C IF CAIL, OUTPUT EIGENVALUES & EIGENVECTORS IF REQUIRED BY "I PREE"
      CALL EIGEN(ALSQ,MATSZ)
 100  STOP
      END
C
C
C
C
C LEVEL 50      PROGRAM CN11LM
      PROGRAM CN11LM
C
C *** CN11LM by JCM 5 May 89 ***
C
C ******************************************************************************
C
C                            C N 1 1 L M
C
C ******************************************************************************
C
C MAIN PROGRAM FOR CN LSQ WITH CENTRE AND PEAK FUNCTIONS 1 1
C           AND ALLOWANCE FOR MAGNETIC STRUCTURE FACTORS
C
C DIMENSION OF ALSQ BELOW, AND SETTING OF MATSZ, TO BE ALTERED TO BE SOMETHING
C A LITTLE LARGER THAN N*(N+3)/2 WHERE THERE WILL BE N BASIC VARIABLES
C
      EXTERNAL PCCN01,PFCN01,DOMAG,CALPRM
%      DIMENSION ALSQ(%MATS%)
%      MATSZ=%MATS%
      CALL FORTY('CN11LM',ALSQ,MATSZ,PCCN01,PFCN01,DOMAG,CALPRM)
      STOP
      END
C
C
C
C
C LEVEL 50      PROGRAM CN11LS
      PROGRAM CN11LS
C
C *** CN11LS by JCM 11 Aug 88 ***
C
C ******************************************************************************
C
C                            C N 1 1 L S
C
C ******************************************************************************
C
C MAIN PROGRAM FOR CN LSQ WITH CENTRE AND PEAK FUNCTIONS 1 1
C
C DIMENSION OF ALSQ BELOW, AND SETTING OF MATSZ, TO BE ALTERED TO BE SOMETHING
C A LITTLE LARGER THAN N*(N+3)/2 WHERE THERE WILL BE N BASIC VARIABLES
C
      EXTERNAL PCCN01,PFCN01,DUMMY,CALPR
%      DIMENSION ALSQ(%MATS%)
%      MATSZ=%MATS%
      CALL FORTY('CN11LS',ALSQ,MATSZ,PCCN01,PFCN01,DUMMY,CALPR)
      STOP
      END
C
C
C
C
C LEVEL 50      PROGRAM CN12LM
      PROGRAM CN12LM
C
C *** CN12LM by JCM 5 May 89 ***
C
C ******************************************************************************
C
C                            C N 1 2 L M
C
C ******************************************************************************
C
C MAIN PROGRAM FOR CN LSQ WITH CENTRE AND PEAK FUNCTIONS 1 2
C           AND ALLOWANCE FOR MAGNETIC STRUCTURE FACTORS
C
C DIMENSION OF ALSQ BELOW, AND SETTING OF MATSZ, TO BE ALTERED TO BE SOMETHING
C A LITTLE LARGER THAN N*(N+3)/2 WHERE THERE WILL BE N BASIC VARIABLES
C
      EXTERNAL PCCN01,PFCN02,DOMAG,CALPRM
%      DIMENSION ALSQ(%MATS%)
%      MATSZ=%MATS%
      CALL FORTY('CN12LM',ALSQ,MATSZ,PCCN01,PFCN02,DOMAG,CALPRM)
      STOP
      END
C
C
C
C
C LEVEL 50      PROGRAM CN12LS
      PROGRAM CN12LS
C
C *** CN12LS by JCM 11 Aug 88 ***
C
C ******************************************************************************
C
C                            C N 1 2 L S
C
C ******************************************************************************
C
C MAIN PROGRAM FOR CN LSQ WITH CENTRE AND PEAK FUNCTIONS 1 2
C
C DIMENSION OF ALSQ BELOW, AND SETTING OF MATSZ, TO BE ALTERED TO BE SOMETHING
C A LITTLE LARGER THAN N*(N+3)/2 WHERE THERE WILL BE N BASIC VARIABLES
C
      EXTERNAL PCCN01,PFCN02,DUMMY,CALPR
%      DIMENSION ALSQ(%MATS%)
%      MATSZ=%MATS%
      CALL FORTY('CN12LS',ALSQ,MATSZ,PCCN01,PFCN02,DUMMY,CALPR)
      STOP
      END
C
C
C
C
C LEVEL 50      PROGRAM LX11LM
      PROGRAM LX11LM
C
C *** LX11LM by JCM 5 May 89 ***
C
C ******************************************************************************
C
C                            L X 1 1 L M
C
C ******************************************************************************
C
C MAIN PROGRAM FOR LX LSQ WITH CENTRE AND PEAK FUNCTIONS 1 1
C           AND ALLOWANCE FOR MAGNETIC STRUCTURE FACTORS
C
C DIMENSION OF ALSQ BELOW, AND SETTING OF MATSZ, TO BE ALTERED TO BE SOMETHING
C A LITTLE LARGER THAN N*(N+3)/2 WHERE THERE WILL BE N BASIC VARIABLES
C
      EXTERNAL PCLX01,PFLX01,DOMAG,CALPRM
%      DIMENSION ALSQ(%MATS%)
%      MATSZ=%MATS%
      CALL FORTY('LX11LM',ALSQ,MATSZ,PCLX01,PFLX01,DOMAG,CALPRM)
      STOP
      END
C
C
C
C
C LEVEL 50      PROGRAM LX11LS
      PROGRAM LX11LS
C
C *** LX11LS by JCM 11 Aug 88 ***
C
C ******************************************************************************
C
C                            L X 1 1 L S
C
C ******************************************************************************
C
C MAIN PROGRAM FOR LX LSQ WITH CENTRE AND PEAK FUNCTIONS 1 1
C
C DIMENSION OF ALSQ BELOW, AND SETTING OF MATSZ, TO BE ALTERED TO BE SOMETHING
C A LITTLE LARGER THAN N*(N+3)/2 WHERE THERE WILL BE N BASIC VARIABLES
C
      EXTERNAL PCLX01,PFLX01,DUMMY,CALPR
%      DIMENSION ALSQ(%MATS%)
%      MATSZ=%MATS%
      CALL FORTY('LX11LS',ALSQ,MATSZ,PCLX01,PFLX01,DUMMY,CALPR)
      STOP
      END
C
C
C
C
C LEVEL 50      PROGRAM LX12LM
      PROGRAM LX12LM
C
C *** LX12LM by JCM 5 May 89 ***
C
C ******************************************************************************
C
C                            L X 1 2 L M
C
C ******************************************************************************
C
C MAIN PROGRAM FOR LX LSQ WITH CENTRE AND PEAK FUNCTIONS 1 2
C           AND ALLOWANCE FOR MAGNETIC STRUCTURE FACTORS
C
C DIMENSION OF ALSQ BELOW, AND SETTING OF MATSZ, TO BE ALTERED TO BE SOMETHING
C A LITTLE LARGER THAN N*(N+3)/2 WHERE THERE WILL BE N BASIC VARIABLES
C
      EXTERNAL PCLX01,PFLX02,DOMAG,CALPRM
%      DIMENSION ALSQ(%MATS%)
%      MATSZ=%MATS%
      CALL FORTY('LX12LM',ALSQ,MATSZ,PCLX01,PFLX02,DOMAG,CALPRM)
      STOP
      END
C
C
C
C
C LEVEL 50      PROGRAM LX12LS
      PROGRAM LX12LS
C
C *** LX12LS by JCM 11 Aug 88 ***
C
C ******************************************************************************
C
C                            L X 1 2 L S
C
C ******************************************************************************
C
C MAIN PROGRAM FOR LX LSQ WITH CENTRE AND PEAK FUNCTIONS 1 2
C
C DIMENSION OF ALSQ BELOW, AND SETTING OF MATSZ, TO BE ALTERED TO BE SOMETHING
C A LITTLE LARGER THAN N*(N+3)/2 WHERE THERE WILL BE N BASIC VARIABLES
C
      EXTERNAL PCLX01,PFLX02,DUMMY,CALPR
%      DIMENSION ALSQ(%MATS%)
%      MATSZ=%MATS%
      CALL FORTY('LX12LS',ALSQ,MATSZ,PCLX01,PFLX02,DUMMY,CALPR)
      STOP
      END
C
C
C
C
C LEVEL 50      PROGRAM MAGTIC

      PROGRAM MAGTIC
C
C *****************************************************************************
C
C                           M A G T I C
C
C             WRITES TIC FILE IN ASCII FOR GENIE DISPLAY
C
C ****************************************************************************
C
C    *** MAGTIC by JBF June 95 ***
CH Program to include magnetic reflections (TIC outputs in
CH    GENIE format and does not include magnetic reflections).
C
/REFIPR/
C      READ CRYSTAL FILE
      CALL PREFIN('MAGTIC')
      TIC=.TRUE.
      CALL PTICN
      CALL OUTTIC
      STOP
      END
C
C
C
C
C LEVEL 50      PROGRAM PICTIC
      PROGRAM PICTIC
C
C *****************************************************************************
C
C                            P I C T I C
C
C       READS .PRO FILE FROM REFINEMENT AND OUTPUTS GENIE FILES
C
C *****************************************************************************
C
/FOCDAT/
/IOUNIT/
/SCRACH/
C
%      MPTS=%PTIC%
C      READ CRYSTAL FILE
      CALL PREFIN('PICTIC')
      MESSAG='Profile file'
      NAMFIL='.PRO'
      INFIL=NOPFIL(111)
      CALL PTIC
C
C READ .PRO FILE DATA:
      READ(INFIL,*,ERR=1,END=1)(TDATA(I),BACK(I),OBSDAT(I),
     +                         CALDAT(I),ERR(I),I=1,MPTS)
      WRITE(LPT,2000) MPTS
      WRITE(ITO,2000) MPTS
2000  FORMAT (/' ONLY THE FIRST',I7,' POINTS HAVE BEEN READ')
      I=MPTS+1
   1  NPT=I-1
      WRITE(LPT,2001) NPT
      WRITE(ITO,2001) NPT
2001  FORMAT (/1X,I7,' POINTS HAVE BEEN READ')
      CALL CLOFIL(INFIL)
C
      DO 2 I=1,NPT
        IF (CALDAT(I) .EQ. 0.) THEN
          DIFDTI= 0.
        ELSE
          DIFDTI=OBSDAT(I)-CALDAT(I)
        ENDIF
        IF (ERR(I).EQ.0.) THEN
          STADAT(I)=0.
        ELSE
          STADAT(I)=DIFDTI/ERR(I)
        ENDIF
   2  CONTINUE
C
      XMN=TDATA(1)
      XMX=TDATA(NPT)
      CALL LIMITS(OBSDAT,NPT,NCYMIN,NCYMAX,YMN,YMX)
C
      YRANGE=YMX-YMN
C NEED 1 MORE TIME CHANNEL BOUNDARY THAN TIME CHANNEL:
      NPT=NPT-1
C
      CALL WRIPIC
      CALL WRITIC
      STOP
      END
C
C
C
C
C LEVEL 50      PROGRAM PRODD
      PROGRAM PRODD
C
C *** PRODD by JPW/JBF Sept 1999 ***
C{P}rofile {R}efinement {O}f {D}iffraction {D}ata
C Multihistogram, multiphase refinement with magnetism present
C
CX
CC 19B
CH Multi-phase, multi-source control of LSQ with magnetism present.
CD Individual phase profiles stored as well as the sum.
C
      REAL *4 TIME1,DELTA
      CHARACTER *6 G77NAM
      LOGICAL DFLTPR,ONCARD
      EXTERNAL PCXX,PFXX,DUMMY,DOMAG,RUNPAR,DFLTPR,VARSAL,MAGCNL,LDUMMY
%      DIMENSION ALSQ(%MATS%)
%      DIMENSION ISCR(2),DETEMP(%VVAR%),YPKPH(%PHAS%)
/CARDRC/
/DERVAR/
/GLOBAL/
/GRDBCK/
/IOUNIT/
/NEWOLD/
/OBSCAL/
/PHASE/
/PRPKFN/
/PRSAVE/
/PRSTAT/
/REFINE/
/REFIPR/
/REFLNS/
/SLAKDA/
/SLKGEO/
/SOURCE/
%      MATSZ=%MATS%
      G77NAM='PRODD'
      CALL PREFAS(G77NAM)
      WRITE(ITO,*)'This is PRODD version 01.03.16'
** DO THIS FOR EACH PHASE:
C DISCOVER WHETHER SLACK CONSTRAINTS:
      CALL GEOMIN(0)
      MAG=.FALSE.
C
C INITIALISE AND READ IN PHASE 0 L CARDS:
      CALL RDPHA0(PCXX,PFXX)
C
C CYCLE OVER PHASES READING STRUCTURE PARAMETERS THEN PROFILE PARS:
      DO 13 JPHASE =1,NPHASE
      CALL LOGPHA(JPHASE)
C ARRANGE TO ADDRESS THE CORRECT CRYSTAL DATA FILE:
      IF (JPHASE .NE. 1) THEN
        CALL VCSWOP(INREA(1,JPHASE),INREA(1,1),26)
        CALL VCSWOP(ICDN(1,JPHASE),ICDN(1,1),26)
      ENDIF
C THE STRUCTURE COMMON IS ASSUMED TO BE OVERWRITTEN EACH TIME
C SO DOES NOT NEED SPECIAL CLEARING:
      IF (MULFAS) THEN
        CALL WRLINE(2,60,'*',0)
        WRITE (LPT,2001) JPHASE
2001    FORMAT (//21X,'*** READING PHASE ',I3,' ***')
      ENDIF
      IPHASE=JPHASE
C FIND OUT IF PHASE IS MAGNETIC IE, Q CARDS PRESENT: READ Q PROP CARD
      CALL FINDCD('Q','PROP',4,0,LCD)
      IF (LCD.GE.0) THEN
        PHMAG(IPHASE) = .TRUE.
        CALL SETPR(PCXX,PFXX,DOMAG)
      ELSE
        PHMAG(IPHASE) = .FALSE.
        CALL SETPR(PCXX,PFXX,DUMMY)
      ENDIF
      JSS=JSOURC
C MAKE LIST OF REFLECTION INDICES:
      DO 15 JSR=1,NSOURC
        JSOURC=JSR
        CALL INRFPR(PCXX,PFXX)
  15  CONTINUE
C
C WRITE OUT STRUCTURE - A SPECIAL INITIAL ENTRY:
      CALL PHMOVE(-2,JPHASE)
  13  CONTINUE
C
C SCAN BACK THROUGH CDFS SETTING UP PARAMETERS:
      DO 12 JPHASE=NPHASE,1,-1
C GET RELEVANT STRUCTURE AND PROFILE PARS BACK:
      CALL PHMOVE(1,JPHASE)
      IF (PHMAG(JPHASE)) THEN
        CALL PARSPR(MAGCNL)
      ELSE
        CALL PARSPR(DUMMY)
      ENDIF
C 89.12 Add so as not to lose spind deriv's
      CALL PHMOVE(-1,JPHASE)
      IF (JPHASE .GT. 1) THEN
        CALL VCSWOP(INREA(1,JPHASE),INREA(1,1),26)
        CALL VCSWOP(ICDN(1,JPHASE),ICDN(1,1),26)
      ENDIF
  12  CONTINUE
      JSOURC=JSS
C
C READ OBS DATA AND SEND OUT TO TEMPORARY UNIT FOR REINPUT EACH CYCLE
      CALL INOBPR(ISCR,NSTART,PCXX,PFXX)
C
      DONE=.FALSE.
      DO 1 ICYC=NCYC1,LASTCY
      WRITE(ITO,2000) ICYC
2000  FORMAT(' >>> Starting cycle ',I4)
C
C START OF TIMED CYCLE
      TIME1=SECNDS(0.0)
C
      IF(ICYC.EQ.NCYC1 .AND. CAIL) PRECYC=.TRUE.
      IF (PRECYC .AND. ICYC .NE. NCYC1) THEN
        SIMUL=.FALSE.
        PRECYC=.FALSE.
      ENDIF
C
C IF NEEDED, CAIL/SAPS/APES PROCESSING ON EACH CYCLE:
C TRY TO GET AWAY WITHOUT A PHASE SWOP? - AND SORT OUT SOURCES LATER:
      DO 11 JSOURC=1,NSOURC
C 90.42 logsou moved to after phase swap
      DO 11 JPHASE=1,NPHASE
      CALL LOGSOU(JSOURC)
      CALL LOGPHA(JPHASE)
      IF (.NOT. RIET) CALL FAM4PR(2,PCXX,PFXX)
  11  CONTINUE
C 89.12 New routine varsal
        CALL VARMAK(DFLTPR,RUNPAR,VARSAL,LDUMMY)
** AND AN ALL PHASE LOOP HERE:
C IF ANY SLACK CONSTRAINTS, SET UP:
      CALL GEOMCO(1)
      CALL LOGSET
C
C INITIALISE R FACTOR SUMS:
      CALL RFACS(1)
C 90.28      CALL RFACPR(1,PCXX)
C
C SET UP POINTERS IN TRIANGULAR MATRIX AND CLEAR OUT LSQ MATRIX AND RHS
      CALL MATSET(ALSQ,MATSZ)
C
C NSTART=THE UNIT ON WHICH TO FIND OBS DATA
      NIN=NSTART
      NOUT=3-NIN
      REWIND ISCR(NIN)
      IF (MULFAS) REWIND ISCR(NOUT)
C
C START A CYCLE OVER PHASES, GETTING REQUIRED STRUCTURE & PROFILE
C INTO STORE:
C
      JPHASE=0
  20  JPHASE=JPHASE+1
      IF (JPHASE.NE.IPHASE) CALL PHMOVE(-1,IPHASE)
      CALL PHMOVE(1,JPHASE)
C
C INITIALISE R FACTOR QUANTITIES DEPENDING ON PHASE:
C 90.28      CALL RFACPR(11,PCXX)
      CALL GOF(1,0.)
C
C CLEAR POINTERS INDICATING SAVED FC CALCULATIONS FROM ONE INTENSITY TO THE
C NEXT:
%      CALL JGMZER(KPOINT,1,%OLAP%)
C
C START READING OBS:
      NOBS=0
      JSOURC=1
      CALL LOGSOU(1)
      NOBTOT=0
C INOBPR HAS TURNED THE VARIOUS FORMATS FOR INPUT INTO ONE, AND DECIDED WHICH
C REFLECTIONS CONTRIBUTE.
C
C NEW ENTRY TO ARRANGE INTERPOLATION FOR SPEED IF APPROPRIATE:
C      CALL PFXX(3)
C Comment this last line out until the interpolation actually
C always means going faster!!
   2  NOBTOT=NOBTOT+1
      IF (NOBTOT .GT. NSOBS(JSOURC)) THEN
C IF NECESSARY MOVE TO NEXT SOURCE:
        IF (JSOURC .GE. NSOURC) GO TO 3
        JSOURC=JSOURC+1
        CALL LOGSOU(JSOURC)
      ENDIF
C
C THIS READS FROM ISCR(1) OR (2), AND WRITES TO THE OTHER ONE:
      IF (JPHASE .EQ. 1) THEN
        READ(ISCR(NIN),END=3)ARGI,OBS,DOBS,WT,ICODE,JHIST,(KMI(I),
     &  KMA(I),I=1,NPHASE),YOLD
      ELSE
        READ(ISCR(NIN),END=3)ARGI,OBS,DOBS,WT,ICODE,JHIST,(KMI(I),
     &  KMA(I),I=1,NPHASE),YOLD,YCALC,YBACK,
     &  (DETEMP(I),I=1,LVARV),(YPKPH(I), I=1,NPHASE)
C KEEP YPEAK FOR ALL PHASES IN YPKPH(NPHASE)
      ENDIF
      KMIN=KMI(JPHASE)
      KMAX=KMA(JPHASE)
C NK REMAINS ZERO IF NONE OF THE PHASES HAS CONTRIBUTIONG REFLECTIONS:
      NK=0
      DO 42 I=1,NPHASE
  42  NK=NK+KMA(I)
C
C CLEAR ALL PARTS OF YCALC, AND DERIVV FOR DERIVATIVES OF YPEAK:
C (DONE HERE IN CASE NO CONTRIBUTING REFLNS)
      YPEAK=0.
      IF (LVARV .GT. 0 .AND. .NOT. SIMUL) CALL GMZER(DERIVV,1,LVARV)
      IF(JPHASE.EQ.1) THEN
       YBACK=0.
       CALL BACKPR(2)
      ENDIF
C
C DEAL WITH CASE YCALC=0 (EITHER BY BEING EXCLUDED OR BY HAVING NO CONTRIBUTING
C REFLECTIONS) - NB ICODE IS NON-ZERO FOR DO **NOT** USE:
      IF ((NK.EQ.0 .AND. .NOT.ZBAKIN) .OR. ICODE.NE.0) THEN
        YCALC=0.
        IF (JPHASE .EQ. NPHASE) THEN
C 90.28          CALL RFACPR(5,PCXX)
          CALL GOF(2,0.)
        ELSE
C WRITE RECORD BACK TO OTHER SCRATCH UNIT:
          YPKPH(JPHASE)=YPEAK
          WRITE (ISCR(NOUT)) ARGI,OBS,DOBS,WT,
     &    ICODE,JHIST,(KMI(I),KMA(I),I=1,NPHASE),YOLD,YCALC,YBACK,
     &    (DERIVV(I),I=1,LVARV),(YPKPH(I), I=1,NPHASE)
        ENDIF
        GO TO 2
      ENDIF
C
C CALCULATE FUNCTI0N TO MATCH OBSERVED, AND ITS DERIVATIVES, AND DO SOME
C STATISTICS:
C 90.28
      IF (KMAX .NE. 0) THEN
        CALL CALPRD(PCXX,PFXX)
      ENDIF
C
C RFACTOR QUANTITIES NEEDING YPEAK:
C 90.28      CALL RFACPR(12,PCXX)
      IF (JPHASE .EQ. 1) THEN
        YCALC=YPEAK+YBACK
      ELSE
        YCALC=YCALC+YPEAK
        CALL GMADD(DERIVV,DETEMP,DERIVV,1,LVARV)
      ENDIF
C
C DIFFERENCE:
      IF (JPHASE.EQ.NPHASE) THEN
        IF (SIMUL) OBS=YCALC
        DIFF = OBS - YCALC
C FROM WEIGHT GET SQRTWT AND WDIFF INTO COMMON:
        CALL WGHTLS(3,ARGI)
      ENDIF
C Add into statistics
      IF(ICYC.EQ.NCYC1) THEN
        CALL GOF(3,YPEAK)
      ELSE
        CALL GOF(3,YOLD)
      ENDIF
      IF (JPHASE .NE. NPHASE) THEN
C Save ycalc into yold for use next cycle
      YOLD=YCALC-YBACK
C NOW WRITE RECORD BACK TO OTHER SCRATCH UNIT:
        YPKPH(JPHASE)=YPEAK
        WRITE(ISCR(NOUT))ARGI,OBS,DOBS,WT,ICODE,JHIST,(KMI(I),
     &  KMA(I),I=1,NPHASE),YOLD,YCALC,YBACK,
     &  (DERIVV(I),I=1,LVARV),(YPKPH(I), I=1,NPHASE)
      ELSE
C Save ycalc into yold for use next cycle
      YOLD=YCALC-YBACK
C NOW WRITE RECORD BACK TO OTHER SCRATCH UNIT:
        YPKPH(JPHASE)=YPEAK
        WRITE(ISCR(NOUT))ARGI,OBS,DOBS,WT,ICODE,JHIST,(KMI(I),
     &  KMA(I),I=1,NPHASE),YOLD,YCALC,YBACK,
     &  (DERIVV(I),I=1,LVARV),(YPKPH(I), I=1,NPHASE)
C YCALC, YPEAK, YBACK AND DERIVV ARE NOW READY TO BEHAVE AS SINGLE PHASE:
C MAKE DERIVATIVES WRT BASIC VARIABLES FROM THOSE WRT VARIABLES:
        CALL RELATE
C ADD DERIVATIVES IN TO LSQ MATRIX:
        IF (CAIL) THEN
          CALL MATTOS(ALSQ,MATSZ)
         ELSE
          CALL MATTOT(ALSQ,MATSZ)
        ENDIF
        NOBS=NOBS+1
      ENDIF
C NEXT OBSERVATION FOR THIS PHASE:
      GO TO 2
C
C END OF ONE PHASE - REWIND UNITS AND FLIP:
   3  REWIND ISCR(NIN)
      IF (MULFAS) REWIND ISCR(NOUT)
      CALL FLIP(NIN,NOUT)
C RFACTORS FOR PHASE DEPENDENT PARTS:
C  90.28      CALL RFACPR(13,PCXX)
      CALL GOF(4,0.)
C
C SLACK CONSTRAINTS - FIRST GEOMETRICAL:
      CALL GEOMLS(ALSQ,MATSZ)
C THEN PAWLEY-TYPE:
      CALL PAWLS(ALSQ,MATSZ,3)
C COMBINED CHI-SQUARED:
      CALL RFACS(6)
C NEXT PHASE:
      IF (JPHASE .LT. NPHASE) GO TO 20
C
C HERE ON ALL PHASES DEALT WITH - PRINT R FACTORS:
C 90.28      CALL RFACPR(3,PCXX)
C
C INVERT MATRIX:
      CALL MATINV(ALSQ,MATSZ)
C CALCULATE SHIFTS AND ESD'S:
      CALL MATSHF(ALSQ,MATSZ)
C APPLY SHIFTS AND PRINT:
C 89.14 We think this works for mag and non mag
      CALL APSHPR(ALSQ,MATSZ,PCXX,PFXX,DOMAG)
C
C 90.82 SCAN THROUGH PHASES GETTING SPHPOL'ars set up:
      DO 55 JPHASE=NPHASE,1,-1
      IF(JPHASE.NE.IPHASE) CALL PHMOVE(-1,IPHASE)
      CALL PHMOVE(1,JPHASE)
      IF (PHMAG(JPHASE))  CALL DOMAG(6)
      CALL PHMOVE(-1,JPHASE)
  55  CONTINUE
C
C END OF TIMED PART OF THE CYCLE
      DELTA=SECNDS(TIME1)
      WRITE(ITO,'(A,F8.2)')'Time in seconds for this cycle: ',DELTA
      WRITE(LPT,'(A,F8.2)')'Time in seconds for this cycle: ',DELTA
C
C OUTPUT NEW CRYSTAL DATA FOR PENULTIMATE CYCLE:
      IF (DONE) GO TO 39
      DONE=(AMAXSH.LT.CONV .OR. ICYC.EQ.LASTCY-1 .OR. NCYC.EQ.1)
C 89.12 Fix for writing mag/non mag phases new .cry files
C 89.14 We think the following works for both mag and non mag.
      IF (DONE)  CALL NWINPR(PCXX,PFXX,DOMAG)
   1  CONTINUE
C
C PRINT CORRELATION MATRIX:
  39  CALL MATCOR(ALSQ,MATSZ)
C
C OUTPUT H,K,L LIST IF REQUIRED:
C      CALL HKLOUT(ALSQ,MATSZ)
      CALL HKLEBO()
C IF CAIL, OUTPUT EIGENVALUES & EIGENVECTORS IF REQUIRED BY "I PREE"
      CALL EIGEN(ALSQ,MATSZ)
 100  STOP
      END
C
C
C
C
C
C LEVEL 50      PROGRAM SIXTY2
      PROGRAM SIXTY2
C
C *** SIXTY2 by JBF 6 Oct 1994 ***
C
CX
CC 19B
CH Multi-phase, multi-source control of LSQ with magnetism present.
CD Individual phase profiles stored as well as the sum.
C
      CHARACTER *6 G77NAM
      LOGICAL DFLTPR,ONCARD,LDUMMY
      EXTERNAL PCXX,PFXX,DUMMY,DOMAG,RUNPAR,DFLTPR,VARSAL,MAGCNL,LDUMMY
%      DIMENSION ALSQ(%MATS%)
%      DIMENSION ISCR(2),DETEMP(%VVAR%),YPKPH(%PHAS%)
/CARDRC/
/DERVAR/
/GLOBAL/
/GRDBCK/
/IOUNIT/
/NEWOLD/
/OBSCAL/
/PHASE/
/PRPKFN/
/PRSAVE/
/PRSTAT/
/REFINE/
/REFIPR/
/REFLNS/
/SLAKDA/
/SLKGEO/
/SOURCE/
C
%      MATSZ=%MATS%
      G77NAM='SIXTY2'
      CALL PREFAS(G77NAM)
** DO THIS FOR EACH PHASE:
C DISCOVER WHETHER SLACK CONSTRAINTS:
      CALL GEOMIN(0)
      MAG=.FALSE.
C
C INITIALISE AND READ IN PHASE 0 L CARDS:
      CALL RDPHA0(PCXX,PFXX)
C
C CYCLE OVER PHASES READING STRUCTURE PARAMETERS THEN PROFILE PARS:
      DO 13 JPHASE =1,NPHASE
      CALL LOGPHA(JPHASE)
C ARRANGE TO ADDRESS THE CORRECT CRYSTAL DATA FILE:
      IF (JPHASE .NE. 1) THEN
        CALL VCSWOP(INREA(1,JPHASE),INREA(1,1),26)
        CALL VCSWOP(ICDN(1,JPHASE),ICDN(1,1),26)
      ENDIF
C THE STRUCTURE COMMON IS ASSUMED TO BE OVERWRITTEN EACH TIME
C SO DOES NOT NEED SPECIAL CLEARING:
      IF (MULFAS) THEN
        CALL WRLINE(2,60,'*',0)
        WRITE (LPT,2001) JPHASE
2001    FORMAT (//21X,'*** READING PHASE ',I3,' ***')
      ENDIF
      IPHASE=JPHASE
C FIND OUT IF PHASE IS MAGNETIC IE, Q CARDS PRESENT: READ Q PROP CARD
      CALL FINDCD('Q','PROP',4,0,LCD)
      IF (LCD.GE.0) THEN
        PHMAG(IPHASE) = .TRUE.
        CALL SETPR(PCXX,PFXX,DOMAG)
      ELSE
        PHMAG(IPHASE) = .FALSE.
        CALL SETPR(PCXX,PFXX,DUMMY)
      ENDIF
C MAKE LIST OF REFLECTION INDICES:
      CALL INRFPR(PCXX,PFXX)
C
C WRITE OUT STRUCTURE - A SPECIAL INITIAL ENTRY:
      CALL PHMOVE(-2,JPHASE)
  13  CONTINUE
C
C SCAN BACK THROUGH CDFS SETTING UP PARAMETERS:
      DO 12 JPHASE=NPHASE,1,-1
C GET RELEVANT STRUCTURE AND PROFILE PARS BACK:
      CALL PHMOVE(1,JPHASE)
      IF (PHMAG(JPHASE)) THEN
        CALL PARSPR(MAGCNL)
      ELSE
        CALL PARSPR(DUMMY)
      ENDIF
C 89.12 Add so as not to lose spind deriv's
      CALL PHMOVE(-1,JPHASE)
      IF (JPHASE .GT. 1) THEN
        CALL VCSWOP(INREA(1,JPHASE),INREA(1,1),26)
        CALL VCSWOP(ICDN(1,JPHASE),ICDN(1,1),26)
      ENDIF
  12  CONTINUE
C
C READ OBS DATA AND SEND OUT TO TEMPORARY UNIT FOR REINPUT EACH CYCLE
      CALL INOBPR(ISCR,NSTART,PCXX,PFXX)
C
      DONE=.FALSE.
      DO 1 ICYC=NCYC1,LASTCY
      WRITE(ITO,2000) ICYC
2000  FORMAT(' >>> Starting cycle ',I4)
      IF (PRECYC .AND. ICYC .NE. NCYC1) THEN
        SIMUL=.FALSE.
        PRECYC=.FALSE.
      ENDIF
C
C IF NEEDED, CAIL/SAPS/APES PROCESSING ON EACH CYCLE:
C TRY TO GET AWAY WITHOUT A PHASE SWOP? - AND SORT OUT SOURCES LATER:
      DO 11 JSOURC=1,NSOURC
      DO 11 JPHASE=1,NPHASE
      CALL LOGPHA(JPHASE)
      IF (.NOT. RIET) CALL FAM4PR(2,PCXX,PFXX)
  11  CONTINUE
C 89.12 New routine varsal
        CALL VARMAK(DFLTPR,RUNPAR,VARSAL,LDUMMY)
** AND AN ALL PHASE LOOP HERE:
C IF ANY SLACK CONSTRAINTS, SET UP:
      CALL GEOMCO(1)
      CALL LOGSET
C
C INITIALISE R FACTOR SUMS:
      CALL RFACS(1)
      CALL RFACPR(1,PCXX)
C
C SET UP POINTERS IN TRIANGULAR MATRIX AND CLEAR OUT LSQ MATRIX AND RHS
      CALL MATSET(ALSQ,MATSZ)
C
C NSTART=THE UNIT ON WHICH TO FIND OBS DATA
      NIN=NSTART
      NOUT=3-NIN
      REWIND ISCR(NIN)
      IF (MULFAS) REWIND ISCR(NOUT)
C
C START A CYCLE OVER PHASES, GETTING REQUIRED STRUCTURE & PROFILE
C INTO STORE:
C
      JPHASE=0
  20  JPHASE=JPHASE+1
      CALL PHMOVE(1,JPHASE)
C
C INITIALISE R FACTOR QUANTITIES DEPENDING ON PHASE:
      CALL RFACPR(11,PCXX)
C
C CLEAR POINTERS INDICATING SAVED FC CALCULATIONS FROM ONE INTENSITY TO THE
C NEXT:
%      CALL JGMZER(KPOINT,1,%OLAP%)
C
C START READING OBS:
      NOBS=0
      JSOURC=1
      CALL LOGSOU(1)
      NOBTOT=0
C INOBPR HAS TURNED THE VARIOUS FORMATS FOR INPUT INTO ONE, AND DECIDED WHICH
C REFLECTIONS CONTRIBUTE.
C
C NEW ENTRY TO ARRANGE INTERPOLATION FOR SPEED IF APPROPRIATE:
      CALL PFXX(3)
   2  NOBTOT=NOBTOT+1
      IF (NOBTOT .GE. NSOBS(JSOURC)) THEN
C IF NECESSARY MOVE TO NEXT SOURCE:
        IF (JSOURC .GE. NSOURC) GO TO 3
        JSOURC=JSOURC+1
        CALL LOGSOU(JSOURC)
      ENDIF
C
C THIS READS FROM ISCR(1) OR (2), AND WRITES TO THE OTHER ONE:
      IF (JPHASE .EQ. 1) THEN
        READ (ISCR(NIN),END=3) ARGI,OBS,DOBS,WT,ICODE,(KMI(I),
     &  KMA(I),I=1,NPHASE)
      ELSE
        READ (ISCR(NIN),END=3) ARGI,OBS,DOBS,WT,ICODE,(KMI(I),
     &  KMA(I),I=1,NPHASE),YCALC,
     &  (DETEMP(I),I=1,LVARV),(YPKPH(I), I=1,NPHASE)
C KEEP YPEAK FOR ALL PHASES IN YPKPH(NPHASE)
      ENDIF
      KMIN=KMI(JPHASE)
      KMAX=KMA(JPHASE)
C
C NK REMAINS ZERO IF NONE OF THE PHASES HAS CONTRIBUTIONG REFLECTIONS:
      NK=0
      DO 42 I=1,NPHASE
  42  NK=NK+KMA(I)
C
C CLEAR ALL PARTS OF YCALC, AND DERIVV FOR DERIVATIVES OF YPEAK:
C (DONE HERE IN CASE NO CONTRIBUTING REFLNS)
      YPEAK=0.
      YBACK=0.
      IF (LVARV .GT. 0 .AND. .NOT. SIMUL) CALL GMZER(DERIVV,1,LVARV)
C
C DEAL WITH CASE YCALC=0 (EITHER BY BEING EXCLUDED OR BY HAVING NO CONTRIBUTING
C REFLECTIONS) - NB ICODE IS NON-ZERO FOR DO **NOT** USE:
      IF ((NK.EQ.0 .AND. .NOT.ZBAKIN) .OR. ICODE.NE.0) THEN
        YCALC=0.
        IF (JPHASE .EQ. NPHASE) THEN
          CALL RFACPR(5,PCXX)
        ELSE
C WRITE RECORD BACK TO OTHER SCRATCH UNIT:
          YPKPH(JPHASE)=YPEAK
          WRITE (ISCR(NOUT)) ARGI,OBS,DOBS,WT,
     &    ICODE,(KMI(I),KMA(I),I=1,NPHASE),YCALC,
     &    (DERIVV(I),I=1,LVARV),(YPKPH(I), I=1,NPHASE)
        ENDIF
        GO TO 2
      ENDIF
C
C CALCULATE FUNCTI0N TO MATCH OBSERVED, AND ITS DERIVATIVES, AND DO SOME
C STATISTICS:
      IF (KMAX .NE. 0) THEN
        IF (PHMAG(JPHASE)) THEN
          CALL CALPRM(PCXX,PFXX)
        ELSE
          CALL CALPR(PCXX,PFXX)
        ENDIF
      ENDIF
C
C RFACTOR QUANTITIES NEEDING YPEAK:
      CALL RFACPR(12,PCXX)
      IF (JPHASE .EQ. 1) THEN
        YCALC=YPEAK
      ELSE
        YCALC=YCALC+YPEAK
        CALL GMADD(DERIVV,DETEMP,DERIVV,1,LVARV)
      ENDIF
C
      IF (JPHASE .NE. NPHASE) THEN
C NOW WRITE RECORD BACK TO OTHER SCRATCH UNIT:
        YPKPH(JPHASE)=YPEAK
        WRITE (ISCR(NOUT)) ARGI,OBS,DOBS,WT,ICODE,(KMI(I),
     &  KMA(I),I=1,NPHASE),YCALC,
     &  (DERIVV(I),I=1,LVARV),(YPKPH(I), I=1,NPHASE)
      ELSE
C IF LAST PHASE GET BACKGROUND VALUE AND DERIVATIVES:
        CALL BACKPR(2)
        YCALC=YCALC+YBACK
C YCALC, YPEAK, YBACK AND DERIVV ARE NOW READY TO BEHAVE AS SINGLE PHASE:
C
C MAKE DERIVATIVES WRT BASIC VARIABLES FROM THOSE WRT VARIABLES:
        CALL RELATE
C
C DIFFERENCE:
        IF (SIMUL) OBS=YCALC
        DIFF = OBS - YCALC
C FROM WEIGHT GET SQRTWT AND WDIFF INTO COMMON:
        CALL WGHTLS(3,ARGI)
C
C ADD IN TO R FACTORS:
        CALL RFACPR(2,PCXX)
C
C ADD DERIVATIVES IN TO LSQ MATRIX:
        IF (CAIL) THEN
          CALL MATTOS(ALSQ,MATSZ)
         ELSE
          CALL MATTOT(ALSQ,MATSZ)
        ENDIF
        NOBS=NOBS+1
      ENDIF
C NEXT OBSERVATION FOR THIS PHASE:
      GO TO 2
C
C END OF ONE PHASE - REWIND UNITS AND FLIP:
   3  REWIND ISCR(NIN)
      IF (MULFAS) REWIND ISCR(NOUT)
      CALL FLIP(NIN,NOUT)
C RFACTORS FOR PHASE DEPENDENT PARTS:
      CALL RFACPR(13,PCXX)
C
C SLACK CONSTRAINTS - FIRST GEOMETRICAL:
      CALL GEOMLS(ALSQ,MATSZ)
C THEN PAWLEY-TYPE:
      CALL PAWLS(ALSQ,MATSZ,3)
C COMBINED CHI-SQUARED:
      CALL RFACS(6)
C NEXT PHASE:
      IF (JPHASE .LT. NPHASE) GO TO 20
C
C HERE ON ALL PHASES DEALT WITH - PRINT R FACTORS:
      CALL RFACPR(3,PCXX)
C
C INVERT MATRIX:
      CALL MATINV(ALSQ,MATSZ)
C CALCULATE SHIFTS AND ESD'S:
      CALL MATSHF(ALSQ,MATSZ)
C APPLY SHIFTS AND PRINT:
C 89.14 We think this works for mag and non mag
      CALL APSHPR(ALSQ,MATSZ,PCXX,PFXX,DOMAG)
C
C OUTPUT NEW CRYSTAL DATA FOR PENULTIMATE CYCLE:
      IF (DONE) GO TO 39
      DONE=(AMAXSH.LT.CONV .OR. ICYC.EQ.LASTCY-1 .OR. NCYC.EQ.1)
C 89.12 Fix for writing mag/non mag phases new .cry files
C 89.14 We think the following works for both mag and non mag.
      IF (DONE)  CALL NWINPR(PCXX,PFXX,DOMAG)
   1  CONTINUE
C
C PRINT CORRELATION MATRIX:
  39  CALL MATCOR(ALSQ,MATSZ)
C
C OUTPUT H,K,L LIST IF REQUIRED:
      CALL HKLOUT(ALSQ,MATSZ)
C IF CAIL, OUTPUT EIGENVALUES & EIGENVECTORS IF REQUIRED BY "I PREE"
      CALL EIGEN(ALSQ,MATSZ)
 100  STOP
      END
C
C
C
C
C LEVEL 50      PROGRAM TF102M
      PROGRAM TF102M
C
C *** TF102M from TF12LM but uses PDTF02 etc by JBF May 94 ***
C
C ******************************************************************************
C
C                            T F 1 0 2 M
C
C ******************************************************************************
C
C MAIN PROGRAM FOR TOF LSQ WITH CENTRE AND PEAK FUNCTIONS 1 and 02
C FOR MAGNETIC STRUCTURES, SAME SIGM, GAMM FOR NUCLEAR & MAGNETIC REFLECTIONS
C
C DIMENSION OF ALSQ BELOW, AND SETTING OF MATSZ, TO BE ALTERED TO BE SOMETHING
C A LITTLE LARGER THAN N*(N+3)/2 WHERE THERE WILL BE N BASIC VARIABLES
C
      EXTERNAL PCTF01,PFTF02,DOMAG,CALPRM
%      DIMENSION ALSQ(%MATS%)
%      MATSZ=%MATS%
      CALL FORTYM('TF102M',ALSQ,MATSZ,PCTF01,PFTF02,DOMAG,CALPRM)
      STOP
      END
C
C
C
C
C LEVEL 50      PROGRAM TF104M
      PROGRAM TF104M
C
C *** TF104M from TF102M but uses PDTF04 etc by JBF Jan 95 ***
C
C ******************************************************************************
C
C                            T F 1 0 4 M
C
C ******************************************************************************
C
C MAIN PROGRAM FOR TOF LSQ WITH CENTRE AND PEAK FUNCTIONS 1 and 04
C FOR MAGNETIC STRUCTURES, SAME SIGM, GAMM FOR NUCLEAR & MAGNETIC REFLECTIONS
C
C DIMENSION OF ALSQ BELOW, AND SETTING OF MATSZ, TO BE ALTERED TO BE SOMETHING
C A LITTLE LARGER THAN N*(N+3)/2 WHERE THERE WILL BE N BASIC VARIABLES
C
      EXTERNAL PCTF01,PFTF04,DOMAG,CALPRM
%      DIMENSION ALSQ(%MATS%)
%      MATSZ=%MATS%
      CALL FORTYM('TF104M',ALSQ,MATSZ,PCTF01,PFTF04,DOMAG,CALPRM)
      STOP
      END
C
C
C
C
C LEVEL 50      PROGRAM TF11LM
      PROGRAM TF11LM
C
C *** TF11LM by JCM 5 May 89 ***
C
C ******************************************************************************
C
C                            T F 1 1 L M
C
C ******************************************************************************
C
C MAIN PROGRAM FOR TOF LSQ WITH CENTRE AND PEAK FUNCTIONS 1 1
C                       WITH ALLOWANCE FOR MAGNETIC STRUCTURES
C
C DIMENSION OF ALSQ BELOW, AND SETTING OF MATSZ, TO BE ALTERED TO BE SOMETHING
C A LITTLE LARGER THAN N*(N+3)/2 WHERE THERE WILL BE N BASIC VARIABLES
C
      EXTERNAL PCTF01,PFTF01,DOMAG,CALPRM
%      DIMENSION ALSQ(%MATS%)
%      MATSZ=%MATS%
      CALL FORTY('TF11LM',ALSQ,MATSZ,PCTF01,PFTF01,DOMAG,CALPRM)
      STOP
      END
C
C
C
C
C LEVEL 50      PROGRAM TF11LS
      PROGRAM TF11LS
C
C *** TF11LS by JCM 11 Aug 88 ***
C
C ******************************************************************************
C
C                            T F 1 1 L S
C
C ******************************************************************************
C
C MAIN PROGRAM FOR TOF LSQ WITH CENTRE AND PEAK FUNCTIONS 1 1
C
C DIMENSION OF ALSQ BELOW, AND SETTING OF MATSZ, TO BE ALTERED TO BE SOMETHING
C A LITTLE LARGER THAN N*(N+3)/2 WHERE THERE WILL BE N BASIC VARIABLES
C
      EXTERNAL PCTF01,PFTF01,DUMMY,CALPR
%      DIMENSION ALSQ(%MATS%)
%      MATSZ=%MATS%
      CALL FORTY('TF11LS',ALSQ,MATSZ,PCTF01,PFTF01,DUMMY,CALPR)
      STOP
      END
C
C
C
C
C LEVEL 50      PROGRAM TF12LS
      PROGRAM TF12LS
C
C *** TF12LS by JCM 12 Aug 88 ***
C
C ******************************************************************************
C
C                            T F 1 2 L S
C
C ******************************************************************************
C
C MAIN PROGRAM FOR TOF LSQ WITH CENTRE AND PEAK FUNCTIONS 1 2
C
C DIMENSION OF ALSQ BELOW, AND SETTING OF MATSZ, TO BE ALTERED TO BE SOMETHING
C A LITTLE LARGER THAN N*(N+3)/2 WHERE THERE WILL BE N BASIC VARIABLES
C
      EXTERNAL PCTF01,PFTF02,DUMMY,CALPR
%      DIMENSION ALSQ(%MATS%)
%      MATSZ=%MATS%
      CALL FORTY('TF12LS',ALSQ,MATSZ,PCTF01,PFTF02,DUMMY,CALPR)
      STOP
      END
C
C
C
C
C LEVEL 50      PROGRAM TF112M
      PROGRAM TF112M
C
C *** TF112M renamed from TF12LM  using PDTF12 etc by JBF May 94 ***
C
C ******************************************************************************
C
C                            T F 1 1 2 M
C
C ******************************************************************************
C
C MAIN PROGRAM FOR TOF LSQ WITH CENTRE AND PEAK FUNCTIONS 1 and 12
C WITH ALLOWANCE FOR MAGNETIC STRUCTURES AND DIFFERING SIGM FOR M AND N PEAKS
C
C DIMENSION OF ALSQ BELOW, AND SETTING OF MATSZ, TO BE ALTERED TO BE SOMETHING
C A LITTLE LARGER THAN N*(N+3)/2 WHERE THERE WILL BE N BASIC VARIABLES
C
      EXTERNAL PCTF01,PFTF12,DOMAG,CALPRM
      CHARACTER *6 G77NAM
%      DIMENSION ALSQ(%MATS%)
%      MATSZ=%MATS%
      G77NAM='TF112M'
      CALL FORTYM(G77NAM,ALSQ,MATSZ,PCTF01,PFTF12,DOMAG,CALPRM)
      STOP
      END
C
C
C
C
C LEVEL 50      PROGRAM TF14LS
      PROGRAM TF14LS
C
C *** TF14LS by JCM 4 Sep 90 ***
C
C ******************************************************************************
C
C                            T F 1 4 L S
C
C ******************************************************************************
C
C MAIN PROGRAM FOR TOF LSQ WITH CENTRE AND PEAK FUNCTIONS 1 4 FOR POLARIS
C
C DIMENSION OF ALSQ BELOW, AND SETTING OF MATSZ, TO BE ALTERED TO BE SOMETHING
C A LITTLE LARGER THAN N*(N+3)/2 WHERE THERE WILL BE N BASIC VARIABLES
C
      EXTERNAL PCTF01,PFTF04,DUMMY,CALPR
%      DIMENSION ALSQ(%MATS%)
%      MATSZ=%MATS%
      CALL FORTY('TF14LS',ALSQ,MATSZ,PCTF01,PFTF04,DUMMY,CALPR)
      STOP
      END
C
C
C
C
C LEVEL 50      PROGRAM TF15LS
      PROGRAM TF15LS
C
C *** TF15LS by JCM ***
C
C ******************************************************************************
C
C                            T F 1 5 L S
C
C ******************************************************************************
C
C MAIN PROGRAM FOR TOF LSQ WITH CENTRE AND PEAK FUNCTIONS 1 5
C
C DIMENSION OF ALSQ BELOW, AND SETTING OF MATSZ, TO BE ALTERED TO BE SOMETHING
C A LITTLE LARGER THAN N*(N+3)/2 WHERE THERE WILL BE N BASIC VARIABLES
C
      EXTERNAL PCTF01,PFTF05,DUMMY,CALPR
%      DIMENSION ALSQ(%MATS%)
%      MATSZ=%MATS%
      CALL FORTY('TF15LS',ALSQ,MATSZ,PCTF01,PFTF05,DUMMY,CALPR)
      STOP
      END
C
C
C
C
C LEVEL 50      PROGRAM TF18LS
      PROGRAM TF18LS
C
C *** TF18LS by JCM ***
C
C ******************************************************************************
C
C                            T F 1 8 L S
C
C ******************************************************************************
C
C MAIN PROGRAM FOR TOF LSQ WITH CENTRE AND PEAK FUNCTIONS 1 8
C
C DIMENSION OF ALSQ BELOW, AND SETTING OF MATSZ, TO BE ALTERED TO BE SOMETHING
C A LITTLE LARGER THAN N*(N+3)/2 WHERE THERE WILL BE N BASIC VARIABLES
C
      EXTERNAL PCTF01,PFTF08,DUMMY,CALPR
%      DIMENSION ALSQ(%MATS%)
%      MATSZ=%MATS%
      CALL FORTY('TF18LS',ALSQ,MATSZ,PCTF01,PFTF08,DUMMY,CALPR)
      STOP
      END
C
C
C
C
C LEVEL 50      PROGRAM TF9192LS
      PROGRAM TF9192LS
C
C *** TF9192LS by JCM 12 Aug 88 ***
C
C ******************************************************************************
C
C                         T F 9 1 9 2 L S
C
C ******************************************************************************
C
C MAIN PROGRAM FOR TOF LSQ WITH CENTRE AND PEAK FUNCTIONS 1 2
C
C DIMENSION OF ALSQ BELOW, AND SETTING OF MATSZ, TO BE ALTERED TO BE SOMETHING
C A LITTLE LARGER THAN N*(N+3)/2 WHERE THERE WILL BE N BASIC VARIABLES
C
      EXTERNAL PCTF91,PFTF92,DUMMY,CALPR
%      DIMENSION ALSQ(%MATS%)
%      MATSZ=%MATS%
      CALL FORTY('TF9192LS',ALSQ,MATSZ,PCTF91,PFTF92,DUMMY,CALPR)
      STOP
      END
C
C
C
C
C LEVEL 50      PROGRAM TIC
      PROGRAM TIC
C
C *****************************************************************************
C
C                                 T I C
C
C                          WRITES GENIE FILE
C
C ****************************************************************************
C
C      READ CRYSTAL FILE
      CALL PREFIN('TIC')
      CALL PTIC
C
      CALL WRITIC
      STOP
      END
C
C
C
C
C LEVEL 50      PROGRAM TOFPOW
      PROGRAM TOFPOW
C
C *** TOFPOW by PJB March 1994 ***
C
C ****************************************************************************
C
C                             T O F P O W
C
C TO GENERATE INDICES OF REFLECTIONS AND CALCULATE TOF POWDER PATTERN
C
C ****************************************************************************
      EXTERNAL DOMAG1
%      DIMENSION H(3,%NSFS%),IS(%NSFS%),MULT(%NSFS%),M(%NSFS%)
      DIMENSION IU(3),RH(3),U(3),VAL(5),K(3),HF(3)
      COMPLEX FCALC,FC
      LOGICAL ENDREF,OUTPUT,LAYER,ISPABS,SAYS,ZRO,MAGABS,LATABS
      CHARACTER*150 VFMT
      CHARACTER*1 SIG(3)
/BRAGG/
/IOUNIT/
/NSYM/
/QCAL/
/SATELL/
/SYMMAG/
/SCRACH/
      DATA VFMT/'(6X,''h'',7X,''k'',7X,''l'',5X,''  h   k   l      '',
     &''  TOF        FNsqr     FMsqr     Intensity''/)'/
      DATA SIG/'+','-',' '/
      DATA VNEUT /3.9560342E-3/
C
      LAYER=.FALSE.
      CALL PREFIN('TOFPOW')
C
      SMIN=0.
C
   30 CALL ASK('Total flight path(m), detector angle (degrees)')
      CALL RDNUMS(VAL,1,2,N,IER)
      IF (N .NE. 2 .OR. IER .NE.0) GO TO 30
      DDET=VAL(1)
      SDANG=SIN(RADIAN(VAL(2)/2.))
      WRITE (LPT,2082) DDET,VAL(2)
 2082 FORMAT (' Total flight path',F8.4,
     &' metres; 2theta of detector',F8.2)
      VCON=SDANG*DDET/VNEUT
   31 CALL ASK('Minimum and (maximum) T.O.F.(microsec)')
      CALL RDNUMS(VAL,1,2,N,IER)
      IF (IER.NE.0) GO TO 31
      IF (N.EQ.1) THEN
        TMIN=VAL(1)
      ELSE
        TMIN=AMIN1(VAL(1),VAL(2))
        TMAX=AMAX1(VAL(1),VAL(2))
        SMIN=VCON/TMAX
        WRITE (LPT,2081) NINT(TMAX)
2081    FORMAT (' Maximum flight time =',I8)
      ENDIF
      SMAX=VCON/TMIN
C
      WRITE (LPT,2080) NINT(TMIN)
2080  FORMAT (' Minimum flight time =',I8)
      CALL ASK('Store indices on file? Y or N')
      OUTPUT=(SAYS('Y'))
C
C  SET UP CRYSTALLOGRAPHY
      CALL SETFCM(DOMAG1)
      CALL MAGCNC
      CALL DOMAG1(2)
      CALL SYMUNI
      CALL SETGEN(SMAX)
      CALL ERRMES(0,0,'for TOFPOW')
C
      CALL SETGEN(SMAX)
C
C  NOW GENERATE REFLECTIONS
      TEST=0.
      NUM=1
      MAGREF=2
      IF (IPROP.EQ.0) MAGREF=1
      NFLAG=-9999
      DO 2 IMAG=1,MAGREF
    1 IF (IMAG.EQ.1) THEN
        CALL GENMUL(H(1,NUM),ENDREF,MULT(NUM))
      ELSE
        CALL GENMAG(H(1,NUM),ENDREF,MULT(NUM),SMAX,NFLAG)
      ENDIF
      IF (ENDREF) GO TO 2
      S=VCTMOD(0.5,H(1,NUM),2)
      IF (S .GT. SMAX .OR. S .LT. SMIN) GO TO 1
      IS(NUM)=JFIX(S*(10**4))
      NUM=NUM+1
%      IF (NUM+NKSTAR.LE. %NSFS%) GO TO 1
      WRITE (ITO,3000) SMAX
%3000  FORMAT (' There are more than the allowed maximum of %NSFS%',
     & ' reflections'/' inside the SinTheta/lambda limit of',F7.3)
    2 CONTINUE
C
C  SORT ON SINTHETA/LAMDA
    3 NUM=NUM-1
      CALL SORTN(IS,M,NUM)
C
C  RESTORE FULL SYMMETRY
      IF (NKSTAR .GT. 1) CALL SYMBAK
C
C  HEADING
      CALL CENTRE(LPT,100,'***** Calculation of magnetic powder '//
     &'diagram  *****',90)
      LIN=3
      IF (OUTPUT) THEN
        LPT1=NOPFIL(2)
        LIN=LIN+1
        CALL MESS(LPT,0,
     & '                   Indices output to '//NAMFIL)
      ENDIF
C
C  AND PRINT OUT RESULTS
      CALL MESS(LPT,1,' ')
      WRITE (LPT,VFMT)
      DO 5 N=1,NUM
      J=M(N)
      DO 6 NN=N+1,NUM
      JJ=M(NN)
      IF (IS(JJ).GT.IS(J)) GO TO 7
      DO 8 I=1,3
      IF (ABS(H(I,J)-H(I,JJ)).GT..0001) GO TO 6
    8 CONTINUE
C MATCH FOUND SKIP
      GO TO 5
    6 CONTINUE
    7 S=FLOAT(IS(J))
      S=S/(10**4)
      STHL=S
      IF (MAGABS(H(1,J),ISS)) THEN
        CALL CGMZER(Q,1,3)
        FMCMOD=0.
        FMCSQR=0.
      ELSE
        CALL FMCALC(H(1,J),FMCMOD,FMCSQR)
        IF (ISS.GT.0) THEN
          CALL GMSUB(H(1,J),PROP,HF,3,1)
          ISAT=1
        ELSE IF (ISS.LT.0) THEN
          CALL GMADD(H(1,J),PROP,HF,3,1)
          ISAT=2
        ELSE
          ISAT=3
        ENDIF
      ENDIF
      FNSQR=0.
      IF (.NOT.LATABS(H(1,J))) THEN
        FC=FCALC(H(1,J))
        ISAT=3
        FNSQR = REAL(FC*CONJG(FC))
      ENDIF
      IF (ISAT.EQ.3) CALL GMEQ(H(1,J),HF,3,1)
      FSQR = FNSQR + FMCSQR
      CALL TESTP(LPT,LIN,1,VFMT,1)
      IN=MULT(J)
      FAC=(2*S)**4
      TOF=VCON/S
      AINT=FLOAT(IN)*FSQR/FAC
      CALL INDFIX(HF,K)
      WRITE (LPT,2007) (H(I,J),I=1,3),K,SIG(ISAT),NINT(TOF),FNSQR,
     &FMCSQR,AINT
2007  FORMAT (1X,3F8.3,2X,3I4,1X,A1,2X,I8,2X,2F10.4,2X,F10.3)
      IF (OUTPUT) WRITE (LPT1,2008) K,ISAT,IN
2008  FORMAT (5I5)
    5 CONTINUE
      STOP
      END
##ENDPMA
##LIB
C
C                       M A R K  4       L I B R A R Y
C
C             AS DESCRIBED IN THE USER'S MANUAL 'CCSL MARK 4'.
C
C
C
C LEVEL 4      SUBROUTINE ABMULT(H,ABSC)
      SUBROUTINE ABMULT(H,ABSC)
C
C *** ABMULT by JCM 24 Sep 85 ***
C
CX
CC 2B
CH Forms transmission (=1/absorption) factors or related integrals.
C
CA On entry:
CA    H is a 3-size real array holding h,k,l on entry
CA    ABSC is a 3-size real array to hold the requested integrals on exit
C
CP On entry, SETABS (or a MAIN program) has placed in COMMON /ABSDAT
CP         AMU = mu, the coefficient of absorption
CP         MODEA = which integral is required -
CP         MODEA = 1 usual exp(-mu(in+out)) transmission factor to ABSC(1)
CP         MODEA = 2 path in exp(-mu(in)) depolarisation to ABSC(2)
CP         MODEA = 3 derivative (in+out)*exp(-mu(in+out)) extinction to ABSC(3)
CP         MODEA = 4 means do 1 and 2
CP         MODEA = 5 means do 1 and 3
CP         MODEA = 6 means do 2 and 3
CP         MODEA = 7 means do all three integrals
CP
CP SETABS has set up (via SETGAU) the Gaussian 3D integration in COMMON /GAUSS
CP
CP SETABS has set up the equations of the plane faces in COMMON /CPLANE.
C
CD Uses 3D Gaussian integration
C
CN There exists also the FUNCTION ABSOR(H), which is similar to ABMULT but will
CN only do one answer at once.
C
      LOGICAL TESTOV
      DIMENSION H(3),DIREC(3,2),ABSC(3)
/ABSDAT/
/CPLANE/
/GAUSS/
C
      CALL GETDC(H,DIREC)
      DO 11 I=1,3
  11  ABSC(I)=0.
      DO 1 J = 1,NQ
      D = 6000.
      E = 6000.
      DO 2 I = 1,NP
      A = DD(I) - AA(I)*XX(J) - BB(I)*YY(J) - CC(I)*ZZ(J)
      B=AA(I)*DIREC(1,1)+BB(I)*DIREC(2,1)+CC(I)*DIREC(3,1)
      IF (TESTOV(A,B)) GO TO 3
      C = A/B
      IF (C) 3,4,4
   4  IF (C-D) 5,5,3
   5  D = C
   3  B=AA(I)*DIREC(1,2)+BB(I)*DIREC(2,2)+CC(I)*DIREC(3,2)
      IF (TESTOV(A,B)) GO TO 2
      C = A/B
      IF (C) 2,6,6
   6  IF (C-E) 7,7,2
   7  E = C
   2  CONTINUE
      IF (MODEA .GT. 7) CALL ERRIN2(MODEA,0,'for ABMULT MODE',
     & 'not allowed - only 1-7')
C
      GO TO (20,21,20,20,20,20,20) , MODEA
  20  TERM=EXP((-AMU)*(D+E))*WW(J)
  21  GO TO (8,9,10,8,8,9,8) , MODEA
   8  ABSC(1)=ABSC(1)+TERM
      GO TO (1,1,1,9,10,1,9) , MODEA
   9  ABSC(2)=ABSC(2)+EXP((-AMU)*D)*WW(J)
      GO TO (1,1,1,1,1,10,10) , MODEA
  10  ABSC(3)=ABSC(3) + (D+E)*TERM
   1  CONTINUE
      RETURN
      END
C
C
C
C
C LEVEL 5      SUBROUTINE ABSCOR(IS)
      SUBROUTINE ABSCOR(IS)
C
C *** ABSCOR updated by PJB 24-Apr-1995 ***
C
CX
CC 2B
CH Applies absorption corrections to groups of equivalent reflections.
C
CA On entry IS =0 for the initial seting up, or 1 for the calculation
C
CP SYMOP, RECIP, SETABS should be obeyed first to set up calls of ABSOR
CP A group of reflections should be present in /REFS/
C
CO If IOUT is > 9 on entry IS=0, creates output unit LP2
CO (Note that this is a non-standard use of IOUT & better change)
CO For entries IS=1, writes to that unit
C
CN A PJB speciality called from ABSMSF
C
      EXTERNAL ABSHED
      DIMENSION ANG(4),KK(3),W1(5),W2(5)
      LOGICAL NEW
/BRAGG/
/CONSTA/
/DGEOM/
      COMMON /HEDABS/HEDAB
      CHARACTER*104 HEDAB
      COMMON /HEDAB2/LP2,LINB,IANG
/IOUNIT/
/REFS/
/SCRACH/
C
C INITIAL ENTRY:
      IF (IS.NE.0) GO TO 5
      IF (IOUT.LT.10) GO TO 100
      GO TO (100,100,100,100,100,1,1,1,100,100,1) ,IGEOM
      GO TO 100
C
    1 IANG=3
      MESSAG='ABSCOR.LIS'
      CALL UPONE(MESSAG,3)
      LP2=NOPFIL(2022)
      IF (INC.EQ.0) GO TO 20
      HEDAB(2:2)='6'
      HEDAB(9:9)='7'
      HEDAB(16:16)='7'
      HEDAB(23:23)='7'
   20 IF (IGEOM .EQ. 8)GO TO 21
      HEDAB(87:)='Chi       Phi''/)'
      IANG=4
   21 WRITE (LP2,HEDAB)
      LINB=3
      GO TO 100
C
C FURTHER ENTRIES:
    5 IR=1
      II=0
    2 L=LL(IR,IS)
      IF (L.EQ.3) GO TO 100
C   SET BEGINNING AND END OF DATA
      IE=II+L
      IB=II+4
      IF (IGEOM.NE.7 .AND. IGEOM.NE.12) THEN
        TRFAC=ABSOR(R(II+1,IS))
        ABSC=1./TRFAC
      ELSE
        NEW=.TRUE.
      ENDIF
C   INITIALIZE
      CALL WTMEAN(X1,Y1,0,W1)
      CALL WTMEAN(X2,Y2,0,W2)
      DO 6 I=IB,IE,ITEMS
      IF (IGEOM.EQ.7) THEN
        IF (.NOT. NEW) THEN
C CHECK FOR EXACT SAME MEASUREMENT
          CALL EQVEC(DIFANG,R(I+2,IS),1,M,0)
          IF (M.EQ.1) GO TO 23
        ENDIF
        CALL GMEQ(R(I+2,IS),ANG,4,1)
        CALL GMSCA(ANG,DIFANG,RAD,4,1)
        TRFAC=ABSOR(R(II+1,IS))
        ABSC=1./TRFAC
      ENDIF
C   ADD IN REPEATED MEASUREMENTS OF THE SAME REFLECTION
   23 CALL WTMEAN(R(I,IS),R(I+1,IS),1,W1)
      R(I,IS)=R(I,IS)*ABSC
      R(I+1,IS)=R(I+1,IS)*ABSC
C   AND ITS INTENSITY AFTER SCALING BY ABSORPTION CORRECTION
      CALL WTMEAN(R(I,IS),R(I+1,IS),1,W2)
    6 CONTINUE
C   FIND MEAN OF REPEATED MEASUREMENTS
      CALL WTMEAN(X1,Y1,-1,W1)
      CALL WTMEAN(X2,Y2,-1,W2)
      IF (IOUT.GT.10) THEN
        IF (IGEOM.NE.7) THEN
C   CALCULATE SETTING ANGLES AS A CHECK
          CALL ANGDIR(R(II+1,IS),ANG)
          DO 4 I=1,IANG
    4     ANG(I)=DEGREE(ANG(I))
        ENDIF
        CALL TESTP(LP2,LINB,1,HEDAB,2)
        IF (INC.EQ.0) THEN
          CALL INDFIX(R(II+1,IS),KK)
          WRITE (LP2,2000) KK,X1,X2,TRFAC,(ANG(I),I=1,IANG)
 2000     FORMAT (2X,3I5,2(2X,F10.2),2X,F10.4,2X,4F10.2)
        ELSE
          WRITE (LP2,2001) (R(II+I,IS),I=1,3),X1,X2,TRFAC,
     &    (ANG(I),I=1,IANG)
 2001     FORMAT (1X,3F8.3,2(2X,F10.2),2X,F10.4,2X,4F10.2)
        ENDIF
      ENDIF
C   ADVANCE POINTER TO NEXT PIECE OF DATA IN ARRAY R(II,IS)
      II=IE+2
      IR=IR+1
      GO TO 2
C
 100  RETURN
      END
C
C
C
C
      BLOCK DATA ABSHED
      COMMON /HEDABS/HEDAB
      CHARACTER*104 HEDAB
      DATA HEDAB/'(6X,''h'',4X,''k'',4X,''l'',5X,''  Iobs        Icor
     &   Trn Fac       Theta     Omega       Nu      ''/)'/
      END
C
C
C
C
C LEVEL 4      FUNCTION ABSOR(H)
      FUNCTION ABSOR(H)
C
C *** ABSOR by JCM 24 Sep 85 ***
C
CX
CC 2B
CH Forms a transmission (=1/absorption) factor or related integrals.
C
CA On entry H is a 3-size real array holding h,k,l
C
CP On entry, SETABS (or a MAIN program) has placed in COMMON /ABSDAT
CP         AMU = mu, the coefficient of absorption
CP         MODEA = which integral is required -
CP         MODEA = 1 usual exp(-mu(in+out)) transmission factor to ABSC(1)
CP         MODEA = 2 path in exp(-mu(in)) depolarisation to ABSC(2)
CP         MODEA = 3 derivative (in+out)*exp(-mu(in+out)) extinction to ABSC(3)
CP
CP SETABS has set up (via SETGAU) the Gaussian 3D integration in COMMON /GAUSS
CP
CP SETABS has set up the equations of the plane faces in COMMON /CPLANE.
C
CD Uses 3D Gaussian integration over the crystal as defined by its plane faces
CN There also exists SUBROUTINE ABMULT, which is capable of calcuating more
CN than one type of integral at one entry.  If, e.g., absorption and
CN depolarisation were both required, one call of ABMULT would be more
CN efficient than 2 calls of ABSOR
C
      LOGICAL TESTOV
      DIMENSION H(3),DIREC(3,2)
/ABSDAT/
/CPLANE/
/GAUSS/
C
      CALL GETDC(H,DIREC)
      ABSC = 0.
      DO 1 J = 1,NQ
      D = 6000.
      E = 6000.
      DO 2 I = 1,NP
      A = DD(I) - AA(I)*XX(J) - BB(I)*YY(J) - CC(I)*ZZ(J)
      B=AA(I)*DIREC(1,1)+BB(I)*DIREC(2,1)+CC(I)*DIREC(3,1)
      IF (TESTOV(A,B)) GO TO 3
      C = A/B
      IF (C) 3,4,4
   4  IF (C-D) 5,5,3
   5  D = C
   3  B=AA(I)*DIREC(1,2)+BB(I)*DIREC(2,2)+CC(I)*DIREC(3,2)
      IF (TESTOV(A,B)) GO TO 2
      C = A/B
      IF (C) 2,6,6
   6  IF (C-E) 7,7,2
   7  E = C
   2  CONTINUE
      IF (MODEA .GT. 3) CALL ERRIN2(MODEA,0,'for FUNCTION ABSOR MODE',
     & 'not allowed - only 1-3')
      GO TO (8,9,10) , MODEA
   8  ABSC = ABSC + EXP((-AMU)*(D+E))*WW(J)
      GO TO 1
   9  ABSC = ABSC + EXP((-AMU)*D)*WW(J)
      GO TO 1
  10  ABSC = ABSC + (D+E)*EXP((-AMU)*(D+E))*WW(J)
   1  ABSOR=ABSC
      RETURN
      END
C
C
C
C
C LEVEL 3      SUBROUTINE ADDANG(NAME,N1,N2,N3,NA,IE)
      SUBROUTINE ADDANG(NAME,N1,N2,N3,NA,IE)
C
C *** ADDANG updated by JCM 25 Jul 91 ***
C
CX
CC 8A
CH Finds an angle in the tables for geometric constraints, or adds it if absent.
CA On entry:
CA           NAME is the angle name, A4, which may be empty
CA           N1 is the number of the bond opposite the angle in the tables
CA           N2 is the number of one bond at the angle
CA           N3 is the number of the other bond at the angle
CA On exit, NA is the number of this angle in the angle names in ANGNAM
CA          IE is an error indicator, =0 if OK
CD If an angle already exists in the tables opposite N1, ignores
CD NAME and sends out NA=its position.
CD If there is no such angle, counts up in NUMANG in /SLKGEO, and adds
CD the new angle.  If in this case NAME is empty, invents a name.
CN The bonds N2 and N3 are held in INANG so that INANG( ,2) < INANG( ,3)
C
      CHARACTER *4 NAME,MAKNAM
/IOUNIT/
/SLKGEC/
/SLKGEO/
C
      IE=0
C IS ANGLE ALREADY GIVEN IN TRIANGLE N1,N2,N3 OPPOSITE N1?
      NMIN=MIN(N2,N3)
      NMAX=MAX(N2,N3)
      DO 1 I=1,NUMANG
      IF (NMIN .EQ. INANG(I,2) .AND. NMAX .EQ. INANG(I,3)) THEN
        IF (NAME .NE. ANGNAM(I) .AND. NAME .NE. '    ') THEN
          WRITE (LPT,3000) NAME,ANGNAM(I)
          WRITE (ITO,3000) NAME,ANGNAM(I)
3000      FORMAT (/' ERROR ** ',A4,' and',A4,' refer to same angle')
          IE=1
          GO TO 100
        ENDIF
        NA=I
        GO TO 100
      ENDIF
   1  CONTINUE
C
C NEW ANGLE - COUNT NUMBER OF BOND ANGLES:
%      CALL ERRCHK(2,NUMANG,%SANG%,1,'angles for geometric constraints')
C
C CHECK NAME OF ANGLE DOES NOT CLASH WITH ANY ATOM  OR BOND NAMES:
      L1=0
      IF (NTARNM .GT. 0) L1=NCFIND(NAME,ATTNAM,NTARNM)
      L2=NCFIND(NAME,BONNAM,NUMBON)
      IF (L1 + L2 + IATOM(NAME) .GT. 0) THEN
        CALL ERRCH2(NAME,1,'Angle name','also used elsewhere')
        IE=1
        GO TO 100
      ENDIF
C
C ANGLE MAY HAVE BEEN GIVEN WITHOUT A NAME:
      ANGNAM(NUMANG)=NAME
      IF (NAME .EQ. '    ') ANGNAM(NUMANG)=MAKNAM('Ang',NUMANG)
      NA=NUMANG
      INANG(NA,1)=N1
      INANG(NA,2)=NMIN
      INANG(NA,3)=NMAX
 100  RETURN
      END
C
C
C
C
C LEVEL 3      SUBROUTINE ADDATM(NAME,IA,XA,ISA,ILA,CELA,N)
      SUBROUTINE ADDATM(NAME,IA,XA,ISA,ILA,CELA,N)
C
C *** ADDATM updated by JCM 9 Jun 91 ***
C
CX
CC 8A
CH Finds an atom in the tables for geometric constraints, or adds it if absent.
CA On entry:
CA          NAME=the atom name, or is empty if a name is to be invented
CA          IA=the number of the base atom from which it is derived
CA          XA(1:3) hold its actual fractional coordinates
CA          ISA is the symmetry operator making it from base (-ve if needed)
CA          ILA is the lattice translation making it from base
CA          CELA(1:3) hold the cell translations making it from base
CA On exit  N=which entry in the atom tables it is
CD Searches for NAME in the existing table; if found, checks that all the
CD other components are the same, and exits with N=where found.
CD If NAME is empty , still does the check on all other components.
CD If not found, counts in NTARNM in /SLKGEO, and adds NAME and all
CD other components to tables, exitting with N=NTARNM
C
      CHARACTER *4 NAME,MAKNAM
      DIMENSION XA(3),CELA(3)
/POSNS/
/SLAKDA/
/SLKGEC/
/SLKGEO
C
C IF NAME IS EMPTY, SEARCH FOR THE REST:
      IF (NAME .EQ. '    ') THEN
        DO 19 I=1,NTARNM
        IF (IABASE(I) .NE. IA) GO TO 19
        DO 18 J=1,3
        IF (CELLTR(J,I) .NE. CELA(J)) GO TO 19
        IF (XSLAK(J,I) .NE. XA(J)) GO TO 19
  18    CONTINUE
        IF (ISYM(I) .NE. ISA) GO TO 19
        IF (ILAT(I) .NE. ILA) GO TO 19
C ATOM FOUND:
        N=I
        GO TO 100
  19    CONTINUE
        GO TO 17
      ENDIF
C
C SEARCH FOR NAME IN THOSE FROM A CARDS:
      N1=IATOM(NAME)
      IF (N1 .LE. 0) GO TO 1
C
      IF (N1 .NE. IA) GO TO 2
      IF (ISA .NE. 1) GO TO 2
      IF (ILA .NE. 1) GO TO 2
      DO 3 I=1,3
      IF (XA(I) .NE. X(I,N1)) GO TO 2
      IF (CELA(I) .NE. 0.) GO TO 2
   3  CONTINUE
C
C ATOM IDENICAL - OK:
      GO TO 1
C
   2  CALL ERRCH2(NAME,1,'L ATOM card name',
     & 'same as one on A card')
      GO TO 100
C
C THIS PUTS EVEN THE ORIGINAL ATOMS INTO THIS TABLE, WHICH IS WHAT WE WANT
C WHEN ACTUALLY APPLYING THE CONSTRAINTS.  WHEN GENERATING CARDS IN SLKGEN
C WE DON'T MIND.
   1  N=0
      IF (NTARNM .GT. 0) N=NCFIND(NAME,ATTNAM,NTARNM)
      IF (N .GT. 0) THEN
        DO 4 I=1,3
        IF (XA(I) .NE. XSLAK(I,N)) GO TO 5
   4    CONTINUE
        GO TO 100
C
   5    CALL ERRCH2(NAME,1,'Name','occurs on 2 L ATOM cards')
        GO TO 100
      ENDIF
C
%  17  CALL ERRCHK(2,NTARNM,%SLAK%,1,'names on L ATOM cards')
      N=NTARNM
C
C IF NO NAME GIVEN, INVENT ONE:
      ATTNAM(N)=NAME
      IF (NAME .EQ. '    ') ATTNAM(N)=MAKNAM('SK0',N)
      IABASE(N)=IA
      DO 7 I=1,3
      CELLTR(I,N)=CELA(I)
   7  XSLAK(I,N)=XA(I)
      ISYM(N)=ISA
      ILAT(N)=ILA
 100  RETURN
      END
C
C
C
C
C LEVEL 3      SUBROUTINE ADDBON(NAME,NA1,NA2,NA)
      SUBROUTINE ADDBON(NAME,NA1,NA2,NA)
C
C *** ADDBON updated by JCM 21 Jul 91 ***
C
CX
CC 8A
CH Finds a bond in the tables for geometric constraints, or adds it if absent.
CA On entry:
CA           NAME is either the bond name, A4, or it is empty, meaning
CA                that the name is irrelevant
CA           NA1 is the number of the atom at one end in the tables
CA           NA2 is the number of the atom at the other end
CA On exit, NA is the number of this bond in the bond tables
CD If a bond already exists in the tables from NA1 to NA2, ignores
CD NAME and sends out NA=its position.
CD If there is no such bond, counts up in NUMBON in /SLKGEO, and adds
CD the new bond.  If in this case NAME is empty, invents a name.
CN The ends of a bond are in IATM(,1:2) with (,1) less than (,2)
C
      CHARACTER *4 NAME,MAKNAM
/CARDRC/
/IOUNIT/
/SLKGEC/
/SLKGEO/
C
C IS BOND ALREADY GIVEN FROM NA1 TO NA2?
      NMIN=MIN(NA1,NA2)
      NMAX=MAX(NA1,NA2)
      DO 1 I=1,NUMBON
      IF (NMIN .EQ. IATM(I,1) .AND. NMAX .EQ. IATM(I,2)) THEN
        IF (NAME .NE. BONNAM(I) .AND. NAME .NE. '    ') THEN
          WRITE (LPT,3000) NAME,BONNAM(I)
          WRITE (ITO,3000) NAME,BONNAM(I)
3000      FORMAT (/' ERROR ** ',A4,' and',A4,' refer to same bond')
          IERR=IERR+1
          GO TO 100
        ENDIF
        NA=I
        GO TO 100
      ENDIF
   1  CONTINUE
C
C NEW BOND - COUNT NUMBER OF INVOLVED BONDS:
%      CALL ERRCHK(2,NUMBON,%SLAK%,1,'bonds for geometric constraints')
C
C CHECK NAME OF BOND DOES NOT CLASH WITH ANY ATOM NAMES:
      L1=0
      IF (NTARNM .GT. 0) L1=NCFIND(NAME,ATTNAM,NTARNM)
      IF (L1 + IATOM(NAME) .GT. 0) THEN
        CALL ERRCH2(NAME,1,'Bond name','is also an atom name')
        GO TO 100
      ENDIF
C
C BOND MAY BE GIVEN WITHOUT A NAME:
      BONNAM(NUMBON)=NAME
      IF (NAME .EQ. '    ') BONNAM(NUMBON)=MAKNAM('Bnd',NUMBON)
      NA=NUMBON
      IATM(NA,1)=NMIN
      IATM(NA,2)=NMAX
 100  RETURN
      END
C
C
C
C
C LEVEL 7      SUBROUTINE ADDCON(NPAR,KK1,AM,NSTAT)
      SUBROUTINE ADDCON(NPAR,KK1,AM,NSTAT)
C
C *** ADDCON corrected by PJB 30-May-1995 ***
C
CX
CC 6C
CH Adds a constraint to the list held in LSQ programs.
CA On entry:
CA          NPAR=number of parameters involved in constraint
CA          KK1 is an array holding the NPAR parameter specs
CA          AM is a corresponding array of amounts
CA          NSTAT is the status to be given to the constraint:
CA   NSTAT=4 : user supplied (may be later removed)
CA   NSTAT=5 : program supplied (may not be later removed)
C
CD Puts the constraint into a standard form, with the KK increasing, and the
CD amount corresponding to the smallest KK as 1.  Thus can tell if it has had
CD this constraint before, and if so merely gives it the new status.
C
CN There is also an entry SUBCON to take one out.  If the first element of
CN KK1 for SUBCON is incomplete, this will scan all constraints looking for
CN any whose KKs are ALL encompassed by KK1(1), and delete them.  It is used
CN to clear out family 4 each cycle for CAILS type refinement
C
      LOGICAL KSAME,KWHOLE,KWIPE
      DIMENSION KK1(NPAR),AM(NPAR)
      DIMENSION KK2(20),KK3(20),AM2(20),KUN(5)
/LENINT/
/LINKAG/
C
C ADDING ENTRY:
      IADD=1
      GO TO 1
C
      ENTRY RELCON(NPAR,KK1,AM,NSTAT)
C ENTRY TO REPLACE AN EXISTING CONSTRAINT:
      IADD=0
      GO TO 1
C
      ENTRY SUBCON(NPAR,KK1,AM,NSTAT)
C SUBTRACTING ENTRY:
      IADD=-1
C
C DISCOVER IF WIPING WHOLE SET:
   1  KWIPE=.NOT. (KWHOLE(KK1(1),KUN))
      IF (KWIPE) GO TO 5
C
C PUT INTO STANDARD FORM OF ASCENDING KK WITH NEW AM(1)=1.:
      CALL JGMEQ(KK1,KK2,1,NPAR)
      DO 2 I=1,NPAR
      KK3(I)=MINIM(KK2,NPAR,N)
      AM2(I)=AM(N)
      IF (I .GT. 1) AM2(I)=AM2(I)/AM2(1)
      KK2(N)=2**(NBITS-1)-1
   2  CONTINUE
      AM2(1)=1.
C
C SCAN EXISTING CONSTRAINTS:
   5  DO 3 I=1,NUMCON
C LOOKING FOR MATCHES:
      KPAR=KPTCON(I+1)-KPTCON(I)
      IF (KPAR .NE. NPAR .AND. .NOT. KWIPE) GO TO 3
      DO 4 J=1,KPAR
      IF (KWIPE) THEN
        IF (.NOT. (KSAME(KK1(1),KKCON(KPTCON(I)+J-1)))) GO TO 3
      ELSE
        IF (KK3(J) .NE. KKCON(KPTCON(I)+J-1)) GO TO 3
C PARAMETER MATCH - NOW COEFFICIENT?
C IF THE NEW CONSTRAINT HAS THE SAME PARAMETERS BUT DIFFERENT COEFFICIENTS..
C THIS CAN MEAN "REMOVE THE OLD ONE AND REPLACE BY THE NEW" (ENTRY RELCON)
C OR SOME INCONSISTENCY LEADING TO A FIXING (ENTRY ADDCON)
        IF (IADD.EQ.0) GO TO 4
        IF (ABS(AM2(J)-AMCON(KPTCON(I)+J-1)) .GT. 0.00001) GO TO 3
      ENDIF
   4  CONTINUE
C
C WE HAVE IT ALREADY - WERE WE ADDING OR SUBTRACTING OR REPLACING?
      IF (IADD) 6,7,101
C
C SUBTRACTING AN EXISTING:
   6  KSTCON(I)=0
      GO TO 3
C REPLACING WITH NEW COEFFICIENTS
    7 DO 8 J=1,KPAR
      AMCON(KPTCON(I)+J-1)=AM2(J)
    8 CONTINUE
      GO TO 101
C
   3  CONTINUE
C
C IF NOT FOUND, BUT SUBTRACTING, EXIT:
      IF (IADD.EQ.-1) GO TO 100
C
C IT IS A REALLY NEW CONSTRAINT - ADD IT:
%      CALL ERRCHK(2,NUMCON,%ALLC%,0,'LSQ constraints')
      KPTCON(NUMCON+1)=KPTCON(NUMCON)+NPAR
      DO 9 I=1,NPAR
      KKCON(KPTCON(NUMCON)+I-1)=KK3(I)
      AMCON(KPTCON(NUMCON)+I-1)=AM2(I)
   9  CONTINUE
      KTPCON(NUMCON)=1
      I=NUMCON
C
C ADDING (OR REPLACING) AN EXISTING JOINS HERE:
 101  KSTCON(I)=NSTAT
C
 100  RETURN
      END
C
C
C
C
C LEVEL 2       SUBROUTINE ADDELM(ITAB,IEL,IJTAB,NUM)
      SUBROUTINE ADDELM(ITAB,IEL,IJTAB,NUM)
C
C *** ADDELM new by PJB C141 March 2006
C
CC 1A
CH Adds the element IEL to the subgroup defined by ITAB
CA On Entry ITAB is a teble in which ITAB(I) is non-zero if element I is
CA               in the subgroup. TAB(I) is negative if only the centric partner
CA               is in the subgroup.
CA          IEL is the operator nomber of the element to add
CA On Exit  IJTAB is a table similar to ITAB for the subgroup with IEL added.

%      DIMENSION ITAB(*),IJTAB(*),JTAB(%SYMO%)
      LOGICAL NEW
/IOUNIT/
/NSYM/
/SYMTAB/
C
      CALL JGMEQ(ITAB,JTAB,NOPC,1)
      JTAB(IABS(IEL))=ISIGN(1,IEL)
C Complete the  group
    1 NEW=.FALSE.
      DO 2 K=2,NOPC
      IF (JTAB(K) .EQ. 0) GO TO 2
      DO 3 J=2,NOPC
      IF (JTAB(J) .EQ. 0) GO TO 3
      JK=MULTAB(J,K)
C      write ( lpt,1000) k,j,jk,jtab(jk)
C 1000 format ('Addelm: ',5i5)
      IF (JTAB(JK) .NE. 0) GO TO 3
      NEW=.TRUE.
C To get the sign right
      JTAB(JK)=JTAB(J)*JTAB(K)
   3  CONTINUE
   2  CONTINUE
      IF (NEW) GO TO 1
C
C Count the elements
      NUM=0
      DO 4 K=1,NOPC
      NUM=NUM+IABS(JTAB(K))
    4 CONTINUE
      CALL JGMEQ(JTAB,IJTAB,NOPC,1)
C
      RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE ADDPLN(NIN,N)
      SUBROUTINE ADDPLN(NIN,N)
C
CC 7B
CH A dummy routine at the moment, called when setting slack constraints
      N=N
      NIN=NIN
      RETURN
      END
C
C
C
C
C LEVEL  2      SUBROUTINE ADDSPC(WORD,LWORD)
      SUBROUTINE ADDSPC(WORD,LWORD)
C
C ***  ADDSPC modified by PJB  15-Apr-1997 ***
CC 13c
CH To pad a word with spaces to length lword
C
      CHARACTER *(*)WORD
      L=LENGT(WORD)
      DO 2 I=1,L
C CONTROL CODES END WORD
      IF (ICHAR(WORD(I:I)).LT. 32) THEN
        L=I-1
        GO TO 3
      ENDIF
    2 CONTINUE
    3 DO 1 I=L+1,LWORD
      WORD(I:I)=' '
    1 CONTINUE
      RETURN
      END
C
C
C
C
C LEVEL 5      SUBROUTINE ADDTOR(NAME,N1,N2,N3,N4,N5,N6,NT,IE)
      SUBROUTINE ADDTOR(NAME,N1,N2,N3,N4,N5,N6,NT,IE)
C
C *** ADDTOR corrected by PJB 2-Jan-1996 ***
C
CX
CC 8A
CH Finds a torsion angle in the tables for geometric constraints, or adds it
CH if absent.
CA On entry:
CA           NAME is the torsion angle name, A4, which may be empty
CA           N1 is the number of the first bond of the pair of non-
CA              intersecting bonds between which the angle is required
CA           N2 is the number of the "axis" bond which joins one atom of N1
CA              to one atom of N3
CA           N3 is the number of the other bond of the pair defining the angle
CA           N4 is the number of the "free" bond joining the two other ends
CA              of N1 and N3
CA           N5 is the third side of the triangle formed by N1 and N2
CA           N6 is the third side of the triangle formed by N3 and N2
CA On exit, NT is the number of this angle in the angle names in ANGTOR
CA          IE is an error indicator, =0 if OK
CD If the angle already exists in the tables, ignores NAME and sends out
CD NT=its position.
CD If there is no such angle, counts up in NUMTOR in /SLKGEO, and adds
CD the new angle.  If in this case NAME is empty, invents a name.
CN The bonds N1 and N3 are held in INTOR;  which is which depends on the axis
CN N2, because it must join atoms (say A2 to A3) so that A2 < A3.  A2 is
CN defined to be on N1, and A3 on N3
CN
C
      CHARACTER *4 NAME
/IOUNIT/
/SLKGEC/
/SLKGEO/
C
      N4=N4
      N5=N5
      N6=N6
      IE=0
C IS TORSION ANGLE ALREADY GIVEN BETWEEN N1 AND N3 WITH N2 AS AXIS?
      NMIN=MIN(N1,N3)
      NMAX=MAX(N1,N3)
      DO 1 I=1,NUMTOR
      IF (NMIN .EQ. INTOR(I,1) .AND. N2 .EQ. INTOR(I,2) .AND.
     & NMAX .EQ. INTOR(I,3)) THEN
        IF (NAME .NE. TORNAM(I) .AND. NAME .NE. '    ') THEN
          WRITE (LPT,3000) NAME,TORNAM(I)
          WRITE (ITO,3000) NAME,TORNAM(I)
3000      FORMAT (/' ERROR ** ',A4,' and',A4,
     &    ' refer to same torsion angle')
          IE=1
          GO TO 100
        ENDIF
        NT=I
        GO TO 100
      ENDIF
   1  CONTINUE
C
C NEW ANGLE - COUNT NUMBER OF TORSION ANGLES:
%      CALL ERRCHK(2,NUMTOR,%TANG%,1,'torsion angles for geometric'//
     & ' constraints')
C
C CHECK NAME OF TORSION ANGLE DOES NOT CLASH WITH ANY OTHER NAMES:
      L1=0
      IF (NTARNM .GT. 0) L1=NCFIND(NAME,ATTNAM,NTARNM)
      L2=NCFIND(NAME,BONNAM,NUMBON)
      IF (NUMANG .GT. 0) L3=NCFIND(NAME,ANGNAM,NUMANG)
      IF (L1 + L2 + L3 + IATOM(NAME) .GT. 0) THEN
        CALL ERRCH2(NAME,1,'Torsion angle name','also used elsewhere')
        IE=1
        GO TO 100
      ENDIF
C
C ANGLE MAY NOT BE NAMED:
      IF (NAME .EQ. '    ') THEN
        WRITE (TORNAM(NUMTOR),2000) NUMTOR
2000    FORMAT ('>',I3)
      ELSE
        TORNAM(NUMTOR)=NAME
      ENDIF
      NT=NUMTOR
C
C N2 IS THE AXIS (FROM A2 TO A3):
      INTOR(NT,2)=N2
** N1 MUST JOIN A1 AND A2, AND N3 MUST JOIN A3 AND A4 - BUT I DON'T THINK
** THIS IS VITAL - I BELIEVE IT TO BE ONLY NOMENCLATURE
      INTOR(NT,1)=NMIN
      INTOR(NT,3)=NMAX
C COMPLETE THE TRIANGLE "N1", N2, AND SET K2 TO POINT TO THEIR COMMON ATOM:
      CALL BONTRI(NMIN,N2,INTOR(NT,5),K2,IEE)
C COMPLETE THE TRIANGLE "N3", N2, AND SET K3 TO POINT TO THEIR COMMON ATOM:
      CALL BONTRI(NMAX,N2,INTOR(NT,6),K3,IEEE)
      IE=IEE+IEEE
      IF (IE .EQ. 0) THEN
C IDENTIFY ENDS OF THE "FREE" BOND:
        K1=IATM(NMIN,1)
        IF (K1 .EQ. K2) K1=IATM(NMIN,2)
        K4=IATM(NMAX,1)
        IF (K4 .EQ. K3) K4=IATM(NMAX,2)
C ADD FREE BOND TO LIST:
        CALL ADDBON('    ',K1,K4,INTOR(NT,4))
      ENDIF
 100  RETURN
      END
C
C
C
C
C LEVEL 5      SUBROUTINE ADJUST(PAR)
      SUBROUTINE ADJUST(PAR)
C
C *** ADJUST updated by JCM 11 Jan 88 ***
C
CX
CC 6C
CH Applies a (possibly fudged) shift to a given LSQ parameter.
CA On entry PAR is the parameter to be updated
CP In /NEWOLD/ SHIFT on entry is the shift from the LSQ matrix inversion
CP             IFAM,IGEN,ISPC specify the parameter, also packed in KPACK
CP In /FUDG/ is a list of all required fudge factors and their types
C
CD Sets XOLD = the existing value of PAR
CD Makes a tentative Xby applying SHIFT to XOLD
CD Scans IFDGPT to see if parameter has a fudge;  if so, branches on
CD its type in IFDTYP, and adjusts XNEW accordingly.
CD Finally sets XNEW into the parameter PAR.
C
/FUDG/
/NEWOLD/
C
      XOLD=PAR
      XNEW=XOLD+SHIFT
C EXIT IF NO FUDGES AT ALL:
      IF (NFUDGE .EQ. 0) GO TO 101
C
C
** WE NEED EVENTUAL PROVISION FOR PARTICULAR PHASES & SOURCES:
C PACK FAMILY AND GENUS, NO PARTICULAR SPECIES:
      JFG=KPAK(IFAM,IGEN,0,0,0)
C PACK FAMILY AND SPECIES, NO PARTICULAR GENUS:
      JFS=KPAK(IFAM,0,ISPC,0,0)
C PACK FAMILY ALONE:
      IFAMM=KPAK(IFAM,0,0,0,0)
C PACK GENUS ALONE:
      IGENN=KPAK(0,IGEN,0,0,0)
C PACK SPECIES ALONE:
      ISPCC=KPAK(0,0,ISPC,0,0)
C
C SCAN ALL FUDGES FOR A MATCH WITH ANY OF:
C        COMPLETE SPECIFICATION IN KPACK
C        FAMILY PLUS GENUS IN JFG
C        FAMILY PLUS SPECIES IN JFS
C        FAMILY ALONE IN IFAMM
C        GENUS ALONE IN IGENN
C        SPECIES ALONE IN ISPCC
      DO 1 I=1,NFUDGE
      IF (KPACK .EQ. IFDGPT(I)) GO TO 2
      IF (JFG .EQ. IFDGPT(I)) GO TO 2
      IF (JFS .EQ. IFDGPT(I)) GO TO 2
      IF (IFAMM.EQ. IFDGPT(I)) GO TO 2
      IF (IGENN .EQ. IFDGPT(I)) GO TO 2
      IF (ISPCC .EQ. IFDGPT(I)) GO TO 2
   1  CONTINUE
      GO TO 101
C
C THERE IS A FACTOR:
   2  GO TO (11,12,13,12) , IFDTYP(I)
C
C SIMPLE MULTIPLICATIVE FACTOR:
  11  XNEW=XOLD+FUDGE1(I)*SHIFT
      GO TO 101
C
C LOWER LIMIT FROM "GE" (MAY BE COMBINED WITH UPPER LIMIT):
  12  IF (XNEW .LT. FUDGE1(I)) XNEW=FUDGE1(I)
      IF (IFDTYP(I) .EQ. 2) GO TO 101
C
C UPPER LIMIT FROM "LE":
  13  IF (XNEW .GT. FUDGE2(I)) XNEW=FUDGE2(I)
      GO TO 101
C
 101  PAR=XNEW
      RETURN
      END
C
C
C
C
C LEVEL 2      SUBROUTINE AINOUT(K,KOLD,FBUF,N,N1,MODE)
      SUBROUTINE AINOUT(K,KOLD,FBUF,N,N1,MODE)
C
C *** AINOUT updated by PJB C4.3 Sept 2007 ***
C4.2 KOLD included in call to facilitate changing the number of sort keys
C
CX
CC 2B
CH Multiple function routine called by ARRNGE type programs to
CH process sort items.
CA The function is chosen by MODE:
CA   MODE = 0 Initialise: vector K of length N holds the limits for the
CA            sorting keys. Sets N1 items to be associated with the sorted
CA            quantity.
CA   MODE = 1 Enter the items in FBUF creating the sort key from K
CA   MODE = 2 Sort all items read
CA   MODE = 3 Return the next item from the sorted list in FBUF together with
CA            the unpacked key in K and the number of identically labelled
CA            items in N. N1 is set to indicate the most significant K that
CA            changes after the Nth item.
CA   MODE = 4 Simply return the next item in the sorted list in FBUF and
CA            the number remaining from the same group in N
C
C
      DIMENSION K(*),KOLD(*),FBUF(1),LRPACK(10,3)
/IOUNIT/
%      COMMON /SCRAT/MSORT(%NOBS%),VALUES(%NO*5%),IPOINT(%NOBS%)
C4.3 Save list instead of COMMON arsort
      SAVE NREFS,KEYS,ITEMS,LRPACK,MS,KP,JPOINT,ICOUNT
%      DATA NOBS,NVALS/%NOBS%,%NO*5%/
C
      GO TO (1,11,21,31,41) MODE+1
C
    1 CALL NPACK(I,K,N,0,LRPACK)
      KEYS=N
      ITEMS=N1
      JPOINT=1
      NREFS=0
      GO TO 100
C
   11 CALL ERRCHK(2,NREFS,NOBS,0,'reflections to sort')
      CALL ERRCHK(1,JPOINT+ITEMS,NVALS,0,'values to store for sorting')
      CALL GMEQ(FBUF,VALUES(JPOINT),ITEMS,1)
      JPOINT=JPOINT+ITEMS
      CALL NPACK(MSORT(NREFS),K,KEYS,1,LRPACK)
      GO TO 100
C
   21 IF (NREFS.EQ.0) CALL ERRMES(1,0,'No reflections to sort')
      CALL MESS(ITO,0,'Sort started . . . ')
      CALL SORTN(MSORT,IPOINT,NREFS)
      WRITE (ITO,2001)NREFS
 2001 FORMAT ('+Sort started . . sorted',I4,' records ')
      MS=MSORT(IPOINT(1))
      CALL NPACK(MS,KOLD,KEYS,2,LRPACK)
      KP=1
      N=NREFS
      GO TO 100
C
   31 CALL JGMEQ(KOLD,K,KEYS,1)
      I=1+(IPOINT(KP)-1)*ITEMS
      CALL GMEQ(VALUES(I),FBUF,ITEMS,1)
      N=1
   32 KP=KP+1
      ICOUNT=N
      IF (KP.GT.NREFS) THEN
        N1=0
        GO TO 100
      ENDIF
      IF (MSORT(IPOINT(KP)).NE.MS) THEN
        MS=MSORT(IPOINT(KP))
        CALL NPACK(MS,KOLD,KEYS,2,LRPACK)
        DO 33 I=1,KEYS
        IF (KOLD(I).NE.K(I)) THEN
          N1=I
          GO TO 100
        ENDIF
   33   CONTINUE
      ENDIF
      N=N+1
      GO TO 32
C
   41 ICOUNT=ICOUNT-1
      I=1+(IPOINT(KP-ICOUNT)-1)*ITEMS
      CALL GMEQ(VALUES(I),FBUF,ITEMS,1)
      N=ICOUNT
      GO TO 100
C
  100 RETURN
      END
C
C
C
C
C LEVEL 9      FUNCTION ALAMB2(H,MAG)
      FUNCTION ALAMB2(H,MAG)
C
C *** ALAMB2 new by PJB C4.19 March 2010 ***
C
CH Calculates and returns the half wavelength intensity
CX
CC 2B
CA On entry H is the 1x3 array holding h,k,l
CA MAG is true if magnetic intensity is to be added
CP Expects the extinction coefficients for lambda in CEXT
C
      DIMENSION H(3),H2(3)
      COMPLEX FCALC,FLAM
      LOGICAL MAG
/DGEOM/
/EXTN/
C
      ALAMB2=0
      IF (ALAM2.LE.0) GO TO 100
      CALL GMSCA(H,H2,2.,3,1)
      FLAM=FCALC(H2)
      AINT2=REAL(FLAM*CONJG(FLAM))
      iF (MAG) THEN
        CALL FMCALC(H2,FMC2,FM2SQR)
        AINT2=AINT2 + FM2SQR
      ENDIF
C Factor of 8 for lambda cubed
      ALAMB2=(ALAM2*AINT2)/8.
      if (IEXTYP .NE.0) THEN
C Extinction for lambda/2
        CEXT(1)=CEXT(1)/8.
        CEXT(2)=CEXT(2)/2.
        CALL EXTINC(2,sqrt(aint2))
C Revert to previous in case needed again
        CEXT(1)=CEXT(1)*8.
        CEXT(2)=CEXT(2)*2.
        YLAM2=EXTCOR**2
        ALAMB2=ALAMB2*YLAM2
      ENDIF
  100 RETURN
      END
C
C
C
C
C LEVEL 1      FUNCTION ALNINT(A,B,X,N)
      FUNCTION ALNINT(A,B,X,N)
C
C *** ALNINT by JCM 21 May 85 ***
C
CX
CC 9C
CH Performs linear interpolation, suitable for profile backgrounds etc.
C
CA On entry:
CA     A is a real array of dimension N which holds the arguments
CA     B is a real array of dimension N which holds the function values
CA     X is a real which holds the argument for which the function value
CA       is required
CA     N is the integer dimension of A and B
CA
CA ALINT on exit will hold the function value for argument X
C
      DIMENSION A(N),B(N)
C
      DO 1 I=2,N
      IF (A(I) .GT. X) GO TO 2
   1  CONTINUE
      I=N
   2  ALNINT=(B(I-1)*(A(I)-X)-B(I)*(A(I-1)-X))/(A(I)-A(I-1))
      RETURN
      END
C
C
C
C
C LEVEL 3      SUBROUTINE ALRPOL(H,ALR,POL,MODE)
      SUBROUTINE ALRPOL(H,ALR,POL,MODE)
C
C *** ALRPOL by JCM 24 Sep 85 ***
C
CX
CC 2B
CH Calculates the reciprocals of Lorentz and polarisation factors.
C
CA H is a 3-size real array holding h,k,l on entry
CA ALR on exit will hold the Lorentz factor
CA POL on exit will hold the polarisation factor
CA MODE on entry =1 if wavelength is already in WLGTH (or ALAMBD)
CA               =2 if wavelength is not set, but SINTH holds sin theta,
CA                  and the wavelength will not be required.
C
CP SETDC must have been obeyed to read necessary D cards to COMMON /DGEOM
C
CP SETLP calls SETDC; it also checks that if a monochromator angle is
CP needed it has been supplied, and ANGLIN(2) holds cos sqrd 2 theta
CP monochromator. POL will be modified appropriately.
CP
CP SETDC has set the geometry type into IGEOM;  possible types are:
CP       IGEOM = 1 Normal beam
CP       IGEOM = 2 Normal beam equatorial
CP       IGEOM = 3 Equi-inclination Weissenberg
CP       IGEOM = 6 4 circle bisecting
CP       IGEOM = 7 4 circle angles given
CP       IGEOM = 8 D3
CP       IGEOM = 9 Powder data, no polarisation
CP       IGEOM = 10 Powder data, X ray
CP       IGEOM = 11 4 circle high chi
CP       IGEOM = 12 SXD geometry
C
      DIMENSION H(3),OH(3),UL(3)
/DGEOM/
/IOUNIT/
C
C REFER H TO STANDARD ORTHOGONAL AXES IN OH, AND MAKE IT A UNIT VECTOR:
      CALL ORTHO(H,OH,2)
      CALL UNIVEC(OH,AK)
C MODE 2 ALLOWS FOR SINTH ALREADY SET ON INPUT (USEFUL IF NO SPECIFIC WLGTH)
      IF (MODE .NE. 2) SINTH = WLGTH*AK*0.5
      CALL SINCOS(SINTH,COSTH,'LP 1')
C THE CORE OF THE LORENTZ CORRECTION IS SIN 2 THETA:
      SIN2TH = 2.*SINTH*COSTH
      ALR=SIN2TH
C NOW ADJUST FOR PARTICULAR IGEOM:
      GO TO (1,2,3,4,4,2,2,8,9,9) , IGEOM
C
   4  CALL ERRIN2(IGEOM,0,'Geometry type','not avaiable in ALRPOL')
C
C NORMAL BEAM:
   1  CALL GMEQ(UM(1),UL,1,3)
      GO TO 6
C
C EQUI-INCLINATION WEISSENBERG:
   3  CALL GMEQ(UM(1),UL,1,3)
      CSPHI=SCALPR(OH,UL)
      CALL SINCOS(CSPHI,SNPHI,'LP 3')
      ALR=ALR*SNPHI
      GO TO 2
C
C D3:
   8  DO 11 I=1,3
  11  UL(I)=UM(I*3)
   6  CSPHI=SCALPR(OH,UL)
      SNRHO=CSPHI/COSTH
      IF (ABS(SNRHO-1.) .LT.  10.E-4) GO TO 5
      ALR=0.
      POL=0.
      WRITE (LPT,3001) H
      WRITE (ITO,3001) H
3001  FORMAT (' WARNING ** REFLEXION',3F4.0,' SHOULD NOT OCCUR')
      GO TO 100
C
   5  CALL SINCOS(SNRHO,CSRHO,'LP 2')
      ALR=ALR*CSRHO
      GO TO 2
C
C  POWDER DATA:
   9  ALR=ALR*SINTH
      GO TO 2
C
C POLARISATION CORRECTION:
   2  GO TO (21,22,22,4,4,22,22,21,29,22), IGEOM
C
C NO POLARISATION:
  29  POL=1.
      GO TO 100
C
C RHO = 0:
  22  CSQRHO=1.
      SSQRHO=0.
      GO TO 20
C
C RHO ALREADY SET UP IN LORENTZ CALCULATION:
  21  CSQRHO=CSRHO*CSRHO
      SSQRHO=SNRHO*SNRHO
C
C SET COS2TH = COS 2 THETA
  20  CALL SINCOS(SIN2TH,COS2TH,'LP 5')
      POL = (1. +ANGLIN(2))/((SSQRHO+ANGLIN(2)*CSQRHO)*COS2TH*COS2TH +
     & CSQRHO + ANGLIN(2)*SSQRHO)
 100  RETURN
      END
C
C
C
C
C LEVEL 4      SUBROUTINE ANGDIR(H,ANG)
      SUBROUTINE ANGDIR(H,ANG)
C
C *** ANGDIR by PJB Sep 87 ***
C
CX
CC 2B
CH Calculates D3 or  4-circle angles from direction cosines.
CA On entry H (of dimension 3) holds h,k,l for the required reflection
CA On exit, ANG (of dimension 4) must hold some useful useful afgles.
CP SETDC must have set IGEOM, UM matrix, NLR for left/right
CN Only written for geometry types 6,7,8,11
C
      DIMENSION DIR(3,2),V(3,2),H(3),ANG(4),T(3),XP(3),TT(3)
/DGEOM/
C
      GO TO (50,50,50,50,50,10,10,10,50,50,10), IGEOM
C
C ERROR IN GEOMETRY TYPE:
  50  CALL ERRIN2(IGEOM,0,'Geometry type',
     & 'not in ANGDIR; only 4circle 6,7,11 or general normal beam 8')
C
   10 CALL GETDC(H,DIR)
      DO 1 I=1,2
      CALL GMPRD(UM,DIR(1,I),V(1,I),3,3,1)
    1 CONTINUE
C  REVERSE INCIDENT BEAM
      CALL GMREV(V(1,1),V(1,1),1,3)
C
      COSY=SCALPR(V(1,1),V(1,2))
      ANG(1)=-SIGN(ARCCOS(COSY),FLOAT(NLR))
      GO TO (50,50,50,50,50,20,20,11,50,50,20), IGEOM
C
C  GENERAL NORMAL BEAM CASE
   11 ANG(2)=ATAN2(V(1,1),V(2,1))
      X=V(3,2)
      V(3,2)=0.
      CALL UNIVEC(V(1,2),D)
      ANG(3)=ATAN2(X,D)
      GO TO 100
C
C  FOUR-CIRCLE
C MAKE T THE VERTICAL DIRECTION IN THE DIFFRACTING POSITION
   20 CALL VECPRD(V(1,2),V(1,1),T)
      CALL UNIVEC(T,D)
C  CHI FROM Z COORDINATE OF T
      ANG(3)=ARCCOS(T(3))
C  TT IS THE NORMAL TO THE CHI CIRCLE (T X Z)
      TT(1)=-T(2)
      TT(2)=T(1)
      TT(3)=0.
      CALL UNIVEC(TT,D)
C  TEST IF TT IS ON THE SAME SIDE AS INCIDENT BEAM
      CS2=SCALPR(TT,V(1,1))
      IF (CS2.LT.0) THEN
        ANG(3)=-ANG(3)
C  IF NOT REVERSE IT AND CHI
        CALL GMREV(TT,TT,3,1)
      ENDIF
      CALL VECPRD(V(1,1),TT,XP)
      SCS2=SCALPR(T,XP)
      ANG(2)=ARCCOS(ABS(CS2))
      IF (SCS2.LT.0) ANG(2)=-ANG(2)
      ANG(4)=ATAN2(-TT(2),TT(1))
      IF (ABS(NLR).EQ.1) GO TO 100
C  REVERSE ALL ANGLES IF NECESSARY
      CALL GMREV(ANG,ANG,1,4)
      GO TO 100
C
  100 RETURN
      END
C
C
C
C
C LEVEL 5      SUBROUTINE ANGERS(I1,NB1,NB2,COSANG,ANGER)
      SUBROUTINE ANGERS(I1,NB1,NB2,COSANG,ANGER)
C
C *** ANGERS corrected by PJB C98 Oct-2000 ***
C
CC 8B
CH To calculate esd's in bond angles
C
CA On Entry I1 is the number of the central atom
CA    NB1 and NB2 are the numbers of the two bonds in the bond list held
CA       in BONDLA
CA    COSANG is the cosine of the angle between them
CA    IATS and IOP hold information about the previous call to ANGERS
CA       (to avoid unnecessary duplication of calculations)
CA On exit ANGER is the ESD in the angle in degrees
CP This subroutine is expected to be called just after an angle calculation
CP it uses data in common BONDLA which is set up by BNDLST
      DIMENSION KSPEC(6),IS(2),M(2),
     &AEXVEC(9),RLMAT(9,9),XB(3,3),TVEC(6),IPT(3,3),
     &AECVEC(6),SPCVEC(6),SPXVEC(9)
      CHARACTER *16 CH
      LOGICAL NEW(3)
/BANERR/
/BONDLA/
/CELFIX/
/CELPAR/
/POSNS/
       DATA IPT/1,6,5,6,2,4,5,4,3/
C
      NEW(1)=I1.NE.IATS(1)
      IATS(1)=I1
      NB=NB1
      DO 33 I=1,2
      IF (N2SAVE(NB).LT.0) THEN
        CALL ATSPEC(-N2SAVE(NB),KSPEC,CH)
        IS(I)=KSPEC(2)
      ELSE
        KSPEC(1)=N2SAVE(NB)
        IS(I)=1
      ENDIF
      NEW(I+1)=KSPEC(1).NE.IATS(I+1)
      IATS(I+1)=KSPEC(1)
      NB=NB2
      IF (.NOT. ATESDS) GO TO 30
   33 CONTINUE
      DO 1 I=1,3
      IF (NEW(I)) THEN
        CALL RELPOS(IATS(I),IPFIX(1,I),APFIX(1,I))
        IF (I.EQ.1) CALL RELMT3(IPFIX(1,1),APFIX(1,1),1,RELMT(1,1,I))
      ENDIF
    1 CONTINUE
      IF (IOP(1).NE. IS(1)) THEN
        IOP(1)=IS(1)
        CALL RELMT3(IPFIX(1,2),APFIX(1,2),IOP(1),RELMT(1,1,2))
      ENDIF
      IF (IOP(2).NE. IS(2)) THEN
        IOP(2)=IS(2)
        CALL RELMT3(IPFIX(1,3),APFIX(1,3),IOP(1),RELMT(1,1,3))
      ENDIF
      CALL RELMTX(RELMT,RLMAT,IATS,3)
C
C GET ALL THREE BONDVECTORS
   30 CALL GMEQ(DXSAVE(1,NB1),XB(1,1),3,1)
      CALL GMEQ(DXSAVE(1,NB2),XB(1,2),3,1)
      CALL GMSUB(XB(1,1),XB(1,2),XB(1,3),3,1)
C FORM THE WEIGHTING FACTORS
      A1=BSAVE(NB1)/BSAVE(NB2)
      A2 = A1 - (1./A1)
      A3=(BSAVE(NB1)*BSAVE(NB2))
      CC = SQRT(BSAVE(NB1)**2 + BSAVE(NB2)**2 - COSANG*A3)
C TVEC GIVES THE MULTIPLIERS OF THE DIFFERENTIAL OF COSANG WRT THE BOND VACTORS
      TVEC(1)= 0.5*A1/BSAVE(NB1)
      TVEC(2)=-(0.5*A1/BSAVE(NB2))
      TVEC(3)=CC/A3
C TTHEN MULTIPLY BY THE DIFFERENTIAL OF EACH BOND VECTOR WRT TO
C THE PARAMETERS
      TVEC(1) = TVEC(1)*0.5/BSAVE(NB1)
      TVEC(2) = 0.5*TVEC(2)/BSAVE(NB2)
      TVEC(3) = 0.5*TVEC(3)/CC
C now sum over all the scalar products for coordinate errors (SPXVEC)
C and those for lattice parameter errors SPCVEC
      CALL GMZER(SPXVEC,9,1)
      CALL GMZER(SPCVEC,6,1)
C Outer loop over the three bonds
      DO 2 IB=1,3
      IF (IB.NE.1) THEN
        M(1) = 1
        M(2) = 2
        IF (IB.EQ.2) M(2) = 3
      ELSE
        M(1) = 2
        M(2) = 3
      ENDIF
C 1st xyz coordinate in product
      DO 3 I=1,3
C 2nd xyz coordinate in product
      DO 4 J=1,3
C SPCVEV acumulates the differentials with respect to the lattice constants
C stored by cpar labels
      IF (SDCELL) THEN
        TERM=XB(I,IB)*XB(J,IB)*TVEC(IB)
        IF (I.EQ.J) TERM = 2.*TERM
        SPCVEC(IPT(I,J))=SPCVEC(IPT(I,J)) + TERM
      ENDIF
C Sum over the two positions in each bond
      IF (ATESDS) THEN
        SIG = -1
        DO 5 JX=1,2
C II is the offset of the parameters of atom M(jx) in the 9-vector
        II=3*(M(JX)-1)
C SPXVEC acumulates the differentials of scalar products with respect to the
C atom coordinates stored by parameter labels
        FAC= TVEC(IB)*CPARS(IPT(I,J),1)
        IF (I.EQ.J) FAC = 2.*FAC
        SPXVEC(II+I)=SPXVEC(II+I) + XB(J,IB)*FAC
C THE SIGN OF THE DIFFERENTIAL IS CHANGED FOR THE SECOND ATOM POS
        SIG = -SIG
    5   CONTINUE
      ENDIF
    4 CONTINUE
    3 CONTINUE
    2 CONTINUE
      IF (ATESDS) CALL GMPRD(SPXVEC,RLMAT,AEXVEC,1,9,9)
      IF (SDCELL) CALL GMPRD(SPCVEC,RCLMAT,AECVEC,1,6,6)
      ANXERR=0.
      ANCERR=0.
      II=1
      DO 7 I=1,3
      DO 8 J=1,3
      IF (ATESDS) ANXERR=ANXERR+((AEXVEC(II)*SDX(J,I))**2)
      IF (SDCELL .AND. J.LE.I) THEN
        ANCERR=ANCERR+
     &  ((AECVEC(IPT(I,J))**2)*CELESD(IPT(I,J),IPT(I,J),1))
      ENDIF
      II=II+1
    8 CONTINUE
    7 CONTINUE
      COSERR=SQRT(ANCERR+ANXERR)
      CALL SINCOS(COSANG,SINANG,'ANGERS')
      IF (SINANG.LT. .01) THEN
C NUMERICAL DIFFERENTIAL IN THIS CASE
        CALL SINCOS(ABS(COSANG)-COSERR,SERR,'ANGER2')
        ANGER = DEGREE(SERR-SINANG)
      ELSE
        ANGER=DEGREE(COSERR/SINANG)
      ENDIF
      RETURN
      END
C
C
C
C
C LEVEL 5      SUBROUTINE ANGLST(I1)
      SUBROUTINE ANGLST(I1)
C
C *** ANGLST updated by PJB  22nd Apr 2003 C123 ***
C
CX
CC 8B
CH Lists all angles at one source atom made by a given list of bonds.
C
CA I1 is the number of the source atom (which will belong to the original list)
C
CP A list of bonds starting from atom I1 must be in COMMON /BONDLA.
CP There will be NB bonds stored in BSAVE, with the specifications of the
CP destination atoms in N2SAVE (held negatively if the atom is not in
CP the original list, but a symmetry relation), and the coordinate differences
CP in DXSAVE.
C
CD If there are at least 2 bonds, scans all pairs of bonds & prints out the
CD angle at atom I1 between the pair.  Destination atoms may be in any of
CD the 27 cells around the central asymmetric unit.
C
CO Writes to unit LPT the list of angles, with specifications of destination
CO        atoms if not original
CO Machine readable list of angles and their specs written to LBOND if it is
CO  non-zero
C
      CHARACTER *16 CH1,CH2
      DIMENSION K1(6),K2(6),XD1(3),XD2(3)
/ATNAM/
/BANERR/
/BONDLA/
/IOUNIT/
/POSNS/
/SLKGEC/
/SLKGEO/
C
      CALL JGMZER(IATS,3,1)
      CALL JGMZER(IOP,2,1)
      IF (NB.LE.1) GO TO 100
      IF (NB.EQ.2) CALL MESS(LPT,1,'Angle at atom '//ATNAME(I1)//' :')
      IF (NB.GT.2) CALL MESS(LPT,1,
     & 'Angles around atom '//ATNAME(I1)//' :')
      CALL MESS(LPT,0,'At1-At2-At3      Angle       Atom1 if not'//
     & ' original                  Atom3 if not original')
      DO 1 I=1,NB
      II=I+1
      IF (II .GT. NB) GO TO 1
      DO 2 J=II,NB
      COSTH = SCLPRD(DXSAVE(1,I),DXSAVE(1,J),1)/(BSAVE(I)*BSAVE(J))
      CALL SINCOS(COSTH,SINTH,'ANGLST')
      ANG = DEGREE(ATAN2(SINTH,COSTH))
      IF (ANGESD) CALL ANGERS(I1,I,J,COSTH,ANGERR)
C
C IF SLACK CONSTRAINTS BEING OUTPUT, ANG MAY BE NEEDED HERE:
      IF (.NOT. SLK) GO TO 42
      IF (ANG .GT. ANG1+SD1 .OR. ANG .LT. ANG1-SD1) GO TO 42
C
C PICK UP BONDS SURROUNDING ANGLE & MAKE 3RD BOND OF TRIANGLE:
      NB1=NBSAVE(I)
      NB2=NBSAVE(J)
      CALL BONTRI(NB1,NB2,NB3,NA,IE)
      N=NUMANG
      CALL ADDANG('    ',NB3,NB1,NB2,NANG,IE)
      IF (NANG .GT. N) WRITE (LSK,2020) ANGNAM(NANG),
     & BONNAM(NB1),BONNAM(NB2),ANG2,SD2
2020  FORMAT ('L ANGL ',3(A4,2X),F10.2,F10.3)
C
  42  IF ((N2SAVE(I) .LT. 0) .OR. (N2SAVE(J) .LT. 0)) GO TO 3
      IF (ANGESD) THEN
        WRITE (LPT,2015)ATNAME(N2SAVE(I)),ATNAME(I1),ATNAME(N2SAVE(J)),
     &ANG,ANGERR
2015  FORMAT (1X,A4,'-',A4,'-',A4,F8.2,'+/-',F5.2)
      ELSE
        WRITE (LPT,2002)ATNAME(N2SAVE(I)),ATNAME(I1),ATNAME(N2SAVE(J)),
     &ANG
2002  FORMAT (1X,A4,'-',A4,'-',A4,F9.2)
      ENDIF
      GO TO 2
C
C ONE OR BOTH ATOMS NEED FURTHER SPECIFICATION:
   3  DO 4 K=1,3
      XD2(K)=X(K,I1)
C TAKEN OUT C41:
C      CALL FRACT(XD2(K),Y,N)
      XD1(K)=XD2(K)-DXSAVE(K,I)
      XD2(K)=XD2(K)-DXSAVE(K,J)
   4  CONTINUE
C UNPACK SPECIFICATIONS:
      IF (N2SAVE(I) .LT. 0) CALL ATSPEC(-N2SAVE(I),K1,CH1)
      IF (N2SAVE(J) .LT. 0) CALL ATSPEC(-N2SAVE(J),K2,CH2)
      IF (ANGESD) THEN
        IF (N2SAVE(J) .GT. 0) THEN
        WRITE (LPT,2011) ATNAME(K1(1)),ATNAME(I1),ATNAME(N2SAVE(J))
     &  ,ANG,ANGERR,CH1,XD1
         IF (LBOND .NE. 0) WRITE (LBOND,2014)
     &   ATNAME(K1(1)),ATNAME(I1),ATNAME(N2SAVE(J)),ANG,ANGERR
        ENDIF
2011  FORMAT (1X,A4,'-',A4,'-',A4,F8.2,'+/-',F5.2,2X,A16,3F8.4)
C123 Include writing machine readable o/p to LBOND if it is non-zero
        IF (N2SAVE(I) .GT. 0) THEN
          WRITE (LPT,2013) ATNAME(N2SAVE(I)),ATNAME(I1),ATNAME(K2(1)),
     &    ANG,ANGERR,CH2,XD2
           IF (LBOND .NE. 0) WRITE (LBOND,2014)
     &     ATNAME(N2SAVE(I)),ATNAME(I1),ATNAME(K2(1)),ANG,ANGERR
        ENDIF
2013  FORMAT (1X,A4,'-',A4,'-',A4,F8.2,'+/-',F5.2,44X,A16,3F8.4)
        IF ((N2SAVE(I) .LT. 0) .AND. (N2SAVE(J) .LT. 0)) THEN
        WRITE (LPT,2012)ATNAME(K1(1)),ATNAME(I1),ATNAME(K2(1)),
     &  ANG,ANGERR,CH1,XD1,CH2,XD2
        IF (LBOND .NE. 0) WRITE (LBOND,2014)
     &  ATNAME(K1(1)),ATNAME(I1),ATNAME(K2(1)),ANG,ANGERR
         ENDIF
2012  FORMAT (1X,A4,'-',A4,'-',A4,F8.2,'+/-',F5.2,2X,A16,3F8.4,2X,
     &  A16,3F8.4)
2014   FORMAT ('Angle: ',3(A4,1X),2F8.2)
      ELSE
      IF (N2SAVE(J) .GT. 0) THEN
        WRITE (LPT,2001) ATNAME(K1(1)),ATNAME(I1),ATNAME(N2SAVE(J)),
     & ANG,CH1,XD1
        IF (LBOND .NE. 0) WRITE (LBOND,2014)
     &   ATNAME(K1(1)),ATNAME(I1),ATNAME(N2SAVE(J)),ANG,ANGERR
      ENDIF
2001  FORMAT (1X,A4,'-',A4,'-',A4,F9.2,2X,A16,3F8.4)
      IF (N2SAVE(I) .GT. 0) THEN
        WRITE (LPT,2003) ATNAME(N2SAVE(I)),ATNAME(I1),ATNAME(K2(1)),
     & CH2,XD2
        IF (LBOND .NE. 0) WRITE (LBOND,2014)
     &  ATNAME(N2SAVE(I)),ATNAME(I1),ATNAME(K2(1)), ANG
      ENDIF
2003  FORMAT (1X,A4,'-',A4,'-',A4,F9.2,44X,A16,3F8.4)
      IF ((N2SAVE(I) .LT. 0) .AND. (N2SAVE(J) .LT. 0)) THEN
        WRITE (LPT,2010) ATNAME(K1(1)),ATNAME(I1),ATNAME(K2(1))
     & ,ANG,CH1,XD1,CH2,XD2
        IF (LBOND .NE. 0) WRITE (LBOND,2014)
     & ATNAME(K1(1)),ATNAME(I1),ATNAME(K2(1)),ANG
      ENDIF
2010  FORMAT (1X,A4,'-',A4,'-',A4,F9.2,2X,A16,3F8.4,2X,A16,3F8.4)
      ENDIF
   2  CONTINUE
   1  CONTINUE
 100  RETURN
      END
C
C
C
C
C LEVEL 3      FUNCTION ANGRAD(A,B,IR)
      FUNCTION ANGRAD(A,B,IR)
C
C *** ANGRAD by JCM 26 Sep 84 ***
C
CX
CC 1B
CH Calculates the angle in radians between two vectors, in either space.
C
CA A is a real 3-sized array which on entry holds the first vector
CA B is a real 3-sized array which on entry holds the second vector
CA IR on entry =1 for real space, 2 for reciprocal
C
CP RECIP must have set up the cell parameters.
CD ANGRAD on exit is set to be the angle in radians between vectors A and B.
CD Uses -A.B/moduli if real space, because expects A and B to be plane
CD normals, and the required angle to be between planes.
C
      DIMENSION A(3),B(3)
C
      C=SCLPRD(A,B,IR)
      C=C/(VCTMOD(1.0,A,IR)*VCTMOD(1.0,B,IR))
      IF (IR .EQ. 1) C=-C
      ANGRAD=ARCCOS(C)
      RETURN
      END
C
C
C
C
C LEVEL 1      FUNCTION ANITF(H,N)
      FUNCTION ANITF(H,N)
C
C *** ANITF by JCM 19 Jul 83 ***
C
CX
CC 4B
CH Forms the contribution to the anisotropic temperature factor on an
CH atom N from indices H.
C
CA H is a 3-size real array holding h,k,l on entry
CA N on entry = which atomic position
C
CP SETANI must have been obeyed to set up in the COMMON /ANISO:
CP      IAPT(N) =I for 'Nth atom has Ith temperature factor in array ATF', or
CP              =0 for 'Nth atom has no anisotropic temperature factor.
CD SETANI has converted the user's coefficients to standard betas in the array
CD ATF, in the expression \$exp-(\beta_{11}h^{2} + 2\beta_{23}kl + \cdots)\$ so that
CD ANITF need use only this single expression.
CN Note the 2's in the expression.
C
      DIMENSION H(3)
/ANISO/
C
      IA=IAPT(N)
      ANITF=1.
      IF (IA .EQ. 0) GO TO 100
C OUT IF NO ATF ON THIS ATOM
      A=ATF(1,IA)*H(1)*H(1)+ATF(2,IA)*H(2)*H(2)+ATF(3,IA)*H(3)*
     & H(3)+2.*ATF(4,IA)*H(2)*H(3)+2.*ATF(5,IA)*H(1)*H(3)+2.*ATF(6,IA)*
     & H(1)*H(2)
      ANITF=EXP(-A)
 100  RETURN
      END
C
C
C
C
C LEVEL 7      SUBROUTINE APSHDS
      SUBROUTINE APSHDS
C
C *** APSHDS updated PJB 4-Apr-2001 ***
C
CX
CC 7B
CH Applies shifts for during d-spacing refinement.
C
CP Only of use from MAIN program DSLSQ,DSMLSQ, or similar;
CP only expects one family of parameters, containing the 6 reciprocal cell
CP quadratic products and the three components of the propagation vector.
CP Expects shifts (one for each basic variable) in array BLSQ, with
CP corresponding ESDs in array DERIVB.
C
CD Applies shifts, possibly fudged, dealing with
CD constraints if necessary.  Recalculates all cell quantities and
CD if the propagation vector has changed, calls REINDX to reindex
CD the reflection indices in /REFLNS/
C
CO Writes to LPT the old and new values, the shift and its esd.
C
      DIMENSION DPROP(3)
      LOGICAL NPROP
      CHARACTER *4 LNAM1,LNAM2
      CHARACTER*32 VFORM
/CELPAR/
/DERBAS/
/DERVAR/
/IOUNIT/
/MATDAT/
/NEWOLD/
/POINTS/
/REFINE/
/SATELL/
C
      WRITE (LPT,2000) ICYC
2000  FORMAT (/////'1Shifts in variables for cycle',I3/
     & '  Variable      New       Esd      Shift      Old',
     &'    Shift/Esd')
C
C
C INITIALISE SHIFT COUNT AND SUMS
      CALL FETSHF(0,0.,0.)
C CLEAR PROPAGATION VECTOR SHIFT
      CALL GMZER(DPROP,3,1)
      NPROP=.FALSE.
C
C CYCLE OVER VARIABLES
      DO 1 I=1,LVARV
      J=LVRBS(I)
      KPACK=LVRPR(I)
C IF VARIABLE IS BASIC:
      IF (J .GT. 0) THEN
        SHIFT=BLSQ(J)
        ESD=DERIVB(J)
C OTHERWISE IT IS REDUNDANT, BY CONSTRAINT NUMBER -J:
      ELSE
        CALL SHFESD(-J)
      ENDIF
C
      CALL FETSHF(2,SHIFT,ESD)
      CALL PARNAM(LNAM1,LNAM2,3,KPACK)
      CALL PUNPAK(KPACK,IFAM,IGEN,ISPC)
      IF (ISPC.LT.6) THEN
        CALL ADJUST(CPARS(ISPC,2))
      ELSE
        CALL ADJUST(PROP(ISPC-6))
        DPROP(ISPC-6)=SHIFT
        NPROP=.TRUE.
      ENDIF
        WRITE (VFORM,2006) NSIGFG(ESD)
        WRITE (LPT,VFORM) LNAM1,LNAM2,XNEW,ESD,SHIFT,XOLD,SHESD
 2006   FORMAT ('(2X,A4,1X,A4,4F10.',I1,'F10.3)')
   1  CONTINUE
      CALL FETSHF(3,SHIFT,ESD)
C RECALCULATE OTHER CELL-RELATED QUANTITIES:
      CALL RECELL(1,1)
      IF (NPROP) CALL REINDX(DPROP)
      RETURN
      END
C
C
C
C
C LEVEL 7      SUBROUTINE APSHFW
      SUBROUTINE APSHFW
C
C *** APSHFW updated by JCM 10 Feb 87 ***
C
CX
CC 7B
CH Applies shifts for Forsyth & Wells scattering factor coefficient
CH refinement.
CP Only useful if called from FWLSQ or similar.
CD Scans variables, applies shifts with possible fudges.
CO Prints new value, shift, esd and old value.
C
      CHARACTER *4 LNAM1,LNAM2
/DERBAS/
/DERVAR/
/FWVALS/
/IOUNIT/
/MATDAT/
/NEWOLD/
/POINTS/
/REFINE/
C
      WRITE (LPT,2000) ICYC
2000  FORMAT (/////'1Shifts in variables for cycle',I3/
     & '   Variable       New           Esd          Shift        ',
     & '  Old    ')
      DO 1 I=1,LVARV
      J=LVRBS(I)
      KPACK=LVRPR(I)
      CALL PARNAM(LNAM1,LNAM2,3,KPACK)
      SHIFT=BLSQ(J)
      ESD=DERIVB(J)
      CALL ADJUST(COEFFS(I))
      COEFFS(I)=XNEW
      WRITE (LPT,2001) LNAM1,LNAM2,XNEW,ESD,SHIFT,XOLD
2001  FORMAT (' ',1X,A4,1X,A4,4G14.5)
   1  CONTINUE
      RETURN
      END
C
C
C
C
C LEVEL 8      SUBROUTINE APSHSF(MAGSHF)
      SUBROUTINE APSHSF(MAGSHF)
C
C *** APSHSF updated by PJB C4.26 new par in MAGSHF March 2013 ***
C
CX
CC 7B
CH Applies shifts to all variables in single crystal structure factor based
CH LSQ, and prints the results.
CA On entry MAGSHF is the name of a routine which applies shifts to magnetic
CA parameters.  It is LDUMMY for non-magnetic applications.
CP Shifts are in array BLSQ, and ESDs in DERIVB (to save space)
C
CD Identifies each variable as a type of parameter, and call individual
CD routines to apply shift (possibly fudged).
C
CD For redundant variables, calculates shift from constituent parts of
CD relevant constraint.
C
CO Prints old and new values, shift and esd, with parameter name
CO If family 2 (structure parameter), does printing in blocks
C
      EXTERNAL MAGSHF
      DIMENSION DUM(4)
      CHARACTER *4 LNAM1,LNAM2
      CHARACTER *80 VFMT
      LOGICAL HEAD,SHFCEL,MAGSHF,CLAIMD
/ATBLOC/
/ATBLOK/
/DERBAS/
/DERVAR/
/IOUNIT/
/MATDAT/
/NEWOLD/
/POINTS/
/REFINE/
C
      DATA VFMT/'(1X,2(1X,A4),4F14.5,F14.4)'/
C
      IF (SIMUL) GO TO 100
      WRITE (LPT,2000) ICYC
2000  FORMAT (/////'1Shifts in variables for cycle',I3)
C
C SET UP QUANTITIES TO USE WITH DIFFERENT STYLES OF OUTPUT:
      IG=0
      IBUFF=0
      IFAMO=0
      HEAD=.FALSE.
C SET NO CELL SHIFTS:
      SHFCEL=.FALSE.
C CLEAR SHIFT AVERAGING:
      CALL FETSHF(1,0.,0.)
C
C SCAN ALL VARIABLES:
      DO 1 I=1,LVARV
      J=LVRBS(I)
      KPACK=LVRPR(I)
C IF VARIABLE IS BASIC:
      IF (J .GT. 0) THEN
        SHIFT=BLSQ(J)
        ESD=DERIVB(J)
C OTHERWISE IT IS REDUNDANT, BY CONSTRAINT NUMBER -J:
      ELSE
        CALL SHFESD(-J)
      ENDIF
C
      CALL PUNPAK(KPACK,IFAM,IGEN,ISPC)
      NEWFAM=0
      IF (IFAM .NE. IFAMO) THEN
        NEWFAM=1
C139 Check whether we need to clear up previous family
C4.26 extra dummy arg in MAGSHF
        CLAIMD=MAGSHF(IFAMO,8,DUM)
      ENDIF
      IFAMO=IFAM
      IF (J .LT. 0 .AND. IFAM .EQ. 2 .AND. ISPC .EQ. 10) GO TO 1
C
C BRANCH ON FAMILY:
      GO TO (11,12), IFAM
      GO TO 99
C
  11  GO TO (21,22) , IGEN
      GO TO 99
C
C FAMILY 1, GENUS 1 - MISCELLANEOUS SPECIES (TFAC,A*,B* . . F*,DOMR,MOSC):
  21  GO TO (31,32,32,32,32,32,32,33,33,33,33,33) , ISPC
      GO TO 99
CC
C TFAC:
  31  CALL LLTFAC(3)
      GO TO 40
C
C DOMR OR MOSC OR FOVLP (EXTINCTION CORRECTION PARAMETERS)
  33  CALL EXTIN3(ISPC-7)
      GO TO 40
C
C CELL PARAMETERS:
  32  CALL CELSHF(ISPC-1)
      SHFCEL=.TRUE.
      GO TO 40
C
C FAMILY 1, GENUS 2 - IN SF THIS IS 'SCAL':
  22  CALL LLSCAL(3)
      GO TO 40
C
C FAMILY 2 - THESE ARE ALL TO DO WITH THE STRUCTURE FACTOR:
  12  IF (ISPC .GT. 12) GO TO 99
      CALL F2SHFT
      GO TO 40

  99  IF (MAGSHF(NEWFAM,3,DUM)) THEN
C4.6  IF (IFAM.EQ. 1 .OR. IFAM .EQ. 2) GO TO 40
        IF (IFAM .LE. 3) GO TO 40
        GO TO 1
      ENDIF
      WRITE (VFMT,1000) IFAM,IGEN,ISPC
 1000 FORMAT (3I4)
      CALL ERRMES(-1,0,'APSHSF Parameter with family, genus'//
     &' and species'//VFMT(1:12)//' not defined')
C
C COMMON EXIT TO PRINT SHIFTS:
  40  CALL FETSHF(2,SHIFT,ESD)
      CALL PARNAM(LNAM1,LNAM2,3,KPACK)
      IF (IFAM .NE. 2 .AND. IFAM .NE.3) GO TO 6
C4.19 DETECT CHANGE OF GENUS OR FAMILY (ATOM or SOURCE)
      IF (NEWFAM .EQ.0 .AND. IG .EQ. IGEN) GO TO 7
      HEAD=.FALSE.
      CALL PRBLOK
C PUT FIRST ENTRY FOR NEW ATOM INTO BUFFERS:
      NAME=LNAM1
      IG=IGEN
   7  IF (IBUFF .GE. 12) CALL PRBLOK
      IBUFF=IBUFF+1
      IPNAME(IBUFF)=LNAM2
      PNEW(IBUFF)=XNEW
      PESD(IBUFF)=ESD
      PSHIFT(IBUFF)=SHIFT
      POLD(IBUFF)=XOLD
      PSESD(IBUFF)=SHESD
      GO TO 1
C
C HERE TO PRINT TYPE 1 SHIFT AS BEFORE:
   6  IF (.NOT. HEAD) CALL MESS(LPT,1,'  Variable         New'//
     & '           Esd          Shift          Old           Shift/Esd')
      HEAD=.TRUE.
      WRITE (VFMT(19:19),2006) NSIGFG(ESD)
 2006 FORMAT (I1)
      WRITE (LPT,VFMT) LNAM1,LNAM2,XNEW,ESD,SHIFT,XOLD,SHESD
   1  CONTINUE
C139 Check whether we need to clear up LAST family
      CLAIMD=MAGSHF(IFAMO,8,DUM)
C
C PRINT ANY REMNANTS FROM BUFFER:
      CALL PRBLOK
      CALL FETSHF(3,0.,0.)
C IF ANY SLACK CONSTRAINTS, UPDATE THEIR BOND ENDS:
      CALL GEOMCO(2)
C IF ANY CELL PARAMETERS CHANGED, UPDATE ALL:
      IF (SHFCEL) CALL RECELL(1,1)
 100  RETURN
      END
C
C
C
C
C LEVEL 8      SUBROUTINE APSHT2
      SUBROUTINE APSHT2
C
C *** APSHT2 updated PJB 4-Apr-2001 ***
C
CX
CC 7B
CH Applies shifts for reciprocal cell quadratic products and zero
CH during 2theta refinement.
C
CP Only of use from MAIN program T2LSQ, or similar;  only expects one family
CP of parameters, being the 6 reciprocal cell quadratic products
CP and a zero point.
CP Expects shifts (one for each basic variable) in array BLSQ, with
CP corresponding ESDs in array DERIVB.
C
CD Applies shifts as given to the parameters, dealing with constraints
CD if necessary.  Recalculates all cell quantities.
C
CO Writes to unit LPT the old and new values, the shift and its esd.
C
      CHARACTER *4 LNAM1,LNAM2
      CHARACTER*32 VFORM
/CELPAR/
/DERBAS/
/DERVAR/
/IOUNIT/
/MATDAT/
/NEWOLD/
/POINTS/
/REFINE/
/ZEROPT/
C
      WRITE (LPT,2000) ICYC
2000  FORMAT (/////'1Shifts in variables for cycle',I3/
     &'  Variable      New       Esd      Shift      Old    Shift/Esd')
      DO 1 I=1,LVARV
      J=LVRBS(I)
      KPACK=LVRPR(I)
C IF VARIABLE IS BASIC:
      IF (J .GT. 0) THEN
        SHIFT=BLSQ(J)
        ESD=DERIVB(J)
        SHESD=SHIFT/ESD
C OTHERWISE IT IS REDUNDANT, BY CONSTRAINT NUMBER -J:
      ELSE
        CALL SHFESD(-J)
      ENDIF
C
      CALL PARNAM(LNAM1,LNAM2,3,KPACK)
      CALL PUNPAK(KPACK,IFAM,IGEN,ISPC)
      IF (ISPC .GT. 6) GO TO 11
      CALL ADJUST(CPARS(ISPC,2))
      GO TO 12
C
C SHIFT IN ZERO POINT:
  11  CALL ADJUST(ZERO)
  12  WRITE (VFORM,2006) NSIGFG(ESD)
      WRITE (LPT,VFORM) LNAM1,LNAM2,XNEW,ESD,SHIFT,XOLD,SHESD
2006  FORMAT ('(2X,A4,1X,A4,4F10.',I1,'F10.3)')
   1  CONTINUE
      CALL RECELL(1,1)
      RETURN
      END
C
C
C
C
C LEVEL 2      FUNCTION ARCCOS(X)
      FUNCTION ARCCOS(X)
C
C *** ARCCOS FOR IBM by JCM 26 Sep 83 ***
C
CX
CC 10C
CH Calculates an arc cosine.
CA On entry X= a cosine
CA On exit ARCCOS is the arc cosine of X in radians in range 0 to Pi.
CN Written because IBM did not have it at the time.
C
/CONSTA/
C
      CALL SINCOS(X,Y,'ARCCOS')
      IF (ABS(X) .LT. 0.5) GO TO 1
      ARCCOS=ATAN(Y/X)
      GO TO 2
   1  ARCCOS=PIBY2-ATAN(X/Y)
   2  IF (ARCCOS .LT. 0.) ARCCOS=ARCCOS+PI
      RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE ARPRIN(H,FBUF,MODE)
      SUBROUTINE ARPRIN(H,FBUF,MODE)
C
C *** ARPRIN corrected by PJB C4.20 Sept 2010 increase length of VFMT4 ***
C
CX
CC 2A
CH A multi-mode routine to produce the output in ARRNGE type main programs.
CA On entry H contains a set of floating indices
CA          FBUF is as set up in the main program. FBUF(1) is the record
CA               number and normally FBUF(2:3) the observation and its
CA               standard deviation.
CA MODE selects what is printed out
CA MODE = 0 Sets up the variable formats in accordance with IFOR
CA MODE = 1 Reject output
CA MODE = 2 Initial heading
CA MODE = 3 1st entry for a reflection (rec no indices and values)
CA MODE = 4 Add values to output file buffer
CA MODE = 5 Entry for repeated reflections (recno and values)
CA MODE = 6 End of sub-group
CA MODE = 7 End of group
CA MODE = 8 Average of configuration domains
C
C4.3 ARRBLK and COMMONs /HEDIN/ and /ARRFMT/ removed, replaced with SAVE
      CHARACTER *140 HEADNG(3),PNAMES(4)*14
      CHARACTER *300 HEADER
      LOGICAL SNP,HDONE
      DIMENSION H(3),FBUF(10),K(3)
      CHARACTER *2 LABEL(9),POLWRD*3
      CHARACTER *200 FILBUF
      CHARACTER HKLFMT*7,VALFMT*16,REJFMT*35
      CHARACTER *30 VFMT1,VFMT2,VFMT3,VFMT4*50,LPTBUF*132
/ARRDAT/
      COMMON /ENVPAR/ SUMPRS(5,4)
/IOUNIT/
/WHEN/
/SCRACH/
      SAVE FILBUF,LPTBUF,HKLFMT,VALFMT,REJFMT,VFMT1,VFMT2,
     &VFMT3,VFMT4,POLWRD,SNP,LIMVAL,HEADER,HDONE
      DATA LABEL/'XX','XY','XZ','YX','YY','YZ','ZX','ZY','ZZ'/
      DATA HEADNG/'(4X,''Record'', 7X,''Indices'', 7X,''Observations'',8
     &X,''Mean of repeated'', 7X,''Labelling'', 4X,''Mean of equivalent'
     &'/',
     &'4X,''Number'',42X,''Observations'', 11X,''Index'', 9X,''Reflectio
     &ns''/',
     &'15X,''h'',4X,''k'',4X,''l'',4X,''Value'',5X,''SDevn'',7X,''Mean''
     &,5X,''SDevn'',7X,''h'',4X,''k'',4X,''l'', 5X            ,''Mean'',
     &5X,''SDevn''/)'/
      DATA PNAMES/'Regul_Temp    ','Sample_Temp   ','Voltmeter     ',
     & 'Magnetic_Field'/
      DATA HDONE/.FALSE./
C
      N=NINT(FBUF(1))
      IF (.NOT.INC .AND. MODE.NE.2) CALL INDFIX(H,K)
      GO TO (1,10,20,30,40,50,60,70,80), MODE+1
C
C  FIDDLE THE FORMATS
C4.3 NUMVAL IS THE NUMBER OF ENTRIES INPUT IN FBUF (includes record nos whether
C to be recorded or not). Its method of calculation has been changed
    1 NUMVAL=3
C Formats for different types of data
C For flipping ratio measurements
      IF (IFOR(1).EQ.1 .OR. IFOR(1) .EQ. 9) THEN
        IF (IFOR(6) .EQ.0) THEN
          VALFMT='(2F10.6)'
        ELSE
          VALFMT='(2F10.6,3F10.2)'
          NUMVAL=NUMVAL+3
        ENDIF
      ELSE IF (IFOR(1).EQ.5) THEN
        VALFMT='(2F10.2,2F10.5)'
        NUMVAL=NUMVAL+2
      ELSE IF (IFOR(1) .GT.10) THEN
        NUMVAL=NUMVAL+1
        VALFMT='(2F10.3,F10.0)'
      ELSE
        IF (IFOR(6) .EQ .0) THEN
          VALFMT='(2F10.2)'
        ELSE
          VALFMT='(2F10.2,4F10.2)'
          NUMVAL=NUMVAL+4
        ENDIF
      ENDIF
      SNP=IFOR(1).GT.10
C ISTORE IS THE NUMBER OF CHARACTERS NEEDED PER MEASUREMENT
      ISTORE=NUMVAL*10
C4.2 IFOR(3) .GT.1 means store record numbers
      IF (IFOR(3).EQ.0)ISTORE=ISTORE-10
C NBUF IS THE NUMBER OF MEASUREMENTS WHICH WILL FIT IN FILBUF
      NBUF=1+ISTORE/74
C FORCE NBUF TO 1 TO ENSURE THAT INPUAR WORKS PROPERLY
C THIS NEEDS TO BE CLEANED UP SOMETIME
      NBUF=1
C
C4.2 Modification of section below to allow for SNP data
      IF (INC) THEN
        HEADNG(1)(14:15)='11'
        HEADNG(1)(28:29)='13'
        HEADNG(1)(69:70)='9'
        HEADNG(2)(13:14)='53'
        HEADNG(3)(1:24)='16X,''h'',7X,''k'',7X,''l'',7X'
        HKLFMT='3F8.3'
        INDLEN=24
        if (.NOT. SNP ) THEN
          HEADNG(1)(85:86)='10'
          HEADNG(2)(33:34)='13'
          HEADNG(2)(45:46)='16'
          HEADNG(3)(66:89)='6X,''h'',7X,''k'',7X,''l'',9X '
C ICHNGE for change in matrix component
          LIMVAL=4
        else
          HEADNG(1)(85:86)='13'
          HEADNG(2)(33:34)='13'
          HEADNG(2)(45:46)='18'
          HEADNG(3)(66:101)=
     &    '7X,''h'',7X,''k'',7X,''l'',5x,''PinOut'',3X'
        endif
      ELSE
C SET IS TO ZERO FOR ARRNGE (NO SATELLITES)
        IS=0
        HKLFMT='3I5  '
        INDLEN=15
        if (SNP ) THEN
          HEADNG(1)(69:70)='7'
          HEADNG(1)(85:86)=' 7'
          HEADNG(2)(45:46)='13'
          HEADNG(3)(88:102)='3x,''PinOut'',4X,'
C ICHNGE for change in matrix component
          LIMVAL=5
        endif
      ENDIF
C
      IF (IFOR(5).NE.0) THEN
        REJFMT='('' Reject '',I9,'//HKLFMT(1:5)//','//
     &  VALFMT(2:LEN(VALFMT))
      ENDIF
      VFMT1='(I9,2X,'//HKLFMT//','//VALFMT(2:)
      VFMT2='(I5,'//HKLFMT//',2I5)'
      VFMT3='('//HKLFMT//','//VALFMT(2:)
      if (SNP)  VFMT3='('//HKLFMT//',4X,A3,'//VALFMT(2:)
      VFMT4='(53X,''Domain average  '','//VFMT3(2:)
      IF (INC) VFMT4(2:3)='62'
      INFBUF=0
C4.3 make HEADER out of modified HEADNG
      HEADER=HEADNG(1)(1:LENGT(HEADNG(1)))//
     &HEADNG(2)(1:LENGT(HEADNG(2)))
     &//HEADNG(3)(1:LENGT(HEADNG(3)))
C
      GO TO 100
C
C REPORT REJECTIONS
   10 IF (INC) THEN
        WRITE (LPT,REJFMT) N,H,(FBUF(I),I=2,NUMVAL)
      ELSE
        WRITE (LPT,REJFMT) N,K,(FBUF(I),I=2,NUMVAL)
      ENDIF
      GO TO 100
C
   20 LINO=6
      INLBUF=1
      NEW=.TRUE.
      WRITE (LPT,HEADER)
C4.12 Write the header info
      IF (HDONE) GO TO 100
      HDONE=.TRUE.
      IF (IPLO .NE.0) THEN
        REWIND (IPLO)
   21   READ (IPLO,4000,END=22) MESSAG
 4000   format (A100)
        WRITE (LUNI,4000) MESSAG
        GO TO 21
      ENDIF
C Mean environment parammeters
   22 DO 23 I=1,4
      IF (NINT(SUMPRS(4,I)).EQ.0) GO TO 23
      CALL WTMEAN(X,DP,-1,SUMPRS(1,I))
      IF (X .GT. 9999.) GO TO 23
      IF ((I.EQ.3) .AND. (ABS(X).LT.0.1)) GO TO 23
      IF (X.LT. 0.01) GO TO 23
      IF (DP/X .GT. 0.2) WRITE (LPT,4001) PNAMES(I),X,DP
 4001 FORMAT ('***Warning ',A14,' varies by more than 20% :',f7.2,
     &'+/-',F6.2)
      WRITE (LUNI,4002) PNAMES(I),X
 4002 FORMAT ('#',A14,F7.2)
   23 CONTINUE
      GO TO 100
C
C PRINTOUT DATA FOR INDIVIDUAL MEASUREMENTS
   30 J=NREF
      CALL TESTP(LPT,LINO,J,HEADER,3)
      LINO=LINO-1
C4.3 ONLY NEEDED FOR SNP: IF INC LIMVAL=5  ELSE LIMVAL=4
      IF (SNP .AND. (NEW .OR. ICHNGE.LE.LIMVAL)) THEN
        IF (FBUF(4).LT.0) THEN
          POLWRD='-'//LABEL(NINT(ABS(FBUF(4))))
         ELSE
           POLWRD='+'//LABEL(NINT(ABS(FBUF(4))))
         ENDIF
      endif
C CHECK WHETHER REFLECTIONS OCCURRING SINGLY ARE TO BE PRINTED
      IF (NEW) THEN
        LPRINT=((IFOR(2).GE.0) .OR. (NREF.GT.1) .OR. (ICHNGE.GE.4))
        NEW=.FALSE.
      ENDIF
      IF (LPRINT) THEN
        IF (INLBUF.GT.1) THEN
          WRITE (LPT,3000) LPTBUF
 3000     FORMAT (A80)
          LINO=LINO+1
        ENDIF
        IF (INC) THEN
          WRITE (LPTBUF,VFMT1)  N,H,FBUF(2),FBUF(3)
        ELSE
          WRITE (LPTBUF,VFMT1) N,K,FBUF(2),FBUF(3)
        ENDIF
        INLBUF=31+INDLEN
      ENDIF
C
C4.3 Correction for record mumbers  WRITE HEADER LINE TO OUTPUT FILE
        IF (IFOR(3) .GT. 0) THEN
          L=NUMVAL*NREF+3
        ELSE
          L=(NUMVAL-1)*NREF+3
        ENDIF
C109 Comma removed
        IF (INFBUF.EQ.0. 0) WRITE (FILBUF(INDLEN:),2001) DATIM
2001    FORMAT (30X,A24)
        INFBUF=INDLEN+44
        IF (INC) THEN
          WRITE (FILBUF(1:21+INDLEN),VFMT2) ICD,H,J,L
        ELSE
          WRITE  (FILBUF(1:21+INDLEN),VFMT2) ICD,K,J,L
        ENDIF
        WRITE (LUNI,3002) (FILBUF(I:I),I=1,INFBUF)
        ICD=ICD+1
        WRITE (FILBUF,3001) ICD
        INFBUF=6
        IBUF=0
        GO TO 100
C

C PUT VALUES INTO A BUFFER TO ACCUMULATE A LINE OF OUTPUT
   40 WRITE (FILBUF(INFBUF:(LEN(FILBUF))),VALFMT) (FBUF(I),
     &I=2,NUMVAL)
      INFBUF=INFBUF+ISTORE
C4.3 IF NUMOR RECORDED IT NOW COMES LAST
      IF (IFOR(3).GT.0) WRITE (FILBUF(INFBUF-10:),3005) FBUF(1)
 3005 FORMAT (F10.0)
      IBUF=IBUF+1
      IF (IBUF.GE.NBUF) THEN
        WRITE (LUNI,3002) (FILBUF(I:I),I=1,INFBUF-1)
 3002   FORMAT (80A1)
        ICD=ICD+1
        IBUF=0
        WRITE (FILBUF,3001) ICD
 3001   FORMAT (I5)
        INFBUF=6
      ENDIF
      GO TO 100
C
C REPEATED MEASUREMENT
   50 IF (LPRINT) THEN
C PRINT LINE JUST TERMINATED
        CALL TESTP(LPT,LINO,1,HEADER,3)
        WRITE (LPT,2000) LPTBUF
 2000   FORMAT (A132)
        LINO=LINO+1
      ENDIF
      WRITE (LPTBUF,VFMT1) N
      WRITE (LPTBUF(12+INDLEN:),VALFMT) FBUF(2),FBUF(3)
      GO TO 100
C
C CHANGE OF SUBGROUP
C EMPTY BUFFER
   60 IF (IBUF.GT.0) THEN
        WRITE (LUNI,3002) (FILBUF(I:I),I=1,INFBUF-1)
        ICD=ICD+1
      ENDIF
      IF (LPRINT) THEN
        INLBUF=33+INDLEN
        WRITE (LPTBUF(INLBUF:),VALFMT) FBUF(2),FBUF(3)
      ENDIF
      GO TO 100
C
C END OF GROUP
   70 L=3
      INLBUF=INLBUF+22
      IF (INC) THEN
        J=100*IS+ICHNGE
        IF (LPRINT) THEN
C4.3 additions for SNP formats
          IF (SNP) THEN
            WRITE (LPTBUF(INLBUF:),VFMT3) H,POLWRD,FBUF(2),FBUF(3)
          else
            WRITE (LPTBUF(INLBUF:),VFMT3) H,FBUF(2),FBUF(3)
          endif
        endif
        WRITE (LUNI,VFMT2) ICD,H,J,L
      ELSE
        J=ICHNGE
        IF (LPRINT) THEN
          IF (SNP) THEN
            WRITE (LPTBUF(INLBUF:),VFMT3) K,POLWRD,FBUF(2),FBUF(3)
          else
            WRITE (LPTBUF(INLBUF:),VFMT3) K,FBUF(2),FBUF(3)
          ENDIF
          WRITE (LUNI,VFMT2) ICD,K,J,L
        ENDIF
      ENDIF
      ICD=ICD+1
      IF (LPRINT) THEN
        CALL TESTP(LPT,LINO,2,HEADER,3)
        WRITE (LPT,2000) LPTBUF
        CALL NEWLIN(LPT)
        LINO=LINO+1
      ENDIF
      INLBUF=1
      NEW=.TRUE.
      GO TO 100
C
C AVERAGE OVER CONFIGURATION DOMAINS
   80 CALL TESTP(LPT,LINO,2,HEADER,3)
       L=3
       J=0
      IF (INC) THEN
        WRITE (LPT,VFMT4)H,FBUF(2),FBUF(3)
        WRITE (LUNI,VFMT2) ICD,H,J,L
      ELSE
        WRITE (LPT,VFMT4)H,FBUF(2),FBUF(3)
        WRITE (LUNI,VFMT2) ICD,K,J,L
      ENDIF
      ICD=ICD+1
      CALL NEWLIN(LPT)
      LINO=LINO+1
      GO TO 100
C
  100 RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE ARREAD(H,FBUF,IEND)
      SUBROUTINE ARREAD(H,FBUF,IEND)
C
C *** ARREAD updated by PJB C4.20 new type 11 for D3 *** ***
C
CX
CC 2A
CH Multiple entry routine to deal with reading items for ARRNGE type programs.
CD Expects IICD3 to have been obeyed to read the data type DTYP. The following
CD formats are defined:
CD    DTYP = 0 user supplied subroutine QARRIN to read the data
CD    DTYP = 1 D3 polarised neutron ratios as given by D3OP99
CD             Data read: NUMOR,K,(ANG(I),I=1,3),R,DR
CD             FORMAT (4I5,3F8.2,2F10.6)4I5,24X,2F1.6
CD    DTYP = 2 COLL5  1 card output
CD    DTYP = 3 COLL5  2 card output
CD             Data read for 2 and 3:NUMOR,K,Fsqr,Dfsqr,(ANG(I),I=1,4)
CD             FORMAT (I6,3I4,2F10.2,4F8.2)
CD    DTYP = 4 RACER floating format output
CD             Data read: NUMOR,H,INT,dINT,(ANG(I),I=1,4)
CD             FORMAT (I6,3F6.2,I8,I4,4F8.2)
CD    DTYP = 5 SXD format output including wave-length and path length
CD             Data read: NUMOR,H,Fsqr,DFsqr,Lambda,path
CD             FORMAT (I8,3F8.2,4F10.4)
CD    DTYP = 6 LLB format (floating indices)
CD             Data read: NUMOR,H,Fsqr,Dfsqr,(ANG(I),I=1,4)
CD             FORMAT (I4,3F6.2,2F10.4,4F8.3)
CD    DTYP = 7 D3 Integrated intensities (ext .ROC obsolete)
CD             Data read: NUMOR,H,Fsqr,Dfsqr,(ANG(I),I=1,4)
CD             FORMAT (I6,3F6.2,2F10.2,4F8.2)
CD    DTYP = 8 COLL5 floating format (1 card ext .COL)
CD             Data read: NUMOR,H,Fsqr,Dfsqr,(ANG(I),I=1,4)
CD             FORMAT (I6,3F7.3,2F10.4,4F8.2)
CD    DTYP = 9 D3 Flipping ratios floating indices (ext .FLI)
CD             Data read: NUMOR,H,(ANG(i),i=1,3),R,DR:
CD             FORMAT (I8,3F8.3,3F8.2,2F10.4)
CD    DTYP =10 D3 Peak heights floating indices (ext .FLI)
CD             Data read: NUMOR,H,(ANG(i),i=1,3),AINT,DAINT:
CD             FORMAT (I8,3F8.3,3F8.2,20X,2F10.4)
CD    DTYP =11 D3 Flipping ratios from instrument fli files (ext .fli)
CD             Data read: NUMOR,H,(ANG(i),i=1,3),R DR:
CD             FORMAT (I8,3F8.3,3F8.2,2F10.4)
C4.20 Tyoe 11 added
C
      DIMENSION H(3),K(3),FBUF(10),ANG(4),SPARS(4),IEPAR(4)
      LOGICAL IEND,JEND,ANGLES,FIRST
      CHARACTER *50 QUERY(2),TBUF
      CHARACTER *150 BUFFER
      CHARACTER *4 EXT(11)
      CHARACTER*10 FILNOM
C
/ARRDAT/
/CARDRC/
      COMMON /ENVPAR/SUMPRS(5,4)
/IOUNIT/
/SCRACH/
C
      SAVE FIRST,LDAT,MDAT,IEPAR
      DATA QUERY/'File with reflections to be arranged',
     &'Next reflection file (or c/r to end)'/
      DATA EXT/'.FLI','.DAT','.DAT','.COL','.SXD','.LLB','.ROC',
     &'.FSQ','.FLI','.FLI','.fli'/
      DATA FIRST/.TRUE./
      DATA IEPAR/1,2,3,4/
C
      ANGLES=(IFOR(6).NE.0)
      ISTART=2
      IF (IEND) THEN
        ISTART=1
        WRITE (LPT,2010) IFOR(1)
 2010   FORMAT (/' Input type',I3,' - ')
        IF (IFOR(1) .LT. 0)  GO TO 98
        LDAT=102
        MDAT=134
        GO TO (10,11,12,13,14,15,16,17,18,19,20,21) , IFOR(1)+1
C
   98   WRITE (ITO,2010) IFOR(1)
        CALL MESS(ITO,0,'NOT YET IMPLEMENTED')
        CALL MESS(LPT,0,'NOT YET IMPLEMENTED')
        IERR=IERR+1
        GO TO 99
C
  10    CALL MESS(LPT,0,'User to supply own routine QARRIN')
        GO TO 3
C
  11    CALL MESS(LPT,0,'D3 polarised neutron ratios 4I5,24X,2F10.6')
        GO TO 3
C
  12    CALL MESS(LPT,0,'College 5 input, 1 card, I6,3I4,2F10.2')
        GO TO 3
C
  13    CALL MESS(LPT,0,'College 5 input, 2 cards, I6,3I4,2F10.2/')
        GO TO 3
C
  14    CALL MESS(LPT,0,'"ADVANCE" floating indices, I6,3F6.2,I8,I4')
        GO TO 3
C
  15    CALL MESS(LPT,0,'SXD intensities,wavelengths and pathlength'//
     &   ' from "SXDABS", I8,3F8.3,4F10.4/')
        GO TO 3
C
  16    CALL MESS(LPT,0,'LLB data: floating indices,' //
     &   'I4,3F6.2,2F10.4,4F8.2')
        GO TO 3
C
  17    CALL MESS(LPT,0,'D3 integrated intensities,' //
     &   'I6,3F6.2,2F10.2,4F8.2')
        GO TO 3

  18    CALL MESS(LPT,0,'COLL5 wide format with floating indices,'//
     &  ' I6,3F7.3,2F10.4,4F8.2')
        GO TO 3
C130
  19    CALL MESS(LPT,0,'D3 Flipping ratios, floating indices/'//
     &   'NUMOR,H,Angles,R,DR: FORMAT (I8,3F8.3,3F8.2,2F10.5)')
        GO TO 3
C4.2
  20    CALL MESS(LPT,0,'D3 Peak heights, floating indices/'//
     &   'NUMOR,H,Angles,Peak,d(Peak):'//
     &   ' FORMAT (I8,3F8.3,3F8.2,20X,2F10.2)')
        GO TO 3
C4.20
  21    CALL MESS(LPT,0,'D3 Flipping Ratios from instrument fli '//
     &  'file, floating indices, Numor,H,Angles,R,DR'//
     &   ' FORMAT (I8,3F8.3,3F8.2,2F10.2)')
C4.20 Don't read date and time info from instrument fli file
        LDAT=77
        MDAT=97
C4.20 Regulation temperature not recorded in instrument fli file
        IEPAR(1)=0
        IEPAR(2)=1
        IEPAR(3)=0
        IEPAR(4)=2
        GO TO 3
      ENDIF
C
C
C4.12 Read the diffraction info from the data header
   1  READ (LUNI,1000,END=2) BUFFER
1000  FORMAT (A150)
      L=LENGT(BUFFER)
      IF (BUFFER(1:1).EQ."*") GO TO 1
      IF (BUFFER(1:1).EQ."#") THEN
        IF (.NOT. FIRST) GO TO 1
C open a scrach file to hold the header info
        IF (IPLO.EQ.0) IPLO=NOPFIL(5)
        WRITE (IPLO,1010) (BUFFER(I:I),I=1,L)
 1010   FORMAT (150A1)
        GO TO 1
      ENDIF
C ONLY READ HEADER FROM THE FIRST FILE
      FIRST=.FALSE.

C SEQUENCE TO SKIP MULTIPLE CARDS
      MESSAG=BUFFER(1:LDAT)
      CALL RDINTG(N,1,IPT,10,IER)
      IF (IER.NE.0) GO TO 1
      IF (N.EQ.NUMOR) GO TO 1
C IGNORE BLANK CARDS:
      IF (L .LT.6) GO TO 1
C
      GO TO (51,52,52,54,55,56,57,58,59,65,59) , IFOR(1)
C
C READ DATA ITEM UNDER USER'S OWN FORMAT:
      CALL QARRIN(N,K,FBUF,LUNI,JEND)
      IF (JEND) GO TO 2
      GO TO 60
C
C D3 POLARISED NEUTRON RATIOS:
  51  READ (MESSAG,1001,END=2) NUMOR,K,(ANG(I),I=1,3),FBUF(2),FBUF(3)
1001  FORMAT (4I5,3F8.2,2F10.6)
      IF (ANGLES) THEN
C ON D3 OMEGA IS THE FIRST ANGLE
         FBUF(4)=ANG(2)
         FBUF(5)=ANG(1)
         FBUF(6)=ANG(3)
      ENDIF
      GO TO 60
C
C COLLEGE 5 INTEGRATED INTENSITIES :
  52  READ (MESSAG,1002,END=2) NUMOR,K,FBUF(2),FBUF(3),ANG
1002  FORMAT (I6,3I4,2F10.2,4F8.2)
C COLL5 PUTS OUT THETA NOT 2THETA
      ANG(1)=2.*ANG(1)
      IF (ANGLES) CALL GMEQ(ANG,FBUF(4),4,1)
      GO TO 60
C
C ADVANCE INTEGRATED INTENSITIES - FLOATING FORMAT:
  54  READ (MESSAG,1030,END=2) NUMOR,H,LFIN,LDFIN,ANG
1030  FORMAT (I6,3F6.2,I8,I4,4F8.2)
      FBUF(2)=FLOAT(LFIN)
      FBUF(3)=FLOAT(LDFIN)
C136 Don't allow the esd to be zero
      IF (FBUF(3).EQ.0) FBUF(3)=0.5
      IF (ANGLES) CALL GMEQ(ANG,FBUF(4),4,1)
C IGNORE BLANK CARDS:
      IF (N+LFIN+LDFIN.EQ.0) GO TO 1
      TBUF=BUFFER(69:L)
      GO TO 67
C
C SXD INTENSITIES FROM SXDABS:
  55  READ (MESSAG,1031,END=2) NUMOR,H,(FBUF(I),I=2,5)
1031  FORMAT (I8,3F8.2,4F10.4)
      IF (N.NE.0) GO TO 61
      GO TO 1
C
C LLB FORMAT:
  56  READ (MESSAG,1032,END=2) NUMOR,H,FBUF(2),FBUF(3),ANG
1032  FORMAT (I4,3F6.2,2F10.4,4F8.3)
      IF (ANGLES) CALL GMEQ(ANG,FBUF(4),4,1)
      IF (N.NE.0) GO TO 61
      GO TO 1
C
C D3 Integrated intensities  .ROC FORMAT:
  57  READ (MESSAG,1033,END=2) NUMOR,H,FBUF(2),FBUF(3),ANG
1033  FORMAT (I6,3F6.2,2F10.2,4F8.2)
      IF (ANGLES) CALL GMEQ(ANG,FBUF(4),4,1)
C
C Floating COLL5 wide format:
  58  READ (MESSAG,1034,END=2) NUMOR,H,FBUF(2),FBUF(3),ANG
1034  FORMAT (I6,3F7.3,2F10.4,4F8.2)
      IF (ANGLES) CALL GMEQ(ANG,FBUF(4),4,1)
      IF (N.EQ.0) GO TO 1
      TBUF=BUFFER(80:L)
      GO TO 67
C
C130 D3 FLOATING INDICES:
  59  READ (MESSAG,1035,END=2) NUMOR,H,(ANG(I),I=1,3),FBUF(2),FBUF(3)
1035  FORMAT (I8,3F8.3,3F8.2,2F10.4)
      GO TO 66
C  D3 Peak Heights:
  65  READ (MESSAG,1036,END=2) NUMOR,H,(ANG(I),I=1,3),FBUF(2),FBUF(3)
1036  FORMAT (I8,3F8.3,3F8.2,20X,2F10.2)
  66  IF (ANGLES) THEN
C ON D3 OMEGA IS THE FIRST ANGLE
         FBUF(4)=ANG(2)
         FBUF(5)=ANG(1)
         FBUF(6)=ANG(3)
      ENDIF
C4.12 Read environment info from data files
      if (L.GT. MDAT) L = MDAT
      TBUF=BUFFER(LDAT:L)
   67 L=LENGT(TBUF)
C If no environment data
      IF (L.EQ.0) GO TO 61
      IF (LETTER(L).GT.0) L=L-1
      ICARD=TBUF(1:L)
      CALL GMZER(SPARS,4,1)
      CALL RDNUMS(SPARS,1,4,NUM,IER)
      DO 62 I=1,4
      if (iepar(i).ne.0) CALL WTMEAN(SPARS(iepar(i)),1.,1,SUMPRS(1,i))
   62 CONTINUE
      GO TO 61
C
  60  CALL INDFLO(H,K)
  61  IF (NREF1 .EQ.-1) NREF1=N
      FBUF(1)=FLOAT(N)
      NREFL=N
      GO TO 100
C
C START READING (NEXT) INPUT DATA FILE:
   2  WRITE (LPT,2005) NREF1,NREFL,FILNOM(LUNI)
2005  FORMAT (/' Reflection numbers ',I8,' to ',I8,' read from file ',
     &A10)
      CLOSE(LUNI)
   3  NUMOR=0
      IF (ISTART.EQ.1) THEN
C4.12 Initialise environment means
        IPLO=0
        DO 80 I=1,4
        CALL WTMEAN(X,DX,0,SUMPRS(1,I))
   80   CONTINUE
      ENDIF
      MESSAG=' '
      NREF1=-1
      NAMFIL=EXT(IFOR(1))
      WRITE (MESSAG,2000) QUERY(ISTART)
2000  FORMAT (A40)
      LUNI=NOPFIL(111)
      IF (LUNI .NE. 0) THEN
        IEND=.FALSE.
        ISTART=2
        GO TO 1
      ENDIF
C
  99  IEND=.TRUE.
 100  RETURN
      END
C
C
C
C
C LEVEL 11      SUBROUTINE ARRHED
      SUBROUTINE ARRHED
C
C *** ARRHED Modified BY PJB Nov2010 C4.22 ***
C
CX
CC 2A
CH Reads the data header on arrnge type data files and indicates which
CH diffraction data were read. These overide the crystal data.
      DIMENSION A(9)
      CHARACTER *100 BUFFER,HEDWDS(3)*5 ,WORD*16
/DGEOM/
/DREAD/
/IOUNIT/
/SCRACH/
      DATA HEDWDS/'UBMAT','WAVEL','GEOM'/
C
      IPLO=0
    1 READ (LUNI,10,END=100) BUFFER
   10 FORMAT (A100)
      IF (BUFFER(1:1).NE.'#') GO TO 100
      LBUF=LENGT(BUFFER)
      M=LBUF
      IF (LBUF .GT.79) M=79
      ICARD=BUFFER(1:M)
      CALL RDWORD(WORD,LEN,2,IPT,20,0,IER)
      ICARD=BUFFER(IPT:LBUF)
      IF (IER.NE.0) GO TO 1
      CALL UPONE(WORD(1:5),1)
      L=NCFIND(WORD(1:5),HEDWDS,2)
      GO TO (3,4,5) L
C open a scratch file to store the headers
    2 IF (IPLO.EQ.0) IPLO=NOPFIL(5)
C4.21 Always retain UBmatrix and wavelength
      WRITE(IPLO,11) (BUFFER(I:I) ,I=1,LBUF)
   11 FORMAT (100A1)
      GO TO (3,4,5) L
      GO TO 1
C UB MATRIX
    3 CALL RDNUMS(A,1,9,NUM,IER)
      IF ((IER .NE.0) .OR. (NUM .NE. 9)) THEN
        CALL ERRMES(1,-1,'Reading UB matrix from data header')
        GO TO 1
      ENDIF
C Convert to CCSL form
      UM(1)=A(4)
      UM(2)=-A(1)
      UM(3)=A(7)
      UM(4)=A(5)
      UM(5)=-A(2)
      UM(6)=A(8)
      UM(7)=A(6)
      UM(8)=-A(3)
      UM(9)=A(9)
      WRITE (LPT,2051) UM
 2051 FORMAT (/' CCSL UB Matrix: ',3F10.5/2(17X,3F10.5/))
      DNEEDS(5)=.FALSE.
      IDREAD(5)=9
      GO TO 1
C WAVELENGTH
    4 CALL RDREAL(WLGTH,1,IPT,10,IER)
      IF (IER .NE.0) THEN
        CALL ERRMES(1,-1,'Reading wavelength from data header')
      ELSE
        DNEEDS(2)=.FALSE.
      ENDIF
      GO TO 1
C GEOMETRY
    5 CALL RDINTG(IGEOM,1,IPT,5,IER)
      IF (IER .NE.0) THEN
        CALL ERRMES(1,-1,'Reading geometry type from data header')
      ELSE
        DNEEDS(1)=.FALSE.
        GO TO 2
      ENDIF
      GO TO 1
C
  100 REWIND (LUNI)
      IF (IPLO .NE.0) REWIND(IPLO)
      RETURN
      END
C
C
C
C
C LEVEL 6      SUBROUTINE ARROW(X,Y,L)
      SUBROUTINE ARROW(X,Y,L)
C
C *** ARROW by PJB Sep 87 ***
C
CX
CC 14C
CH Draws an arrow centred at X,Y in the current space.
CP General CCSL plotting must have been set up.
CA On entry L=0 requests outline arrow
CA          L=1 requests solid arrow
C
      DIMENSION SPTS(2,7),PTS(2,7)
/PLTRAN/
      DATA SPTS/-8.,-1.,-8.,1.,4.,1.,4.,4.,8.,0.,4.,-4.,4.,-1./
      DATA NPTS/7/
C
C  ADD DISPLACEMENT
      DO 2 I=1,NPTS
      PTS(1,I)=SPTS(1,I)+X
    2 PTS(2,I)=SPTS(2,I)+Y
C
C  DRAW OUTLINE
      CALL KANGA1(PTS(1,NPTS),PTS(2,NPTS),3)
      DO 1 N=1,NPTS
      CALL KANGA1(PTS(1,N),PTS(2,N),2)
    1 CONTINUE
C
C  RETURN IF L=0
      IF (L.EQ.0) GO TO 100
C
C  GET EFFECTIVE GRID FOR SHADING
      CALL PLCONV(0.,0.,1,A1,B1,NSPCE)
      CALL PLCONV(.02,0.,1,A,B,NSPCE)
      A=A-A1
      B=B-B1
      STEP=SQRT(A**2+B**2)
C
C  NOW SHADE THE ARROW
C  FIRST THE TAIL
      CALL KANGA1(PTS(1,1),PTS(2,1),3)
      NX=IFIX((PTS(1,7)-PTS(1,1))/STEP)
      XX=PTS(1,1)
      DO 3 IX=1,NX
      XX=XX+STEP
      CALL KANGA1(XX,PTS(2,2),2)
    3 CALL KANGA1(XX,PTS(2,1),2)
C  THEN THE HEAD
      SY1=STEP*((PTS(2,5)-PTS(2,4))/(PTS(1,5)-PTS(1,4)))
      SY2=STEP*((PTS(2,5)-PTS(2,6))/(PTS(1,5)-PTS(1,6)))
      CALL KANGA1(PTS(1,6),PTS(2,6),3)
      Y1=PTS(2,4)
      Y2=PTS(2,6)
C
C NOTE FROM JCM - THIS OUGHT TO BE TIDIED: DONE PJB JUNE2004
      NX=IFIX((PTS(1,5)-PTS(1,7))/STEP)
      XX=PTS(1,7)
      DO 4 IX=1,NX
      XX=XX+STEP
      Y1=Y1+SY1
      Y2=Y2+SY2
      CALL KANGA1(XX,Y1,2)
      CALL KANGA1(XX,Y2,2)
    4 CONTINUE
  100 RETURN
      END
C
C
C
C
C LEVEL 2      SUBROUTINE ASK(MESS)
      SUBROUTINE ASK(MESS)
C
C *** ASK updated by PJB 17-Jun-1994 ***
C
CX
CC 13C
CH Writes a message on unit ITO and reads an interactive answer to /SCRACH/.
CA On entry MESS is the message.
CI On exit the answer typed to the terminal unit ITI is in ICARD, A80.
CO Writes the message on unit ITO, using a FORMAT finishing $ if this is
CO allowed by the FORTRAN system being used.
C
      CHARACTER *20 FORM
      CHARACTER *(*) MESS
/IOUNIT/
/SCRACH/
      DATA FORM/'(1X,80A1,'' : '',$)'/
C
      L1=LENGT(MESS)
      IF (L1 .EQ. 0) L1=1
C ANY SYSTEM WHICH WILL REALLY NOT TAKE $ SHOULD HAVE IT REMOVED:
CS PICKY      FORM(16:16)=' '
      WRITE (FORM(5:6),2000) L1
2000  FORMAT (I2)
      WRITE (ITO,FORM) (MESS(I:I),I=1,L1)
CS UNIX       CALL FLUSH(ITO)
      READ (ITI,1000) ICARD
1000  FORMAT (A80)
      RETURN
      END
C
C
C
C
C LEVEL 6      FUNCTION ASPHFF(H,IAT)
      FUNCTION ASPHFF(H,IAT)
C
C *** ASPHFF by PJB Jun 86 ***
C
CX
CC 17C
CH Calculates an aspherical form factor for a cubic space group.
CA On entry H is a 3-sized array holding h,k,l
CA          IAT=which atom
CA On exit ASPHFF holds the form factor.
C
      DIMENSION H(3)
/CONSTA/
      COMMON/VALUES/VAL(3,10),NVAL
C
      SUM=0.
C
C  CALCULATE CUBIC ASYMMETRY FACTOR
      AHKL=0.
      SHKL=0.
      J=2
      L=3
      DO 51 I=1,3
      AHKL=AHKL+(H(I)**4)-3*(H(J)*H(L))**2
      SHKL=SHKL+H(I)**2
      L=J
   51 J=I
      AHKL=AHKL/(SHKL**2)
C
      AK=VCTMOD(TWOPI,H,2)
      DO 1 L=1,3
      LL=2*(L-1)
      F=FORMFC(AK,LL,0,IAT)
      IF (L.EQ.2) F=F*VAL(2,IAT)
      IF (L.EQ.3) F=F*VAL(3,IAT)*AHKL
    1 SUM=SUM+F
C
      ASPHFF=SUM*VAL(1,IAT)
      RETURN
      END
C
C
C
C
C LEVEL 4      SUBROUTINE ASUNIT(H,HIN,N,M)
      SUBROUTINE ASUNIT(H,HIN,N,M)
C
C *** ASUNIT by JCM 3 Jul 84 ***
C
CX
CC 1B
CH Produces reflection indices in the asymmetric unit, related to those given.
CP SYMUNI must have set up the asymmetric unit.
CA On entry H is a 3-sized vector containing h,k,l, which may be anywhere
CA in reciprocal space.
CA On exit HIN is a 3-sized vector related by symmetry to H, and in (or on)
CA             the asymmetric unit.
CA           M is its multiplicity.
CA           N is the number of the symmetry operator which takes H into
CA             HIN.  N is -ve if (-x,-y,-z) involved, or 0 if error.
C
CD Takes account of Friedel - for non-centrosymmetric groups, Friedel is
CD *** ONLY *** assumed if the user has given an I FRIE card with a non-zero
CD number.  If HIN is related to H by an operator belonging to the Friedel-
CD related set (which are not stored explicitly in  COMMON SYMDA), then N is
CD set negatively.
CD
CD If there has been an error in the formation of the asymmetric unit, and
CD H does not therefore transform into the unit using any of the space group
CD operators, N is set=0
C
      DIMENSION H(3),HIN(3)
/FRIED/
/NSYM/
C
C ARRANGE TO SCAN + AND - IF FRIEDEL:
      KEND=1
      IF (FRIEDL) KEND=2
      DO 1 K=1,KEND
      DO 1 I=1,NOPC
      CALL ROTSYM(H,HIN,I,2)
      IF (K .EQ. 2) CALL GMREV(HIN,HIN,3,1)
      MM=MULBOX(HIN)
      IF (MM .NE. 0) GO TO 101
C
   1  CONTINUE
C
C ERROR - REFLECTION NEVER TRANSFORMS INTO ASYMMETRIC UNIT:
      N=0
      M=0
      GO TO 100
C
C FOUND: SET N TO POINT TO OPERATOR, -VE IF IN FRIEDEL SET:
 101  N=(3-2*K)*I
      M=MM
 100  RETURN
      END
C
C
C
C
C LEVEL 6      SUBROUTINE ATMPIG
      SUBROUTINE ATMPIG
C
C
C *** ATMPIG NEW by PJB C4.38 AUG 2017  ***
C
CX
CC 5B
CH Plots atom positions found by ATMPLT using PIGLET graphics
CP ATNPLT to fill in the common MAPLAB
CP PIGLET to set up graphics

/ATNAM/
/IOUNIT/
/MAPDA/
/MAPLAB/
/PLODAT/
/PLOMAP/

C actual plotting of positions found by atmplt
      call spcset(4)
      LFOUND=0
      DO 30 IL=1,NLABS
        IF (FOUNDL(IL)) LFOUND=LFOUND+1
   30 CONTINUE
      DO 4 NL=1,NFOUND
        IL=labno(nl)
        if (.not.foundl(IL))  go to 4
C Set pen colour to label colour
         ICOL=-MCOLOR(IL)
         CALL PIGLET(XP,YP,ICOL)
         FX=(poslab(1,nl)-OUTLIM(1,1))*FLOAT(NX-1)/(OUTLIM(2,1)
     &    -OUTLIM(1,1))
         FY=(poslab(2,nl)-OUTLIM(1,2))*FLOAT(NY-1)/(OUTLIM(2,2)
     &    -OUTLIM(1,2))
         SYMSZ=SYSIZE(IL)*SCALMP
         KSYM=LSYMB(IL)
         if (fill(il)) ksym=-ksym
         write (lpt,5000)atname(labat(il)), FX,FY,SYMSZ,KSYM
 5000 format ('Call KANGA3 ',a4,2f8.4,2x,f8.4,2x,i5)
         CALL KANGA3(FX,FY,SYMSZ,KSYM)
    4  continue
C Make label Key
      FX=FLOAT(NX-1)
      FY=FLOAT(NY-1)
      CALL PLCONV(FX,FY/2.,4,C1,C2,5)
C C2 and C1 are the bottom and midpoint of the map converted to char 1
C Y offset to clear Angstrom marker
      C2=C2-4*CHUNIT
      call spcset(5)
      AN=FLOAT(LFOUND)
C Width of 1 atom label
      ALWID=8.*CHUNIT
      C1=C1-(0.5*(ALWID*(FLOAT(LFOUND-1))))
      C1=C1-CHUNIT
      DO 31 IL=1,NLABS
        IF (FOUNDL(IL)) THEN
          CALL PIGLET(XP,YP,-MCOLOR(IL))
C SYMBOL SIZE SHOULD BE IN ANGSTROMS
          SYMSZ=SYSIZE(IL)*SCALMP
C Set pen colour to label colour
          ICOL=-MCOLOR(IL)
          CALL PIGLET(XP,YP,ICOL)
         KSYM=LSYMB(IL)
         if (fill(il)) ksym=-ksym
          CALL KANGA3(C1,C2,SYMSZ,KSYM)
          OFF=CHUNIT
          CC1=C1+OFF
          CALL PIGLET(XP,YP,-1)
          L=LENGT(ATNAME(LABAT(IL)))
          CALL KANGA2(CC1,C2-0.3*CHUNIT,T,ATNAME(LABAT(IL)),L)
          C1=C1+ALWID
        ENDIF
   31 CONTINUE
      return
      end
C
C
C
C
C LEVEL 6      SUBROUTINE ATMPLO(IFND,NFND,JP)
      SUBROUTINE ATMPLO(IFND,NFND,JP)
C
C *** ATMPLO by PJB Aug 86 ***
C
CX
CC 5B
CH Plots atom positions on a map.
CA On exit NFND=number of positions plotted
CA         IFND, an integer array, contains pointers to the atoms plotted
CA         JP, an integer array, points to the symbols used for each atom
C
      DIMENSION JP(4),IFND(4),Z(2)
      LOGICAL FOUND1
/MAPDA/
/NSYM/
/PLODAT/
/PLOMAP/
/POSNS/
      COMMON/SCRAT/AA(3,3),TRXX(3,48),TLAT(3,4),BOUNDS(2,6),XX(3,3),
     & TMPV1(3),TMPV2(3),TMPV3(3),TTXX(3,50),NT,JUNK(27654)
/SYMDA/
C
C SET MAP SPACE:
      CALL SPCSET(4)
      JP(1)=1
      JP(2)=2
      JP(3)=4
      JP(4)=9
C
      NT=NDIM
      NFND=0
C
C  GET INVERSE OF U
      CALL GMEQ(U,AA,3,3)
      CALL TRINV3(AA,D)
C  TRANSORM LATTICE VECTORS IF NECESSARY
      DO 6 L=1,NLAT
      IF (MODET.EQ.1) THEN
        CALL GMPRD(ALAT(1,L),AA,TLAT(1,L),1,3,3)
      ELSE
        CALL GMEQ(ALAT(1,L),TLAT(1,L),1,3)
      ENDIF
    6 CONTINUE
C  FIX BOUNDARIES
      CALL GMEQ(OUTLIM,BOUNDS,2,1)
      CALL GMEQ(OUTLIM(1,2),BOUNDS(1,2),2,1)
C  LIMIT IN Z
      AL=VCTMOD(1.,U(1,3),1)
      ALZ=.1/AL
      BOUNDS(1,3)=OUTLIM(1,3) -ALZ
      BOUNDS(2,3)=OUTLIM(1,3) +ALZ
C  COPY VECTOR
      CALL GMEQ(BOUNDS(1,1),BOUNDS(1,4),2,3)
      IF (MODET.EQ.0) GO TO 5
      II=1
      DO 20 I=1,2
      TMPV1(3)=BOUNDS(I,3)
      DO 20 J=1,2
      TMPV1(2)=BOUNDS(J,2)
      DO 20 L=1,2
      TMPV1(1)=BOUNDS(L,1)
      CALL GMPRD(U,TMPV1,TRXX(1,II),3,3,1)
   20 II=II+1
C  FIND MAXIMUM AND MINIMUM ON EACH CRYSTALLOGRAPHIC AXIS
      DO 21 I=1,3
      BOUNDS(1,I)=AMIN1(TRXX(I,1),TRXX(I,2),TRXX(I,3),TRXX(I,4),
     & TRXX(I,5),TRXX(I,6),TRXX(I,7),TRXX(I,8))
      BOUNDS(2,I)=AMAX1(TRXX(I,1),TRXX(I,2),TRXX(I,3),TRXX(I,4),
     & TRXX(I,5),TRXX(I,6),TRXX(I,7),TRXX(I,8))
   21 CONTINUE
C GENERATE ATOMIC POSITIONS
    5 DO 1 IAT=1,NATOM
C FOR SKEW BUT RATIONAL PLANE, POSITIONS MUST BE TRANSFORMED TO MATCH THE
C SYMMETRY OPERATORS
      IF (MODET.EQ.1) THEN
        CALL GMPRD(X(1,IAT),AA,TRXX(1,1),1,3,3)
      ELSE
        CALL GMEQ(X(1,IAT),TRXX(1,1),1,3)
      ENDIF
      CALL ATOGEN(MOLD)
      FOUND1=.FALSE.
      DO 3 M=1,MOLD
      IF (MODET.NE.1) THEN
        CALL GMEQ(TRXX(1,M),TMPV1,1,3)
      ELSE
        CALL GMPRD(TRXX(1,M),U,TMPV1,1,3,3)
      ENDIF
      CALL TBOUND(IFOUND)
      IF (IFOUND .EQ.0) GO TO 3
      FOUND1=.TRUE.
      DO 31 IFN=1,IFOUND
      DO 30 I=1,2
      Z(I)=(TTXX(I,IFN)-OUTLIM(1,I))/OUTLIM(3,I)
   30 CONTINUE
      CALL KANGA3(Z(1),Z(2),1.5*CHUNIT*CHSCAL(2,3),JP(NFND+1))
   31 CONTINUE
    3 CONTINUE
      IF (FOUND1) CALL ERRCHK(2,NFND,4,0,'atoms in ATMPLO')
      IFND(NFND)=IAT
    1 CONTINUE
      RETURN
      END
C
C
C
C
C LEVEL 6      SUBROUTINE ATMPLT(ZED)
      SUBROUTINE ATMPLT(ZED)
C
C *** ATMPLT rewritten by PJB C4.31 Nov 2016  updated Aug 17 to remove piglet references C4.38 ***
C
CX
CC 5B
CH Plots atom positions on a section or projection of a crystal structure
CA On entry ZED gives the z-value of the section. Irelevant if 2D.
CN This version checks for the presence of multiple lattice points
CN within a section.
%      PARAMETER (MAXP=%SYMO%)
%      DIMENSION XAT(3,%SY*2%)
       DIMENSION VCRY(3),VMAP(3),PRIMV(3,MAXP)
C WORKING SPACE
      DIMENSION VEC(3),VECS(3,MAXP),HCF(2),IAX(2),SUMV(3,2),zoff(2)
      LOGICAL FIRST,LERCHK
C
/ATNAM/
/CONTUR/
/IOUNIT/
/MAPDA/
/MAPLAB/
/MAPMAP/
/NSYM/
/PLODAT/
/PLOMAP/
/PLTRAN/
/POSNS/
/SYMDA/
      DATA FIRST/.TRUE./
      SAVE FIRST,PRIMV,zoff
C
C      write (lpt,5000) zed,ndim,first
C 5000 format ('atmplt called for z=',f8.3,i3,' first is ',L)
C IF NO LABELS
      IF (NLABS.EQ.0) GO TO 100

C Setting up part
      IF (.NOT.FIRST) GO TO 1
      FIRST=.FALSE.
C Get the iinterlayer spacing
      DO 2 I=1,3
    2 AXLEN(I)=SCALPR(U(1,I),U(1,I))
      NPRIM=NINT(DET/AXLEN(3))
C The projection of the z axis on the plane
      ZLEN=VCTMOD(1.,U(1,3),1)
      ZOFF(1)=UINV(1,3)
      ZOFF(2)=UINV(2,3)
C      write (lpt,5050) zoff
C 5050 format ('Z offsets: ',2f8.4)
C  Find non-primitive lattice points in the plane
      CALL ERRCHK (1,NPRIM,MAXP,0,'Lattice points in the section')
      CALL GMZER(PRIMV(1,1),3,1)
      IF (NPRIM .EQ.1) GO TO 7
      II=1
      DO 5 I=1,3
        NFH=NHCF(U(I,1),U(I,2))
        IF (NFH.EQ.0) GO TO 5
        HCF(II)=FLOAT(NFH)
        IAX(II)=I
        II=II+1
        IF (II.GT.2) GO TO 6
    5 CONTINUE
    6 NP=1
      DO 3 I=1,2
        CALL GMSCA(U(1,1),VECS(1,1),U(IAX(3-I),2)/HCF(3-I),3,1)
        CALL GMSCA(U(1,2),VECS(1,2),U(IAX(I),1)/HCF(I),3,1)
        CALL GMSUB(VECS(1,1),VECS(1,2),SUMV(1,I),3,1)
        CALL FCTOR (SUMV(1,I),J)
        CALL GMZER(VECS,3,2)
C  Get non-primitive points
   4   IF (J.GT.1) THEN
          CALL GMADD(SUMV(1,I),VECS(1,1),VECS(1,1),3,1)
          CALL PRIMBX(VECS(1,1),VECS(1,2),U,AXLEN,NN,1)
          CALL EQVEC(PRIMV,vecs(1,2),NP,M,NPRIM)
          IF (M.GT.NP) NP=M
          J=J-1
          IF (NP.EQ.NPRIM) GO TO 7
          GO TO 4
        ENDIF
    3 CONTINUE
    7 DO 8 N=1,NPRIM
        CALL GMEQ(PRIMV(1,N),VEC,3,1)
        CALL GMPRD(UINV,VEC,PRIMV(1,N),3,3,1)
        IF (N.EQ.1) THEN
          WRITE (LPT,1003) N,VEC,(PRIMV(I,N),I=1,3)
        ELSE
          WRITE(LPT,1005) N,VEC,(PRIMV(I,N),I=1,3)
      endif
    8 continue
 1003 FORMAT ('Lattice Vectors in the map plane:',I3,2X,3F6.1,2x,3f8.4)
 1005 FORMAT (33x,I3,2X,3F6.1,2x,3f8.4)
C Report  the cryst to map transformation
      WRITE (LPT,1002) 'Cryst to map transformation'
      WRITE (LPT,1000) UINV
 1000 FORMAT (3F8.3)
 1002 FORMAT (/A,2X,2I3, 3F8.3)
C End of setting up part. Do the rest for each zed value
    1 NFOUND=0
        IF (NDIM.EQ.2) THEN
      	  WRITE (LPT,1004) 'Marking positions of Atoms in projection'
      	ELSE
      	  write (lpt,1004) 'Marking positions of Atoms in section at',zed
      	ENDIF
 1004 FORMAT (/A,3F8.3)
      DO 10 IL=1,NLABS
        NF=0
        IAT=LABAT(IL)
        FOUNDL(IL)=.FALSE.
C Find the atom positions to be marked
        CALL ATOMS(IAT,NA,XAT,48)
        DO 11 NAT=1,NA
          CALL GMEQ(XAT(1,NAT),VCRY,3,1)
C          CALL GMPRD(UINV,vcry,VMAP,3,3,1)
 5500 format ('Position ',A4,3f8.4,2x,'Xpars',8(f8.4,2x))
          IF (NDIM.EQ. 3) THEN
C Check whether atom  is in the zed layer
            ZCRY=SCALPR(VCRY,U(1,3))
            ZLEN= ZED*AXLEN(3)
            ZCELL=AINT(ZLEN)
            ZPOS=AMOD(ZLEN,1.)
            ZSH=AMOD(ZCRY-ZPOS,1.)
C            WRITE (LPT,5500) ATNAME(IAT),VCRY,ZCRY,ZLEN,ZCELL,
C     &      ZPOS,ZSH,ZDIF
            IF (ABS(ZSH) .GT. 0.0001) GO TO 11
            ZDIF=ANINT(ZCRY-ZPOS)
            IF (ABS(ZDIF).GT.0) THEN
                IY=2
                IZ=3
                DO 24 IX=1,3
                  IF (U(IX,3).EQ.0) GO TO 23
                  VEC(IY)=AMOD(U(IY,3),U(IX,3))
                  VEC(IX)=-((U(IY,3)*VEC(IY))-1.)/U(IX,3)
                  VEC(IZ)=0
                  GO TO 25
   23             IZ=IY
                  IY=IX
   24           CONTINUE
   25           CALL GMSCA(VEC,VEC,ZDIF,3,1)
 1018           FORMAT  ('Add offset for zpos',I2,3F8.3)
                WRITE (LPT,1018) IX,VEC
                CALL GMSUB(VCRY,VEC,VCRY,3,1)
              ENDIF
C  HERE WHEN AN ATOM FOUND WITHIN THE LAYER
              CALL GMPRD(UINV,VCRY,VMAP,3,3,1)
              IF (ZCELL .NE. 0) THEN
                CALL GMSCA(ZOFF,VEC,ZCELL,2,1)
                WRITE (LPT,5051) ZCELL,(VEC(I),I=1,2),VMAP
                CALL GMADD(VMAP,VEC,VMAP,2,1)
 5051           format ('Add offset for zcell=',f3.0,1x,2f8.4,2x,3f8.4)
              endif
            WRITE (LPT,1010) ATNAME(IAT),(XAT(IJ,NAT),IJ=1,3),VMAP
 1010       FORMAT (A4,' Atom in layer at',3F8.3,2X,
     &        ' in map at',3F8.3)
          else
            CALL GMPRD(UINV,vcry,VMAP,3,3,1)
          ENDIF
C  Loop over multiple cells, non-primitive lattice points and
C find corresponding points inside the map
          DO 12 LAT=1,NPRIM
C Add in map coordinates
            CALL GMADD(VMAP,PRIMV(1,lat),vec,3,1)
            CALL MAPBX(VEC,VECS,NN,.TRUE.)
            IF (NN.GT.0)   FOUNDL(IL)=.TRUE.
            DO 13 N=1,NN
              IF (.NOT. LERCHK(2,NFOUND,50,1,
     &        'Number of labels to plot')) go to 100
              NF=NF+1
              LABNO(NFOUND)=IL         ! WHICH ATOM
              POSLAB(1,NFOUND)=Vecs(1,n)
              POSLAB(2,NFOUND)=VECs(2,n)
C IL COUNTS THE ATOMS TO LABEL, NFOUND THE TOTAL NUMBER TO PLOT
   13       CONTINUE
   12     CONTINUE
   11   CONTINUE
        WRITE (LPT,1006) NF, ATNAME(IAT)
 1006   FORMAT (I3,1X,A4,' found in the map')
   10   CONTINUE
        go to 100
  100   RETURN
      END
C
C
C
C
C LEVEL 4      SUBROUTINE ATOGEN(MOLD)
      SUBROUTINE ATOGEN(MOLD)
C
C *** ATOGEN by PJB Aug 86 ***
C
CX
CC 5B
CH Generates a set of equivalent positions.
CA MOLD on exit is the number generated
CP In /SCRAT/ on entry (usually from ATMPLO) TRXX(1:3,1) holds the original
CP atomic position.
CD Generates all the related (different) positions in TRXX within 1 unit cell.
C
CN A PJB special for use with ATMPLO.
C
/NSYM/
      COMMON/SCRAT/AA(3,3),TRXX(3,48),TLAT(3,4),BOUNDS(2,6),XX(3,3),
     & TMPV1(3),TMPV2(3),TMPV3(3),TTXX(3,50),NT,JUNK(27654)
/SYMDA/
C
      MOLD=0
      CALL GMEQ(TRXX(1,1),XX,1,3)
      DO 1 L=1,NLAT
      DO 1 N=1,NOPC
      CALL GMADD(TRANS(1,N),TLAT(1,L),TMPV1,1,3)
      CALL ROTSYM(XX,XX(1,2),N,1)
C  CYCLE OVER CENTRE OF SYMMETRY
      DO 2 IR=1,NCENT
      CALL GMADD(TMPV1,XX(1,2),TMPV2,1,3)
      IF (MOLD.EQ.0) THEN
        MOLD=1
      ELSE
        CALL EQPOS(TRXX,TMPV2,MOLD,M,48)
        IF (M.GT.MOLD) MOLD=M
      ENDIF
C
    2 CALL GMREV(XX(1,2),XX(1,2),1,3)
    1 CONTINUE
      RETURN
      END
C
C
C
C
C LEVEL 4      SUBROUTINE ATOMS(IR,N,ALIST,MAX)
      SUBROUTINE ATOMS(IR,N,ALIST,MAX)
C
C *** ATOMS by JCM 3 Apr 88 ***
C
CX
CC 4B
CH Makes a real space unit cell full of related atomic positions.
C
CA On entry IR=an atom number
CA          MAX is the maximum number of positions ALIST can hold
CA On exit  N is the number of distinct positions related to the original,
CA               still within the original unit cell.
CA          ALIST(3,) holds N distinct atomic positions, the first being
CA               the given position, translated into (0,1) if necessary
C
      DIMENSION ALIST(3,MAX)
      DIMENSION XX(3),CEL(3)
/NSYM/
/POSNS/
C
      N=0
C INITIAL POSITION:
      CALL GMEQ(X(1,IR),XX,1,3)
C
C OVER CENTRE IF PRESENT:
      DO 1 IC=1,NCENT
C OVER OTHER OPERATORS:
      DO 2 NS = 1,NOPC
      IS=NS*(3-2*IC)
C LATTICE TRANSLATIONS:
      DO 3 IL=1,NLAT
C NO NEIGHBOURING CELLS:
      CALL GMZER(CEL,1,3)
      CALL XTRANS(IR,XX,IS,IL,CEL)
      CALL FRAC3(XX)
      CALL EQPOS(ALIST,XX,N,M,MAX)
      IF (M .GT. N)  N=M
   3   CONTINUE
   2   CONTINUE
   1   CONTINUE
      RETURN
      END
C
C
C
C
C LEVEL 10      SUBROUTINE ATOPOS
      SUBROUTINE ATOPOS
C
C ***  ATOPOS modified by PJB  26-Aug-1998 ***
C
CX
CC 4A
CH Reads and interprets all given A cards.
CP PREFIN must have first read the Crystal Data File
CP SYMOP must have already input the space group symmetry.
C
CD Reads a sequence of A cards.
CD Each card should start:
CD   A <atom label> or A SD <atom label>
CD     The <atom label> is a word of up to 4 characters, starting with a
CD     letter
CD   In the first case the data following  <atom label> are:
CD     X,Y and Z coordinates (which may be given as fractions if appropriate,
CD     e.g.  1/4  or 2/3)
CD     an isotropic temperature factor
CD     a possible scattering factor label (if different from starting letters
CD                                       of atom label)
CD     a possible site occupation factor (set = 1 if read as 0, so that it can
CD     be omitted altogether if wished.
CD   In the second case the data are the estimated standard deviations in
CD   the above parameters
CD
CD The scattering factor label and site occupation factor are both
CD optional, which means that if anything occurs after the isotropic temperature
CD factor, it is a label if it starts with a letter, or a number if a digit.
CD
CD Calculates the numbers of atoms of each type in the unit cell, and if the
CD position is special records the generators of its subgroup.
CD
CD Keeps lists of atom labels and scattering factor labels.
C
      CHARACTER *4 LABA,LABS,ESDCHR(3)*9
      LOGICAL LATVEC
      DIMENSION XIN(3),IPFIX(3),APFIX(3)
/ATNAM/
/CARDRC/
/FORMDA/
/FONAM/
/FORMD2/
/IOUNIT/
/NSYM/
/PHASE/
/POSNS/
/POSNS2/
%      COMMON /SCRAT/NTORD(%SYMO%),Z(6)
/SYMDA/
/SYMTAB/
C
C ARRANGE INPUT OF "S" CARDS IF NOT DONE
      IF (INREAD(19) .GT. 0) CALL SYMOP
C
C SET "A CARDS READ":
      INREAD(1) = -IABS(INREAD(1))
C
C INITIALISE NAME TABLES FOR ATOM AND SCATT NAMES:
      NUMANM=0
      NUMFNM=0
      ATESDS = .FALSE.
C
C NUMBER OF A CARDS:
      NACARD=ICDNO(1)
      NATOM=0
      IF (NACARD .EQ. 0) THEN
        CALL MESS(LPT,1,'No atomic positions have been read from'//
     &  ' Crystal Data File')
        GO TO 100
      ENDIF
C
C
C     NPOS=NUMBER OF GENERAL EQUIVALENT POSITIONS POSSIBLE
      NPOS = NLAT*NOP
C
C READ A CARDS ONE BY ONE:
      ID=IABS(INREAD(1))
      DO 1 IAC= 1,NACARD
      CALL INPUTA(ID,LABA,LBALEN,LABS,LBSLEN,XIN,TIN,SIIN,IER)
      ID=ID+NYZ
C ADD ATOM NAME TO TABLE - THE NAME WILL NOT USUALLY BE THERE ALREADY,
C BUT WE DO NOT AT THIS STAGE MIND IF IT IS:
%      N=LMATCH(LABA,ATNAME,NUMANM,%ATOM%)
      IF (N.GT.NATOM) THEN
%        CALL ERRCHK(2,NATOM,%ATOM%,0,'atomic positions')
C PUT A MARKER TO INDICATES WHETHER POSN AND ESD'S HAVE BEEN READ
        IF (SDREAD) THEN
          X(1,N)=999.
        ELSE
          SDX(1,N)=999.
        ENDIF
      ENDIF
C WAS THIS AN SD CARD OR AN ORDINARY A CARD?
      IF (SDREAD) THEN
        ATESDS=.TRUE.
        CALL GMEQ(XIN,SDX(1,N),1,3)
        SDTF(N)=TIN
        SDSITE(N)=SIIN
** LATER, PRINT
        GO TO 1
      ENDIF
C ATOMIC POSITON:
      NATO(JPHASE)=NATOM
      CALL GMEQ(XIN,X(1,N),1,3)
      TF(N)=TIN
      SITE(N)=SIIN
C ADD SCATTERING FACTOR NAME TO TABLE, OR FIND IT THERE ALREADY:
      LKEEP=NUMFNM
%      L=LMATCH(LABS,FONAME,NUMFNM,%FORM%)
      NFORMF(N)=L
C IF FIRST ATOM OF THIS FACTOR, KEEP A BACKWARDS POINTER ALSO (FOR LSQ)
      IF (L .GT. LKEEP) THEN
        NBKF(L,JPHASE)=N
        NBAKF(L)=N
        NMFNM(JPHASE)=L
      ENDIF
C
C DEAL WITH POSSIBLE SPECIAL POSITION:
      M = 0
C
C  OPERATE WITH EACH SYMMETRY ELEMENT IN TURN:
      ISGEN(1,N)=1
      MC=0
C
C  TEST CENTRE OF SYMMETRY
      IF (CENTRC) THEN
        DO 4 I=1,3
    4   Z(I)=2.*X(I,N)
        IF (LATVEC(Z)) MC=1
      ENDIF
C
C  NOW EACH SYMMETRY OPERATOR
      NTORD(1)=1
      DO 2 NO=2,NOPC
      NTORD(NO)=0
      CALL ROTSYM(X(1,N),Z,NO,1)
C
C  ADD TRANSLATIONAL PART OF SYMMETRY ELEMENT:
      CALL GMADD(Z,TRANS(1,NO),Z,1,3)
      ISIG=1
      CALL GMSUB(X(1,N),Z,Z(4),1,3)
      IF (LATVEC(Z(4))) GO TO 6
C
C IF CENTROSYMMETRIC, TRY RELATED POSITION ALSO:
      IF (.NOT. CENTRC) GO TO 2
      ISIG=-1
      CALL GMADD(X(1,N),Z,Z(4),1,3)
      IF (.NOT. LATVEC(Z(4))) GO TO 2
C
    6 NTORD(NO)=IABS(NORD(NO))
      IF (NTORD(NO).GT.10) NTORD(NO)=NTORD(NO)-100
      NTORD(NO)=ISIG*(NTORD(NO))
C
C  COUNT FOR ORDER OF SUBGROUP
      ISGEN(1,N)=ISGEN(1,N)+1
   2  CONTINUE
C
      M=NPOS/(ISGEN(1,N)*(1+MC))
      IF (MC.EQ.1) ISGEN(1,N)=-ISGEN(1,N)
C
C  GET GENERATORS OF SUBGROUP
      CALL GENELM(NTORD,ISGEN(1,N))
      AMULT(N) = FLOAT(M)/FLOAT(NOP)
   1  CONTINUE
C
C WRITE OUT RESULTS
      CALL MESS(LPT,1,'Atoms in the unit cell are')
      IF (ATESDS) THEN
        CALL MESS(LPT,0,' Mult Name      X                Y         '//
     & '       Z               ITF             Site      Scat Fac '//
     & 'Sub-Group')
      ELSE
        CALL MESS(LPT,0,' Mult Name       X         Y         Z'//
     & '        ITF      Site  Scat Fac Sub-Group')
      ENDIF
      DO 20 N=1,NATOM
      L=NFORMF(N)
      M=JFIX(AMULT(N)*FLOAT(NOP))
      IF (X(1,N).GT.900) THEN
        CALL ERRMES(1,1,
     &  'A card with atomic positions for '//ATNAME(N)//'not found')
        GO TO 20
      ENDIF
      IF (ATESDS) THEN
        CALL RELPOS(N,IPFIX,APFIX)
        IF (SDX(1,N).GT.900) THEN
          II=IPFIX(1)+IPFIX(2)+IPFIX(3)
          IF (II.NE.0) THEN
            CALL ERRMES(1,1,'A card with esd''s'//
     &     'of atomic positions for '//ATNAME(N)//'not found')
            GO TO 20
          ELSE
            CALL GMZER(SDX(1,N),3,1)
          ENDIF
        ENDIF
        DO 21 I=1,3
        IF (IPFIX(I).EQ.0) THEN
          ESDCHR(I)=' '
        ELSE
          WRITE (ESDCHR(I),2105) SDX(I,N)
        ENDIF
   21   CONTINUE
 2105   FORMAT('+/-',F6.4)
        IF (ISGEN(1,N) .GT. 0) THEN
          IF (ISGEN(2,N).EQ.1 .AND. ISGEN(3,N) .EQ.0) THEN
            WRITE (LPT,2103) M,ATNAME(N),(X(I,N),ESDCHR(i),I=1,3),TF(N),
     &      SDTF(N),SITE(N),SDSITE(N),FONAME(L)
          ELSE
            WRITE (LPT,2103) M,ATNAME(N),(X(I,N),ESDCHR(i),I=1,3),TF(N),
     &      SDTF(N),SITE(N),SDSITE(N),FONAME(L),(ISGEN(I,N),I=2,3)
          ENDIF
        ELSE
          WRITE (LPT,2104) M,ATNAME(N),(X(I,N),ESDCHR(i),I=1,3),TF(N),
     &      SDTF(N),SITE(N),SDSITE(N),FONAME(L),(ISGEN(I,N),I=2,3)
      ENDIF
2103  FORMAT (1X,I4,2X,A4,1X,3(F8.4,A9),2(f7.3,'+/-',f5.3),2X,A4,2I3)
2104  FORMAT (1X,I4,2X,A4,1X,3(F8.4,A9),2(f7.3,'+/-',f5.3),2X,A4,2I3
     &,' -1')
      ELSE
        IF (ISGEN(1,N) .GT. 0) THEN
          IF (ISGEN(2,N).EQ.1 .AND. ISGEN(3,N) .EQ.0) THEN
            WRITE (LPT,2003) M,ATNAME(N),(X(I,N),I=1,3),TF(N),
     &      SITE(N),FONAME(L)
          ELSE
            WRITE (LPT,2003) M,ATNAME(N),(X(I,N),I=1,3),TF(N),
     &      SITE(N),FONAME(L),(ISGEN(I,N),I=2,3)
          ENDIF
        ELSE
          WRITE (LPT,2004) M,ATNAME(N),(X(I,N),I=1,3),TF(N),
     &    SITE(N),FONAME(L),(ISGEN(I,N),I=2,3)
        ENDIF
      ENDIF
2003  FORMAT (1X,I4,2X,A4,1X,5F10.4,3X,A4,2I3)
2004  FORMAT (1X,I4,2X,A4,1X,5F10.4,3X,A4,2I3,' -1')
   20 CONTINUE
 100  RETURN
      END
C
C
C
C
C LEVEL 4      SUBROUTINE ATSPEC(N,K,CH)
      SUBROUTINE ATSPEC(N,K,CH)
C
C *** ATSPEC updated by JCM 12 Nov 89 ***
C
CX
CC 8C
CH Makes the 16-character specification of a symmetry related atom from
CH its packed specification.
C
CP Specification must have been packed by a call of NPACK
C
CA N on entry is the packed integer giving atom specification
CA K is a 6-sized integer array which on exit is filled as follows:
CA     K(1)=which atom number was the original
CA     K(2)=which symmetry operator gave current position, -ve if also
CA          needed (-x,-y,-z)
CA     K(3)=which lattice translation
CA     K(4)=which cell in x direction (-1, 0 or +1)
CA     K(5)=which cell in y direction (-1, 0 or +1)
CA     K(6)=which cell in z direction (-1, 0 or +1)
CA CH is a A16 string; on exit it holds a printable representation of K
C
      CHARACTER *16 CH
      DIMENSION K(6),IDIG(5)
/ATNMPK/
C
      CALL NPACK(N,K,6,2,ATPACK)
      CH=' '
      IF (K(2) .NE. 1) THEN
        IF (K(2) .LT. 0) CH(1:1)='-'
        CH(2:2)='S'
        CALL INTDIG(K(2),IDIG,NDIG)
        CALL INTCHR(IDIG,NDIG,CH(3:3),2,0)
      ENDIF
      IF (K(3) .NE. 1) THEN
        CH(6:6)='L'
        CALL INTDIG(K(3),IDIG,NDIG)
        CALL INTCHR(IDIG,NDIG,CH(7:7),1,0)
      ENDIF
      IF (IABS(K(4))+IABS(K(5))+IABS(K(6)) .NE. 0) THEN
        CH(9:9)='('
        IF (K(4) .LT.0) CH(10:10)='-'
        CALL INTDIG(K(4),IDIG,NDIG)
        CALL INTCHR(IDIG,NDIG,CH(11:11),1,0)
        IF (K(5) .LT.0) CH(12:12)='-'
        CALL INTDIG(K(5),IDIG,NDIG)
        CALL INTCHR(IDIG,NDIG,CH(13:13),1,0)
        IF (K(6) .LT.0) CH(14:14)='-'
        CALL INTDIG(K(6),IDIG,NDIG)
        CALL INTCHR(IDIG,NDIG,CH(15:15),1,0)
        CH(16:16)=')'
      ENDIF
      RETURN
      END
C
C
C
C
C LEVEL 3      SUBROUTINE AXIS(R,A)
      SUBROUTINE AXIS(R,A)
C
C *** AXIS by PJB/JCM 28 Jun 83 ***
C
CX
CC 1C
CH Finds the axis of a given rotation matrix.
CA On entry R is a 3x3 rotation matrix
CA On exit  A is a 1x3 vector holding its axis
C
      DIMENSION R(3,3),S(3,3),A(3)
C
C COPY R TO LOCAL S:
      CALL GMEQ(R,S,3,3)
C
C SET D= + OR -1 AS DETERMINANT OF R (AN EIGENVALUE):
      D=1.
      IF (DETER3(S) .LT. 0.) D=-1.
C
C FORM R MINUS D*(UNIT MATRIX):
      DO 1 I=1,3
    1 S(I,I)=S(I,I)-D
C
C I,J,K COUNT CYCLICALLY OVER 1,2,3:
      J=2
      K=3
      DO 3 I=1,3
      A(I)=S(J,J)*S(K,K)-S(J,K)*S(K,J)
      IF (ABS(A(I)).LT.10.E-4) GO TO 2
C A(I) HAS "DIAGONAL" ELEMENT OF VECTOR OF COFACTORS - IF NON-ZERO,
C VECTOR IS ACCEPTABLE, BUT IF ZERO GO ON TO LOOK AT NEXT
      A(J)=S(K,I)*S(J,K)-S(J,I)*S(K,K)
      A(K)=S(K,J)*S(J,I)-S(J,J)*S(K,I)
      GO TO 100
    2 J=K
    3 K=I
 100  CALL FCTOR(A,N)
      RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE BATCH
      SUBROUTINE BATCH
C
C *** BATCH by JCM 27 Jun 86 ***
C
CX
CC 16C
CH Signals batch running, not interactive.
C
CO Sets NBATCH in COMMON /GLOBAL to be the distinctive value 42
C
CN BATCH should be called AFTER INITIL, but before anything else.
CN The relevant input/output unit numbers should also be set up
CN in MAIN, AFTER BATCH, if they differ from the following settings:
C
/CARDRC/
/GLOBAL/
/IOUNIT/
/MAPGT/
/MAPRD/
/MAPSV/
/NEWOLD/
/PRSTAT/
C
      NBATCH=42
      ICRYDA=11
      LUNI=2
      NEWIN=9
      NDUMPS=3
      IDUMPG=4
      IDUMPR=4
      IOP1=2
      IOP2=1
      CALL MESS(LPT,2,'            Batch running - no interaction')
      RETURN
      END
C
C
C
C
C LEVEL 2      SUBROUTINE BIGCHA(BWORD)
      SUBROUTINE BIGCHA(BWORD)
C
C *** BIGCHA corrected by PJB 31-May-1994 ***
C
CX
CC 13C
CH Writes on unit LPT up to 9 characters in large letters.
CA On entry, BWORD is the required word
CO Writes (up to 9) characters of BWORD to output LPT in letters/digits
CO 12 characters wide by 12 lines high, composed of the relevant character
CO and finishes with 2 blank lines
CN Turns lower case into upper
C
      CHARACTER *(*) BWORD
      DIMENSION NSTART(10)
      COMMON /BIGONE/ X(504)
      CHARACTER*12 X
/IOUNIT/
C
      MAXLEN=9
      LENGTH=LENGT(BWORD)
      NCHARS=90
C
      DO 1 J=1,MAXLEN
C DEFAULT SPACE:
      I=40
      IF (J .GT. LENGTH) GO TO 1
      IF (BWORD(J:J) .EQ. ' ') GO TO 1
      I=LETTER(BWORD(J:J))
      IF (I .GT. 0) GO TO 1
      I=NDIGIT(BWORD(J:J))+29
      IF (I .GE. 29) GO TO 1
      I=40
      IF (BWORD(J:J) .EQ. '.') I=27
      IF (BWORD(J:J) .EQ. '+') I=28
      IF (BWORD(J:J) .EQ. '/') I=39
   1  NSTART(J)=(I-1)*12
      DO 2 K=1,12
   2  WRITE(LPT,2000) (X(NSTART(I)+K),I=1,MAXLEN)
2000  FORMAT(10(1X,A12,1X))
      WRITE (LPT,2001)
2001  FORMAT(//)
      RETURN
      END
C
C
C
C
      BLOCK DATA BIGLET
      COMMON /BIGONE/ X
      CHARACTER*12 X(504),A(72),B(72),C(72),D(72),E(72),F(72),G(72)
      EQUIVALENCE (X(1),A(1)),(X(73),B(1)),(X(145),C(1)),
     & (X(217),D(1)),(X(289),E(1)),(X(361),F(1)),(X(433),G(1))
      DATA A/
     &   ' AAAAAAAAAA ','AAAAAAAAAAAA','AA        AA','AA        AA',
     &   'AA        AA','AAAAAAAAAAAA','AAAAAAAAAAAA','AA        AA',
     &   'AA        AA','AA        AA','AA        AA','AA        AA',
     &   'BBBBBBBBBBB ','BBBBBBBBBBBB','BB        BB','BB        BB',
     &   'BB       BB ','BBBBBBBBBB  ','BBBBBBBBBB  ','BB       BB ',
     &   'BB        BB','BB        BB','BBBBBBBBBBBB','BBBBBBBBBBB ',
     &   ' CCCCCCCCCC ','CCCCCCCCCCCC','CC        CC','CC          ',
     &   'CC          ','CC          ','CC          ','CC          ',
     &   'CC          ','CC        CC','CCCCCCCCCCCC',' CCCCCCCCCC ',
     &   'DDDDDDDDD   ','DDDDDDDDDD  ','DD       DD ','DD        DD',
     &   'DD        DD','DD        DD','DD        DD','DD        DD',
     &   'DD        DD','DD       DD ','DDDDDDDDDD  ','DDDDDDDDD   ',
     &   'EEEEEEEEEEEE','EEEEEEEEEEEE','EE          ','EE          ',
     &   'EE          ','EEEEEEEE    ','EEEEEEEE    ','EE          ',
     &   'EE          ','EE          ','EEEEEEEEEEEE','EEEEEEEEEEEE',
     &   'FFFFFFFFFFFF','FFFFFFFFFFFF','FF          ','FF          ',
     &   'FF          ','FFFFFFFF    ','FFFFFFFF    ','FF          ',
     &   'FF          ','FF          ','FF          ','FF          '/
      DATA B/
     &   ' GGGGGGGGGG ','GGGGGGGGGGGG','GG        GG','GG          ',
     &   'GG          ','GG          ','GG     GGGGG','GG     GGGGG',
     &   'GG        GG','GG        GG','GGGGGGGGGGGG',' GGGGGGGGGG ',
     &   'HH        HH','HH        HH','HH        HH','HH        HH',
     &   'HH        HH','HHHHHHHHHHHH','HHHHHHHHHHHH','HH        HH',
     &   'HH        HH','HH        HH','HH        HH','HH        HH',
     &   ' IIIIIIIIII ',' IIIIIIIIII ','     II     ','     II     ',
     &   '     II     ','     II     ','     II     ','     II     ',
     &   '     II     ','     II     ',' IIIIIIIIII ',' IIIIIIIIII ',
     &   '  JJJJJJJJJJ','  JJJJJJJJJJ','      JJ    ','      JJ    ',
     &   '      JJ    ','      JJ    ','      JJ    ','      JJ    ',
     &   'JJ    JJ    ','JJ    JJ    ','JJJJJJJJ    ',' JJJJJJ     ',
     &   'KK        KK','KK       KK ','KK      KK  ','KK     KK   ',
     &   'KK    KK    ','KKKKKKK     ','KKKKKKK     ','KK    KK    ',
     &   'KK     KK   ','KK      KK  ','KK       KK ','KK        KK',
     &   'LL          ','LL          ','LL          ','LL          ',
     &   'LL          ','LL          ','LL          ','LL          ',
     &   'LL          ','LL          ','LLLLLLLLLLLL','LLLLLLLLLLLL'/
      DATA C/
     &   'MM        MM','MMM      MMM','MMMM    MMMM','MM MM  MM MM',
     &   'MM  MMMM  MM','MM   MM   MM','MM        MM','MM        MM',
     &   'MM        MM','MM        MM','MM        MM','MM        MM',
     &   'NN        NN','NNN       NN','NNNN      NN','NN NN     NN',
     &   'NN  NN    NN','NN   NN   NN','NN    NN  NN','NN     NN NN',
     &   'NN      NNNN','NN       NNN','NN        NN','NN         N',
     &   'OOOOOOOOOOOO','OOOOOOOOOOOO','OO        OO','OO        OO',
     &   'OO        OO','OO        OO','OO        OO','OO        OO',
     &   'OO        OO','OO        OO','OOOOOOOOOOOO','OOOOOOOOOOOO',
     &   'PPPPPPPPPPP ','PPPPPPPPPPPP','PP        PP','PP        PP',
     &   'PP        PP','PPPPPPPPPPPP','PPPPPPPPPPP ','PP          ',
     &   'PP          ','PP          ','PP          ','PP          ',
     &   ' QQQQQQQQQQ ','QQQQQQQQQQQQ','QQ        QQ','QQ        QQ',
     &   'QQ        QQ','QQ        QQ','QQ        QQ','QQ    QQ  QQ',
     &   'QQ     QQ QQ','QQ      QQQQ','QQQQQQQQQQQ ',' QQQQQQQQ QQ',
     &   'RRRRRRRRRRR ','RRRRRRRRRRRR','RR        RR','RR        RR',
     &   'RR        RR','RRRRRRRRRRRR','RRRRRRRRRRR ','RR    RR    ',
     &   'RR     RR   ','RR      RR  ','RR       RR ','RR        RR'/
      DATA D/
     &   ' SSSSSSSSSS ','SSSSSSSSSSSS','SS        SS','SS          ',
     &   'SSS         ',' SSSSSSSSS  ','  SSSSSSSSS ','         SSS',
     &   '          SS','SS        SS','SSSSSSSSSSSS',' SSSSSSSSSS ',
     &   'TTTTTTTTTTTT','TTTTTTTTTTTT','     TT     ','     TT     ',
     &   '     TT     ','     TT     ','     TT     ','     TT     ',
     &   '     TT     ','     TT     ','     TT     ','     TT     ',
     &   'UU        UU','UU        UU','UU        UU','UU        UU',
     &   'UU        UU','UU        UU','UU        UU','UU        UU',
     &   'UU        UU','UU        UU','UUUUUUUUUUUU',' UUUUUUUUUU ',
     &   'VV        VV','VV        VV','VV        VV','VV        VV',
     &   'VV        VV','VV        VV','VV        VV',' VV      VV ',
     &   '  VV    VV  ','   VV  VV   ','    VVVV    ','     VV     ',
     &   'WW        WW','WW        WW','WW        WW','WW        WW',
     &   'WW        WW','WW        WW','WW   WW   WW','WW  WWWW  WW',
     &   'WW WW  WW WW','WWWW    WWWW','WWW      WWW','WW        WW',
     &   'XX        XX','XX        XX',' XX      XX ','  XX    XX  ',
     &   '   XX  XX   ','    XXXX    ','    XXXX    ','   XX  XX   ',
     &   '  XX    XX  ',' XX      XX ','XX        XX','XX        XX'/
      DATA E/
     &   'YY        YY','YY        YY',' YY      YY ','  YY    YY  ',
     &   '   YY  YY   ','    YYYY    ','     YY     ','     YY     ',
     &   '     YY     ','     YY     ','     YY     ','     YY     ',
     &   'ZZZZZZZZZZZZ','ZZZZZZZZZZZZ','         ZZ ','        ZZ  ',
     &   '       ZZ   ','      ZZ    ','     ZZ     ','    ZZ      ',
     &   '   ZZ       ','  ZZ        ',' ZZZZZZZZZZZ','ZZZZZZZZZZZZ',
     &   '            ','            ','            ','            ',
     &   '            ','            ','            ','            ',
     &   '     ..     ','    ....    ','    ....    ','     ..     ',
     &   '            ','     ++     ','     ++     ','     ++     ',
     &   '     ++     ',' ++++++++++ ',' ++++++++++ ','     ++     ',
     &   '     ++     ','     ++     ','     ++     ','            ',
     &   '  00000000  ',' 0000000000 ','00        00','00        00',
     &   '00        00','00        00','00        00','00        00',
     &   '00        00','00        00',' 0000000000 ','  00000000  ',
     &   '     11     ','    111     ','   1111     ','     11     ',
     &   '     11     ','     11     ','     11     ','     11     ',
     &   '     11     ','     11     ',' 1111111111 ',' 1111111111 '/
      DATA F/
     &   ' 2222222222 ','222222222222','22        22','          22',
     &   '          22','         22 ','       22   ','     22     ',
     &   '   22       ',' 22         ','222222222222','222222222222',
     &   ' 3333333333 ','333333333333','33        33','          33',
     &   '          33','       3333 ','       3333 ','          33',
     &   '          33','33        33','333333333333',' 3333333333 ',
     &   '      444   ','     4444   ','    44 44   ','   44  44   ',
     &   '  44   44   ',' 44444444444','444444444444','       44   ',
     &   '       44   ','       44   ','       44   ','       44   ',
     &   '555555555555','555555555555','55          ','55          ',
     &   '55          ','555555555   ','5555555555  ','         55 ',
     &   '          55','          55','555555555555','55555555555 ',
     &   ' 6666666666 ','666666666666','66        66','66          ',
     &   '66          ','66666666666 ','666666666666','66        66',
     &   '66        66','66        66','666666666666',' 6666666666 ',
     &   '777777777777','77777777777 ','77      77  ','       77   ',
     &   '      77    ','     77     ','     77     ','     77     ',
     &   '     77     ','     77     ','     77     ','     77     '/
      DATA G/
     &   ' 8888888888 ','888888888888','88        88','88        88',
     &   ' 88      88 ','  88888888  ','  88888888  ',' 88      88 ',
     &   '88        88','88        88','888888888888',' 8888888888 ',
     &   ' 9999999999 ','999999999999','99        99','99        99',
     &   '99        99','999999999999','999999999999','          99',
     &   '          99','99        99','999999999999',' 9999999999 ',
     &   '          //','         // ','        //  ','       //   ',
     &   '      //    ','     //     ','    //      ','   //       ',
     &   '  //        ',' //         ','//          ','            ',
     &               36*'            '/
      END
C
C
C
C
C LEVEL 6      SUBROUTINE BIGGAM(K,IQ,CSMAX,LBIG)
      SUBROUTINE BIGGAM(K,IQ,CSMAX,LBIG)
C
C *** BIGGAM updated by PJB 24-May-2000 ***
C
CX
CC 2B
CH Deals with gammas whose value is greater than one, in SORGAM.
CH There is also the entry SETGAM to set up the calculation.
CA On entry K is a set of reflection indices to be tested
CA IQ is returned as 1 if gamma for this reflection is greater than 1
CA       returned as 0 otherwise
CA CSMAX is the maximum value of cos(rho) for which the effective gamma
CA       is >1
CA Entry SETGAM SOME is a logical which is set true if a GAMA 1 is found
CA                   on an I card.  It is false otherwise.
CA LBIG is the unit from which the indices are read, it is set by SETGAM
CA      and used by BIGGAM, the value tranferred via the calling program.
C
      DIMENSION K(3)
      LOGICAL ENDG,SOME,ONCARD
      CHARACTER *10 FILNOM
      COMMON /BIGAM/KG(3),CSRED,ENDG
/IOUNIT/
/SCRACH/
C
      IQ=0
      IF (ENDG) GO TO 100
C
      DO 1 I=3,1,-1
      IF (KG(I)-K(I)) 2,1,100
    1 CONTINUE
C MATCH:
      IF (CSRED.NE.0.) THEN
        WRITE (ITO,16)KG,CSRED
      ELSE
        WRITE (ITO,17)KG
      ENDIF
   16 FORMAT (' Gamma > 1 for ',3I3,' and Cos(rho) >',F7.4)
   17 FORMAT (' Gamma > 1 for ',3I3)
      IQ=1
      CSMAX=CSRED
      GO TO 5
C
C  INDICES OUT OF ORDER
    2 WRITE (ITO,12) K,KG
   12 FORMAT (' Error in order of indices matching',3I3,' with',3I3/
     & ' Gamma < 1 assumed from here on')
    4 ENDG =.TRUE.
      GO TO 100
C
C  SETUP ENTRY
      ENTRY SETGAM(SOME,LBIG)
      ENDG=.FALSE.
      SOME=.FALSE.
C  SEARCH FOR GAMA ON ICARD = IF NOT FOUND ASSUME ALL GAMMA < 1
      IF (.NOT. ONCARD('I','GAMA',A)) GO TO 100
C
      IGAM=JFIX(A)
      IF (IGAM.EQ.0) GO TO 100
    6 CALL ASK('File of labelling indices for gamma > 1 reflections ?')
      LBIG=NOPFIL(21)
      IF (LBIG .LE. 0) GO TO 6
      CALL MESS(LPT,1,'Reflections with abs(gamma) > 1 from file '//
     & FILNOM(LBIG)//' these marked ** on the output list')
      SOME = .TRUE.
    5 READ (LBIG,11,END=4) KG,CSRED
   11 FORMAT (3I5,F10.4)
  100 RETURN
      END
C
C
C
C
C LEVEL 2      LOGICAL FUNCTION BINDIG(N,NBIN)
      LOGICAL FUNCTION BINDIG(N,NBIN)
C
C *** BINDIG by JCM 13 Nov 91 ***
C
CX
CC 11C
CH Tests for the presence of a given binary digit within an integer.
CA On entry N is the integer to be tested
CA          NBIN is a binary digit (in decimal form, e.g. 1, 2, 4, 8 etc)
CA On exit BINDIG is TRUE if N contains NBIN, FALSE if not.
CN NBIN is not checked;  if it is not pure binary there will be strange results.
C
      LOGICAL EVEN
C
      IF (NBIN .NE. 0) THEN
        CALL PARITY(IABS(N/NBIN),I,EVEN)
        BINDIG=.NOT. EVEN
      ELSE
        BINDIG=.TRUE.
      ENDIF
      RETURN
      END
C
C
C
C
C LEVEL 2      SUBROUTINE BITSET(I,NC,TEST,SET)
      SUBROUTINE BITSET(I,NC,TEST,SET)
C
C *** BITSET by JCM 25 Nov 82 ***
C
CX
CC 15C
CH Sets or tests a single bit in a word.
CA On entry I,NC pick out the required bit in array IBIT
CA          SET is a LOGICAL.
CA On exit, if SET is TRUE, sets relevant single bit into array IBIT.
CA          if FALSE, sets LOGICAL TEST to indicate whether relevant bit is
CA                    already present in IBIT, and removes it if it is.
C
      LOGICAL TEST,SET
/BITMAP/
/IOUNIT/
/LENINT/
C
      J = (NC-1)/NBITS + 1
      IF (J .LE. NWORDS) GO TO 3
      WRITE (LPT,3000) J,NWORDS,NC,NBITS
      WRITE (ITO,3000) J,NWORDS,NC,NBITS
3000  FORMAT (/' ERROR ** in BITSET - integer',I4,' called, but ',
     & 'only',I4,' available.  NC, NBITS=',2I4)
      STOP
C
   3  IB = MOD(NC,NBITS)
      IF (IB .EQ. 0) IB = NBITS
      M=ITPOS(IB)
      IF (SET) GO TO 1
      TEST = (LOGAND(IBIT(I,J),M) .NE. 0)
      IF (TEST) IBIT(I,J)=IBIT(I,J)-M
      GO TO 100
C
   1  IBIT(I,J)=LOGOR(IBIT(I,J),M)
 100  RETURN
      END
C
C
C
C
C LEVEL 3      FUNCTION BJ(N,X)
      FUNCTION BJ(N,X)
C
C *** BJ by JCM 17 Jan 85 ***
C
CX
CC 9C
CH Calculates Bessel functions of order 1 or 2.
CA On entry N is the order required
CA          X is the argument
CA On exit BJ holds the required Bessel function
CD Uses Harwell Library FF01A or FF02A, which have been included as
CD part of the CCSL.
C
C
      IF (N-1) 1,2,99
C
C ORDER 1:
    1 CALL FF01A(BJ,Y,X,0)
      GO TO 100
C
C ORDER 2:
    2 CALL FF02A(BJ,Y,X,0)
      GO TO 100
C
C ANY OTHER ORDER:
  99  CALL ERRIN2(N,0,'Bessel function order',' not calculated by BJ')
 100  RETURN
      END
C
C
C
C
C LEVEL 5      SUBROUTINE BNDLST(NAME1,NAME2)
      SUBROUTINE BNDLST(NAME1,NAME2)
C
C *** BNDLST updated by PJB  22 Apr 2003 C123 ***
C
CX
CC 8B
CH Writes out and saves a list of bonds from one atomic position.
CA On entry NAME1 is the name of source atom in list in /POSNS/,
CA                   NOT a general atom name (i.e. all letters) because that
CA                   would not group together bonds from a single atom, to
CA                   be used in angles.
CA          NAME2  is EITHER the name of one destination atom,
CA                    OR a general atom name.
CP In /BONDLA/ BMAX and BMIN give the limits of bonds to consider.
C
CD To find both NAME1 and NAME2, scans the list in ATNAME.  Accepts a complete
CD match;  also for NAME2 accepts a match of a general atom name with ALL the
CD starting letters of a name in the list.
C
CD So, e.g. for NAME2, Si2 matches with ONLY Si2 (not Si23)
CD                     Si matches with Si, Si1, Si2 etc (not SiA)
C
CD Makes from atom 2 all useful destination atoms related by symmetry to it.
CD Because bonds are also used as slack constraints in LSQ, the destination atom
CD formed by a particular symmetry operation, which may well fall outside the
CD original unit cell (i.e. have coordinates < 0 or > 1) is NOT now put
CD back into the original cell.  Previously it was, and the resulting
CD 3x3x3 cube of cells was scanned.  This makes a terrible mess of refined
CD coordinates which themselves hop over a cell edge.
CD So now a symmetry related position is formed, and the surrounding 5x5x5
CD cube of unit cells is scanned.
CD
CD A list of found bonds (and related information) is held in /BONDLA/ for
CD use when rejecting duplicate bonds, and perhaps later if angles are
CD required.
C
CO Writes found bonds to unit LPT with their esd's if these were requested
CD by including a B BESD card.
CO Writes generated cards to unit LSK
C
      CHARACTER *16 CH
      CHARACTER *4 NAME1,NAME2,GENNAM,TONAME
      LOGICAL DONT,HEAD,MIDD
      DIMENSION DX(3),CEL(3),XD(3),X1(3),X2(3),XD1(3),XD2(3),K(6),ODX(3)
      DIMENSION ZER(3),CELXYZ(3)
/ATNAM/
/ATNMPK/
/BANERR/
/BONDLA/
/IOUNIT/
/NSYM/
/POSNS/
/SLKGEC/
/SLKGEO/
/SYMDA/
      DATA ZER/0.,0.,0./
C
C
      IF (BNDESD) THEN
        CALL JGMZER(IATS,2,1)
        IOP(1)=0
        ENDIF
C IDENTIFY SOURCE:
      I1=IATOM(NAME1)
      IF (I1 .LE. 0) GO TO 100
C
C ADD TO LIST:
      CALL ADDATM(NAME1,I1,X(1,I1),1,1,ZER,N1)
C
C CLEAR COUNT OF SAVED BONDS IF NEW SOURCE:
      IF (I1 .NE. I1LAST) THEN
        NB=0
        HEAD=.TRUE.
      ENDIF
      I1LAST=I1
C
C IDENTIFY DESTINATION:
      DO 42 I2=1,NATOM
      IF (NAME2 .NE. ATNAME(I2) .AND. GENNAM(ATNAME(I2))
     & .NE. NAME2) GO TO 42
C
C123 SET START OF BOND COUNT FOR THIS DESTINATION
      NPREV = NB
      DO 14 I=1,3
      X1(I)=X(I,I1)
C DO NOT NOW PUT SOURCE ATOM INTO CENTRAL CELL:
C      CALL FRACT(X1(I),Y,N)
      X2(I)=X(I,I2)
   14 CONTINUE
C
C OUTER CYCLE OVER CENTRE OF SYMMETRY IF PRESENT:
      DO 1 IC=1,NCENT
C NEXT CYCLE OVER SYMMETRY OPERATORS FOR SPACE GROUP
      DO 2 IS=1,NOPC
      CALL ROTSYM(X2,XD1,IS,1)
      CALL GMADD(XD1,TRANS(1,IS),XD1,1,3)
      IF (IC .EQ. 2) CALL GMREV(XD1,XD1,1,3)
C
C MIDDLE CYCLE OVER LATTICE SYMMETRY
      DO 3 IL=1,NLAT
      CALL GMADD(XD1,ALAT(1,IL),XD2,1,3)
C
C DO NOT NOW PUT DESTINATION ATOM INTO CENTRAL CELL
C      CALL FRAC3(XD2)
C
C INNER CYCLES OVER 5x5x5 UNIT CELLS, WHICH IS OVERKILL & SLOW BUT WON'T MISS
C MUCH:
      DO 4 NCELZ=1,5
      CEL(3)=FLOAT(NCELZ-3)
      DO 5 NCELY=1,5
      CEL(2)=FLOAT(NCELY-3)
      DO 6 NCELX=1,5
      CEL(1)=FLOAT(NCELX-3)
C
      CALL GMADD(XD2,CEL,XD,1,3)
      CALL GMSUB(X1,XD,DX,1,3)
C REJECT IF ONE LENGTH IS > MAX BOND:
      DO 38 I=1,3
      IF (DX(I) .GT. BMAX) GO TO 6
  38  CONTINUE
C
      B = VCTMOD(1.,DX,1)
      IF (B .GT. BMAX) GO TO 6
      IF (B .LT. BMIN) GO TO 6
      IF (B .LT. 0.00001) GO TO 6
C
C SAVE BOND:
      DO 12 I=1,NB
      DO 13 J=1,3
      IF (ABS(DXSAVE(J,I)-DX(J)) .GT. 0.00001) GO TO 12
  13  CONTINUE
C TO 6 IF LATEST BOND HAS OCCURRED PREVIOUSLY AND IS NOT WANTED AGAIN
C123 IT MAY BE THE SAME POSITION UNDER A DIFFERENT NAME
      IF (I .GT .NPREV) GO TO 6
  12  CONTINUE
%      CALL ERRCHK(2,NB,%BSAV%,0,'bonds from 1 atom')
      BSAVE(NB)=B
      IF (BNDESD) THEN
        ISC=IS
        IF (IC.EQ.2) ISC=-ISC
        CALL BONERR(I1,I2,ISC,DX,B,BERR)
      ENDIF
      DXSAVE(1,NB)=DX(1)
      DXSAVE(2,NB)=DX(2)
      DXSAVE(3,NB)=DX(3)
      N2SAVE(NB)=I2
C
C FORM THETA, PHI ANGLES AND REPORT THEM WITH DELTAS(X,Y,Z)
      CALL ORTHO(DX,ODX,1)
      CALL GMREV(ODX,ODX,1,3)
      CALL UNIVEC(ODX,C)
      ANGT1=DEGREE(ACOS(ODX(3)))
      DONT = (ABS(ODX(3)) .GT. 0.9999)
      IF (.NOT. DONT) ANGT2=DEGREE(ATAN2(ODX(2),ODX(1)))
      MIDD = ((IL.EQ.1) .AND. (IS.EQ.1) .AND. (NCELX.EQ.3) .AND.
     & (NCELY.EQ.3) .AND. (NCELZ.EQ.3) .AND. (IC .EQ. 1))
      IF (HEAD) THEN
        IF (BNDESD) THEN
          CALL MESS(LPT,2,'    SOURCE ATOM: '//NAME1)
          CALL MESS(LPT,0,'Atom1-Atom2         Bond           Atom 2'//
     &   '               Position                Atom 1 - Atom 2'//
     &   '       Bond Angles')
        CALL MESS(LPT,0,'                              '//
     &   '(if not original)   '//
     & '   x       y       z      delta x delta y delta z   theta phi')
        ELSE
          CALL MESS(LPT,2,'    SOURCE ATOM: '//NAME1)
          CALL MESS(LPT,0,'Atom1-Atom2     Bond        Atom 2'//
     & '               Position                Atom 1 - Atom 2'//
     & '       Bond Angles')
          CALL MESS(LPT,0,'                       (if not original)'//
     & '      x       y       z      delta x delta y delta z   '//
     & 'theta phi')
       ENDIF
      ENDIF
      HEAD=.FALSE.
C
C IF MAKING CARDS FOR SLACK CONSTRAINTS:
      IF (SLK) THEN
        IF (.NOT. MIDD) THEN
C INVENT NEW NAME INTO TONAME:
          CELXYZ(1)=FLOAT(NCELX-3)
          CELXYZ(2)=FLOAT(NCELY-3)
          CELXYZ(3)=FLOAT(NCELZ-3)
          ISC=IS*(3-2*IC)
          NOLD=NTARNM
          CALL ADDATM('    ',I2,XD,ISC,IL,CELXYZ,N2)
          IF (NOLD .LT. NTARNM) THEN
            TONAME=ATTNAM(NTARNM)
            WRITE (LSK,2005) TONAME,ATNAME(I2),ISC,IL,NCELX-3,
     &      NCELY-3,NCELZ-3
2005        FORMAT ('L ATOM ',A4,2X,A4,2X,I3,2X,I3,2X,3I3)
          ELSE
            TONAME=ATTNAM(N2)
            GO TO 43
          ENDIF
        ELSE
          TONAME=ATNAME(I2)
C ADD TO LIST:
          CALL ADDATM(TONAME,I2,X(1,I2),1,1,ZER,N2)
        ENDIF
  43    NOLD=NUMBON
        CALL ADDBON('    ',N1,N2,NN)
        NBSAVE(NB)=NN
        N3SAVE(NB)=N2
        IF (NOLD .EQ. NUMBON) GO TO 6
        IF (.NOT. BONOUT) THEN
          WRITE (LSK,2051) BONNAM(NN),NAME1,TONAME,BON2,SD2
2051      FORMAT ('L BOND ',A4,2X,A4,2X,A4,2F10.5)
        ELSE
          WRITE (LSK,2051) BONNAM(NN),NAME1,TONAME
        ENDIF
      ENDIF
      IF (MIDD) GO TO 10
C
      K(1)=I2
      K(2)=(3-2*IC)*IS
      K(3)=IL
      K(4)=NCELX-3
      K(5)=NCELY-3
      K(6)=NCELZ-3
      CALL NPACK(I3,K,6,1,ATPACK)
      N2SAVE(NB)=-I3
      CALL ATSPEC(I3,K,CH)
      IF (BNDESD) THEN
C123 Include writing machine readable o/p to LBOND if it is non-zero
        IF (DONT) WRITE (LPT,2100) ATNAME(I1),ATNAME(I2),B,BERR,CH,XD,
     &  DX,ANGT1
        IF (.NOT. DONT) WRITE (LPT,2100) ATNAME(I1),ATNAME(I2),
     &  B,BERR,CH,XD,DX,ANGT1,ANGT2
2100    FORMAT (1X,A4,' - ',A4,F7.4,'+/-',F7.4,2X,A16,2X,3F8.4,2X,
     &       3F8.4,2F8.2)
        IF (LBOND .NE. 0) WRITE (LBOND,2014)
     &  ATNAME(I1),ATNAME(I2),B,BERR
        GO TO 6
2101  FORMAT (1X,A4,' - ',A4,F7.4,'+/-',F7.4,46X,3F8.4,2F8.2)
      ELSE
        IF (DONT) WRITE (LPT,2000) ATNAME(I1),ATNAME(I2),B,CH,XD,DX,
     &  ANGT1
        IF (.NOT. DONT) WRITE (LPT,2000) ATNAME(I1),ATNAME(I2),
     &  B,CH,XD,DX,ANGT1,ANGT2
2000    FORMAT (1X,A4,' - ',A4,F10.4,2X,A16,2X,3F8.4,2X,3F8.4,2F8.2)
      ENDIF
        IF (LBOND .NE. 0) WRITE (LBOND,2014)
     &  ATNAME(I1),ATNAME(I2),B
      GO TO 6
  10  IF (BNDESD) THEN
        IF (DONT) WRITE (LPT,2101) ATNAME(I1),ATNAME(I2),B,BERR,DX,ANGT1
        IF (.NOT. DONT) WRITE (LPT,2101) ATNAME(I1),ATNAME(I2),
     &  B,BERR,DX,ANGT1,ANGT2
        IF (LBOND .NE. 0) WRITE (LBOND,2014)
     &  ATNAME(I1),ATNAME(I2),B,BERR
 2014  FORMAT ('Bond:  ',2(A4,2X),2F8.4)
      ELSE
        IF (DONT) WRITE (LPT,2001) ATNAME(I1),ATNAME(I2),B,DX,ANGT1
        IF (.NOT. DONT) WRITE (LPT,2001) ATNAME(I1),ATNAME(I2),
     &  B,DX,ANGT1,ANGT2
2001    FORMAT (1X,A4,' - ',A4,F10.4,46X,3F8.4,2F8.2)
        IF (LBOND .NE. 0) WRITE (LBOND,2014)
     &  ATNAME(I1),ATNAME(I2),B
      ENDIF
   6  CONTINUE
   5  CONTINUE
   4  CONTINUE
   3  CONTINUE
   2  CONTINUE
   1  CONTINUE
  42  CONTINUE
 100  RETURN
      END
C
C
C
C
C LEVEL 3      SUBROUTINE BONCOS(B1,B2,B3,ANGLE,COSTH,SINTH,DADB)
      SUBROUTINE BONCOS(B1,B2,B3,ANGLE,COSTH,SINTH,DADB)
C
C *** BONCOS by JCM 18 Oct 90 ***
C
CX
CC 8B
CH Given 3 bonds forming a triangle, calculates the angle opposite the first,
CH its sine and cosine, and its derivatives wrt all 3 bonds.
CA On entry B1, B2, B3 are the values of the bonds (not their pointers)
CA On exit ANGLE is the angle opposite B1 in radians
CA         COSTH is its sine
CA         SINTH is its cosine
CA         DADB is a 1x3 array holding the derivatives of ANGLE wrt B1,B2,B3
C
      DIMENSION DADB(3)
C
      COSTH=(B2*B2 + B3*B3 - B1*B1)/(2.*B2*B3)
      CALL SINCOS(COSTH,SINTH,'BONCOS')
C ANGLE IN RADIANS:
      ANGLE=(ARCCOS(COSTH))
C
C DERIVATIVES OF COS THETA WRT B1, THEN B2, THEN B3
      DADB(1)=-(B1/(B2*B3))
      DADB(2)=1./B3 - COSTH/B2
      DADB(3)=1./B2 - COSTH/B3
C CONVERT TO BE DERIVATIVES OF THETA RADIANS WRT BONDS:
      DO 1 I=1,3
   1  DADB(I)=-(DADB(I)/SINTH)
      RETURN
      END
C
C
C
C
C LEVEL 2      FUNCTION BONDA(I1,I2,I3)
      FUNCTION BONDA(I1,I2,I3)
C
C *** BONDA by JCM 1 Oct 86 ***
C
CX
CC 8B
CH Calculates the angle between two bonds.
CA On entry I1 is the serial number of one atom in list in /POSNS/
CA          I2 is the serial number of the central atom
CA          I3 is the serial number of the third atom
CA On exit BONDA is the angle between the bonds, in degrees
CD Calculates the angle between bonds joining atoms I1-I2 and I2-I3.
CD Does no symmetry operations at all.
CN It would probably be useful also to have a routine which accepts as
CN arguments X1(1:3), X2(1:3) and X3(1:3), position coordinates.
C
      DIMENSION D12(3),D23(3)
/POSNS/
C
      DO 1 I=1,3
      D12(I)=X(I,I1)-X(I,I2)
      D23(I)=X(I,I3)-X(I,I2)
   1  CONTINUE
      B12=VCTMOD(1.,D12,1)
      B23=VCTMOD(1.,D23,1)
      COSTH=SCLPRD(D12,D23,1)/(B12*B23)
      CALL SINCOS(COSTH,SINTH,'BONDA')
      BONDA=DEGREE(ATAN2(SINTH,COSTH))
      RETURN
      END
C
C
C
C
C LEVEL 3      SUBROUTINE BONDER(N)
      SUBROUTINE BONDER(N)
C
C *** BONDER updated by JCM 22 Oct 90 ***
C
CX
CC 8B
CH Calculate a bond and its derivatives for slack constraints.
CA On entry N points to which bond of the list in /SLKGEO is wanted
CD On exit, in /SLKGEO, BCALC(N) = bond length
CD Also sets up the 12 derivatives (whether needed or not) in /SLKGEO
CD        DERPOS(3,N,2)=derivatives of BCALC wrt x,y,z (in original
CD                      atom lists), both ends.
CD        DERCEL(6,N)  =derivatives of BCALC wrt A*, B*, C* etc
CD                      the cell quadratic products in reciprocal space
C
      DIMENSION DX(3),TEMP(3),TEMP1(6)
/CELPAR/
/SLKGEO/
C
C N IS THE BOND - SET N1 & N2 TO POINT TO ITS END ATOMS:
      N1=IATM(N,1)
      N2=IATM(N,2)
C DIFFERENCE VECTOR - DIFFERENCES BETWEEN ACTUAL COORDS OF ENDS:
      CALL GMSUB(XSLAK(1,N1),XSLAK(1,N2),DX,1,3)
C BOND:
      BCALC(N)=VCTMOD(1.,DX,1)
C
C DERIVATIVES WRT 6 CELL QUADRATIC PRODUCTS, FIRST IN REAL SPACE:
      J=2
      K=3
      DO 2 I=1,3
      DERCEL(I,N)=DX(I)*DX(I)/(2.*BCALC(N))
      DERCEL(I+3,N)=DX(J)*DX(K)/BCALC(N)
      J=K
   2  K=I
C THEN CONVERTED TO RECIPROCAL:
      CALL GMPRD(TOSTAR,DERCEL(1,N),TEMP1,6,6,1)
      CALL GMEQ(TEMP1,DERCEL(1,N),1,6)
C
C DERIVATIVES WRT GIVEN COORDS:
C INTO TEMP1 PUT a(a*DX + b cos gamma *DY + c cos beta *DZ)
C                b(a cos gamma *DX + b*DY + c cos alpha *DZ)
C                c(a cos beta *DX + b cos alpha *DY + c*DZ)
C WHICH IS Bond*(dBond/dX1, dBond/dY1, dBond/dZ1) OR
C ALSO    -Bond*(dBond/dX2, dBond/dY2, dBond/dZ2)
C
C VECTOR a*DX, b*DY, c*DZ:
      DO 11 I=1,3
  11  TEMP(I)=CELL(I,1,1)*DX(I)
C CONVERT USING COSINE MATRIX:
      CALL GMPRD(COSIN,TEMP,TEMP1,3,3,1)
      DO 12 I=1,3
  12  TEMP1(I)=TEMP1(I)*CELL(I,1,1)
C CONVERT DERIVS WRT ACTUAL COORDS TO THOSE WRT PARAMETERS OF REFINEMENT
      CALL ROTSYM(TEMP1,DERPOS(1,N,1),IABS(ISYM(N1)),1)
C IF CENTRE INVOLVED, REVERSE:
      IF (ISYM(N1).LT.0) CALL GMREV(DERPOS(1,N,1),
     & DERPOS(1,N,1),1,3)
C AND FOR SECOND ATOM, REVERSING SIGNS:
      CALL ROTSYM(TEMP1,DERPOS(1,N,2),IABS(ISYM(N2)),1)
      IF (ISYM(N2) .GT. 0) CALL GMREV(DERPOS(1,N,2),
     & DERPOS(1,N,2),1,3)
C FINALLY DIVIDE BY THE BOND, AS THE EXPRESSION WE HAVE DIFFERENTIATED IS
C BOND SQUARED, AND WE HAVE CANCELLED A 2:
      DO 21 I=1,3
      DO 21 J=1,2
  21  DERPOS(I,N,J)=DERPOS(I,N,J)/BCALC(N)
      RETURN
      END
C
C
C
C
C LEVEL 4      SUBROUTINE BONERR(I1,I2,IS,XBON,BL,BERR)
      SUBROUTINE BONERR(I1,I2,IS,XBON,BL,BERR)
C
C  *** BONERR corrected by PJB C98 Oct-2000 ***
CX
CC 8B
CH To calculate the esd's in bondlengths
C
CA On entry I1 and I2 are the source and destination atoms
CA          XBON is the vector in real space coordinates joining the two atoms
CA          IS is the operator creating I2, negative if reversed
CA          BL is the bondlength
CA On exit  BERR is the esd
CD The subroutine calculates the esd of the bondlength using both the
CD esd's in the atomic coordinates and those in the cell quadratic
CD products The result is stored in COMMON BESDS as BERR(IB)
      DIMENSION RLMAT(6,6),SPXVEC(6),SPCVEC(6),TVEC(3),
     &AEXVEC(6),AECVEC(6),IPT(3,3),XP(3,2),XBON(3)
      LOGICAL NEW(2)
/BANERR/
/CELFIX/
/CELPAR/
/IOUNIT/
/POSNS/
C
       DATA IPT/1,6,5,6,2,4,5,4,3/
C
      IF (.NOT. ATESDS) GO TO 30
C Set up the position constraints
      NEW(1)=I1.NE.IATS(1)
      IATS(1)=I1
      NEW(2)=I2.NE.IATS(2)
      IATS(2)=I2
       DO 1 I=1,2
      IF (NEW(I)) THEN
        CALL RELPOS(IATS(I),IPFIX(1,I),APFIX(1,I))
        IF (I.EQ.1) CALL RELMT3(IPFIX(1,1),APFIX(1,1),1,RELMT(1,1,I))
      ENDIF
    1 CONTINUE
      IF (IOP(1).NE.IS) THEN
        IOP(1)=IS
        CALL RELMT3(IPFIX(1,2),APFIX(1,2),IOP(1),RELMT(1,1,2))
      ENDIF
      CALL RELMTX(RELMT,RLMAT,IATS,2)
C GET the POSITIONS
   30 CALL GMEQ(X(1,IATS(1)),XP(1,1),3,1)
      CALL GMSUB(X(1,IATS(1)),XBON,XP(1,2),3,1)
C FORM THE WEIGHTING FACTORS
      TVEC(2)= 1/BL
      TVEC(1)=0.5*TVEC(2)
C now sum over all the scalar products for coordinate errors (TMPVEC)
C and those for lattice parameter errors TMPVC1
      CALL GMZER(SPXVEC,6,1)
      CALL GMZER(SPCVEC,6,1)
C These loops restructured Sep 2000
C Sum over the parameter index for cellpars,
      DO 4 IX=1,3
C Sum over the parameter index or cellpars, (xyz) for atom J for coords
      DO 5 JX=1,3
C SPCVEC acumulates the differentials with respect to the lattice constants
C stored by cpar labels
      IF (SDCELL) THEN
        TERM=XBON(IX)*XBON(JX)*TVEC(1)
        SPCVEC(IPT(IX,JX))=SPCVEC(IPT(IX,JX))+TERM
      ENDIF
      IF (ATESDS) THEN
        SIG = -1.
        DO 2 I=1,2
C II is the offset of the parameters of atom I in the 6-vector
        II=3*(I-1)
        IPTR=I
        IF (I.NE.JX) IPTR=2
C SPXVEC acumulates the differentials with respect to the atom coordinates
C stored by parameter labels
        FAC=CPARS(IPT(IX,JX),1)*TVEC(IPTR)*SIG
        SPXVEC(II+IX)=SPXVEC(II+IX)+XBON(JX)*FAC
        SIG = -SIG
    2   CONTINUE
      ENDIF
    5 CONTINUE
    4 CONTINUE
      IF (ATESDS) CALL GMPRD(SPXVEC,RLMAT,AEXVEC,1,6,6)
      IF (SDCELL) CALL GMPRD(SPCVEC,RCLMAT,AECVEC,1,6,6)
      XERR=0.
      CERR=0.
      II=1
      DO 7 I=1,2
      IA = IATS(I)
      DO 8 J=1,3
      IF (ATESDS) XERR=XERR+((AEXVEC(II)*SDX(J,IA))**2)
      IF (SDCELL) CERR=CERR+
     &((AECVEC(II)**2)*CELESD(II,II,1))
      II=II+1
    8 CONTINUE
    7 CONTINUE
      BERR=SQRT(CERR+XERR)
      RETURN
      END
C
C
C
C
C LEVEL 4      SUBROUTINE BONTRI(N1,N2,N3,K,IE)
      SUBROUTINE BONTRI(N1,N2,N3,K,IE)
C
C *** BONTRI by JCM 17 Oct 1990 ***
C
CX
CC 8B
CH Given two bonds with a common atom, completes the triangle and identifies
CH the atom.
CA On entry N1 and N2 are the pointers to 2 bonds (in the list generated by
CA          L ATOM and L BOND cards)
CA On exit N3 points to the third bond completing the triangle
CA         K points to the common atom, opposite N3 in the triangle.
CA         and N1 and N2 are possibly interchanged; the result is N1 < N2.
CA         IE is an error indicator, set = 0 if OK, non-zero if error.
C
/IOUNIT/
/SLKGEC/
/SLKGEO/
C
      IE=0
C FIND THIRD BOND:
      IF (N1 .GT. N2) CALL FLIP(N2,N1)
      I1=0
      DO 3 I=1,2
      DO 3 J=1,2
      IF (IATM(N1,I) .EQ. IATM(N2,J)) THEN
        K=IATM(N1,I)
        I1=3-I
        I2=3-J
      ENDIF
   3  CONTINUE
      IF (I1 .EQ. 0) THEN
        WRITE (LPT,3031) BONNAM(N1),BONNAM(N2)
        WRITE (ITO,3031) BONNAM(N1),BONNAM(N2)
3031    FORMAT (/'  ERROR ** bonds ',A4,' and ',A4,
     &  ' have no common atom')
        IE=1
        GO TO 100
      ENDIF
C ADD THIRD SIDE OF TRIANGLE TO LIST OF INVOLVED BONDS;  IF IT IS NOT
C ALREADY THERE IT WILL BE GIVEN A BOGUS NAME:
      CALL ADDBON('    ',IATM(N1,I1),IATM(N2,I2),N3)
 100  RETURN
      END
C
C
C
C
C LEVEL 2      FUNCTION BRILL(T,TN,S)
      FUNCTION BRILL(T,TN,S)
C
C *** BRILL from PJB 14 Jun 88 ***
C
CX
CC 9C
CH Returns the value of the Brillouin function.
CA On entry T is the absolute temperature at which the function is required,
CA          TN the transition temperature,
CA          S is the spin.
CN  Uses the subprogram NB01A from the Harwell library.
C
/IOUNIT/
C
      IF (T.LE.0) THEN
        BRILL=1.
        GO TO 100
      ELSE IF (T.GE.TN) THEN
        BRILL=0.
        GO TO 100
      ENDIF
      K=0
      NUM=0
      B=1.
      ERR=.0001
      MAXIT=100
      X=0.002
      GO TO 1
    5 CALL NB01A(K,A,B,ERR,X,Y,MAXIT)
      GO TO (1,2,3,4) K
C
    1 S2=(2*S+1)/(2*S)
      Z=3*X*S*TN/((S+1)*T)
      Y=X-(S2/TANH(S2*Z))+(1./(TANH(Z/(2*S))*2*S))
      IF (K.EQ.1) GO TO 5
      IF (Y.LE.ERR) THEN
        X=2*X
        GO TO 1
      ENDIF
      A=X
      GO TO 5
C
    2 BRILL=X
      GO TO 100
C
    3 K=0
      B=A
      A=A/2.
      NUM=NUM+1
      IF (NUM.LE.10) GO TO 5
      I=0
   6  WRITE (ITO,3000) I,T,TN,S
      WRITE (LPT,3000) I,T,TN,S
3000  FORMAT (' ERROR **',I2,' calculating Brillouin function: ',3F8.2)
      BRILL=-1
      GO TO 100
C
    4 I=1
      GO TO 6
C
  100 RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE C1MSCA(A,B,SCALE,NI,NJ)
      SUBROUTINE C1MSCA(A,B,SCALE,NI,NJ)
C
C *** C1MSCA by PJB Apr 87 ***
C
CX
CC 12C
CH Multiplies every element of the REAL matrix A by the COMPLEX scalar SCALE.
CA On entry A is a REAL matrix of dimension NIxNJ
CA          SCALE is a COMPLEX scalar
CA On exit  B is a scaled COMPLEX matrix being SCALE times A
CN B may be the same as A
CN Does nothing if NI or NJ is zero
C
      COMPLEX B(1),SCALE
      DIMENSION A(1)
      NIJ=NI*NJ
      DO 1 I=1,NIJ
    1 B(I)=SCALE*A(I)
      RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE CALCDS(H)
      SUBROUTINE CALCDS(H)
C
C *** CALCDS by JCM 31 Jan 85 ***
C
CX
CC 7B
CH Calculates  d star squared, and its derivatives wrt reciprocal
CH cell quadratic products.
CA On entry H is a 1x3 vector holding h,k,l
CP In /CELPAR/ CPARS(1:6,2) should hold the 6 reciprocal quadratic products
CP             A* = a* squared
CP             D* =  b* c* cos alpha* etc
CP             KCPARS(1:6) should hold fix/vary information for each of the 6
CP             reciprocal cell quadratic products.
CD Sets GCALC in /OBSCAL/ to be d star squared, the d spacing squared,
CD and DERIVV in /DERVAR/ to be the derivative, where relevant
C
      DIMENSION H(3)
/CELPAR/
/DERVAR/
/OBSCAL/
/POINTS/
C
      GCALC=0.
      J=2
      K=3
      DO 1 I=1,3
      C1=H(I)*H(I)
      C2=2.*H(J)*H(K)
      GCALC=GCALC+C1*CPARS(I,2)+C2*CPARS(I+3,2)
      L1=KCPARS(I)
      L2=KCPARS(I+3)
      IF (L1 .GT. 0) DERIVV(L1)=C1
      IF (L2 .GT. 0) DERIVV(L2)=C2
      J=K
   1  K=I
C
      RETURN
      END
C
C
C
C
C LEVEL 8      SUBROUTINE CALCFR(H,SFCALC,MGCALC)
      SUBROUTINE CALCFR(H,SFCALC,MGCALC)
C
C *** CALCFR updated and corrected by PJB C4.19  March 2010 ***
C
CX
CC 7B
CH LSQ for flipping ratios or polarised neutron asymmetries
CD Calculates either the flipping ratio (IREF=5) or the polarised neutron
CH asymmetry (IREF=7) and their derivatives with respect to all parameters.
CA On entry H is the 1x3 array holding h,k,l
CA       SFCALC is the name of the routine to get nuclear structure factors
CA              and their derivatives.  This is usually LFCALC.
CA       MGCALC is the name of the routine to get magnetic structure factors
CA              and their derivatives.  This is usually LMCALC.
CP Structure factor data must have been set up in various COMMON blocks
CP by SYMOP RECIP ATOPOS, SETFOR, SETANI
CP LSETUP, PARSSF, VARMAK must have set up the Least Squares.
CP STLSSF must have read the L cards:
C
CD Sets GCALC, the calculated function corresponding to an OBS just read
CD Applies an extinction correction if there was an E card.
CD Also produces the vector DERIVV (LVARV long) of derivatives of this
CD function wrt each variable in turn.

      EXTERNAL SFCALC,MGCALC
      DIMENSION H(3)
      DIMENSION EXT(2),XSEC(2),EXSEC(2),DEXF(2),DEXG(2),DEXR(2),
%     &UPNUM(2),DWNUM(2),AINT(2),DERRAT(2,%VVAR%)
C4.18 include complex CRSCLP
      COMPLEX FN,PHASE,CRSCLP,FND
      LOGICAL LATABS,ISPABS,MAGABS,TESTOV,BINDIG
/BRAGG/
/DERVAR/
/DGEOM/
/EXTN/
/FCAL/
/IOUNIT/
/MAGDAT/
/MCAL/
/OBSCAL/
/OVER/
/PHASE/
/POINTS/
/POLDA/
/PRBLEM/
/QCAL/
/QCALD/
/REFINE/
/SCLDAT/
/SYMMAG/

C CLEAR DERIVATIVES WRT VARIABLES - THERE MAY NOT BE AN ENTRY FOR EVERY ONE FOR
C THIS INPUT VALUE OF H:
      IF (LVARV .GT. 0) THEN
        CALL GMZER(DERIVV,1,LVARV)
C4.18 Initialise DERRAT too
        CALL GMZER(DERRAT,2,LVARV)
        SUMNUM=0
        SUMDEN=0
      ENDIF
C Set no multiple scattering for Now
      AMULS=0
C Number of fam 2 + fam 5 variables
      LVF25=NVARF(5,JPHASE,1)+NVARF(2,JPHASE,1)
      FCMOD=0
      FMCMOD=0
      YCALC=0
      GCALC=0.
      IF (IREF.EQ.5 .OR. IREF.eq.10) GCALC=1.
      IF (LATABS(H) .OR. ISPABS(H) .OR. MAGABS(H,IK)) GO TO 100
      STHL = VCTMOD(0.5,H,2)
C STHL=SIN THETA/LAMBDA;  SSQRD = IT SQUARED
      SSQRD = STHL*STHL
      CALL SFCALC(H)
      CALL MGCALC(H)
C      write (lpt,5003) (q(i,1),i=1,3)
C 5003 format ('Q(1,1)',3(2(2f8.4),1x))
      P2S=FCMOD**2+FMCSQR
C      YCALC=SQRT(P2S)
      IF (.NOT. PARA) THEN
        QDOTP=CRSCLP(Q(1,1),POLND)
        DO 8 I=1,LVF25
        DQDOTP(I)=CRSCLP(FQCDER(1,1,I),POLND)
    8   CONTINUE
C 5002 format ('Qdotp etc',3f8.4,2x,2(2f8.4,1x),2x,3(2(2f8.4),1x))
      ENDIF
      PHASE=CMPLX(COSAL,SINAL)
      FN=FCMOD*PHASE
C      write (lpt,5002) polnd,qdotp,FN,(q(i,1),i=1,3)
      XST=2.*REAL(FN*CONJG(QDOTP))
      YCALC=XST
C Extinction FOR FLIPPING RATIOS
      SIG = 1
      DO 2 I=1,2
      UPNUM(I) = 0.5*(1.+ SIG*POLUP*SCALE(ISCALE))
      DWNUM(I) = 0.5*(1.+ SIG*POLDW*SCALE(ISCALE))
      XSEC(I)=P2S + SIG*XST
      SIG = -SIG
      X2=SQRT(XSEC(I))
      CALL EXTINC(3,X2)
      EXT(I)=EXTCOR**2
      DEXF(I) = DEXDFQ*X2
      DEXR(I) = DEXDRQ
      DEXG(I) = DEXDGQ
      EXSEC(I) = EXT(I)*XSEC(I)
    2 CONTINUE
C Lambda/2 correction
      CORLAM=ALAMB2(H,MAG)
      EXSEC(1)=EXSEC(1)+CORLAM
      EXSEC(2)=EXSEC(2)+CORLAM
      FACLAM=2.*(CORLAM+AMULS)/(EXSEC(1)+EXSEC(2))
C NOW GET THE CONTRIBUTIONS TO THE UP AND DOWN INTENSITIES
      RNUM = XSEC(1)*UPNUM(1)+XSEC(2)*UPNUM(2)
      RDEN = XSEC(1)*DWNUM(1)+XSEC(2)*DWNUM(2)
      AINT(1) = EXSEC(1)*UPNUM(1)+EXSEC(2)*UPNUM(2)
      AINT(2) = EXSEC(1)*DWNUM(1)+EXSEC(2)*DWNUM(2)

C DERIVATIVE WRT DEPOLARISATION
      IF (KSCALE(ISCALE) .NE.0) THEN
        DERRAT(1,KSCALE(ISCALE)) = 0.5*POLUP*(EXSEC(1)-EXSEC(2))
        DERRAT(2,KSCALE(ISCALE)) = 0.5*POLDW*(EXSEC(1)-EXSEC(2))
       ENDIF
C DERIVATIVES WRT EXTINCTION
       IF (KDOMR .NE. 0) THEN
          DERRAT(1,KDOMR) = 2.*(DEXR(1)*EXSEC(1)*UPNUM(1) +
     &                          DEXR(2)*EXSEC(2)*UPNUM(2))
          DERRAT(2,KDOMR) = 2.*(DEXR(1)*EXSEC(1)*DWNUM(1) +
     &                          DEXR(2)*EXSEC(2)*DWNUM(2))
       ENDIF
       IF (KMOSC .NE. 0) THEN
         DERRAT(1,KMOSC) = 2.*(DEXG(1)*EXSEC(1)*UPNUM(1) +
     &                         DEXG(2)*EXSEC(2)*UPNUM(2))
         DERRAT(2,KMOSC) = 2.*(DEXG(1)*EXSEC(1)*DWNUM(1) +
     &                         DEXG(2)*EXSEC(2)*DWNUM(2))
        ENDIF
C CONVERT DERIVATIVES FOR FAMILY 2 FROM BEING 'OF FCMOD' TO ones wrt
C INTENSITIES
C ALLOW FOR FAMILY 5 (MULTIPOLES)
      L25ST=LVFST1(2,1,1)
      IF (L25ST .EQ. -1) L25ST=LVFST1(5,1,1)
C      write (ito,3100) LVFST1(2,1,1),LVFST1(5,1,1),NVARF(5,JPHASE,1),
C     & NVARF(2,JPHASE,1),LAST
C 3100 format (8i5)
      DO 4 I=1,NVARF(5,JPHASE,1)+NVARF(2,JPHASE,1)
      FND=FCDERS(I)*CONJG(PHASE)
C      write (lpt,3010) I,FMCDER(I),(FQCDER(J,1,I),j=1,3)
C 3010 format ('Mag derivs ',I3,f10.4,3(2f8.3,2x))
C419 was      BIT1 = 2.*(REAL(FND*FN))+ FMCDER(I)
      BIT1 = 2.*(REAL(FND*FN)+ FMCDER(I))
C4.21 FM replaced by QDOTP
      BIT2 = 2.*(REAL(QDOTP*FND)+REAL(FN*CONJG(DQDOTP(I))))
      DXDI1 = (BIT1+BIT2)*EXT(1)*(1.+DEXF(1))
      DXDI2 = (BIT1-BIT2)*EXT(2)*(1.+DEXF(2))
      DERRAT(1,L25ST+I) = DXDI1*UPNUM(1) + DXDI2*UPNUM(2)
      DERRAT(2,L25ST+I) = DXDI1*DWNUM(1) + DXDI2*DWNUM(2)
    4 CONTINUE
C GET EITHER FLIPPING RATIO OR ASYMMETRY
      IF (IREF.EQ.5 .OR. IREF.eq.10) THEN
         IF (TESTOV(AINT(1),AINT(2))) GO TO 1
         GCALC = AINT(1)/AINT(2)
C MAKE ALL DERIVATIVES WRT FLIPPING RATIO
         DO 6 I=1,LVARV
C4.2 typo corrected
   6     DERIVV(I)=GCALC*((DERRAT(1,I)/AINT(1)) -
     &                    (DERRAT(2,I)/AINT(2)))
      ELSE
        GCALC = (AINT(1)-AINT(2))/(AINT(1)+AINT(2))
        DO 7 I=1,LVARV
        DERIVV(I)=2.*(DERRAT(1,I)*AINT(2) - DERRAT(2,I)*AINT(1))
     &   /((AINT(1) + AINT(2))**2)
      if (bindig(iout,2048)) write (lpt,3003) i,derivv(i)
 3003 format (' derivv p = ',i4,f10.6)
    7   CONTINUE
      ENDIF
      IF (bindig(iout,4096)) write (lpt,3001) GCALC,(derivv(i),
     &i=1,lvarv)
 3001 format (15X,9f10.6)
    1 continue
  100 RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE CALCFW(S)
      SUBROUTINE CALCFW(S)
C
C *** CALCFW by JCM 19 Nov 84 ***
C
CX
CC 7B
CH Calculates the Forsyth & Wells exponential function which approximates
CH to observed scattering factor curves.
CA On entry S is sin theta.
C
CP The relevant number of coeffivients (usually 5, 7 or 9) are held in
CP /FWVALS/ as COEFFS(1:NVALS)
CD Used in FWLSQ as a very simple LSQ application, with no constraints.
CD Sets GCALC = Forsyth & Wells sum of exponential terms,
CD and DERIVV in /DERVAR/ as NVALS derivatives.
CN PJB says it doesn't work;  this must be investigated.
C
/DERVAR/
/FWVALS/
/OBSCAL/
C
      SSQRD=S*S
      GCALC=COEFFS(NVALS)
      DERIVV(NVALS)=1.0
C
      DO 1 I=3,NVALS,2
      J=NVALS-I+2
      TEX=EXP(-(COEFFS(J)*SSQRD))
      TERM=COEFFS(J-1)*TEX
      GCALC=GCALC+TERM
      DERIVV(J)=-(SSQRD*TERM)
   1  DERIVV(J-1)=TEX
      RETURN
      END
C
C
C
C
C LEVEL 8      SUBROUTINE CALCGM(H,SFCALC,MGCALC)
      SUBROUTINE CALCGM(H,SFCALC,MGCALC)
C
C *** CALCGM temporary PJB Oct 2009 ***
C
CX
CC 7B
CH Calculates GCALC (IREF=6) as the ratio of antiferromagnetic to nuclear scattering
CH Probably obsolete replaced by SNPLSQ types
C
CA On entry H is the 1x3 array holding h,k,l
CA       SFCALC is the name of the routine to get nuclear structure factors
CA              and their derivatives.  This is usually LFCALC.
CA       MGCALC is the name of the routine to get magnetic structure factors
CA              and their derivatives.  This is usually LMCALC.
CP Structure factor data must have been set up in various COMMON blocks
CP by SYMOP RECIP ATOPOS, SETFOR, SETANI
CP LSETUP, PARSSF, VARMAK must have set up the Least Squares.
CP STLSSF must have read the L cards:
C
CD Sets GCALC, the calculated function corresponding to an OBS just read
CD Applies an extinction correction if there was an E card.
CD Also produces the vector DERIVV (LVARV long) of derivatives of this
CD function wrt each variable in turn.
C
CD The function GCALC is made up of three functions multiplied together.
CD We write G=P1*P2*P3 where P2 is a simple function of FCALC, P1 is
CD independent of FCALC (being Scale * overall itf), and P3 is the extinction
CD correction.(They are written in this way for ease of differentiation.)
C
CD If IREF=2, we are in fact comparing OBS squared with GCALC squared.  This is
CD dealt with right at the end, after proceeding as though we were not.
CD
CD The sequence of operations is:
CD      Get STHL= sin theta/lambda, SSQRD= STHL squared.
CD      Clear derivatives to zero.
CD      Form P1 and its derivatives.
CD      Form P2: get FCALC and derivatives of mod FCALC wrt family 2 variables,
CD               using both nuclear and magnetic structure factors
CD      The scattering factors are calculated using PFORMF with multipoles.
CD      Convert derivatives to be of P2, not just mod FCALC
CD      Form P3: convert derivatives
CD      Form GCALC and make all derivatives so that they are of GCALC
CD      Adjust for GCALC squared if necessary
CD On exit in /OBSCAL/ GCALC = calculated function to compare with observed
CD On exit in /DERVAR/ DERIVV is an array holding all derivatives of GCALC
CD wrt all variables
CD
CN  L REFI=6 the GOBS and CCALC are gammas (Fmag/Fnuc) expects imag Fmag
C
      EXTERNAL SFCALC,MGCALC
      DIMENSION H(3),TVEC(3),OH(3),PVEC(3),QVEC(3)
      COMPLEX FN,PHASE
      LOGICAL TESTOV
/BRAGG/
/DERVAR/
/EXTN/
/FCAL/
/IOUNIT/
/MAGDAT/
/MCAL/
/OBSCAL/
/OVER/
/PHASE/
/POINTS/
/POLDA/
/PRBLEM/
/QCAL/
/QCALD/
/REFINE/
/SCLDAT/
C
      STHL = VCTMOD(0.5,H,2)
C STHL=SIN THETA/LAMBDA;  SSQRD = IT SQUARED
      SSQRD = STHL*STHL
C
C CLEAR DERIVATIVES WRT VARIABLES - THERE MAY NOT BE AN ENTRY FOR EVERY ONE FOR
C THIS INPUT VALUE OF H:
      IF (LVARV .GT. 0) CALL GMZER(DERIVV,1,LVARV)
C
C NEXT DO P2:
      CALL SFCALC(H)
      CALL MGCALC(H)
      P2S=FCMOD**2+FMCSQR
      PHASE=CMPLX(COSAL,SINAL)
      FN=FCMOD*PHASE
C GET A CONSISTENT SIGN FOR GAMMA CALC
C ASSUME SPINDIR GIVEN BY FIRST MAGNETIC ATOM
      DO 3 I=1,3
      TVEC(I) = AIMAG(Q(I,1))
    3 CONTINUE
      CALL ORTHO(H,OH,2)
      CALL VECPRD(SPIND,OH,PVEC)
      CALL VECPRD(OH,PVEC,QVEC)
      D = SCALPR(TVEC,QVEC)
      IF (TESTOV(1.,D)) THEN
        P2 = 0.
      ELSE
        QSIGN = SIGN(1.,D)
        P2 = QSIGN*FMCMOD/REAL(FN)
C Cryopad Gammas should not suffer from extinction
      ENDIF
      YCALC=P2
C
C CONVERT DERIVATIVES FOR FAMILY 2 FROM BEING 'OF FCMOD' AS THEY ARE OUT OF
C LFCALC, USING:
C DP2/DV = DMODFC/DV * DP2/DMODFC - AND ALL ARE DIVIDED BY P2
C DP3/DV = DMODFC/DV * DP3/DMODFC - AND ALL ARE DIVIDED BY P3
C GIVING D(GCALC)/DV OVER GCALC=(DP2/DV OVER P2 + DP3/DV OVER P3)
C
C ALLOW FOR FAMILY 5 (MULTIPOLES)
      L25ST=LVFST1(2,1,1)
      IF (L25ST .EQ. -1) L25ST=LVFST1(5,1,1)
      DO 4 I=1,NVARF(5,JPHASE,1)+NVARF(2,JPHASE,1)
        DERIVV(L25ST+I)=(FMCDER(I)/FMCSQR)-(FCDERS(i)/FCMOD)
    4 CONTINUE
C      WRITE (LPT,1000) H,GCALC,(DERIVV(L25ST+I),
C     &I=1,NVARF(5,JPHASE,1)+NVARF(2,JPHASE,1))
C 1000 FORMAT (3F4.0,F8.4,2X,6F8.4)
C
      GCALC = P2
C ADJUST IF NECESSARY FOR GCALC SQUARED:
      FAC=GCALC
      DO 6 I=1,LVARV
   6  DERIVV(I)=DERIVV(I)*FAC
      RETURN
      END
C
C
C
C
C LEVEL 8      SUBROUTINE CALCGR(H,FAC)
      SUBROUTINE CALCGR(H,FAC)
C
C *** CALCGR by JCM 18 Feb 85 ***
C
CX
CC 7B
CH Gives the calculated function for grouped single crystal Least Squares.
CA On entry H is a 1x3 real array holding h,k,l
CA          FAC is the factor by which to multiply GCALC before summing
CP SETFC (or its constituent parts SYMOP, RECIP etc) must have set up the
CP    structure factor calculation.
CP EXTINC must have set up the extinction corrections
CP LSETUP, PARSSF and VARMAK must have set up the Least Squares
CP STLSSF must have read the L cards.
CD Forms GCALC and sums it in YCALC, multiplied by FAC. Also derivatives of
CD GCALC with respect to any parameters, and summs them likewise into DERIVV.
CD GCALC is the product of 3 functions, P1, P2, P3
CD P1 is the scale * overall itf * FAC (at present in GRLSQ FAC=multiplicity
CD    times d to the power 4)
CD P2 is the square of the structure factor.
CD P3 is an extinction correction, possibly absent.
CN Only IREF=1 makes sense here.
C
      DIMENSION H(3)
/BRAGG/
/DERVAR/
/EXTN/
/FCAL/
/OBSCAL/
/OVER/
/POINTS/
/PRBLEM/
/SCLDAT/
%      DIMENSION DERIVA(%VVAR%)
C
      STHL = VCTMOD(0.5,H,2)
C STHL=SIN THETA/LAMBDA;  SSQRD = IT SQUARED
      SSQRD = STHL*STHL
C
C CLEAR INTERNAL DERIVATIVES:
      IF (LVARV .GT. 0) CALL GMZER(DERIVA,1,LVARV)
C
C FORM P1, THE PART OF GCALC INDEPENDENT OF MOD(FC)
      P1=SCALE(ISCALE)*EXP((-TFAC)*SSQRD)*FAC
      IF (KTFAC .GT. 0) DERIVA(KTFAC)=-SSQRD
      L=KSCALE(ISCALE)
      IF (L .NE. 0) DERIVA(L)=1./SCALE(ISCALE)
C NEXT DO P2:
      CALL LFCALC(H)
      P2=FCMOD*FCMOD
      DP2DFQ=2./FCMOD
C
C P3:
      CALL EXTINC(3,FCMOD)
      P3=EXTCOR*EXTCOR
      IF (KDOMR .NE. 0) DERIVA(KDOMR)=2.*DEXDRQ
      IF (KMOSC .NE. 0) DERIVA(KMOSC)=2.*DEXDGQ
C
C CONVERT DERIVATIVES FOR FAMILY 2 FROM BEING 'OF FCMOD' AS THEY ARE OUT OF
C LFCALC, USING:
C DP2/DV = DMODFC/DV * DP2/DMODFC - AND ALL ARE DIVIDED BY P2
C DP3/DV = DMODFC/DV * DP3/DMODFC - AND ALL ARE DIVIDED BY P3
C GIVING D(GCALC)/DV OVER GCALC=(DP2/DV OVER P2 + DP3/DV OVER P3)
      DO 4 I=1,NVARF(2,1,1)
   4  DERIVA(LVFST1(2,1,1)+I)=FCDERS(I)*(DP2DFQ+2.*DEXDFQ)
C
      GCALC = P1*P2*P3
      YCALC=YCALC+GCALC
C
      DO 6 I=1,LVARV
   6  DERIVV(I)=DERIVV(I) + DERIVA(I)*GCALC
      RETURN
      END
C
C
C
C
C LEVEL 8      SUBROUTINE CALCMG(H,SFCALC,MGCALC)
      SUBROUTINE CALCMG(H,SFCALC,MGCALC)
C
C *** CALCMG updated  by PJB C4.24 March 2013 ***
C
CX
CC 7B
CH Calculates GCALC and its derivatives for structures which may have
CH mixed magnetic and nuclear reflections.
C
CA On entry H is the 1x3 array holding h,k,l
CA       SFCALC is the name of the routine to get nuclear structure factors
CA              and their derivatives.  This is usually LFCALC.
CA       MGCALC is the name of the routine to get magnetic structure factors
CA              and their derivatives.  This is usually LMCALC.
CP Structure factor data must have been set up in various COMMON blocks
CP by SYMOP RECIP ATOPOS, SETFOR, SETANI
CP LSETUP, PARSSF, VARMAK must have set up the Least Squares.
CP STLSSF must have read the L cards:
C
CD Sets GCALC, the calculated function corresponding to an OBS just read
CD Applies an extinction correction if there was an E card.
CD Also produces the vector DERIVV (LVARV long) of derivatives of this
CD function wrt each variable in turn.
C
CD The function GCALC is made up of three functions multiplied together.
CD We write G=P1*P2*P3 where P2 is a simple function of FCALC, P1 is
CD independent of FCALC (being Scale * overall itf), and P3 is the extinction
CD correction.(They are written in this way for ease of differentiation.)
C
CD If IREF=2, we are in fact comparing OBS squared with GCALC squared.  This is
CD dealt with right at the end, after proceeding as though we were not.
CD
CD The sequence of operations is:
CD      Get STHL= sin theta/lambda, SSQRD= STHL squared.
CD      Clear derivatives to zero.
CD      Form P1 and its derivatives.
CD      Form P2: get FCALC and derivatives of mod FCALC wrt family 2 variables,
CD               using both nuclear and magnetic structure factors
CD      The scattering factors are calculated using PFORMF with multipoles.
CD      Convert derivatives to be of P2, not just mod FCALC
CD      Form P3: convert derivatives
CD      Form GCALC and make all derivatives so that they are of GCALC
CD      Adjust for GCALC squared if necessary
CD On exit in /OBSCAL/ GCALC = calculated function to compare with observed
CD On exit in /DERVAR/ DERIVV is an array holding all derivatives of GCALC
CD wrt all variables
CD
CN If L REFI=5 the GOBS and GCALC are polarised neutron flipping ratios
CN             and the scales multiply the up and down polarisations
CN if L REFI=6 the GOBS and CCALC are gammas (Fmag/Fnuc) expects imag Fmag
C
      EXTERNAL SFCALC,MGCALC
      DIMENSION H(3)
      LOGICAL TESTOV
/BRAGG/
/DERVAR/
/EXTN/
/FCAL/
/IOUNIT/
/MAGDAT/
/MCAL/
/OBSCAL/
/OVER/
/PHASE/
/POINTS/
/POLDA/
/PRBLEM/
/QCAL/
/QCALD/
/REFINE/
/SCLDAT/
/SYMMAG/
C
      STHL = VCTMOD(0.5,H,2)
C STHL=SIN THETA/LAMBDA;  SSQRD = IT SQUARED
      SSQRD = STHL*STHL
C
C CLEAR DERIVATIVES WRT VARIABLES - THERE MAY NOT BE AN ENTRY FOR EVERY ONE FOR
C THIS INPUT VALUE OF H:
      IF (LVARV .GT. 0) CALL GMZER(DERIVV,1,LVARV)
C
C FORM P1, THE PART OF GCALC INDEPENDENT OF MOD(FC)
C4.18 Calculation of SINTH and COSTH removed
      P1=SCALE(ISCALE)*EXP((-TFAC)*SSQRD)
      IF (KTFAC .NE. 0) DERIVV(KTFAC)=-SSQRD
      L=KSCALE(ISCALE)
      IF (L .NE. 0) DERIVV(L)=1./SCALE(ISCALE)
C
C NEXT DO P2:
      CALL SFCALC(H)
      CALL MGCALC(H)
      P2S=FCMOD**2+FMCSQR
      P2=SQRT(P2S)
C  CHECK THAT P2 IS NOT ZERO
      IF (TESTOV(1.,P2)) THEN
        GCALC = 0.
        GO TO 7
      ENDIF
      DFTDFQ=1./P2
C P3:
      CALL EXTINC(3,P2)
      P3=EXTCOR
      IF (KDOMR .NE. 0) DERIVV(KDOMR)=DEXDRQ
      IF (KMOSC .NE. 0) DERIVV(KMOSC)=DEXDGQ
      YCALC=P2
C
C CONVERT DERIVATIVES FOR FAMILY 2 FROM BEING 'OF FCMOD' AS THEY ARE OUT OF
C LFCALC, USING:
C DP2/DV = DMODFC/DV * DP2/DMODFC - AND ALL ARE DIVIDED BY P2
C DP3/DV = DMODFC/DV * DP3/DMODFC - AND ALL ARE DIVIDED BY P3
C GIVING D(GCALC)/DV OVER GCALC=(DP2/DV OVER P2 + DP3/DV OVER P3)
C
      if (CPVEC) then
C Derivatives of FMCsqr with repect to the phase of the order pars are zero
        DO 1 IR=1,2
        L=KSPORD(IR,1)
        IF (L.EQ.0) GO TO 1
        DERIVV(L)=FMCDER(L)*(DEXDFQ+DFTDFQ)*DFTDFQ
    1   CONTINUE
      ENDIF
C ALLOW FOR FAMILY 5 (MULTIPOLES)
      L25ST=LVFST1(2,1,1)
C4.26 Note start of fam 1 (for order pars)
      L1F=NVARF(1,JPHASE,1)
      IF (L25ST .EQ. -1) L25ST=LVFST1(5,1,1)
      DO 4 I=1,NVARF(5,JPHASE,1)+NVARF(2,JPHASE,1)
        DERIVV(L25ST+I)=((FCDERS(I)*FCMOD)+FMCDER(I+L1F))*
     &  (DEXDFQ+DFTDFQ)*DFTDFQ
    4 CONTINUE
C4.19 Multiple scattering and half wavelength contamination
      HLFWAV=ALAMB2(H,.TRUE.)
      AMULS=0.00
      COR=0.5*(AMULS+HLFWAV)/(P2*P3)**2
      GCALC = P1*P2*P3*(1.+cor)
C ADJUST IF NECESSARY FOR GCALC SQUARED:
    7 FAC=GCALC
      IF (IREF .EQ. 2) THEN
        GCALC=GCALC*GCALC
        FAC=2.*GCALC
      ENDIF
      DO 6 I=1,LVARV
      DERIVV(I)=DERIVV(I)*FAC
    6 continue
      RETURN
      END
C
C
C
C
C LEVEL 8      SUBROUTINE CALCMP(H)
      SUBROUTINE CALCMP(H)
C
C *** CALCMP by PJB Oct 88 ***
C
CX
CC 7B
CH Makes the calculated function and derivatives for single crystal LSQ
CH with multipoles.
CA On input H is a 3-sized array containing h,k,l
CP Structure factor data must have been set up in various COMMON blocks
CP by SYMOP RECIP ATOPOS, SETFOR, SETANI
C
CD Sets GCALC, the calculated function corresponding to an OBS just read
CD Applies an extinction correction if there was an E card.
CD Also produces the vector DERIVV (LVARV long) of derivatives of this
CD function wrt each variable in turn.
C
CD The function GCALC is made up of three functions multiplied together.
CD We write G=P1*P2*P3 where P2 is a simple function of FCALC, P1 is
CD independent of FCALC (being Scale * overall itf), and P3 is the extinction
CD correction.(They are written in this way for ease of differentiation.)
C
CD If IREF=2, we are in fact comparing OBS squared with GCALC squared.  This is
CD dealt with right at the end, after proceeding as though we were not.
CD
CD The sequence of operations is:
CD      Get STHL= sin theta/lambda, SSQRD= STHL squared.
CD      Clear derivatives to zero.
CD      Form P1 and its derivatives.
CD      Form P2: get FCALC and derivatives of mod FCALC wrt family 2 variables
CD               This includes the multipoles.
CD      Convert derivatives to be of P2, not just mod FCALC.
CD      Form P3: convert derivatives.
CD      Form GCALC and make all derivatives so that they are of GCALC.
CD      Adjust for GCALC squared if necessary.
C
      LOGICAL TESTOV
      DIMENSION H(3)
/BRAGG/
/DERVAR/
/EXTN/
/FCAL/
/OBSCAL/
/OVER/
/PHASE/
/POINTS/
/PRBLEM/
/REFINE/
/SCLDAT/
C
      STHL = VCTMOD(0.5,H,2)
C STHL=SIN THETA/LAMBDA;  SSQRD = IT SQUARED
      SSQRD = STHL*STHL
C
C CLEAR DERIVATIVES WRT VARIABLES - THERE MAY NOT BE AN ENTRY FOR EVERY ONE FOR
C THIS INPUT VALUE OF H:
      DO 2  I=1,LVARV
   2  DERIVV(I)=0.
C
C FORM P1 AND THE FAMILY 1 DERIVATIVES:
C
C FORM P1, THE PART OF GCALC INDEPENDENT OF MOD(FC)
      P1=SCALE(ISCALE)*EXP((-TFAC)*SSQRD)
      IF (KTFAC .GT. 0) DERIVV(KTFAC)=-SSQRD
      L=KSCALE(ISCALE)
      IF (L .GT. 0) DERIVV(L)=1./SCALE(ISCALE)
C NEXT DO P2:
      CALL LMPCAL(H)
      P2=FCMOD
      IF (IREF .EQ. 4) P2=REAL(FC)
      DP2DFQ=0.
      IF (.NOT. TESTOV(1.,FCMOD)) DP2DFQ=1./FCMOD
C
C P3:
      CALL EXTINC(3,FCMOD)
      P3=EXTCOR
      IF (KDOMR .NE. 0) DERIVV(KDOMR)=DEXDRQ
      IF (KMOSC .NE. 0) DERIVV(KMOSC)=DEXDGQ
C
C CONVERT DERIVATIVES FOR FAMILY 2 FROM BEING 'OF FCMOD' AS THEY ARE OUT OF
C LFCALC, USING:
C DP2/DV = DMODFC/DV * DP2/DMODFC - AND ALL ARE DIVIDED BY P2
C DP3/DV = DMODFC/DV * DP3/DMODFC - AND ALL ARE DIVIDED BY P3
C GIVING D(GCALC)/DV OVER GCALC=(DP2/DV OVER P2 + DP3/DV OVER P3)
      L25ST=LVFST1(2,1,1)
      IF (L25ST .EQ. -1) L25ST=LVFST1(5,1,1)
      DO 4 I=1,NVARF(5,1,1)+NVARF(2,1,1)
   4  DERIVV(L25ST+I)=FCDERS(I)*(DP2DFQ+DEXDFQ)
C
      GCALC = P1*P2*P3
C ADJUST IF NECESSARY FOR GCALC SQUARED:
      FAC=GCALC
      IF (IREF .EQ. 2) THEN
        GCALC=GCALC*GCALC
        FAC=2.*GCALC
      ENDIF
      DO 6 I=1,LVARV
   6  DERIVV(I)=DERIVV(I)*FAC
      RETURN
      END
C
C
C
C
C LEVEL 5      SUBROUTINE CALCPA(H,IPDIR,SFCALC,MGCALC)
      SUBROUTINE CALCPA(H,IPDIR,SFCALC,MGCALC)
C
C *** CALCPA Updated C4.7 by PJB March 2008 ***
C
CX
CC 7B
CH Calculates scattered polarisations and their derivatives for structures
CH which may have mixed magnetic and nuclear reflections.
C
CA On entry H is the 1x3 array holding h,k,l
CA          SFCALC is the name of the routine to get nuclear structure factors
CA                 and their derivatives.  This is usually LFCALC.
CA          MGCALC is the name of the routine to get magnetic structure factors
CA                and their derivatives.  This is now LMCALC.
CP Structure factor data must have been set up in various COMMON blocks
CP by SYMOP RECIP ATOPOS, SETFOR, SETANI
CP LSETUP, PARSSF, VARMAK must have set up the Least Squares.
CP STLSSF must have read the L cards:
C
CD Sets GCALC to the component of the scattered polarisation indicated by Pin
CD Also produces the vector DERIVV (LVARV long) of derivatives of this
CD function wrt each variable in turn.
C
CD The sequence of operations is:
CD      Get STHL= sin theta/lambda, SSQRD= STHL squared.
CD      Clear derivatives to zero.
CD      If NEW calculate the nuclear and magnetic structure factors and
CD      their derivatives.
CD      If ICOMP=1 (ie 1st component for this input polarisation)
CD      calculate the output polarisation, summing over all domains
CD      and its differential wrt all parameters.
CD      Otherwise just set GCALC to previously calculated component
CD      of polarisation and scale the appropriate component of the
CD      differentials.
CD On exit in /OBSCAL/ GCALC = calculated function to compare with observed
CD         in /DERVAR/ DERIVV is an array holding all derivatives of GCALC
CD                            wrt all variables.
C
      EXTERNAL SFCALC,MGCALC
      COMPLEX CVEC(3),QSTAR(3),CPRD,CRSCLP,QCROSP(3)
      COMPLEX DPOLDP(3),TENS(3,3),CFAC,QSAVE(3,24),QDSAVE(3,24,100)
      DIMENSION H(3),HH(3),VEC(3),VEC1(3),POLI(3),POLA(3),DIFFER(3,10),
     &QCROSQ(3),IPDIR(2)
/BRAGG/
/DERVAR/
/DSOURC/
/FCAL/
/IOUNIT/
/QCAL/
/QCALD/
/OBSCAL/
/OVER/
/PHASE/
/POINTS/
/POLDA/
/POLDAT/
/PRBLEM/
/SATELL/
/SYMMAG/
/TWIN/
       SAVE ICOMP
C
C
C CLEAR DERIVATIVES WRT VARIABLES - THERE MAY NOT BE AN ENTRY FOR EVERY ONE FOR
C THIS INPUT VALUE OF H:
      IF (LVARV .GT. 0) CALL GMZER(DERIVV,1,LVARV)
C
C Set the domain pointer FOR THE FIRST TWIN AND DOMAIN
      IDOMPT=0
      IF (JSRC .NE.1) IDOMPT=IPDOM(JSRC-1)
      IDPTR=IDOMPT
      NDTOT=KCENT*NDOM*ND180*NTWIN
      NDT=NDOM*NTWIN
      NND=0
C       write (lpt,4018) 'T ',ICODE,ICOMP,IPDIR,pold
C 4018 FORMAT (A2,4I2,3F8.4)
      IF (ICODE.EQ.0) GO TO 1
C  CALCULATE H dependent quantities ON FIRST ENTRY
C GET THE X,Y, AND Z AXES ON ORTHOGONAL CRYST COORDS
      CALL GMEQ(POLND,POLIT(1,3),3,1)
      CALL ORTHO(H,POLIT(1,1),2)
      CALL UNIVEC(POLIT(1,1),DS)
      CALL VECPRD(POLIT(1,3),POLIT(1,1),POLIT(1,2))
C STHL=SIN THETA/LAMBDA;  SSQRD = IT SQUARED
      STHL=DS/2.
      SSQRD = STHL*STHL
      CALL SFCALC(H)
      IF (MTWIN) THEN
C Get the structure factors for each twin
        NND=1
        DO 2 ITWIN=1,NTWIN
        CALL GMPRD(H,TWMAT(1,1,ITWIN),hH,1,3,3)
        CALL MGCALC(HH)
C TRANSFORM Q AND DERIVATIVES TO UNTWINNED AXES
        DO 3 ND=1,NDOM
        CALL RCMPRD(TWMAT(1,1,ITWIN),Q(1,ND),QSAVE(1,NND),3,3,1 )
C      WRITE (LPT,4004) NND,(Q(II,ND),II=1,3)
C      WRITE (LPT,4004) NND,(QSAVE(II,NND),II=1,3)
        DO 4 I=1,NVARF(2,JPHASE,1)
        CALL RCMPRD(TWMAT(1,1,ITWIN),FQCDER(1,ND,I),QDSAVE(1,NND,I),
     &  3,3,1)
    4   CONTINUE
        NND=NND+1
    3   CONTINUE
    2   CONTINUE
C COPY ALL BACK INTO QCAL AND QCALD COMMON
        CALL CGMEQ(QSAVE,Q,3,NDT)
        DO 5 I=1,NVARF(2,JPHASE,1)
        CALL CGMEQ(QDSAVE,FQCDER,3,NDT)
    5   CONTINUE
      ELSE
        CALL MGCALC(H)
      ENDIF
      ICOMP=0
    1 IF (IPDIR(1) .EQ. ICOMP) GO TO 7
      ICOMP=IPDIR(1)
C  CLEAR SUMS
      CALL GMZER(POLD,1,3)
      CALL CGMZER(DPOLDQ,3,3)
      CALL CGMZER(DPOLDN,3,1)
      CALL CGMZER(DXSDQ,3,1)
      QSQRM=0.
      DXSDN=CMPLX(0.,0.)
C  SET INPUT POLARISATION
      CALL GMEQ(POLIT(1,IABS(IPDIR(1))),POLI,3,1)
      IF (IPDIR(1).LT.0) CALL GMREV(POLI,POLI,3,1)
      NND=0
      N180D=1
      IF (IPROP.EQ.0) N180D=2
      DO 22 N180=1,N180D
      DO 20 ND=1,NDT
      DO 27 NDK=1,KCENT
      NND=NND+1
C INCREMENT the domain pointer IDOMPT
      IDOMPT=IDOMPT+1
C  CALCULATION OF SCATTERED POLARISATION VECTOR
      CALL CMCONJ(Q(1,ND),QSTAR,3,1)
C QN* term
      CALL CGMSCA(Q(1,ND),CVEC,CONJG(FC),3,1)
      CALL CMREAL(CVEC,POLO(1,NND),3,1)
C  QXQ* TERM
      CALL CMREAL(QSTAR,VEC,3,1)
      CALL CMIMAG(QSTAR,VEC1,3,1)
      CALL VECPRD(VEC,VEC1,QCROSQ)
      if (NDK .eq.2) call gmrev(qcrosq,qcrosq,3,1)
C141 Keep the Q X Q* term we need it later
C      WRITE (LPT,4006)POLI,(Q(I,ND),I=1,3),QCROSQ
C  4006 FORMAT (3F8.4,2X,3(2F8.4,2X),3F8.4)
      CALL GMADD(POLO(1,NND),QCROSQ,VEC,3,1)
C  POLARISATION DEPENDENT PART OF CROSS-SECTION
      POLPRD=2.*SCALPR(VEC,POLI)
C141 Correct the sign by subtracting here
      CALL GMSUB(POLO(1,NND),QCROSQ,POLO(1,NND),3,1)
C  N*PXQ PART OF POLARISATION
      CALL CMIMAG(CVEC,VEC,3,1)
      CALL VECPRD(POLI,VEC,VEC1)
C      if (NDK.eq.2) call gmrev(vec1,vec1,3,1)
C      write (lpt,4008) N180,ND,vec1
      CALL GMADD(POLO(1,NND),VEC1,POLO(1,NND),3,1)
C  Q(P.Q*) PART OF POLARISATION
      CPRD=CRSCLP(QSTAR,POLI)
C 4008 format (2i4,2(3f8.4,2x),2x,2f8.4)
      CALL CGMSCA(Q(1,ND),CVEC,CPRD,3,1)
      CALL CMREAL(CVEC,VEC,3,1)
C      write (lpt,4005) 10,(polo(I,nnd),I=1,3),VEC
      CALL GMADD(POLO(1,NND),VEC,POLO(1,NND),3,1)
C  DOUBLE ALL THIS FOR TWICE REAL AND IMAG PARTS
      CALL GMSCA(POLO(1,NND),POLO(1,NND),2.,3,1)
C      write (lpt,4005) 11,(polo(I,nnd),I=1,3)
C  PART PARALLEL TO INCIDENT POLN
      FNSQR=(CABS(FC))**2
      QMOD=RSCALP(Q(1,ND),Q(1,ND))
      CALL GMSCA(POLI,VEC,FNSQR-QMOD,3,1)
      CALL GMADD(POLO(1,NND),VEC,POLO(1,NND),3,1)
C
C DERIVATIVES WITH RESPECT TO FC AND Q
C FIRST DIFFERENTIATE THE CROSSECTION
      DXSDN=DXSDN+(CONJG(FC)+CPRD)*DPOP(IDOMPT)
      CALL CMCONJ(Q(1,ND),DXSDQ(1,NND),3,1)
      CALL C1MSCA(POLI,CVEC,CONJG(FC),3,1)
      CALL CGMADD(CVEC,DXSDQ(1,NND),DXSDQ(1,NND),3,1)
C FIDDLE THE QXQ TERM  -idQ{Q*xP}
      CALL CMREAL(QSTAR,VEC,3,1)
      CALL VECPRD(VEC,POLI,VEC1)
      CALL C1MSCA(VEC1,QCROSP,CMPLX(0.,-1.),3,1)
      CALL CMIMAG(QSTAR,VEC,3,1)
      CALL VECPRD(VEC,POLI,VEC1)
      CALL C1MSCA(VEC1,CVEC,CMPLX(1.,0.),3,1)
      CALL CGMADD(CVEC,QCROSP,QCROSP,3,1)
      if (NDK .eq.2) call gmrev(qcrosp,qcrosp,3,1)
      CALL CGMADD(QCROSP,DXSDQ(1,NND),DXSDQ(1,NND),3,1)
C THE DIFFERENTIALS OF THE SCATTERED POLARISATION
C  FIRST WITH RESPECT TO NUCLEAR PART
      CALL C1MSCA(POLI,CVEC,CONJG(FC),3,1)
      CALL CGMADD(QSTAR,CVEC,CVEC,3,1)
      CALL CGMADD(QCROSP,CVEC,CVEC,3,1)
      CALL CMRSCA(CVEC,CVEC,DPOP(IDOMPT),3,1)
C SUM UP WEIGHTING WITH DOMAIN POPULATION
      CALL CGMADD(CVEC,DPOLDN,DPOLDN,3,1)
C THEN THE TENSOR FOR THE MAGNETIC DERIVATIVES
      DO 25 J=1,3
      DO 25 I=1,3
      DPOLDQ(I,J,NND)=QSTAR(I)*POLI(J)-POLI(I)*QSTAR(J)
      IF (I.EQ.J) THEN
        DPOLDQ(I,I,NND)=DPOLDQ(I,I,NND)+CONJG(FC)+CPRD
      ELSE
        DO 26 K=1,3
        IF (K.EQ.I .OR. K.EQ.J) GO TO 26
        IF (ABS(J-I).EQ.1) THEN
          SIG=FLOAT(ISIGN(1,J-I))
        ELSE
          SIG=FLOAT(ISIGN(1,I-J))
        ENDIF
        DPOLDQ(I,J,NND)=DPOLDQ(I,J,NND)+
     &  SIG*CMPLX(0.,1.)*(CONJG(FC)*POLI(K)+QSTAR(K))
        if (NDK .eq.2) DPOLDQ(I,J,NND)=DPOLDQ(I,J,NND)-2.*QSTAR(K)
   26   CONTINUE
      ENDIF
   25 CONTINUE
C
C  SCALE BY DOMAIN FRACTIONS ADD INTO SUMS FOR MEAN POLARISATION
C141 remove this line        CALL GMEQ(POLO(1,NND),VEC,3,1)
C  CROSSSECTION FOR THIS INPUT POLARISATION
      QSQR(NND)=POLPRD+FNSQR+QMOD
      CALL GMSCA(POLO(1,NND),VEC,DPOP(IDOMPT),3,1)
      CALL GMADD(VEC,POLD,POLD,3,1)
      QSQRM=QSQRM+QSQR(NND)*DPOP(IDOMPT)
C      write (lpt,4005) NND,(polo(I,nnd),I=1,3),QSQR(nnd),DPOP(IDOMPT)
C     &QSQR(NND),POLPRD,QMOD
C 4005 FORMAT (11x,I4,3(3F8.4,2X),2x,6F8.4)
C  SUMS FOR DERIVATIVES
      CALL CMRSCA(DXSDQ(1,NND),DXSDQ(1,NND),DPOP(IDOMPT),3,1)
      CALL CMRSCA(DPOLDQ(1,1,NND),DPOLDQ(1,1,NND),DPOP(IDOMPT),3,3)
      IF (IPROP.EQ.0)  CALL CGMREV(Q(1,ND),Q(1,ND),3,1)
C      WRITE (LPT,4004) NND,(Q(II,ND),II=1,3)
   27 continue
   20 CONTINUE
   22 CONTINUE
C  CONVERT POLD WHICH IS AN INTENSITY TO POLARISATION
      CALL GMSCA(POLD,POLD,1./QSQRM,3,1)
C     1(FQCDER(II,JJ,1),II=1,3),JJ=1,ND)
C 4004 FORMAT (' Q  : ',I4,3(2F8.3,2X))
C      WRITE (LPT,4000) POLI,POLD,FC
C4000 FORMAT (' Polarisations:', 2(3F8.4,2X),2x,F8.4)

C
C This section done for every entry
C Take the components parallel to the Analysis direction
    7 CALL GMEQ(POLIT(1,IABS(IPDIR(2))),POLA,3,1)
C      write (lpt,4005) ICOMP,pold,pola
      IF (IPDIR(2).LT.0) CALL GMREV(POLA,POLA,3,1)
      GCALC = SCALPR(POLA,POLD)
C      WRITE (LPT,4000) POLD,POLA,GCALC
C  DERIVATIVES WITH RESPECT TO DOMAIN POPS
      DO 24 ND=1,NDTOT
      temp=scalpr(pola,polo(1,nd))
C      write (lpt,4444) ipdir(2),nd,(polo(i,nd),i=1,3),temp
C 4444 format (2i4,3f8.3,2x,f8.3)
C  THE DOMAINs and twins are treated together
      L=KDPOP(IDPTR+ND)
      IF (L .NE.0) DERIVV(L)=(SCALPR(POLO(1,ND),POLA)
     &-GCALC*QSQR(ND))/QSQRM
   24 CONTINUE
C
C CONVERT DERIVATIVES FOR FAMILY 2 FROM BEING 'OF FCMOD' AS THEY ARE OUT OF
C LFCALC, TO DERIVATIVES OF POLARISATION
      DO 6 I=1,NVARF(2,JPHASE,1)
      SUM=0.
C FIRST NUCLEAR DERIVATIVES: THEY DONT DEPEND ON WHICH DOMAIN
      cfac= crsclp(dpoldn ,pola)
      ANBIT=2.*REAL((cfac-DXSDN*gcalc)*DERIVT(I))
C SUM OVER DOMAINS FOR MAGNETIC BIT
      N180D=1
      IF (IPROP.EQ.0) N180D=2
      DO 30 ND=1,N180D*KCENT
C 180 degree domains are numbered from NDOM up
      IF (IPROP.EQ.0 .AND. ND .GT.NDOM) THEN
        CALL CMRSCA(FQCDER(1,ND-NDOM,I),CVEC,-1.,3,1)
      ELSE
        CALL CGMEQ(FQCDER(1,ND,I),CVEC,3,1)
      ENDIF
      DO 31 L=1,3
      DO 31 J=1,3
   31 TENS(L,J)=POLD(L)*DXSDQ(J,ND)
      CALL CMRSCA(TENS,TENS,-1.,3,3)
      CALL CGMADD(DPOLDQ(1,1,ND),TENS,TENS,3,3)
      CALL CGMPRD(TENS,CVEC,DPOLDP,3,3,1)
      CFAC=CRSCLP(DPOLDP,POLA)
      SUM=SUM+2.*REAL(CFAC)
C      IF (ICOMP.EQ.1) WRITE (LPT,4001) ND,(POLO(IX,ND),IX=1,3),DPOLDP
C 4001 FORMAT (' Domain poln and diff.: ',I4,2X,3(3F8.4,2X))
   30 CONTINUE
      DERIVV(LVFST1(2,JPHASE,1)+I)=(ANBIT+SUM)/QSQRM
C  TEST OUTPUT
      IF (IOUT.GE.100) THEN
        DIFFER(ICOMP,I)=DERIVV(LVFST1(2,JPHASE,1)+I)
        IF (ICOMP.EQ.3) THEN
          IF (I.EQ.1) THEN
            WRITE (LPT,4002)I, (DIFFER(L,I),L=1,3)
        ELSE
            WRITE (LPT,4003)I, (DIFFER(L,I),L=1,3)
        ENDIF
 4002     FORMAT (/' Calculated Differentials Var no.',I3,2X,3F8.4)
 4003     FORMAT (26X,'Var no.',I3,2X,3F8.4)
        ENDIF
      ENDIF
    6 CONTINUE
C      write (lpt,4010) gcalc,(DERIVV(I),I=1,LVARV)
C 4010 format (F9.3,2X,8F9.3)
C
      RETURN
      END
C
C
C
C
C LEVEL 8      SUBROUTINE CALCQX(H,MGCALC)
      SUBROUTINE CALCQX(H,MGCALC)
C
C *** CALCQX new by PJB C4.26 March 2013 ***
C
CX
CC 7B
CH Calculates GCALC= Q x Q* and its derivatives for magnetic structures
CH  of CPVEC type.
C
CA On entry H is the 1x3 array holding h,k,l
CA       MGCALC is the name of the routine to get magnetic structure factors
CA              and their derivatives.  This is LPVCAL.
CP Structure factor data must have been set up in various COMMON blocks
CP by SYMOP RECIP ATOPOS, SETFOR, SETANI
CP LSETUP, PARSSF, VARMAK must have set up the Least Squares.
CP STLSSF must have read the L cards:
C
CD Sets GCALC, the calculated function corresponding to an OBS just read
CD Also produces the vector DERIVV (LVARV long) of derivatives of this
CD function wrt each variable in turn.
C
CD The function GCALC is made up of three functions multiplied together.
CD We write G=P1*P2*P3 where P2 is a simple function of FCALC, P1 is
CD independent of FCALC (possibly doamin fac), and P3 is the extinction
CD correction.(They are written in this way for ease of differentiation.)
CD
CD The sequence of operations is:
CD      Get STHL= sin theta/lambda, SSQRD= STHL squared.
CD      Clear derivatives to zero.
CD      Form P1 and its derivatives.
CD      Form P2: get FCALC and derivatives of mod FCALC wrt family 2 variables,
CD               using both nuclear and magnetic structure factors
CD      The scattering factors are calculated using PFORMF with multipoles.
CD      Convert derivatives to be of P2, not just mod FCALC
CD      Form P3: convert derivatives
CD      Form GCALC and make all derivatives so that they are of GCALC
CD On exit in /OBSCAL/ GCALC = calculated function to compare with observed
CD On exit in /DERVAR/ DERIVV is an array holding all derivatives of GCALC
CD wrt all variables
CD
CN Expects L REFI=10 the GOBS and GCALC are polarised neutron cross term (P.Q X Q*)/Q.Q*
CN             and the scale gives the domain factor
C
      EXTERNAL MGCALC
      DIMENSION H(3),QREAL(3),QIMAG(3),QDREAL(3),QDIMAG(3),TMP(3),
     &TTP(3)
      LOGICAL TESTOV
/BRAGG/
/DERVAR/
/EXTN/
/IOUNIT/
/MAGDAT/
/MCAL/
/OBSCAL/
/OVER/
/PHASE/
/POINTS/
/POLDA/
/PRBLEM/
/QCAL/
/QCALD/
/REFINE/
/SCLDAT/
/SYMMAG/
      DATA POLND /1.0,0.,0./
C
      STHL = VCTMOD(0.5,H,2)
C STHL=SIN THETA/LAMBDA;  SSQRD = IT SQUARED
      SSQRD = STHL*STHL
C
C CLEAR DERIVATIVES WRT VARIABLES - THERE MAY NOT BE AN ENTRY FOR EVERY ONE FOR
C THIS INPUT VALUE OF H:
      IF (LVARV .GT. 0) CALL GMZER(DERIVV,1,LVARV)
C DO P2 first
      CALL MGCALC(H)
      QXQCAL = 0.
      do 6 IREP=1,2
      P2DEN =rscalp(q(1,irep),q(1,irep))
C  CHECK THAT P2 IS NOT ZERO
      IF (TESTOV(1.,P2DEN)) GO TO 6
      CALL CMREAL(Q(1,IREP),QREAL,3,1)
      CALL CMIMAG(Q(1,IREP),QIMAG,3,1)
      call vecprd(qimag,qreal,tmp)
C  scalar product with P
      XCOMP=SCALPR(POLND,TMP)
      QXQCAL=QXQCAL+ (XCOMP/P2DEN)
C
C Then P1
      P1=SCALE(ISCALE)
C
C Derivatives with repect to the phase of the order pars are zero
      do 1 ir=1,2
      l=KSPORD(ir,1)
      if (L.eq.0) go to 1
      CALL CMREAL(FQCDER(1,IREP,L),QDREAL,3,1)
      CALL CMIMAG(FQCDER(1,IREP,L),QDIMAG,3,1)
      call vecprd(qdimag,qreal,tmp)
      call vecprd(qimag,qdreal,ttp)
      call gmadd(tmp,ttp,tmp,3,1)
      DERIVV(L)=DERIVV(L) + (scalpr(polnd,tmp)/p2den)*p1
    1 continue
C ALLOW FOR FAMILY 5 (MULTIPOLES)
      L25ST=LVFST1(2,1,1)
      L1F=NVARF(1,JPHASE,1)
      IF (L25ST .EQ. -1) L25ST=LVFST1(5,1,1)
      DO 4 I=1,NVARF(5,JPHASE,1)+NVARF(2,JPHASE,1)
      CALL CMREAL(FQCDER(1,IREP,I),QDREAL,3,1)
      CALL CMIMAG(FQCDER(1,IREP,I),QDIMAG,3,1)
      call vecprd(qdimag,qreal,tmp)
      call vecprd(qimag,qdreal,ttp)
      call gmadd(tmp,ttp,tmp,3,1)
      DERIVV(L25ST+I)=DERIVV(L25ST+I) + (scalpr(polnd,tmp)/p2den)*p1
    4 CONTINUE
    6 continue
      gcalc=qxqcal*p1
C In QXQ refinement scale gives domain ratio
      L=KSCALE(ISCALE)
      IF (L .NE. 0) DERIVV(L)=QXQCAL
      ycalc=fmcsqr
      RETURN
      END
C
C
C
C
C LEVEL 8      SUBROUTINE CALCSF(H,SFCALC)
      SUBROUTINE CALCSF(H,SFCALC)
C
C *** CALCSF updated by PJB 31-May-1994 ***
C
CX
CC 7B
CH Makes the calculated function and derivatives for single crystal LSQ.
CA On entry H is a 3-sized array containing h,k,l
CA   SFCALC is a subroutine name used for the actual structure factor
CA   calculation, like LFCALC
CP Structure factor data must have been set up in various COMMON blocks
CP by SYMOP RECIP ATOPOS, SETFOR, SETANI
CP LSETUP, PARSSF, VARMAK must have set up the Least Squares.
CP STLSSF must have read the L cards:
C
CD Sets GCALC, the calculated function corresponding to an OBS just read
CD Applies an extinction correction if there was an E card.
CD Also produces the vector DERIVV (LVARV long) of derivatives of this
CD function wrt each variable in turn.
C
CD The function GCALC is made up of three functions multiplied together.
CD We write G=P1*P2*P3 where P2 is a simple function of FCALC, P1 is
CD independent of FCALC (being Scale * overall itf), and P3 is the extinction
CD correction.(They are written in this way for ease of differentiation.)
C
CD If IREF=2, we are in fact comparing OBS squared with GCALC squared.  This is
CD dealt with right at the end, after proceeding as though we were not.
CD
CD The sequence of operations is:
CD      Get STHL= sin theta/lambda, SSQRD= STHL squared.
CD      Clear derivatives to zero.
CD      Form P1 and its derivatives.
CD      Form P2: get FCALC and derivatives of mod FCALC wrt family 2 variables
CD      Convert derivatives to be of P2, not just mod FCALC
CD      Form P3: convert derivatives
CD      Form GCALC and make all derivatives so that they are of GCALC
CD      Adjust for GCALC squared if necessary
C
      EXTERNAL SFCALC
      LOGICAL TESTOV
      DIMENSION H(3)
/BRAGG/
/DERVAR/
/EXTN/
/FCAL/
/OBSCAL/
/OVER/
/PHASE/
/POINTS/
/PRBLEM/
/REFINE/
/SCLDAT/
C
      STHL = VCTMOD(0.5,H,2)
C STHL=SIN THETA/LAMBDA;  SSQRD = IT SQUARED
      SSQRD = STHL*STHL
C
C CLEAR DERIVATIVES WRT VARIABLES - THERE MAY NOT BE AN ENTRY FOR EVERY ONE FOR
C THIS INPUT VALUE OF H:
      IF (LVARV .GT. 0) CALL GMZER(DERIVV,1,LVARV)
C
C FORM P1, THE PART OF GCALC INDEPENDENT OF MOD(FC)
      P1=SCALE(ISCALE)*EXP((-TFAC)*SSQRD)
      IF (KTFAC .NE. 0) DERIVV(KTFAC)=-SSQRD
      L=KSCALE(ISCALE)
      IF (L .NE. 0) DERIVV(L)=1./SCALE(ISCALE)
C NEXT DO P2:
      CALL SFCALC(H)
      P2=FCMOD
      IF (IREF .EQ. 4) P2=REAL(FC)
      DP2DFQ=0.
      IF (.NOT. TESTOV(1.,FCMOD)) DP2DFQ=1./FCMOD
C
C P3:
      CALL EXTINC(3,FCMOD)
      P3=EXTCOR
      IF (KDOMR .NE. 0) DERIVV(KDOMR)=DEXDRQ
      IF (KMOSC .NE. 0) DERIVV(KMOSC)=DEXDGQ
      a=DEXDGQ
C
C CONVERT DERIVATIVES FOR FAMILY 2 FROM BEING 'OF FCMOD' AS THEY ARE OUT OF
C LFCALC, USING:
C DP2/DV = DMODFC/DV * DP2/DMODFC - AND ALL ARE DIVIDED BY P2
C DP3/DV = DMODFC/DV * DP3/DMODFC - AND ALL ARE DIVIDED BY P3
C GIVING D(GCALC)/DV OVER GCALC=(DP2/DV OVER P2 + DP3/DV OVER P3)
C ALLOW FOR FAMILY 5 (MULTIPOLES)
      L25ST=LVFST1(2,1,1)
      IF (L25ST .EQ. -1) L25ST=LVFST1(5,1,1)
      DO 4 I=1,NVARF(5,JPHASE,1)+NVARF(2,JPHASE,1)
   4  DERIVV(LVFST1(2,1,1)+I)=FCDERS(I)*(DP2DFQ+DEXDFQ)
C
      GCALC = P1*P2*P3
C ADJUST IF NECESSARY FOR GCALC SQUARED:
      FAC=GCALC
      IF (IREF .EQ. 2) THEN
        GCALC=GCALC*GCALC
        FAC=2.*GCALC
      ENDIF
      DO 6 I=1,LVARV
   6  DERIVV(I)=DERIVV(I)*FAC
      RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE CALDSM(H,ISAT)
      SUBROUTINE CALDSM(H,ISAT)
C
C *** CALDSM to include PROPAGATION VECTOR by PJB 21-Sept-93 ***
C
CX
CC 17B
CH Calculates  d star squared, and its derivatives wrt reciprocal
CH cell quadratic products and components of propagation vector.
CA On entry H is a 1x3 vector holding h,k,l
CP In /CELPAR/ CPARS(1:6,2) should hold the 6 reciprocal quadratic products
CP             A* = a* squared
CP             D* =  b* c* cos alpha* etc
CP             KCPARS(1:6) should hold fix/vary information for each of the 6
CP             reciprocal cell quadratic products.
CP If magnetic /SATELL/ should have been set up with a call to PROPER
CP             and the corresponding symmetry constraints with PROPSM
CD Sets GCALC in /OBSCAL/ to be d star squared, the d spacing squared,
CD and DERIVV in /DERVAR/ to be the derivative, where relevant
C
      DIMENSION H(3),DER(3)
/CELPAR/
/DERVAR/
/OBSCAL/
/POINTS/
/REFINE/
/SATELL/
C
      GCALC=0.
      J=2
      K=3
      DO 1 I=1,3
      C1=H(I)*H(I)
      C2=2.*H(J)*H(K)
      GCALC=GCALC+C1*CPARS(I,2)+C2*CPARS(I+3,2)
      L1=KCPARS(I)
      L2=KCPARS(I+3)
      IF (L1 .GT. 0) DERIVV(L1)=C1
      IF (L2 .GT. 0) DERIVV(L2)=C2
      J=K
   1  K=I
C
      IF (MAG .AND. ISAT .NE.0) THEN
        CALL PROPDR(H,ISAT,DER)
        DO 2 I=1,3
        L=KPROP(I)
        IF (L.GT.0) DERIVV(L)=DER(I)
    2   CONTINUE
      ENDIF
      RETURN
      END
C
C
C
C
C LEVEL 8      SUBROUTINE CALMMG(HH,SFCALC,MGCALC)
      SUBROUTINE CALMMG(HH,SFCALC,MGCALC)
C
C *** CALMMG updated C4.23  by PJB June 2011 quanities printed by LSQCYC ***
C
CX
CC 7B
CH Calculates GCALC and its derivatives for structures with magnetic twinning
C
CA On entry H is the 1x3 array holding h,k,l
CA       SFCALC is the name of the routine to get nuclear structure factors
CA              and their derivatives.  This is usually LFCALC.
CA       MGCALC is the name of the routine to get magnetic structure factors
CA              and their derivatives.  This is usually LMCALC.
CP Structure factor data must have been set up in various COMMON blocks
CP by SYMOP RECIP ATOPOS, SETFOR, SETANI
CP LSETUP, PARSSF, VARMAK must have set up the Least Squares.
CP STLSSF must have read the L cards:
C
CD called by LSQCYC iF MTWIN and MAG are true
CD Sets GCALC, the calculated function corresponding to an OBS just read
CD Applies an extinction correction if there was an E card.
CD Also produces the vector DERIVV (LVARV long) of derivatives of this
CD function wrt each variable in turn.
C
CD The function GCALC is made up of three functions multiplied together.
CD We write G=P1*P2*P3 where P2 is a simple function of FCALC, P1 is
CD independent of FCALC (being Scale * overall itf), and P3 is the extinction
CD correction.(They are written in this way for ease of differentiation.)
C
CD If IREF=2, we are in fact comparing OBS squared with GCALC squared.  This is
CD dealt with right at the end, after proceeding as though we were not.
CD
CD The sequence of operations is:
CD      Get STHL= sin theta/lambda, SSQRD= STHL squared.
CD      Clear derivatives to zero.
CD      Form P1 and its derivatives.
CD      Form P2: get FCALC and derivatives of mod FCALC wrt family 2 variables,
CD               using both nuclear and magnetic structure factors
CD      The scattering factors are calculated using PFORMF with multipoles.
CD      Convert derivatives to be of P2, not just mod FCALC
CD      Form P3: convert derivatives
CD      Form GCALC and make all derivatives so that they are of GCALC
CD      Adjust for GCALC squared if necessary
CD On exit in /OBSCAL/ GCALC = calculated function to compare with observed
CD On exit in /DERVAR/ DERIVV is an array holding all derivatives of GCALC
CD wrt all variables
CD Sets FCMOD and FMCMOD as domain and twin averaged nuclear and magnetic structure factors
CD YCALC to total averaged structure factor without extinction.
CD

C
      EXTERNAL SFCALC,MGCALC
      DIMENSION H(3),HH(3),save(4)
      LOGICAL TESTOV
/BRAGG/
/DERVAR/
/DSOURC/
/EXTN/
/FCAL/
/IOUNIT/
/MAGDAT/
/MCAL/
/OBSCAL/
/OVER/
/PHASE/
/POINTS/
/POLDA/
/PRBLEM/
/QCAL/
/QCALD/
/REFINE/
/SCLDAT/
/SYMMAG/
/TWIN/
C
      IF  (IREF .GT.4) CALL ERRIN2(IREF 1,0,
     &'CALMMG shouldn''t be called with IREF=',' ')
      STHL = VCTMOD(0.5,HH,2)
C STHL=SIN THETA/LAMBDA;  SSQRD = IT SQUARED
      SSQRD = STHL*STHL
C
C CLEAR DERIVATIVES WRT VARIABLES - THERE MAY NOT BE AN ENTRY FOR EVERY ONE FOR
C THIS INPUT VALUE OF H:
      IF (LVARV .GT. 0) CALL GMZER(DERIVV,1,LVARV)
C
C FORM P1, THE PART OF GCALC INDEPENDENT OF MOD(FC)
      P1=SCALE(ISCALE)*EXP((-TFAC)*SSQRD)
      IF (KTFAC .NE. 0) DERIVV(KTFAC)=-SSQRD
      L=KSCALE(ISCALE)
      IF (L .NE. 0) DERIVV(L)=1./SCALE(ISCALE)
C
C Set the domain pointer FOR THE FIRST TWIN AND DOMAIN
      IDOMPT=0
      IF (JSRC .NE.1) IDOMPT=IPDOM(JSRC-1)
C XCALC accumulates the crossection
      XCALC =0.0
      FMCALC=0.0
      FNCALC=0.0
C Start of the twin loop
      DO 1 ITWIN=1,NTWIN
      CALL GMPRD(HH,TWMAT(1,1,ITWIN),H,1,3,3)
C NEXT DO P2:
      CALL SFCALC(H)
      CALL MGCALC(H)
      P2S=FCMOD**2
C Start of the domain loop
      DO 2 ND=1,NDOM
C Increment the domain pointer
      IDOMPT=IDOMPT+1
      P2ST=RSCALP(Q(1,ND),Q(1,ND))
C 1011 format ('Q for dom',i3,3(2f8.4,2x),2f8.4)
C      write (lpt,4000)itwin, h,IDOMPT,dpop(IDOMPT)
C 4000 format (i4,3f8.3,I4,f10.4)
      P2TT=P2S + P2ST
      P2T=SQRT(P2TT)
C  CHECK THAT P2S IS NOT ZERO
        IF (TESTOV(1.,P2T)) GO TO 2
      DFTDFQ=1./P2T
C P3:
      CALL EXTINC(3,P2T)
      P3TT=EXTCOR**2
      XCALT=DPOP(IDOMPT)*P3TT*P2TT
      FNCALT=DPOP(IDOMPT)*P2S
      FMCALT=DPOP(IDOMPT)*P2ST
      XCALC=XCALC+XCALT
C4.23 FNCALC and FMCALC accumulate nuclear and magnetic intensities
      FNCALC=FNCALC+FNCALT
      FMCALC=FMCALC+FMCALT
C      write (lpt,4000)itwin, h,p2t,P3TT,p2tt,xcalt
C 4000 format (i4,3f8.3,6f10.4)
      save(ITWIN)=xcalt
      IF (KDOMR .NE. 0) DERIVV(KDOMR)=DERIVV(KDOMR)+DEXDRQ*XCALT
      IF (KMOSC .NE. 0) DERIVV(KMOSC)=DERIVV(KMOSC)+DEXDGQ*XCALT
C
C CONVERT DERIVATIVES FOR FAMILY 2 FROM BEING 'OF FCMOD' AS THEY ARE OUT OF
C LFCALC, USING:
C DP2/DV = DMODFC/DV * DP2/DMODFC - AND ALL ARE DIVIDED BY P2
C DP3/DV = DMODFC/DV * DP3/DMODFC - AND ALL ARE DIVIDED BY P3
C GIVING D(GCALC)/DV OVER GCALC=(DP2/DV OVER P2 + DP3/DV OVER P3)
C
C DERIVATIVES OF DPOPS
      L=KDPOP(IDOMPT)
      IF (L .NE. 0)
     &DERIVV(L)=0.5*P3TT*P2TT
C FAMILY 2 AND 5 DERIVATIVES
C ALLOW FOR FAMILY 5 (MULTIPOLES)
      L25ST=LVFST1(2,1,1)
      IF (L25ST .EQ. -1) L25ST=LVFST1(5,1,1)
      DO 4 I=1,NVARF(5,JPHASE,1)+NVARF(2,JPHASE,1)
      EFAC=P3TT*(1.+P2T*DEXDFQ)
      BIT=(FCDERS(I)*FCMOD)+RSCALP(FQCDER(1,ND,I),Q(1,ND))
      DERIVV(L25ST+I)=DERIVV(L25ST+I) + DPOP(IDOMPT)*BIT*EFAC
    4 CONTINUE
C      WRITE (LPT,1000) H,GCALC,(DERIVV(L25ST+I),
C     &I=1,NVARF(5,JPHASE,1)+NVARF(2,JPHASE,1))
C 1000 FORMAT (3F4.0,F8.4,2X,6F8.4)
    2 CONTINUE
    1 CONTINUE
C
C XCALC IS NOW THE TOTAL INTENSITY
C AND THE DERIVATIVES ARE MULTIPLIED BY SQRT(XCALC)
      ZCALC=SQRT(XCALC)
      GCALC =P1*ZCALC
      YCALC=sqrt(FMCALC+FNCALC)
C4.23 Transfer sqrt of nuclear and magnetic intensities to coomon for output
      FMCMOD=sqrt(FMCALC)
      FCMOD=SQRT(FNCALC)
C ADJUST IF NECESSARY FOR GCALC SQUARED:
C  CHECK THAT XCALC IS NOT ZERO
      IF (TESTOV(1.,YCALC)) GO TO 100
      FAC=P1/YCALC
      IF (IREF .EQ. 2) THEN
C4.21 CORRECTION P1 REPLACES PI
        GCALC=XCALC*P1**2
        FAC=2.*P1**2
      ENDIF
      DO 6 I=1,LVARV
   6  DERIVV(I)=DERIVV(I)*FAC
C      WRITE (LPT,1000) HH,GCALC,(DERIVV(I), I=1,LVARV)
 100  RETURN
      END
C
C
C
C
C LEVEL 5      SUBROUTINE CALPOL(H,NEW,ICOMP,SFCALC,MGCALC)
      SUBROUTINE CALPOL(H,NEW,ICOMP,SFCALC,MGCALC)
C
C *** CALPOL corrected by PJB 31-May-1994 ***
C
CX
CC 7B
CH Calculates scattered polarisations and their derivatives for structures
CH which may have mixed magnetic and nuclear reflections.
C
CA On entry H is the 1x3 array holding h,k,l
CA          NEW is TRUE if this hkl differs from the previous one
CA                   FALSE if it is the same
CA          ICOMP is the component of polarisation required
CA          SFCALC is the name of the routine to get nuclear structure factors
CA                 and their derivatives.  This is usually LFCALC.
CA          MGCALC is the name of the routine to get magnetic structure factors
CA                and their derivatives.  This is now LMCALC.
CP Structure factor data must have been set up in various COMMON blocks
CP by SYMOP RECIP ATOPOS, SETFOR, SETANI
CP LSETUP, PARSSF, VARMAK must have set up the Least Squares.
CP STLSSF must have read the L cards:
C
CD Sets GCALC to the ICOMPth component of the scattered polarisation.
CD Also produces the vector DERIVV (LVARV long) of derivatives of this
CD function wrt each variable in turn.
C
CD The sequence of operations is:
CD      Get STHL= sin theta/lambda, SSQRD= STHL squared.
CD      Clear derivatives to zero.
CD      If NEW calculate the nuclear and magnetic structure factors and
CD      their derivatives.
CD      If ICOMP=1 (ie 1st component for this input polarisation)
CD      calculate the output polarisation, summing over all domains
CD      and its differential wrt all parameters.
CD      Otherwise just set GCALC to previously calculated component
CD      of polarisation and scale the appropriate component of the
CD      differentials.
CD On exit in /OBSCAL/ GCALC = calculated function to compare with observed
CD         in /DERVAR/ DERIVV is an array holding all derivatives of GCALC
CD                            wrt all variables.
C
      EXTERNAL SFCALC,MGCALC
      COMPLEX CVEC(3),QSTAR(3),CPRD,CRSCLP,QCROSP(3)
      COMPLEX DPOLDP(3),TENS(3,3)
      LOGICAL NEW
      DIMENSION H(3),VEC(3),VEC1(3),POLI(3),DIFFER(3,10),QCROSQ(3)
/BRAGG/
/DERVAR
/FCAL/
/IOUNIT/
/QCAL/
/QCALD/
/OBSCAL/
/OVER/
/PHASE/
/POINTS/
/POLDAT/
/PRBLEM/
/SATELL/
/SCLDAT/
C
      STHL = VCTMOD(0.5,H,2)
C STHL=SIN THETA/LAMBDA;  SSQRD = IT SQUARED
      SSQRD = STHL*STHL
C
C CLEAR DERIVATIVES WRT VARIABLES - THERE MAY NOT BE AN ENTRY FOR EVERY ONE FOR
C THIS INPUT VALUE OF H:
      IF (LVARV .GT. 0) CALL GMZER(DERIVV,1,LVARV)
C
C  CALCULATE STRUCTURE FACTORS ON FIRST ENTRY
      IF (NEW) THEN
        CALL SFCALC(H)
        CALL MGCALC(H)
      ENDIF
      IF (ICOMP.EQ.1) THEN
C  CLEAR SUMS
        CALL GMZER(POLD,1,3)
        CALL CGMZER(DPOLDQ,3,3)
        CALL CGMZER(DPOLDN,3,1)
        CALL CGMZER(DXSDQ,3,1)
        QSQRM=0.
        DXSDN=CMPLX(0.,0.)
C  SET POLARISATION
        CALL GMEQ(POLM,POLI,3,1)
C  LOOP OVER DOMAINS
        NND=0
        DO 22 N180=1,ND180
        DO 20 ND=1,NDOMN/ND180
        NND=NND+1
C  CALCULATION OF POLARISATION DIRECTIONS
        CALL CMCONJ(Q(1,ND),QSTAR,3,1)
        CALL CGMSCA(Q(1,ND),CVEC,CONJG(FC),3,1)
        CALL CMREAL(CVEC,POLO(1,NND),3,1)
C  QXQ* TERM
        CALL CMREAL(QSTAR,VEC,3,1)
        CALL CMIMAG(QSTAR,VEC1,3,1)
        CALL VECPRD(VEC,VEC1,QCROSQ)
C141 Keep the Q X Q* term separate
        CALL GMADD(POLO(1,NND),QCROSQ,VEC,3,1)
C  POLARISATION DEPENDENT PART OF CROSS-SECTION
        POLPRD=2.*SCALPR(VEC,POLI)
C141 Correct the sign by subtracting here
        CALL GMSUB(POLO(1,NND),QCROSQ,POLO(1,NND),3,1)
C  N*PXQ PART OF POLARISATION
        CALL CMIMAG(CVEC,VEC,3,1)
        CALL VECPRD(POLI,VEC,VEC1)
        CALL GMADD(POLO(1,NND),VEC1,POLO(1,NND),3,1)
C  Q(P.Q*) PART OF POLARISATION
        CPRD=CRSCLP(QSTAR,POLI)
        CALL CGMSCA(Q(1,ND),CVEC,CPRD,3,1)
        CALL CMREAL(CVEC,VEC,3,1)
        CALL GMADD(POLO(1,NND),VEC,POLO(1,NND),3,1)
C  DOUBLE ALL THIS FOR TWICE REAL AND IMAG PARTS
        CALL GMSCA(POLO(1,NND),POLO(1,NND),2.,3,1)
C  PART PARALLEL TO INCIDENT POLN
        FNSQR=(ABS(FC))**2
        QMOD=RSCALP(Q(1,ND),Q(1,ND))
        CALL GMSCA(POLI,VEC,FNSQR-QMOD,3,1)
        CALL GMADD(POLO(1,NND),VEC,POLO(1,NND),3,1)
C
C DERIVATIVES WITH RESPECT TO FC AND Q
C FIRST DIFFERENTIATE THE CROSSECTION
        DXSDN=DXSDN+(CONJG(FC)+CPRD)*SCALE(NND)
        CALL CMCONJ(Q(1,ND),DXSDQ(1,NND),3,1)
        CALL C1MSCA(POLI,CVEC,CONJG(FC),3,1)
        CALL CGMADD(CVEC,DXSDQ(1,NND),DXSDQ(1,NND),3,1)
C FIDDLE THE QXQ TERM  -idQ{Q*xP}
        CALL CMREAL(QSTAR,VEC,3,1)
        CALL VECPRD(VEC,POLI,VEC1)
        CALL C1MSCA(VEC1,QCROSP,CMPLX(0.,-1.),3,1)
        CALL CMIMAG(QSTAR,VEC,3,1)
        CALL VECPRD(VEC,POLI,VEC1)
        CALL C1MSCA(VEC1,CVEC,CMPLX(1.,0.),3,1)
        CALL CGMADD(CVEC,QCROSP,QCROSP,3,1)
        CALL CGMADD(QCROSP,DXSDQ(1,NND),DXSDQ(1,NND),3,1)
C THE DIFFERENTIALS OF THE SCATTERED POLARISATION
C  FIRST WITH RESPECT TO NUCLEAR PART
        CALL C1MSCA(POLI,CVEC,CONJG(FC),3,1)
        CALL CGMADD(QSTAR,CVEC,CVEC,3,1)
        CALL CGMADD(QCROSP,CVEC,CVEC,3,1)
        CALL CMRSCA(CVEC,CVEC,SCALE(NND),3,1)
C SUM UP WEIGHTING WITH DOMAIN POPULATION
        CALL CGMADD(CVEC,DPOLDN,DPOLDN,3,1)
C THEN THE TENSOR FOR THE MAGNETIC DERIVATIVES
        DO 25 J=1,3
        DO 25 I=1,3
        DPOLDQ(I,J,NND)=QSTAR(I)*POLI(J)-POLI(I)*QSTAR(J)
        IF (I.EQ.J) THEN
          DPOLDQ(I,I,NND)=DPOLDQ(I,I,NND)+CONJG(FC)+CPRD
        ELSE
          DO 26 K=1,3
          IF (K.EQ.I .OR. K.EQ.J) GO TO 26
          IF (ABS(J-I).EQ.1) THEN
            SIG=FLOAT(ISIGN(1,J-I))
          ELSE
            SIG=FLOAT(ISIGN(1,I-J))
          ENDIF
          DPOLDQ(I,J,NND)=DPOLDQ(I,J,NND)+
     &    SIG*CMPLX(0.,1.)*(CONJG(FC)*POLI(K)+QSTAR(K))
   26     CONTINUE
        ENDIF
   25   CONTINUE
C
C  SCALE BY DOMAIN FRACTIONS ADD INTO SUMS FOR MEAN POLARISATION
C141 remove this line        CALL GMEQ(POLO(1,NND),VEC,3,1)
C  CROSSSECTION FOR THIS INPUT POLARISATION
        QSQR(NND)=POLPRD+FNSQR+QMOD
        CALL GMSCA(POLO(1,NND),VEC,SCALE(NND),3,1)
        CALL GMADD(VEC,POLD,POLD,3,1)
        QSQRM=QSQRM+QSQR(NND)*SCALE(NND)
C  SUMS FOR DERIVATIVES
        CALL CMRSCA(DXSDQ(1,NND),DXSDQ(1,NND),SCALE(NND),3,1)
        CALL CMRSCA(DPOLDQ(1,1,NND),DPOLDQ(1,1,NND),SCALE(NND),3,3)
        IF (ND180.EQ.2) THEN
          DO 23 II=1,3
          Q(II,ND)=-Q(II,ND)
   23     CONTINUE
        ENDIF
   20   CONTINUE
   22   CONTINUE
C  CONVERT POLD WHICH IS AN INTENSITY TO POLARISATION
        CALL GMSCA(POLD,POLD,1./QSQRM,3,1)
C      WRITE (LPT,4004) (JJ,(Q(II,JJ),II=1,3),
C     1(FQCDER(II,JJ,1),II=1,3),JJ=1,NDOM)
C 4004 FORMAT (' Q and dQ/dmu for each domain: ',3(I4,2(6F6.3,2X)/38X))
C      WRITE (LPT,4000) POLI,POLD,FC
C 4000 FORMAT (' Input and Output polarisations:'  2(3F8.4,2X)/
C     1'  Nuclear SF : '2F8.4)
      ENDIF
C
C  DERIVATIVES WITH RESPECT TO SCALE FACTORS
      DO 24 ND=1,NDOMN
C  THE SCALES ARE THE DOMAIN POPULATIONS
      L=KSCALE(ND)
      IF (L .NE.0) DERIVV(L)=(POLO(ICOMP,ND)-POLD(ICOMP)*QSQR(ND))/QSQRM
   24 CONTINUE
C
C CONVERT DERIVATIVES FOR FAMILY 2 FROM BEING 'OF FCMOD' AS THEY ARE OUT OF
C LFCALC, TO DERIVATIVES OF POLARISATION
      DO 4 I=1,NVARF(2,JPHASE,1)
      SUM=0.
C FIRST NUCLEAR DERIVATIVES: THEY DONT DEPEND ON WHICH DOMAIN
      ANBIT=2.*REAL((DPOLDN(ICOMP)-DXSDN*POLD(ICOMP))*DERIVT(I))
C SUM OVER DOMAINS FOR MAGNETIC BIT
      DO 30 ND=1,NDOMN
      IF (ND180.EQ.2 .AND. ND .GT.NDOMN/2) THEN
        CALL CMRSCA(FQCDER(1,ND-NDOMN/2,I),CVEC,-1.,3,1)
      ELSE
        CALL CGMEQ(FQCDER(1,ND,I),CVEC,3,1)
      ENDIF
      DO 31 L=1,3
      DO 31 J=1,3
   31 TENS(L,J)=POLD(L)*DXSDQ(J,ND)
      CALL CMRSCA(TENS,TENS,-1.,3,3)
      CALL CGMADD(DPOLDQ(1,1,ND),TENS,TENS,3,3)
      CALL CGMPRD(TENS,CVEC,DPOLDP,3,3,1)
      SUM=SUM+2.*REAL(DPOLDP(ICOMP))
C      IF (ICOMP.EQ.1) WRITE (LPT,4001) ND,(POLO(IX,ND),IX=1,3),DPOLDP
C 4001 FORMAT (' Domain poln and diff.: ',I4,2X,3(3F8.4,2X))
   30 CONTINUE
      DERIVV(LVFST1(2,JPHASE,1)+I)=(ANBIT+SUM)/QSQRM
C  TEST OUTPUT
      IF (IOUT.GE.100) THEN
        DIFFER(ICOMP,I)=DERIVV(LVFST1(2,JPHASE,1)+I)
        IF (ICOMP.EQ.3) THEN
          IF (I.EQ.1) THEN
            WRITE (LPT,4002)I, (DIFFER(L,I),L=1,3)
        ELSE
            WRITE (LPT,4003)I, (DIFFER(L,I),L=1,3)
        ENDIF
 4002     FORMAT (/' Calculated Differentials Var no.',I3,2X,3F8.4)
 4003     FORMAT (26X,'Var no.',I3,2X,3F8.4)
        ENDIF
      ENDIF
    4 CONTINUE
C
      GCALC = POLD(ICOMP)
      RETURN
      END
C
C
C
C
C LEVEL 8      SUBROUTINE CALPOW(H,MODE,AFAC,SFCALC,MGCALC)
      SUBROUTINE CALPOW(H,MODE,AFAC,SFCALC,MGCALC)
C
C *** CALPOW  updated by PJB April 2013 C4.27 ***
C
CX
CC 7B
C
CH LSQ for magnetised powders and polarised neutrons
C4.19 ANGFAC now entered as AFAC
CD Calculates the up and down intensities and their derivatives with respect
CD to all parameters.
CA On entry H is the 1x3 array holding h,k,l
CA       MODE is 0 for the first entry for each H, calculates the structure
CA                 factors and differentials and returns I+ as GCALC
CA            is >0 for the second entry which returns I-.
CA       MODE = 2 Gcalc= I+ - I-
CA       AFAC is the intensity angle factor for powderd mult/sin(theta)*sin(2theta)
CA       SFCALC is the name of the routine to get nuclear structure factors
CA              and their derivatives.  This is usually LFCALC.
CA       MGCALC is the name of the routine to get magnetic structure factors
CA              and their derivatives.  This is usually LMCALC.
CP Structure factor data must have been set up in various COMMON blocks
CP by SYMOP RECIP ATOPOS, SETFOR, SETANI
CP LSETUP, PARSSF, VARMAK must have set up the Least Squares.
CP STLSSF must have read the L cards:
C
CD Sets GCALC, the calculated function corresponding to an OBS just read
CD Also produces the vector DERIVV (LVARV long) of derivatives of this
CD function wrt each variable in turn.

      EXTERNAL SFCALC,MGCALC
      DIMENSION H(3)
      DIMENSION XSEC(2),UPNUM(2),DWNUM(2),AINT(2)
      COMPLEX FN,PHASE,FND
      LOGICAL LATABS,ISPABS
/BRAGG/
/DERVAR/
/FCAL/
/IOUNIT/
/MAGDAT/
      DIMENSION CHIIJ(6,20),KCHIJ(6,20)
      EQUIVALENCE (ANGM,CHIIJ),(KSMOD,KCHIJ)
/MCAL/
/OBSCAL/
/OVER/
/PHASE/
/POINTS/
/POLDA/
/PRBLEM/
/QCAL/
/QCALD/
/REFINE/
/SCLDAT/
      save p1,aint,xst
C Calculate all H dependent quantities on first entry
C      write (lpt,4000) h,mode,afac,scale(Iscale),Iscale
C 4000 format ('Calpow ',3f4.0,i4,2f10.2,i4)
      ANGFAC=AFAC
      IF (MODE.EQ.1) THEN
        ICOMP=2
        POL=POLDW
        GO TO 50
      ENDIF
      ICOMP=1
      pol=polup
C CLEAR DERIVATIVES WRT VARIABLES - THERE MAY NOT BE AN ENTRY FOR EVERY ONE FOR
C THIS INPUT VALUE OF H:
      IF (LVARV .GT. 0) CALL GMZER(DERIVV,1,LVARV)
      FCMOD=0
      FMCMOD=0
      YCALC=0.
      GCALC=0.
      STHL = VCTMOD(0.5,H,2)
      P1=SCALE(ISCALE)*ANGFAC
C STHL=SIN THETA/LAMBDA;  SSQRD = IT SQUARED
      SSQRD = STHL*STHL
      if (.not. (latabs(h) .or.ispabs(h))) CALL SFCALC(H)
      CALL MGCALC(H)
      P2S=FCMOD**2+FMCSQR
C      YCALC=SQRT(P2S)
      PHASE=CMPLX(COSAL,SINAL)
      FN=FCMOD*PHASE
      XST=2.*REAL(FN*CONJG(QDOTP))
      YCALC=XST
      SIG = 1
      DO 2 I=1,2
      UPNUM(I) = 0.5*(1.+ SIG*POLUP*SCALE(ISCALE+1))
      DWNUM(I) = 0.5*(1.+ SIG*POLDW*SCALE(ISCALE+1))
      XSEC(I)=P2S + SIG*XST
      SIG = -SIG
    2 CONTINUE
C NOW GET THE CONTRIBUTIONS TO THE UP AND DOWN INTENSITIES
      AINT(1) = XSEC(1)*UPNUM(1)+XSEC(2)*UPNUM(2)
      AINT(2) = XSEC(1)*DWNUM(1)+XSEC(2)*DWNUM(2)
C      write (lpt,1000) XSEC,UPNUM,DWNUM,aint,xst,angfac
C 1000 format (11f12.4)
C4.27 To allow refinement on UP-Down
   50 if (MODE .LT. 2) then
        P2=AINT(ICOMP)
      else
        p2=AINT(1)-AINT(2)
        POL=POLUP-POLDW
      endif
      GCALC=P1*P2
C DERIVATIVE for scale
      L=KSCALE(ISCALE)
      IF (L .NE. 0) DERIVV(L)=1./SCALE(ISCALE)
C DERIVATIVE WRT DEPOLARISATION
      IF (KSCALE(ISCALE+1) .NE.0) THEN
        DERIVV(KSCALE(ISCALE+1)) =P1*POL*XST
      ENDIF
C CONVERT DERIVATIVES  TO ones wrto INTENSITIES
C ALLOWING FOR FAMILY 5 (MULTIPOLES)
      L25ST=LVFST1(2,1,1)
      IF (L25ST .EQ. -1) L25ST=LVFST1(5,1,1)
      LAST=NVARF(5,JPHASE,1)+NVARF(2,JPHASE,1)
      DO 4 I=1,NVARF(5,JPHASE,1)+NVARF(2,JPHASE,1)
      PHASE=CMPLX(COSAL,-SINAL)
      FND=FCDERS(I)*PHASE
      DIDPAR = 2.*(REAL(FND*FN))+ FMCDER(I)
      DXDPAR = 2.*(REAL(QDOTP*FND)+REAL(FCMOD*PHASE*DQDOTP(I)))
      DERIVV(L25ST+I)=POL*DXDPAR/P2
      If (Mode .Lt.2)Derivv(L25St+I)=Derivv(L25St+I)+ Didpar/P2
    4 CONTINUE
      DO 5 I=1,LVARV
      DERIVV(I)=DERIVV(I)*GCALC
    5 CONTINUE

      RETURN
      END
C
C
C
C
C LEVEL 8      SUBROUTINE CAMPHS(MODE,VAL,AMPHS,M,N)
      SUBROUTINE CAMPHS(MODE,VAL,AMPHS,M,N)
C
C *** CAMPHS new by PJB C4.26 March 2013 ***
C
CX
CC 12C
CH Conversion between amp phase and real imag representatiom of
CH complex MxN vectors
C
CA M,N the domensions of the vector to convert
CA MODE = -1 converts complex VAL(i,j) to to amps amphs(i,j,1) and phase
CA           amphs(i,j,2)
CA MODE = 1 does the reverse
      COMPLEX VAL(*)
      DIMENSION AMPHS(*)
C
      IJ=1
      GOTO (20,22,21),MODE+2
   22 CALL ERRIN2(MODE,0,'Entry to CAMPHS with mode=',' illegal')
   20 DO 1 J=1,N
      DO 1 I=1,M
      AMPHS(IJ)=CABS(VAL(IJ))
      b=AIMAG(VAL(IJ))
      a=REAL(VAL(IJ))
      AMPHS(IJ+1)=ATAN2(b,a)
      IJ=IJ+2
    1 CONTINUE
      GO TO 100
   21 DO 2 J=1,N
      DO 2 I=1,M
      VAL(IJ)=AMPHS((2*IJ)-1)*CEXP(CMPLX(0.,AMPHS(2*IJ)))
      IJ=IJ+1
    2 CONTINUE
  100 RETURN
      END
C
C
C
C
C LEVEL 3      SUBROUTINE CARDIN(IDEN)
      SUBROUTINE CARDIN(IDEN)
C
C *** CARDIN by JCM 2 Feb 88 ***
C
CX
CC 13C
CH Finds the record number IDEN in the DIRECT ACCESS file on unit IO10,
CH which is a copy of the Crystal Data File.
CA On entry IDEN holds the number of the required record.
C
CD Reads card in format A80 to ICARD, leaving this to be interpreted elsewhere.
CD Ignores Y and Z cards, which were not counted when PREFIN read the data.
CD Counts those it ignores in NYZ, and so that calling routines know if last
CD card is Y or Z, sets NYZ=-1 in those cases.
CD
CD Complains if record IDEN is not present.
C
/CARDRC/
/PHASE/
/SCRACH/
C
      NYZ=0
C
C CHECK NOT TRYING TO READ SILLY RECORD:
      ILOW=0
      IF (JPHASE .GT. 1) ILOW=NTOTAL(JPHASE-1)
      IHI=NTOTAL(JPHASE)
      IF (IDEN .LE. ILOW .OR. IDEN .GT. IHI) CALL ERRIN2(IDEN,0,
     & 'record','requested from crystal data is not there')
C
C CATCH ALSO CDFS ENDING IN Y OR Z CARDS:
   1  IF (IDEN+NYZ .GT. IHI) GO TO 101
      READ (IO10,REC=IDEN+NYZ,FMT=1001) ICARD
1001  FORMAT (A80)
      NYZ=NYZ+1
      IF (ICARD(1:1) .EQ. 'Y' .OR. ICARD(1:1) .EQ. 'Z') GO TO 1
      GO TO 100
C
 101  NYZ=-1
 100  RETURN
      END
C
C
C
C
C LEVEL 6      SUBROUTINE CDFIN(NUMCDF,ID,ENDIP)
      SUBROUTINE CDFIN(NUMCDF,ID,ENDIP)
C
C *** CDFIN updated by JCM 21 Jan 92 ***
C
CX
CC 13C
CH Reads in one Crystal Data File and copies it to direct access unit number
CH IO10, starting at record number ID.
CA  On entry NUMCDF = which crystal data file is required;  1 in MK3
CA        ID is the previously used record of DIRECT ACCESS file IO10
CA        in COMMON /CARDRC/ ICRYDA=unit from which to read
CA On exit  ID has been advanced and gives total records on IO10
CA        ENDIP is TRUE if the end of the file hs been reached.
CD Writes to /CARDRC/ the following:
CD        NTOTAL(NUMCDF)=number of records for phase NUMCDF
CD        INREA(26,NUMCDF)=absolute starting addresses for letters
CD        ICDN(26,NUMCDF)=numbers of cards starting with letters
CD Also detects presence of I OUTP item, and unless a non-zero value is
CD already in IOUT in /IOUNIT/, interprets the integer after the I OUTP.
CD
CD Also detects if it is reading phase 1 of a multiphase job, because it must
CD form the union of this with "phase 0"
CD
CO Writes Y cards straight to unit LPT.
CI Reads crystal data sets from unit ICRYDA.
CO Lists on LPT numbers of each type of card read.
CN Modified to ignore empty cdfs (e.g. if the file inadvertently starts with
CN a non-letter)
C
      CHARACTER *4 MWORD
      CHARACTER *1 ISS
      CHARACTER *10 FILNOM
      LOGICAL GETM,ENDIP,ONCARD
C
/CARDRC/
/CHARS/
/GLOBAL/
/IOUNIT/
/PHAS0/
/PHASE/
/SCRACH/
C
      IDIN=ID
      ENDIP=.FALSE.
      N1=NUMCDF
C UNLESS PHASE 1 FOLLOWING PHASE 0, FOR EACH LETTER, SET NO CARDS YET READ:
      IF (.NOT. MULFAS .OR. (NPHASE .NE. 1)) THEN
        DO 1 I = 1,26
        ICDN(I,N1) = 0
    1   INREA(I,N1) = 1
      ELSE
C CLEAR ONLY THE COUNT OF L CARDS:
        ICDN(12,N1)=0
        INREA(12,N1)=1
C AND NOTE THE END OF PHASE 0, FOR THE NEW CDF:
        NCDF0=NTOTAL(1)
      ENDIF
C SET HAVE NOT READ CARD STARTING "M GET" ASKING TO UNDUMP PREVIOUS MAP:
      GETM=.FALSE.
C THE DATASET IS COPIED ACROSS WITH Y AND Z CARDS,
C AND THE STARTING LINE NUMBER FOR EACH LETTER IS RECORDED IN INREA.
C ICDN SAYS HOW MANY CARDS OF THAT LETTER HAVE BEEN READ:
C INLET HOLDS SERIAL NUMBER OF PREVIOUS STORED CARD'S LETTER:
      INLET=-999
   8  READ (ICRYDA,1000,END=2) ICARD
1000  FORMAT (A80)
C IGNORE BLANK LINES ANYWHERE:
      LEN=LENGT(ICARD)
      IF (LEN .EQ. 0) GO TO 8
      L=LETTER(ICARD(1:1))
C THIS GIVES AN ANSWER IN RANGE 1-26, BUT ACCEPTS LOWER CASE
      IF (L .EQ. 0) GO TO 12
C
C LETTER RECOGNISED:
      IF (L .NE. 25) GO TO 3
C Y CARDS COPIED ON TO OUTPUT:
      WRITE (LPT,2004) (ICARD(J:J),J=2,LEN)
2004  FORMAT (' ',79A1)
      GO TO 7
C
C Z CARDS TOTALLY IGNORED:
   3  IF (L .EQ. 26) GO TO 7
C
C CARDS OTHER THAN Y AND Z:
C JUMP IF SAME INITIAL LETTER AS PREVIOUSLY STORED CARD:
      IF (INLET .EQ. L) GO TO 4
C
C NEW BLOCK - CHECK NOT HAD ANY OF THIS LETTER BEFORE:
      IF (ICDN(L,N1) .NE. 0) GO TO 6
      INREA(L,N1) = ID+1
      INLET=L
C JOIN HERE IN MIDDLE OF BLOCK:
   4  ICDN(L,N1) = ICDN(L,N1) + 1
      IF (L .EQ. 13) THEN
        CALL RDWORD(MWORD,ITEMP,3,IPT,80,0,IER)
        GETM = (MWORD .EQ. 'GET')
      ENDIF
   7  ID=ID+1
      WRITE (IO10,REC=ID,FMT=1000) ICARD
      GO TO 8
C
C ERROR ON SHUFFLED CARDS:
   6  CALL ERRCH2(ICARD(1:1),0,
     & 'more than one group of cards labelled',
     & 'found on crystal data file')
C
C END OF CRYSTAL DATA:
   2  ENDIP=.TRUE.
  12  IF (.NOT. ENDIP .AND. ID .EQ. IDIN) GO TO 8
      IF (GETM) CALL MAJUST
      IF (N1 .EQ. 1) CALL MESS(LPT,1,
     & 'Data read by PREFIN from file '//FILNOM(ICRYDA))
      IF (N1 .GT. 1) CALL MESS(LPT,1,
     & 'Next phase data read by PREFIN from file '//FILNOM(ICRYDA))
      DO 5 I = 1,26
      IF (ICDN(I,N1) .EQ. 0) GO TO 5
      ISS=' '
      IF (ICDN(I,N1) .GT. 1) ISS='s'
      WRITE (LPT,2001) ICDN(I,N1),ISS,LETUP(I)
2001  FORMAT (5X,I4,' card',A1,'  labelled ',A1)
    5 CONTINUE
C
      NTOTAL(N1)=ID
      IF (IOUT .EQ. 0) THEN
        IF (ONCARD('I','OUTP',A)) IOUT=JFIX(A)
        IF (IOUT .NE. 0) WRITE (LPT,2000) IOUT
 2000   FORMAT (/' Diagnostic output at number',I5,' required'/)
      ENDIF
      RETURN
      END
C
C
C
C
C LEVEL 4      SUBROUTINE CDSCAN(CH,WORDS,LEN,K,LCD,NW)
      SUBROUTINE CDSCAN(CH,WORDS,LEN,K,LCD,NW)
C
C *** CDSCAN updated by JCM 2 Feb 88 ***
C
CX
CC 13C
CH Finds the next card which starts with the letter given in CH, and has
CH then a word which is one of the collection given in WORDS.
CA On entry CH is the A1 character to start the card
CA          WORDS is an A4 array of length LEN with possible next words
CA          K is 0 if to search from start, otherwise where to start
CA           - i.e. we search from the K+1th card of the crystal data
CA On exit  LCD = which card, if found
CA             = -1 if none found starting CH
CA             = 0 if some start CH, but none of WORDS come next
CA          NW = which word of WORDS was found
CD sets a copy of the found card into ICARD
C
      CHARACTER *1 CH
      CHARACTER *4 WORDS(LEN),WORD
/CARDRC/
/PHASE/
/SCRACH/
C
      L=-1
      I=LETTER(CH)
C
C IF NO CH CARDS AT ALL, EXIT:
      IF (ICDNO(I) .EQ. 0) GO TO 101
      ID=K+1
      IF (K .EQ. 0) ID=IABS(INREAD(I))
C
C READ NEXT CARD:
   1  IF (ID .GT. NTOTAL(JPHASE)) GO TO 102
      CALL CARDIN(ID)
C  WE HAVE TO DO SOMETHING ABOUT CDFS ENFDING Y OR Z
      IF (NYZ .EQ. -1) GO TO 102
      ID=ID+NYZ
      L=ID-1
C CHECK WE STILL HAVE CH CARDS:
      IF (ICARD(1:1) .NE. CH) GO TO 102
C READ WORD STARTING AT POSITION 3:
      CALL RDWORD(WORD,J,3,IPT,80,0,IER)
C SCAN POSSIBLE VOCABULARY OF NEXT WORDS:
      DO 2 NW=1,LEN
      IF (WORD .EQ. WORDS(NW)) GO TO 101
   2  CONTINUE
C "WORD" ON THIS CARD DOES NOT MATCH - TRY NEXT "CH" CARD:
      GO TO 1
 102  L=0
 101  LCD=L
      RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE CELDER(H,DERS)
      SUBROUTINE CELDER(H,DERS)
C
C *** CELDER updated by JCM  7 Sep 88 ***
C
CX
CC 6B
CH From h,k,l calculates d* squared and its derivatives, and sets SSQRD.
CA On entry H is a real 1x3 vector holding h,k,l
CA On exit DERS is a real 1x6 array holding the derivatives of d* squared
CA              wrt A*, B*, C*, D*, E*, F*
CP CPARS in /CELPAR/ must contain A*, B*, C*, D*, E*, F*
CD Also sets SSQRD in /BRAGG/ to be s squared (=d* squared/4)
CD STHL in /BRAGG/ to be sin theta/lambda, s, or d*/2
CD and DSTAR2 in /BRAGG/ to be d* squared
C
      DIMENSION H(3),DERS(6)
/BRAGG/
/CELPAR/
C
      DSDS=0.
      J=2
      K=3
      DO 1 I=1,3
      DERS(I)=H(I)*H(I)
      DERS(I+3)=2.*H(J)*H(K)
      DSDS=DSDS+DERS(I)*CPARS(I,2)+DERS(I+3)*CPARS(I+3,2)
      J=K
   1  K=I
      SSQRD=DSDS/4.
      DSTAR2=DSDS
      STHL=SQRT(SSQRD)
      RETURN
      END
C
C
C
C
C LEVEL 2      SUBROUTINE CELLMA(BGTOSM)
      SUBROUTINE CELLMA(BGTOSM)
C
C *** from MATCEL by PJB Aug 98 26-Aug-1998 ***
C
CC 1A
CH Makes the matrix to transform the variance/covariance matrix for
CH the quadratic products to that for a,b,c etc
C
CA On exit BGTOSM(6,6) is the required matrix
C
      DIMENSION BGTOSM(6,6)
/CELPAR/
C
C FIRST FORM LITTLE A,B,C
      ASMALL=CELL(1,1,1)
      BSMALL=CELL(2,1,1)
      CSMALL=CELL(3,1,1)
C
      CALL GMZER(BGTOSM,6,6)
      BGTOSM(1,1)=2.*ASMALL
      BGTOSM(2,2)=2.*BSMALL
      BGTOSM(3,3)=2.*CSMALL
C     BGTOSM(4,4) HAS THE FORM -(180/PI)*B*C*SIN(ALPHA) ETC.
      BGTOSM(4,4)=-RADIAN(BSMALL*CSMALL*CELL(1,3,1))
      BGTOSM(5,5)=-RADIAN(ASMALL*CSMALL*CELL(2,3,1))
      BGTOSM(6,6)=-RADIAN(ASMALL*BSMALL*CELL(3,3,1))
      BGTOSM(2,4)=CPARS(4,1)/BSMALL
      BGTOSM(3,4)=CPARS(4,1)/CSMALL
      BGTOSM(1,5)=CPARS(5,1)/ASMALL
      BGTOSM(3,5)=CPARS(5,1)/CSMALL
      BGTOSM(1,6)=CPARS(6,1)/ASMALL
      BGTOSM(2,6)=CPARS(6,1)/BSMALL
      RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE CELMAT(TOSTAR)
      SUBROUTINE CELMAT(TOSTAR)
C
C *** CELMAT by JCM 17 Aug 89 ***
C
CX
CC 1B
CH Sets up the matrix to convert derivatives wrt A,B,C . . (cell quadratic
CH products in real space) to derivatives wrt A*, B*, C*, . . in
CH reciprocal space.
CA On exit TOSTAR is the required 6x6 matrix
CP On entry CPARS(1:6,1) contain the real space cell quadratic products,
CP A=a sqrd, B=b sqrd, C=c sqrd D=b c cos alpha, etc
C
      DIMENSION TOSTAR(6,6)
/CELPAR/
C
C FIRST COPY OUT A B C D E F FOR SANITY:
      A=CPARS(1,1)
      B=CPARS(2,1)
      C=CPARS(3,1)
      D=CPARS(4,1)
      E=CPARS(5,1)
      F=CPARS(6,1)
C THERE WILL BE CLEVERER WAYS OF DOING THIS, BUT LETS GET IT RIGHT FIRST:
      TOSTAR(1,1)=-(A*A)
      TOSTAR(1,2)=-(F*F)
      TOSTAR(1,3)=-(E*E)
      TOSTAR(1,4)=-(F*E)
      TOSTAR(1,5)=-(E*A)
      TOSTAR(1,6)=-(A*F)
      TOSTAR(2,1)=-(F*F)
      TOSTAR(2,2)=-(B*B)
      TOSTAR(2,3)=-(D*D)
      TOSTAR(2,4)=-(B*D)
      TOSTAR(2,5)=-(D*F)
      TOSTAR(2,6)=-(F*B)
      TOSTAR(3,1)=-(E*E)
      TOSTAR(3,2)=-(D*D)
      TOSTAR(3,3)=-(C*C)
      TOSTAR(3,4)=-(D*C)
      TOSTAR(3,5)=-(C*E)
      TOSTAR(3,6)=-(E*D)
C
      TOSTAR(4,1)=-(2.*E*F)
      TOSTAR(4,2)=-(2.*B*D)
      TOSTAR(4,3)=-(2.*D*C)
      TOSTAR(4,4)=-(B*C)-(D*D)
      TOSTAR(4,5)=-(C*F)-(D*E)
      TOSTAR(4,6)=-(B*E)-(D*F)
      TOSTAR(5,1)=-(2.*A*E)
      TOSTAR(5,2)=-(2.*D*F)
      TOSTAR(5,3)=-(2.*C*E)
      TOSTAR(5,4)=-(C*F)-(D*E)
      TOSTAR(5,5)=-(A*C)-(E*E)
      TOSTAR(5,6)=-(A*D)-(E*F)
      TOSTAR(6,1)=-(2.*A*F)
      TOSTAR(6,2)=-(2.*B*F)
      TOSTAR(6,3)=-(2.*D*E)
      TOSTAR(6,4)=-(B*E)-(D*F)
      TOSTAR(6,5)=-(A*D)-(E*F)
C4.21 FV REPLACED BY F
      TOSTAR(6,6)=-(A*B)-(F*F)
      RETURN
      END
C
C
C
C
C LEVEL 3      SUBROUTINE CELNEW
      SUBROUTINE CELNEW
C
C *** CELNEW updated by PJB  26-Aug-1998 ***
C
CX
CC 6C
CH Writes out a new C card after cell parameter refinement.
CP CELL in /CELPAR/ should contain a,b,c, cos alpha, beta, gamma
CP CELESD  in /CELPAR/ should contain the variance/covariance matrix
CP for the quadratic products (see MATCEL)
CO Writes to unit NEWIN a new C card
CN Does not preserve any blanks originally left for symmetry.
C
      DIMENSION ANG(3)
/CELPAR/
/DERBAS/
/NEWOLD/
/OBSCAL/
/SCRACH/
C
      CHI2=SUMWD/(NOBS-LVARB)
C MAY BE SD CARD:
      IF (ICARD(3:4) .EQ. 'SD') THEN
        IF (PRODSD) THEN
          WRITE (NEWIN,2001) (SQRT(CELESD(I,I,1)),I=1,6)
2001      FORMAT ('C SD PROD',6F10.4)
        ELSE
          WRITE (NEWIN,2002) (SQRT(CHI2*CELLSD(I,I)),I=1,6)
2002      FORMAT ('C SD ',3(F10.6,1X),3(F9.5,1X))
          GO TO 100
        ENDIF
      ENDIF
C
      DO 1 I=1,3
   1  ANG(I)=DEGREE(ARCCOS(CELL(I,2,1)))
      WRITE (NEWIN,2000) (CELL(I,1,1),I=1,3),(ANG(I),I=1,3)
2000  FORMAT ('C ',3F10.5,3F10.3)
 100  RETURN
      END
C
C
C
C
C LEVEL 9      SUBROUTINE CELREL(IFAM,IGEN,ISPC)
      SUBROUTINE CELREL(IFAM,IGEN,ISPC)
C
C *** CELREL updated by JCM 2 May 90 ***
C
CX
CC 6A
CH Transfers any  relations which exist between cell parameters from
CH their own COMMON to the general "contraint/fixing" COMMON.
CA On entry IFAM, IGEN, ISPC designate the first parameter, A*
CD Moves the constraint and/or fixing information from /CELFIX/ to
CD join the general initial fix/constrain info.
CD Also keep starting family, genus, species for later consultation in
CD NCELF,NCELG,NCELS
C
CN Cell parameters are source-independent (KSOURC=1) but may be phase dependent
CN B*, C* etc are assumed to have ISPC going sequentially up in 1's from A*
C
      DIMENSION NCOUNT(6)
/CELFIX/
/PHASE/
C
C SET UP LIST OF 6 KK VALUES:
      DO 5 I=1,6
   5  NCOUNT(I)=KPAK(IFAM,IGEN,ISPC+I-1,JPHASE,1)
      CALL FIXREL(6,IPTCEL,AMCELL,NCOUNT,5)
      NCELF=IFAM
      NCELG=IGEN
      NCELS=ISPC
      RETURN
      END
C
C
C
C
C LEVEL 5      SUBROUTINE CELSDP(ALSQ,MATSZ)
      SUBROUTINE CELSDP(ALSQ,MATSZ)
C
C *** CELSDP by JCM 17 Aug 89 ***
C
CX
CC 6C
CH Prints the esds of real cell parameters after a cycle of refinement.
CA ALSQ, MATSZ need to be handed around in routine calls
CP ALSQ must hold the inverse LSQ matrix
CP CPARS holds A,B,C,D,E,F, the real cell quadratic products, and
CP CELL the result of reading a C card.
CO If a variance is negative, writes 0.
C
      DIMENSION ALSQ(MATSZ)
      CHARACTER *1 SI(3)
      CHARACTER *5 AN(3)
/CELPAR/
/DERBAS/
/IOUNIT/
/OBSCAL/
      DATA SI/'a','b','c'/
      DATA AN/'alpha',' beta','gamma'/
C
C KEEP COMPILER QUIET
      ALSQ(1)=ALSQ(1)
C NOT IN JWP VERSION
C      CALL MATCEL(ALSQ,MATSZ)
      CHI2=SUMWD/(NOBS-LVARB)
      CALL MESS(LPT,2,
     & ' ************* LATTICE CONSTANTS *************')
      CALL NEWLIN(LPT)
C
      DO 1 I=1,6
C jpw Chi^2 factor added
      C=SQRT(CHI2*AMAX1(CELLSD(I,I),0.))
      IF (I .LT. 4) WRITE(LPT,2001) SI(I),CELL(I,1,1),C
 2001 FORMAT('        ',A1,' = ',F8.5,' +/- ',F6.5)
      IF (I .GE. 4) WRITE(LPT,2002) AN(I-3),
     & DEGREE(ACOS(CELL(I-3,2,1))),C
2002  FORMAT('    ',A5,' = ',F8.4,' +/- ',F6.4)
   1  CONTINUE
C
      RETURN
      END
C
C
C
C
C LEVEL 7      SUBROUTINE CELSHF(N)
      SUBROUTINE CELSHF(N)
C
C *** CELSHF updated by JCM 10 Feb 87 ***
C
CX
CC 6C
CH Applies a shift to a cell quadratic product.
CA N= which parameter; 1=A*, 2=B*, 3=C* etc
C
/CELPAR/
C
      CALL ADJUST(CPARS(N,2))
      GO TO 100
C
C
C TO SET ALL CELL PARAMETERS FIXED, OR VARY ONE:
      ENTRY CELVAR(N,NV)
      IF (N .EQ. 0) THEN
        DO 1 I=1,6
   1    KCPARS(I)=0
      ELSE
        KCPARS(N)=NV
      ENDIF
 100  RETURN
      END
C
C
C
C
C LEVEL 2      SUBROUTINE CENTRE(LUNIT,N,TXT,NWIDE)
      SUBROUTINE CENTRE(LUNIT,N,TXT,NWIDE)
C
C *** CENTRE by JCM 12 Sep 92 ***
C
CX
CC 13C
CH Writes on unit LUNIT the given message, centred & preceded by N empty lines.
CA On entry TXT is a CHARACTER variable holding the message,
CA          N is in integer requesting N empty lines before the message, and
CA            may be 0, for no lines
CA            or > 98, for a page throw.
CA          LUNIT is the unit on which to write.
CA          NWIDE is the width of page in which the text is to be centred.
CO Writes to unit LUNIT N empty lines or a page throw, then the given text with
CO a "space" carriage control, centred within NWIDE spaces.
C
      CHARACTER *(*) TXT
C
      IF (N .LT. 99) THEN
        DO 1 I=1,N
   1    WRITE (LUNIT,2000)
2000    FORMAT (1X)
      ELSE
        WRITE (LUNIT,2002)
2002    FORMAT ('1')
      ENDIF
      L=LENGT(TXT)
      M=0
C THIS SHOULD ROUND BY MOVING THE TEXT 1 PLACE LEFTWARDS:
      IF (L .LT. NWIDE) M=(NWIDE-L)/2
      WRITE (LUNIT,2001) (' ',I=1,M),(TXT(I:I),I=1,L)
2001  FORMAT (1X,200A1)
      RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE CENTRO(CVEC,SVEC,RMAT,PSIFCC,)
      SUBROUTINE CENTRO(CVEC,SVEC,RMAT,PSIFAC,PSIFCC)
C
C *** CENTRO updated by PJB C141 March 2006 ***
C
CX
CC 17B
CH Executes the action of the centre of symmetry on a term in the
CH magnetic structure factor for helimagnetic structures.
CA On entry: CVEC(3)   is a complex vector, the term for one operator,
CA           RMAT(3,3) is the required rotation matrix,
CA           PSIFAC    is the phase factor associated with the operator,
CA           PSIFCC    is the phase factor for the centrosymmetic operator,
CA On exit:  SVEC(3)   is the result of applying the phase factors and the
CA                     centrosymmetric rotation.
CA For entry CENDIF the two terms VEC1 and VEC2 whose sum is SVEC
CA are also returned to allow calculation of the differentials wrt the psi's.
CN SVEC can be the same as CVEC if replacement is required
CN Called in magnetic stucture factors and magnetic least squares when
CN treating the centre of symmetry.
C
C141 Logicals PSI and PCEN in the call removed
      LOGICAL DIF
      COMPLEX CVEC(3),SVEC(3),TVEC(3),TVEC1(3),TVEC2(3)
      COMPLEX PSIFAC,PSIFCC,VEC1(3),VEC2(3)
      DIMENSION RMAT(3,3)
C
      DIF=.FALSE.
      GO TO 1
C
C141 Logicals PSI and PCEN in entry removed
      ENTRY CENDIF(CVEC,SVEC,VEC1,VEC2,RMAT,PSIFAC,PSIFCC)
      DIF=.TRUE.
C COMPLEX CONJUGATE FOR CENTROSYMETRIC STRUCTURE FACTOR
   1  CALL CMCONJ(CVEC,TVEC1,3,1)
C PHASE FACTOR ASSOCIATED WITH DIRECT OPERATOR
      CALL CGMSCA(CVEC,TVEC,PSIFAC,3,1)
C SPIN ROTATION ASSOCIATED WITH THE CENTRE OF SYMMETRY
      CALL RCMPRD(RMAT,TVEC1,TVEC2,3,3,1)
C PHASE FACTOR ASSOCIATED WITH CENTRIC  OPERATOR
      CALL CGMSCA(TVEC2,TVEC2,PSIFCC,3,1)
      CALL CGMADD(TVEC2,TVEC,SVEC,3,1)
      IF (DIF) THEN
C BOTH TERMS IN THE SUM RETURNED FOR DIFFERENTIALS
        CALL CGMEQ(TVEC,VEC1,3,1)
        CALL CGMEQ(TVEC2,VEC2,3,1)
      ENDIF
      RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE CGAMMA(R,PUP,PDN,DEL,G,QQ,QLAM,RMS)
      SUBROUTINE CGAMMA(R,PUP,PDN,DEL,G,QQ,QLAM,RMS)
C
C *** CGAMMA modified by PJB  04-May-1999 ***
C
CX
CC 9C
CH Solves the quadratic equation for gamma in terms of the flipping ratio.
CD Used to determine the ratio, gamma, of mangetic to nuclear scattering from
CD polarised neutron flipping ratios.
CD Can correct for spin-independent multiple or unpolarised lambda/2
CA scattering.
CA On entry R is the flipping ratio,
CA          PUP is the up polarisation,
CA          PDN is the down polarisation,
CA          DEL(3) contains the esd's in R, PUP and PDN in that order
CA          QQ is the sin of the angle between the magnetisation direction
CA             and the scattering vector
CA          QLAM is the cosine of the angle between the polarisation direction
CA             and the scattering vector
CA          RMS is the ratio of multiple (or lamba/2) to nuclear scattering.
CA On exit the positive root is in G(1) and the negative one is in G(2).
CN For polarised neutron data analysis.
C
      DIMENSION G(2,2),FAC(4),DEL(3),DG(3)
      DOUBLE PRECISION A,B,BR,C,Y
C
      A = DBLE(R)-DBLE(1.)
      BR = DBLE(((R*PDN -PUP)*QLAM)/QQ)
      B=BR/A
      C=DBLE((1.+RMS)/(QQ*QQ))
      Y=C/(B*B)
      S=SNGL(SQRT(C))
      IF (Y.GE.1.0) THEN
C CASE OF GAMMA CLOSE TO 1 ( equal roots)
         G(1,1)=-SIGN(S,SNGL(B))
         G(1,2)=G(1,1)
         GO TO 4
      ENDIF
C NORMAL GAMMA
      IF (Y.GT. .001) THEN
        ROOT=SNGL(SQRT(1.-Y))
        G(1,1)=-(SNGL(B)*(1.+ROOT))
        G(1,2)=-(SNGL(B)*(1.-ROOT))
        FAC(2)=(PUP-PDN)/SNGL(A**2)
        FAC(3)=-SNGL(1./A)
        FAC(4)=R/SNGL(A)
        IF (ROOT .LT. .01) GO TO 4
        DO 1 I=1,2
        FAC(1)=G(1,I)/(G(1,I)+SNGL(B))
        DO 2 J=1,3
        DG(J)=FAC(1)*FAC(J+1)*DEL(J)
    2   CONTINUE
        G(2,I)=SQRT(DG(1)**2+DG(2)**2+DG(3)**2)
    1   CONTINUE
      ELSE
C CASE OF SMALL GAMMA
        DGB=SNGL(0.5*C/(BR**2))
        DIFF=SNGL(0.5*C/B)
        G(1,2)=-SNGL((2.*B))+DIFF
        G(1,1)=-DIFF
        DG(1)=DGB*QLAM*(PUP-PDN)*DEL(1)/QQ
        DG(2)=DGB*QLAM*SNGL(A)*DEL(2)/QQ
        DG(3)=DGB*QLAM*R*SNGL(A)*DEL(3)/QQ
        G(2,1)=SQRT(DG(1)**2+DG(2)**2+DG(3)**2)
        DG(1)=-(2*QLAM*(PUP-PDN)*DEL(1)/(QQ*SNGL(A*A)))
        DG(2)=-(2*QLAM*DEL(2)/(QQ*SNGL(A)))
        DG(3)=-(2*QLAM*R*DEL(3)/(QQ*SNGL(A)))
        G(2,2)=SQRT(DG(1)**2+DG(2)**2+DG(3)**2)
      ENDIF
      GO TO 100
C esd's when gamma close to 1 must be calculated numerically
    4 DG(1)=(QLAM*DEL(1)*R)*(PUP-PDN)/(SNGL(A*A)*QQ)
      DG(2)=(QLAM*DEL(2)*PUP)/(SNGL(A)*QQ)
      DG(3)=(R*QLAM*DEL(3)*PDN)/(SNGL(A)*QQ)
      G(2,1)=SQRT(2.*(ABS(DG(1))+ABS(DG(2))+ABS(DG(3))))
      G(2,2)=G(2,1)
C
  100 RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE CGMADD(A,B,C,NI,NJ)
      SUBROUTINE CGMADD(A,B,C,NI,NJ)
C
C *** CGMADD by JCM 20 Nov 87 ***
C
CX
CC 12C
CH Sets COMPLEX matrix C = COMPLEX matrix A + COMPLEX matrix B.
CA On entry A and B are NI by NJ COMPLEX matrices
CA On exit C is set to the sum of A and B
C
      COMPLEX A(NI,NJ),B(NI,NJ),C(NI,NJ)
      DO 1 I= 1,NI
      DO 1 J=1,NJ
   1  C(I,J) = A(I,J) + B(I,J)
      RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE CGMEQ(A,B,N,M)
      SUBROUTINE CGMEQ(A,B,N,M)
C
C *** CGMEQ by JCM ***
C
CX
CC 12C
CH Sets COMPLEX matrix B equal to COMPLEX matrix A.
CA On entry A is a COMPLEX matrix of DIMENSION N,M
CA On exit B, a COMPLEX matrix of the same total size, has been set equal to A
CN Would not give error even if N or M were zero.
      COMPLEX A(1),B(1)
      NE = N*M
      DO 1 I = 1,NE
    1 B(I) = A(I)
      RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE CGMPRD(A,B,C,I,J,K)
      SUBROUTINE CGMPRD(A,B,C,I,J,K)
C
C *** CGMPRD by JCM ***
C
CX
CC 12C
CH Multiplies together two COMPLEX matrices.
CA On entry A (of dimensions IxJ) and B (of dimensions JxK) are COMPLEX matrices
CA On exit  C (of dimensions IxK) is the product of A and B
CN C is unchanged if any of I,J or K is zero.
C
      COMPLEX A(1),B(1),C(1)
      DO 2 II = 1,I
      IK = II
      JK = 1
      DO 2 KK = 1,K
      IJ = II
      C(IK) = 0.
      DO 1 JJ = 1,J
      C(IK) = C(IK) + A(IJ)*B(JK)
      IJ = IJ + I
    1 JK = JK + 1
    2 IK = IK + I
      RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE CGMREV(A,B,NI,NJ)
      SUBROUTINE CGMREV(A,B,NI,NJ)
C
C *** CGMREV by PJB 14-Mar-96 ***
C
CX
CC 12C
CH Reverses the signs of the elements of an NI X NJ complex matrix.
CA On entry A is a complex matrix of dimension NIxNJ
CA On exit  B is a complex matrix holding -A
CN A and B may be the same matrix
C
      COMPLEX A(NI,NJ),B(NI,NJ)
      DO 1 I=1,NI
      DO 1 J=1,NJ
    1 B(I,J)=-A(I,J)
      RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE CGMSCA(A,B,SCALE,NI,NJ)
      SUBROUTINE CGMSCA(A,B,SCALE,NI,NJ)
C
C *** CGMSCA by PJB Apr 87 ***
C
CX
CC 12C
CH Multiplies every element of a COMPLEX matrix by a COMPLEX scale.
CA On entry, A holds a COMPLEX NI by NJ matrix
CA           SCALE holds a COMPLEX scalar scaling number
CA On exit,  B holds a COMPLEX NI by NJ matrix being A times SCALE
CN A may be the same as B
CN Note the existence of CMRSCA which works with a REAL scale
C
      COMPLEX A(1),B(1),SCALE
      NIJ=NI*NJ
      DO 1 I=1,NIJ
    1 B(I)=SCALE*A(I)
      RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE CGMSUB(A,B,C,NI,NJ)
      SUBROUTINE CGMSUB(A,B,C,NI,NJ)
C
C *** CGMSUB by PJB 20 Feb 91 ***
C
CX
CC 12C
CH Sets COMPLEX matrix C = COMPLEX matrix A - COMPLEX matrix B.
CA On entry A nnd B are NI by NJ COMPLEX matrices
CA On exit C is set to the difference of A and B
C
      COMPLEX A(NI,NJ),B(NI,NJ),C(NI,NJ)
      DO 1 I= 1,NI
      DO 1 J=1,NJ
   1  C(I,J) = A(I,J) - B(I,J)
      RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE CGMUNI(A,NI)
      SUBROUTINE CGMUNI(A,NI)
C
C *** CGMUNI modified by PJB c17 17 sept 93 ***
C
CX
CC 12C
CH Clears a COMPLEX square matrix to contain the unit matrix.
CA On exit A is an NIxNI unit matrix
CN NI must be at least 1
C
      COMPLEX A(NI,NI)
      DATA C0,C1/0.,1./
C
      DO 1 I=1,NI
      A(I,I)=CMPLX(C1,C0)
      I1=I+1
      IF (I1 .GT. NI) GO TO 100
      DO 1 J=I1,NI
      A(I,J)=CMPLX(C0,C0)
   1  A(J,I)=A(J,I)
 100  RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE CGMZER(A,NI,NJ)
      SUBROUTINE CGMZER(A,NI,NJ)
C
C *** CGMZER by JCM 23 Oct 87 ***
C
CX
CC 12C
CH Clears to zero a complex matrix.
CA On entry A is an NI by NJ COMPLEX matrix
CA On exit A is cleared to COMPLEX zero
C
      COMPLEX A(1)
      NIJ=NI*NJ
      DO 1 I=1,NIJ
   1  A(I)=CMPLX(0.,0.)
      RETURN
      END
C
C
C
C
C LEVEL 2      LOGICAL FUNCTION CHGPAR(A,B,N)
      LOGICAL FUNCTION CHGPAR(A,B,N)
C
C *** CHGPAR BY PJB  14-Mar-1997 ***
C
CC 11C
CH Indicates whether two real arrays are the same
CA On entry A and B are real arrays of length N
CA On exit CHGPAR is TRUE if they are different (i.e. CHanGed PARameters)
CA                   FALSE if same
C
      DIMENSION A(N),B(N)
      DO 1  I=1,N
      IF (ABS(A(I)-B(I)) .LT. 10.E-12) GO TO 1
      CHGPAR=.TRUE.
      GO TO 100
    1 CONTINUE
      CHGPAR=.FALSE.
  100 RETURN
      END
C
C
C
C
C LEVEL 14      SUBROUTINE CHICON(IAT,NFIX,NUMCON,NPAR,KKCON,AMCON,FIRST)
      SUBROUTINE CHICON(IAT,NFIX,NUMCON,NPAR,KKCON,AMCON,FIRST)
C
C *** CHICON Updated by PJB March 2011 C4.22 ***
CX
CC 17A
C
CH Determines constraints on an atom's susceptibility tensor
CA IATO is the number of the magnetic atom in question
CA LMFIX(I) is set to TRUE if parameter I for this atom is fixed by symmetry
CA FIRST is TRUE if no constraints have yet been found
C
C ***
      DIMENSION NFIX(6),NPAR(12),KKCON(6,12),AMCON(6,12)
      DIMENSION RR(6,12)
      CHARACTER*4 CNAMES(6),CSIGN*3
      LOGICAL FIRST
C
/ATNAM/
/IOUNIT/
/MAGCHI/
/POSNS/
/SCRACH/
C
      DATA CNAMES/'CH11','CH22','CH33','CH23','CH31','CH12'/


      IF (FIRST) WRITE (LPT,1000)
      FIRST=.FALSE.
 1000 FORMAT (/'Symmetry Constraints  on Susceptibility coefficients;')
C  WORK OVER ALL MAGNETIC ATOMS
      NUMCON=0
      LFIX=0
      IM=0
      DO 3 I = 2,3
C INVERSION MAKES NO DIFFERENCE
      IOP = IABS(ISGEN(I,iAT))
      IF (IOP.NE.0)  THEN
        CALL GMEQ(chisym(1,1,IOP),RR(1,IM+1),6,6)
        DO 4 J=1,6
        RR(J,IM+J)=RR(J,IM+J)-1.
    4   CONTINUE
        IM=IM+6
      ENDIF
    3 CONTINUE
C C4.22 Section changed to use RELSMO not RELSM6
      IF (IM.NE.0)  CALL RELSMO(RR,IM,LFIX,NFIX,NUMCON,NPAR,KKCON,AMCON)
C Report constraints
      IF ((NUMCON.EQ.0) .AND. (LFIX.EQ.0)) THEN
        WRITE (LPT,1001)  ATNAME(IAT)
 1001   FORMAT (A4,2X,'None')
      ELSE
        MESSAG(1:13)=ATNAME(IAT)//'         '
        IBUF=14
        DO 10 I=1,6
        IF (NFIX(I).NE.0) GO TO 10
          MESSAG(IBUF:)= CNAMES(I)//' = 0    '
          IBUF=IBUF+12;
   10   CONTINUE
        WRITE (LPT,1003) (MESSAG(I:I),I=1,IBUF-1)
 1003 FORMAT (100A1)
        DO 8 N=1,NUMCON
        MESSAG='     '
        IBUF=6
        DO 9 I=1,NPAR(N)
        K=KKCON(I,N)
        CSIGN=' +'
        IF (AMCON(I,N) .LT.0)CSIGN=' -'
        IF (I.EQ.1) THEN
          WRITE (MESSAG(IBUF:),1004) '  ',AMCON(I,N),CNAMES(K)
        ELSE
          WRITE (MESSAG(IBUF:),1004) CSIGN,ABS(AMCON(I,N)),CNAMES(K)
        ENDIF
 1004   FORMAT (A2,F6.3,A4)
        IBUF=IBUF+12
    9   CONTINUE
        MESSAG(IBUF:)=' = 0'
        IBUF=IBUF+4
        WRITE (LPT,1003) (MESSAG(I:I),I=1,IBUF)
    8   CONTINUE
      ENDIF
      WRITE (LPT,1004)
      RETURN
      END
C
C
C
C
C LEVEL 14      SUBROUTINE CHITRN
      SUBROUTINE CHITRN
C
C *** CHITRN rewritten for tensor structure factors C4.17 by PJB June 2009 ***
C
CX
CC 17B
CH Calculate transformed susceptibility for all operators
CH In orthogonal crystallographic coordinates
CO prints the coefficients if (OUTP & 512)
C
      DIMENSION OSYM(3,3),TEMPO(3,3),TEMP(3,3),IPTR(3,3)
      LOGICAL PRINT,BINDIG
/CELPAR/
/IOUNIT/
/MAGCHI/
/NSYM/
/SYMDA/
/SYMTAB/
      DATA IPTR/1,6,5,6,2,4,5,4,3/
C
C Diagnostic write
      PRINT=BINDIG(IOUT,512)
      IF (PRINT) write (lpt,1200)
 1200 format(/' Transformed susceptibility coefficients:')
      CALL GMEQ(ORTH(1,1,1),TEMPO,3,3)
      CALL TRANSQ(TEMPO,3)
      DO 11 NO = 1,NOPC
      CALL GMZER(CHISYM(1,1,NO),6,6)
C Put symmetry operator onto orthogonal cryst coordinates
      CALL GMPRD(SYM(1,1,NO),ORTH(1,1,2),TEMP,3,3,3)
      IF (NORD(NO).LT.0.) CALL GMREV(TEMP,TEMP,3,3)
      CALL GMPRD(TEMPO,TEMP,OSYM,3,3,3)
      DO 12 I=1,3
      DO 12 J=I,3
      IP=IPTR(I,J)
      DO 14 II=1,3
      DO 14 JJ=1,3
      CHISYM(IPTR(II,JJ),IP,NO)=CHISYM(IPTR(II,JJ),IP,
     &NO)+OSYM(I,II)*OSYM(J,JJ)
   14 CONTINUE
   12 CONTINUE
      IF (PRINT) THEN
      DO 13 I=1,6
        IF (I.EQ.4) THEN
          WRITE (LPT,1201) NO,(CHISYM(I,J,NO),J=1,6)
        ELSE
          if (I .lt.4) then
          WRITE (LPT,1202) (CHISYM(J,I,NO),J=1,6),(osym(i,j),j=1,3)
          else
          WRITE (LPT,1202) (CHISYM(J,I,NO),J=1,6)
          endif
        ENDIF
 1202 FORMAT (4X,6F8.4,2x,3f8.4)
 1201 FORMAT (1X,I3,6F8.4)
   13 CONTINUE
      WRITE (LPT,1201)
      ENDIF
   11 CONTINUE
      RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE CHOOSF(F,SF,ALPHA1,ALPHA,MODEF)
      SUBROUTINE CHOOSF(F,SF,ALPHA1,ALPHA,MODEF)
C
C *** CHOOSF by PJB ***
C
CX
CC 5C
CH Chooses modulus and phase for a particular Fourier.
C
CA On entry ALPHA1 is an original phase
CA          F is a 1x2 array of read coefficients
CA          MODEF is the type of Fourier:
CA            MODEF=1   FCAL
CA            MODEF=2   FOBS (Centrosymmetric)
CA            MODEF=3   mod(FOBS)*phase(FCAL)
CA            MODEF=4   FOBS-FCAL
CA            MODEF=5   (mod(FOBS)-mod(FCAL))*phase(FCAL)
CA            MODEF=6   FOBS*FOBS (Patterson)
CA On exit SF holds the modulus and ALPHA the required phase.
C
      DIMENSION F(2)
C
      ALPHA=ALPHA1
      GO TO (21,22,23,24,25,26),MODEF
C
  21  SF = ABS(F(1))
      GO TO 10
C
   22  SF = F(2)
      ALPHA = 0.
      GO TO 10
C
  23  SF = ABS(F(2))
      GO TO 10
C
  24  SF = F(2) -F(1)
      ALPHA = 0.
      GO TO 10
C
  25  SF = ABS(F(2)) - ABS(F(1))
      GO TO 10
C
  26  SF = F(2)*F(2)
      ALPHA = 0.
C
C SF AND ALPHA NOW SET UP:
C
   10 RETURN
      END
C
C
C
C
C LEVEL 6      SUBROUTINE CIRCLE(XX,YY,R,M)
      SUBROUTINE CIRCLE(XX,YY,R,M)
C
C *** CIRCLE by PJB 25 May 90 ***
C
CX
CC 14C
CH Draws a circle of given radius and centre, with various options.
CA On entry XX,YY give the centre of the circle in the current space.
CA          R is the required radius, in cms.
CA          M lists the required options:
CA If M=0 the circle is open
CA If M=+/- 1 a plus or minus is inscribed
CA If M>1 the circle is hatched at intervals of M*.25 mm.
C
      COMPLEX ARG,PHASE,POS
      DIMENSION A(2),PTS(2,12),FPTS(2,12),IPT(4)
/CONSTA/
/PLTRAN/
      EQUIVALENCE (A,POS),(A(1),X),(A(2),Y)
      DATA FPTS/3.5,1.,1.,1.,1.,3.5,-1.,3.5,-1.,1.,
     & -3.5,1.,-3.5,-1.,-1.,-1.,-1.,-3.5,1.,-3.5,1.,-1.,3.5,-1./
      DATA IPT/1,6,7,12/
      DATA GRID/.025/
C
C  SAVE CURRENT SPACE
      MSPCE=NSPCE
      CALL PLCONV(XX,YY,NSPCE,A1,B1,3)
      CALL SPCSET(3)
C
C  DRAW CIRCLE
      CALL KANGA1(A1+R,B1,3)
      PHASE=CMPLX(1.,0.)
      ARG=CEXP(CMPLX(0.,TWOPI/200.))
      DO 1 I=1,200
      PHASE=PHASE*ARG
      POS=PHASE*R
      CALL KANGA1(A1+X,B1+Y,2)
    1 CONTINUE
C
      IF (M.EQ.0) GO TO 101
      IF (IABS(M).EQ.1) THEN
C  SCALE SIGNS
        CALL GMSCA(FPTS,PTS,R*.2,2,12)
        CALL GMEQ(PTS(1,12),A,2,1)
        CALL KANGA1(A1+X,B1+Y,3)
        IF (M.LT.0) THEN
          NPTS=4
        ELSE
          NPTS=12
        ENDIF
        DO 2 I=1,NPTS
        J=I
        IF (M.LT.0) J=IPT(I)
        CALL GMEQ(PTS(1,J),A,2,1)
        CALL KANGA1(A1+X,B1+Y,2)
    2   CONTINUE
C
C  SHADE SIGN
        STEP=.05
        IF (M.GT.0) THEN
          CALL KANGA1(A1+PTS(1,5),B1+PTS(2,5),3)
          NW = IFIX((PTS(2,4)-PTS(2,5))/STEP)
          W=PTS(2,5)
          DO 20 IW=0,NW
          CALL KANGA1(A1+PTS(1,4),B1+W,2)
          CALL KANGA1(A1+PTS(1,3),B1+W,2)
          W=W+STEP
   20     CONTINUE
        ENDIF
        CALL KANGA1(A1+PTS(1,7),B1+PTS(2,7),3)
        NW = IFIX((PTS(2,6)-PTS(2,7))/STEP)
        W=PTS(2,7)
        DO 21 IW=0,NW
        CALL KANGA1(A1+PTS(1,7),B1+W,2)
        CALL KANGA1(A1+PTS(1,12),B1+W,2)
         W=W+STEP
   21   CONTINUE
        IF (M.GT.0) THEN
          CALL KANGA1(A1+PTS(1,9),B1+PTS(2,9),3)
          NW = IFIX((PTS(2,8)-PTS(2,9))/STEP)
          W=PTS(2,9)
          DO 22 IW=0,NW
          CALL KANGA1(A1+PTS(1,9),B1+W,2)
          CALL KANGA1(A1+PTS(1,10),B1+W,2)
          W=W+STEP
   22     CONTINUE
        ENDIF
      ELSE
        IF (M.LT.2) GO TO 101
      ENDIF
C
C  SHADE CIRCLES
      CALL KANGA1(A1+R,B1,3)
      STEP=GRID*FLOAT(M)
      NW=IFIX(2*R/STEP)
      W=-R
      DO 23 IW=0,NW
      V=(R*R-W*W)
      IF (V.LT.0) GO TO 23
      V=SQRT(V)
      CALL KANGA1(A1+W,B1-V,2)
      CALL KANGA1(A1+W,B1+V,2)
      W=W+STEP
   23 CONTINUE
C
C  RESTORE ORIGINAL SPACE
  101 CALL SPCSET(MSPCE)
      RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE CLOFIL(LUN)
      SUBROUTINE CLOFIL(LUN)
C
C *** CLOFIL by PJB Jan 86 ***
C
CX
CC 13C
CH Closes the FORTRAN unit LUN and returns the CCSL unit to the pool.
CA On entry LUN is the number of an existing FORTRAN unit, now finished with.
CP NOPFIL (or OPNFIL) should have set up LUN when the file was opened.
CD Closes LUN;  releases its table entries IOTAB in /LOONEY and FILNAM in
CD /FINAME.
CD
CD If LUN was not in such table entries, does nothing.
C
/FINAME/
/LOONEY/
C
      CLOSE (LUN)
%      DO 1 I=1,%FILE%
      IF (LUNTAB(I).NE.LUN) GO TO 1
      IOTAB(I)=0
      FILNAM(I)=' '
      GO TO 100
    1 CONTINUE
  100 RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE CMCONJ(A,B,I,J)
      SUBROUTINE CMCONJ(A,B,I,J)
C
C *** CMCONJ by PJB Nov 89 ***
C
CX
CC 12C
CH Gives the conjugate of a COMPLEX matrix.
CA On entry A is a complex I by J matrix
CA On exit the I by J complex matrix B contains conjugate complex of A
C
      COMPLEX A(I,J), B(I,J)
      DO 1 II=1,I
      DO 2 JJ=1,J
      B(II,JJ)=CONJG(A(II,JJ))
    2 CONTINUE
    1 CONTINUE
      RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE CMIMAG(A,B,I,J)
      SUBROUTINE CMIMAG(A,B,I,J)
C
C *** CMIMAG by PJB Nov 89 ***
C
CX
CC 12C
CH Gives the imaginary parts of a COMPLEX matrix.
CA On entry A is a complex I by J matrix
CA On exit the I by J real matrix B contains the imaginary parts of A
C
      COMPLEX A(I,J)
      DIMENSION B(I,J)
      DO 1 II=1,I
      DO 2 JJ=1,J
      B(II,JJ)=AIMAG(A(II,JJ))
    2 CONTINUE
    1 CONTINUE
      RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE CMREAL(A,B,I,J)
      SUBROUTINE CMREAL(A,B,I,J)
C
C *** CMREAL by PJB Nov 89 ***
C
CX
CC 12C
CH Gives the real parts of a COMPLEX matrix.
CA On entry A is a complex I by J matrix
CA On exit the I by J real matrix B contains the real parts of A
C
      COMPLEX A(I,J)
      DIMENSION B(I,J)
      DO 1 II=1,I
      DO 2 JJ=1,J
      B(II,JJ)=REAL(A(II,JJ))
    2 CONTINUE
    1 CONTINUE
      RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE CMRSCA(A,B,SCALE,NI,NJ)
      SUBROUTINE CMRSCA(A,B,SCALE,NI,NJ)
C
C *** CMRSCA by JCM 23 Aug 88 ***
C
CX
CC 12C
CH Multiplies every element of a COMPLEX matrix by a REAL scale.
CA On entry, A holds a COMPLEX NI by NJ matrix
CA           SCALE holds a REAL scalar scaling number
CA On exit,  B holds a COMPLEX NI by NJ matrix being A times SCALE
CN A may be the same as B
CN Note also the existence of CGMSCA which works entirely in COMPLEX.
C
      COMPLEX A(1),B(1)
      NIJ=NI*NJ
      DO 1 I=1,NIJ
    1 B(I)=SCALE*A(I)
      RETURN
      END
C
C
C
C
C LEVEL 1      FUNCTION CONATF(N,IA)
      FUNCTION CONATF(N,IA)
C
C *** CONATF by JCM 16 Nov 84 ***
C
CX
CC 4B
CH Produces for a single coefficient of an anisotropic temperature
CH factor, its conversion factor from the internally used betas, in
CH order to communicate with the user.
CA On entry IA says which ATF
CA           N says which of the coefficients, in the program's ordering
CA             11 22 33 23 13 12
CA On exit CONATF is the required muliplicative conversion factor.
CN It is inefficient, but not often used.
C
/ANISO/
/CELPAR/
/CONSTA/
C
      I=IATYP(IA)
      GO TO (2,2,3,4,5) , I
C BRANCH ON TYPE OF ATF GIVEN BY USER - THESE TYPES ARE AS IN MK2, BUT 1 WAS
C FOUND TO BE BAD AND WAS REMOVED.
C
C  TYPE 2 - AS IN HEWAT PROFILE REFINEMENT -  NO COSINES
   2  FAC=4.
      GO TO 30
C
C  TYPE 3 U'S AS IN EXP-2*PI*PI(ETC)
   3  FAC=1./(TWOPI*PI)
  30  GO TO (21,21,21,24,25,26) , N
  21  C=FAC/CPARS(N,2)
      GO TO 101
  24  C=FAC/(CELL(2,1,2)*CELL(3,1,2))
      GO TO 101
  25  C=FAC/(CELL(1,1,2)*CELL(3,1,2))
      GO TO 101
  26  C=FAC/(CELL(1,1,2)*CELL(2,1,2))
      GO TO 101
C
C
C  TYPE 4 - ONLY THE 2'S MISSING
   4  GO TO (41,41,41,42,42,42) , N
  41  C=1.0
      GO TO 101
  42  C=2.0
      GO TO 101
C
C
   5  C=1.
 101  CONATF=C
      RETURN
      END
C
C
C
C
C LEVEL 2      SUBROUTINE CONVMP(MODE)
      SUBROUTINE CONVMP(MODE)
C
C *** CONVMP updated by JCM 20 Apr 90 ***
C
CX
CC 7B
CH Converts between user values and LSQ parameters for multipoles.
CA On entry MODE = the action required:
CA MODE=1 convert user values in POLAMP(,1) to LSQ parameters in POLAMP(,2)
CA MODE=2 convert LSQ obtained ESD's to user EDS's, and
CA        convert LSQ shifts in POLAMP(,4) to user values in POLAMP(,3)
CP In /MPODA/ CONMAT must have been set up by ORTFUN
CP            POLAMP must contain the user values, read by ORTFUN
CP            KCLUMP must contain clump sizes set in ORTFUN
CP            NCLUMP must be number of clumps set in ORTFUN
C
/MPODA/
/MPODAC/
C
      DIMENSION TMP(13)
C
      IA=1
      ICMAT=1
C SCAN NCLUMP CLUMPS:
      DO 4 K=1,NCLUMP
      JJ=KCLUMP(K)
      IF (MODE .EQ. 1) THEN
        CALL GMPRD(CONMAT(ICMAT,2),POLAMP(IA,1),POLAMP(IA,2),JJ,JJ,1)
      ELSE
        CALL GMPRD(CONMAT(ICMAT,1),POLAMP(IA,4),POLAMP(IA,3),JJ,JJ,1)
C  PROCEDURE FOR ESD'S
        DO 2 I=1,JJ
        TMP(I)=0
        IJ=I-1
        DO 3 J=1,JJ
        TMP(I)=TMP(I)+(POLAMP(IA+J-1,6)*CONMAT(ICMAT+IJ,1))**2
        IJ=IJ+JJ
    3   CONTINUE
        POLAMP(IA+I-1,5)=SQRT(TMP(I))
    2   CONTINUE
      ENDIF
C
      IA=IA+KCLUMP(K)
      ICMAT=ICMAT+KCLUMP(K)*KCLUMP(K)
   4  CONTINUE
      RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE COSET(JEL,ICOSET,N,IFTAB,NGP)
      SUBROUTINE COSET(JEL,ICOSET,N,IFTAB,NGP)
C
C *** New by PJB 13 March 2006 ***
C
CX
CC 1A
CH Returns the coset in the full group generated by a given element of
CH one of its sub-grouo
CA On entry IFTAB contains the sub-group factorisation table of a group of
CA          order NGP
CH          JEL is the number of the element whose coset is required (it must
CA          be in the sub-group)
CA On exit ICOSET is a table containing the operator numbers of the N members of
CA          the coset
C
      DIMENSION ICOSET(*),IFTAB(NGP)
C
      N=0
      IEL=IFTAB(JEL)
      DO 1 I=1,NGP
      N=N+1
      IF (IFTAB(I).EQ.IEL) THEN
        ICOSET(N)=I
      ELSE IF (IFTAB(I).EQ. -IEL) THEN
        ICOSET(N)=-I
      ELSE
        N=N-1
      ENDIF
    1 CONTINUE
      RETURN
      END
C
C
C
C
C LEVEL 4      SUBROUTINE CPVCON(IATO,NPAR,FIRST,NFIX,FIX)
      SUBROUTINE CPVCON(IATO,NPAR,FIRST,NFIX,FIX)
C
C *** CPVCON new by PJB C4.26 March 2013 ***
C
CX
CC17A
CH Finds and reports the symmetry constraints on CPVEC magnetic parameters.
C
CD Determined the symmetry constraints on the complex fourier components
CD of the magnetisation distributiom for the INCM structure type.
CD and mposes these constraints on the magnetic parameters
CA IATO is the number of the magnetic atom in question
CA LMFIX(I) is set to TRUE if parameter I for this atom is fixed by symmetry
CA FIRST is TRUE if no constraints have yet been found
C
      LOGICAL FIRST,NONE
%      DIMENSION IATAB(%SYMO%),NFIX(NPAR),FIX(NPAR),FIDIF(NPAR,NPAR)
     &,RVAL(NPAR),TVEC(3),TTVEC(3),VEC(3)
      COMPLEX CVEC(3,2),CRVEC(3,2),CPHS
      CHARACTER*1 SYMB(3)
C
/ATNAM/
/CONSTA/
/IOUNIT/
/MAGDAT/
/NSYM/
/POSNS/
/SATELL/
/SCRACH/
/SYMDA/
/SYMMAG/
/SYMTAB/
C
      DATA SYMB/'X','Y','Z'/

      IAT=JMAGAT(IATO)
      IPOF=6
C Full factorisation of the atom group
      CALL MAKGRP(ISGEN(1,IAT),IATAB,0,DUMMY)
      CALL FACGRP(IATAB,IATAB,NFAC)
C4.1 FCENT true when structure centric, and magnetic groups are  not
      FCENT(IATO)=(CENTRC .AND. (MSTAB(NOPC+1) .EQ.0)
     & .AND.(ISGEN(1,IAT).GT.0))
C  CHECK THAT STRUCTURE AND SYMMETRY ARE COMPATIBLE WITH THE
C  PROPAGATION VECTOR
      DO 28 N=2,NOPC
      IF (IABS(KSTAB(N)).NE.1 .AND. IATAB(N).EQ.0) THEN
        WRITE (ITO,2800) N
        WRITE (LPT,2800) N
 2800   FORMAT (/' ERROR ** Structure symmetry is reduced by ',
     &   'that of the propagation vector (operator #',I2,').'/
     &  ' **** Change S cards ****')
        STOP
      ENDIF
   28 CONTINUE
      N1=0
      IF (FIRST) CALL MESS(LPT,1,
     & 'Symmetry constraints on magnetic moments:')
      FIRST=.FALSE.
      WRITE (ICARD,2001) ATNAME(IAT)
2001  FORMAT (1X,A4,' None')
      DO 29 N=1,NPAR
  29  NFIX(N)=9999
C
      IF (ISGEN(1,IAT).EQ.1) GO TO 17
C begin loop over generators
      DO 9 IGEN=2,ISGEN(1,IAT)
      IOP=ISGEN(IGEN,IAT)
      IO=IABS(IOP)
C  JUMP IF NOT SPECIAL
      NONE = IOP.EQ.1
      IF (NONE) GO TO 17
      CALL GMEQ(X(1,IAT),TTVEC,3,1)
C Use the inverse operation to transform fourier components
      CALL ROTSYM(TTVEC,TVEC,IO,2)
C Reverse translation for inverse
      CALL GMSUB(TVEC,TRANS(1,IO),TVEC,3,1)
C IF spin does not transform into itself WHAT LATTICE VECTOR separates them
      IF (IOP.LT.0) CALL GMREV(TVEC,TVEC,1,3)
      CALL GMSUB(TVEC,X(1,IAT),VEC,3,1)
C  GIVES A PHASE SHIFT
      PH=TWOPI*SCALPR(PROP,VEC)
C      write (lpt,5002) iat,iop,(X(i,IAT),i=1,3),tvec,vec
C 5002 format ('CPVCON',2i4,3(3f6.2,2x))
C Now operate with the element
C Loop over reps
      NN=1
      DO 1 NR=1,2
      DO 2 I=1,3
      CALL CGMZER(CVEC,3,2)
      CVEC(I,NR)=CMPLX(1.,0)
      CALL ROTCMG(CVEC,CRVEC,IOP)
      CPHS=CEXP(CMPLX(0.,-PHIK(IO)))
      IF (IOP.LT.0) CPHS=CONJG(CPHS)
      CALL CGMSCA(CRVEC,CRVEC,CPHS,3,2)
      MM=1
      DO 3 MR=1,2
C Loop over components
      DO 4 J=1,3
      MM = 3*(MR-1)+J
      IF (NN .GT.MM) GO TO 4
C Convert to amp phase format For amplitudes and phases
      if (abs(crvec(j,mr)) .lt. .0001) go to 4
      RPHASE=ATAN2(AIMAG(CRVEC(J,MR)),REAL(CRVEC(J,MR)))
      RFIX=1.
      NONE=.FALSE.
      FIDIF(MM,NN)=RPHASE+PH
      FIDIF(MM,NN)=RANGER(FIDIF(MM,NN),PI,-PI)
      IF (NN.EQ.MM) THEN
        RVAL(NN)=RFIX
C If iop positive (no conjugation)  moment is fixed to zero
        IF (ABS(RFIX-1.).GT.0.0001 .OR. IOP .GT.0) THEN
           CALL FIXPAR(NN,NFIX)
        ELSE
           CALL FIXPAR(NN+IPOF,NFIX)
        ENDIF
      ELSE
        CALL RELPAR(NN,1.,MM,RFIX,NFIX,FIX)
        AA=SIGN(1.,FLOAT(IOP))
        CALL RELPAR(NN+IPOF,1.,MM+IPOF,AA,NFIX,FIX)
      ENDIF
    4 CONTINUE
    3 CONTINUE
      NN=NN+1
    2 CONTINUE
    1 CONTINUE
      IF  (NONE) THEN
        CALL MESS(LPT,0,ICARD)
        GO TO 17
      ENDIF
    9 CONTINUE
C Put in the appropriate values
C Loop over reps
      NN=0
      DO 5 NR=1,2
C Loop over components
      DO 6 I=1,3
      NN=NN+1
      IF (NFIX(NN) .EQ.9999) GO TO 7
      IF (NFIX(NN) .EQ.0) THEN
        RVEC(I,NR,IATO)=0.
        WRITE (ICARD(6:),2002) NR,SYMB(I)
 2002   FORMAT ('Rep',I2,'  Amplitude of',1X,A1,' Component = 0')
        CALL MESS(LPT,0,ICARD)
      ENDIF
    7 IF (NFIX(NN+IPOF) .EQ.9999) GO TO 8
      IF (NFIX(NN+IPOF) .EQ.0) THEN
        AMP=CABS(RVEC(I,NR,IATO))
        PHDAT=ATAN2(AIMAG(RVEC(I,NR,IATO)),REAL(RVEC(I,NR,IATO)))
C Two posssible solutions
        PHI=RANGER(FIDIF(NN,NN)/2.,PI,-PI)
        PHI1=RANGER(PHI+PI,PI,-PI)
Choose the one nearest to the given value
        IF (ABS(PHDAT-PHI) .GT. ABS(PHDAT-PHI1)) PHI=PHI1
        RVEC(I,NR,IATO)=AMP*CEXP(CMPLX(0.,PHI))
C        WRITE (LPT,5001) 'SETTING RVEC ',I,NR,IATO,RVEC(I,NR,IATO)
C     &,AMP,FIDIF(NN,MM),PHI,PHI1,PHDAT
C 5001 FORMAT (A16,3I4,2F8.3,2X,28F8.3)
        WRITE (ICARD(6:),2003)NR,SYMB(I),DEGREE(FIDIF(NN,NN)/2.)
 2003   FORMAT ('Rep',I2,'  Phase of',5X,A1,' Component =',F8.2)
        CALL MESS(LPT,0,ICARD)
        GO TO 8
      ENDIF
C related parameters
C first amplitudes
      MM= NFIX(NN)
      DO 21 IAP=1,2
      IF (IAP.EQ.2) MM=NFIX(NN+IPOF)-IPOF
      IF (MM.EQ.0 .OR. MM.LT.NN) GO TO 21
      MR=1+(MM-1)/3
      J=MOD(MM-1,3) +1
      IF (IAP .EQ.1) THEN
        AMP=FIX(MM)*CABS(RVEC(I,NR,IATO))/CABS(RVEC(J,MR,IATO))
        RVEC(J,MR,IATO)= AMP*RVEC(I,MR,IATO)
        WRITE (ICARD(6:),2004) MR,SYMB(I),FIX(MM),NR,SYMB(J)
      ELSE
        AMP=CABS(RVEC(J,MR,IATO))
        PHASE=ATAN2(AIMAG(RVEC(I,NR,IATO)),REAL(RVEC(I,NR,IATO)))
        WRITE (ICARD(6:),2005) MR,SYMB(I),DEGREE(FIDIF(MM,NN)),
     &  NR,SYMB(J)
        PHASE=PHASE+FIDIF(MM,NN)
        RVEC(J,MR,IATO)=AMP*CEXP(CMPLX(0,PHASE))
      ENDIF
      CALL MESS(LPT,0,ICARD)
 2004   format ('Rep',i2,'  Amplitude of ',A1,' component =',f8.4,
     &  ' x Rep',i2,'  Amplitude of ',a1,' component')
 2005   format ('Rep',i2,'  Phase of     ',a1,' component =',f8.2,
     &  ' + Rep',i2,'  Phase of     ',a1,' component',f8.2)
   21 CONTINUE
    8 CONTINUE
    6 CONTINUE
    5 CONTINUE
   17  IF  (NONE)  CALL MESS(LPT,0,ICARD)
      WRITE (LPT,2006)
 2006 FORMAT (' ')
      RETURN
      END
C
C
C
C
C LEVEL 14      SUBROUTINE CPVESD
      SUBROUTINE CPVESD
C
C *** CPVESD new by PJB C4.26 March 2013 ***
C
CX
CC 17B
C
CH Calculates ESD's of complex vectors from those in the AMP PHASE
CH representation
CD Called after a least squares cycle (typically the last one.)
C
      DIMENSION DRVEC(2)
      CHARACTER*80 BUF
/ATNAM/
/IOUNIT/
/MAGDAT/

C First the order parameters
      WRITE (LPT,1006) (IR,SPORD(IR),IR=1,2)
 1006 format (/'Refined parameters'/'Complex order parameters'
     &/2(I4,' =',2F8.3,2X))
      IBUF=1
      DO 1 IREP=1,2
      ESDA=ESDFOR(KSPORD(IREP,1))
      ESDP=ESDFOR(KSPORD(IREP,2))
      IF (ESDA+ESDP.EQ.0) THEN
        WRITE (BUF(IBUF:),1008)
 1008  FORMAT (24X)
       IBUF=IBUF+24
        GO TO 1
      ENDIF
      DAMPR=ESDA/CABS(SPORD(IREP))
      DRVEC(1)=SQRT((REAL(SPORD(IREP))*DAMPR)**2
     &+ (AIMAG(SPORD(IREP))*ESDP)**2)
      DRVEC(2)=SQRT((AIMAG(SPORD(IREP))*DAMPR)**2
     &+ (REAL(SPORD(IREP))*ESDP)**2)
      WRITE (BUF(IBUF:),1007 ) DRVEC
 1007 FORMAT (' ESD =',2F8.3,2X)
      IBUF=IBUF+24
    1 CONTINUE
      IF (IBUF .GT.1) WRITE (LPT,1001) (BUF(I:I),I=1,IBUF)
 1001 FORMAT (80A1)
 1002 format ('Atom     Rep                Moment  Vector'/
     &16X,'    X                 Y                 Z')
      WRITE (LPT,1002)
C 5001 FORMAT (I3,'KRVEC ',12I4)
      DO 2 IM=1,NMAG
C      WRITE (ITO,5001) IM,(((KRVEC(J,I,IR,IM),J=1,3),I=1,2),IR=1,2)
      DO 2 IREP=1,2
      WRITE (BUF,1004)
 1004 FORMAT (5X,'ESD ')
      IBUF=10
      DO 3 I=1,3
      ESDA=ESDFOR(KRVEC(I,IREP,1,IM))
      ESDP=ESDFOR(KRVEC(I,IREP,2,IM))
 1005 FORMAT (40X)
      IF (ESDA+ESDP.EQ.0) THEN
        WRITE (BUF(IBUF:),1005)
        IBUF=IBUF+16
        GO TO 3
      ENDIF
      DAMPR=ESDA/CABS(RVEC(I,IREP,IM))
      DRVEC(1)=SQRT((REAL(RVEC(I,IREP,IM))*DAMPR)**2
     &+ (AIMAG(RVEC(I,IREP,IM))*ESDP)**2)
      DRVEC(2)=SQRT((AIMAG(RVEC(I,IREP,IM))*DAMPR)**2
     &+ (REAL(RVEC(I,IREP,IM))*ESDP)**2)
      WRITE (BUF(IBUF:),1003) DRVEC
      IBUF=IBUF+18
 1003 FORMAT (2X,2F8.3)
    3 CONTINUE
 1000 FORMAT (A4,' RVEC',I2,3(2F8.3,2X))
      WRITE (LPT,1000) ATNAME(JMAGAT(IM)),IREP,(RVEC(I,IREP,IM),
     &I=1,3)
      WRITE (LPT,1001) (BUF(I:I),I=1,IBUF)
    2 CONTINUE
      RETURN
      END
C
C
C
C
C LEVEL 8      SUBROUTINE CPVMUS(MODE)
      SUBROUTINE CPVMUS(MODE)
C
C *** CPVMUS new by PJB C4.26 March 2013 ***
CX
CC 17B
C
CH Calculates atomic magnetic moments from complex fourier components
C
CD Calculates and prints the atomic magnetic moments at each site
CD in two unit cells from the complex fourier coefficients fo the
CD INCM structure type.
CA MODE = 1 Prints components of moments at each site
CA MODE = 2 Prints the amplitide and phase of the components at each site.
CA MODE = 3 Prints both

      COMPLEX CVEC(3),TVEC(3,2),TCVEC(3,2),SVEC(3)
      DIMENSION PVEC(3),PPVEC(3),RRS(3),RRL(3,24),TRAN(3),RRP(3)
/ATNAM/
/CONSTA/
/IOUNIT/
/MAGDAT/
/NSYM/
/POSNS/
/SATELL/
/SYMDA/
/SYMMAG/
C
      ISTART=1
      IEND=2
      if (MODE .EQ.1) IEND=1
      IF (MODE .EQ.2) ISTART=2
      do 7 iou=istart,iend
C      write (lpt,1000)
 1000 format (//'Magnetic moments of atoms in the origin cell'/
     &'Atom  Op',9x,'Position'21x,'Moment'/12x,'x',7x,
     &'y',7x,'z',9x,'Mx',6x,'My',6x,'Mz'7x,'|M|')
C 1001 format (//'Magnetic moments of atoms in the origin cell'/
C     &'Atom  Op',9x,'Position',30x,'Amplitude and Phase'/12x,'x',7x,
C     &'y',7x,'z',13x,'Mx',14x,'My',14x,'Mz'10x,'|M|')
 1002 format (//'Magnetic moments of atoms in the origin cell'/
     &'Atom  Op',9x,'Position',18x,'Moments Orientation and Phase'
     &/12x,'x',7x,'y',7x,'z',8x,'Mu',5x,'Phi',6x,'Mu1',5x,'Psi',4x,
     &'Psiz',6x,'|M|')
      IF (IOU.EQ.1) WRITE (LPT,1000)
      IF (IOU.EQ.2) WRITE (LPT,1002)
C CYCLE OVER MAGNETIC ATOMS:
      DO 1 IM=1,NMAG
      IR=JMAGAT(IM)
      do 20 iz=0,1
      npos=0
      DO 2 IS=1,NOPC
Cycle over centre
      DO 3 IC=1,-1,-2
      ISS=IS*IC
C  ONLY USE OPERATORS WHICH LEAVE THE PROPAGATION DIRECTION INVARIANT
      IF (IS.NE.1 .AND.IABS(KSTAB(IS)).NE.1) GO TO 2
C Inverse symmetry operation on position vector
      CALL GMEQ(X(1,IR),PPVEC,3,1)
      IF (IC.LT.0) CALL GMREV(PPVEC,PPVEC,3,1)
      CALL ROTSYM(PPVEC,PVEC,IS,1)
      CALL GMSUB(PVEC,TRANS(1,IS),PVEC,3,1)
C  SYMMETRY operation on spin vector
      CALL ROTCMG(RVEC(1,1,IM),TVEC,ISS)
C multiply by the order parameters
      CALL CGMSCA(TVEC(1,1),TCVEC(1,1),SPORD(1),3,1)
      CALL CGMSCA(TVEC(1,2),TCVEC(1,2),SPORD(2),3,1)
      CALL CGMADD(TCVEC(1,1),TCVEC(1,2),CVEC,3,1)
C Put strictly into origin cell
      CALL INCELL(PVEC,RRS,TRAN)
C check not found before
      IF (NPOS .EQ. 0) THEN
      CALL GMZER (RRL,3,24)
        CALL GMEQ(RRS,RRL,3,1)
        NPOS=1
      ELSE
        CALL EQVEC(RRL,RRS,NPOS,NP,24)
        IF (NP.LE.NPOS) GO TO 3
        NPOS=NP
      ENDIF
      PHASE =-TWOPI*SCALPR(PROP,TRAN)
      PHASE=PHASE+(TWOPI*PROP(3)*FLOAT(IZ))
      CALL CGMSCA(CVEC,SVEC,CEXP(CMPLX(0.,PHASE)),3,1)
      CALL GMEQ(RRS,RRP,3,1)
      RRP(3)=RRP(3)+FLOAT(IZ)
C Get moments
      AMU=0.
      DO 4 I=1,3
C Don't need factor of 2 (rvec is spin?)
      AMU=AMU+(REAL(SVEC(I)))**2
      IF (I.EQ.2) AMU0=SQRT(AMU)
    4 CONTINUE
      AMU=SQRT(AMU)
      PSI=ATAN2(AIMAG(SVEC(1)),REAL(SVEC(1)))
      AMU1=REAL(SVEC(2))
      PHI=ATAN2(CABS(SVEC(2)),CABS(SVEC(1)))
      PSIZ=ATAN2(AIMAG(SVEC(3)),REAL(SVEC(3)))
    8 IF (PSIZ .LT. -0.00001) THEN
        PSIZ=PSIZ+PI
        AMU1=-AMU1
        GO TO 8
      ENDIF
      IF (IOU.EQ.1)WRITE (LPT,5006) ATNAME(IR),ISS,
     &RRP,(REAL(SVEC(I)),I=1,3),AMU
      IF (IOU.EQ.2) WRITE (LPT,5008) ATNAME(IR),ISS,RRP,
     &AMU0,DEGREE(PHI),AMU1,DEGREE(PSI),
     &DEGREE(PSIZ),AMU
 5006 FORMAT (A4,I3,2(1X,3F8.4,1X),F8.4,2F8.2)
 5008 FORMAT (A4,I3,1X,3F8.4,1X,2(F8.3,F8.2),F8.2,2X,F8.4)
    3 CONTINUE
    2 CONTINUE
   20 CONTINUE
      WRITE (LPT,5008)
    1 CONTINUE
      WRITE (LPT,5008)
    7 CONTINUE
      RETURN
      END

C
C
C
C
C LEVEL 10      SUBROUTINE CPVSYM(KITAB)
      SUBROUTINE CPVSYM(KITAB)
C
C *** CPVSYM new by PJB C4.26 March 2013 ***
C
CX
CC 17A
C
CH Symmetry operations on Fourier components of magnetisation for a given
CH propagation vector
C
CD Called by PROPER for INCM structure type to determines the symmetry
CD operations on the order parameters for a given propagation vector (k) and
CD space group given in SYMDA.
CP SYMOP, DOMAG1 and PROPER must have set up SYMDA, SYMMAG and SATELL
CA KITAB defines the star of K treating vectors relatied by a lattice
CA vector as distict
      DIMENSION KITAB(*),KFTAB(49),AX(3,1),RAX(3)
/CONSTA/
/IOUNIT/
/NSYM/
/SATELL/
/SYMDA/
/SYMMAG/
      IAX=0
      IPP=0
      CALL GMZER(PHIK,NOPC,1)
C Find the operators for which prop is absolutely invariant
      DO 1 IO=2,NOPC
      IF (IAX .EQ.0 .AND. KITAB(IO).EQ.1) IAX=IO
      IF (KITAB(IO) .GT.IPP) THEN
        IPP=KITAB(IO)
        KITAB(IO)=1
      ELSE
        KITAB(IO)=0
      ENDIF
    1 CONTINUE
      CALL=AXIS(SYM(1,1,IAX),AX)
C factorise the non-centro subgroup with respect to this element
      KITAB(NOPC+1)=0
      CALL FACGRP(KITAB,KFTAB,NFAC)
      CALL GMZER(SIGMAT(1,1,1),4,NOPC+1)
      DO 5 IO=1,NOPC
      CALL ROTSYM(PROP, RAX,IO,2)
      CALL EQVEC(PROP,RAX,1,N,0)
      IF (KFTAB(IO) .EQ. 1) THEN
        IF (N.EQ.1) THEN
          CALL GMUNI(SIGMAT(1,1,IO),2,2)
        ELSE
          SIGMAT(2,1,IO)=1.
          SIGMAT(1,2,IO)=1.
        ENDIF
      ELSE
C Here for coset element , is there a phase shift?
      PHIK(IO)=-TWOPI*SCALPR(PROP,TRANS(1,IO))
       IF (N.EQ.1) THEN
          SIGMAT(2,1,IO)=1.
          SIGMAT(1,2,IO)=-1.
        ELSE
          SIGMAT(1,1,IO)=1.
          SIGMAT(2,2,IO)=-1.
        ENDIF
      ENDIF
    5 CONTINUE
      SIGMAT(1,2,NOPC+1)=1.
      SIGMAT(2,1,NOPC+1)=1.
      RETURN
      END

C
C
C
C
C LEVEL 1      SUBROUTINE CRMPRD(A,B,C,I,J,K)
      SUBROUTINE CRMPRD(A,B,C,I,J,K)
C
C *** CRMPRD by PJB Nov 89 ***
C
CX
CC 12C
CH Performs COMPLEX by REAL matrix multiplication.
CA On entry A (of dimensions IxJ) is a COMPLEX matrix
CA          B (of dimensions JxK) is a REAL matrix
CA On exit  C (of dimensions IxK and COMPLEX) is the product of A and B.
CN C is unchanged if any of I,J or K is zero.
CN Note also the existence of SUBROUTINE RCMPRD which multiplies them
CN the other way round.
C
      DIMENSION B(1)
      COMPLEX A(1),C(1)
      DO 2 II = 1,I
      IK = II
      JK = 1
      DO 2 KK = 1,K
      IJ = II
      C(IK) = 0.
      DO 1 JJ = 1,J
      C(IK) = C(IK) + A(IJ)*B(JK)
      IJ = IJ + I
    1 JK = JK + 1
    2 IK = IK + I
      RETURN
      END
C
C
C
C
C LEVEL 1      COMPLEX FUNCTION CRSCLP(A,B)
      COMPLEX FUNCTION CRSCLP(A,B)
C
C *** CRSCLP by PJB Nov 89 ***
C
CX
CC 12C
CH Finds the COMPLEX scalar product of a COMPLEX with a REAL vector.
CA On entry A is a complex vector of dimension 3
CA          B is a real vector of dimension 3 in a space orthogonal to
CA            that of A
CD On exit the function value is the scalar product of A and B
C
      COMPLEX A(3),C
      DIMENSION  B(3)
      C=CMPLX(0.,0.)
      DO 1 I=1,3
      C=C+A(I)*B(I)
    1 CONTINUE
      CRSCLP=C
      RETURN
      END
C
C
C
C
C LEVEL 8      SUBROUTINE CVPARS(IP,MWORDS,MSPEC)
      SUBROUTINE CVPARS(IP,MWORDS,MSPEC)
C
C *** CVPARS New by PJB Sept 2012 ***
C
CX
CC 17A
CH Makes vocabulary for magnetic parameters for the INCM structure type
CD Creates the names for magnetic parameters for INCM structues and assigns
CD Their family genus and species.
CA ISCP is a logical set by the subroutine to false if not INCM structure type
CA MWORDS and MSPEC are returned if ISCP is true.
CN Magnetic parameters start at 13 POSITION 28 IN F2NAMES. Their IDs increase
CN in the order amplitude (x,y,z) for each rep, then phase((x,y,z) for each rep,
CN Magnetic blanket parameters start at -8
CN CPVEC MWORDS are: OPnA OPnP for the order parameters n is the rep number
CN                       MdNA and MdNP where d=X,Y,Z for the components.
CN                       A and P indicate amplitude or phase.
C
      CHARACTER *4 GROUPS(6),MWORDS(*)
      DIMENSION NUMS(3,6),MSPEC(3,22)
      CHARACTER *1 LET(2),DIR(3)
/SATELL/
/SYMMAG/
      DATA LET,DIR/'A','P','X','Y','Z'/
      DATA GROUPS /'ORDP','MVEC','REP1','REP2','MAMP','MPHS'/
      DATA NUMS /-8,0,0, -9,0,0, -10,0,0, -11,0,0, -12,0,0, -13,0,0/
C
      IP=0
      IF (.NOT. CPVEC) RETURN
      IP=1
      JP=10
C First the order parameters
      DO 1 IR=1,2
      DO 2 N=1,2
      WRITE (MWORDS(IP),10) N,LET(IR)
   10 FORMAT ('OP',I1,A1)
      MSPEC(1,IP)=1
      MSPEC(2,IP)=1
      MSPEC(3,IP)=JP
      IP=IP+1
      JP=JP+1
    2 CONTINUE
    1 CONTINUE
C Then the moment vectors
      JP=13
      DO 4 IR=1,2
      DO 5 N=1,2
      DO 3 J=1,3
      WRITE (MWORDS(IP),11) N,DIR(J),LET(IR)
   11 FORMAT ('M',I1,2A1)
      MSPEC(1,IP)=2
      MSPEC(2,IP)=0
      MSPEC(3,IP)=JP
      IP=IP+1
      JP=JP+1
    3 CONTINUE
    5 CONTINUE
    4 CONTINUE
      CALL JGMEQ(NUMS,MSPEC(1,IP),3,6)
      DO 6 I=1,6
      MWORDS(IP)=GROUPS(I)
      IP=IP+1
    6 CONTINUE
C
      RETURN
      END
C
C
C
C
C LEVEL 4      SUBROUTINE DATASF(NTRUE,LMODE)
      SUBROUTINE DATASF(NTRUE,LMODE)
C
C *** DATASF updated by PJB for new REFI types C4.27 April 2013 ***
CX
CC 6B
CH To get the data files and data for structure factor lsq
C
C4.22 New common DSRCNM contains thenames and identifiers of the data files
CA LMODE contains the NTRUE allowed MODER Values for the current application
CN NMODES to be set to the number of data types defined (currently 12)
CN HMASK is a list of 6 logicals indicating which header data are required
CN Initiially all set to TRUE
CN  HMASK(1) Polarisation           HMASK(2) Wavelength
CN  HMASK(3) Absorption coeff.      HMASK(4) Umatrix
CN  HMASK(5) Not used yet           HMASK(6) Not Used yet

      DIMENSION A(3),LMODE(NTRUE),IPSAV(6)
      CHARACTER *100 NAME,VFMT
      CHARACTER *24 HEAD(2)
C4.22 Logical ONLCARD says whether data L DATA cards were read
      LOGICAL  MODES(12),SINGLE,ASUSET,ONLCRD,POL
      COMMON /SFHEDC/FRMATS(6),HEDWDS(6)
      CHARACTER * 50 FRMATS,HEDWDS*4
/SFHEDP/
/DSOURC/
/DSRCNM/
/EXTN/
/IOUNIT/
/REFINE/
/SCLDAT/
/SCRACH/
/SYMMAG/
/WHEN/
      DATA HEAD/'Measurement set number: ',' Observations read from '/
      DATA NMODES,ASUSET/12,.FALSE./
C
      NOBS=0
      LAST=0
C4.22  Were the data files specified on L cards?
      ONLCRD = (NUMSRC.ne.0)
C SET THE MASK OF ALLOWED MODES
      DO 1 L=1,NMODES
    1 MODES(L)=.FALSE.
      DO 3 L=1,NTRUE
    3 MODES(LMODE(L))=.TRUE.
C Save the scale pointers deduced from L CARDS
%      IF (ONLCRD)   call jgmeq(ipscal,ipsav,%DSRC%,1)
%      CALL JGMZER(IPSCAL,%DSRC%,1)
C4.22  If the sourcenames were on L Cards
      JSRC=0
      NUMSCL=0
    2 IF (ONLCRD) THEN
        JSRC=JSRC+1
        IF (JSRC.GT.NUMSRC) GO TO 100
        MODER=MSRC(1,JSRC)
        IREF=MSRC(2,JSRC)
        LEN=LENGT(DNAME(JSRC))
        NAME=DNAME(JSRC)
      ELSE
C OPEN FILES FROM WHICH TO READ DATA:
        CALL ASK ('Name of data set, its MODE, REFI and weight? ')
        CALL RDWORD(NAME,LEN,1,IPT,80,-1,JER)
        IF (JER.EQ.100) GO TO 100
C If just data set name given assume single source refinement
        SINGLE =(NUMSRC.EQ.0 .AND.LENGT(ICARD).LE.IPT)
        IF (.NOT.SINGLE) THEN
          CALL RDNUMS(A,IPT,3,NUM,JER)
          SINGLE =(NUMSRC.EQ.0 .AND.NUM.EQ.0)
          IF (.NOT.SINGLE) THEN
            IF (JER.NE.0 .OR. NUM .NE.3) GO TO 2
C Allow MODES with Fsqrd  data
            MODOBS=NINT(A(1)/100.)
            MODER=MOD(NINT(A(1)),100)
            IREF=NINT(A(2))
          ENDIF
        ENDIF
%        CALL ERRCHK(2,NUMSRC,%DSRC%,0,'Data sets')
        JSRC=NUMSRC
        IF (SINGLE) THEN
          SRCWT(JSRC)=1.
        ELSE
          SRCWT(JSRC)=A(3)
        ENDIF
      ENDIF
C MUST HAVE MODE 11 DATA FOR POWDER REFINEMENTS
      MODES(11)=(MODES(11) .AND.(IREF.EQ.9 .OR. IREF.EQ. 10))
      MESSAG=NAME(1:LEN)
C CHECK COMPATIBLE MODER
      IF (MODER .NE. 0 .AND. .NOT. MODES(MODER))
     &CALL ERRIN2(MODER,1,'MODER',' not allowed for '//MAIN)
C Open the reflection data file
      LUNI=NOPFIL(21)
C USE COMMON INTERFACE TO READ DATA; STORE IT
      IF ((IREF.EQ.9 .OR. IREF.eq.10).AND. .NOT.ASUSET) THEN
        CALL SYMUNI
C This is so multiplicities can be calculated for powder intensities
        asuset=.true.
      endif
C SET THE HEADER MASK
      POL=IREF.EQ.5 .OR. IREF .EQ. 7 .OR.
     &(IREF.GE. 9 .AND. IREF .LE. 11)
      HMASK(1)=.NOT. POL
C NEED WAVELENGTH FOR POWDER INTENSITIES IF 2theta not read
      HMASK(2)=(.NOT.(IREF .EQ.9 .AND. MODER .NE. 11))
      IF (IEXTYP .NE.0) THEN
C4.22 For MODE 12 read wavelength with reflection
        IF (MODER.NE.12) HMASK(2)=.FALSE.
        HMASK(3)=.NOT. PATHS
        HMASK(4)=HMASK(4).AND. (.NOT. PATHS)
      ENDIF
C      WRITE (ITO,2000) NAME,NHEAD,(LHEAD(I),I=1,NHEAD)
C 2000 FORMAT (A10,10I4)
      CALL REPREF(IREF)
C Don't need polarisation direction for powder
      IF (PARA .AND. (IREF .EQ.9 .OR. IREF.eq.10)) LHEAD(1)=4
      CALL REFHDR
C Set POLND for para even if not polarised
C4.19 indices corrected
      IF (PARA .AND. (IREF .LT.5 .OR. IREF .EQ.6)) THEN
        SRCPAR(3,JSRC)=SRCPAR(11,JSRC)
        SRCPAR(4,JSRC)=SRCPAR(14,JSRC)
        SRCPAR(5,JSRC)=SRCPAR(17,JSRC)
      ENDIF
C4.22 RREFSF is now the unique SF least squares data reading routine
      CALL RREFSF
      write (VFMT,1011) LEN
 1011 FORMAT ('(1X,A24,i2, i5,A24,A',I2,','' Weight'',F6.3/)')
      WRITE (LPT,VFMT) HEAD(1),JSRC,NOBSRC(JSRC),HEAD(2),NAME,
     &SRCWT(JSRC)
      CALL CLOFIL(LUNI)
      if (onlcrd) then
C Dont need scale factors if IREF=8
        IF (IREF.NE. 8) THEN
C4.22 Chack here not in INPLSF
C CHECK THAT ENOUGH SCALES HAVE BEEN READ
          numreg=ipscal(jsrc)-last
          if (ipscal(jsrc) .gt. ipsav(jsrc) ) CALL ERRIN2(NUMREG,1,
     &    'Not the rignt number of scale factors for '
     &    //DNAME(JSRC),' needed')
          WRITE (LPT,3007)  ('SC',I-IPSCAL(JSRC)+numreg,SCALE(I),
     & I=IPSCAL(JSRC)-numREG+1,IPSCAL(JSRC))
 3007     FORMAT (' Scale Factors:     ',4(2x,A2,i2.2,F8.3)/
     &    (20x,4(2x,A2,i2.2,F8.3)) )
        ENDIF
      ENDIF
      last=ipscal(jsrc)
      IF (.NOT. SINGLE) GO TO 2
  100 RETURN
C
      END
C
C
C
C
      BLOCK DATA SFDHED
C Default data headers for DATASF
      COMMON /SFHEDC/FRMATS(6),HEDWDS(6)
      CHARACTER * 50 FRMATS,HEDWDS*4
/SFHEDP/
      DATA FRMATS/'(''Polarisation  '',2F8.4,'' parallel to'',3F8.4)',
     & '(''Wavelength    '',F8.4,4(4x,a12,f8.4)) '
     &,'(''Absorp. Coeff.'',f8.4)',
     &'(''U Matrix:     '',3F8.4,2(/14x,3f8.4))',
     &'',''/
      DATA HEDWDS/'POLA','WAVE','ABSO','ORIE','',''/
      DATA HMASK/.TRUE.,.TRUE.,.TRUE.,.TRUE.,.TRUE.,.TRUE./
C4.19 LHEAD updated for lambda/2
      DATA NHEAD,LHEAD/4,1,6,8,9,18,0,0/
      END
C
C
C
C
C LEVEL 1      FUNCTION DEGREE(X)
      FUNCTION DEGREE(X)
C
C *** DEGREE by JCM ***
C
CX
CC 10C
CH Converts from radians to degrees.
CA On entry X is an angle in radians
CA On exit DEGREE is the angle in degrees
C
CN The function RADIAN(X) does the degrees to radians conversion.
CN In routines where time matters, it is quicker to declare the COMMON
CN /CONSTA/ and multiply X by DEG.
/CONSTA/
C
      DEGREE = DEG*X
      RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE DEPRIN(IPRNT)
      SUBROUTINE DEPRIN(IPRNT)
C
C *** DEPRIN by JCM 11 Feb 80 ***
C
CX
CC 6C
CH Decodes an integer which describes the frequency of LSQ printing
CH required, and outputs this frequency.
CA On entry IPRNT = 0 for 'never'
CA                  1 for 'first cycle'
CA                  2 for 'last cycle'
CA                  3 for 'first and last cycles'
CA                  4 for 'every cycle'
CP An explanatory message is assumed to have been previously output
CD Interprets IPRNT as read from, usually, I card under such headings as
CD    'PRIN', 'PRFC', 'PRSK' etc, depending on the calling program
CO Outputs suitable message
C
/IOUNIT/
C
      IF (IPRNT .EQ. 1) THEN
        CALL MESS(LPT,0,'first cycle')
      ELSE IF (IPRNT .EQ. 2) THEN
        CALL MESS(LPT,0,'last cycle')
      ELSE IF (IPRNT .EQ. 3) THEN
        CALL MESS(LPT,0,'first and last cycles')
      ELSE IF (IPRNT .EQ. 4) THEN
        CALL MESS(LPT,0,'every cycle')
      ELSE
        CALL MESS(LPT,0,'never')
      ENDIF
      RETURN
      END
C
C
C
C
C LEVEL 1      FUNCTION DETER3(A)
      FUNCTION DETER3(A)
C
C *** DETER3 by JCM 28 Jun 83 ***
C
CX
CC 12C
CH Forms the determinant of a 3 x 3 matrix.
CA On entry A is a 3x3 real matrix.
CA On exit DETER3 holds its determinant.
C
      DIMENSION A(3,3)
      D=0.
      J=2
      K=3
      DO 1 I=1,3
      D=D+A(1,I)*(A(2,J)*A(3,K)-A(2,K)*A(3,J))
      J=K
   1  K=I
      DETER3=D
      RETURN
      END
C
C
C
C
C LEVEL 2      LOGICAL FUNCTION DFLTMG(IFAM,IGEN,ISPC)
      LOGICAL FUNCTION DFLTMG(IFAM,IGEN,ISPC)
C
C *** DFLTMG updated by PJB 27 C4.26 March 2013 ***
C
CX
CC 7A
CH Called as a substitute for DEFALT via VARMAK, giving default fix/vary
CH for otherwise unspecified parameters for magnetic structures.
CA On entry IFAM, ISPC, IGEN give family, genus, species of parameter
CA On exit LOGICAL DFLTMG is TRUE if the parameter is to be varied, or
CA                           FALSE if to be fixed.
CD For magnetic structures, fix all conventional structure parameters,
CD and vary all possible magnetic parameters.
C
/MAGDAT/
/SLAKDA/
/SYMMAG/
%      DATA NSTYPE,NPSI/8,%PSIS%/
C
      DFLTMG=.TRUE.
      GO TO (1,2) , IFAM
      GO TO 100
C
C FAMILY 1 - DEFAULT VARY SCALES, OR WHATEVER IS IN THEIR PLACE:
   1  IF (IGEN .NE. 1) GO TO 100
C IF GEOMETRIC SLACK CONSTRAINTS, DEFAULT VARY CELL PARAMETERS:
      IF (NSLAK(1).EQ.0 .AND. (ISPC.GE.2 .AND. ISPC.LE.7)) GO TO 101
C DEFAULT FIX DOMR & MOSC:
      IF (ISPC .EQ. 8 .OR. ISPC .EQ. 9) GO TO 101
C Vary ORDER params 10,11
      GO TO 100
C
C FAMILY 2 - DEFAULT FIX NUCLEAR PARAMETERS:
   2  IF (ISPC .LE. 12) GO TO 101
C
C  FIX MAGNETIC PARS OF NON-MAGNETIC ATOMS
      IF (MAGAT(IGEN).EQ.0) GO TO 101
C
C For incomensurate complex vector vary all mag pars
      IF (CPVEC) GO TO 100
C  IF HELICAL ALL MAGNETIC PARS ARE ALLOWED
      IF (HELI) GO TO 100
C  IF AMPLITUDE MODULATED PSI'S ARE VARIED
      J=ISPC-12-NPSI
      IF (J.LE.0) THEN
        IF (AMOD) GO TO 100
C ELSE FIX PSI'S
        GO TO 101
      ENDIF
C  FIX MINOR AXIS
      GO TO (100,100,101,101,100,101),J
C
C FIX:
 101  DFLTMG=.FALSE.
 100  RETURN
      END
C
C
C
C
C LEVEL 2      LOGICAL FUNCTION DFLTMP(IFAM,IGEN,ISPC)
      LOGICAL FUNCTION DFLTMP(IFAM,IGEN,ISPC)
C
C *** DFLTMP by PJB Oct 88  ***
C
CX
CC 7A
CH Called as a substitute for DEFALT out of VARMAK, giving defaults fix/vary
CH for otherwise unspecified parameters of multipole refinements.
CA On entry, IFAM,ISPC,IGEN hold family, genus and species of a parameter
CA for which there exists no other information as to whether to fix or
CA vary it.
CD Varies all multipoles and fixes the rest.
C
      I=IGEN + ISPC
      DFLTMP=(IFAM.EQ.5)
      RETURN
      END
C
C
C
C
C LEVEL 2      LOGICAL FUNCTION DFLTSF(IFAM,IGEN,ISPC)
      LOGICAL FUNCTION DFLTSF(IFAM,IGEN,ISPC)
C
C *** DFLTSF updated by JCM 10 May 90 ***
C
CX
CC 7A
CH Called as a substitute for DEFALT out of SUBROUTINE VARMAK, giving
CH default fix/vary information for structure parameters.
CA On entry IFAM, IGEN, ISPC specify the parameter.
CD On exit DFLTSF is .TRUE. if parameter IFAM,IGEN,ISPC is by default varied
CD         and .FALSE. if fixed.
C
CD In general varies, but fixes scattering factor, and only varies an itf
CD if there is no corresponding atf. Only allows A*-F* to vary if there
CD are slack constraints.
C
/ANISO/
/SLAKDA/
C
      DFLTSF=.TRUE.
      GO TO (1,2) , IFAM
      GO TO 100
C
C
C TRAP NON-EXISTENT CELL PARAMETERS:
   1  IF (IGEN .NE. 1) GO TO 100
      IF (NSLAK(1).EQ.0 .AND. (ISPC.GE.2 .AND. ISPC.LE.7)) GO TO 101
      GO TO 100
C
   2  IF (ISPC .LT. 10) GO TO 100
      IF (ISPC .LT. 12) GO TO 101
C IF VARYING ITF BY DEFAULT, CHECK NOT ALSO ATF:
      IF (IAPT(IGEN) .EQ. 0) GO TO 100
C
C FIX:
 101  DFLTSF=.FALSE.
 100  RETURN
      END
C
C
C
C
C LEVEL 1      LOGICAL FUNCTION DFTRUE(IFAM,IGEN,ISPC)
      LOGICAL FUNCTION DFTRUE(IFAM,IGEN,ISPC)
C
C *** DFTRUE by JCM 3 Dec 90 ***
C
CX
CC 7A
CH Called as a substitute for DEFALT out of VARMAK in main programs, to vary
CH an otherwise unspecified parameter.
CA DFTRUE on exit is .TRUE. if parameter is by default varied, .FALSE. if fixed
CA      - in this case it is always TRUE
CA IFAM on entry = family
CA IGEN on entry = genus
CA ISPC on entry = species (in this case, all irrelevant)
C
CD Varies all by default:
C TO KEEP COMPILERS HAPPY:
      I=IFAM
      I=IGEN
      I=ISPC
      DFTRUE=.TRUE.
      RETURN
      END
C
C
C
C
C LEVEL 4      SUBROUTINE DIJROT(D,ALPHA,BETA,GAMMA,KMAX)
      SUBROUTINE DIJROT(D,ALPHA,BETA,GAMMA,KMAX)
C
C *** DIJROT renamed by PJB C17 15-Sept-93 ***
C
CX
CC 9C
CH Calculates the matrix D(i,j) for the Euler rotations alpha,beta,gamma
CH of the eigenfunctions of angular momentum l.
CA On entry KMAX gives the multiplicity = 2l+1, and hence the dimension of D.
CA ALPHA, BETA GAMMA in radians are the rotations
CA On exit, D is a COMPLEX matrix
CO If IOUT in /IOUNIT/ is > 100, outputs D.
CN     i = l+m1+1,j = l+m2+1, so that
CN     when i=j=k,m1=m2=l and when i=j=1,m1=m2=-l
C
      DIMENSION C(21),S(21)
      COMPLEX D(KMAX,KMAX),EALPHA(21),EGAMMA(21),EAL,EGA
      EQUIVALENCE (C,EALPHA),(S,EGAMMA)
/IOUNIT/
C
      SINB = SIN(0.5*BETA)
      COSB = COS(0.5*BETA)
      S(1)=1.
      C(1)=1.
      DO 8 K=2,KMAX
      S(K)=S(K-1)*SINB
    8 C(K)=C(K-1)*COSB
      D(1,1) = CMPLX(COS(0.5*BETA),0.)
      D(1,2) = -CMPLX(SIN(0.5*BETA),0.)
      D(2,2) = D(1,1)
      D(2,1) = -D(1,2)
      IF (KMAX .LT. 3) GO TO 4
      K = 2
    3 DO 1 M = 1,K
      I = K-M+1
      DO 2 J = 1,K
      X = SQRT((FLOAT(K-I+1))/FLOAT(K-J+1))
      D(I,J) = X*D(I,J)*COSB
      IF (I .EQ. 1) GO TO 2
      X = SQRT((FLOAT(I-1))/FLOAT(K-J+1))
      D(I,J) = D(I,J) + X*D(I-1,J)*SINB
    2 CONTINUE
    1 CONTINUE
      K = K + 1
      DO 5 I = 1,K
      X = SQRT((FACT(K-1))/(FACT(K-I)*FACT(I-1)))
      SIGN = FLOAT(1-2*MOD(K-I,2))
      D(I,K) = SIGN*X*C(I)*S(K-I+1)
      D(K,I) = SIGN*D(I,K)
    5 CONTINUE
      IF (IOUT.EQ.100) THEN
        DO 20 I = 1,K
   20   WRITE (LPT,2000) (D(I,J),J=1,K)
2000    FORMAT (7(F9.4,F8.4))
        WRITE (LPT,2001)
2001    FORMAT (' ')
      ENDIF
      IF (K .LT. KMAX) GO TO 3
    4 M = (K-1)/2 + 1
      CALL TRIG (EALPHA,ALPHA,M)
      CALL TRIG (EGAMMA,GAMMA,M)
      DO 6 I = 1,K
      DO 7 J = 1,K
      EAL = EALPHA(IABS(I-M)+1)
      IF (I .LT. M) EAL = CONJG(EAL)
      EGA = EGAMMA(IABS(J-M)+1)
      IF (J .LT. M) EGA = CONJG(EGA)
      D(I,J) = D(I,J)*EGA*EAL
    7 CONTINUE
    6 CONTINUE
      RETURN
      END
C
C
C
C
C LEVEL 14      SUBROUTINE DOCHI1(MODI)
      SUBROUTINE DOCHI1(MODI)
C
C *** DOCHI1 to Library C139 July-4-2005 ***
C
CX
CC 17B
CH Multiple entry subroutine to read and check  parameters for paramagnetic
CH structure calculations given on Q cards
CA On entry MODI indicates action required:
CA          MODI = 1 Read all Q cards
CA          MODI = 2 Tidy and check magnetic parameters
CI Reads in and interprets all Q cards for paramagnetic structures.
CO Reports what it read from Q cards on LPT.
C
      CHARACTER*4 NAME,CNAMES(6)
      DIMENSION PROP(3)
/ATNAM/
/CARDRC/
/FONAM/
/IOUNIT/
/MAGDAT/
      DIMENSION CHIIJ(6,20),KCHIJ(6,20)
      EQUIVALENCE (ANGM,CHIIJ),(KSMOD,KCHIJ)
/NSYM/
/POLDA/
/POSNS/
/REFINE/
/SCRACH/
/SYMDA/
/SYMMAG/
/SYMTAB/
      DATA CNAMES/'CH11','CH22','CH33','CH23','CH31','CH12'/
C
      GO TO (1,20), MODI
      GO TO 100
C
C  READ ALL "Q" CARDS
    1 IER=IERR
C  INITIALISE PROPAGATION VECTOR TO ZERO
      CALL GMZER(PROP,1,3)
      call proper(prop)
C
      INREAD(17)=-IABS(INREAD(17))
      IF (ICDNO(17).EQ.0) THEN
        CALL ERRMES(2,1,'Q cards for magnetic structure calculations')
        GO TO 100
      ENDIF
      MAG=.TRUE.
      ID=IABS(INREAD(17))
      NMAG=0
      CALL JGMZER(MAGAT,1,NATOM)
C
%      CALL GMZER(CHIIJ,6,%MGAT%)
%      CALL JGMZER(NMFORM,1,%MGAT%)
C
C NQ COUNTS Q CARDS:
      DO 7 NQ=1,ICDNO(17)
      CALL INPUTQ(ID,NTYP,IAT,IPT1,IE)
      IF (IE .NE.0) THEN
        IERR=IERR+1
        GO TO 6
      ENDIF
      GO TO (10,6,6,6,70,6,6,6,2) ,NTYP
      GO TO 6
C
C  STYP: MAGNETIC STRUCTURE TYPE
  10  CALL RDWORD(NAME,L,IPT1,IPT,80,0,IE)
      IF (NAME .NE.'PARA') THEN
        CALL ERRMES(1,1,'Magnetic structure type must be PARA for '
     &  //'DOCHI')
      ELSE
        PARA=.TRUE.
        MTYP=6
      ENDIF
      GO TO 6
C
C  Q FORM:
   70 CALL RDWORD(NAME,L,IPT1,IPT,80,0,IE)
      IF (IE.EQ.100) GO TO 6
      NA=IATOM(NAME)
      IF (NA.EQ.0) CALL ERRATM(NAME,1,'Q card')
      IF (MAGAT(NA).EQ.0) THEN
%        CALL ERRCHK(2,NMAG,%MGAT%,1,'magnetic atoms')
        MAGAT(NA)=NMAG
        JMAGAT(NMAG)=NA
      ENDIF
      JAT=MAGAT(NA)
      IF (NMFORM(JAT).EQ.0) THEN
        NMFORM(JAT)=IAT
      ELSE
        CALL ERRMES(1,-1,
     &'Attempt to redefine magnetic form factor of '
     & //NAME//' ignored')
      ENDIF
       IPT1=IPT
      GO TO 70
C
C Q CHI: susceptibility tensor
    2 IF (MAGAT(IAT).EQ.0) THEN
%        CALL ERRCHK(2,NMAG,%MGAT%,1,'magnetic atoms')
        JMAGAT(NMAG)=IAT
      ENDIF
      JAT = MAGAT(IAT)
      CALL RDNUMS(CHIIJ(1,JAT),IPT1,6,NUM,IE)
      IF (IE.NE.0) THEN
        NUM=0
        GO TO 98
      ENDIF
C 4.22 Leave constraints for DOCHI2
      IF (NUM .EQ.1) THEN
C CONVERT FROM ISOTROPIC
        CHIIJ(2,JAT)= CHIIJ(1,JAT)
        CHIIJ(3,JAT)= CHIIJ(1,JAT)
        CALL GMZER(CHIIJ(4,JAT),3,1)
      ENDIF
      GO TO 6
C
C READING ERROR
  98  CALL ERRCH2('Q',2,'reading','card')
      GO TO 6
C
   6  ID=ID+NYZ
   7  CONTINUE
      IF (IER .NE. IERR) GO TO 100
C
C  END OF CARDS - CHECK THEM AND REPORT WHAT WAS READ:
      IF (NMAG.EQ.0) THEN
        CALL ERRMES(1,1,'no magnetic atoms')
      ELSE
        CALL MESS(LPT,1,'Magnetic structure type PARA')
        WRITE (LPT,2007)
 2007   FORMAT ('+',30X,'Aligned Paramagnetic')
      ENDIF
      GO TO 100
C
C  TIDY UP AND CHECK MAGNETIC PARAMETERS
   20 CALL MESS(LPT,1,'Magnetic susceptibilities and form factors '
     &//'with respect to crystallographic axes are:')
      WRITE (LPT,2005)
 2005 FORMAT (5X,'Atom     Form        Susceptibility Tensor Components'
     &  /13X,'factor     11      22      33      23      31      12')
      DO 9 I=1,NMAG
      jer = 0
      IF (NMFORM(I).EQ.0) THEN
        CALL ERRCH2(ATNAME(JMAGAT(I)),1,
     &  'No magnetic form factor for',' ')
        JER=JER+1
      ENDIF
      IF (CHIIJ(1,I) .EQ. 0) THEN
         CALL ERRCH2(ATNAME(JMAGAT(I)),1,'No Q CHI card for',' ')
         JER=JER+1
      ENDIF
      if (jer.eq.0) WRITE (LPT,2011) ATNAME(JMAGAT(I)),
     &FONAME(NMFORM(I)),(CHIIJ(J,I),J=1,6)
 2011 FORMAT (5X,A4,5X,A4,2X,6F8.4)
    9 CONTINUE
  100 RETURN
      END
C
C
C
C
C LEVEL !4      LOGICAL FUNCTION DOCHI2(NN,MODE)
      LOGICAL FUNCTION DOCHI2(NN,MODE)
C
CC *** DOCHI2 Modified for orthogonal symmetry constraints March 2011 PJB C4.22 ***
CC 17B
CH Logical multi-purpose function to deal with magnetic
CH variables in paramagnetic structure refinements
CD DOCHI2 follows the structure of the prototype
CD function for least squares parameters. It  has 2 dummy
CD arguments. NN transmits information, MODE indicates what function
CD is required the function returns TRUE if the routine dealt with
CD the call.
CP It is assumed that IFAM, IGEN and ISPC have been into common NEWOLD
CA On entry MODE indicates action required:
CA          MODE = 1 Determine symmetry constraints
CA                   NN is not used
CA          MODE = 2 Set Variable pointers
CA                   NN is the variable number
CA          MODE = 3 Apply shifts, one parameter per entry.
CA                   NN is not used
CA          MODE = 4 Write new Q card (one per entry)
CA                   KP is the serial number of the letter on the card to
CA                   rewrite.
CA          MODE = 6 Blanket fix or vary for CHIJ genus given
CA          MODE = 7 Blanket fix or vary for CHIJ all atoms
CA          MODE = 8 Not used no clearing up to do
C
      DIMENSION NFIX(6),AFIX(6),NCOUNT(6),NPAR(12),KKCON(6,12),
     &AMCON(6,12)
      LOGICAL FX,FIRST
/ATNAM/
/MAGDAT/
      DIMENSION CHIIJ(6,20),KCHIJ(6,20)
      EQUIVALENCE (ANGM,CHIIJ),(KSMOD,KCHIJ)
/NEWOLD/
/PHASE/
/POSNS/
/SCRACH/
/SOURCE/
/SYMDA/
/SYMTAB/
C
      IF (MODE .EQ.1) GO TO 1
      IF (MODE .EQ.4) GO TO 40
      IF (MODE .EQ.2 .AND. NN.EQ.0) GO TO 20
C Only CHIJ pars from family 2 dealt with
      IF (IFAM .NE. 2) GO TO 99
      IF (ISPC .LT.13 .OR. ISPC .GT. 18) GO TO 99
      GO TO (1,22,30,40,99,60,70), MODE
      GO TO 99
C
C ENTRY 1 TO SET CONSTRAINTS
C  WORK OVER ALL MAGNETIC ATOMS
      FIRST=.TRUE.
    1 DO 5 IATO = 1,NMAG
      IAT = JMAGAT(IATO)
      DO 2 I=1,6
      NFIX(I)=9999
      AFIX=0.
    2 CONTINUE
C4.22 changed to use CHICON
      CALL CHICON(IAT,NFIX,NUMCON,NPAR,KKCON,AMCON,FIRST)
C
C TRANSFER IN CASE THESE ARE LSQ PARAMETERS:
      DO 4 I=1,6
      NCOUNT(I)=KPAK(2,IAT,12+I,JPHASE,1)
    4 CONTINUE
      CALL FIXREL(6,NFIX,AFIX,NCOUNT,5)
      DO 6 NC=1,NUMCON
      DO 7 IP=1,NPAR(NC)
      I=KKCON(IP,NC)
      KKCON(IP,NC)=KPAK(2,IAT,12+I,JPHASE,1)
    7 CONTINUE
      CALL ADDCON(NPAR(NC),KKCON(1,NC),AMCON(1,NC),5)
    6 CONTINUE
    5 CONTINUE
C Return false here because other constraints may be needed
      GO TO 99
C
C ENTRY 2 TO SET VARIABLES

C INITIALISE KCHIJ FOR ALL MAGNETIC ATOMS:
   20 DO 21 I=1,NMAG
      DO 21 J=1,6
   21 KCHIJ(J,I)=0
C RETURN FALSE SO THAT OTHER PARAMETERS WILL BE SET
      GO TO 99
C RECORD ONE VARIABLE:
   22 IM=MAGAT(IGEN)
      IF (IM.EQ.0) GO TO 99
      IS = ISPC-12
      KCHIJ(IS,IM)=NN
      GO TO 101
C
C  APPLY SHIFTS:
   30 IP=MAGAT(IGEN)
      J=ISPC-12
      CALL ADJUST(CHIIJ(J,IP))
      GO TO 101
C
C  WRITE NEW Q CARDS
   40 IF (NN .NE.LETTER('Q')) GO TO 99
      CALL INPUTQ(0,NTYP,JAT,IPT,IE)
      IF (NTYP.LT.9) GO TO 41
      IAT=MAGAT(JAT)
      WRITE (ICARD(IPT:),214) (CHIIJ(I,IAT),I=1,6)
  214 FORMAT (6F10.4)
   41 WRITE (NEWIN,209) (ICARD(I:I),I=1,LENGT(ICARD))
  209 FORMAT (80A1)
      GO TO 101
C
C Blanket name CHIJ NN = 8 GIVEN GENUS
   60 IF (IABS(NN) .NE. 8) GO TO 99
      FX = (NN .GT.0)
      DO 61 I=12,18
      CALL FIXVAR(FX,2,IGEN,I,KPHASE,KSOURC,4)
   61 CONTINUE
      GO TO 101
C
C Blanket name CHIJ NN = 8 ALL ATOMS
   70 IF (IABS(NN) .NE. 8) GO TO 99
      FX = (NN .GT.0)
      DO 71 I=12,18
      CALL FIXVAR(FX,2,0,I,KPHASE,KSOURC,4)
   71 CONTINUE
      GO TO 101

   99 DOCHI2 = .FALSE.
      GO TO 100
  101 DOCHI2 = .TRUE.

  100 RETURN
      END
C
C
C
C
C LEVEL 14      SUBROUTINE DOINC1(MODE)
      SUBROUTINE DOINC1(MODE)
C
C *** DOINC1 new by PJB C4.26 July 2012 ***
CX
CC 17A
CH Multiple entry subroutine called from DOMAG1  for INCM type magnetic
CH structures.
CD DOINC1 called from DOMAG1 for structure type INCM to read the special Q
CD cards needed to define a modulated magnetic structure defined by
CD complex vector fourier coefficients. It finds the  magnetic symmetry,
CD reads the complex moment vectors and order parameters.
C NTYPE's treated by DOINC
CA MODE copied from DOMAG1 indicates action required:
CA          MODE = 1 Read all relevant Q cards
CA          MODE = 2 Tidies and checkd special  magnetic parameters
C
CN The extra Q card types treated by DOINC1 are:
CN      NTYP=11 for SORD Complex order parameters should be 2
CN      NTYP=12 for RVEC Complex moment vectors one for each
CN                       independent sub-lattice and order parameter
      DIMENSION S(9),IRVEC(50),IMSYM(49)
      LOGICAL BINDIG
/ATNAM/
/CARDRC/
/FONAM/
/IOUNIT/
/MAGDAT/
/NSYM/
/SATELL/
C
      SAVE NSORD,IRVEC

      if (mode .eq.2) go to 60
C Set no parameters read yet
      NSORD=0;
      call jgmzer(irvec,nmag,1)
      call jgmzer(imsym,nopc,1)
C
      ID=IABS(INREAD(17))
C Find PROP first as is needed for phase shifts
      call findcd('Q','PROP',4,ID-1,LCD)
      if (LCD .eq.0) then
      CALL ERRMES(2,1,
     &'Q PROP card giving, magnetic propagation vector')
      endif
      CALL RDNUMS(PROP,7,3,NUM,IE)
      IF (IE.NE.0 .or. NUM .ne. 3)  CALL ERRCH2('Q',2,'reading','card')
C
C Now read the rest of the Q cards
      DO 7 NQ=1,ICDNO(17)
      CALL INPUTQ(ID,NTYP,IAT,IPT1,IE)
      IF (IE .NE.0) THEN
        CALL ERRMES(1,1,'Error reading Q card')
        GO TO 6
      ENDIF
      go to (82,83) NTYP-2
      if (NTYP .le.10) go to 6
      GO TO (1 ,2) ,NTYP-10
C
C  Q MSYM:
   82 CALL RDINTG(IOP,IPT1,IPT,80,IE)
      CALL RDREAL(VAL,IPT,IPT1,80,IE)
      IF (IE.EQ.100) GO TO 6
      IF (IE.NE.0) GO TO 98
      CALL MELIN(IOP,VAL)
      GO TO 82
C
C  Q NSYM:
  83  CALL RDINTG(IOP,IPT1,IPT,80,IE)
      CALL RDNUMS(SROT,IPT,9,NUM,IE)
      IF (IE .NE. 0 .OR. NUM .NE. 9) GO TO 98
      CALL NELIN(IOP,SROT)
      GO TO 6
C  Q SORD:
    1 CALL RDINTG(ISORD,IPT1,IPT,ipt1+10,IE)
      IF (IE.NE.0) GO TO 98
      IF (ISORD .LT.1 .or. ISORD .GT.2) then
        call ERRIN2 (ISORD,1,'Illegal magnetic order parameter',
     & 'should be 1 or 2')
        GO TO 6
      endif
      CALL RDNUMS(S,IPT,2,NUM,IE)
      IF (IE.NE.0 .OR. NUM .LT. 2) GO TO 98
C Don't Convert to amp phase rep yet
      spord(ISORD)=cmplx(s(1),s(2))
      NSORD=1
      GO TO 6
C
C  Q RVEC:
    2 IF (MAGAT(IAT).EQ.0) THEN
        CALL ERRMES(2,1,ATNAME(IAT)//' is not a magnetic atom: no'//
     &  'magnetic form factor given')
        go to 6
      ENDIF
      CALL RDINTG(IP,IPT1,IPT,ipt1+10,IE)
      IF (IE.NE.0) GO TO 98
      CALL RDNUMS(S,IPT,6,NUM,IE)
      IF (IE.NE.0) THEN
        NUM=0
        GO TO 98
      ENDIF
      JAT=MAGAT(IAT)
      i=1
      do 31 n=1,3
C Don't Convert complex to amp/phi format
      rvec(n,IP,JAT)=cmplx(s(i),s(i+1))
      i=i+2
   31 continue
C Mark as read
      IRVEC(JAT)=IRVEC(JAT)+IP
      GO TO 6
C
C READING ERROR
  98  CALL ERRCH2('Q',2,'reading','card')
      GO TO 6
C
   6  ID=ID+NYZ
   7  CONTINUE
      GO TO 100
C
C  TIDY UP AND CHECK MAGNETIC PARAMETERS
  60  IF (NSORD.EQ.0)  THEN
        CALL ERRMES(2,1,'Q SORD card giving complex'
     &//'  magnetic order parameters')
      ELSE
        WRITE (LPT,2016)(I,SPORD(I),I=1,2)
 2016   format (/'Complex order parameters'/4(2x,i1,' =',2f8.4,2x))
      WRITE (LPT,2014)
      ENDIF
 2014   FORMAT (/'Atom  Partner',15x,'Moment  Vector',21x,'Form'
     & /19x,'X',16x,'Y',16x,'Z',9X,'factor')
      DO 61 I=1,NMAG
      II=0
      DO 62 IP=1,2
      IF (.NOT. BINDIG(IRVEC(I),IP)) THEN
        CALL ERRIN2(IP,1, 'No Q RVEC card found for partner ',
     &'of atom '//ATNAME(JMAGAT(I)))
        GO TO 61
      ENDIF
      WRITE (LPT,2015)  ATNAME(JMAGAT(I)),IP,(RVEC(J,IP,I),J=1,3),
     &FONAME(NMFORM(I))
 2015 FORMAT (A4,2X,I3,2X,3(2F8.4,1X),2X,A4)
   62 CONTINUE
   61 CONTINUE
      GO TO 88
C
C Make orthogonal symmetry operators
   88 CALL ROTOSM(S,S,0,0)
  100 RETURN
      END
C
C
C
C
C
C
C
C
C LEVEL 14      LOGICAL FUNCTION DOINC2(NN,MODE,IPARS)
      LOGICAL FUNCTION DOINC2(NN,MODE,IPARS)
C
C *** DOINC2 new by PJB C4.26 Sept 2012 ***
C
CX
CC 17B
CH Multiple entry subroutine to deal with magnetic
CH variables in  INCM structure type
CD DOINC2 is a logical function which follows the structure of the prototype
CD functions for least squares parameters. It has 3 dummy
CD arguments. NN transmits information and MODE indicates what function
CD is required. IPARS is needed to indicate the scope of blanket parameters.
CD The function returns TRUE if it has dealt with the call.
C
CP It is assumed that IFAM, IGEN and ISPEC are set in the COMMON NEWOLD
CA On entry MODE indicates action required:
CA          MODE = 1 Determine symmetry constraints
CA                   NN is not used.
CA          MODE = 2 Set Variable pointers
CA                   NN is the variable number
CA          MODE = 3 Apply shifts, one parameter per entry.
CA                   NN is not used
CA          MODE = 4 Write new Q card (one per entry)
CA                   NN is the serial number of the letter labelling the card to
CA                   rewrite
CA          MODE = 5 NOT NEEDED
CA          MODE = 6 Blanket fix or vary to deal with groups of parameters
CA                   identified as MVEC, REP1 REP2 MAMP MPHS when genus is given.
CA          MODE = 7 Blanket fix or vary as obove  to apply to all atoms + ORDP.
CA                   IPARS returns range of parameter specs to fix,very or fudge
CA          MODE = 8 Not used no clearing up to do
CA          MODE = 9 Count the number of order parameter variables
CC
C109 Range added to EXTERNAL to avoid conflict with intrinsic function
      DIMENSION IPARS(4),AMPHS(2)
      EXTERNAL DFLTMG,PARRUN,VARSMG,RANGE
C      LOGICAL DOINC2
/ATNAM/
/CARDRC/
/CONSTA/
/FONAM/
/IOUNIT/
/MAGDAT/
/NEWOLD/
/NSYM/
/POSNS/
/REFINE/
/SATELL/
/SCRACH/
/SYMMAG/
C
      IF (.NOT. CPVEC) go to 99
      IFF=IFAM
      ISP=ISPC
      IGN=IGEN
C Only MAGNETIC pars from family 2 and complex order pars are dealt with
      GO TO (1,20,30,40,50,2,2,101,90), MODE
      GO TO 99
c
C      THIS IS A BLANKET SPEC
    2 IF (IABS(NN) .LT. 8 .OR. IABS(NN) .GT.18) GO TO 99
      GO TO (60,70),MODE -5
C
C  SET UP CONSTRAINTS
    1 CALL MAGCNL
      GO TO 101
C
   20 IF (NN .EQ. 0) THEN
C ENTRY 0 IS TO FIX ALL PARAMETERS:
        CALL JGMZER(KSPORD,2,2)
        CALL JGMZER(KRVEC,12,NMAG)
      ELSE
C RECORD ONE VARIABLE:
        IF (IFAM .NE. 2) then
          IF (IGEN .NE. 1 .OR. (ISPC.LT.10 .OR. ISPC .GT.13)) GO TO 99
          MM=ISPC-10
          IR=MOD(MM,2)+1
          IAP=1+MM/2
          KSPORD(IR,IAP)=NN
        ELSE
          IM=MAGAT(IGEN)
          IF (IM.EQ.0) GO TO 99
          IF (ISPC .LT. 13 .OR. ISPC .GT. 24) GO TO 99
          MMM=ISPC-13
          IAP=1+ MMM/(6)
          MM=MOD(MMM,6)
          IR=1+MM/3
          I=MOD(MM,3)+1
          KRVEC(I,IR,IAP,IM)=NN
        ENDIF
      ENDIF
      GO TO 101
C
C  APPLY SHIFTS:
   30 IF (IFAM .NE. 2) then
        IF (IGEN .NE. 1 .OR. (ISPC.LT.10 .OR. ISPC .GT.13)) GO TO 99
        MM=ISPC-10
        IR=MOD(MM,2)+1
        IAP=1+MM/2
C Conversion to amp phase format and back
        CALL CAMPHS(-1,SPORD(IR),AMPHS,1,1)
        CALL ADJUST(AMPHS(IAP))
        CALL CAMPHS(1,SPORD(IR),AMPHS,1,1)
      ELSE
        IM=MAGAT(IGEN)
        MMM=ISPC-13
        IAP=1+ MMM/(6)
        MM=MOD(MMM,(6))
        IR=1+MM/3
        I=MOD(MM,3)+1
        CALL CAMPHS(-1,RVEC(I,IR,IM),AMPHS,1,1)
        CALL ADJUST(AMPHS(IAP))
        CALL CAMPHS(1,RVEC(I,IR,IM),AMPHS,1,1)
      ENDIF
      GO TO 101
C
C  WRITE NEW Q CARDS
   40 IF (NN .NE. LETTER('Q')) GO TO 99
      CALL INPUTQ(0,NTYP,JAT,IPT,IE)
      IF (NTYP.EQ.2) THEN
        CALL PROPAG(4,NEWIN)
        GO TO 101
C  SORD write order parameter
      ELSE IF (NTYP.EQ. 11) THEN
        CALL RDINTG(K,IPT,IPT1,IPT+10,IER)
        WRITE (ICARD(IPT1:),200) SPORD(K)
  200   FORMAT(2F10.4)
      ELSE IF (NTYP.EQ.12) THEN
C RVEC COMPLEX SPIN VECTOR COMPONENTS
        IAT=MAGAT(JAT)
        CALL RDINTG(K,IPT,IPT1,IPT+10,IER)
        DO 42 I=1,3
        WRITE (ICARD(IPT1:),201) RVEC(I,K,IAT)
  201   FORMAT (2F10.4,2X)
        IPT1=IPT1+22
   42   CONTINUE
      ENDIF
      GO TO 41
   41  WRITE (NEWIN,209) (ICARD(I:I),I=1,LENGT(ICARD))
  209 FORMAT (80A1)
      GO TO 101

C
C  RECALCULATE SPIN VECTORS (NOT NEEDED)
   50 GO TO 99
C
C Blanket names ORDP NN = 8 No Genus
C With Genus MVEC NN = 9 MUS  , REP1 NN = 10       REP2 NN = 11
C            MAMP NN = 12 Amps, MPHS NN = 13 Phases
   60 IPARS(2) = IGEN
      GO TO 71
C Blanket name ALL ATOMS
   70 IPARS(2) = 0
   71 II = IABS(NN)
      IPARS(1)=2
      IF (II.EQ.8) THEN
        IPARS(1)=1
        IPARS(2)=1
        IPARS(3)=10
        IPARS(4)=IPARS(3)+(6)-1
      ELSE IF (II .EQ. 9) THEN
          IPARS(3)=13
          IPARS(4)=(12)-1
      ELSE IF (II.EQ.10 .OR. II.EQ.11) THEN
        IP=3*(II-10) +13
        IF (NN .GT. 0) THEN
          IPARS(3)=IP
          IPARS(4)=IP+2
C set nn negative as there are more to do
          NN=-II
        ELSE
          IPARS(3)=IP+6
          IPARS(4)=IP+8
          NN=II
        ENDIF
      ELSE IF (II.EQ.12) THEN
        IPARS(3) = 13
        IPARS(4) = 18
      ELSE IF (II.EQ.13) THEN
        IPARS(3) = 19
        IPARS(4) = 24
      ELSE
        GO TO 99
      ENDIF
      GO TO 101
C
C MODE = 9 Count the number of order parameter variables
   90 NN=0
      DO 91 IREP=1,3
      DO 91 IAP=1,2
      IF (KSPORD(IREP,IAP).NE.0) NN=NN+1
   91 CONTINUE
      GO TO 101
C
   99 DOINC2 = .FALSE.
      GO TO 100
  101 DOINC2 = .TRUE.

  100 RETURN
      END

C
C
C
C
C LEVEL 14      SUBROUTINE DOMAG(MODE)
      SUBROUTINE DOMAG(MODE)
C
C *** DOMAG updated by PJB  21-Oct-1997 ***
C
CX
CC 17B
CH Multiple entry subroutine to deal with parameters for magnetic
CH structures on Q cards (but not their fixing/varying).
CA On entry MODE indicates action required:
CA          MODE = 1 Read all Q cards
CA          MODE = 2 Tidy and check magnetic parameters
CA          MODE = 3 Apply shifts, one parameter per entry.
CA          MODE = 4 Write new Q card (one per entry)
CA          MODE = 5 Recalculate vector components and possible new constraints
CA                   at the end of a least squares cycle
CA          MODE = 6 as 5 but in profile refinement VARMAK is called anyway
CA                   at the start of each cycle.
CI Reads in and interprets all Q cards.
CO Reports what it read from Q cards on LPT.
C
      EXTERNAL DFLTMG,PARRUN,VARSMG,LDUMMY,RANGER
      CHARACTER*4 NAME,STYPES(5)
      DIMENSION S(4),SROT(3,3),PROP(3)
/ATNAM/
/CARDRC/
/FONAM/
/IOUNIT/
/MAGDAT/
/NEWOLD/
/NSYM/
/POSNS/
/REFINE/
/SCRACH/
/SYMMAG/
      DATA STYPES/'FERO','FERA','HELI','AMOD','ANTI'/
%      DATA NSTYPE,NPSI/5,%PSIS%/
C
      GO TO (1,20,30,40,50,50 ), MODE
C
C  READ ALL "Q" CARDS
    1 IER=IERR
C  INITIALISE PROPAGATION VECTOR TO ZERO
      CALL GMZER(PROP,1,3)
C  INITIALISE MAGNETIC SYMMETRY
      CALL MAGSYM(0)
C
      INREAD(17)=-IABS(INREAD(17))
      IF (ICDNO(17).EQ.0) THEN
        CALL ERRMES(2,1,'Q cards for magnetic structure refinements')
        GO TO 100
      ENDIF
      MAG=.TRUE.
      ID=IABS(INREAD(17))
      NMAG=0
      CALL JGMZER(MAGAT,1,NATOM)
C
%      DO 8 I=1,%MGAT%
      ANGM(1,I)=999.5
      SMOD(1,I)=0.
    8 NMFORM(I)=0
      CALL JGMZER(LPHI,NPSI,1)
C
C NQ COUNTS Q CARDS:
      DO 7 NQ=1,ICDNO(17)
      CALL INPUTQ(ID,NTYP,IAT,IPT1,IE)
      IF (IE .NE.0) THEN
        IERR=IERR+1
        GO TO 6
      ENDIF
      GO TO (10,81,82,83,70,80,2,28) ,NTYP
C
C  STYP: MAGNETIC STRUCTURE TYPE
  10  CALL RDWORD(NAME,L,IPT1,IPT,80,0,IE)
      MTYP=NCFIND(NAME,STYPES,NSTYPE)
      IF (MTYP.EQ.0) CALL ERRCH2(NAME,1,'Magnetic structure type ',
     & 'not known')
      GO TO 6
C
C  SDIR
C  SET SPIN DIRECTIONS
    2 CALL GMZER(S,4,1)
      CALL RDNUMS(S,IPT1,4,NUM,IE)
      IF (IE.NE.0)THEN
        NUM=0
        GO TO 98
      ELSE
        IF (MAGAT(IAT).EQ.0) THEN
%          CALL ERRCHK(2,NMAG,%MGAT%,1,'magnetic atoms')
          MAGAT(IAT)=NMAG
          JMAGAT(NMAG)=IAT
        ENDIF
        JAT=MAGAT(IAT)
        DO 25 I=1,4
   25   CALL PUTPAR(S,I,NUM,ANGM(I,JAT),999.5)
      ENDIF
      GO TO 6
C
C  Q PSI: relative phases of spirals on different sublattices
   28 IF (MAGAT(IAT).EQ.0) THEN
%       CALL ERRCHK(2,NMAG,%MGAT%,1,'magnetic atoms')
        MAGAT(IAT)=NMAG
        JMAGAT(NMAG)=IAT
      ENDIF
      JAT=MAGAT(IAT)
      I=0
   29 CALL RDINTG(L,IPT1,IPT2,80,IE)
      IF (IE .EQ. 100) GO TO 6
      IF (IE .GT. 0) GO TO 98
      CALL RDREAL(P,IPT2,IPT1,80,IE)
      IF (IE .EQ. 100) GO TO 6
      IF (IE .GT. 0) GO TO 98
      IF (IABS(L).LT. 1 .OR. IABS(L).GT.NOPC)
     & CALL ERRIN2(L,1,'Illegal operator number',' on Q PSI card')
      CALL ERRCHK(2,I,NPSI,1,'PSI values')
      LPHI(I,JAT)=L
      PHIH(I,JAT)=P
      IF (I.LE.NPSI) GO TO 29
      GO TO 6
C
C  Q FORM:
   70 CALL RDWORD(NAME,L,IPT1,IPT,80,0,IE)
      IF (IE.EQ.100) GO TO 6
      NA=IATOM(NAME)
      IF (NA.EQ.0) CALL ERRATM(NAME,1,'Q card')
      IF (MAGAT(NA).EQ.0) THEN
%        CALL ERRCHK(2,NMAG,%MGAT%,1,'magnetic atoms')
        MAGAT(NA)=NMAG
        JMAGAT(NMAG)=NA
      ENDIF
      JAT=MAGAT(NA)
      IF (NMFORM(JAT).EQ.0) THEN
        NMFORM(JAT)=IAT
      ELSE
        CALL ERRMES(1,-1,
     &'Attempt to redefine magnetic form factor of '
     & //NAME//' ignored')
      ENDIF
       IPT1=IPT
      GO TO 70
C
C Q MU:
   80 CALL GMZER (S,4,1)
      CALL RDNUMS(S,IPT1,2,NUM,IE)
      IF (IE.NE.0) THEN
        NUM=0
        GO TO 98
      ENDIF
      IF (MAGAT(IAT).EQ.0) THEN
%        CALL ERRCHK(2,NMAG,%MGAT%,1,'magnetic atoms')
        MAGAT(IAT)=NMAG
        JMAGAT(NMAG)=IAT
      ENDIF
      JAT=MAGAT(IAT)
      CALL PUTPAR(S,1,NUM,SMOD(1,JAT),999.)
      CALL PUTPAR(S,2,NUM,SMOD(2,JAT),999.)
      GO TO 6
C
C  Q PROP:
   81 CALL RDNUMS(PROP,IPT1,3,NUM,IE)
      IF (IE.EQ.0) GO TO 6
      GO TO 98
C
C  Q MSYM:
   82 CALL RDINTG(IOP,IPT1,IPT,80,IE)
      CALL RDREAL(VAL,IPT,IPT1,80,IE)
      IF (IE.EQ.100) GO TO 6
      IF (IE.NE.0) GO TO 98
      CALL MELIN(IOP,VAL)
      GO TO 82
C
C  Q NSYM:
  83  CALL RDINTG(IOP,IPT1,IPT,80,IE)
      CALL RDNUMS(SROT,IPT,9,NUM,IE)
      IF (IE .NE. 0 .OR. NUM .NE. 9) GO TO 98
      CALL NELIN(IOP,SROT)
      GO TO 6
C
C READING ERROR
  98  CALL ERRCH2('Q',2,'reading','card')
      GO TO 6
C
   6  ID=ID+NYZ
   7  CONTINUE
      IF (IER .NE. IERR) GO TO 100
C
C  END OF CARDS - CHECK THEM AND REPORT WHAT WAS READ:
      IF (NMAG.EQ.0) THEN
        CALL ERRMES(1,1,'no magnetic atoms')
      ELSE
        IF (MTYP .GT. 0) THEN
          CALL LOGMAG
          CALL MESS(LPT,1,'Magnetic structure type '//STYPES(MTYP))
          IF (FERO .OR. FERA) WRITE (LPT,2007)
 2007     FORMAT ('+',30X,'Ferromagnetic')
          IF (HELI) WRITE (LPT,2009) PROP
 2009     FORMAT (' Helimagnetic Structure with Propagation Vector ',
     &     3F8.4/)
          IF (AMOD) WRITE (LPT,2008) PROP
 2008     FORMAT (/' Amplitude Modulated Structure with Propagation ',
     &   ' Vector ',3F8.4/)
          IF (ANTI) WRITE (LPT,2010) PROP
2010      FORMAT (/' Commensurate magnetic structure with Propagation ',
     &   ' Vector ',3F8.4/)
        ENDIF
        CALL PROPER(PROP)
        CALL MAGSYM(1)
      ENDIF
      GO TO 100
C
C  TIDY UP AND CHECK MAGNETIC PARAMETERS
   20 CALL MESS(LPT,1,'Magnetic moments, form factors and polar'//
     & ' angles of spin directions')
      CALL MESS(LPT,0,'with respect to orthogonal crystallographic'//
     & ' axes are:')
      IF (HELI) THEN
        WRITE (LPT,2003)
 2003   FORMAT (5X,'Atom     Form',11X,'Major Axis',16X,
     & 'Minor Axis',12X,'Phase Angles'/13X,'factor',
     & 2(4X,'Moment   Theta    Phi '),3X,4('Op. Phase   '))
      ELSE IF (AMOD) THEN
        WRITE (LPT,2005)
 2005   FORMAT (5X,'Atom     Form    Moment    Theta','    Phi',
     &  16X,'Phase Angles'/13X,'factor',31X,4('Op. Phase   '))
      ELSE
        WRITE (LPT,2004)
 2004   FORMAT (5X,'Atom     Moment     Form       Theta',
     & '       Phi'/25X,'factor')
      ENDIF
      DO 9 I=1,NMAG
      IF (NMFORM(I).EQ.0) THEN
        CALL ERRCH2(ATNAME(JMAGAT(I)),1,
     &  'No magnetic form factor for',' ')
      ELSE
        IF (ANGM(1,I) .GT. 999) THEN
          CALL ERRCH2(ATNAME(JMAGAT(I)),1,'No Q SDIR card for',' ')
        ELSE
          NUM=2
          IF (HELI) NUM=4
          DO 51 J=2,NUM
          IF (ANGM(J,I) .LT. 999.) GO TO 51
          CALL ERRCH2(ATNAME(JMAGAT(I)),1,
     &    'Not enough data on SDIR card for',' ')
          GO TO 52
   51     CONTINUE
        ENDIF
   52   IF (SMOD(1,I).EQ.0. ) THEN
            WRITE (LPT,3008) ATNAME(JMAGAT(I))
            WRITE (ITO,3008) ATNAME(JMAGAT(I))
 3008       FORMAT (' WARNING ** Zero moment for ',A4)
        ELSE
          IF (HELI .AND. SMOD(2,I).GE.999.)
     &    CALL ERRCH2(ATNAME(JMAGAT(I)),1,
     &    'Not enough data on MU card for',' ')
        ENDIF
        IF (MODUL) THEN
          IF (NPHI(I).GT.0) THEN
            NP=NPHI(I)
            DO 53 J=1,NP
            IF (LPHI(J,I) .EQ.0) THEN
                CALL ERRIN2(J,1,
     &        'PSI value for sublattice','missing on PSI '
     &        //ATNAME(JMAGAT(I))//' card')
                GO TO 54
            ENDIF
   53       CONTINUE
          ENDIF
   54     IF (HELI) THEN
            WRITE (LPT,2001) ATNAME(JMAGAT(I)),
     &    FONAME(NMFORM(I)),SMOD(1,I),(ANGM(J,I),J=1,2),
     &    SMOD(2,I),(ANGM(J,I),J=3,4),(LPHI(J,I),
     &    PHIH(J,I),J=1,NP)
 2001       FORMAT (5X,A4,5X,A4,2X,2(F8.3,2F8.1,2X),2X,3(I3,F7.1,2X))
          ELSE
            WRITE (LPT,2011) ATNAME(JMAGAT(I)),
     &    FONAME(NMFORM(I)),SMOD(1,I),(ANGM(J,I),J=1,2),
     &    (LPHI(J,I),PHIH(J,I),J=1,NP)
 2011       FORMAT (5X,A4,5X,A4,2X,F8.3,2F8.1,5X,4(I3,F7.1,2X))
          ENDIF
        ELSE
          WRITE (LPT,2000) ATNAME(JMAGAT(I)),SMOD(1,I),
     &    FONAME(NMFORM(I)),ANGM(1,I),ANGM(2,I)
 2000     FORMAT (5X,A4,2X,F8.4,7X,A4,2X,2F10.2)
        ENDIF
      ENDIF
    9 CONTINUE
      CALL ERRMES(0,0,'from DOMAG(2)')
      GO TO 100
C
C  APPLY SHIFTS:
   30 IP=MAGAT(IGEN)
      J=ISPC-12
      IF (J.LE.NPSI) GO TO 23
      J=J-NPSI
      IF (J.LE.4) GO TO 21
      J=J-4
      GO TO 22
C
   21 CALL ADJUST(ANGM(J,IP))
      ANGM(J,IP)=RANGER(ANGM(J,IP),180.,-180.)
      XNEW=ANGM(J,IP)
      GO TO 100
C
   22 CALL ADJUST(SMOD(J,IP))
      GO TO 100
C
   23 CALL ADJUST(PHIH(J,IP))
      GO TO 100
C
C  WRITE NEW Q CARDS
   40 CALL INPUTQ(0,NTYP,JAT,IPT,IE)
      IF (NTYP.EQ.2) THEN
        CALL PROPAG(4,NEWIN)
        GO TO 100
      ENDIF
      IF (NTYP.LT.6) GO TO 31
      IAT=MAGAT(JAT)
      IP=2
      IF (MTYP.EQ.3) IP=4
      IM=IP/2
      IF (NTYP.EQ.8) THEN
        NPH=NPHI(IAT)
        DO 41 J=1,NPH
        LP=LPHI(J,IAT)
        IF (LP.GT.NOPC) LP=-1
        WRITE (ICARD(IPT:),214) LP,PHIH(J,IAT)
  214 FORMAT (I5,F10.4)
        IPT=IPT+15
   41   CONTINUE
      ELSE IF (NTYP.EQ.7) THEN
        WRITE (ICARD(IPT:),213) (ANGM(J,IAT),J=1,IP)
  213   FORMAT (4F10.4)
      ELSE IF (NTYP.EQ.6) THEN
        WRITE (ICARD(IPT:),213) (SMOD(J,IAT),J=1,IM)
      ENDIF
  31  WRITE (NEWIN,209) (ICARD(I:I),I=1,LENGT(ICARD))
  209 FORMAT (80A1)
      GO TO 100
C
C  RECALCULATE SPIN VECTORS
   50 DO 61 IM=1,NMAG
      CALL SPHPOL(ANGM(1,IM),ANGM(2,IM),SPIND(1,1,1,IM),3)
      IF (HELI) THEN
        CALL SPHPOL(ANGM(3,IM),ANGM(4,IM),SPIND(1,1,2,IM),3)
        CALL SPHELI(IM,2)
      ENDIF
   61 CONTINUE
C IN PROFILE REFINEMENT VARMAK IS CALLED ANYWAY
      IF (HELI .AND. MODE .EQ.5)
     &CALL VARMAK(DFLTMG,PARRUN,VARSMG,LDUMMY)
C
  100 RETURN
      END
C
C
C
C
C LEVEL 14      SUBROUTINE DOMAG1(MODE)
      SUBROUTINE DOMAG1(MODE)
C
C *** DOMAG1 updated by PJB MODE=3 FOR MAGNETIC SYMMETRY ONLY C4.30 AUGUST 2016  ***
C
CX
CC 17B
CH Multiple entry subroutine to deal with parameters for magnetic
CH structures on Q cards.
CD DOMAG1 reads the Q cards needed to define a magnetic structure and uses
CD them to find the magnetic symmetry, the magnitude and direction of the
CD moments on the magnetic atoms, and the  magnetic form-factors which
CD apply. DOMAG1 is needed  needed for both magnetic structure factor
CD calculation and refinement.
CA On entry MODE indicates action required:
CA          MODE = 1 Read all Q cards
CA          MODE = 2 Tidy and check magnetic parameters
CA          MODE = 3 Requires Q cards for magnetic symmetry only
CI Reads in and interprets all Q cards.
CO Reports what it read from Q cards on LPT.
CP The crystal structure must already be defined by SETFC or its equivalent.
C
      CHARACTER*4 NAME,STYPES(8)
      DIMENSION S(6),SROT(3,3)
/ATNAM/
/CARDRC/
/FONAM/
/IOUNIT/
/MAGDAT/
/NEWOLD/
/NSYM/
/POSNS/
/REFINE/
/SATELL/
/SCRACH/
/SYMMAG/
C 4.26 Types FANI and CPVEC added
      DATA STYPES/'FERO','FERA','HELI','AMOD','ANTI','PARA','FANI',
     &'INCM'/
%      DATA NSTYPE,NPSI/8,%PSIS%/
      SAVE IPT1
C4.30
      GO TO (1,20,1), MODE
      GO TO 100
C
C  READ ALL "Q" CARDS
    1 IER=IERR
C  INITIALISE PROPAGATION VECTOR TO ZERO
      CALL GMZER(PROP,1,3)
C  INITIALISE MAGNETIC SYMMETRY
      CALL MAGSYM(0)
C
      INREAD(17)=-IABS(INREAD(17))
      IF (ICDNO(17).EQ.0) THEN
        CALL ERRMES(2,1,'Q cards for magnetic structure calculations')
        GO TO 100
      ENDIF
      MAG=.TRUE.
      ID=IABS(INREAD(17))
      NMAG=0
      CALL JGMZER(MAGAT,1,NATOM)
C
C Determine  the magnetic structure type
      CALL FINDCD('Q','STYP',4,ID-1,LCD)
      IF (LCD .EQ.0) THEN
      CALL ERRMES(2,1,
     &'Q STYP card giving, magnetic structure type')
      ENDIF
      CALL RDWORD(NAME,L,7,IPT,80,0,IE)
      MTYP=NCFIND(NAME,STYPES,NSTYPE)
      IF (MTYP.EQ.0) THEN
        CALL ERRCH2(NAME,1,'Magnetic structure type ','not known')
        GO TO 100
      ENDIF
C Set logicals
      CALL LOGMAG
C Determine the magnetic atoms and their form factors
C Sift out the Q FORM cards
C NQ COUNTS Q CARDS:
      NOQ=ICDNO(17)
      DO 27 NQ=1,NOQ
      CALL INPUTQ(ID,NTYP,IAT,IPT1,IE)
      IF (IE .NE.0) THEN
        IER=IER+1
        GO TO 26
      ENDIF
C4.30 Mode=3 if only magnetic symmetry is required
      IF ((MODE .EQ. 1) .AND. (NTYP .EQ.5)) THEN
  70    CALL RDWORD(NAME,L,IPT1,IPT,80,0,IE)
        IF (IE.EQ.100) GO TO 26
        NA=IATOM(NAME)
        IF (NA.EQ.0) CALL ERRATM(NAME,1,'Q card')
        IF (MAGAT(NA).EQ.0) THEN
%        CALL ERRCHK(2,NMAG,%MGAT%,1,'magnetic atoms')
          MAGAT(NA)=NMAG
          JMAGAT(NMAG)=NA
        ENDIF
        JAT=MAGAT(NA)
        IF (NMFORM(JAT).EQ.0) THEN
          NMFORM(JAT)=IAT
        ELSE
          CALL ERRMES(1,-1,
     &    'Attempt to redefine magnetic form factor of '
     &     //NAME//' ignored')
        ENDIF
        IPT1=IPT
        GO TO 70
      ENDIF
  26  ID=ID+NYZ
  27  CONTINUE
      IF (IER .NE. IERR) GO TO 100
      if (CPVEC) then
        IER=IERR
        CALL DOINC1(1)
        IF (IER .NE. IERR) GO TO 100
        GO TO 90
      ENDIF
C
      DO 8 I=1,NMAG
      DO 71 j=1,4
      ANGM(J,I)=999.5
   71 continue
    8 SMOD(1,I)=0.
      CALL JGMZER(LPHI,NPSI,1)
C
C NQ COUNTS Q CARDS:
      ID=IABS(INREAD(17))
      DO 7 NQ=1,ICDNO(17)
      CALL INPUTQ(ID,NTYP,IAT,IPT1,IE)
      IF (IE .NE.0) THEN
        IER=IER+1
        GO TO 6
      ENDIF
      GO TO (6,81,82,83,6,80,2,28) ,NTYP
C4.3 For Q cards not  treated by DOMAG
      GO TO 6
C
C  STYP: MAGNETIC STRUCTURE TYPE, already read
C
C  SDIR
C  SET SPIN DIRECTIONS
    2 CALL GMZER(S,4,1)
      CALL RDNUMS(S,IPT1,4,NUM,IE)
      IF (IE.NE.0)THEN
        NUM=0
        GO TO 98
      ELSE
        IF (MAGAT(IAT).EQ.0) THEN
%          CALL ERRCHK(2,NMAG,%MGAT%,1,'magnetic atoms')
          MAGAT(IAT)=NMAG
          JMAGAT(NMAG)=IAT
        ENDIF
        JAT=MAGAT(IAT)
        DO 25 I=1,4
   25   CALL PUTPAR(S,I,NUM,ANGM(I,JAT),999.5)
      ENDIF
      GO TO 6
C
C  Q PSI: relative phases of spirals on different sublattices
   28 IF (MAGAT(IAT).EQ.0) THEN
%       CALL ERRCHK(2,NMAG,%MGAT%,1,'magnetic atoms')
        MAGAT(IAT)=NMAG
        JMAGAT(NMAG)=IAT
      ENDIF
      JAT=MAGAT(IAT)
      I=0
   29 CALL RDINTG(L,IPT1,IPT2,80,IE)
      IF (IE .EQ. 100) GO TO 6
      IF (IE .GT. 0) GO TO 98
      CALL RDREAL(P,IPT2,IPT1,80,IE)
      IF (IE .EQ. 100) GO TO 6
      IF (IE .GT. 0) GO TO 98
      IF (IABS(L).LT. 1 .OR. IABS(L).GT.NOPC)
     & CALL ERRIN2(L,1,'Illegal operator number',' on Q PSI card')
      CALL ERRCHK(2,I,NPSI,1,'PSI values')
      LPHI(I,JAT)=L
      PHIH(I,JAT)=P
C141 Set NPHI
      NPHI(JAT)=I
      IF (I.LE.NPSI) GO TO 29
      GO TO 6
C
C  Q FORM: already read
C
C Q MU:
   80 CALL GMZER (S,4,1)
      CALL RDNUMS(S,IPT1,2,NUM,IE)
      IF (IE.NE.0) THEN
        NUM=0
        GO TO 98
      ENDIF
      IF (MAGAT(IAT).EQ.0) THEN
%        CALL ERRCHK(2,NMAG,%MGAT%,1,'magnetic atoms')
        MAGAT(IAT)=NMAG
        JMAGAT(NMAG)=IAT
      ENDIF
      JAT=MAGAT(IAT)
      CALL PUTPAR(S,1,NUM,SMOD(1,JAT),999.)
      CALL PUTPAR(S,2,NUM,SMOD(2,JAT),999.)
      GO TO 6
C
C  Q PROP:
   81 CALL RDNUMS(PROP,IPT1,3,NUM,IE)
      IF (IE.EQ.0) GO TO 6
      GO TO 98
C
C  Q MSYM:
   82 CALL RDINTG(IOP,IPT1,IPT,80,IE)
      CALL RDREAL(VAL,IPT,IPT1,80,IE)
      IF (IE.EQ.100) GO TO 6
      IF (IE.NE.0) GO TO 98
      CALL MELIN(IOP,VAL)
      GO TO 82
C
C  Q NSYM:
  83  CALL RDINTG(IOP,IPT1,IPT,80,IE)
      CALL RDNUMS(SROT,IPT,9,NUM,IE)
      IF (IE .NE. 0 .OR. NUM .NE. 9) GO TO 98
      CALL NELIN(IOP,SROT)
      GO TO 6
C
C READING ERROR
  98  CALL ERRCH2('Q',2,'reading','card')
      GO TO 6
C
   6  ID=ID+NYZ
   7  CONTINUE
      IF (IER .NE. IERR) GO TO 100
C
C  END OF CARDS - CHECK THEM AND REPORT WHAT WAS READ:
C4.30
   90 IF (NMAG.EQ.0 .AND. MODE .EQ.1) THEN
        CALL ERRMES(1,1,'no magnetic atoms')
      ELSE
        IF (MTYP .GT. 0) THEN
          CALL MESS(LPT,1,'Magnetic structure type '//STYPES(MTYP))
          IF (FERO .OR. FERA) WRITE (LPT,2007)
 2007     FORMAT ('+',30X,'Ferromagnetic')
          IF (HELI) WRITE (LPT,2009) PROP
 2009     FORMAT (' Helimagnetic Structure with Propagation Vector ',
     &     3F8.4/)
          IF (AMOD) WRITE (LPT,2008) PROP
 2008     FORMAT (/' Amplitude Modulated Structure with Propagation ',
     &   ' Vector ',3F8.4/)
          IF (ANTI) WRITE (LPT,2010) PROP
2010      FORMAT (/' Commensurate magnetic structure with Propagation ',
     &   ' Vector ',3F8.4/)
          IF (FANI) WRITE (LPT,2011)
 2011     FORMAT (/' Anisotropic ferromagnetic structure ',
     &   ' Vector ',3F8.4/)
          IF (CPVEC) WRITE (LPT,2012) PROP
 2012     FORMAT (/' Complex Modulated Structure with Propagation ',
     &   ' Vector ',3F8.4/)
        ENDIF
        CALL PROPER(PROP)
        CALL MAGSYM(1)
      ENDIF
      GO TO 100
C
C  TIDY UP AND CHECK MAGNETIC PARAMETERS
   20  if (CPVEC) then
         CALL DOINC1(2,PROP,IER)
         GO TO 88
      ENDIF
      CALL MESS(LPT,1,'Magnetic moments, form factors and polar'//
     & ' angles of spin directions')
      CALL MESS(LPT,0,'with respect to orthogonal crystallographic'//
     & ' axes are:')
      IF (HELI) THEN
        WRITE (LPT,2003)
 2003   FORMAT (5X,'Atom     Form',11X,'Major Axis',16X,
     & 'Minor Axis',12X,'Phase Angles'/13X,'factor',
     & 2(4X,'Moment   Theta    Phi '),3X,4('Op. Phase   '))
      ELSE IF (AMOD) THEN
        WRITE (LPT,2005)
 2005   FORMAT (5X,'Atom     Form    Moment    Theta','    Phi',
     &  16X,'Phase Angles'/13X,'factor',31X,4('Op. Phase   '))
      ELSE
        WRITE (LPT,2004)
 2004   FORMAT (5X,'Atom     Moment     Form       Theta',
     & '       Phi'/25X,'factor')
      ENDIF
      DO 9 I=1,NMAG
      IF (NMFORM(I).EQ.0) THEN
        CALL ERRCH2(ATNAME(JMAGAT(I)),1,
     &  'No magnetic form factor for',' ')
      ELSE
C
        IF (ANGM(1,I) .GT. 999) THEN
          CALL ERRCH2(ATNAME(JMAGAT(I)),1,'No Q SDIR card for',' ')
        ELSE
          NUM=2
          IF (HELI) NUM=4
          DO 51 J=2,NUM
          IF (ANGM(J,I) .LT. 999.) GO TO 51
          CALL ERRCH2(ATNAME(JMAGAT(I)),1,
     &    'Not enough data on SDIR card for',' ')
          GO TO 52
   51     CONTINUE
        ENDIF
   52   IF (SMOD(1,I).EQ.0. ) THEN
            WRITE (LPT,3008) ATNAME(JMAGAT(I))
            WRITE (ITO,3008) ATNAME(JMAGAT(I))
 3008       FORMAT (' WARNING ** Zero moment for ',A4)
        ELSE
          IF (HELI .AND. SMOD(2,I).GE.999.)
     &    CALL ERRCH2(ATNAME(JMAGAT(I)),1,
     &    'Not enough data on MU card for',' ')
        ENDIF
        IF (MODUL) THEN
          NP=NPHI(I)
          IF (HELI) THEN
            WRITE (LPT,2001) ATNAME(JMAGAT(I)),
     &    FONAME(NMFORM(I)),SMOD(1,I),(ANGM(J,I),J=1,2),
     &    SMOD(2,I),(ANGM(J,I),J=3,4),(LPHI(J,I),
     &    PHIH(J,I),J=1,NP)
 2001       FORMAT (5X,A4,5X,A4,2X,2(F8.3,2F8.1,2X),2X,3(I3,F7.1,2X))
          ELSE
            WRITE (LPT,2013) ATNAME(JMAGAT(I)),
     &      FONAME(NMFORM(I)),SMOD(1,I),(ANGM(J,I),J=1,2),
     &      (LPHI(J,I),PHIH(J,I),J=1,NP)
 2013       FORMAT (5X,A4,5X,A4,2X,F8.3,2F8.1,5X,4(I3,F7.1,2X))
          ENDIF
        ELSE
          WRITE (LPT,2000) ATNAME(JMAGAT(I)),SMOD(1,I),
     &    FONAME(NMFORM(I)),ANGM(1,I),ANGM(2,I)
 2000     FORMAT (5X,A4,2X,F8.4,7X,A4,2X,2F10.2)
        ENDIF
      ENDIF
    9 CONTINUE
      GO TO 88
C
C MAKE ORTHOGONAL SYMMETRY OPERATORS
   88 CALL ROTOSM(S,S,0,0)
  100 RETURN
      END
C
C
C
C
C LEVEL 14      LOGICAL FUNCTION DOMAG2((NN,MODE,IPARS)
      LOGICAL FUNCTION DOMAG2(NN,MODE,IPARS)
C
C *** DOMAG2 updated PJB C4.26 March 2013 ***
C
CX
CC 17B
CH Multiple entry subroutine to deal with magnetic
CH variables in magnetic structure refinements
CD DOMAG2 is a logical function which follows the structure of the prototype
CD functions for least squares parameters. It has 2 dummy
CD arguments. NN transmits information and MODE indicates what function
CD is required. The function returns TRUE if it has dealt with the call.
C
CP It is assumed that IFAM, IGEN and ISPEC are set in the COMMON NEWOLD
CA On entry MODE indicates action required:
CA          MODE = 1 Determine symmetry constraints
CA                   NN is not used.
CA          MODE = 2 Set Variable pointers
CA                   NN is the variable number
CA          MODE = 3 Apply shifts, one parameter per entry.
CA                   NN is not used
CA          MODE = 4 Write new Q card (one per entry)
CA                   NN is the serial number of the letter labelling the card to
CA                   rewrite
CA          MODE = 5 Recalculate vector components and possible new constraints
CA                   at the end of a least squares cycle
CA          MODE = 6 Blanket fix or vary to deal with groups of parameters
CA                   identified as PSIS, ANGS, MUS, or MPAR when the
CA                   genus is given
CA          MODE = 7 Blanket fix or vary as obove to apply to all atoms
CA          MODE = 8 Not used no clearing up to do
CC
C109 Range added to EXTERNAL to avoid conflict with intrinsic function
      EXTERNAL DFLTMG,PARRUN,VARSMG,RANGE,DOINC2
C4.26 IPARS needed to fill range of variables for blanket entries to DOMAG2
      DIMENSION IPARS(4)
      LOGICAL DOINC2
/ATNAM/
/CARDRC/
/FONAM/
/MAGDAT/
/NEWOLD/
/NSYM/
/POSNS/
/REFINE/
/SCRACH/
/SYMMAG/
%      DATA NSTYPE,NPSI/8,%PSIS%/
C
      IF (CPVEC) THEN
         DOMAG2=DOINC2(NN,MODE,IPARS)
         GO TO 100
      ENDIF
      IF (MODE .EQ.1) GO TO 1
      IF (MODE .EQ.4) GO TO 40
      IF (MODE .EQ.2 .AND. NN.EQ.0) GO TO 20
      IF (MODE .EQ.5 .AND. NN.EQ.0) GO TO 50
      IF (MODE .EQ. 6 .OR. MODE .EQ.7) THEN
C      THIS IS A BLANKET SPEC
        IF (IFAM .GT. -8 .OR. IFAM .LT.-11) GO TO 99
        GO TO (60,70),MODE -5
      ENDIF
C Only MAGNETIC pars from family 2 now dealt with
      IF (IFAM .NE. 2) GO TO 99
      IF (ISPC .LT.13 .OR. ISPC .GT. 18+NPSI) GO TO 99
      GO TO (1,20,30,40), MODE
      GO TO 99
C
C  SET UP CONSTRAINTS
    1 CALL MAGCNL
      GO TO 101
C
   20 IF (NN .EQ. 0) THEN
C ENTRY 0 IS TO FIX ALL PARAMETERS:
        CALL JGMZER(KSMOD,2,NMAG)
        CALL JGMZER(KANGM,4,NMAG)
%        CALL JGMZER(KPHIH,%PSIS%,NMAG)
      ELSE
C RECORD ONE VARIABLE:
        IF (IFAM .NE. 2) GO TO 99
        IM=MAGAT(IGEN)
        IF (IM.EQ.0) GO TO 99
        IF (ISPC .GE. 13 .AND. ISPC .LE. 16) THEN
          KPHIH(ISPC-12,IM)=NN
        ELSE IF (ISPC .GE. 17 .AND. ISPC .LE. 20) THEN
          KANGM(ISPC-16,IM)=NN
        ELSE IF (ISPC .GE. 21 .AND. ISPC .LE. 22) THEN
          KSMOD(ISPC-20,IM)=NN
        ELSE
          GO TO 99
        ENDIF
      ENDIF
      GO TO 101
C
C  APPLY SHIFTS:
   30 IF (IFAM .NE.2) GO TO 99
      IP=MAGAT(IGEN)
       IF (IP.EQ.0) GO TO 99
      J=ISPC-12
      IF (J.GT.6+NPSI) GO TO 99
      IF (J.LE.NPSI) GO TO 33
      J=J-NPSI
      IF (J.GT.6) GO TO 99
      IF (J.LE.4) GO TO 21
      J=J-4
      GO TO 22
C
   21 CALL ADJUST(ANGM(J,IP))
      ANGM(J,IP)=RANGER(ANGM(J,IP),180.,-180.)
      XNEW=ANGM(J,IP)
      GO TO 101
C
   22 CALL ADJUST(SMOD(J,IP))
      GO TO 101
C
   33 CALL ADJUST(PHIH(J,IP))
      GO TO 101
C
C  WRITE NEW Q CARDS
   40 IF (NN .NE. LETTER('Q')) GO TO 99
      CALL INPUTQ(0,NTYP,JAT,IPT,IE)
      IF (NTYP.EQ.2) THEN
        CALL PROPAG(4,NEWIN)
        GO TO 101
      ENDIF
      IF (NTYP.LT.6) GO TO 41
      IAT=MAGAT(JAT)
      IP=2
      IF (MTYP.EQ.3) IP=4
      IM=IP/2
      IF (NTYP.EQ.8) THEN
        NPH=NPHI(IAT)
        DO 42 J=1,NPH
        LP=LPHI(J,IAT)
        IF (LP.GT.NOPC) LP=-1
        WRITE (ICARD(IPT:),214) LP,PHIH(J,IAT)
  214 FORMAT (I5,F10.4)
        IPT=IPT+15
   42   CONTINUE
      ELSE IF (NTYP.EQ.7) THEN
        WRITE (ICARD(IPT:),213) (ANGM(J,IAT),J=1,IP)
  213   FORMAT (4F10.4)
      ELSE IF (NTYP.EQ.6) THEN
        WRITE (ICARD(IPT:),213) (SMOD(J,IAT),J=1,IM)
      ENDIF
  41  WRITE (NEWIN,209) (ICARD(I:I),I=1,LENGT(ICARD))
  209 FORMAT (80A1)
      GO TO 101
C
C  RECALCULATE SPIN VECTORS
   50 DO 51 IM=1,NMAG
      CALL SPHPOL(ANGM(1,IM),ANGM(2,IM),SPIND(1,1,1,IM),3)
      IF (HELI) THEN
        CALL SPHPOL(ANGM(3,IM),ANGM(4,IM),SPIND(1,1,2,IM),3)
        CALL SPHELI(IM,2)
      ENDIF
   51 CONTINUE
      GO TO 101
C
C Blanket name PSiS NN = 8 ANGS NN = 9 MUS NN=10 MPAR NN = 11 GIVEN GENUS
   60 iF (IGEN.EQ.0) GO TO 99
      IPARS(2) = IGEN
      GO TO 71
C Blanket namE ALL ATOMS
   70 IPARS(2) = 0
   71 II = IABS(NN)
      IPARS(1)=2
C      FX = (NN .GT.0)
      IF (II .EQ. 8) THEN
        IPARS(3) = 13
        IPARS(4) = 12+NPSI
      ELSE IF (II.EQ.9) THEN
        IPARS(3) = 12+NPSI+1
        IPARS(4) = IPARS(3)+ 2
C        if (MODUL) ilast=ilast+2
      ELSE IF (II.EQ.10) THEN
        IPARS(3) = 12+NPSI+5
        IPARS(4) = IPARS(3)+1
C        if (MODUL) ilast=ilast+1
      ELSE IF (II.EQ.11) THEN
        IPARS(3) = 13
        IPARS(4) = 12+NPSI+6
      ELSE
        GO TO 99
      ENDIF
C      CALL FIXVAR(FX,2,IG,I,KPHASE,KSOURC,4)
      GO TO 101
   99 DOMAG2 = .FALSE.
      GO TO 100
  101 DOMAG2 = .TRUE.

  100 RETURN
      END
C
C
C
C
C LEVEL 14      LOGICAL FUNCTION DOMPL2(NN,MODE)
      LOGICAL FUNCTION DOMPL2(NN,MODE)
C
C *** DOMPL2 new by PJB C139 July-4-2005 ****
C Replaces various special MP subroutines
C
CC 18B
CH Logical multi-purpose function to deal with multipole
CH variables in least squares structure refinements
CD DOMPL2 follows the structure of the prototype
CD function for least squares parameters. It  has 2 dummy
CD arguments. NN transmits information, MODE indicates what function
CD is required the function returns TRUE if the routine dealt with
CD the call.
CP It is assumed that IFAM, IGEN and ISPC have been into common NEWOLD
CA On entry MODE indicates action required:
CA          MODE = 1 Determine symmetry constraints
CA                   NN is not used
CA          MODE = 2 Set Variable pointers
CA                   NN is the variable number
CA          MODE = 3 Apply shifts, one parameter per entry.
CA                   NN is not used
CA          MODE = 4 Write new Q card (one per entry)
CA                   NN is the serial number of the letter on the card to
CA                   rewrite.
CA          MODE = 6 Blanket fix or vary for genus given
CA          MODE = 7 Blanket fix or vary for  all MPOL
CA          MODE = 8 Clear up and print multipole shifts
C
      CHARACTER *4 LNAM1,LNAM2
      CHARACTER *32 VFORM
/CARDRC/
      COMMON /DOMPL/JCOUNT
/IOUNIT/
/MPODA/
/NEWOLD/
/PHASE/
/POSNS/
/REFINE/
/SCRACH/
/SOURCE/
/SYMDA/
C
      IFN=IFAM
      IG=IGEN
      ISP=ISPC
      IF (MODE.EQ.1) GO TO 1
      IF (MODE .EQ.4) GO TO 40
      IF (MODE .EQ.2 .AND. NN.EQ.0) GO TO 20
      IF (MODE.EQ.8 .AND. NN.EQ.5) GO TO 80
C Only family 5 multpoles dealt with
      IF (IFAM .NE. 5) GO TO 99
      GO TO (1,22,30,40,99,60,70), MODE
      GO TO 99

C ENTRY 1 TO SET CONSTRAINTS (
    1 IF (MAG) CALL MAGCNL
C Not used for multipoles, constraints set elsewhere
      GO TO 99
C Return false to ensure other constraints are set
C
C ENTRY 2 TO SET VARIABLES
C INITIALISE KMPOL FOR ALL MULTIPOLES :
   20 DO 21 I=1,NMPOL
   21 KPOLMP(I)=0
C RETURN FALSE SO THAT OTHER VARIABLES WILL BE SET
      GO TO 99
C RECORD ONE VARIABLE:
   22 KPOLMP(ISPC)=NN
      GO TO 101
C
C  APPLY SHIFTS:
C PRINT ANY REMNANTS FROM BUFFER:
   30 IF (NN .EQ.1) THEN
        CALL PRBLOK
        CALL MESS(LPT,1,'Multipole parameter shifts:')
        CALL MESS(LPT,0,'  Variable      New'//
     & '       Esd      Shift      Old     Shift/Esd')
      ENDIF
      POLAMP(ISPC,4)=SHIFT
      POLAMP(ISPC,6)=ESD
      GO TO 101
C
C  WRITE NEW J CARDS
   40 IF (NN .NE.LETTER('J')) GO TO 99
      JCOUNT = JCOUNT+1
      CALL RDWORD(LNAM1,LEN,3,IPT,80,0,IER)
      CALL RDWORD(LNAM1,LEN,IPT,IPT,80,0,IER)
      IF (LNAM1 .NE. 'MPOL') WRITE (NEWIN,2000)
     &(ICARD(I:I),I=1,LENGT(ICARD))
2000  FORMAT (80A1)
      Jc = jcount
      jj = ICDNO(NN)
      IF (JCOUNT.GE. ICDNO(NN)) THEN
C ONLY WRITE NEW ONES WHEN ALL THE OLD HAVE BEEN READ
        CALL JMPOL
        JCOUNT=0
      ENDIF
      GO TO 101
C
C Blanket names not yet defined
   60 GO TO 99
   70 GO TO 99
C
C  CLEAR UP AND PRINT MULTIPOLE PARAMETERS
   80 CALL CONVMP(2)
C
C APPLY ALL USER SHIFTS TO USER VALUES:
      IFAM=5
      IGEN=1
      DO 81 ISPC=1,NMPOL
      IF (KPOLMP(ISPC) .EQ. 0) GO TO 81
      SHIFT=POLAMP(ISPC,3)
      ESD=POLAMP(ISPC,5)
      CALL ADJUST(POLAMP(ISPC,1))
      CALL FETSHF(2,SHIFT,ESD)
      CALL PARNAM(LNAM1,LNAM2,3,KPAK(5,1,ISPC,0,0))
      WRITE (VFORM,2001) NSIGFG(ESD)
      WRITE (LPT,VFORM) LNAM1,LNAM2,XNEW,ESD,SHIFT,XOLD,SHESD
2001  FORMAT ('(2X,A4,1X,A4,4F10.',I1,'F10.3)')
   81 CONTINUE
C
C CONVERT NEW USER VALUES TO NEW PROGRAM VALUES:
      CALL CONVMP(1)
      GO TO 101


   99 DOMPL2 = .FALSE.
      GO TO 100
  101 DOMPL2 = .TRUE.

  100 RETURN
      END
C
C
C
C
C LEVEL 14      LOGICAL FUNCTION DOPOPS(NN,MODE)
      LOGICAL FUNCTION DOPOPS(NN,MODE)
C
C ***  DOPOPS Corrected by PJB C4.19 March 2010 ***
C
CC 17B
CH Routine to process domain populations in multi-source LSQ
CA On entry MODE indicates action required:
CA MODE = 1 with NN > 0 sets NDOMs=NN, determines the number of FAM 3 species
CA                      needed for scales and domain pops and creates their
CA                      names. Sets NEED and MISS for each source to control
CA                      how many species each source has.
CA          with NN = 0 Permanently fixes parmeters for non-existent species
CA MODE=2   with NN = 0 fixes all possible scales and domain populations
CA          with NN > 0 sets the domain population for source IGEN and numbered
CA                      ISPC as the variable NN.(IGEN and  ISPC in /NEWOLD/)
CA MODE=3 applies a shift to the population of the domain ISPC for source IGEN
CA        (IGEN and  ISPC in /NEWOLD/).
CA MODE=4 writes out new L SORC DPOP cards to unit NEWIN.
CA          NN  is the number of the intial letter on the card to be treated.
CA MODE = 5 Not used
CA MODE = 6 Blanket fix or vary to deal with groups of parameters
CA                   identified as DPOP or SCAL when the genus (data source)
CA                   is given
CA MODE = 7 Blanket fix or vary as obove to apply to all sources
CA MODE = 8 Not used no clearing up to do
C
CD Returns true if the routine can treat this card
CP IFAM, IGEN and ISPC must have been set in common /NEWOLD/.
C
      DIMENSION MISS(4),NEED(4),ISPEC(3)
      CHARACTER *4 LWD
      LOGICAL FX
/DSOURC/
/NEWOLD/
/PHASE/
/SCLDAT/
/SCRACH/
/TWIN/
      SAVE MISS,NEED,NDOMS,NSMAX
C
      go to (1,20,30,40,99,60,70), MODE
      go to 99
C IF nn=0 Fix all nonexistent parameters

C determine MISS and the number of scales for each source
    1 IF (NN.EQ.0) GO TO 5
      NDOMS=NN
      NSMAX=0
      NUM=0
      DO 2 J=1,NUMSRC
      CALL NDPOPS(MSRC(2,J),NEED(J),MISS(J))
      NEED(J)=NEED(J)*MISS(J)
      NUM=IPSCAL(J)-NUM
      IF (NUM.GT.NSMAX) NSMAX=NUM
    2 CONTINUE
      ISPEC(1)=3
      ISPEC(2)=0
      ISPEC(3)=0
C MAKE THE DPOP AND SCAL NAMES
      DO 3 I=1,NDOMS
      ISPEC(3)=ISPEC(3)+1
      WRITE (LWD,1000) 'DP',I
 1000 FORMAT (A2,I2.2)
      CALL VOCAB(LWD,ISPEC,1)
    3 CONTINUE
      DO 4 I=1,NSMAX
      ISPEC(3)=ISPEC(3)+1
      WRITE (LWD,1000) 'SC',I
      CALL VOCAB(LWD,ISPEC,1)
    4 CONTINUE
      NN=ISPEC(3)
      GO TO 101
C
C FIX ALL NONEXISTENT PARAMETERS
    5 IFAM=3
      IP=0
      DO 6 JS=1,NUMSRC
      IGEN=JS
      IF (MISS(JS).NE.1) THEN
        DO 7 IS=2,NEED(JS),2
        CALL ADDFX5(IFAM,IGEN,IS,1,1,5)
    7   CONTINUE
      ENDIF
C FIX POSSIBLE 180 DEGREE DOMAINS IF THEY CAN'T BE DISTINGUISHED
      IF (NEED(JS) .LT. NDOMS) THEN
        DO 8 IS=NEED(JS)+1,NDOMS
        CALL ADDFX5(IFAM,IGEN,IS,1,1,5)
    8   CONTINUE
C4.19 IF ONLY ONE DOMAIN CAN BE DISTINGUISHED FIX ITS POP
      IF (NEED(JS) .EQ. 1) CALL ADDFX5(IFAM,IGEN,1,1,1,5)
      ENDIF
C SCALE FACTORS
      NS=IPSCAL(JS)-IP
      IP=IPSCAL(JS)
      DO 9 I=NS+1,NSMAX
      IS=I+NDOMS
      CALL ADDFX5(IFAM,IGEN,IS,1,1,5)
    9 CONTINUE
    6 CONTINUE
      GO TO 101
C
C ENTRY NN=0 IS TO FIX ALL PARAMETERS:
   20 IF (NN.EQ.0) THEN
C        write (6,1002) numsrc,ipdom(numsrc),
C     &  (kdpop(i),i=1,ipdom(numsrc))
C 1002 format('Entry 20 ',2i3,2x,12i4)
%        CALL JGMZER(KDPOP,%DOMS%,1)
        CALL JGMZER(KSCALE,IPSCAL(NUMSRC),1)
        go to 101
      ENDIF
C Which parameter ?
      IF (IFAM .NE.3) GO TO 99
      IP=0
      IF (ISPC .GT. NDOMS) THEN
        IF (IGEN .NE. 1) IP=IPSCAL(IGEN-1)
        IP=IP+ISPC-NDOMS
        KSCALE(IP)=NN
      ELSE
        IF (IGEN .NE. 1) IP=IPDOM(IGEN-1)
        IP=IP+(ISPC-1)/MISS(IGEN)+1
        KDPOP(IP)=NN
      ENDIF
      GO TO 101
C
   30 IF (IFAM .NE.3) GO TO 99
      IP=0
      IF (ISPC .GT. NDOMS) THEN
        IF (IGEN .NE. 1) IP=IPSCAL(IGEN-1)
        IP=IP+ISPC-NDOMS
        CALL ADJUST(SCALE(IP))
      ELSE
        IF (IGEN .NE. 1) IP=IPDOM(IGEN-1)
        IP=IP+(ISPC-1)/MISS(IGEN)+1
        CALL ADJUST(DPOP(IP))
      ENDIF
      GO TO 101
C
C WRITE NEW L SORC CARD
   40 IF (LETTER('L').NE.NN) GO TO 99
      IPT=INDEX(ICARD,'SORC')
      IF (IPT .EQ.0) GO TO 99
      JSRC=IGEN
      IPT=INDEX(ICARD,'DPOP')
      IF (IPT .EQ.0) GO TO 41
      IPT=IPT+4
      CALL LLDPOP(4,IPT)
      IF (IPT .LT.0) GO TO 99
      GO TO 101
   41 IPT=INDEX(ICARD,'SCAL')
      IF (IPT .EQ.0) GO TO 99
      IPT=IPT+4
      CALL LDSCAL(4,IPT)
      IF (IPT .LT.0) GO TO 99
      GO TO 101
C
C Blanket name SCAL NN = 12  DPOP NN = 13 GIVEN GENUS
   60 iF (IGEN.EQ.0) GO TO 99
      IG = IGEN
      GO TO 71
C
C Blanket name apply to all sources
   70 IG = 0
C II=12 means fix SCAL, 13 means fix DPOP
   71 II = IABS(NN)
      FX = (NN .GT.0)
      IF (II .EQ. 13) THEN
        IFIRST = 1
        ILAST = NDOMS
      ELSE IF (II.EQ.12) THEN
        IFIRST = NDOMS+1
        ILAST = IFIRST + NSMAX
      ELSE
        GO TO 99
      ENDIF
      DO 72 I=IFIRST,ILAST
      CALL FIXVAR(FX,3,IG,I,KPHASE,KSOURC,4)
   72 CONTINUE
      GO TO 101
C
   99 DOPOPS = .FALSE.
      GO TO 100
  101 DOPOPS = .TRUE.

  100 RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE DOSIDE(A,B,ISIDE,NR,NC,X,Y)
      SUBROUTINE DOSIDE(A,B,ISIDE,NR,NC,X,Y)
C
C *** DOSIDE 24 Nov 83 by JCM ***
C
CX
CC 5C
CH A specialist routine for contour plotting, to help to decide where a
CH contour crosses the side of a square.
C
      IF (ISIDE .NE. 1) THEN
        DO 3 I=2,ISIDE
        C=B
        B=A
   3    A=1.0-C
      ENDIF
      Y = FLOAT(NC-1) + A
      X = B + FLOAT(NR-1)
      RETURN
      END
C
C
C
C
C LEVEL 14      SUBROUTINE DOTWN1(MODE)
      SUBROUTINE DOTWN1(MODE)
C
C *** DOTWN1 modified by PJB May 2008 C4.9 ***
C
CX
CC 4A
CH Routine to read twin parameters
C
CA DOTWN1 MODE = 0 Rread twin matrices, don't expect TPOP (magnetic twinning)
CA        MODE = 1 Read twin matrices, and TPOP
CA        MODE = 2 Transformations to and from untwinned measurement axes

CD reads in R TMAT and R TPOP cards and fills in the COMMON block
CD /TWIN/.
C
      DIMENSION AXES(3,3),AX(3),PROD(3)
      CHARACTER *4 RWD
      logical gmsame
/CARDRC/
/CELPAR/
/IOUNIT/
/NEWOLD/
/POINTS/
/SCRACH/
/TWIN/
C
      IF (INREAD(18) .LT.0) THEN
        IF (MODE.EQ.2) GO TO 50
        GO TO 100
      ENDIF
C CHAECK THET THERE ARE  R CARDS
      INREAD(18)=-IABS(INREAD(18))
      ID=IABS(INREAD(18))
      NCARD=ICDNO(18)
      IF (NCARD.EQ.0)  THEN
        CALL ERRMES(2,1,'R TMAT and TPOP cards')
        GO TO 100
      ENDIF
C READ ALL THE R CARDS
      NTWIN = 0
      NPOP=0
      DO 1 ICD=1,NCARD
      CALL CARDIN(ID)
      ID=ID+NYZ
      CALL RDWORD(RWD,LEN,3,IPT,80,0,IER)
      IF (RWD .EQ.'TPOP') GO TO 2
      IF (RWD .NE.'TMAT') GO TO 1
      CALL ERRCHK(2,NTWIN,12,1,'Twin matrices')
      CALL RDNUMS(TWMAT(1,1,NTWIN),7,9,NUM,IER)
      IF (IER.NE.0) THEN
        CALL ERRMES(1,1,'Reading R TWIN card')
      ELSE IF (NUM .NE.9) THEN
        CALL ERRMES(1,1,'Need 9 numbers on R TWIN cards')
      ENDIF
      GO TO 1
C  TPOP
    2 IF (MODE .EQ.0) go to 1
      NLEFT=12-NPOP
      CALL RDNUMS(TWPOP(NPOP+1),7,NLEFT,NUM,IER)
      IF (IER.EQ.2) THEN
        CALL ERRIN2(12,1,'More than the maximum of',
     &  'TPOP values read')
        GO TO 1
      ENDIF
      IF (IER.NE.0) THEN
        CALL ERRMES(1,1,'Reading R TPOP card')
      ELSE
        NPOP=NPOP+NUM
      ENDIF
      GO TO 1
C
    1 CONTINUE
C4.7 Don't need TPOPS here if read from L SORC cards (Mode 0)
      IF (MODE .EQ.0) go to 6
      IF (NPOP.EQ.0) THEN
        CALL ERRMES(1,1,'No R TPOP card for twin populations')
        GO TO 100
      ELSE IF (NPOP.NE.NTWIN) THEN
        CALL ERRIN2(NTWIN1,1,'Need','numbers on R TPOP card(s)')
        GO TO 100
      ENDIF
C All read report them
    6 NL=NTWIN/3
      IF (MOD(NTWIN,3).NE.0) NL=NL+1
      NN=1
      WRITE (LPT,12)
   12 format (/"Twin Matrices:")
      DO 3 NM=1,NL
      NE=NN+2
      IF (NE.GT.NTWIN) NE=NTWIN
      WRITE (LPT,10) ('TMAT',N,(TWMAT(I,1,N),I=1,3),N=NN,NE)
   10 FORMAT (1x,3(A4,I3,' = ',3F7.3,2X))
      WRITE (LPT,11)((TWMAT(I,2,N),I=1,3),N=NN,NE)
      WRITE (LPT,11)((TWMAT(I,3,N),I=1,3),N=NN,NE)
   11 format (1x,4(10X,3F7.3,2X))
      IF (MODE .NE.0)
     &WRITE (LPT,13)('TPOP',N,TWPOP(N),N=NN,NE)
   13 FORMAT (1X,3(A4,I3,' = ',F8.4,15X))
      WRITE (LPT,11)
      NN=NE+1
    3 CONTINUE
      NTWN = NTWIN
C4.9 Check whethr any of the twin matrices are unit
      CALL GMUNI(AXES,3)
      DO 8 N=1,NTWIN
      TMUNIT=GMSAME(TWMAT(1,1,N),AXES,9,0.001)
      IF (TMUNIT) GO TO 100
    8 CONTINUE
      GO TO 100
C
C RECIP MEASUREMENT AXES
   50 CALL GMTRAN(TWMAT(1,1,1),AXES(1,1),3,3)
      DO 4 I=1,3
      AX(I)=VCTMOD(1.,AXES(1,I),2)
    4 CONTINUE
      J=2
      K=3
      DO 5 I=1,3
      PROD(I)=SCLPRD(AXES(1,J),AXES(1,K),2)/(AX(J)*AX(K))
      J=K
      K=I
    5 CONTINUE
C MAKE THE ORTHO MATRICES FOR THE UNTWINNED AXES
C NEED REAL COS ALPHA
C4.2 This matrix is used to relate the untwined UB to the twinned axes.
        COSALF=(PROD(2)*PROD(3))-PROD(1)
      CALL GMZER(TORTH(1,1,2),3,3)
      TORTH(1,1,2)=AX(1)
      CALL SINCOS(PROD(3),SANG,'DOTWN1')
      TORTH(2,1,2)=AX(2)*PROD(3)
      TORTH(2,2,2)=AX(2)*SANG
      COSALF=COSALF/SANG
      CALL SINCOS(PROD(2),SANG,'DOTWN2')
      COSALF=COSALF/SANG
      CALL SINCOS(COSALF,SINALF,'DOTWN3')
      TORTH(3,1,2)=AX(3)*PROD(2)
      TORTH(3,2,2)=-AX(3)*SANG*COSALF
      TORTH(3,3,2)=AX(3)*SANG*SINALF
      CALL GMEQ(TORTH(1,1,2),TORTH(1,1,1),3,3)
      CALL TRINV3(TORTH(1,1,1),D)
      WRITE (LPT,14)
   14 format (/' Orthogonal matrices for untinnned axes')
      WRITE (LPT,15) ((TORTH(I,1,K),I=1,3),K=1,2)
   15 FORMAT (' Direct:',3f8.4,'    Recip:',3f8.4)
      WRITE (LPT,16) (((TORTH(I,J,K),I=1,3),K=1,2),J=2,3)
   16 FORMAT (2('        ',3f8.4,'          ',3f8.4/)/)
      GO TO 100
C
  100 RETURN
      END
C
C
C
C
C LEVEL 14      LOGICAL FUNCTION DOTWN2(NN,MODE)
      LOGICAL FUNCTION DOTWN2(NN,MODE)
C
C *** DOTWN2 corrected by PJB Nov 2004 ***
C
CX
CC 7B
CH Routine to process twin parameters
C
CA MODE=2 sets the twin parameter TPOP(ISPC) (with ISPC in /NEWOLD/)
CA        as the variable NN.
CA MODE=3 applies a shift to the twin population TPOP(ISPC)(with ISPC
CA        in /NEWOLD/).
CA MODE=4 writes out a new R TPOP card to unit NEWIN.
CA        NN  is the number of the intial letter on the card to be treated.
C
CD Returns true if the routine can treat this card
CP IFAM, IGEN and ISPC must have been set in common /NEWOLD/.
C
/NEWOLD/
/SCRACH/
/TWIN/
C
      GO TO (101,20,30,40), MODE
      GO TO 99
C
   20 IF (NN .EQ. 0) THEN
C ENTRY 0 IS TO FIX ALL PARAMETERS:
%        CALL JGMZER(KTWPOP,%TWIN%,1)
      ELSE
        IF ((IFAM.NE.1) .OR. (IGEN .NE.3)) GO TO 99
        KTWPOP(ISPC)=NN
      ENDIF
      GO TO 101
C
   30 IF ((IFAM.NE.1) .OR. (IGEN .NE.3)) GO TO 99
      CALL ADJUST(TWPOP(ISPC))
      GO TO 101
C
   40 IF (LETTER('R').NE.NN) GO TO 99
      IF (ICARD(3:6) .EQ.'TPOP') THEN
        WRITE (NEWIN,400) (TWPOP(I),I=1,NTWIN)
  400 FORMAT ('R TPOP',12F8.4)
      ELSE
        WRITE (NEWIN,401) ICARD
  401 FORMAT (A80)
      ENDIF
      GO TO 101
C
   99 DOTWN2 = .FALSE.
      GO TO 100
  101 DOTWN2 = .TRUE.

  100 RETURN
      END
C
C
C
C
C LEVEL 6      SUBROUTINE DPLOT(XXIN,YYIN,LINE)
      SUBROUTINE DPLOT(XXIN,YYIN,LINE)
C
C *** DPLOT by PJB Apr 85 ***
C
CX
CC 14C
CH Does plotting in current coordinate system.
CA On entry:
CA     XXIN,YYIN give the target position.
CA     LINE controls the kind of line being drawn:
CA          If LINE = 0 pen is "up"
CA          If LINE = 1 a continuous line is drawn
CA          If LINE = 2 a dashed line is drawn
CA          If LINE>10 but <21 the symbol LINE-10 is drawn at intervals of
CA                     DASH in /ADASH/
CP COMMON /ADASH/ is used to remember what is happening for dashed lines
CP        X1,Y1=where pen went to.
CD The pen is moved from its current position to XXIN,YYIN.
C
/ADASH/
/PLTRAN/
C
      IF (LINE .LE. 1) GO TO 12
      ILINE=1
      IF (LINE.GT.10) ILINE=2
C  CHECK THAT THE SPACE HAS NOT CHANGED
      IF (IDSH.EQ.NSPCE) GO TO 10
C  MAKE A DUMMY CALL TO PLCONV
      CALL PLCONV(0.,0.,0,X,Y,3)
C  AND SET DTRAN FROM THE NEW PTRAN
      CALL GMEQ(PTRAN(1,1,2),DTRAN,2,2)
      IDSH=NSPCE
      GO TO 10
C
C NOT DASHING - RESET DASH COUNT - JOIN HERE IF DASHING AT CONTOUR START:
   12 II=3-LINE
      REM = 0.
      IPEN = 2
      CALL KANGA1 (XXIN,YYIN,II)
C FOR NOW - AS IPN IS NOT SET THIS CANNOT BE RIGHT, BUT OFFHAND I DON'T KNOW
C WHAT IT SHOULD BE:
C      IF (IPN .GT. 0) GO TO 100
      GO TO 101
C AVOID STORAGE OF X1,Y1 IF NOT DASHING, AND EXIT
C
C HERE FOR DASHED LINE:
C IF "DASHING" BUT ACTUALLY PEN UP, DO NOT COMPUTE DASHES, BUT DO ARRANGE TO
C STORE CURRENT POSITION IN X1,Y1:
C LENGTH OF LINE TO BE PLOTTED
   10 U = XXIN-X1
      V = YYIN-Y1
      ALEN = SQRT((U*DTRAN(1,1)+V*DTRAN(1,2))**2+(U*DTRAN(2,1)+V*DTRAN(2
     & ,2))**2)
C
C  DEAL WITH ANY PART LEFT FROM LAST ENTRY:
      BLEN = ALEN-REM
      IF (BLEN .LE.0.) GO TO 1
C  IN CASE THAT VECTOR IS LESS THAN REMAINING DASH LENGTH
C
C  REMAINDER OF PREVIOUS DASH:
      FRAC = REM/ALEN
      X = X1 + FRAC*U
      Y = Y1 + FRAC*V
      GO TO (4,5),ILINE
    4 CALL KANGA1(X,Y,IPEN)
      IPEN=5-IPEN
      GO TO 6
   5  CONTINUE
      CALL KANGA3(X,Y,DASH/5,LINE-10)
C
C  CALCULATE NUMBER OF DASHES:
    6 NUM = IFIX(BLEN/DASH)
      REM = FLOAT(NUM+1)*DASH-BLEN
      IF (NUM .EQ.0) GO TO 2
      FRAC = DASH/ALEN
C
C  DO DASHES:
      DO 3 I=1,NUM
      X = X+FRAC*U
      Y = Y+FRAC*V
      GO TO (7,8),ILINE
    7 CALL KANGA1(X,Y,IPEN)
C  CHANGE MODE:
      IPEN = 5-IPEN
      GO TO 3
   8  CONTINUE
      CALL KANGA3(X,Y,DASH/5,LINE-10)
    3 CONTINUE
      GO TO 2
C
    1 REM = -BLEN
C  FINISH OFF
    2 IF (ILINE.EQ.2) GO TO 101
      CALL KANGA1(XXIN,YYIN,IPEN)
 101  X1=XXIN
      Y1=YYIN
      RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE DUMMY
      SUBROUTINE DUMMY
C
C *** DUMMY by JCM 21 Mar 89 ***
C
CC 16C
CH Does absolutely nothing;  used as a default in routine calls.
CD The only way we can avoid unnecessary routines being loaded is to
CD pass their names through the system as arguments of other routines.
CD Sometimes we wish to set such arguments to avoid doing anything.
C
      RETURN
      END
C
C
C
C
C LEVEL 3      SUBROUTINE EA06C(A,VALUE,VECTOR,M,IA,IV,W)
      SUBROUTINE EA06C(A,VALUE,VECTOR,M,IA,IV,W)
CX
CC 9C
CH Harwell routine to Find the eigenvalues and eigenvectors of a real
CH symmetric matrix A
CA On entry A is 2-dimensional matrix with 1st dimension IA, containing
CA          the lower triangle (A(I,J) I>=J) of the matrix
CA          M is the order of the matrix
CA On exit  the vector VALUE ocontains the eigen values
CA          the 2-dimensional matrix with 1st dimension IX contains the
CA          normalised eighenvectors. The vector (X(J,I),J=1,M) is the
CA          eigenvector with eigenvalue VALUE(I).
CA W is a real array of length at least 5M to be used as working space
C
C######DATE   01 JAN 1984     COPYRIGHT UKAEA, HARWELL.
C######ALIAS EA06C
C###### CALLS   EA08    MC04
C
      REAL              A,PP,VALUE,VECTOR,W
      REAL             ZERO,AIW,ONE
      DIMENSION A(IA,M),VALUE(M),VECTOR(IV,M),W(*)
      DATA ZERO/0.0E0/,ONE/1.0E0/
      DO 1000 I=1,M
      DO 1010 J=1,M
      VECTOR(J,I)=ZERO
1010  CONTINUE
      VECTOR(I,I)=ONE
1000  CONTINUE
      M1=M+1
      M2=M1+M
      W(1)=A(1,1)
      IF(M-2)60,10,15
10    W(2)=A(2,2)
      W(4)=A(2,1)
      GO TO 60
   15 CALL MC04B (A,W,W(M1),M,IA,W(M2))
   60 CALL EA08C (W,W(M1),VALUE,VECTOR,M,IV,W(M2))
      IF(M.LE.2)RETURN
      M22=2*M
      CALL EA06D (VECTOR,IV,M)
      DO 56 I=M-2,1,-1
      IF(W(M1+I).NE.ZERO)THEN
        AIW=ONE/(A(I,I+1)*W(M1+I))
        DO 61 IDA=I+1,M
        W(IDA)=A(I,IDA)
   61   CONTINUE
        DO 58 L=1,M
        PP=ZERO
        DO 210 IDA=I+1,M
        PP=PP+W(IDA)*VECTOR(L,IDA)
  210   CONTINUE
        PP=PP*AIW
        DO 100 IDA=I+1,M
        VECTOR(L,IDA)=VECTOR(L,IDA)+PP*W(IDA)
  100   CONTINUE
   58   CONTINUE
      ENDIF
   56 CONTINUE
      CALL EA06D (VECTOR,IV,M)
      RETURN
      END
C
C
C
C

C LEVEL 1      SUBROUTINE EA06D(V,IV,M)
      SUBROUTINE EA06D(V,IV,M)
CX
CC 9C
CH  Harwell routine called by EA06C
      REAL             V(IV,M),X
      DO 1 I=1,M-1
      DO 2 J=I+1,M
      X=V(I,J)
      V(I,J)=V(J,I)
      V(J,I)=X
    2 CONTINUE
    1 CONTINUE
      RETURN
      END
C
C
C
C
C LEVEL 2      SUBROUTINE EA08C(A,B,VALUE,VEC,M,IV,W)
      SUBROUTINE EA08C(A,B,VALUE,VEC,M,IV,W)
CX
CC 9C
CH  Harwell routine to find the eigenvalues and eigenvector of a
CH  symmetric tridiagonal matrix.
CD  Uses qr iteration to find the eigenvalues and eigenvectors
CD  of the symmetric tridiagonal matrix whose diagonal elements are
CD  A(I),I=1,M and off-diagonal elements are B(I),I=2,M.  The array
CD  W is used for workspace and must have dimension at least 2*M.
C######DATE   01 JAN 1984     COPYRIGHT UKAEA, HARWELL.
C######ALIAS EA08C
C###### CALLS   EA09
      REAL             A,A11,A12,A13,A21,A22,A23,A33,A34,B,BB,CC,
     &        CO,EPS,ROOT,S,SI,SML,VALUE,VEC,V1,W,XAX,XX
      REAL             ZERO,ONE,SIM
      DIMENSION A(M),B(M),VALUE(M),VEC(IV,M),W(1)
      DATA A34/0.0E0/
      DATA ZERO/0.0E0/,ONE/1.0E0/
C     THIS USES QR ITERATION TO FIND THE EIGENVALUES AND EIGENVECTORS
C  OF THE SYMMETRIC TRIDIAGONAL MATRIX WHOSE DIAGONAL ELEMENTS ARE
C  A(I),I=1,M AND OFF-DIAGONAL ELEMENTS ARE B(I),I=2,M.  THE ARRAY
C  W IS USED FOR WORKSPACE AND MUST HAVE DIMENSION AT LEAST 2*M.
      EPS=5.9604646E-07
      SML=EPS*FLOAT(M)
      CALL EA09C (A,B,W(M+1),M,W)
C     SET VEC TO THE IDENTITY MATRIX.
      DO 5 I=1,M
      VALUE(I)=A(I)
      W(I)=B(I)
      DO 3 J=1,M
      VEC(J,I)=ZERO
    3 CONTINUE
      VEC(I,I)=ONE
    5 CONTINUE
      K=0
      IF(M.EQ.1)RETURN
      DO 200 N3=2,M
      N2=M+2-N3
C     EACH QR ITERATION IS PERFORMED OF ROWS AND COLUMNS N1 TO N2
      MN2=M+N2
      ROOT=W(MN2)
      DO 190 ITER=1,20
      BB=(VALUE(N2)-VALUE(N2-1))/2.0
      CC=W(N2)*W(N2)
      A22=VALUE(N2)
      IF(CC.NE.ZERO)A22=A22+CC/(BB+ SIGN(ONE,BB)* SQRT(BB*BB+CC))
      DO 125 I=1,N2
      MI=M+I
      IF( ABS(ROOT-A22).LE. ABS(W(MI)-A22))GO TO 125
      ROOT=W(MI)
      MN=M+N2
      W(MI)=W(MN)
      W(MN)=ROOT
  125 CONTINUE
      DO 130 II=2,N2
      N1=2+N2-II
      IF( ABS(W(N1)).LE.( ABS(VALUE(N1-1))+ ABS(VALUE(N1)))*SML)GOTO140
  130 CONTINUE
      N1=1
  140 IF(N2.EQ.N1) GO TO 200
      N2M1=N2-1
      IF(ITER.GE.3)ROOT=A22
      K=K+1
      A22=VALUE(N1)
      A12=A22-ROOT
      A23=W(N1+1)
      A13=A23
      DO 180 I=N1,N2M1
      A33=VALUE(I+1)
      IF(I.NE.N2M1)A34=W  (I+2)
      S= SIGN( SQRT(A12*A12+A13*A13),A12)
      SI=A13/S
      CO=A12/S
      SIM=-SI
      DO 160 JI=1,MIN0(M,I+K)
      V1=VEC(JI,I)
C     V2=VEC(JI,I+1)
      VEC(JI,I)=CO*VEC(JI,I)+SI*VEC(JI,I+1)
      VEC(JI,I+1)=CO*VEC(JI,I+1)+SIM*V1
  160 CONTINUE
      IF(I.NE.N1)  W(I)=S
      A11=CO*A22+SI*A23
      A12=CO*A23+SI*A33
      A13=SI*A34
      A21=CO*A23-SI*A22
      A22=CO*A33-SI*A23
      A23=CO*A34
      VALUE(I)=A11*CO+A12*SI
      A12=-(A11*SI+A12*CO)
      W(I+1)=A12
      A22=A22*CO-A21*SI
  180 CONTINUE
      VALUE(N2)=A22
  190 CONTINUE
      WRITE(6,195)
  195 FORMAT(48H1CYCLE DETECTED IN SUBROUTINE EA08 -STOPPING NOW)
      STOP
  200 CONTINUE
C     RAYLEIGH QUOTIENT
      DO 220 J=1,M
      XX=VEC(1,J)**2
      XAX=XX*A(1)
      DO 210 I=2,M
      XX=XX+VEC(I,J)**2
      XAX=XAX+VEC(I,J)*(2.0*B(I)*VEC(I-1,J)+A(I)*VEC(I,J))
  210 CONTINUE
      VALUE(J)=XAX/XX
  220 CONTINUE
      RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE EA09C(A,B,VALUE,M,OFF)
      SUBROUTINE EA09C(A,B,VALUE,M,OFF)
CX
CC 9C
CH Harwell routine used in solution of eigenvalue problem
CN Called by EC08C
C
C######DATE   01 JAN 1984     COPYRIGHT UKAEA, HARWELL.
C######ALIAS EA09C
      PARAMETER(ZERO=0.)
      REAL             A,A11,A12,A13,A21,A22,A23,A33,A34,B,BB,
     &               CC,CO,EPS,OFF,ROOT,S,SBB,SI,SML,VALUE,ONE
      DIMENSION A(M),B(M),VALUE(M),OFF(M)
      DATA A34/0.0E0/,ONE/1.0E0/
      EPS= 5.9604646E-07
      SML=EPS*FLOAT(M)
      VALUE(1)=A(1)
      IF(M.EQ.1)RETURN
      DO 10 I=2,M
      VALUE(I)=A(I)
10    OFF(I)=B(I)
C     EACH QR ITERATION IS PERFORMED OF ROWS AND COLUMNS N1 TO N2
      MAXIT=10*M
      DO 90 ITER=1,MAXIT
      DO 45 N3=2,M
      N2=M+2-N3
      DO 30 II=2,N2
      N1=2+N2-II
      IF( ABS(OFF(N1)).LE.( ABS(VALUE(N1-1))+ ABS(VALUE(N1)))*SML)GOTO40
30    CONTINUE
      N1=1
40    IF(N2.NE.N1) GO TO 50
   45 CONTINUE
      RETURN
C     ROOT  IS THE EIGENVALUE OF THE BOTTOM 2*2 MATRIX THAT IS NEAREST
C     TO THE LAST MATRIX ELEMENT AND IS USED TO ACCELERATE THE
C     CONVERGENCE
50    BB=(VALUE(N2)-VALUE(N2-1))/2.0
      CC=OFF(N2)*OFF(N2)
      SBB=ONE
      IF(BB.LT.ZERO)SBB=-ONE
      ROOT=VALUE(N2)+CC/(BB+SBB* SQRT(BB*BB+CC))
      N2M1=N2-1
      A22=VALUE(N1)
      A12=A22-ROOT
      A23=OFF(N1+1)
      A13=A23
      DO 80 I=N1,N2M1
      A33=VALUE(I+1)
      IF(I.NE.N2M1)A34=OFF(I+2)
      S= SIGN( SQRT(A12*A12+A13*A13),A12)
      SI=A13/S
      CO=A12/S
      IF(I.NE.N1)OFF(I)=S
      A11=CO*A22+SI*A23
      A12=CO*A23+SI*A33
      A13=SI*A34
      A21=CO*A23-SI*A22
      A22=CO*A33-SI*A23
      A23=CO*A34
      VALUE(I)=A11*CO+A12*SI
      A12=-(A11*SI+A12*CO)
      OFF(I+1)=A12
80    A22=A22*CO-A21*SI
   90 VALUE(N2)=A22
       WRITE(6,100)
  100 FORMAT(39H1LOOPING DETECTED IN EA09-STOPPING NOW )
      STOP
      END
C
C
C
C
C LEVEL 1      FUNCTION ELEMAT(ALSQ,MATSZ,I,J)
      FUNCTION ELEMAT(ALSQ,MATSZ,I,J)
C
C *** ELEMAT by JCM 16 Jul 87 ***
C
CX
CC 6C
CH Gets a matrix element from the triangular LSQ matrix.
CA ALSQ holds the symmetrical triangular LSQ matrix
CA MATSZ is its dimension
CA I,J ask for the particular element, as though ALSQ were square
CA ELEMAT is set on exit to the element I,J
CN ALSQ and MATSZ are passed through the whole of the LSQ system as arguments,
CN enabling MATSZ to be set and ALSQ to be dimensioned in MAIN programs.
C
%      DIMENSION ALSQ(MATSZ),MM(%BVAR%)
/MATDAT/
      EQUIVALENCE (MM(1),MATPNT(2))
C
      IND=MM(I)+J
      IF (J .LT. I) IND=MM(J)+I
      ELEMAT=ALSQ(IND)
      RETURN
      END
C
C
C
C
C LEVEL 4      SUBROUTINE EQOP(R,T,N,L)
      SUBROUTINE EQOP(R,T,N,L)
C
C *** EQOP by JCM 28 Jun 83 ***
C
CX
CC 1B
CH Checks whether a rotation matrix and a translation vector of a symmetry
CH operator are already in a list, and adds them if not.  Also finds
CH lattice translations.
CA On entry R holds a 3x3 rotation matrix (part of a space group symmetry
CA          operator)
CA          T holds a 1x3 translation vector for the same operator.
CA          N is the number of entries in the list in /SCRAT so far
CA          L is the number of non-primitive lattice vectors so far.
CA On exit N and or L may have been increased by 1.  N may also indicate
CA which element of TSYM matched R.
C
CD Checks whether R is already in table TSYM in /SCRAT.  If not, R and T are
CD added to TSYM and TTRANS in /SCRAT, and N is incremented.
CD
CD If R occurs in TSYM table, examines T in case it gives a new lattice
CD translation.  If it does, adds that to the permanent array ALAT in /SYMDA
CD and increments L. Returns pointer to matching TSYM in N.
CD
CD Checks are made that  N<=48 and L<=4.
C
      DIMENSION R(3,3),T(3)
%      COMMON /SCRAT/TSYM(3,3,%SY*2%),TTRANS(3,%SY*2%),
%     & MLTAB(%SY*2%,%SY*2%),VEC(3)
/SYMDA/
C
      NN=N
      DO 1 I=1,NN
      DO 2 J=1,3
      DO 3 K=1,3
      IF (ABS(TSYM(J,K,I)-R(J,K)) .GT..0001) GO TO 1
    3 CONTINUE
    2 CONTINUE
C
C MATRIX THE SAME - CHECK TRANSLATION VECTOR
      IS=0
      DO 4 K=1,3
      VEC(K) = AMOD(TTRANS(K,I)-T(K)+1.,1.)
      IF (VEC(K) .GT. .0001) IS=1
    4 CONTINUE
      IF (IS .EQ. 0) GO TO 6
      NL1 = L
      CALL EQPOS(ALAT,VEC,NL1,NL2,4)
      IF (NL2 .EQ. L+1) L = L+1
    6 N=I
      GO TO 100
    1 CONTINUE
C
C A NEW ROTATION MATRIX HAS BEEN FOUND:
%      CALL ERRCHK(2,N,%SY*2%,0,'symmetry operators')
      CALL GMEQ(R,TSYM(1,1,N),3,3)
      CALL GMEQ(T,TTRANS(1,N),1,3)
 100  RETURN
      END
C
C
C
C
C LEVEL 3      SUBROUTINE EQPOS(VEC1,VEC2,N1,N2,M)
      SUBROUTINE EQPOS(VEC1,VEC2,N1,N2,M)
C
C *** EQPOS updated by JCM 13 Apr 86 ***
C
CX
CC 11C
CH Checks whether the given atom position already occurs in a given list,
CH and adds the new one if not.
CA On entry VEC2 holds a 1x3 vector giving a real space postion.
CA          VEC1 is a table of 1x3 vectors, of size (3,M)
CA          N1 is the number of entries in VEC1 so far
CD Determines whether VEC2 occurs in VEC1, disregarding multiples of unit cells.
CD If VEC2 gives a new position it is added to the list VEC1 and N2 is set to
CD N1+1.  A check is made that the total number of positions does not exceed
CD M, the maximum allowed.
CD
CD All elements of VEC1 are put into the range 0 =< X <1.
CD
CD If VEC2 does occur in the list VEC1, N2 is set to its position there.
CN M must be at least 1.
C
      DIMENSION VEC1(3,*),VEC2(3)
/IOUNIT/
C
      IF (N1 .LT. 1) GO TO 4
      DO 1 I=1,N1
      DO 2 J=1,3
      A = AMOD(ABS(VEC1(J,I)-VEC2(J)),1.)
      IF ((A .GT. .0005) .AND. (A .LT. .9995))GO TO 1
    2 CONTINUE
C MATCH FOUND - JUMP:
      GO TO 101
    1 CONTINUE
C
C A NEW VECTOR FOUND IN VEC2 - STORE IT IN VEC1:
    4 I = N1+1
      IF (I .LE. M) GO TO 5
      WRITE (LPT,3000) M,((VEC1(J1,I1),J1=1,3),I1=1,M)
      WRITE (ITO,3000) M,((VEC1(J1,I1),J1=1,3),I1=1,M)
3000  FORMAT (/' ERROR ** more than',I3,' equivalent positions ',
     & 'found in EQPOS - list so far is:'/(1X,3F12.4))
      STOP
   5  CALL GMEQ(VEC2,VEC1(1,I),1,3)
      CALL FRAC3(VEC1(1,I))
 101  N2=I
      RETURN
      END
C
C
C
C
C LEVEL 3      SUBROUTINE EQPPOS(VEC1,VEC2,N1,N2,M)
      SUBROUTINE EQPPOS(VEC1,VEC2,N1,N2,M)
C
C *** EQPPOS corrected by PJB 31-May-1994 ***
C
CX
CC 11C
CH Checks whether the given position vector is related by lattice translation
CH to one already in the given list.
CA On entry VEC2 holds a 1x3 vector giving a real space postion.
CA          VEC1 is a table of 1x3 vectors, of size (3,M)
CA          N1 is the number of entries in VEC1 so far
CD Determines whether VEC2 occurs in VEC1, disregarding multiples of
CD lattice vectors.
CD If VEC2 gives a new position it is added to the list VEC1 and N2 is set to
CD N1+1.  A check is made that the total number of positions does not exceed
CD M, the maximum allowed.
CD
CD All elements of VEC1 are put into the range 0 =< X <1.
CD
CD If VEC2 does occur in the list VEC1, N2 is set to its position there.
CN M must be at least 1.
C
      DIMENSION VEC1(3,*),VEC2(3),TVEC(3)
      LOGICAL LATVEC
/IOUNIT/
C
      IF (N1 .LT. 1) GO TO 4
      DO 1 I=1,N1
      CALL GMSUB(VEC1(1,I),VEC2,TVEC,3,1)
      IF (LATVEC(TVEC)) GO TO 101
C MATCH FOUND - JUMP:
    1 CONTINUE
C
C A NEW VECTOR FOUND IN VEC2 - STORE IT IN VEC1:
    4 I = N1+1
      IF (I .GT. M) THEN
        WRITE (LPT,3000) M,((VEC1(J1,I1),J1=1,3),I1=1,M)
        WRITE (ITO,3000) M,((VEC1(J1,I1),J1=1,3),I1=1,M)
3000    FORMAT (/' ERROR ** more than',I3,' equivalent positions ',
     & 'found in EQPOS - list so far is:'/(1X,3F12.4))
        STOP
      ENDIF
C
      CALL GMEQ(VEC2,VEC1(1,I),1,3)
      CALL FRAC3(VEC1(1,I))
 101  N2=I
      RETURN
      END
C
C
C
C
C LEVEL 4      SUBROUTINE EQRLV(VEC1,VEC2,N1,N2,M)
      SUBROUTINE EQRLV(VEC1,VEC2,N1,N2,M)
C
C *** EQRLV by PJB Jun 88 ***
C
CX
CC 11C
CH Checks whether vectors differ by a reciprocal lattice vector.
C
CA On entry VEC1 holds a list of 1x3 vectors
CA          VEC2 holds a single 1x3 vector
CA          N1 is the number of vectors in the list VEC1
CA          M is positive if it is required to add VEC2 to list if unique.
CA On exit N2 points to the position of VEC2 in the list VEC1
CD Checks whether VEC2 is identical to, or differs by a reciprocal
CD lattice vector from any of the N1 vectors stored in VEC1.  If on entry
CD M>0 and if VEC2 is unique it is added to the list VEC1 and N2 is
CD set to N1+1; otherwise N2=which vector it matched.
CD
CD A check is made that the total number of vectors in VEC1 is <= M ,
CD the maximum allowed.
CD
CD If on entry M=0, N2 is set as above, but the new vector is not added to
CD the list.
C
      DIMENSION VEC1(3,*),VEC2(3),TVEC(3)
      LOGICAL LATABS
/IOUNIT/
C
      N=N1
      IF (N .LT. 1) GO TO 4
      DO 1 I=1,N
      CALL GMSUB(VEC1(1,I),VEC2,TVEC,3,1)
      IF (LATABS(TVEC)) GO TO 1
C HAVE FOUND DUPLICATE - IGNORE & SET N2 TO POINT TO IT:
      GO TO 101
   1  CONTINUE
C
C HAVE NEW VECTOR:
   4  I = N+1
      IF (M .EQ. 0) GO TO 101
      IF (I .LE. M) GO TO 5
      WRITE (LPT,3000) M,((VEC1(J,I),J=1,3),I=1,M)
      WRITE (ITO,3000) M,((VEC1(J,I),J=1,3),I=1,M)
 3000 FORMAT (' ERROR ** more than',I3,'equivalent vectors ',
     & 'formed - vectors so far are'/(1X,3E12.5))
      STOP
C
C TO STORE NEW VECTOR:
   5  CALL GMEQ(VEC2,VEC1(1,I),1,3)
 101  N2=I
      RETURN
      END
C
C
C
C
C LEVEL 2      SUBROUTINE EQVEC(VEC1,VEC2,N1,N2,M)
      SUBROUTINE EQVEC(VEC1,VEC2,N1,N2,M)
C
C *** EQVEC updated by JCM 22 Oct 86 ***
C
CX
CC 11C
CH Finds a given vector in given table of vectors, or adds it as a new one.
CA On entry VEC1 holds a list of 1x3 vectors
CA          VEC2 holds a single 1x3 vector
CA          N1 is the number of vectors in the list VEC1
CA          M is positive if it is required to add VEC2 to list if unique.
CA On exit N2 points to the position of VEC2 in the list VEC1
CD Checks whether VEC2 is identical to any of the N1 vectors stored in VEC1.
CD If on entry M>0 and if VEC2 is unique it is added to the list VEC1 and N2
CD is set to N1+1; otherwise N2=which vector it matched.
CD
CD A check is made that the total number of vectors in VEC1 is <= M ,
CD the maximum allowed.
CD
CD If on entry M=0, N2 is set as above, but the new vector is not added to
CD the list.
C
      DIMENSION VEC1(3,*),VEC2(3)
      LOGICAL GMSAME
/IOUNIT/
C
      N=N1
      IF (N .LT. 1) GO TO 4
      DO 1 I=1,N
      IF (.NOT. GMSAME(VEC1(1,I),VEC2,3,0.0001)) GO TO 1
C HAVE FOUND DUPLICATE - IGNORE & SET N2 TO POINT TO IT:
      GO TO 101
   1  CONTINUE
C
C HAVE NEW VECTOR:
   4  I = N+1
      IF (M .EQ. 0) GO TO 101
      IF (I .LE. M) GO TO 5
      WRITE (LPT,3000) M,((VEC1(J,I),J=1,3),I=1,M)
      WRITE (ITO,3000) M,((VEC1(J,I),J=1,3),I=1,M)
 3000 FORMAT (' ERROR ** more than',I3,'equivalent vectors ',
     & 'formed - vectors so far are'/(1X,3E12.5))
      STOP
C
C TO STORE NEW VECTOR:
   5  CALL GMEQ(VEC2,VEC1(1,I),1,3)
 101  N2=I
      RETURN
      END
C
C
C
C
C LEVEL 1      FUNCTION ERFNC(X)
      FUNCTION ERFNC(X)
C
C *** ERFNC by WIFD 22 Aug 85 ***
C
CX
CC 9C
CH Calculates the error function accurate to 3E-7, for + and - X.
CA On entry X is the argument at which the function is required.
CA On exit ERFNC holds the function.
CD See Abramovitz and Stegun p.299
C
      DATA A1,A2,A3/0.0705230784,0.0422820123,0.0092705272/
      DATA A4,A5,A6/0.0001520143,0.0002765672,0.0000430638/
C  THESE COEFFICIENTS WERE TAKEN FROM ABRAMOVITZ AND STEGUN P.299
C  AND GIVE ERFNC ACCURATE TO 3E-07 FOR BOTH +VE AND -VE X.
C
      Z= ABS(X)
      ZZ=Z*Z
      ZZZ=Z*Z*Z
      E= 1.0 +A1*Z +A2*ZZ +A3*ZZZ +A4*ZZ*ZZ +A5*ZZ*ZZZ +A6*ZZZ*ZZZ
      IF(E.LT.10.0) GO TO 1
      E=0.0
      GO TO 2
   1  E=1.0/E**16
      IF (E.LE.0.0) E=0.0
   2  IF (X.LT.0.0) E=2.0-E
C
      ERFNC=E
      RETURN
      END
C
C
C
C
C LEVEL 2      SUBROUTINE ERRATM(NAME,NACT,MESS)
      SUBROUTINE ERRATM(NAME,NACT,MESS)
C
C *** ERRATM by JCM 25 Sep 89 ***
C
CX
CC 13C
CH Writes an error message to say that the given name is not an atom name;
CH there is a choice of subsequent action.
CA On entry, NAME is the A4 non-atom name
CA On entry NACT says which action is required:
CA    NACT +ve means increase IERR in /CARDRC/ by 1, complain and exit
CA    NACT -ve means complain and exit
CA    NACT =0 means complain and stop
CA   IABS(NACT)=1 just gives atom name
CA   IABS(NACT)=2 also writes out ICARD from /SCRACH
CA On entry MESS is the message specific to this error state
CO Writes message on units LPT and ITO.
C
      CHARACTER *(*) MESS
      CHARACTER *4 NAME
/CARDRC/
/IOUNIT/
/SCRACH/
C
      L=LENGT(MESS)
      IF (NACT .GT. 0) IERR=IERR+1
      WRITE (LPT,3001) NAME,(MESS(I:I),I=1,L)
      WRITE (ITO,3001) NAME,(MESS(I:I),I=1,L)
3001  FORMAT (/' ERROR ** ',A4,' is not an atom name - on ',80A1)
      IF (IABS(NACT) .EQ. 2) THEN
        WRITE (LPT,2001) ICARD
        WRITE (ITO,2001) ICARD
2001    FORMAT (' Card says:'/1X,A80)
      ENDIF
C
      IF (NACT .EQ. 0) STOP
      RETURN
      END
C
C
C
C
C LEVEL 2      SUBROUTINE ERRCH2(WORD,NACT,MESS1,MESS2)
      SUBROUTINE ERRCH2(WORD,NACT,MESS1,MESS2)
C
C *** ERRCH2 by JCM 25 Sep 89 ***
C
CX
CC 13C
CH Write an error message which involves a given WORD between 2 messages;
CH there is a choice of subsequent action.
CA On entry, WORD is the A4 word to print
CA On entry NACT says which action is required:
CA    NACT +ve means increase IERR in /CARDRC/ by 1, complain and exit
CA    NACT -ve means complain and exit
CA    NACT =0 means complain and stop
CA Absolute values for NACT on entry are:
CA          1 means simply write MESS1, WORD, MESS2
CA          2 means follow these on the next line by ICARD
CA On entry MESS1 is the message before WORD
CA On entry MESS2 is the message after WORD
CP If ABS(NACT)=2, ICARD in /SCRACH/ must contain the A80 card read
CO Writes message on units LPT and ITO.
C
      CHARACTER *34 FORM
      CHARACTER *(*) MESS1,MESS2
      CHARACTER *(*) WORD
/CARDRC/
/IOUNIT/
/SCRACH/
      DATA FORM/'('' ERROR ** '',80A1,1X,A4 ,1X,80A1)'/
C
      LW=LENGT(WORD)
      IF (LW .EQ. 0) LW=1
      WRITE (FORM(24:25),2000) LW
      L1=LENGT(MESS1)
      IF (L1 .EQ. 0) L1=1
      WRITE (FORM(15:16),2000) L1
2000  FORMAT (I2)
      L2=LENGT(MESS2)
      IF (NACT .GT. 0) IERR=IERR+1
      WRITE (LPT,FORM) (MESS1(I:I),I=1,L1),WORD,(MESS2(I:I),I=1,L2)
      WRITE (ITO,FORM) (MESS1(I:I),I=1,L1),WORD,(MESS2(I:I),I=1,L2)
      IF (IABS(NACT) .EQ. 2) THEN
        WRITE (LPT,2001) ICARD
        WRITE (ITO,2001) ICARD
2001    FORMAT (' Card says:'/1X,A80)
      ENDIF
C
      IF (NACT .EQ. 0) STOP
      RETURN
      END
C
C
C
C
C LEVEL 2      SUBROUTINE ERRCHK(NTYP,NVALUE,NBOUND,NACT,MESS)
      SUBROUTINE ERRCHK(NTYP,NVALUE,NBOUND,NACT,MESS)
C
C *** ERRCHK by JCM 4 Oct 88 ***
C
CX
CC 13C
CH (Possibly increases and) checks a value, giving if appropriate an error
CH message;  there is a choice of subsequent action.
CA On entry NTYP=type of check required:
CA    NTYP=1 simply check NVALUE for being NOT GREATER THAN NBOUND
CA    NTYP=2 increment NVALUE by 1, then as type 1
CA On entry NVALUE is the integer to be checked
CA          NBOUND is its upper bound
CA On entry NACT says which action is required if the test fails:
CA    NACT +ve means increase IERR in /CARDRC/ by 1, complain and exit
CA    NACT -ve means complain and exit
CA    NACT =0 means complain and stop
CA On entry MESS is the message specific to this error state
C
CD The error message starts " ERROR ** ", and finishes with MESS.
CD If NTYP=1, NVALUE is printed.
CO Outputs the required message on units LPT and ITO
C
      CHARACTER *(*) MESS
/CARDRC/
/IOUNIT/
C
      IF (NTYP .NE. 1) NVALUE=NVALUE+1
      IF (NVALUE .LE. NBOUND) GO TO 100
C
      IF (NACT .GT. 0) IERR=IERR+1
      L=LENGT(MESS)
      IF (NTYP .EQ. 1) THEN
        WRITE (LPT,3001) NVALUE,(MESS(I:I),I=1,L)
        WRITE (ITO,3001) NVALUE,(MESS(I:I),I=1,L)
3001    FORMAT (/' ',I6,80A1)
      ENDIF
      WRITE (LPT,3000) NBOUND,(MESS(I:I),I=1,L)
      WRITE (ITO,3000) NBOUND,(MESS(I:I),I=1,L)
3000  FORMAT (/' ERROR ** there is an upper limit of',I6,
     & ' on number of ',80A1)
      IF (NACT .EQ. 0) STOP
 100  RETURN
      END
C
C
C
C
C LEVEL 2      SUBROUTINE ERRIN2(INT,NACT,MESS1,MESS2)
      SUBROUTINE ERRIN2(INT,NACT,MESS1,MESS2)
C
C *** ERRIN2 by JCM 25 Sep 89 ***
C
CX
CC 13C
CH Writes an error message which involves a given integer INT between 2
CH messages;  there is a choice of subsequent action.
CA On entry, INT is the integer to print
CA On entry NACT says which action is required:
CA    NACT +ve means increase IERR in /CARDRC/ by 1, complain and exit
CA    NACT -ve means complain and exit
CA    NACT =0 means complain and stop
CA   IABS(NACT)=1 means just give message
CA   IABS(NACT)=2 means also print contents of /SCRACH/
CA On entry MESS1 is the message before INT
CA On entry MESS2 is the message after INT
CO Writes message on units LPT and ITO.
C
      CHARACTER *33 FORM
      CHARACTER *(*) MESS1,MESS2
/CARDRC/
/IOUNIT/
/SCRACH/
      DATA FORM/'('' ERROR ** '',80A1,1X,I5,1X,80A1)'/
C
      L1=LENGT(MESS1)
      IF (L1 .EQ. 0) L1=1
      WRITE (FORM(15:16),2000) L1
2000  FORMAT (I2)
      L2=LENGT(MESS2)
      IF (NACT .GT. 0) IERR=IERR+1
      WRITE (LPT,FORM) (MESS1(I:I),I=1,L1),INT,(MESS2(I:I),I=1,L2)
      WRITE (ITO,FORM) (MESS1(I:I),I=1,L1),INT,(MESS2(I:I),I=1,L2)
C
      IF (IABS(NACT) .EQ. 2) THEN
        WRITE (LPT,2001) ICARD
        WRITE (ITO,2001) ICARD
2001    FORMAT (' Card says:'/1X,A80)
      ENDIF
      IF (NACT .EQ. 0) STOP
      RETURN
      END
C
C
C
C
C LEVEL 6      SUBROUTINE ERRMAP
      SUBROUTINE ERRMAP
C
C *** ERRMAP updated by JCM 14 Apr 89 ***
C
CX
CC 5B
CH Calculates the standard deviation of the density in a Fourier map.
CP The results are meaningless if DELTA, the resolution length, is zero.
CP Should be set up in the same way as FOUR1Z
C
CD Uses the same kind of data as FOUR1Z, the normal Fourier routine, but the
CD calculation is much slower.  One should therefore use a coarser sampling
CD grid. Experience shows that the results vary very little throughout the
CD unit cell.
CD
CD Assumes errors in non-equivalent reflections are independent and those in
CD related reflections the same.
CI Reads data from unit LUNI in FORMAT given by MODED in /MAPDA/
CN Old.
C
      DIMENSION FIN(4)
%      DIMENSION H(3,%SY*2%),EH(3),HI(3),K(3),SINCOX(100),SINCOY(100)
/CONSTA/
/IOUNIT/
/MAPDA/
/NSYM/
      COMMON /SCRAT/SUM(10201)
/SYMDA/
C
      NOBSIN=-1
      NUSED=0
      SCALEF=SCALF1*SCALF2
C
C     GET OUT THE SINES AND COSINES REQUIRED IN THE RECURSIONS.
      CALL TRIG(SINCOX,TWOPI*OUTLIM(3,1),(NH-1)/2+1)
      CALL TRIG(SINCOY,TWOPI*OUTLIM(3,2),NK)
C     CLEAR STORE FOR SUMS
      DO 1 I=1,NXY
      SUM(I) = 0.
    1 DENS(I) = 0.
C
C     READ REFLECTIONS FROM STREAM LUNI
C     MODED=1 H,K,L, FCAL,FOBS,DELF
C     MODED=2 H,K,L, ARG(FCAL),PHASE ANGLE,FOBS,DELF
C     MODED=3 H,K,L, A,B,FOBS,DELF
C     MODED=4 H,K,L, FOBS,DELF
   2  NOBSIN=NOBSIN+1
      CALL RDDATA(LUNI,K,HI,FIN,4,IOU)
      IF (IOU .EQ. -9999) GO TO 7
C     SWITCH ACCORDING TO FORMAT OF REFLECTION CARDS (MODED)
      GO TO (3,4,4,5), MODED
   3  F=FIN(2)
      SF=FIN(3)
      GO TO 6
C
   4  F=FIN(3)
      SF=FIN(4)
      GO TO 6
C
   5  F=FIN(1)
      SF=FIN(2)
C     ABSOLUTE PHASE DOESN'T MATTER AS TERMS ARE TO BE SQUARED
C     TEST FOR 0 0 0 REFLECTION
    6 IF ((K(1).EQ.0) .AND. (K(2).EQ.0) .AND. (K(3) .EQ.0)) GO TO 8
      IF (VCTMOD(0.5,HI,2) .GT. SMAX) GO TO 2
C     MULTIPLY BY 2 BECAUSE WE ASSUME -H,-K,-L, IS NOT GIVEN AND WILL
C     NOT BE GENERATED IF NCENT=2
      NUSED=NUSED+1
      SF = 2.*SF*RESOL(HI,DELTA)*SCALEF
      DO 26 N = 1,NOPC
      CALL ROTSYM(HI,EH,N,2)
      IF (N .NE. 1) GO TO 44
      DO 45 I = 1,3
   45 H(I,1) = EH(I)
      MI = 1
      GO TO 46
  44  CALL EQVEC(H,EH,MI,M,NOP)
      IF (M .LE. MI) GO TO 26
      MI = M
   46 IF (NDIM .NE. 2) GO TO 27
C     SYMMETRY MATRICES ALREADY ROTATED TO AXES OF MAP
      IF (EH(3) .NE. 0) GO TO 26
   27 TRA = 0.
      DO 23 I = 1,3
      K(I) = JFIX(EH(I))
   23 TRA = TRA + EH(I)*(TRANS(I,N) - OUTLIM(1,I))
C     PHASE AT ORIGIN OF MAP
      TRA = TWOPI*TRA
C
C     NOW CALCULATE THE CONTRIBUTION FROM THIS REFLECTION AT ALL POINTS
      J = 2*IABS(K(1))+1
      SDX = SINCOX(J+1)
      CDX = SINCOX(J)
      IF (K(1) .GT. 0) SDX = -SDX
      J = 2*IABS(K(2))+1
      SDY = SINCOY(J+1)
      CDY = SINCOY(J)
      IF (K(2) .GT. 0) SDY = -SDY
      COX = COS(TRA)*SF
      SOX = SIN(TRA)*SF
      DO 30 IX = 1,NX
      I = IX
      SUM(I) = SUM(I) + COX
      COY = COX*CDY - SOX*SDY
      SOY = SOX*CDY + COX*SDY
      DO 31 IY = 2,NY
      I = I+NX
      SUM(I) = SUM(I) + COY
      SNEW = SOY*CDY + COY*SDY
      COY = COY*CDY - SOY*SDY
   31 SOY = SNEW
      SNEW = SOX*CDX + COX*SDX
      COX = COX*CDX - SOX*SDX
   30 SOX = SNEW
C
C     ACCUMULATE SUM OVER ALL EQUIVALENTS
   26 CONTINUE
C     NOW SQUARE SUM, ADD TO RESULT AND CLEAR FOR NEXT
      DO 32 I = 1,NXY
      DENS(I) = DENS(I) + SUM(I)**2
   32 SUM(I) = 0.
      GO TO 2
C     ADD CONTRIBUTION FROM 0,0,0 REFLECTION
    8 SF = (SF*SCALEF)**2
      DO 9 I = 1,NXY
    9 DENS(I) = DENS(I) + SF
      GO TO 2
C     HAVE RUN OUT OF REFLECTIONS ON STREAM LUNI
C     TAKE SQRT TO GET STANDARD DEVIATION
    7 DO 50 I = 1,NXY
   50 DENS(I) = SQRT(DENS(I))
      RETURN
      END
C
C
C
C
C LEVEL 2      SUBROUTINE ERRMES(NTYP,NACT,MESS)
      SUBROUTINE ERRMES(NTYP,NACT,MESS)
C
C *** ERRMES updated by PJB C118 Sept 2002 *** ***
C
CX
CC 13C
CH Writes an error message, with choice of action on exit.
CA On entry, NTYP=type of message:
CA      NTYP=0 If IERR not 0 write "Errors in input" followed by MESS and stop
CA      NTYP=1      write "ERROR **" followed by MESS
CA      NTYP=-1     write "PROGRAM ERROR **" followed by MESS
CA      ABS(NTYP)=2 write "ERROR ** need" followed by MESS
CA      ABS(NTYP)=3 write "ERROR ** need card" followed by MESS
CA      NTYP=4      write "WARNING **" followed by MESS
CA On entry NACT says which action is then required
CA    NACT +ve means increase IERR in /CARDRC/ by 1, complain and exit
CA    NACT -ve means complain and exit
CA    NACT =0 means complain and stop
CA On entry MESS is the message specific to this error state
CO Writes message on units LPT and ITO.
C
      CHARACTER *(*) MESS
/CARDRC/
/IOUNIT/
C
      L=LENGT(MESS)
      IF (NTYP .EQ. 0) THEN
        IF (IERR .NE. 0) THEN
          WRITE (LPT,3000) IERR,(MESS(I:I),I=1,L)
          WRITE (ITO,3000) IERR,(MESS(I:I),I=1,L)
3000      FORMAT (///' *** ',I4,' fatal error(s) in input ',80A1)
          STOP
        ELSE
         GO TO 100
        ENDIF
      ENDIF
C
      IF (NACT .GT. 0) IERR=IERR+1
      IF (NTYP .EQ. 1) THEN
      WRITE (LPT,3001) (MESS(I:I),I=1,L)
      WRITE (ITO,3001) (MESS(I:I),I=1,L)
3001  FORMAT (/' ERROR ** ',80A1)
C118 Warning message NTYP=4 implemented
      ELSE IF (NTYP .EQ. 4) THEN
      WRITE (LPT,3005) (MESS(I:I),I=1,L)
      WRITE (ITO,3005) (MESS(I:I),I=1,L)
3005  FORMAT (/' WARNING ** ',80A1)
      ELSE IF (IABS(NTYP) .EQ. 2) THEN
      WRITE (LPT,3002) (MESS(I:I),I=1,L)
      WRITE (ITO,3002) (MESS(I:I),I=1,L)
3002  FORMAT (/' ERROR ** need ',80A1)
      ELSE IF (IABS(NTYP) .EQ. 3) THEN
      WRITE (LPT,3003) (MESS(I:I),I=1,L)
      WRITE (ITO,3003) (MESS(I:I),I=1,L)
3003  FORMAT (/' ERROR ** need card ',80A1)
      ELSE IF (NTYP .EQ. -1) THEN
      WRITE (LPT,3004) (MESS(I:I),I=1,L)
      WRITE (ITO,3004) (MESS(I:I),I=1,L)
3004  FORMAT (/' PROGRAM ERROR ** ',80A1)
      ENDIF
C
      IF (NACT .EQ. 0) STOP
 100  RETURN
      END
C
C
C
C
C LEVEL 2      SUBROUTINE ERRRE2(X,NACT,MESS1,MESS2)
      SUBROUTINE ERRRE2(X,NACT,MESS1,MESS2)
C
C *** ERRRE2 by JCM 25 Sep 89 ***
C
CX
CC 13C
CH Writes an error message which involves a given real X between 2
CH messages;  there is a choice of subsequent action.
CA On entry, X is the real number to print
CA On entry NACT says which action is required:
CA    NACT +ve means increase IERR in /CARDRC/ by 1, complain and exit
CA    NACT -ve means complain and exit
CA    NACT =0 means complain and stop
CA   IABS(NACT)=1 means just give message
CA   IABS(NACT)=2 means also print contents of /SCRACH/
CA On entry MESS1 is the message before X
CA On entry MESS2 is the message after X
CO Writes message on units LPT and ITO.
C
      CHARACTER *36 FORM
      CHARACTER *(*) MESS1,MESS2
/CARDRC/
/IOUNIT/
/SCRACH/
      DATA FORM/'('' ERROR ** '',80A1,1X,G12.4,1X,80A1)'/
C
      L1=LENGT(MESS1)
      IF (L1 .EQ. 0) L1=1
      WRITE (FORM(15:16),2000) L1
2000  FORMAT (I2)
      L2=LENGT(MESS2)
      IF (NACT .GT. 0) IERR=IERR+1
      WRITE (LPT,FORM) (MESS1(I:I),I=1,L1),X,(MESS2(I:I),I=1,L2)
      WRITE (ITO,FORM) (MESS1(I:I),I=1,L1),X,(MESS2(I:I),I=1,L2)
C
      IF (IABS(NACT) .EQ. 2) THEN
        WRITE (LPT,2001) ICARD
        WRITE (ITO,2001) ICARD
2001    FORMAT (' Card says:'/1X,A80)
      ENDIF
      IF (NACT .EQ. 0) STOP
      RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE ESDFMT(X,DX,BUFF,IW)
      SUBROUTINE ESDFMT(X,DX,BUFF,IW)
C
CC 13A
C *** ESDFMT modified by PJB 14-Mar-96 ***
C
CH Writes X and its esd DX in the form X(DX)
C
CD A value X and its its ESD DX are written into the buffer BUFF in the form
CD X(DX) as often used in published tables.
CA X is the value and DX its standard deviation
CA BUFF is a character buffer to receive the result
CA IW is the maximum number of characters in BUFF to be used
C
      CHARACTER *(*) BUFF
      CHARACTER *40 VFMT
      LOGICAL TWOFIG
C
      DEL=ABS(DX)
      IF (DEL.LT.10E-10) THEN
        WRITE (VFMT,13) IW
   13 FORMAT ('(E',I2,'.4)')
        WRITE (BUFF,VFMT) X
        GO TO 100
      ENDIF
      ISIG=NINT(DEL)
      IF (ISIG.EQ.0) THEN
        IS=0
    1   IS=IS+1
        DEL=10.*DEL
        ISIG=NINT(DEL)
        IF (ISIG.EQ.0) GO TO 1
        JW=IW-3
        IF (JW.LT.3) GO TO 99
        WRITE (VFMT,10) JW,IS
   10 FORMAT ('(F',I2,'.',I1,',''('',I1,'')'')')
        WRITE (BUFF,VFMT) X,ISIG
      ELSE
        IS=1
    2   TWOFIG=(ISIG.GE.10)
        IS=IS+1
        IF (ISIG.GT.15) THEN
          DEL=DEL/10.
          ISIG=NINT(DEL)
          GO TO 2
        ENDIF
        IS=IS-1
        MUL=10**(IS-1)
        IF (TWOFIG) IS=IS+1
        IX=(NINT(X/FLOAT(MUL)))*MUL
        ISIG=ISIG*MUL
        JW=IW-2-IS
        IF (JW.LT.IS) GO TO 99
        WRITE (VFMT,11) JW,IS
   11 FORMAT ('(I',I2,',''('',I',I1,','')'')')
        WRITE (BUFF,VFMT) IX,ISIG
      ENDIF
      GO TO 100
   99 WRITE (BUFF,12) ('*',I=1,IW)
   12 FORMAT (80A1)
  100 RETURN
      END
C
C
C
C
C LEVEL 8	  FUNCTION ESDFOR(KPAR)
      FUNCTION ESDFOR(KPAR)
C
C *** ESDFOR new by PJB C4.26 March 2013 ***
C
CX
CC 6C
C
CH Returns the ESD of parameter KPAR
C
/DERBAS/
/MATDAT/
/NEWOLD/
/POINTS/
C
      ESDFOR=0
      IF (KPAR.LE.0) GO TO 100
      J=LVRBS(KPAR)
C IF VARIABLE IS BASIC:
      IF (J .GT. 0) THEN
        ESD=DERIVB(J)
      ELSE
        CALL SHFESD(-J)
      ENDIF
      ESDFOR=ESD
  100 RETURN
      END
C
C
C
C
C LEVEL 2      SUBROUTINE EULSYM(ANG,SYM,ROT)
      SUBROUTINE EULSYM(ANG,SYM,ROT)
C
C *** EULSYM by PJB ***
C
CX
CC 1B
CH Finds the Euler angles correponding to a symmetry rotation.
CA On entry SYM holds a 3x3 symmetry matrix
CA    ROT 3x3x2 contains the matrix relating the axes for the Euler rotations
CA        to the axes of the symmetry matrices and its inverse.
CA On exit ANG holds the corresponding Euler angles alpha,beta and gamma
CA        in radians.
C
      DIMENSION ANG(3),SYM(3,3),ORSYM(3,3),TEMP(3,3),ROT(3,3,2)
/CONSTA/
C
C TRANSFORM SYMMETRY ROTATIONS WITH MATRIX ROT
      CALL GMPRD(ROT(1,1,1),SYM,TEMP,3,3,3)
      CALL GMPRD(TEMP,ROT(1,1,2),ORSYM,3,3,3)
C
      IF (ABS(ABS(ORSYM(3,3))-1.).LT. .0001) THEN
        IF (ORSYM(3,3).LT.0.) THEN
          ANG(2)=PI
          ANG(3)=PI
        ELSE
          ANG(2)=0.
          ANG(3)=0.
        ENDIF
        ANG(1)=ATAN2(ORSYM(1,2),ORSYM(1,1))
      ELSE
        ANG(1)=ATAN2(ORSYM(3,2),ORSYM(3,1))
        ANG(3)=ATAN2(ORSYM(2,3),-ORSYM(1,3))
        IF (ABS(ORSYM(3,2)).LT.0.0001) THEN
          S=ORSYM(3,1)/COS(ANG(1))
        ELSE
          S=ORSYM(3,2)/SIN(ANG(1))
        ENDIF
        ANG(2)=ATAN2(S,ORSYM(3,3))
      ENDIF
      RETURN
      END
C
C
C
C
C LEVEL 1      LOGICAL FUNCTION EXCLD(A,B,M)
      LOGICAL FUNCTION EXCLD(A,B,M)
C
C *** EXCLD by JCM 17 Jan 85 ***
C
CX
CC 11C
CH Determines whether a number occurs within any of a set of given ranges.
CA On entry A is a single element.
CA          B is an array of M/2 pairs of numbers, B1 and B2 say.
CA            Each B1 must be < or = its own B2, but the B's need not all
CA            be in ascending order.
CA On exit EXCLD is.TRUE. if A occurs within any of the ranges B1 to B2,
CA            both inclusive.
C
CN If M should be 0 it should be given as 1
C
      DIMENSION B(M)
      EXCLD=.FALSE.
      IF (M .LT. 2) GO TO 100
      DO 1 I=2,M,2
      IF (A .LT. B(I-1)) GO TO 1
      IF (A .GT. B(I))   GO TO 1
      EXCLD=.TRUE.
      GO TO 100
   1  CONTINUE
 100  RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE EXPAND(IBUF,OBUF)
      SUBROUTINE EXPAND(IBUF,OBUF)
C
C *** EXPAND new by PJB Mar-28-1994 ***
CC 13C
CH Expands UNIX pathnames by substituting for environment variables
CA IBUF is a character variable containing the path name to be expanded
CA on output the character variable OBUF contains the expanded pathname
CN OBUF must be given a length by the calling program which is sufficient
CN to hold the expanded path
C
      CHARACTER *(*) IBUF,OBUF
C
      L=LENGT(IBUF)
      M=LEN(OBUF)
C
      I=1
      J=1
    1 IDOLL=INDEX(IBUF(I:),'$')
      IF (IDOLL.EQ.0) THEN
        OBUF(J:)=IBUF(I:L)
        GO TO 100
      ENDIF
      IP=IDOLL-1
      IF (IP.GT.0) OBUF(J:)=IBUF(I:I+IP-1)
      J=J+IP
      IF (IBUF(IP:IP).EQ.CHAR(92)) THEN
        OBUF(J:J)='$'
        J=J+1
        I=I+IP+2
      ELSE
        IP=IP+2
        DO 2 I=IP,L
        LET=LETTER(IBUF(I:I))
        IF (LET.GT.0) GO TO 2
        INT=NDIGIT(IBUF(I:I))
        IF (INT.GT.-1) GO TO 2
        GO TO 3
    2   CONTINUE
    3   CONTINUE
CS UNIX        CALL GETENV(IBUF(IP:I-1),OBUF(J:))
        J=LENGT(OBUF)
        J=J+1
        CALL ERRCHK(1,J,M,0,'Expanded path name too long')
      ENDIF
      IF (I.LE.L) GO TO 1
  100 RETURN
      END
C
C
C
C
C LEVEL 4      FUNCTION EXPINT(A,P,N,L)
      FUNCTION EXPINT(A,P,N,L)
C
C *** EXPINT by PJB Dec 84 ***
C
CX
CC 9C
CH Calculates an exponential radial integral.
CA On entry A, P N and L are set up for the routine to calculate the integral
CA between 0 and infinity of the Lth order spherical Bessel function of
CA A*X times X**N*exp(-P*X)
C
CD Uses hypergeometric series.
CN Used to calculate form-factors from Slater type wave-functions
      DIMENSION B(4)
      B(1) = FLOAT(N+L+3)
      B(2) = 0.5*FLOAT(L-N-1)
      B(3) = FLOAT(L) + 1.5
      EX = 2.0
      GAM = B(3)-1.0
      L1=L+1
      DO 5 I=1,L1
      EX = EX*GAM
   5  GAM = GAM-1.0
C
      EX = FACT(N+L+2)/EX
      IF (L .NE. 0) THEN
        X = (0.5*A)**L
        EX = EX*X
      ENDIF
      X = A*A + P*P
      B(1) = 0.5*B(1)
      EX = EX/(X**B(1))
      X = A*A/X
C
C     HYPERGEOMETRIC SERIES
      SUM = 1.
      TERM = 1.
      B(4) = 1.
    3 T = TERM
      TERM = TERM*B(1)*B(2)*X/(B(3)*B(4))
      SUM = SUM+ TERM
      E = ABS(TERM/SUM)
      IF (E .GT. .001) THEN
        DO 2 I = 1,4
    2   B(I) = B(I) + 1.0
        GO TO 3
      ENDIF
C
      EXPINT = EX*SUM
      RETURN
      END
C
C
C
C
C LEVEL 7      SUBROUTINE EXTINC(N,F)
      SUBROUTINE EXTINC(N,F)
C
C *** EXTINC Modified C141 February 2006 ***
C
CX
CC 2B
CH Multi-entry routine to deal with all aspects of single crystal extinction
CH corrections.
CA On entry N indicates action required:
CA     N=1 Read and interpret an E card
CA         (This is also ENTRY EXTIN1)
CA     N=2 Calculate an extinction correction, given F=mod(FC)
CA     N=3 as 2, and also calculate divided derivatives
CA     N=4 Apply shift to DOMR
CA     N=5 Apply shift to MOSC
CA         (These are also ENTRY EXTIN3(NP) where NP=1 for DOMR, 2 for MOSC)
CA     N=6 Output new E card
CA         (This is also ENTRY EXTIN4)
CA
CA     ENTRY EXTIN8(NP,NV) sets DOMR (NP=1) or MOSC (NP=2) to be variable NV
CA     ENTRY EXTIN9 sets both DOMR and MOSC fixed.
C
CD     Entry EXTPAR calculates the theta dependent extinction parameters for
CD     reflection H, WLGTH holds the wavelength and TM the mean pathlength
CD     ENTRY EXTALL calculates both the coefficients and the extinction.
CP Entries 2 through 6 require that the extinction is set up by an entry 1.
CP Entries 2 and 3 expect in the array CEXT in /EXTN/ the 4 coefficients as
CP described in Becker & Coppens (1974) Acta Cryst A30 p129.
CP Normally entry 3 would be from an LSQ job via CALCSF
CP          entries 4 & 5 from an LSQ job via APSHSF
CP          entry 6 from an LSQ job via NWINSF
C
CD Entry 1 reads DOMR and MOSC and IEXTYP into /EXTN, setting LOGICALS
CD         GAUSS and LOREN
CD Entry 2 calculates EXTCOR, which is SQRT(Y) in the theory above, using either
CD         the Lorenztian (IEXTYP=1) or Gaussian (IEXTYP=2) model.
C
CD Entry 3 calculates in addition the derivatives:
CD         DEX/DR (R is DOMR)   DEX/DG (G is MOSC) and DEX/DF (F is mod(FC))
CD         and all these are required divided by EX itself.  They are
CD         therefore put into variables ending Q for "quotient"
CO Entry 6 writes a new E card to unit NEWIN
C
CN If the path length is given in mm ,the wavelength and cell pars in
CN Angstroms and the scattering lengths in 10e-12cm then the domain radius
CN is in nanometres and the mosaic spread in inverse radians
C
C129 Change to put all dimensions into nanometres (10-9m)
C4.1 Correct dimensions and add extpar to extinc
      DIMENSION H(3),ABSC(3)
      LOGICAL TESTOV,DOALL
/ABSDAT/
/CELPAR/
/EXTN/
/NEWOLD/
C PSCALE SCALES CEXT(1) INTO THE RANGE 100 TO 0.01 (FOR READ/WRITE)
      DATA PSCALE,DOALL/10000.,.FALSE./
C
      GO TO (1,2,2,4,5,6) , N
C
      ENTRY EXTALL(H,F,N,WLGTH)
        DOALL=.TRUE.
        GO TO 20
      ENTRY EXTIN1
C
C READ E CARD:
   1  CALL INPUTE
      GO TO 100
C
C CALCULATE EXTCOR - WITH DERIVATIVES IF N=3:
   2  IF (IEXTYP .EQ. 0) GO TO 10
C140 TEST TO PREVENT OVERFLOW FOR ZERO F
      IF (TESTOV(1.,F)) GO TO 10
C129 Keep domr in nano metres
      A=1.5*DOMR/CEXT(2)
C A is now dimensionless
C129 conversion for scattering lengths squared
      FACB2 = 10.0E-10
      B=CEXT(1)*F*F*PSCALE*FACB2/(1.5)
C B should now be dimensionless
      C=1.5*AMOSC
      G=2.*AMOSC*AMOSC
C
      IF (LOREN) D=1./(1.+A/C)
      IF (GAUSS) D=1./(SQRT(1.+A*A/G))
C
      X=B*A*D
C129 XEXT now saved in common
      XEXT=X
      X2=2.*X
      XX=X*X
      C4=1.+CEXT(4)*X
      YY=1./(1.+X2+CEXT(3)*XX/C4)
      Y=SQRT(YY)
      EXTCOR=SQRT(Y)
      IF (N .EQ. 2) GO TO 100
C
C DERIVATIVES:
      IF (LOREN) FACTOR=1./C
      IF (GAUSS) FACTOR=A*D/G
      FACTOR=FACTOR*A*D
      DNUM=2.+X2*(2.*CEXT(4)+CEXT(3)) + CEXT(4)*XX*(2.*CEXT(4)+CEXT(3))
      E = -(YY*DNUM*X/(4.*C4*C4))
      DEXDRQ = E*(1.-FACTOR)/DOMR
      DEXDGQ = E*FACTOR/AMOSC
      DEXDFQ = E*2./F
      GO TO 100
C
C Entry EXTPAR to calculate theta dependent coefficients
C  THETA DEPENDENT PART OF EXTINCTION CONSTANTS
      ENTRY EXTPAR(H,WLGTH)
   20 VEC=VCTMOD(0.5,H,2)
C129 conversion Angstrom to nm
      FACANG=0.10
      ALAM3=(WLGTH)**3
      SINTH = WLGTH*VEC
      CALL SINCOS(SINTH,COSTH,'EXTCAL')
      SINTH = 2.*SINTH*COSTH
      COSTH = (2.*COSTH*COSTH) - 1.
      CON1 = ALAM3/((SINTH*V(1)**2)*(FACANG**3))
      CEXT(2) = FACANG*WLGTH/SINTH
      IF (LOREN) THEN
C EXTINCTION FOR LORENTZIAN DISTRIBUTION
        CEXT(3) = .025 + .285*COSTH
        IF (COSTH.GT.0) THEN
          CEXT(4) = 0.15 - 0.2*(0.75-COSTH)**2
        ELSE
          CEXT(4)= -(0.45*COSTH)
        ENDIF
      ELSE IF (GAUSS) THEN
C GAUSSIAN DISTRIBUTION
        CEXT(3) = 0.58+0.48*COSTH+0.24*(COSTH**2)
        CEXT(4) = 0.02-0.025*COSTH
      ENDIF
C
C129  ASSUME DIMENSIONS FOR G CARDS ARE mm
      FACMM=10.0E6
C4.1 Get path length of possible
      IF (PATHS) THEN
C  SET MODEA FOR PATHLENGTH
        MODEA=5
        CALL ABMULT(H,ABSC)
        TM = ABSC(3)/ABSC(1)
C DEFAULT PATH 2MM
      ELSE
        TM=2.0
      ENDIF
      CEXT(1)=CON1*TM*FACMM/PSCALE
C GET THE EXTINCTION FACTOR IF WANTED
      IF (DOALL) GO TO 2
      GO TO 100
C
C ENTRY 2 OR 3 - NO EXTINCTION CORRECTION:
  10  EXTCOR=1.
      DEXDRQ=0.
      DEXDGQ=0.
      DEXDFQ=0.
      GO TO 100
C
      ENTRY EXTIN3(NP)
      GO TO (4,5) , NP
C
C APPLY SHIFT TO DOMR:
   4  CALL ADJUST(DOMR)
      GO TO 100
C
C APPLY SHIFT TO MOSC:
   5  CALL ADJUST(AMOSC)
      GO TO 100
C
      ENTRY EXTIN4
C
C NEW E CARD:
   6  WRITE (NEWIN,2000) IEXTYP,DOMR,AMOSC
2000  FORMAT ('E',I5,2F10.4)
      GO TO 100
C
      ENTRY EXTIN8(NP,NV)
      IF (NP .EQ. 1) KDOMR=NV
      IF (NP .EQ. 2) KMOSC=NV
      GO TO 100
C
      ENTRY EXTIN9
      KDOMR=0
      KMOSC=0
      GO TO 100

 100  RETURN
      END
C
C
C
C
C LEVEL 5      SUBROUTINE F2NEW(L)
      SUBROUTINE F2NEW(L)
C
C *** F2NEW updated by JCM 6 Feb 90 ***
C
CX
CC 6B
CH Outputs a new LSQ family 2 (structure parameters) card (for A, T
CH or F cards).
CA On entry L is the position in the alphabet of the first letter of the card:
CA L = 1, 6 OR 20 for A, F OR T.
CP The card should have been read to ICARD in /SCRACH/.
CO Outputs to unit NEWIN  a new card, with altered parameters if necessary.
C
C
      CHARACTER *4 LABA,LABS,LABF
      DIMENSION A(6)
/ANISO/
/CARDRC/
/FORMDA/
/NEWOLD/
/POSNS/
/SCRACH/
C
      IF (L .EQ. 1) GO TO 1
      IF (L .EQ. 6) GO TO 2
      IF (L .EQ. 20) GO TO 3
      CALL ERRIN2(L,0,'F2NEW entered with L=',' ')
C
C 'A' CARD:
   1  CALL INPUTA(0,LABA,LBALEN,LABS,LBSLEN,A,TOLD,SOLD,IER)
C REREAD CARD TO FIND OUT WHICH ATOM, AND WHETHER SCAT LABEL EXPLICIT OR NOT:
      IR=IATOM(LABA)
      LABF=' '
      IF (LBSLEN .GT. 0) LABF=LABS
C MAY BE SD CARD:
      IF (SDREAD) THEN
        WRITE (NEWIN,2020) LABA,(SDX(J,IR),J=1,3),
     &   SDTF(IR),LABF,SDSITE(IR)
2020    FORMAT ('A SD ',A4,4F10.5,1X,A4,F10.5)
      ELSE
        IF (SITE(IR) .EQ. 1.) WRITE (NEWIN,2000)
     &   LABA,(X(J,IR),J=1,3),TF(IR),LABF
        IF (SITE(IR) .NE. 1.) WRITE (NEWIN,2000)
     &   LABA,(X(J,IR),J=1,3),TF(IR),LABF,SITE(IR)
2000    FORMAT ('A ',A4,4F10.5,1X,A4,F10.5)
      ENDIF
      GO TO 100
C
C 'F' CARD:
   2  CALL INPUTF(0,LABF,LBFLEN,NTYP,IPT,IER)
C REREAD CARD TO DISCOVER WHICH FACTOR AND TYPE:
      IF (NTYP .NE. 1) GO TO 101
      IR=ISCAT(LABF)
      WRITE (NEWIN,2001) LABF,NTYP,CMULT(IR)
2001  FORMAT ('F ',A4,I5,F10.5)
      GO TO 100
C
C 'T' CARD:
   3  CALL INPUTT(0,LABA,LBALEN,NTYP,A,IER)
C REREAD CARD TO DISCOVER WHICH:
      IR=IATOM(LABA)
      IA=IAPT(IR)
      DO 9 I=1,6
   9  A(I)=ATF(I,IA)*CONATF(I,IA)
      WRITE (NEWIN,2002) LABA,IATYP(IAPT(IR)),A
2002  FORMAT ('T ',A4,I5,6F10.5)
      GO TO 100
C
C COPY OUT UNCHANGED CARD:
 101  WRITE (NEWIN,2003) (ICARD(I:I),I=1,LENGT(ICARD))
2003  FORMAT (80A1)
C
 100  RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE F2PARP
      SUBROUTINE F2PARP
C
C **** F2PARP New by PJB May 2003 ***
C
CC 7A
CH Dummy routine to force inclusion of BLOCK DATA F2PARS
C125
      DUMMY = 0.
      DUMMY=DUMMY
      RETURN
      END
C
C
C
C
      BLOCK DATA F2PARS
C
C *** F2PARS corrected by PJB Dec 2006 C4.1 ***
C
CH Block data to set up common blocks /F2NAMS/ and /F2NUMS/
/F2NAMS/
/F2NUMS/
      DATA F2NAME/
     & 'X','Y','Z','B11','B22','B33',
     & 'B23','B13','B12','SCAT','SITE','ITF',
     & 'TFAC','A*','B*','C*','D*','E*','F*',
     & 'FAM1','FAM2','XYZ','BIJ','XYZT','CELL','XYZB','XYZS',
     & 'PSI1','PSI2','PSI3','PSI4',
     & 'THET','PHI','THE1','PHI1','MU','MU1',
     & 'KX','KY','KZ',
     & 'PSIS','ANGS','MUS', 'MPAR'/
      DATA NF2NUM/
     & 2,0,1, 2,0,2, 2,0,3, 2,0,4, 2,0,5, 2,0,6,
     & 2,0,7, 2,0,8, 2,0,9, 2,0,10, 2,0,11, 2,0,12,
     & 1,1,1, 1,1,2, 1,1,3, 1,1,4, 1,1,5, 1,1,6, 1,1,7,
     & 1,0,0, 2,0,0, -1,0,0, -2,0,0, -3,0,0, -4,0,0, -5,0,0, -6,0,0,
     & 2,0,13, 2,0,14, 2,0,15, 2,0,16,
     & 2,0,17, 2,0,18, 2,0,19, 2,0,20, 2,0,21, 2,0,22,
     & 1,1,11, 1,1,12, 1,1,13,
     & -8,0,0, -9,0,0, -10,0,0, -11,0,0/
      END
C
C
C
C
C LEVEL 9      SUBROUTINE F2RELA(IFAM,ISPVEC)
      SUBROUTINE F2RELA(IFAM,ISPVEC)
C
C *** F2RELA updated by JCM 8 Sep 88 ***
C
CX
CC 6B
CH Collects all structure factor type constraints implied by the symmetry.
CA IFAM gives family number;  so far this is 2 for structure parameters,
CA      but it may one day be more general
CA ISPVEC is a vector holding miscellaneous pointers saying which parameters
CA        within family IFAM, genus IR(=which atom) the following are:
CA        (1) x position coord
CA        (2) B11 first atf coefficient
CA        (3) f, the scattering factor
CA        with room for others which may be required later
CP JPHASE, JSOURC hold phase and source
C
CD Space group symmetry generated constraints are each between 2 parameters
CD only, and refer to x, y, z coordinates, or to anisotropic coefficients
CD Some of the relations found may lead to fixings rather than constraints
CD (Later - if magnetic, do the constraints on the magnetic pars here
CD also)
CD
CD We also chain together here the scattering factors of like atoms
CD and fix any non-existent atfs.  In the process, we check that the given
CD atfs have the correct symmetry to start with.
C
      DIMENSION ISPVEC(10)
      DIMENSION RMAT(3,3),NFIX3(3),FIX3(3),NFIX6(6),FIX6(6)
      DIMENSION KK1(2),AM(2),NCOUNT(6)
/ANISO/
/CARDRC/
/FORMDA/
/PHASE/
/POSNS/
/SYMDA/
C
C SCAN ALL ATOMS, PICKING UP RELATIONS BETWEEN POSITION PARAMETERS, ANISOTROPIC
C COEFFICIENTS, AND SCATTERING FACTORS BELONGING TO OTHER ATOMS ALSO:
      IF (NATOM .LE. 0) GO TO 100
C IF NO ATFS AT ALL, FIX ALL:
      IF (ICDNO(20) .EQ. 0) THEN
        DO 15 I=1,6
  15    CALL ADDFX5(IFAM,0,ISPVEC(2)+I-1,JPHASE,1,5)
      ENDIF
      DO 3 IR=1,NATOM
C CLEAR OUT ALL FIX/RELA INFO FOR THIS ATOM:
      DO 2 K=1,6
      NFIX6(K)=9999
      IF (K .GT. 3) GO TO 2
      NFIX3(K)=9999
   2  CONTINUE
C
C JUMP IF NOT SPECIAL:
      IF (ISGEN(1,IR) .EQ. 1) GO TO 6
C JUMP IF NOT SPECIAL BECAUSE OF A CENTRE OF SYMMETRY AT THE ORIGIN:
      IF (ISGEN(1,IR) .GT. 0) GO TO 4
C FIX ALL POSITION:
      DO 5 I=1,3
   5  CALL FIXPAR(I,NFIX3)
C ATF ON ATOM ON CENTRE:
      IF (IAPT(IR) .EQ. 0) GO TO 4
      CALL GMUNI(RMAT,3)
      CALL GMREV(RMAT,RMAT,3,3)
      CALL RELSM6(RMAT,NFIX6,FIX6)
C
C
C TAKE FIRST (OF POSSIBLE 2) SYMMETRY ELEMENTS MAKING THIS POSITION SPECIAL:
   4  DO 1 I=2,3
      K=IABS(ISGEN(I,IR))
      CALL GMEQ(SYM(1,1,K),RMAT,3,3)
      IF (ISGEN(I,IR) .LT. 0) CALL GMREV(RMAT,RMAT,3,3)
      CALL RELSM3(RMAT,NFIX3,FIX3)
C IF THERE IS AN ATF, FIND ITS RELATIONS ALSO:
      IF (IAPT(IR) .NE. 0) CALL RELSM6(RMAT,NFIX6,FIX6)
C
C IS THERE A SECOND GENERATOR OF THE SUB-GROUP WHICH MAKES THIS ATOM SPECIAL?
      IF (ISGEN(3,IR) .EQ. 0) GO TO 6
   1  CONTINUE
C ALL POSITION AND ATF RELATIONS COLLECTED IN TEMPORARY SPACE - USE:
   6  DO 16 I=1,3
  16  NCOUNT(I)=KPAK(IFAM,IR,ISPVEC(1)+I-1,JPHASE,1)
      CALL FIXREL(3,NFIX3,FIX3,NCOUNT,5)
      IF (IAPT(IR) .NE. 0) THEN
        DO 17 I=1,6
  17    NCOUNT(I)=KPAK(IFAM,IR,ISPVEC(2)+I-1,JPHASE,1)
        CALL FIXREL(6,NFIX6,FIX6,NCOUNT,5)
      ENDIF
C
C NOW LINK SCATTERING FACTORS FOR THOSE ATOMS WITH SAME FACTOR:
      IS=NFORMF(IR)
      IT=NBAKF(IS)
      IF (IT .NE. IR) THEN
        KK1(1)=KPAK(IFAM,IR,ISPVEC(3),JPHASE,1)
        KK1(2)=KPAK(IFAM,IT,ISPVEC(3),JPHASE,1)
        AM(1)=1.
        AM(2)=-1.
        CALL ADDCON(2,KK1,AM,5)
      ENDIF
C
C AND FIX ALL NON-EXISTENT ATF COEFFS, CHECKING ANY WITH FIX/RELA INFO:
      IF (ICDNO(20) .EQ. 0) GO TO 3
      IF (IAPT(IR) .EQ. 0) THEN
        DO 8 I=ISPVEC(2),ISPVEC(2)+5
   8    CALL ADDFX5(IFAM,IR,I,JPHASE,1,5)
        GO TO 3
      ENDIF
C
      DO 9 I=1,6
      IF (NFIX6(I) .EQ. 9999) GO TO 9
      IF (NFIX6(I) .EQ. 0) THEN
*     CHECK THAT ATF COEFF ALSO = 0 & ADJUST IF NOT
        GO TO 9
      ENDIF
      I1=I
  10  I2=NFIX6(IABS(I1))
      IF (I2 .EQ.I) GO TO 9
*     CHECK THAT COEFF I1 AND COEFF I2 HAVE CORRECT RELATIONSHIP
      I1=I2
      GO TO 10
C
   9  CONTINUE
   3  CONTINUE
 100  RETURN
      END
C
C
C
C
C LEVEL 7      SUBROUTINE F2SHFT
      SUBROUTINE F2SHFT
C
C *** F2SHFT updated by JCM 10 Feb 87 ***
C
CX
CC 6B
CH Applies a shift to a particular family 2 (structure) parameter.
C
CP On entry in/NEWOLD/ IGEN=which atom and ISPC=which parameter
CP       SHIFT is the LSQ matrix inversion shift
CP       ESD is the its esd.
C
/ANISO/
/FORMDA/
/NEWOLD/
/POSNS/
C
      GO TO (1,1,1,4,4,4,4,4,4,10,11,12) , ISPC
C
C X, Y OR Z:
   1  CALL ADJUST(X(ISPC,IGEN))
      SDX(ISPC,IGEN)=ESD
      GO TO 100
C
C B11, B22 ETC:
   4  IA=IAPT(IGEN)
      FAC=CONATF(ISPC-3,IA)
      ATF(ISPC-3,IA)=ATF(ISPC-3,IA)*FAC
      SHIFT=SHIFT*FAC
      ESD=ESD*FAC
      CALL ADJUST(ATF(ISPC-3,IA))
      ATF(ISPC-3,IA)=ATF(ISPC-3,IA)/FAC
      GO TO 100
C
C FORM/SCATTERING FACTOR:
  10  CALL ADJUST(CMULT(NFORMF(IGEN)))
      GO TO 100
C
C SITE OCCUPATION FACTOR:
  11  CALL ADJUST(SITE(IGEN))
      SDSITE(IGEN)=ESD
      GO TO 100
C
C ISOTROPIC TEMPERATURE FACTOR:
  12  CALL ADJUST(TF(IGEN))
      SDTF(IGEN)=ESD
C
 100  RETURN
      END
C
C
C
C
C LEVEL 7      SUBROUTINE F2VAR8(NG,NS,NV)
      SUBROUTINE F2VAR8(NG,NS,NV)
C
C *** F2VAR8 corrected by PJB 30-Jan-98 ***
C
CX
CC 6A
CH Records varying information for a particular family 2 (structure) parameter.
C
CA On entry NG is the genus (which atom)
CA          NS is the species
CA          NV is which variable it will be
CD Records the information for future consultation
C
/ANISO/
/FORMDA/
/POSNS/
C
      GO TO (1,1,1,4,4,4,4,4,4,10,11,12) , NS
C
C X, Y OR Z:
   1  KX(NS,NG)=NV
      GO TO 100
C
C B11, B22 ETC:
   4  KATF(NS-3,IAPT(NG))=NV
      GO TO 100
C
C FORM/SCATTERING FACTOR:
  10  KCMULT(NG)=NV
      GO TO 100
C
C SITE OCCUPATION FACTOR:
  11  KSITE(NG)=NV
      GO TO 100
C
C ISOTROPIC TEMPERATURE FACTOR:
  12  KTF(NG)=NV
      GO TO 100
C
C
C TO CLEAR ALL FAMILY 2 VARIABLES TO BE FIXED:
      ENTRY F2VAR9
      DO 50 IR=1,NATOM
      DO 51 I=1,3
  51  KX(I,IR)=0
      IAPTR=IAPT(IR)
      IF (IAPTR.NE.0) THEN
        DO 52 I=1,6
  52    KATF(IAPTR,IR)=0
      ENDIF
       KCMULT(IR)=0
      KSITE(IR)=0
      KTF(IR)=0
  50  CONTINUE
C
 100  RETURN
      END
C
C
C
C
C LEVEL 2      SUBROUTINE FACGRP(ISTAB,ISFTAB,NFAC)
      SUBROUTINE FACGRP(ISTAB,ISFTAB,NFAC)
C
C *** FACGRP rewritten by PJB March 2006 ***
C
CX
CC 1A
CH Finds the factor elements which generate a space group from one of its
CH sub-groups.
CD To extract the factor group  F of space group G given a subgroup S
CD such that  FxS=G
CA On entry:
CA      ISTAB(I)      is positive if element I is in S.
CA      ISTAB(I)      is negative if S is non-centric and only the centre
CA                    related partner is in S
CA      ISTAB(NOPC+1) is zero if G is non-centrosymmetric
CA                    +1 if S is centric, -1 if it is non-centric
CA On exit:
CA      IFTAB(I)     defines the factorisation.
CA      IFTAB(I)     =1 if I is in S,
CA                   = I if I is a member of F
CA                   for all other elements IFTAB(N)=I where MULTAB(I,J)=N
CA                   and J is an element of S.
CA                   Negative values of the entries indicate that it is the
CA                   centre related partner that is required.
CA     IFTAB(NOPC+1) = ISTAB(NOPC+1) set as above
CA     NFAC          is the multiplicity of F
CN ISTAB and IFTAB may refer to the same vector in the calling routine
C
      DIMENSION ISTAB(*),ISFTAB(*)
%      DIMENSION IFTAB(%SYMO%),ITTAB(%SYMO%),ITRY(%SYMO%),JTRY(%SYMO%)
/IOUNIT/
/NSYM/
/SYMTAB/
C
      NSUB=0
      DO 1 I=1,NOPC
      IF (ISTAB(I).EQ.0) GO TO 1
      NSUB=NSUB+1
      IFTAB(NSUB)=I
    1 CONTINUE
      NFAC=NOPC/NSUB
      CALL JGMEQ(ISTAB,ITTAB,NOPC+1,1)
C CONSTRUCT THE FACTOR GROUP IN ITRY:
      CALL JGMZER(ITRY,NOPC,1)
      ITRY(1)=1
      DO 2 I=2,NOPC
C POTENTIAL NEW ELEMENT OF A FACTOR GROUP:
      IF (ITTAB(I).NE.0 .OR. ITRY(I) .NE.0) GO TO 2
      CALL ADDELM(ITRY,I,JTRY,IFAC)
C MAKE SURE IT IS A POSSIBLE FACTOR
C      WRITE (LPT,1002) 'CYCLE',i,IFAC,(JTRY(II),II=1,NOPC)
      IF (MOD(NFAC,IFAC) .NE.0) GO TO 2
      CALL JGMEQ(JTRY,ITRY,NOPC,1)
C      WRITE (LPT,1000) 'FACT ',I,(ITRY(II),II=1,NOPC)
      DO 20 N=1,NSUB
      IK=IFTAB(N)
      DO 21 IOP=2,NOPC
      IF (ITRY(IOP) .EQ. 0) GO TO 21
      IIK=MULTAB(IK,IOP)
      ITTAB(IIK)=IOP
   21 CONTINUE
   20 CONTINUE
C      write (lpt,1000) 'ISTAB',I, (ISTAB(Ii),Ii=1,NOPC)
C      WRITE (LPT,1000) 'ITRY ', IFAC,(ITRY(II),II=1,NOPC)
C 1000 FORMAT(A6,I4,2X,24I4)
C 1002 FORMAT(A5,2I4,2X,24I4)
      IF (IFAC.GE.NFAC) GO TO 3
C NEED ANOTHER ELEMENT IN THE FACTOR GROUP
    2 CONTINUE
C
    3 CALL JGMEQ(ITTAB,ISFTAB,NOPC,1)
C CENTRIC PROPERTIES ARE CONSERVED
      ISFTAB(NOPC+1)=ISTAB(NOPC+1)
C      WRITE (LPT,1000) 'ISFTAB',IFAC,(ISFTAB(I),I=1,NOPC+1)
C
      RETURN
      END
C
C
C
C
C LEVEL 3      FUNCTION FACT(K)
      FUNCTION FACT(K)
C
C *** FACT by PJB 19 Jan 85 ***
C
CX
CC 9C
CH Calculates factorial K.
CA On entry K holds an integer which is positive or zero.
CA On exit FACT holds factorial K
C
C
      FAC = 1.
      IF (K) 1,101,2
   1  CALL ERRIN2(K,1,'negative argument for factorial',' ')
C
    2 DO 3 I = 1,K
    3 FAC = FAC*FLOAT(I)
 101  FACT=FAC
      RETURN
      END
C
C
C
C
C LEVEL 3      COMPLEX FUNCTION FCALC(H)
      COMPLEX FUNCTION FCALC(H)
C
C *** FCALC by JCM 19 Jul 83 ***
C
CX
CC 4B
CH Calculates the COMPLEX nuclear structure factor for the reflection H.
CA On entry H is a 1x3 read vector holding h,k,l.
CA On exit FCALC holds the COMPLEX nuclear structure factor
CP PREFIN, RECIP, SYMOP, SETFOR, ATOPOS and SETANI must be called before the
CP first call to FCALC.  (All these except PREFIN are all in SETFC)
CD Forms sin theta/lambda and leaves it in STHL in /BRAGG
CD Cycles over atomic positions, then over symmetry operators, forming
CD COMPLEX FCALC by the usual formula.
CD
CD Applies scattering factor, site occupation factor, multiplicity of atom and
CD individual isotropic or anisotropic temperature factors.
C
      COMPLEX SUM1,TERM,FORMFA,FO
      DIMENSION RH(3),H(3)
/BRAGG/
/CONSTA/
/FORMDA/
/NSYM/
/POSNS/
/SYMDA/
C
      FCALC = CMPLX(0.,0.)
C
C CALCULATE SINTHETA/LAMBDA:
      STHL = VCTMOD(0.5,H,2)
C
C INITIALISE J, WHICH SAYS WHICH FORM FACTOR USED ON "PREVIOUS" ATOM:
      J = 0
C
C SUM OVER ATOMS IN CELL:
      DO 1 N = 1,NATOM
      SUM1 = CMPLX(0.,0.)
C
C SUM OVER SYMMETRY EQUIVALENTS:
      DO 3 I = 1,NOPC
      CALL ROTSYM(H,RH,I,-1)
      F1=SCALPR(X(1,N),RH)+SCALPR(TRANS(1,I),H)
      TERM = CEXP(CMPLX(0.,TWOPI*F1))
C CALCULATE ANISOTROPIC TEMPERATURE FACTOR IF REQUIRED:
      TERM = TERM*ANITF(RH,N)
    3 SUM1 = SUM1 + TERM
C IN CASE ANOM SCATT AND CENTROSYMMETRIC:
      IF (CENTRC) SUM1=SUM1+CONJG(SUM1)
C
      SUM1 = SUM1*AMULT(N)*SITE(N)
      IF (NFORMF(N) .EQ.J) GO TO 1
C CALCULATE A NEW FORM FACTOR:
      J = NFORMF(N)
      FO = FORMFA(STHL,J)
    1 FCALC = FCALC + SUM1*FO*EXP((-TF(N))*STHL*STHL)
      RETURN
      END
C
C
C
C
C LEVEL 6      SUBROUTINE FCHALC(H,FMCMOD,FMCSQR)
      SUBROUTINE FCHALC(H,FMCMOD,FMCSQR)
C
C *** FCHALC new by PJB May 2001 ***
C
CX
CC 17B
CH Calculates induced magnetic interaction vectors and magnetic structure factors.
CH with anisotropic susceptibilities
CA On entry H is the 1x3 vector containing h,k,l
CA On exit   FMCMOD = domain average of the lengths of the m.i. vector
CA           FMCSQR = square of the above
CD On exit Q(1:3,1:NDOM) in COMMON QCAL contains the magnetic interaction
CD vectors for each of the NDOM domains.
CP STHL in /BRAGG should hold sin theta/lambda
CP NKSTAR in /SATELL should have been set up by routine PROPER
CP
CP The setting up routines:
CP     RECIP  (for the cell parameters)
CP     SYMOP  (for the space group symmetry)
CP     SETFOR (for the scattering factors, both nuclear and magnetic)
CP     SETANI (for the anisotropic temperature factors)
CP     DOCHI(1) and (2) (for the susceptibilities)
CP should all have been obeyed to set up the structure.
CD Sets SSQRD in /BRAGG to be STHL squared
CD Gives zero as answers for magnetic absences
CN There is also the routine LMCALC which does a similar calculation but also
CN calculates derivatives, for use in LSQ.
C
      COMPLEX SUM1(3),TERM,TVEC(3),FORM,HR,FORMFA,FMC(3)
      LOGICAL MAGABS
      DIMENSION RH(3),H(3),RS(3),HD(3,3),OH(3),UNIMAT(3,3)
/BRAGG/
/CONSTA/
      COMMON /MAGCHI/CHISYM(3,6,48)
/MAGDAT/
      DIMENSION CHIIJ(6,20),KCHIJ(6,20)
      EQUIVALENCE (ANGM,CHIIJ),(KSMOD,KCHIJ)
/NSYM/
/POSNS/
/QCAL/
/SATELL/
/SYMDA/
/SYMMAG/
/SYMTAB/
      DATA UNIMAT/1.,0.,0.,0.,1.,0.,0.,0.,1./
C
C CLEAR ALL ANSWERS IN CASE ABSENT:
C
C CLEAR MODULUS AND SQUARE:
      FMCMOD=0.
      FMCSQR=0.
      SSQRD=STHL*STHL
C
C OUT IF ABSENT:
      IF (MAGABS(H,IK)) GO TO 100
C
C FMC COLLECTS THE MAGNETIC STRUCTURE FACTOR, A COMPLEX VECTOR,
      CALL CGMZER(FMC,1,3)
C FIRST SCATTERING FACTOR:
      IFF=0
C
C CYCLE OVER MAGNETIC ATOMS:
      DO 1 IM=1,NMAG
      IR=JMAGAT(IM)
C
C JUMP IF FORM/SCATTERING FACTOR THE SAME AS BEFORE
      IF (NMFORM(IM) .NE. IFF) THEN
C IF NOT, GET IT
        IFF=NMFORM(IM)
        FORM=FORMFA(STHL,IFF)
      ENDIF
C
      CALL CGMZER(SUM1,3,1)
C INNER LOOP OVER SYMMETRY EQUIVALENTS:
      DO 3 IS=1,NOPC
      CALL ROTSYM(H,RH,IS,-1)
      F1=TWOPI*(SCALPR(X(1,IR),RH)+SCALPR(TRANS(1,IS),H))
C  ANISOTROPIC T F (=1. IF NOT THERE) NEEDED SEPARATELY FOR LSQ:
      ERS=ANITF(RH,IR)
      ARS=COS(F1)*ERS
      BRS=SIN(F1)*ERS
      TERM=CMPLX(ARS,BRS)
C FIND OUT WHAT THE SYMMETRY DOES TO THE SUSCEPTIBILITY
C  and GET THE SPIN DIRECTION FOR THIS ATOM
      DO 2 I=1,3
      RS(I)=0.
      FAC=1.
      DO 5 J=1,6
      IF (J.GT.3) FAC=2.
      RS(I)=RS(I)+FAC*CHIIJ(J,IM)*CHISYM(I,J,IS)
    5 CONTINUE
    2 CONTINUE
      CALL C1MSCA(RS,TVEC,TERM,3,1)
C IF CENTROSYMMETRIC, COMPENSATE FOR USING ONLY HALF NUMBER OF OPERATORS:
      IF (CENTRC)CALL CMRSCA(TVEC,TVEC,2.0,3,1)
      CALL CGMADD(SUM1,TVEC,SUM1,1,3)
C
C END OF INNERMOST CYCLE OVER SYMMETRY
    3 CONTINUE
C
C HR IS PRODUCT OF ATOM DEPENDENT BUT SYMMETRY INDEPENDENT FACTORS
      HR=FORM*SITE(IR)*VALMUB*AMULT(IR)*EXP((-TF(IR))*SSQRD)
C SCALE MOMENT TO CMS-12
      CALL CGMSCA(SUM1,TVEC,HR,3,1)
      CALL CGMADD(FMC,TVEC,FMC,1,3)
C
   1  CONTINUE
C END OF CYCLE OVER ATOMIC POSITIONS
C
C NOW CONVERT FMC TO FMC perp
C FMC IS IN ORTHOGONAL CRYST COORDINATES
C CONVERT H ALSO TO ORTHOGONAL CRYSTALLO
      CALL ORTHO(H,OH,2)
      CALL UNIVEC(OH,SCATV)
      CALL GMPRD(OH,OH,HD,3,1,3)
      CALL GMSUB(UNIMAT,HD,HD,3,3)
C HD IS THE MATRIX TO PROJECT OUT FMPERP
      CALL RCMPRD(HD,FMC,Q,3,3,1)
C FMCSQR is the modulus squared of the magnetic interaction vector
      FMCSQR=RSCALP(Q,Q)
      FMCMOD=SQRT(FMCSQR)
C
  100 RETURN
      END
C
C
C
C
C LEVEL 2      SUBROUTINE FCTOR(H,N)
      SUBROUTINE FCTOR(H,N)
C
C *** FCTOR by PJB/JCM 28 Jun 83 ***
C
CX
CC 1C
CH Finds the highest common factor of a set of indices and reduces them
CH by that factor.
CA On entry H is a 1x3 array holding 3 reals, usually h,k,l
CA On exit N is the integer highest common factor of the elements of H, assumed
CA integral, and H has been divided through by N
C
      DIMENSION H(3),AH(3)
C
C USE ONLY MODULI:
      N=0
      DO 1 I=1,3
      AH(I)=ABS(H(I))
   1  CONTINUE
C
C C106 replaced MAX1 with MAX to allow compiler switch for
C double precision throughout
C NMAX= LARGEST:
      NMAX=NINT(MAX(AH(1),AH(2),AH(3)))
C FOR 0,0,0 EXIT WITH N=0
      IF (NMAX .EQ. 0) GO TO 100
      FN=FLOAT(NMAX)
C
C NOW SCAN EACH POSSIBLE HCF, DOWNWARDS:
      DO 2 NN=2,NMAX
      DO 3 I=1,3
C TO 2 IF FN IS NOT A FACTOR OF ANY ONE ELEMENT:
      IF (AMOD(AH(I),FN).GT.10.E-4) GO TO 2
    3 CONTINUE
C IF HERE, HCF FOUND; REDUCE ELEMENTS BY IT:
      DO 4 I=1,3
    4 H(I)=H(I)/FN
      GO TO 5
    2 FN=FN-1.
      FN=1.
    5 N=JFIX(FN)
 100  RETURN
      END
C
C
C
C
C LEVEL 2      SUBROUTINE FETSHF(N,SH,ES)
      SUBROUTINE FETSHF(N,SH,ES)
C
C *** FETSHF updated by JCM 21 Mar 89 ***
C
CX
CC 6C
CH Fettles a shift and esd for printing and counts, in the application
CH of shifts in LSQ.
CA  On entry N indicates which action is required:
CA  N=1 initialise
CA  N=2 add in to totals
CA  N=3 print at cycle end
CA On entry 2 SH holds the shift
CA            ES holds the esd
CP In /NEWOLD/ ISHFT = number of shifts dealt with so far in this cycle,
CP             AVSHFT=the sum of their SHIFT/ESD so far,
CP             AMAXSH=the maximum SHIFT/ESD so far.
CD Updates ISHFT, AVSHFT and AMAXSH
C
      LOGICAL TESTOV
/IOUNIT/
/NEWOLD/
/REFINE/
C
      GO TO (1,2,3) , N
C
C INITIALISE:
   1  AVSHFT=0.
      ISHFT=0
      AMAXSH=0.
      GO TO 100
C
C ADD IN TOTALS:
   2  SHESD=0.
      IF (.NOT. TESTOV(SH,ES)) SHESD=ABS(SH/ES)
      ISHFT=ISHFT+1
      AVSHFT=AVSHFT+SHESD
      AMAXSH=MAX(AMAXSH,SHESD)
      GO TO 100
C
C PRINT AT CYCLE END:
C C106 Catch overflow
   3  IF(TESTOV(AVSHFT,1.*ISHFT)) THEN
        WRITE (LPT,2003) ICYC, AMAXSH
2003    FORMAT (//' Average SHIFT/ESD for cycle ',I3,
     &  ' is undefined, Maximum SHIFT/ESD = ',G14.5)
      ELSE
        WRITE (LPT,2002) ICYC,AVSHFT/ISHFT,AMAXSH
2002  FORMAT (//' Average SHIFT/ESD for cycle ',I3,' =',G14.5/
     & ' Maximum SHIFT/ESD = ',G14.5)
      ENDIF
 100  RETURN
      END
C
C
C
C
C LEVEL 4      SUBROUTINE FETTLE(X,IFIELD,IFDIG)
      SUBROUTINE FETTLE(X,IFIELD,IFDIG)
C
C *** FETTLE by JCM 8 Jun 82 ***
C
CX
CC 13C
CH Decides field width and fractional part of real number in order to print it.
CA On entry X holds the real number.
CA On exit IFDIG is the minimum number of digits in which the
CA               fractional part of X may be printed (up to 4)
CA         IFIELD is the corresponding necessary total field width.
C
      DIMENSION ITEMP(5)
      A=ABS(X)
      CALL FRACT(A,B,N)
      CALL INTDIG(JFIX(B),ITEMP,IFIELD)
      CALL INTDIG(JFIX(A*10.**4),ITEMP,NDIG)
      IFDIG=0
      IF ((NDIG .EQ. 1) .AND. (ITEMP(1) .EQ. 0)) GO TO 1
      IFDIG=4
   2  IF (NDIG .EQ. 0) GO TO 1
      IF (ITEMP(NDIG) .NE. 0) GO TO 1
      IFDIG=IFDIG-1
      NDIG=NDIG-1
      GO TO 2
   1  IF (IFDIG .NE. 0) IFIELD=IFIELD+1+IFDIG
      IF (X .LT.0.) IFIELD=IFIELD+1
      RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE FF01A(VJS,VYS,XS,N)
      SUBROUTINE FF01A(VJS,VYS,XS,N)
C
C *** FF01A from HARWELL LIBRARY modified by JCM 17 Jan 85 ***
C
CX
CC 9C
CH Modified Harwell routine for zero order Bessel functions.
C
      DOUBLE PRECISION A(18),B(19),C(18),D(18)
      DOUBLE PRECISION XLG
      DOUBLE PRECISION VJ0,VY0,X,Y,Z,Q1,Q2,Q3,FX,X1,X2,X3,X4
      DOUBLE PRECISION ABCD(73)
      EQUIVALENCE (ABCD(1),A(1)),(ABCD(19),B(1)),(ABCD(38),C(1))
      EQUIVALENCE (ABCD(56),D(1))
      DATA A/
     &   -.17D-18                  , .1222D-16             ,
     &   -.75885D-15               , .4125321D-13          ,
     &   -.194383469D-11           , .7848696314D-10       ,
     &   -.267925353056D-8         , .7608163592419D-7     ,
     &   -.176194690776215D-5      , .3246032882100508D-4  ,
     &   -.4606261662062751D-3    , .4819180069467605D-2 ,
     &   -.3489376941140889D-1    , .1580671023320973D0  ,
     &   -.3700949938726498D0     , .2651786132033368D0  ,
     &   -.8723442352852221D-2    , .3154559429497802D0  /
      DATA B/
     &   -.1D-19                   , .39D-18               ,
     &   -.2698D-16                , .164349D-14           ,
     &   -.8747341D-13             , .402633082D-11        ,
     &   -.15837552542D-9          , .524879478733D-8      ,
     &   -.14407233274019D-6       , .32065325376548D-5    ,
     &   -.5632079141056987D-4     , .7531135932577742D-3 ,
     &   -.7287962479552079D-2    , .4719668959576339D-1 ,
     &   -.1773020127811436D0     , .2615673462550466D0  ,
     &    .179034314077183D0     ,-.2744743055297453D0  ,
     &   -.6629222640656988D-1     /
      DATA C/
     &   -.1D-19                   , .2D-19                ,
     &   -.11D-18                  , .55D-18               ,
     &   -.288D-17                 , .1631D-16             ,
     &   -.10012D-15               , .67481D-15            ,
     &   -.506903D-14              , .4326596D-13          ,
     &   -.43045789D-12            , .516826239D-11        ,
     &   -.7864091377D-10          , .163064646352D-8      ,
     &   -.5170594537606D-7        , .307518478751947D-5   ,
     &   -.5365220468132117D-3    , .1998920698695037D1 /
      DATA D/
     &    .1D-19                   ,-.3D-19                ,
     &    .13D-18                  ,-.62D-18               ,
     &    .311D-17                 ,-.1669D-16             ,
     &    .9662D-16                ,-.60999D-15            ,
     &    .425523D-14              ,-.3336328D-13          ,
     &    .30061451D-12            ,-.320674742D-11        ,
     &    .4220121905D-10          ,-.72719159369D-9       ,
     &    .1797245724797D-7        ,-.74144984110606D-6    ,
     &    .683851994261165D-4      ,-.3111170921067402D-1 /
C
CS LAX      DATA XLG/1.7D+38/
CS PICKY      XLG=(1.0D0 - 16.0D0**(-14)) * 16.0D0**(+63)
      X=DBLE(XS)
      Y=DABS(X)
      Z=Y*.125D0
      IF (Z .GT.1D0) GO TO 1
      IF (Z .EQ. 0D0) GO TO  2
      X2=4D0*Z*Z-2D0
      JUMP=1
      N1=1
      N2=18
   3  Q3=0D0
      Q2=0D0
      DO 4  I=N1,N2
      Q1=Q2
      Q2=Q3
   4  Q3=X2*Q2-Q1+ABCD(I)
      FX=(Q3-Q1)*.5D0
      GO TO (10,11,12,13),JUMP
  10  VJ0=FX
      VJS=SNGL(VJ0)
      IF (N .LE. 0) GO TO 100
      JUMP=2
      N1=19
      N2=37
      GO TO 3
C
   2  VJ0=1D0
      VY0=-XLG
      GO TO 101
C
  11  VY0=.6366197723675813D0*DLOG(Y)*VJ0+FX
      VYS=SNGL(VY0)
      GO TO 100
C
   1  Z=1D0/Z
      X2=4D0*Z*Z-2D0
      JUMP=3
      N1=38
      N2=55
      GO TO 3
C
  12  X1=FX
      JUMP=4
      N1=56
      N2=73
      GO TO 3
C
  13  X2=DCOS(Y-.7853981633974483D0)
      X3=DSIN(Y-.7853981633974483D0)
      X4=.7978845608028654D0/DSQRT(Y)
      FX=FX*Z
      VJ0=X4*(X1*X2-FX*X3)
      VY0=X4*(FX*X2+X1*X3)
 101  VJS=SNGL(VJ0)
      VYS=SNGL(VY0)
 100  RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE FF02A(VJS,VYS,S,N)
      SUBROUTINE FF02A(VJS,VYS,S,N)
C
C *** FF02A from HARWELL LIBRARY modified by JCM 17 Jan 85 ***
C
CX
CC 9C
CH Modified Harwell routine for first order Bessel functions.
C
      DOUBLE PRECISION A(18),B(18),C(18),D(18),ABCD(72),XLG
      DOUBLE PRECISION VJ1,VY1,X,Y,Z,Q1,Q2,Q3,FX,X1,X2,X3,X4
      EQUIVALENCE (ABCD(1),A(1)),(ABCD(19),B(1)),(ABCD(37),C(1)),
     & (ABCD(55),D(1))
      DATA A/
     &   -.4D-19                   , .295D-17              ,
     &   -.19554D-15               , .1138572D-13          ,
     &   -.57774042D-12            , .2528123664D-10       ,
     &   -.94242129816D-9          , .2949707007278D-7     ,
     &   -.76175878054003D-6       , .1588701923993213D-4  ,
     &   -.2604443893485807D-3    , .3240270182683858D-2 ,
     &   -.2917552480615421D-1    , .1777091172397283D0  ,
     &   -.6614439341345433D0     , .1287994098857678D1  ,
     &   -.1191801160541217D1     , .1296717541210530D1  /
      DATA B/
     &    .9D-19                   ,-.658D-17              ,
     B    .42773D-15               ,-.2440949D-13          ,
     C    .121143321D-11           ,-.5172121473D-10       ,
     D    .187547032473D-8         ,-.5688440039919D-7     ,
     E    .141662436449235D-5      ,-.283046401495148D-4   ,
     F    .4404786298670995D-3    ,-.5131641161061085D-2 ,
     G    .4231918035333690D-1    ,-.2266249915567549D0  ,
     H    .6756157807721877D0     ,-.7672963628866459D0  ,
     I   -.1286973843813500D0     , .4060821177186851D-1 /
      DATA C/
     J    .1D-19                   ,-.2D-19                ,
     K    .12D-18                  ,-.58D-18               ,
     L    .305D-17                 ,-.1731D-16             ,
     M    .10668D-15               ,-.72212D-15            ,
     N    .545267D-14              ,-.4684224D-13          ,
     O    .46991955D-12            ,-.570486364D-11        ,
     P    .881689866D-10           ,-.187189074911D-8      ,
     Q    .6177633960644D-7        ,-.398728430048891D-5   ,
     R    .8989898330859409D-3    , .2001806081720027D1  /
      DATA D/
     S   -.1D-19                   , .3D-19                ,
     T   -.14D-18                  , .65D-18               ,
     U   -.328D-17                 , .1768D-16             ,
     V   -.10269D-15               , .65083D-15            ,
     W   -.456125D-14              , .3596777D-13          ,
     X   -.32643157D-12            , .351521879D-11        ,
     Y   -.4686363688D-10          , .82291933277D-9       ,
     Z   -.2095978138408D-7        , .91386152579555D-6    ,
     &    -.9627723549157079D-4     , .9355557413907065D-1 /
C
CS LAX      DATA XLG/1.7D+38/
CS PICKY      XLG=(1.0D0 - 16.0D0**(-14)) * 16.0D0**(+63)
      X=DBLE(S)
      Y=DABS(X)
      Z=Y*.125D0
      IF (Z.GT.1D0) GO TO 1
      IF (Z .LE. 0D0) GO TO 2
      X2=4D0*Z*Z-2D0
      JUMP=1
      N1=1
      N2=18
   3  Q3=0D0
      Q2=0D0
      DO 4 I=N1,N2
      Q1=Q2
      Q2=Q3
      Q3=X2*Q2-Q1+ABCD(I)
   4  CONTINUE
      FX=(Q3-Q1)*.5D0
      GO TO (10,11,12,13),JUMP
C
  10  VJ1=FX*Z
      VJS=SNGL(VJ1)
      IF(N.LE.0)GO TO 100
      JUMP=2
      N1=19
      N2=36
      GO TO 3
   2  VJ1=0D0
      VY1=-XLG
      GO TO 101
C
  11  VY1=.6366197723675813D0*(DLOG(Y)*VJ1-1D0/Y)+FX*Z
      VYS=SNGL(VY1)
      GO TO 100
C
   1  Z=1D0/Z
      X2=4D0*Z*Z-2D0
      JUMP=3
      N1=37
      N2=54
      GO TO 3
C
  12  X1=FX
      JUMP=4
      N1=55
      N2=72
      GO TO 3
C
  13  X2=DCOS(Y-2.356194490192345D0)
      X3=DSIN(Y-2.356194490192345D0)
      X4=.7978845608028654D0/DSQRT(Y)
      FX=FX*Z
      VJ1=X4*(X1*X2-FX*X3)
      VY1=X4*(FX*X2+X1*X3)
 101  VJS=SNGL(VJ1)
      VYS=SNGL(VY1)
 100  RETURN
      END
C
C
C
C
C LEVEL 2      SUBROUTINE FGAMMA(R,M,QQ,QL,RMS)
      SUBROUTINE FGAMMA(R,M,QQ,QL,RMS)
C
C *** FGAMMA modified to match new CGAMMA by PJB  04-May-1999 ***
C
CX
CC 2B
CH Calculates gamma, the ratio of magnetic and nuclear scattering,
CH and its standard deviation.
CA On entry R(1) holds the flipping ratio
CA          R(2) holds the standard deviation
CA          M = 0 for abs(gamma) >1
CA              1 for abs(gamma) <1
CA          QQ is the sine of the angle between the magnetisation direction
CA             and the scattering vector
CA          QL is the cosine of the angle between the polarisation direction
CA             and the scattering vector
CA          RMS is the ratio of multiple (or lamba/2) to nuclear scattering.
CA    and to FGAMMS, RMS is the ratio of nuclear to magnetic scattering.
CA On exit  R(1) holds the appropriate gamma
CA          R(2) holds its standard deviation.
CP SETPOL should have set the polarisation values in /POLDA/
C
      DIMENSION G(2,2),R(2),DEL(3)
/POLDA/
C
      GO TO 2
C
C  SAVE VALUES OF R AND DR
   2  AR=R(1)
      DEL(1)=R(2)
      DEL(2)=DPOLUP
      DEL(3)=DPOLDW
C
      CALL CGAMMA(AR,POLUP,POLDW,DEL,G,QQ,QL,RMS)
      A=ABS(G(1,1))
      K=1
      IF (A.GT.1 .AND. M.EQ.0) K=2
      IF (A.LT.1 .AND. M.EQ.1) K=2
      R(2) = G(2,K)
      R(1) = G(1,K)
      IF (R(2).EQ.0.) R(2)=DEL(1)/AR
      RETURN
      END
C
C
C
C
C LEVEL 3      CHARACTER*10 FUNCTION FILNOM(LUN)
      CHARACTER*10 FUNCTION FILNOM(LUN)
C
C *** FILNOM by PJB Jan 86 **
C
CX
CC 13C
CH Returns the name of the file on FORTRAN unit LUN.
CA LUN on entry holds an input/output unit number
CA FILNOM is an A10 character variable which on exit holds the file name
CP NOPFIL (or OPNFIL) must have attached the unit number to the name in LUNTAB
CO If unit LUN is not in the table LUNTAB, an error message is given
C
/FINAME/
/LOONEY/
C
%      I=NFIND(LUN,LUNTAB,%FILE%)
      IF (I .EQ. 0) THEN
        CALL ERRIN2(LUN,-1,'in FILNOM - unit','not in table LUNTAB')
      ELSE
        FILNOM=FILNAM(I)
      ENDIF
      RETURN
      END
C
C
C
C
C LEVEL 2      SUBROUTINE FILPRO(DEFT,IU,LFIL)
      SUBROUTINE FILPRO(DEFT,IU,LFIL)
C
C *** FILPRO updated by PJB for UNIX 28-Mar-1994 ***
C
CX
CC 13C
CH Makes sense of general file names, under VMS AND UNIX.
C
%      CHARACTER*%FNAM% DEFT
%      CHARACTER*%FNAM% BUFF
      CHARACTER*1 SEP(4)
      LOGICAL DOT
      DIMENSION IMTAB(4),JTAB(4),JMTAB(4),IPOS(5),MARK(5)
/FINAME/
/GLOBAL/
/IOUNIT/
/SCRACH/
CS LAX      DATA  IMTAB,JTAB,JMTAB/4,1,2,3,2,4,3,1,2,3,4,1/
C TO KEEP FUJITSU COMPILER HAPPY
CS PICKY      DATA  IMTAB,JTAB,JMTAB/4,1,2,3,2,4,3,1,2,3,4,1/
      DATA IPOS/1,5,17,23,61/
      DATA SEP/'.',':','[',']'/
C
C BRANCH ON SYSTEM, AS SET BY INITIL:
      IF (NSYSTM .EQ. 4) GO TO 50
      IF (NSYSTM.LT.2) GO TO 60
C THIS SECTION FOR UNIX
C EXPAND NAMFIL AS INPUT IN BUF
CS UNIX       CALL EXPAND(NAMFIL,BUFF)
C FRIG DEFAULT DISC
CS UNIX       L=LENGT(DEFT(5:10))
       IF (L .GT.0 ) THEN
         IF (DEFT(5:5).EQ.'$') THEN
          M=6
       ELSE
          M=5
       ENDIF
         L=L+4
         IF (DEFT(L:L) .EQ.':') L=L-1
         CALL GETENV(DEFT(M:L),NAMFIL)
         IFP=LENGT(NAMFIL)+1
         NAMFIL(IFP:IFP)='/'
       ELSE
         IFP=1
       ENDIF
C DEAL WITH DEFAULTS FOR PATH
       IF(LENGT(DEFT(11:30)).GT.0) THEN
CS UNIX         CALL EXPAND(DEFT(11:),NAMFIL(IFP:))
         IFP=LENGT(NAMFIL)+1
       ENDIF
C ADD FILE PART
      L=LENGT(BUFF) +IFP-1
%      CALL ERRCHK(1,L,%FNAM%,0,'File path too long')
      NAMFIL(IFP:)=BUFF
      IFP=L+1
C CHECK FOR EXTENSION
      DOT=(DEFT(1:1).NE.'.')
      DO 30 I=L,1,-1
      IF (NAMFIL(I:I).EQ.'/') GO TO 31
      IF (NAMFIL(I:I) .NE.'.') GO TO 30
      DOT=.TRUE.
   30 CONTINUE
   31 IF (.NOT.DOT) THEN
        L=L+LENGT(DEFT(1:4))
%        CALL ERRCHK(1,L,%FNAM%,0,'File path too long')
        CALL UPONE(DEFT(1:4),3)
        NAMFIL(IFP:)=DEFT(1:4)
      ENDIF
      LFIL=L-I
      CALL ERRCHK(1,LFIL,10,0,'Leaf name too long')
      FILNAM(IU)=NAMFIL(I+1:L)
      LFIL=L
      GO TO 100

C THIS SECTION FOR VMS
   60 CALL JGMZER(MARK,1,4)
%      L=LENG(NAMFIL,%FNAM%)
      MARK(5)=L+1
C
C  SEPARATE UP THE FILE-NAME
      JJ=0
      DO 1 I=1,L
      DO 2 J=1,4
      IF (NAMFIL(I:I).NE.SEP(JMTAB(J))) GO TO 2
C  SKIP SEPARATORS INSIDE SQUARE BRACKETS
      IF (JJ .GT. 0) THEN
        IF (JMTAB(JJ).EQ.3 .AND. JMTAB(J).NE.4) GO TO 1
      ENDIF
C  FORCE CORRECT ORDER
      IF (JJ.GE.J) GO TO 20
      JJ=J
      MARK(J)=I
      GO TO 1
    2 CONTINUE
    1 CONTINUE
C
C  PROCESS EACH PART SEPARATELY
      DO 5 IP=1,4
      GO TO (6,7,8,9), IP
C
C  EXTENSION
    6 M=MARK(IMTAB(IP))
      IF (M.NE.0) THEN
      JP=IMTAB(IP)+1
      GO TO 10
      ELSE
      IF (DEFT(1:1).NE.'.') DEFT(1:4)='.DAT'
      GO TO 5
      ENDIF
C
C  DISC
    7 JP=IMTAB(IP)
      MM=MARK(JP)
      IF (MM.EQ.0) GO TO 5
      GO TO 12
C
C  NAME
    8 JP=IMTAB(1)
      GO TO 12
C
C  DIRECTORY PATH
    9 M=MARK(IMTAB(IP-1))
      MM=MARK(IMTAB(IP))
      IF (M.EQ.0) GO TO 5
      IF (M.GE.MM) GO TO 20
      GO TO 4
C
C  WRITE THE DIFFERENT PARTS TO DEFT
C  SEARCH BACKWARDS FOR NEXT SEPARATOR
   12 DO 11 I=JP-1,1,-1
      M=MARK(I)+1
      IF (M.GT.1) GO TO 10
   11 CONTINUE
      M=1
C
C  AND THEN FORWARDS IF NECESSARY
   10 IF (IP.EQ.2) GO TO 4
      DO 3 I=JP,5
      MM=MARK(I)-1
      IF (MM.GT.0) GO TO 4
    3 CONTINUE
      MM=L
    4 DEFT(IPOS(IP):IPOS(IP+1)-1)=NAMFIL(M:MM)
C
    5 CONTINUE
C
C  CONDENSE AND WRITE BACK TO NAMFIL
      IP=1
      DO 14 JP=1,4
      I=JTAB(JP)
      L=LENG(DEFT(IPOS(I):),IPOS(I+1)-IPOS(I))
      NAMFIL(IP:)=DEFT(IPOS(I):IPOS(I+1)-1)
      IF (I.EQ.3) M=IP
      IP=IP+L
      IF (I.EQ.1) MM=IP-1
   14 CONTINUE
C
      FILNAM(IU)=NAMFIL(M:MM)
      LFIL=IP-1
      GO TO 100
C
C  ERROR
   20 CALL MESS(ITO,0,'Illegal file-name : '//NAMFIL)
CS LAX      CALL MESS(ITO,0,'Should be DISK:[DIRECTORY PATH]NAME.EXT')
      LFIL=0
      GO TO 100
C
C IBM, FOR NOW:
  50  DO 51 I=1,40
      IF (NAMFIL(I:I) .EQ. '.') GO TO 52
  51  CONTINUE
      I=0
C
  52  FILNAM(IU)=NAMFIL(I+1:I+10)
      LFIL=40
C
  100 RETURN
      END
C
C
C
C
C LEVEL 4      SUBROUTINE FINDCD(CH,WORD,LEN,K,LCD)
      SUBROUTINE FINDCD(CH,WORD,LEN,K,LCD)
C
C *** FINDCD updated by JCM 2 Feb 88 ***
C
CX
CC 13C
CH Searches for a card starting with letter CH and with WORD in columns 3-6.
CA On entry CH is a single character with which the card is required to start
CA          WORD is an A4 character variable required in columns 3-6
CA          LEN is the number of characters of WORD required to match (=<4)
CA          K points to the last read card:
CA                   K=0 means start at the beginning of the CH cards
CA                   K>0 implies that the Kth card was a CH card
CA On exit  LCD indicates whether such a card has been found:
CA                   LCD=-1 if no cards are found starting CH
CA                      = 0 if some start CH, but no "WORD"
CA                      >=1 if card found, and then LCD is its position in
CA                          the Crystal Data File.
CD The search starts at the K+1th card of the whole crystal data
CD If a card is found, a copy of the card in A80 FORMAT is in ICARD in /SCRACH
C
C
      CHARACTER *1 CH
      CHARACTER *4 WORD
/CARDRC/
/PHASE/
/SCRACH/
C
      L=-1
      I=LETTER(CH)
C
C IF NO CH CARDS AT ALL, EXIT:
      IF (ICDNO(I) .EQ. 0) GO TO 101
      ID=K+1
      IF (K .EQ. 0) ID=IABS(INREAD(I))
C
C READ NEXT CARD:
   1  IF (ID .GT. NTOTAL(JPHASE)) GO TO 102
      CALL CARDIN(ID)
C WE HAVE TO DO SOMETHING ABOUT CDFS ENDING Y OR Z
      IF (NYZ .EQ. -1) GO TO 102
      ID=ID+NYZ
      L=ID-1
C CHECK WE STILL HAVE CH CARDS:
      IF (ICARD(1:1) .NE. CH) GO TO 102
C IGNORE INTERVENING SPACES:
      DO 88 IST=2,80
      IF (ICARD(IST:IST) .NE. ' ') GO TO 87
  88  CONTINUE
      GO TO 1
C
  87  IF (ICARD(IST:IST+LEN-1) .NE. WORD(1:LEN)) GO TO 1
C FOUND CARD:
      GO TO 101
 102  L=0
 101  LCD=L
      RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE FIXPAR(NP,NFIX)
      SUBROUTINE FIXPAR(NP,NFIX)
C
C *** FIXPAR by JCM 13 Jul 83 ***
C
CX
CC 6A
CH Records an instruction to fix a LSQ parameter.
CA On entry NP= which parameter to fix, assuming that there is a new
CA      numbering of parameters so that NP is an address in the array
CA      NFIX.  All parameters which may be involved with NP must also
CA      have addresses within NFIX.
CA      NFIX is an integer array containing potential chaining information
CA           for the relevant parameters.
CD Records the fixing of the given parameter, and any chained to it.
C
      DIMENSION NFIX(1)
C
      I=NP
   1  IOLD=I
      I=NFIX(I)
      NFIX(IOLD)=0
C I=WHAT WAS THERE FOR CHAINING
      IF ((I .NE. 0) .AND. (I .NE. 9999)) GO TO 1
C UNCHAIN IF FIXED PAR WAS ALREADY RELATED TO ANOTHER
C OUT IF PAR ALREADY FIXED, OR PAR UNREFERENCED SO FAR
      RETURN
      END
C
C
C
C
C LEVEL 8      SUBROUTINE FIXREL(N,NFIX,FIX,KKLIST,NSTAT)
      SUBROUTINE FIXREL(N,NFIX,FIX,KKLIST,NSTAT)
C
C *** FIXREL by JCM 11 Jan 88 ***
C
CX
CC 6A
CH Takes a temporary set of fix/relate information and adds it to the
CH permanent information.
CA          NFIX, FIX contain their temporary fix/relate info out of
CA                    FIXPAR, RELPAR
CA          KKLIST is a list of KK (parameter spec) values corresponding to
CA                    the entries in NFIX
CA          NSTAT is the status to be given to any FIX or CON  info
C
      DIMENSION NFIX(N),FIX(N),KKLIST(N),KK1(2),AM(2)
C
      DO 1 I=1,N
C 9999 MEANS NOTHING KNOWN ABOUT THIS PARAMETER:
      IF (NFIX(I) .EQ. 9999) GO TO 1
C -VE MEANS "THIS PARAMETER ALREADY DEALT WITH BY THIS ROUTINE"
      IF (NFIX(I) .LT. 0) GO TO 1
C 0 MEANS "FIXED":
      IF (NFIX(I) .EQ. 0) THEN
        CALL ADDFIX(KKLIST(I),NSTAT)
        GO TO 1
      ENDIF
C PARAMETER INVOLVED IN (AT LEAST 1) CONSTRAINT:
      I1=I
   2  I2=IABS(NFIX(I1))
C IF CHAIN CLOSED, THIS IS NOT AN EXTRA CONSTRAINT:
      IF (I2 .EQ. I) GO TO 1
      KK1(1)=KKLIST(I)
      KK1(2)=KKLIST(I2)
      AM(1)=FIX(I)
      AM(2)=-FIX(I2)
      CALL ADDCON(2,KK1,AM,NSTAT)
      NFIX(I2)=-NFIX(I2)
C
      I1=I2
      GO TO 2
   1  CONTINUE
C
C RESTORE NFIX +VE:
      DO 3 I=1,N
   3  NFIX(I)=IABS(NFIX(I))
      RETURN
      END
C
C
C
C
C LEVEL 5      SUBROUTINE FIXUNI(A,NDO)
      SUBROUTINE FIXUNI(A,NDO)
C
C *** FIXUNI updated by JCM 26 Sep 84 ***
C
CX
CC 1A
CH Deals with one potential plane face of asymmetric unit, while the unit
CH is being formed.
C
CA On entry NDO indicates the required action:
CA     If NDO is -ve, removes plane number -NDO.
CA     If NDO is +ve, it is the status of plane A, which is to be added
CA            if possible.
CA     A contains the direction cosines of the normal to the offered plane.
C
CD Calls TRYUNI to test particular possible units.  Tests "NICE" on return:
CD   NICE=0  OK, we have a unit of right size with 1 typical refln in it
CD   NICE=1  Unit too big - continue
CD   NICE=-1 Unit not possible - either it is too small, or there is no
CD           typical reflection there at all.
CD
CD TRYUNI also sends back VOL=number of times too big/small unit is, or
CD VOL=0. if there are 3 planes but they form a hinge.
CD
CD Called repeatedly from SYMUNI, which decides what to offer or remove.
CD FIXUNI deals with the "NICE=-1" and the hinge conditions before
CD returning to SYMUNI.
C
      DIMENSION A(3),PTEMP(3)
/IOUNIT/
%      COMMON /SCRAT/AXI(3,%SYMO%,2),MIRROR(%SYMO%),D(3,3),PL1(3),PL2(3),PL3(3),
     & HT(3),ASY(3,4),NSTAT(4),NOPL,NICE,VOL,MOP1,MOP2
C
      IF (NDO .GT. 0) GO TO 1
      J=-NDO
      IF (NSTAT(J) .EQ. 0) GO TO 100
C REMOVE PLANE IF THERE:
      NSTAT(J)=0
      NOPL=NOPL-1
      GO TO 100
C
C ADD PLANE A IF POSSIBLE;  IF NONE THERE ALREADY, SIMPLY ACCEPT:
   1  CALL FCTOR(A,N)
      IF (NOPL .GT. 0) GO TO 2
      NOPL=1
      NSTAT(1)=NDO
      NNEW=1
      CALL GMEQ(A,ASY(1,1),1,3)
      GO TO 10
C
C SOMETHING THERE ALREADY - IF 4, TOO MANY:
   2  IF (NOPL .LT. 4) GO TO 3
      WRITE (LPT,3000) A
      WRITE (ITO,3000) A
3000  FORMAT (/' *** PROGRAM ERROR - OFFERING PLANE',3F5.0,
     & ' TO FIXUNI, WITH 4 PLANES ALREADY')
      STOP
C
C CHECK WE DO NOT ALREADY HAVE A OR -A:
   3  DO 4 I=1,4
      IF (NSTAT(I) .EQ. 0) GO TO 4
      CALL VECPRD(A,ASY(1,I),PTEMP)
      IF (VCTMOD(1.0,PTEMP,1) .LT. 0.0001) GO TO 100
   4  CONTINUE
C
C A IS NEW;  ADD IT, EVEN IF FOR NOW TO POSITION 4:
      DO 7 NNEW=1,4
      IF (NSTAT(NNEW) .EQ. 0) GO TO 8
   7  CONTINUE
C SHOULD NOT BE HERE - ALL 4 SLOTS IN ASY (AND HENCE NSTAT) SHOULD NOT BE FULL:
      WRITE (LPT,3001) NOPL
      WRITE (ITO,3001) NOPL
3001  FORMAT (/' *** PROGRAM ERROR IN FIXUNI - ASY FULL BUT NOPL=',I3)
      STOP
C
    8  NOPL=NOPL+1
      NSTAT(NNEW)=NDO
      CALL GMEQ(A,ASY(1,NNEW),1,3)
C
C NOW TEST NEW CONFIGURATION - IF 4 PLANES JOIN PART WHICH TAKES ONLY 3:
  10  IF (NOPL .GE. 4) GO TO 11
      CALL TRYUNI(0)
      IF (NICE) 12,100,13
C
C PLANE NOT TO BE USED - REMOVE:
  12  NOPL=NOPL-1
      NSTAT(NNEW)=0
      GO TO 100
C
C PLANE OK BUT VOL TOO BIG (OR A HINGE):
  13  IF (NOPL .NE. 3) GO TO 100
C IF ONLY 1 OR 2 PLANES, NOTHING MORE WE CAN DO; (4 PLANES NOT HERE)
      IF (VOL .NE. 0.) GO TO 100
C HERE IF 3 PLANES ALL JOINING AT HINGE:
  11  NOPL=NOPL-1
C WE OFFER TO TRYUNI SUBSETS OF WHAT WE HAVE IN ASY, OMITTING ONE PLANE AT ONCE
      OLDVOL=100.
      DO 14 I=1,4
C NOT IF PLANE NOT THERE:
      IF (NSTAT(I) .EQ. 0) GO TO 14
C DO NOT OMIT A MANDATORY PLANE:
      IF (NSTAT(I) .EQ. 2) GO TO 14
C OR THE NEWLY OFFERED ONE:
      IF (I .EQ. NNEW) GO TO 14
      NSTATS=NSTAT(I)
      NSTAT(I)=0
      CALL TRYUNI(0)
      IF (NICE) 5,100,15
C
C IF NICE EVER BECOMES -1, OMIT NEW PLANE:
   5  NSTAT(I)=NSTATS
      NSTAT(NNEW)=0
      GO TO 100
C
C VOL IS STILL TOO LARGE:
  15  IF (VOL .GT. OLDVOL) GO TO 6
C KEEP SMALLEST FOUND VOL
      OLDVOL=VOL
C PUT PLANE BACK:
      N1=I
   6  NSTAT(I)=NSTATS
  14  CONTINUE
C
C STILL TOO BIG, BUT SHOULD HAVE SMALLEST VOL OF HINGE IN OLDVOL, AND THE PLANE
C WE OMITTED TO GET IT IN N1:
      NSTAT(N1)=0
C TIDY UP AGAIN:
      CALL TRYUNI(0)
 100  RETURN
      END
C
C
C
C
C LEVEL 6      SUBROUTINE FIXVAR(FX,IFAM,IGEN,ISPC,KP,KS,NSTAT)
      SUBROUTINE FIXVAR(FX,IFAM,IGEN,ISPC,KP,KS,NSTAT)
C
C *** FIXVAR by JCM 9 Nov 90 ***
C
CX
CC 6C
CH Adds a request to fix (or vary) a parameter to the lists held in setting
CH up LSQ environments.
CA On entry:
CA For entries FIXVAR, ADDFX5, ADDVR5:
CA    IFAM, IGEN, ISPC are the family, genus & species of the parameter
CA    KP, KS are the phase & source if relevant, or may be zero
CA For entry FVKPAK, ADDFIX, ADDVAR
CA          KK is the packed parameter spec, possibly incomplete
CA          NSTAT is the status of the request (5=not changeable)
CA                                             (4=changeable)
CP LSETUP must have initialised the list
CD Ensures an entry in the fix/vary list for the given parameter.
CD If there already was one for exactly this parameter, alters it as
CD requested, checking that the request is reasonable.
CD Records whether the request was fix or vary in KSTFV, as + or -
CD Records status of request also in KSTFV.
CD Records time of request in KTIME, so that conflict can be resolved.
CD Keeps count of total number of such requests in NUMFV
CD Sets KTYPFV to 0 if the packed KK was complete (ie specific), or an
CD address in the table KUNPFV into which the incomplete KK has been
CD unpacked for future reference.
CN Also entries ADDFIX, ADDVAR, FVKPAK
C
      LOGICAL FX,FIX,KWHOLE
      CHARACTER *4 FV(2),NAM1,NAM2
      DIMENSION K(5)
/IOUNIT/
/LINKAG/
/PHASE/
/SOURCE/
      DATA FV/'fix','vary'/
C
C EITHER FIX OR VARY, GIVEN FAMILY, GENUS & SPECIES WITH PHASE & SOURCE
      KK=KPAK(IFAM,IGEN,ISPC,KP,KS)
      FIX=FX
      GO TO 1
C
C FIXING ENTRY WITH UNPACKED 5:
      ENTRY ADDFX5(IFAM,IGEN,ISPC,KP,KS,NSTAT)
      KK=KPAK(IFAM,IGEN,ISPC,KP,KS)
      FIX=.TRUE.
      GO TO 1
C
C VARYING ENTRY WITH UNPACKED 5:
      ENTRY ADDVR5(IFAM,IGEN,ISPC,KP,KS,NSTAT)
      KK=KPAK(IFAM,IGEN,ISPC,KP,KS)
      FIX=.FALSE.
      GO TO 1
C
C FIXING ENTRY WITH PACKED PARAMETER SPEC:
      ENTRY ADDFIX(KKK,NSTAT)
      FIX=.TRUE.
      GO TO 10
C
C VARYING ENTRY WITH PACKED PARAMETER SPEC:
      ENTRY ADDVAR(KKK,NSTAT)
      FIX=.FALSE.
      GO TO 10
C
C EITHER FIX OR VARY ENTRY, WITH PACKED KK:
      ENTRY FVKPAK(KKK,NSTAT,FX)
      FIX=FX
  10  KK=KKK
C IS IT THERE ALREADY?
   1  IF (NUMFV .EQ. 0) GO TO 2
      N=NFIND(KK,KKFV,NUMFV)
      IF (N .EQ. 0) GO TO 2
C IF THERE, RECORD OLD AND NEW FIX OR VARY INDICATORS:
      I1=1
      IF (.NOT. FIX) I1=2
      I2=1
      IF (KSTFV(N) .LT. 0) I2=2
C CANNOT LOWER STATUS:
      IF (NSTAT .GE. IABS(KSTFV(N))) GO TO 3
C
C THIS IS A SIMPLIFICATION COVERING EXISTING CASES:
      CALL PARNAM(NAM1,NAM2,3,KK)
      CALL MESS(LPT,0,'Ignored request to '//FV(I1)//' parameter '//
     & NAM1//NAM2//' - fixed by symmetry')
      GO TO 100
C
C A NEW REQUEST - ACCEPT IT:
%   2  CALL ERRCHK(2,NUMFV,%FXVA%,0,'fix or vary requests')
      N=NUMFV
      KKFV(N)=KK
C RECORD WHETHER OR NOT KK COMPLETE:
      KTYPFV(N)=0
      IF (.NOT. KWHOLE(KK,K)) THEN
%        CALL ERRCHK(2,NUMPAK,%FVPK%,0,'incomplete fix/vary requests')
        KTYPFV(N)=NUMPAK
        CALL JGMEQ(K,KUNPFV(1,NUMPAK),1,5)
      ENDIF
C
C JOIN HERE TO UPDATE AN EXISTING ENTRY:
   3  KSTFV(N)=NSTAT
      IF (.NOT. FIX) KSTFV(N)=-NSTAT
      KTIME(N)=NTICK(NTIME)
 100  RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE FLIP(I,J)
      SUBROUTINE FLIP(I,J)
C
C *** FLIP by JCM 4 Feb 88 ***
C
CX
CC 16C
CH Exchanges the integers I and J.
CA On entry I and J holds certain values
CA On exit their values have been exchanged.
C
      K=I
      I=J
      J=K
      RETURN
      END
C
C
C
C
C LEVEL 6      SUBROUTINE FMCALC(H,FMCMOD,FMCSQR)
      SUBROUTINE FMCALC(H,FMCMOD,FMCSQR)
C
C *** FMCALC COMMON MAGSF  added for magnetic structure factor
C C4.30  August 2016 ***
C
CX
CC 17B
CH Calculates magnetic interaction vectors and magnetic structure factors.
CA On entry H is the 1x3 vector containing h,k,l
CA On exit   FMCMOD = domain average of the lengths of the m.i. vector
CA           FMCSQR = square of the above
CD On exit Q(1:3,1:NDOM) in COMMON QCAL contains the magnetic interaction
CD vectors for each of the NDOM domains.
CP STHL in /BRAGG should hold sin theta/lambda
CP NKSTAR in /SATELL should have been set up by routine KSTAR
CP
CP The setting up routines:
CP     RECIP  (for the cell parameters)
CP     SYMOP  (for the space group symmetry)
CP     SETFOR (for the scattering factors, both nuclear and magnetic)
CP     SETANI (for the anisotropic temperature factors)
CP     DOMAG1(1) and (2) (for the magnetic structure) and
CP     SPHELI (to set up the spin directions on spherical polars)
CP should all have been obeyed to set up the structure.
CD Sets SSQRD in /BRAGG to be STHL squared
CD Gives zero as answers for magnetic absences
CN There is also the routine LMCALC which does a similar calculation but also
CN calculates derivatives, for use in LSQ.
C
      COMPLEX SUM1(3),TERM,TVEC(3),FORM,HR,FORMFA,P(3)
      COMPLEX PSIFAC,PSIFCC
      LOGICAL SKIP,MAGABS
      DIMENSION RH(3),H(3),RS(3,3),HD(3,3),SDOM(3,3)
/BRAGG/
/CONSTA/
/IOUNIT/
/MAGDAT/
/MAGSF/
/NSYM/
/POSNS/
/QCAL/
/SATELL/
/SYMDA/
/SYMMAG/
/SYMTAB/
C
C CLEAR ALL ANSWERS IN CASE ABSENT:
C
C CLEAR MODULUS AND SQUARE:
      FMCMOD=0.
      FMCSQR=0.
      SSQRD=STHL*STHL
C
C OUT IF ABSENT:
      IF (MAGABS(H,IK)) GO TO 100
      TAU=-FLOAT(IK)
C
C  CYCLE OVER DOMAINS
      ND=0
      IHELIX=1
      IF (HELI) THEN
        IHELIX=2
C4.7  CHIRALITY DOMAINS, structure factors are complex conjugate
C  no need to calculate separately
C        IF (IABS(IPROP).EQ.1 .AND. CENTRC) ICHIR=2
      ENDIF
      SKIP=.FALSE.
      DO 15 IDOMOP=1,NOPC
      IF (FERO .AND. IDOMOP .NE.1) GO TO 18
C DOMAINS EXIST FOR ALL ELEMENTS NOT IN THE MAGNETIC GROUP
      IF (IDOMOP.NE.1 .AND. IABS(MSTAB(IDOMOP)).NE.IDOMOP) GO TO 15
C FMC COLLECTS THE MAGNETIC STRUCTURE FACTOR, A COMPLEX VECTOR,
C ZEROED BEFORE CALCULATING THE VALUE FOR EACH DOMAIN
      CALL CGMZER(FMC,1,3)
C FIRST SCATTERING FACTOR:
      IFF=0
C
C CYCLE OVER MAGNETIC ATOMS:
      DO 1 IM=1,NMAG
      IR=JMAGAT(IM)
C
C JUMP IF FORM/SCATTERING FACTOR THE SAME AS BEFORE
      IF (NMFORM(IM) .EQ. IFF) GO TO 2
C IF NOT, GET IT
      IFF=NMFORM(IM)
      FORM=FORMFA(STHL,IFF)
C  CALCULATE FOR EACH COMPONENT OF THE HELIX IN TURN
   2  DO 30 ICOMP=1,IHELIX
      CALL CGMZER(SUM1,3,1)
C INNER LOOP OVER SYMMETRY EQUIVALENTS:
C PREPARE TO COUNT OPERATORS USED
      NOPU=0
      DO 3 IS=1,NOPC
C  ONLY USE OPERATORS WHICH LEAVE THE PROPAGATION DIRECTION INVARIANT
      IF (IS.NE.1 .AND.IABS(KSTAB(IS)).NE.1) GO TO 3
C  THE OPERATOR TO USE IS THE PRODUCT OF IS WITH THAT CREATING THE DOMAIN
      IROP=MULTAB(IDOMOP,IS)
      IF (MODUL) THEN
C INSYM IS THE NUMBER OF THE CO-SET ELEMENT INVOLVED (FROM THE CO-SET NSYM)
C IT MAY BE NEGATIVE IF INVERSION IS INCLUDED
C Better correction for IROP=1 Feb 1998
        IF (IROP.EQ.1) THEN
          INSYM=1
        ELSE
          INSYM=MSTAB(IROP)
        ENDIF
C ISBGN IS THE NUMBER OF THE SUBLATTICE GENERATED BY INSYM
        ISBGN=IPTAB(IABS(INSYM),IM)
C THE NUMBBERS IN LPHI MAY ALSO BE NEGATIVE IF INVERSION IS INVOLVED
C SKIP IF IROP DOESNT GENERATE A DISTINCT SUB-LATTICE
        IF (LPHI(ISBGN,IM).NE.INSYM) GO TO 3
      ENDIF
      CALL ROTSYM(H,RH,IROP,-1)
      IF (IDOMOP .NE.1 .AND. MSTAB(IDOMOP).LT.0) CALL GMREV(RH,RH,3,1)
      F1=TWOPI*(SCALPR(X(1,IR),RH)+SCALPR(TRANS(1,IROP),H))
C  ANISOTROPIC T F (=1. IF NOT THERE) NEEDED SEPARATELY FOR LSQ:
      ERS=ANITF(RH,IR)
      ARS=COS(F1)*ERS
      BRS=SIN(F1)*ERS
      TERM=CMPLX(ARS,BRS)
C  FIND OUT WHAT THE SYMMETRY DOES TO THE SPIN DIRECTION
      CALL ROTMAG(SPIND(1,1,ICOMP,IM),SDOM,IS)
C  GET THE SPIN DIRECTION FOR THIS DOMAIN
      CALL ROTOSM(SDOM,RS,IDOMOP,1)
      CALL C1MSCA(RS,TVEC,TERM,3,1)
      PSIFAC=CMPLX(1.,0)
      PSIFCC=CMPLX(1.,0)
      IF (MODUL) THEN
C INCLUDE A PHASE SHIFT FOR THIS SUB-LATTICE IF NECESSARY
        IP=IPTAB(IROP,IM)
        TEST=TAU*(RADIAN(PHIH(IP,IM)))
        PSIFAC=CEXP(CMPLX(0.,TEST))
C141 Logical FCENT now used to determine whether to set phase shifts
        IF (FCENT(IM)) THEN
          IP=IPTAB(IROP+NOPC,IM)
          TEST=TAU*(RADIAN(PHIH(IP,IM)))
          PSIFCC=CEXP(CMPLX(0.,TEST))
        ENDIF
      ENDIF
C IF CENTROSYMMETRIC, COMPENSATE FOR USING ONLY HALF NUMBER OF OPERATORS:
C  OTRSYM(NOPC+1) SHOULD CONTAIN THE MATRIX RELATING THE MAGNETIC COMPONENTS
C  OF ATOMS RELATED BY THE CENTRE OF SYMMETRY, WHETHER THIS IS IN THE
C  MAGNETIC GROUP OR NOT.
C141 Logic here simplified because PSIFAC and PSICEN are now always set
      IF (CENTRC) THEN
        CALL CENTRO(TVEC,TVEC,OTRSYM(1,1,NOPC+1),PSIFAC,PSIFCC)
      ELSE
      IF (MODUL) CALL CGMSCA(TVEC,TVEC,PSIFAC,3,1)
      ENDIF
      CALL CGMADD(SUM1,TVEC,SUM1,1,3)
C
C INCREMENT COUNT OF OPERATORS USED
      NOPU=NOPU+1
C END OF INNERMOST CYCLE OVER SYMMETRY
    3 CONTINUE
C
      FAC=AMULT(IR)*EXP(-(TF(IR)*SSQRD))
C COMPENSATE FOR NOT USING ALL SYMMETRY ELEMENTS
      FACTOR=FLOAT(NOPC)/FLOAT(NOPU)
      FAC=FAC*FACTOR
C SCALE MOMENT TO CMS-12
      SM=SMOD(ICOMP,IM)*VALMUB
C HR IS PRODUCT OF ATOM DEPENDENT BUT SYMMETRY INDEPENDENT FACTORS
      HR=FAC*FORM*SITE(IR)
      TERM=HR*SM
C SHIFT THE PHASE OF THE PERPENDICULAR COMPONENT OF THE SPIRAL
      IF (ICOMP.EQ.2) THEN
        TERM=TERM*CMPLX(0.,TAU)
      ENDIF
      CALL CGMSCA(SUM1,TVEC,TERM,3,1)
      CALL CGMADD(FMC,TVEC,FMC,1,3)
   30 CONTINUE
C
C
   1  CONTINUE
C END OF CYCLE OVER ATOMIC POSITIONS
C
C  COMPENSATE FOR MULTIPLICITY OF THE STAR
        CALL CMRSCA(FMC,FMC,FKSTAR,3,1)
C
C FMC is the magnetic structure factor, we now calculate
C the interaction vector from it
C4.30 Get FMSQR needed in sorpol
      FMSQR=RSCALP(FMC,FMC)
C NOW THE CYCLE FOR THE DOMAIN AVERAGE
   18 IF (IDOMOP .EQ.1 .OR. FERO) CALL MAGDOM(H,HD,IDOMOP,SKIP)
      CALL RCMPRD(HD,FMC,P,3,3,1)
      FMCSQR=FMCSQR+RSCALP(P,P)
      IF (.NOT.SKIP) ND=ND+1
      IF (FERO) THEN
C       PUT Q BACK INTO UNROTATED FRAME
        CALL CROTO(P,Q(1,ND),IS,1)
      ELSE
        CALL CGMEQ(P,Q(1,ND),3,1)
      ENDIF
   15 CONTINUE
C
C NOW THE DOMAIN AVERAGE
        FMCSQR=FMCSQR/FLOAT(ND)
        FMCMOD=SQRT(FMCSQR)
C
 100  RETURN
      END
C
C
C
C
C LEVEL 6      SUBROUTINE FMMPCA(H,FMCMOD,FMCSQR)
      SUBROUTINE FMMPCA(H,FMCMOD,FMCSQR)
C
C *** FMMPCA from FMCALC by PJB 16 Feb 2001 ***
C
CX
CC 18B
CH Calculates magnetic interaction vectors and magnetic structure factors with
CH multipole form factors.
CA On entry H is the 1x3 vector containing h,k,l
CA On exit   FMCMOD = domain average of the lengths of the m.i. vector
CA           FMCSQR = square of the above
CD On exit Q(1:3,1:NDOM) in COMMON QCAL contains the magnetic interaction
CD vectors for each of the NDOM domains.
CP STHL in /BRAGG should hold sin theta/lambda
CP NKSTAR in /SATELL should have been set up by routine KSTAR
CP
CP The setting up routines:
CP     RECIP  (for the cell parameters)
CP     SYMOP  (for the space group symmetry)
CP     SETFOR (for the scattering factors, both nuclear and magnetic)
CP     PFSET  (for the multipole form factors
CP     SETANI (for the anisotropic temperature factors)
CP     DOMAG1(1) and (2) (for the magnetic structure) and
CP     SPHELI (to set up the spin directions on spherical polars)
CP should all have been obeyed to set up the structure.
CD Sets SSQRD in /BRAGG to be STHL squared
CD Gives zero as answers for magnetic absences
CN There is also the routine LMMCA which does a similar calculation but also
CN calculates derivatives, for use in LSQ.
C
      COMPLEX SUM1(3),TERM,TVEC(3),HR,P(3)
      COMPLEX PFACS(50),TERMF,PSUM
      COMPLEX PSIFAC,PSIFCC
      LOGICAL SKIP,MAGABS,BINDIG
      DIMENSION RH(3),H(3),RS(3,3),HD(3,3),SDOM(3,3)
/BRAGG/
/CONSTA/
/IOUNIT/
/MAGDAT/
/MPODA/
/MPODAC/
/NSYM/
/POLDA/
/POLFOR/
/POSNS/
/QCAL/
/SATELL/
/SYMDA/
/SYMMAG/
/SYMTAB/
C
C CLEAR ALL ANSWERS IN CASE ABSENT:
C
C CLEAR MODULUS AND SQUARE:
      FMCMOD=0.
      FMCSQR=0.
      SSQRD=STHL*STHL
C
C OUT IF ABSENT:
      IF (MAGABS(H,IK)) GO TO 100
      TAU=-FLOAT(IK)
C
C  CYCLE OVER DOMAINS
      ND=0
      IHELIX=1
      IF (HELI)  IHELIX=2
      SKIP=.FALSE.
      DO 15 IDOMOP=1,NOPC
      IF (FERO .OR. FERA .AND. IDOMOP .NE.1) GO TO 18
C DOMAINS EXIST FOR ALL ELEMENTS NOT IN THE MAGNETIC GROUP
      IF (IDOMOP.NE.1 .AND. IABS(MSTAB(IDOMOP)).NE.IDOMOP) GO TO 15
C FMC COLLECTS THE MAGNETIC STRUCTURE FACTOR, A COMPLEX VECTOR,
C ZEROED BEFORE CALCULATING THE VALUE FOR EACH DOMAIN
      CALL CGMZER(FMC,1,3)
C FIRST SCATTERING FACTOR:
      IFF=0
C
C CYCLE OVER MAGNETIC ATOMS:
      DO 1 IM=1,NMAG
      IR=JMAGAT(IM)
C
C128 get the multipole form factor number for this atom
      IMPFOR =MPFOR(NMFORM(IM))
C  SET MP TO THE MULTIPOLE ATOM AND NMP1, NMP2 TO SCAN ITS MULTIPOLES:
      MP=MPNMTB(IR)
      IF (MP.EQ.0) THEN
        NMP1=0
        NMP2=-1
C128 form factors for non-multipole atoms
        IF (IMPFOR .NE.0 .AND. MPLFOR(1,IMPFOR).EQ.-999) THEN
          AKK = FOURPI*STHL
          PSUM=FORMFC(AKK,0,0,NMFORM(IM))
        ELSE
          PSUM=FORMFA(STHL,NMFORM(IM))
        ENDIF
      ELSE
        NMP1=MPTAB(MP)
        NMP2=MPTAB(MP+1)-1
C128 RADIAL FORM FACTORS: only for multipole atoms
        CALL PFORMF(H,MP,PSUM,PFACS,0)
      ENDIF
C
C RADIAL FORM FACTORS:
      CALL PFORMF(H,MP,PSUM,PFACS,0)
C
C  CALCULATE FOR EACH COMPONENT OF THE HELIX IN TURN
      DO 30 ICOMP=1,IHELIX
      CALL CGMZER(SUM1,3,1)
C INNER LOOP OVER SYMMETRY EQUIVALENTS:
C PREPARE TO COUNT OPERATORS USED
      NOPU=0
      DO 3 IS=1,NOPC
C  ONLY USE OPERATORS WHICH LEAVE THE PROPAGATION DIRECTION INVARIANT
      IF (IS.NE.1 .AND.IABS(KSTAB(IS)).NE.1) GO TO 3
C  THE OPERATOR TO USE IS THE PRODUCT OF IS WITH THAT CREATING THE DOMAIN
      IROP=MULTAB(IDOMOP,IS)
      IF (MODUL) THEN
C INSYM IS THE NUMBER OF THE CO-SET ELEMENT INVOLVED (FROM THE CO-SET NSYM)
C IT MAY BE NEGATIVE IF INVERSION IS INCLUDED
C Better correction for IROP=1 Feb 1998
        IF (IROP.EQ.1) THEN
          INSYM=1
        ELSE
          INSYM=MSTAB(IROP)
        ENDIF
C ISBGN IS THE NUMBER OF THE SUBLATTICE GENERATED BY INSYM
        ISBGN=IPTAB(IABS(INSYM),IM)
C THE NUMBBERS IN LPHI MAY ALSO BE NEGATIVE IF INVERSION IS INVOLVED
C SKIP IF IROP DOESNT GENERATE A DISTINCT SUB-LATTICE
        IF (LPHI(ISBGN,IM).NE.INSYM) GO TO 3
      ENDIF
      CALL ROTSYM(H,RH,IROP,-1)
      IF (IDOMOP .NE.1 .AND. MSTAB(IDOMOP).LT.0) CALL GMREV(RH,RH,3,1)
      F1=TWOPI*(SCALPR(X(1,IR),RH)+SCALPR(TRANS(1,IROP),H))
C  ANISOTROPIC T F (=1. IF NOT THERE) NEEDED SEPARATELY FOR LSQ:
      ERS=ANITF(RH,IR)
      ARS=COS(F1)*ERS
      BRS=SIN(F1)*ERS
      TERM=CMPLX(ARS,BRS)
C NON-SPHERICAL FORM FACTORS:
      CALL PFORMF(RH,MP,PSUM,PFACS,1)
C APPLY FORM FACTOR HERE (IN SIMPLER APPLICATIONS IT IS OUTSIDE THE
C SYMMETRY LOOP):
      TERMF=TERM*PSUM
      IF (FERA ) THEN
C FOR FERA THE SPIN IS PARALLEL TO THE POLARISATION
         CALL GMEQ(POLND,RS,3,1)
      ELSE
C  FIND OUT WHAT THE SYMMETRY DOES TO THE SPIN DIRECTION
        CALL ROTMAG(SPIND(1,1,ICOMP,IM),SDOM,IS)
C  GET THE SPIN DIRECTION FOR THIS DOMAIN
        CALL ROTOSM(SDOM,RS,IDOMOP,1)
      ENDIF
      CALL C1MSCA(RS,TVEC,TERMF,3,1)
      PSIFAC=CMPLX(1.,0)
      PSIFCC=CMPLX(1.,0)
      IF (MODUL) THEN
C INCLUDE A PHASE SHIFT FOR THIS SUB-LATTICE IF NECESSARY
        IP=IPTAB(IROP,IM)
        TEST=TAU*(RADIAN(PHIH(IP,IM)))
        PSIFAC=CEXP(CMPLX(0.,TEST))
        IF (FCENT(IM)) THEN
          IP=IPTAB(IROP+NOPC,IM)
          TEST=TAU*(RADIAN(PHIH(IP,IM)))
          PSIFCC=CEXP(CMPLX(0.,TEST))
        ENDIF
      ENDIF
C IF CENTROSYMMETRIC, COMPENSATE FOR USING ONLY HALF NUMBER OF OPERATORS:
C  OTRSYM(NOPC+1) SHOULD CONTAIN THE MATRIX RELATING THE MAGNETIC COMPONENTS
C  OF ATOMS RELATED BY THE CENTRE OF SYMMETRY, WHETHER THIS IS IN THE
C  MAGNETIC GROUP OR NOT.
      IF (CENTRC) THEN
        CALL CENTRO(TVEC,TVEC,OTRSYM(1,1,NOPC+1),PSIFAC,PSIFCC)
      ELSE
      IF (MODUL) CALL CGMSCA(TVEC,TVEC,PSIFAC,3,1)
      ENDIF
      CALL CGMADD(SUM1,TVEC,SUM1,1,3)
C
C INCREMENT COUNT OF OPERATORS USED
      NOPU=NOPU+1
C END OF INNERMOST CYCLE OVER SYMMETRY
      IF (BINDIG(IOUT,128))
     &WRITE (LPT,1040) ND,IS,NOPU,TVEC,SUM1
 1040 FORMAT (4X,3I4,2(3(2F8.3,1X),2X))
    3 CONTINUE
C
      FAC=AMULT(IR)*EXP(-(TF(IR)*SSQRD))
C COMPENSATE FOR NOT USING ALL SYMMETRY ELEMENTS
      FACTOR=FLOAT(NOPC)/FLOAT(NOPU)
      FAC=FAC*FACTOR
C SCALE MOMENT TO CMS-12
      SM=SMOD(ICOMP,IM)*VALMUB
C HR IS PRODUCT OF ATOM DEPENDENT BUT SYMMETRY INDEPENDENT FACTORS
      HR=FAC*SITE(IR)
      TERM=HR*SM
C SHIFT THE PHASE OF THE PERPENDICULAR COMPONENT OF THE SPIRAL
      IF (ICOMP.EQ.2) THEN
        TERM=TERM*CMPLX(0.,TAU)
      ENDIF
      CALL CGMSCA(SUM1,TVEC,TERM,3,1)
      CALL CGMADD(FMC,TVEC,FMC,1,3)
   30 CONTINUE
C
C
   1  CONTINUE
C END OF CYCLE OVER ATOMIC POSITIONS
C
C  COMPENSATE FOR MULTIPLICITY OF THE STAR
        CALL CMRSCA(FMC,FMC,FKSTAR,3,1)
C
C FMC is the magnetic structure factor, we now calculate
C the interaction vector from it
C NOW THE CYCLE FOR THE DOMAIN AVERAGE
   18 IF (IDOMOP .EQ.1 .OR. FERO) CALL MAGDOM(H,HD,IDOMOP,SKIP)
      CALL RCMPRD(HD,FMC,P,3,3,1)
      FMCSQR=FMCSQR+RSCALP(P,P)
      IF (.NOT.SKIP) ND=ND+1
      IF (FERO) THEN
C       PUT Q BACK INTO UNROTATED FRAME
        CALL CROTO(P,Q(1,ND),IS,1)
      ELSE
        CALL CGMEQ(P,Q(1,ND),3,1)
      ENDIF
   15 CONTINUE
C
C NOW THE DOMAIN AVERAGE
        FMCSQR=FMCSQR/FLOAT(ND)
        FMCMOD=SQRT(FMCSQR)
C
 100  RETURN
      END
C
C
C
C
C LEVEL 7      COMPLEX FUNCTION FMPCAL(H)
      COMPLEX FUNCTION FMPCAL(H)
C
CX
CC 18B
CH Calculates the COMPLEX nuclear structure factor for the reflection H, using
CH a multipole expansion of the form factor.
C
      COMPLEX TERM,CRS,SUM1,HR,PSUM,PFACS(50)
      LOGICAL LATABS
      DIMENSION H(3),RH(3)
/BRAGG/
/CONSTA/
/FCAL/
/FORMDA/
/MPODA/
/MPODAC/
/NSYM/
/POLFOR/
/POSNS/
/SYMDA/
C
C CLEAR ANSWERS IN CASE ABSENT:
C
C  FC COLLECTS THE CONVENTIONAL STRUCTURE FACTOR, COMPLEX:
      FC=CMPLX(0.,0.)
C CLEAR MODULUS AND ANGLES:
      FCMOD=0.
      COSAL=0.
      SINAL=0.
C OUT IF ABSENT:
      IF (LATABS(H)) GO TO 100
C
C STHL = SIN THETA/LAMBDA
      STHL=VCTMOD(0.5,H,2)
C
C SET FIRST SCATTERING FACTOR:
      IFF=0
C
C CYCLE OVER INDEPENDENT ATOMS:
      DO 1 IR=1,NATOM
C
C128 get the multipole form factor number for this atom
      IMPFOR =MPFOR(NFORMF(IR))
C  SET MP TO THE MULTIPOLE ATOM
      MP=MPNMTB(IR)
      IF (MP.EQ.0) THEN
C128 get form factors for non-multipole atoms
        IF (IMPFOR .NE.0 .AND. MPLFOR(1,IMPFOR).EQ.-999) THEN
          AKK = FOURPI*STHL
          PSUM=FORMFC(AKK,0,0,NFORMF(IR))
        ELSE
          PSUM=FORMFA(STHL,NFORMF(IR))
        ENDIF
      ELSE
C128  CALCULATE RADIAL FORM-FACTORS now only for multipole atoms
        CALL PFORMF(H,MP,PSUM,PFACS,0)
      ENDIF
C
      SUM1=CMPLX(0.,0.)
C  CALCULATE RADIAL FORM-FACTORS
      CALL PFORMF(H,MP,PSUM,PFACS,0)
C
C INNER LOOP OVER SYMMETRY EQUIVALENTS:
      DO 3 IS=1,NOPC
      CALL ROTSYM(H,RH,IS,-1)
C CALCULATE NON-SPHERICAL FORM FACTORS
      CALL PFORMF(RH,MP,PSUM,PFACS,1)
      F1=TWOPI*(SCALPR(X(1,IR),RH)+SCALPR(TRANS(1,IS),H))
      ERS=ANITF(RH,IR)
C ANISOTROPIC T F (=1. IF NOT THERE) NEEDED SEPARATELY FOR LSQ:
      CRS=CEXP(CMPLX(0.,F1))*ERS
      TERM=CRS*PSUM
      ARS=REAL(TERM)
      BRS=AIMAG(TERM)
      SUM1=SUM1+TERM
C
   3  CONTINUE
C END OF INNERMOST CYCLE OVER SYMMETRY
C
C IF CENTROSYMMETRIC, COMPENSATE FOR USING ONLY HALF NUMBER OF OPERATORS:
      IF (CENTRC) SUM1=SUM1+CONJG(SUM1)
C
      FAC=AMULT(IR)*EXP(-(TF(IR)*STHL*STHL))
      HR=FAC*SITE(IR)
C HR IS PRODUCT OF ATOM DEPENDENT BUT SYMMETRY INDEPENDENT FACTORS
      FC=FC + HR*SUM1
C
   1  CONTINUE
C END OF CYCLE OVER ATOMIC POSITIONS
C
C  TIDY FCALC AND COLLECT TRUE D(MODFC)/D(VARIABLE)
C
      A = REAL(FC)
      B = AIMAG(FC)
      FCMOD = SQRT(A*A+B*B)
      FMPCAL=FC
 100  RETURN
      END
C
C
C
C
C LEVEL 8      SUBROUTINE FORIER(IIN,IOP,START)
      SUBROUTINE FORIER(IIN,IOP,START)
C
C *** FORIER updated by PJB 29 Apr 88 ***
C
CX
CC 5B
CH Controls Fourier calculations.
C
CA On entry START, a logical, indicates whether this is the first call of FORIER
CA On exit  IIN indicates how the next map is to be obtained:
CA          IIN = 1 means get back previously saved map
CA                2 means read back pre-calculated map in binary form
CA                3 means calculate map using FOUR1Z
CA                4 means calculate map using FOURGP (general plane)
CA                5 means calculate map using ERRMAP (error map)
CA          IOP indicates how the next map is to be sent out:
CA          IOP contains 1 bit = print
CA                       2 bit = plot
CA                       4 bit = save
C
CP Must be set up by a call of SETFOU, reading the relevant M cards
C
CD If 2D (NDIM=2), only one possible map, a projection, is involved.  If 3D
CD (NDIM=3), several layers may be involved.  Their values of Z are stored
CD in arrays:
CD    ZRDVAL for reading down pre-calculated maps
CD    ZGTVAL for getting back previously saved maps
CD    ZSVVAL for saving maps just calculated
CD    ZPRVAL for printing
CD    ZPLVAL for plotting
CD NDIM=4 is a request for a bounded section
C
      LOGICAL START
/CONTUR/
/MAPDA/
/MAPGT/
/MAPPR/
/MAPRD/
/MAPSV/
/SCRACH/
C
C DOES NOT OPEN FILE FROM WHICH TO READ REFLECTIONS - ASSUMES USER WANTS
C TO DO IT HIMSELF IN MAIN
C SET ZERO FOR A START
      IOP=0
      IIN=0
C  THEN SWITCH IF NOT STARTING
      IF (START) THEN
      START=.FALSE.
C
C SET FLAG TO SAY NO MAPS SAVED YET (TO BE CONSULTED IN SAVMAP):
      NSAV=0
C
C IF SAVING , OPEN FILE (IF GETTING, FILE IS OPENED IN MAJUST):
      MESSAG='Saved maps'
      NAMFIL='.SAV'
      IF (IZSV .GT. 0) CALL OPNFIL(NDUMPS,1112)
C
C IF READING BINARY PRE-CALCULATED MAP, OPEN FILE:
      MESSAG='Pre-calculated maps'
      IF (IZRD .GT. 0) CALL OPNFIL(IDUMPR,1011)
C
      IF (NDIM .EQ. 2) GO TO 1
C
C 3D - FIND ALL VALUES OF Z IN ALL 5 LISTS:
      IPR=1
      IF (IZPR .EQ. 0) THEN
      ZCPR=99999.
      ELSE
      ZCPR=ZPRVAL(1)
      ENDIF
      IPL=1
      IF (IZPL .EQ. 0) THEN
      ZCPL=99999.
      ELSE
      ZCPL=ZPLVAL(1)
      ENDIF
      ISV=1
      IF (IZSV .EQ. 0) THEN
      ZCSV=99999.
      ELSE
      ZCSV=ZSVVAL(1)
      ENDIF
      IGT=1
      IF (IZGT .EQ. 0) THEN
      ZCGT=99999.
      ELSE
      ZCGT=ZGTVAL(1)
      ENDIF
      IRD=1
      IF (IZRD .EQ. 0) THEN
      ZCRD=99999.
      ELSE
      ZCRD=ZRDVAL(1)
      ENDIF
C
      ENDIF
C  START HERE AFTER FIRST ENTRY
C
      IF (NDIM.EQ.2) GO TO 1
C
C NEXT VALUE OF Z:
      Z=AMIN1(ZCPL,ZCSV,ZCPR,ZCGT,ZCRD)
      IF (Z.GT.99998.) GO TO 100
      OUTLIM(1,3)=Z
C
C DO WE NEED TO GET SAVED FILE FOR THIS VALUE OF Z?
      IF (ABS(ZCGT-Z) .GT. 10.E-5) GO TO 37
      IIN=1
      IGT=IGT+1
      ZCGT=ZGTVAL(IGT)
      IF (IGT.GT.IZGT) ZCGT=99999.
      GO TO 10
C
C DO WE NEED TO READ BINARY FILE FOR THIS VALUE OF Z?
  37  IF (ABS(ZCRD-Z) .GT. 10.E-5) GO TO 97
      IIN=2
      IRD=IRD+1
      ZCRD=ZRDVAL(IRD)
      IF (IRD.GT.IZRD) ZCRD=99999.
      GO TO 10
C
C WE WANT TO CALCULATE A NEW MAP:
  97  IF (MODET .EQ. 2) THEN
      IIN=4
      ELSE
      IF (MODEF .LT. 7) IIN=3
      IF (MODEF .EQ. 7) IIN=5
      ENDIF
C
C DO WE WANT TO PRINT AT THIS VALUE OF Z?
  10  IF (ABS(ZCPR-Z) .GT. 10.E-5) GO TO 17
      IOP=IOP+1
      IPR=IPR+1
      ZCPR=ZPRVAL(IPR)
      IF (IPR.GT.IZPR) ZCPR=99999.
C
C DO WE WANT TO PLOT AT THIS VALUE OF Z?
  17  IF (ABS(ZCPL-Z) .GT. 10.E-5) GO TO 7
      IOP=IOP+2
      IPL=IPL+1
      ZCPL=ZPLVAL(IPL)
      IF (IPL.GT.IZPL) ZCPL=99999.
C
C DO WE WANT TO SAVE THIS VALUE OF Z?
   7  IF (ABS(ZCSV-Z) .GT. 10.E-5) GO TO 8
      IOP=IOP+4
      ISV=ISV+1
      ZCSV=ZSVVAL(ISV)
      IF (ISV.GT.IZSV) ZCSV=99999.
   8  IF (NDIM.NE.4 .OR.IOP.EQ.0) GO TO 100
C
C  SPECIAL FOR BOUNDED SECTIONS
      SECEND=Z
      IF (ZCPL.LT.99999.) SECEND=ZCPL
      IF (ZCPR.LT.99999.) SECEND=AMAX1(SECEND,ZCPR)
      IF (ZCSV.LT. 99999.) SECEND=AMAX1(SECEND,ZCSV)
      IF (ZCPR .LT.99999.) THEN
        IF (ABS(SECEND-ZCPR).GT.10.E-4) THEN
          IPR=IPR-1
          ZCPR=ZPRVAL(IPR)
        ELSE
          IPR=IPR+1
          ZCPR=ZPRVAL(IPR)
          IF (IPR.GT.IZPR) ZCPR=99999.
        ENDIF
      ENDIF
      IF (ZCPL.LT. 99999.) THEN
        IF (ABS(SECEND-ZCPL).GT.10.E-4) THEN
          IPL=IPL-1
          ZCPL=ZPLVAL(IPL)
        ELSE
          IPL=IPL+1
          ZCPL=ZPLVAL(IPL)
          IF (IPL.GT.IZPL) ZCPL=99999.
        ENDIF
      ENDIF
      IF (ZCSV.LT.99999.) THEN
        IF (ABS(SECEND-ZCSV).GT.10.E-4) THEN
          ISV=ISV-1
          ZCSV=ZSVVAL(ISV)
        ELSE
          ISV=ISV+1
          ZCSV=ZSVVAL(ISV)
          IF (ISV.GT.IZSV) ZCSV=99999.
        ENDIF
      ENDIF
      GO TO 100
C
C 2D IS EASIER BECAUSE THERE IS NO Z COUNT:
    1 IF (IZGT .EQ. 0) GO TO 2
      IIN=1
      GO TO 3
   2  IF (IZRD .EQ. 0) GO TO 90
      IIN=2
      GO TO 3
  90  OUTLIM(1,3)=0.
      IIN=3
      IF (MODEF .EQ. 7) IIN=5
   3  IF (IZPR .NE. 0) IOP=IOP+1
      IF (IZPL .NE. 0) IOP=IOP+2
      IF (IZSV .NE. 0) IOP=IOP+4
      GO TO 100
C
  100 RETURN
      END
C
C
C
C
C LEVEL 2      COMPLEX FUNCTION FORMFA(AK,II)
      COMPLEX FUNCTION FORMFA(AK,II)
C
C *** FORMFA updated by JCM 25 Jan 91 ***
C
CX
CC 4B
CH Calculates form or scattering factors.
CA On entry AK=sin theta/lambda if relevant
CA          II=which factor is required
CA On exit  FORMFA holds the factor.
CP SETFOR must have read and interpreted F cards.
C
CD Allows 5 types of scattering factor, depending on MODE(I):
CD    MODE(I)=1 neutron nuclear factor, the COMPLEX value (CMULT(I),0.)
CD            2 exponential series of NT(I) terms held in F(,I)
CD            3 interpolation in table of NT(I) entries held in S(,I) and F(,I)
CD            4 as 2, but also times sin theta/lambda squared.
CD            5 Form factor to be calculated from radial wave-functions
CD              given on W cards and read by RADFUN (allowed by SETFOR
CD              but not included in FORMFA;  see FORFAC)
CD    Types 2,3 and 4 may also be multiplied by a constant in CMULT(I)
CD
CD If NAMODE(I)=1, an anomalous scattering factor is added from FDASH(,I)
CO For type 3, if AK is given outside the range in S(,I), an error message is
CO given and the routine stops.
C
/ANSCAT/
/FORMDA/
/IOUNIT/
C
      I=II
      M = MODE(I)
      GO TO (1,2,3,2,100), M
C
C     NEUTRON NUCLEAR SCATTERING:
   1  G = 1.0
      GO TO 20
C
C     FORM FACTORS AS EXPONENTIAL SERIES:
    2 N = NT(I)
      G = F(N,I)
      N = N-2
      DO 5 L = 1,N,2
      ARG = F(L+1,I)*AK*AK
      IF (ARG .LE. 174) G = G + F(L,I)*EXP(-ARG)
    5 CONTINUE
      IF (M .EQ. 4) G=G*AK*AK
      GO TO 20
C
C     FORM FACTORS GIVEN IN A TABLE:
    3 N = NT(I)
      IF ((AK .LE. S(N,I)) .AND. (AK .GE. S(1,I))) GO TO 14
      WRITE (LPT,3000) AK,I
      WRITE (ITO,3000) AK,I
3000  FORMAT(/' ERROR **  sin theta/lamda =',F6.3,
     & ' outside range of table for form factor number',I3)
      STOP
C
  14  IF (N .LT. 5) THEN
        NN = N
        MM = 1
        GO TO 11
      ENDIF
      D1 = ABS(AK-S(1,I))
      DO 6 J = 2,N
      D = ABS(AK-S(J,I))
      IF (D .GT. D1) GO TO 13
      D1 = D
    6 CONTINUE
C
      M = N
      GO TO 8
C
   13 M = J-1
      IF (M.GT.2) GO TO 8
      MM = 1
      GO TO 12
    8 IF (M+2.GT.N) THEN
        MM = N-4
      ELSE
        MM = M-2
      ENDIF
   12 NN = 5
   11 CALL TB02A (S(MM,I),F(MM,I),AK,G,NN)
C
  20  FORMFA=CMPLX(G*CMULT(I),0.)
C ANOMALOUS SCATTERING IF GIVEN:
 100  IF (NAMODE(I) .EQ. 1) FORMFA=FORMFA+FDASH(I)
      RETURN
      END
C
C
C
C
C LEVEL 5      FUNCTION FORMFC(AK,L,MODE,JAT)
      FUNCTION FORMFC(AK,L,MODE,JAT)
C
C *** FORMFC updated by PJB/JBF 3 Sep 89 ***
C
CX
CC 4B
CH Calculates form factor integrals from radial wave functions.
CA On entry AK=4*pi* sin theta/lamda.
CA          MODE=0 requests FORMFC to be <Jl>
CA          MODE=1 requests <Gl>, the orbital integral
CA          MODE=2 requests the wavefunction factor.
CA On exit FORMFC contains the form factor
CP RADFUN should have read the radial wave function
C
/RADINT/
C
      IAT=NFIND(JAT,IRADF,NRADF)
      FORMFC = 0.
      IMAX = NTERMS(IAT)
      DO 1 I = 1,IMAX
      IF (MODE .EQ. 2) THEN
        FORMFC = FORMFC + FF(1,I,IAT)*EXPINT(AK,FF(2,I,IAT),N(I,IAT),L)
        GO TO 1
      ENDIF
C
      DO 2 J = 1,IMAX
      MAX = N(I,IAT)+N(J,IAT)
      NUM = MAX+1
      P = FF(2,I,IAT) + FF(2,J,IAT)
      IF (MODE .EQ.0) GO TO 3
      FAC = 1/P
      G = 0
      DO 5 M = 1,NUM
      G = G + FAC*EXPINT(AK,P,MAX-M,L)
    5 FAC = FAC*FLOAT(MAX-M+1)/P
      FORMFC = FORMFC + FF(1,I,IAT)*FF(1,J,IAT)*G*2.
      IF (MODE .EQ.1) GO TO 2
    3 FORMFC = FORMFC + FF(1,I,IAT)*FF(1,J,IAT)*EXPINT(AK,P,MAX,L)
    2 CONTINUE
    1 CONTINUE
      RETURN
      END
C
C
C
C
C LEVEL 6      SUBROUTINE FOUINP(K,F,ALPHA,MODED,MODEF,ENDIP)
      SUBROUTINE FOUINP(K,F,ALPHA,MODED,MODEF,ENDIP)
C
C *** FOUINP updated by JCM 14 Apr 89 ***
C
CX
CC 5C
CH Reads one data item for a given type of Fourier, in a given format.
CA On entry MODED indicates the data format type, from M DTYP card
CA     MODED=0: user-supplied routine QFOUIN should set K, F, ALPHA, ENDIP
CA     MODED=1: read H,K,L FCAL,FOBS,(D)
CA     MODED=2: read H,K,L, mod(FCAL), phase angle, FOBS
CA     MODED=3: read H,K,L, A, B, FOBS
CA     MODED=4: read H,K,L, FOBS (or FCAL)
CA On entry MODEF indicates the Fourier type required, from M FTYP card
CA     MODEF=1:   FCAL
CA     MODEF=2:   FOBS (Centrosymmetric)
CA     MODEF=3:   mod(FOBS)*phase(FCAL)
CA     MODEF=4:   FOBS-FCAL
CA     MODEF=5:   (mod(FOBS)-mod(FCAL))*phase(FCAL)
CA     MODEF=6:   FOBS*FOBS (Patterson)
CA On exit  K is a 1x3 integer vector holding h,k,l
CA          F is a 1x2 vector holding whichever of FOBS, etc were requested
CA          ALPHA, if relevant, holds the phase
CA          ENDIP is a logical set TRUE if the end of the input has occurred.
CO Checks that MODED and MODEF are compatible and complains and stops if not.
C
      LOGICAL ENDIP
      DIMENSION K(3),F(3),H(3)
/CONSTA/
/IOUNIT/
C
      ENDIP=.FALSE.
      IF (MODED .GT. 0) GO TO 9
      CALL QFOUIN(K,F,ALPHA,ENDIP)
      GO TO 100
C
   9  CALL RDDATA(LUNI,K,H,F,3,IOU)
      IF (IOU .EQ. -9999) GO TO 101
      GO TO (11,12,13,14) , MODED
  11  ALPHA = PIBY2 - SIGN(PIBY2,F(1))
      GO TO 100
C
  12  ALPHA=F(2)
      F(2)=F(3)
      GO TO (100,99,100,99,100,100),MODEF
C
  13  FA=F(1)
      FB=F(2)
      F(2)=F(3)
      F(1) = SQRT(FA*FA+FB*FB)
      IF (F(1) .EQ. 0.) GO TO 9
      ALPHA = ATAN2(FB,FA)
      GO TO (100,99,100,99,100,100),MODEF
C
  14  F(2)=F(1)
      GO TO (99,100,99,99,99,100),MODEF
C
C ERROR:
  99  CALL ERRMES(1,0,'MODEF & MODED values incompatible')
C
C  MARK END OF DATA
  101 ENDIP=.TRUE.
  100 RETURN
      END
C
C
C
C
C LEVEL 7      SUBROUTINE FOUR1D
      SUBROUTINE FOUR1D
C
C *** FOUR1D by PJB Dec 85 ***
C
CX
CC 5B
CH Calculates a Fourier along a general line.
CP SETFOU should have been obeyed to read M, N and I  cards and set up
CP the calculation.
CD Uses FOUINP to allow all different data input and Fourier types.
CD Puts calculated 1-D Fourier in array DENS in /MAPDA
C
CN Expects that the h,k,l values cover a suitable asymmetric unit, from which it
CN uses the given symmetry to generate an entire reciprocal space full.  If the
CN data stray outside one asymmetric unit, some h,k,l values will occur more
CN than once.
C
      COMPLEX RHO(1500),CE(100,3),FAC(2),Y,YM
      LOGICAL USED,ENDIP
%      DIMENSION H(3,%SY*2%),HI(3),K(3),F(2)
      DIMENSION KLIM(3),SF(2),ALPH(2)
/CONSTA/
/MAPDA/
/NSYM/
      EQUIVALENCE (DENS,RHO),(CE,DENS(3001)),(KLIM(1),NH)
C
C NOBSIN COUNTS DATA READ, NUSED COUNTS THOSE USED
      NOBSIN=-1
      NUSED=0
      SCALEF=SCALF1*SCALF2
C
      NY=4*NX
C     CLEAR STORE FOR SUM OVER L
      DO 1 M = 1,NY
    1 DENS(M) = 0.
C
C  GET RQUIRED TRIG FUNCTIONS
      DO 2 I=1,3
      KK=KLIM(I)+1
      AMP=-(TWOPI*OUTLIM(3,I))
      CALL TRIG(CE(1,I),AMP,KK)
    2 CONTINUE
C
C  NOW READ REFLECTIONS
    7 USED=.FALSE.
      CALL FOUINP(K,F,ALPHA,MODED,MODEF,ENDIP)
      IF (ENDIP) GO TO 20
C
      NOBSIN=NOBSIN+1
      CALL INDFLO(HI,K)
C DO NOT USE IF SIN THETA/LAMBDA TOO LARGE:
      VL =VCTMOD(0.5,HI,2)
      IF (VL .GT. SMAX) GO TO 7
C
C APPLY RESOLUTION FUNCTION AND USER'S SCALE:
      AMP = RESOL(HI,DELTA)*SCALEF
      DO 3 MODE=1,2
      CALL CHOOSF(F,SF(MODE),ALPHA,ALPH(MODE),MODE)
C SF AND ALPHA NOW SET UP:
C
C DOUBLE ALL BUT 000 REFLN. AS WE ARE ONLY USING HALF RECIPROCAL SPACE:
      IF  ((K(1).NE.0).OR.(K(2).NE.0).OR.(K(3).NE.0))
     & SF(MODE)=2.*SF(MODE)
C
      SF(MODE)=SF(MODE)*AMP
    3 CONTINUE
C
C DEAL WITH SYMMETRY EQUIVALENTS:
      MI=0
C TO MAKE EQVEC ACCEPT FIRST SET OF INDICES
      DO 8 N = 1,NOPC
      CALL SYMEQU(HI,H,K,N,MI,UU,BETA)
      IF (UU.EQ.0.) GO TO 8
      USED=.TRUE.
      FAC(1)=SF(1)*CEXP(CMPLX(0.,UU*ALPH(1)+BETA))
      FAC(2)=SF(2)*CEXP(CMPLX(0.,UU*ALPH(2)+BETA))
      DO 9 I=1,NX
      RHO(I)=RHO(I)+FAC(1)
      RHO(NX+I)=RHO(NX+I)+FAC(2)
      YM=CMPLX(1.,0.)
      DO 10 J=1,3
      Y=CE(IABS(K(J))+1,J)
      IF (K(J).LT.0) Y=CONJG(Y)
   10 YM=YM*Y
      FAC(1)=FAC(1)*YM
      FAC(2)=FAC(2)*YM
    9 CONTINUE
C
    8 CONTINUE
      IF (USED) NUSED=NUSED+1
      GO TO 7
C
C  HERE ON END OF DATA
   20 NY=2*NX
      II=2*NY
      DO 11 I=1,NY,2
      DENS(II+I)=DENS(NY+I)-DENS(I)
   11 CONTINUE
C
      RETURN
      END
C
C
C
C
C LEVEL 7      SUBROUTINE FOUR1Z
      SUBROUTINE FOUR1Z
C
C *** FOUR1Z corrected by PJB 17-Jun-1994 ***
C
CX
CC 5B
CH Calculates 1 layer of Fourier sum : a section if 3D, a projection if 2D,
CH or a bounded section if "4D".
C
CP Must be set up by call to SETFOU to read M, N, I cards
C
CD Uses FOUINP to allow all different data input and Fourier types.
CD Puts calculated  Fourier map in array DENS in /MAPDA
C
CN Expects that the h,k,l values cover a suitable asymmetric unit, from which it
CN uses the given symmetry to generate an entire reciprocal space full.  If the
CN data stray outside one asymmetric unit, some h,k,l values will occur more
CN than once.
CN
CN Ignores FRIEDL - if non-centrosymmetric, and Friedel's law not to be assumed,
CN the user must do something to combine F(H,K,L) and F(-H,-K,-L) outside
CN FOUR1Z.
C
      LOGICAL USED,ENDIP
%      DIMENSION H(3,%SY*2%),HI(3),K(3),F(3),SINCO(200)
/CONSTA/
/MAPDA/
/NSYM/
      COMMON /SCRAT/SUM(10201)
C
C NOBSIN COUNTS DATA READ, NUSED COUNTS THOSE USED
      NOBSIN=0
      NUSED=0
      SCALEF=SCALF1*SCALF2
C
C SET ORIGIN OF SECTION:
      DO 2 I=1,3
   2  SECZER(I)=OUTLIM(1,I)
C
C     CLEAR STORE FOR SUM OVER L
      DO 1 M = 1,NHK
    1 DENS(M) = 0.
C
C JJ=H MAX + 1
      JJ = ((NH-1)/2)+1
C  NOW READ REFLECTIONS
    7 USED=.FALSE.
      CALL FOUINP(K,F,ALPHA,MODED,MODEF,ENDIP)
      IF (ENDIP) GO TO 20
C
      NOBSIN=NOBSIN+1
      CALL INDFLO(HI,K)
C DO NOT USE IF SIN THETA/LAMBDA TOO LARGE:
      IF (VCTMOD(0.5,HI,2) .GT. SMAX) GO TO 7
C
C APPLY RESOLUTION FUNCTION AND USER'S SCALE:
      AMP = RESOL(HI,DELTA)*SCALEF
      CALL CHOOSF(F,SF,ALPHA,ALPH,MODEF)
C SF AND ALPHA NOW SET UP:
C
C DOUBLE ALL BUT 000 REFLN. AS WE ARE ONLY USING HALF RECIPROCAL SPACE:
      IF  ((K(1).NE.0).OR.(K(2).NE.0).OR.(K(3).NE.0))
     & SF=2.*SF
C
      SF=SF*AMP
C
C DEAL WITH SYMMETRY EQUIVALENTS:
C TO MAKE EQVEC ACCEPT FIRST SET OF INDICES
      MI=0
C TRANSFORM HI (GIVEN H) TO OCCUPY FIRST PLACE IN TABLE FOR EQVEC:
      CALL GMEQ(HI,H(1,1),1,3)
      CALL GMPRD(H(1,1),U,HI,1,3,3)
      DO 8 N = 1,NOPC
      CALL SYMEQU(HI,H,K,N,MI,UU,BETA)
      IF (UU.EQ.0.) GO TO 8
      USED=.TRUE.
C49 - SECTION updated by PJB
      ALPHA1=ALPH*SIGN(1.,UU)+BETA
      SFUU=SF*ABS(UU)
      KF=1
      KH = 2*(NK*(K(1)+JJ-1)+K(2)+KF)
      DENS(KH-1) = DENS(KH-1)+SFUU*COS(ALPHA1)
      DENS(KH) = DENS(KH) + SFUU*SIN(ALPHA1)
C49 - END OF UPDATED SECTION
C
    8 CONTINUE
      IF (USED) NUSED=NUSED+1
      GO TO 7
C
C     SUM OVER L COMPLETED - ALL REFLECTIONS HAVE BEEN READ
C CLEAR STORE FOR SUM OVER H:
  20  DO 30 N = 1,NKX
   30 SUM(N) = 0.
C
C SET UP COS AND SIN TABLES:
      CALL TRIG (SINCO,TWOPI*OUTLIM(3,1),JJ)
      KH = 1
      DO 34 IH=1,NH
      KXI = 1
      J = 2*IABS(IH-JJ)+1
      SD = -SINCO(J+1)
      CD = SINCO(J)
      IF (IH .LT. JJ) SD = -SD
      DO 34 IK=1,NK
      KX = KXI
      IF ((DENS(KH) .EQ. 0.) .AND. (DENS(KH+1) .EQ.0.)) GO TO 39
      C = DENS(KH)
      S = DENS(KH+1)
      DO 38 N=1,NX
      SUM(KX) = SUM(KX) + C
      SUM(KX+1) = SUM(KX+1) + S
      CNEW = C*CD - S*SD
      S = C*SD + S*CD
      C = CNEW
   38 KX = KX+2
   39 KH = KH+2
   34 KXI = KXI + 2*NX
C
C     SUM OVER H COMPLETE
C FINAL SUM OVER K:
      KF=NK
      CALL TRIG(SINCO,TWOPI*OUTLIM(3,2),KF)
C CLEAR DENS FOR ANSWERS:
      DO 40 N = 1,NXY
   40 DENS(N) = 0.
      KX = 1
      DO 41 IK=1,NK
      KK = 2*IK
      CD = SINCO(KK-1)
      SD = -SINCO(KK)
      DO 42 N = 1,NX
      M = N
      IF ((SUM(KX) .EQ. 0.) .AND. (SUM(KX+1) .EQ. 0.)) GO TO 42
      C = SUM(KX)
      S = SUM(KX+1)
      DO 43 IY = 1,NY
      DENS(M) = DENS(M) + C
      CNEW = C*CD - S*SD
      S = C*SD + S*CD
      C = CNEW
   43 M = M+NX
   42 KX = KX+2
   41 CONTINUE
      RETURN
      END
C
C
C
C
C LEVEL 7      SUBROUTINE FOURGP
      SUBROUTINE FOURGP
C
C *** FOURGP by PJB Dec 85 ***
C
CX
CC 5B
CH Calculates a Fourier on a general plane.
C
CP Must be set up by call to SETFOU to read M, N, I cards
C
CD Uses FOUINP to allow all different data input and Fourier types.
CD Puts calculated  Fourier map in array DENS in /MAPDA
C
CN Expects that the h,k,l values cover a suitable asymmetric unit, from which it
CN uses the given symmetry to generate an entire reciprocal space full.  If the
CN data stray outside one asymmetric unit, some h,k,l values will occur more
CN than once.
CN
CN Ignores FRIEDL - if non-centrosymmetric, and Friedel's law not to be assumed,
CN the user must do something to combine F(H,K,L) and F(-H,-K,-L) outside
CN FOURGP
C
      COMPLEX RHO,CE,Y,YM(2),VAL
      LOGICAL USED,ENDIP
%      DIMENSION H(3,%SY*2%),HI(3),K(3),F(2)
      DIMENSION KLIM(3)
/CONSTA/
/MAPDA/
/NSYM/
      COMMON /SCRAT/RHO(100),CE(100,6)
      EQUIVALENCE (KLIM(1),NH)
C
C NOBSIN COUNTS DATA READ, NUSED COUNTS THOSE USED
      NOBSIN=0
      NUSED=0
      SCALEF=SCALF1*SCALF2
C
C     CLEAR STORE FOR SUM
      DO 1 M = 1,NXY
    1 DENS(M) = 0.
C
C
C  GET REQUIRED TRIG FUNCTIONS, AND TRANSFORMED STARTING POS
      L=1
      DO 2 J=1,3
      SECZER(J)=0.
      DO 2 I=1,3
      IF (J.EQ.3) GO TO 4
      KK=KLIM(I)+1
      AMP=-(TWOPI*OUTLIM(3,J)*U(I,J))
      CALL TRIG(CE(1,L),AMP,KK)
      L=L+1
    4 SECZER(J)=SECZER(J)+OUTLIM(1,I)*U(J,I)
    2 CONTINUE
C
C  NOW READ REFLECTIONS
    7 USED=.FALSE.
      CALL FOUINP(K,F,ALPHA,MODED,MODEF,ENDIP)
      IF (ENDIP) GO TO 100
C
      NOBSIN=NOBSIN+1
      CALL INDFLO(HI,K)
C DO NOT USE IF SIN THETA/LAMBDA TOO LARGE:
      IF (VCTMOD(0.5,HI,2) .GT. SMAX) GO TO 7
C
C APPLY RESOLUTION FUNCTION AND USER'S SCALE:
      AMP = RESOL(HI,DELTA)*SCALEF
      CALL CHOOSF(F,SF,ALPHA,ALPH,MODEF)
C SF AND ALPHA NOW SET UP:
C
C DOUBLE ALL BUT 000 REFLN. AS WE ARE ONLY USING HALF RECIPROCAL SPACE:
      IF  ((K(1).NE.0).OR.(K(2).NE.0).OR.(K(3).NE.0))
     & SF=2.*SF
C
      SF=SF*AMP
C
C DEAL WITH SYMMETRY EQUIVALENTS:
      MI=0
C TO MAKE EQVEC ACCEPT FIRST SET OF INDICES
      DO 8 N = 1,NOPC
      CALL SYMEQU(HI,H,K,N,MI,UU,BETA)
      IF (UU.EQ.0.) GO TO 8
      USED=.TRUE.
      VAL=SF*CEXP(CMPLX(0.,UU*ALPH+BETA))
      L=1
      DO 9 I=1,2
      YM(I)=CMPLX(1.,0.)
      DO 9 J=1,3
      Y=CE(IABS(K(J))+1,L)
      L=L+1
      IF (K(J).LT.0) Y=CONJG(Y)
   9  YM(I)=YM(I)*Y
C
      L=1
      RHO(1)=VAL
      DO 10 J=1,NY
      VAL=RHO(J)
      RHO(J+1)=RHO(J)*YM(2)
      DO 10 I=1,NX
      DENS(L)=DENS(L)+REAL(VAL)
      L=L+1
      VAL=VAL*YM(1)
   10 CONTINUE
C
    8 CONTINUE
      IF (USED) NUSED=NUSED+1
      GO TO 7
C
C  HERE ON END OF DATA
  100 RETURN
      END
C
C
C
C
C LEVEL 2      SUBROUTINE FRAC3(VEC)
      SUBROUTINE FRAC3(VEC)
C
C *** FRAC3 by JCM 11 Nov 83 ***
C
CX
CC 1C
CH Makes all 3 elements of a vector fractional
CA On entry VEC is a 1x3 real vector.
CA On exit the elements of VEC have each been put into the range 0 =< X < 1
C
      DIMENSION VEC(3)
C
      DO 1 I=1,3
   1  CALL FRACT(VEC(I),A,J)
      RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE FRACT(X,Y,N)
      SUBROUTINE FRACT(X,Y,N)
C
C *** FRACT by JCM ***
C
CX
CC 9C
CH Forms the fractional part of a real number.
CA On entry X is a real number
CA On exit  X is in the range 0=< X <1
CA          Y is set so that X+Y=original X
CA          N= 0 if X was unchanged
CA           = 1 if X was >= 1
CA           =-1 if X was < 0
C
      Y=0.
      N=1
      IF (X .GE. 1.) GO TO 1
      N=0
      IF (X .GE. 0.) GO TO 100
C OUT IN USUAL CASE OF X ALREADY BEING +VE FRACTION
C
      N=-1
   1  Y=AINT(X)
      IF (N .EQ. -1) Y=Y-1.0
      X=X-Y
 100  RETURN
      END
C
C
C
C
C LEVEL 6      SUBROUTINE FRAME(X1,Y1,X2,Y2)
      SUBROUTINE FRAME(X1,Y1,X2,Y2)
C
C *** FRAME by JCM 24 Nov 83 ***
C
CX
CC 14C
CH Draws a rectangle in the plotting context.
CA On entry (X1,Y1) and (X2,Y2) are the coordinates of opposite corners of
CA the required rectangle.  These are in "current coordinates"
CP The plotting must have been set up by, e.g. STPLOT, and a suitable space
CP selected by SPCSET.
C
      CALL KANGA1(X1,Y1,3)
      CALL KANGA1(X1,Y2,2)
      CALL KANGA1(X2,Y2,2)
      CALL KANGA1(X2,Y1,2)
      CALL KANGA1(X1,Y1,2)
      RETURN
      END
C
C
C
C
C LEVEL 1    SUBROUTINE FT01A(IT,INV,TR,TI)
      SUBROUTINE FT01A(IT,INV,TR,TI)
C
C *** FT01A updated by JCM FROM HARWELL ROUTINE 9 Sep 91 ***
C
CX
CC 9C
CH Modification of Harwell Fast Fourier Transform.
C
%      DIMENSION TR(%FFT2%),TI(%FFT2%)
      EXTERNAL FFTADD
/CONSTA/
      COMMON /FFTDA/KJUMP,UR(15),UI(15)
C
      GO TO (1,2),KJUMP
   1  UM=0.5
      DO 6 I=1,15
      UM=0.5*UM
      TH=TWOPI*UM
      UR(I)=COS(TH)
   6  UI(I)=SIN(TH)
      KJUMP=2
C
C SECOND AND SUBSEQUENT ENTRIES:
   2  UM=1.
      IF (INV .EQ. 1) UM=-1.
      IO=2
      DO 3 I=2,16
      IO=IO+IO
      IF(IO-IT)3,4,99
   3  CONTINUE
C ERROR EXIT - IT NOT A POWER OF 2, OR TOO BIG:
  99  INV=-1
      GO TO 100
C
   4  IO=I
      II=IO
      I1=IT/2
      I3=1
  10  K=0
      I2=I1+I1
  11  WR=1.
      WI=0.
      KK=K
      JO=IO
C
  12  IF (KK .EQ. 0) GO TO 13
  14  JO=JO-1
      KK1=KK
      KK=KK/2
      IF (KK1 .EQ. 2*KK) GO TO 14
      WS=WR*UR(JO)-WI*UI(JO)
      WI=WR*UI(JO)+WI*UR(JO)
      WR=WS
      GO TO 12
C
  13  WI=WI*UM
      J=0
C
   9  L=J*I2+K
      L1=L+I1
      ZR=TR(L+1)+TR(L1+1)
      ZI=TI(L+1)+TI(L1+1)
      Z=WR*(TR(L+1)-TR(L1+1))-WI*(TI(L+1)-TI(L1+1))
      TI(L1+1)=WR*(TI(L+1)-TI(L1+1))+WI*(TR(L+1)-TR(L1+1))
      TR(L+1)=ZR
      TR(L1+1)=Z
      TI(L+1)=ZI
      J=J+1
      IF (J.LT. I3) GO TO 9
      K=K+1
      IF (K .LT. I1) GO TO 11
      I3=I3+I3
      IO=IO-1
      I1=I1/2
      IF (I1 .GT. 0) GO TO 10
      J=1
      UM=1.
      IF (INV .EQ. 1) UM=1./FLOAT(IT)
C
   7  K=0
      J1=J
      DO 8 I=1,II
      J2=J1/2
      K=2*(K-J2)+J1
   8  J1=J2
C
      IF (K .GE. J) THEN
        IF (K .EQ. J) THEN
          TR(J+1)=TR(J+1)*UM
          TI(J+1)=TI(J+1)*UM
        ELSE
          ZR=TR(J+1)
          ZI=TI(J+1)
          TR(J+1)=TR(K+1)*UM
          TI(J+1)=TI(K+1)*UM
          TR(K+1)=ZR*UM
          TI(K+1)=ZI*UM
        ENDIF
      ENDIF
      J=J+1
      IF (J .LT. IT-1) GO TO 7
      TR(1)=TR(1)*UM
      TI(1)=TI(1)*UM
      TR(IT)=TR(IT)*UM
      TI(IT)=TI(IT)*UM
 100  RETURN
      END
C
C
C
C
      BLOCK DATA FFTADD
      COMMON /FFTDA/KJUMP,UR(15),UI(15)
      DATA KJUMP/1/
      END
C
C
C
C
C LEVEL 4      SUBROUTINE FUDGET(IPT,ITYP,F1,F2)
      SUBROUTINE FUDGET(IPT,ITYP,F1,F2)
C
C *** FUDGET by JCM 10 Feb 87 ***
C
CX
CC 6C
CH Reads a fudge factor from a card having already read a parameter
CH specification.
C
CA IPT on entry points at next char on card ICARD
CA IPT on exit has been advanced by the amount read
CA ITYP on exit = type of factor read
CA F1 on exit = first no. read if appropriate
CA F2 on exit = second no. read if appropriate
CP Card is held in /SCRACH/ in ICARD
C
CD Reads one of:
CD    a number into F1 (setting ITYP=1)
CD    "GE" number into F1 (setting ITYP=2)
CD    "LE" number into F2 (setting ITYP=3)
CD    both the above, setting ITYP=4
C
      CHARACTER *10 WORD
      ITYP=1
      IPKEEP=IPT
      CALL RDREAL(F1,IPT,IPT,80,IER)
C IF NUMBER READ, TYPE 1 SIMPLE MULTIPLICATIVE FACTOR:
      IF (IER .EQ. 0) GO TO 100
C
C WORD READ - EXPECT GE OR LE
      IPT=IPKEEP
  42  IPKEEP=IPT
      CALL RDWORD(WORD,LEN,IPT,IPT,80,0,IER)
      IF (WORD .NE. 'GE') GO TO 41
      IF (ITYP .GT. 1) ITYP=4
      IF (ITYP .EQ. 1) ITYP=2
      CALL RDREAL(F1,IPT,IPT,80,IER)
      GO TO 42
  41  IF (WORD .NE. 'LE') GO TO 43
      IF (ITYP .GT. 1) ITYP=4
      IF (ITYP .EQ. 1) ITYP=3
      CALL RDREAL(F2,IPT,IPT,80,IER)
      GO TO 42
C
C NEITHER GE NOR LE - MAY BE NEXT PARAMETER SPEC:
  43  IPT=IPKEEP
 100  RETURN
      END
C
C
C
C
C LEVEL 7      SUBROUTINE FUDGIN(MAGPAR)
      SUBROUTINE FUDGIN(MAGPAR)
C
C *** FUDGIN updated by PJB C4.26  March 2013 it now has a dummy argument ***
C
CX
CC 6A
CH Interprets all L FUDG cards.
CD Sets NFUDGE in /FUDG to be the number of fudge factors read.
CD Reads from the cards sets of <parameter specification> <fudge factor>
CD The parameter specification may be any of those described under PARRD
CD The fudge factor may be one of:
CD    1)  A simple multiplicative factor
CD    2)  GE followed by a lower limit
CD    3)  LE followed by an upper limit
CD    4)  both 2) and 3) in either order
C
      EXTERNAL MAGPAR
      LOGICAL MAGPAR
      DIMENSION IPARS(4)
/CARDRC/
/FUDG/
/IOUNIT/
/PHASE/
/SCRACH/
/SOURCE/
C
      IN=0
C NEXT "L FUDG" CARD:
  31  CALL FINDCD('L','FUDG',4,IN,L)
      IF (L .LE. 0) GO TO 100
      CALL MESS(LPT,0,'Fudge factor:')
      CALL MESS(LPT,0,ICARD(7:80))
      IN=L
      IPT=7
C READ NEXT PARAMETER SPEC ON CARD:
   3  IPTT=IPT
      CALL PARRD(IPT,IPT,K,IFAM,IGEN,ISPC)
      IF (K) 1,31,2
C
C K +VE - A PACKED PARAMETER SPEC:
   2  IER=IERR
%      CALL ERRCHK(2,NFUDGE,%FUDG%,0,'fudge factors')
      IF (IER .NE. IERR) GO TO 100
C
C READ FUDGE FACTOR:
      IFDGPT(NFUDGE)=K
      CALL FUDGET(IPT,IFDTYP(NFUDGE),FUDGE1(NFUDGE),FUDGE2(NFUDGE))
      GO TO 3
C
C K -VE - A WORD LIKE ALL(-100), ONLY (-99)
   1  I=-K-98
      GO TO (11,12) , I
C
C 'ONLY' SHOULD BE A MISTAKE HERE:
  11  CALL ERRMES(1,1,'"ONLY" not allowed on L FUDG card')
      GO TO 3
C
C 'ALL' SHOULD BE ACCOMPANIED BY EITHER +VE IFAM, MEANING THAT A (POSSIBLY
C  PARTIAL) PARAMETER SPEC IS GIVEN, OR -VE IFAM, MEANING THAT A COMPOSITE
C WORD FOLLOWED THE 'ALL':
C IFAM=-1 XYZ, -2 BIJ, -3 XYZT, -4 CELL, -5 XYZB, -6 XYZS
C BY CONVENTION - THIS MUST HAVE BEEN BUILT IN TO THE MAIN PROGRAM
  12  IF (IFAM .LE. 0) GO TO 5
      K=KPAK(IFAM,IGEN,ISPC,KPHASE,KSOURC)
      GO TO 2
C
   5  II=-IFAM
      GO TO (21,22,21,24,25,21) , II
C Not defined in SF try magpar
      CALL FUDGET(IPT,ITYP,F1,F2)
      IDOTH=6
      IF (IFAM.LT.0) IDOTH=7
   37 IF (MAGPAR(II,IDOTH,IPARS)) THEN
        DO 35 J=IPARS(3),IPARS(4)
        IER=IERR
%        CALL ERRCHK(2,NFUDGE,%FUDG%,1,'FUDGE FACTORS')
        IF (IER .NE. IERR) GO TO 100
        IFDTYP(NFUDGE)=ITYP
        FUDGE1(NFUDGE)=F1
        FUDGE2(NFUDGE)=F2
        IFDGPT(NFUDGE)=KPAK(IPARS(1),IPARS(2),J,KPHASE,1)
   35   CONTINUE
C Need to do again if required parameters are separated in store
        IF (II .LT.0) GO TO 37
        GO TO 3
      ELSE
        CALL ERRMES(1,0,'unforseen word '//ICARd(IPTT:IPT-1)
     &//' after FUDG')
      ENDIF
C
C 'XYZB' - SET SPECIES 1-9 (ALL GENERA, FAMILY 2)
  25  L1=1
      GO TO 19
C
C 'BIJ' - SET SPECIES 4-9 (ALL GENERA, FAMILY 2)
  22  L1=4
  19  L2=9
      N1=2
      N2=0
      GO TO 20
C
C 'CELL' - SET SPECIES 2-7, FAMILY 1, GENUS 1:
  24  L1=2
      L2=7
      N1=1
      N2=1
      GO TO 20
C
C 'XYZ' - SET SPECIES 1-3 (ALL GENERA, FAMILY 2) - ALSO XYZT WITH ADDED 12
C AND XYZS WITH ADDED 11
  21  L1=1
      L2=3
      N1=2
      N2=0
  20  CALL FUDGET(IPT,ITYP,F1,F2)
      DO 4 I=L1,L2
      IER=IERR
%      CALL ERRCHK(2,NFUDGE,%FUDG%,1,'fudge factors')
      IF (IER .NE. IERR) GO TO 100
      IFDTYP(NFUDGE)=ITYP
      FUDGE1(NFUDGE)=F1
      FUDGE2(NFUDGE)=F2
      IFDGPT(NFUDGE)=KPAK(N1,N2,I,KPHASE,1)
   4  CONTINUE
      IF (IFAM .EQ. -3) THEN
        IER=IERR
%        CALL ERRCHK(2,NFUDGE,%FUDG%,1,'fudge factors')
        IF (IER .NE. IERR) GO TO 100
        IFDTYP(NFUDGE)=ITYP
        FUDGE1(NFUDGE)=F1
        FUDGE2(NFUDGE)=F2
        IFDGPT(NFUDGE)=KPAK(2,0,12,KPHASE,1)
      ELSE IF (IFAM .EQ. -6) THEN
        IER=IERR
%        CALL ERRCHK(2,NFUDGE,%FUDG%,1,'fudge factors')
        IF (IER .NE. IERR) GO TO 100
        IFDTYP(NFUDGE)=ITYP
        FUDGE1(NFUDGE)=F1
        FUDGE2(NFUDGE)=F2
        IFDGPT(NFUDGE)=KPAK(2,0,11,KPHASE,1)
      ENDIF
      GO TO 3
C
 100  RETURN
      END
C
C
C
C
C LEVEL 8      SUBROUTINE GAMEX(R,G,FC,QQ,QL,RMS,IERR)
      SUBROUTINE GAMEX(R,G,FC,QQ,QL,RMS,IERR)
C
C *** GAMEX updated by PJB c4.18 March 2010  ***
C4.18 ITER Incresed to 500
C129 better treatment of R's near turning points
C Catch R's outside limits corrected to deal with negative Pup
C
CX
CC 2B
CH Calculates an extinction corrected gamma from a flipping ratio.
CA On entry R is a 1x2 real array holding the flipping ratio and its
CA            standard deviation
CA          G holds the initial gamma value (no extinction)
CA          FC is the value of the nuclear structure factor
CA          QQ is sin(alpha) the angle between Q and k
CA On exit  G(1)  holds the extinction corrected gamma
CA          QQ is the sin of the angle between the magnetisation direction
CA             and the scattering vector
CA          QL is the sine of the angle between the polarisation direction
CA             and the scattering vector
CA          RMS is the ratio of multiple (or lamba/2) to nuclear scattering.
CA          IERR=0 if no error
CA               1 if no zero found in range
CA               2 if no convergence after 50 iterations
C
      DIMENSION R(2),G(2),F(2),PP(4)
/EXTN/
/IOUNIT/
/POLDA/
      DATA ITER,PREC/500,10./
C
      IERR=0
C IF IN FACT NO EXTINCTION, EXIT:
      IF (IEXTYP .EQ. 0) GO TO 100
C
      IF (ABS(G(1)).LT. 0.001) THEN
C PROCEDURE FOR SMALL GAMMA
        CALL EXTINC(3,FC)
C113 Correction to allow negative Pup (now assumes polarisations always
C have the correct signs)
        FAC=2.*QQ*QL*((POLUP)-(POLDW))
        EFAC=1+FC*DEXDFQ
        RMSFAC=(1.+RMS)
        FACE=FAC*EFAC*RMSFAC
        G(1)=(R(1)-1.)/FACE
        G(2)=R(2)/FACE
        GO TO 100
      ENDIF
C
C SET UP AND DOWN BEAM INTENSITIES
      PP(1)=0.5*(1.+POLUP)
      PP(2)=0.5*(1.-POLUP)
      PP(3)=0.5*(1.+POLDW)
      PP(4)=0.5*(1.-POLDW)
C  SET LIMITS
C113 We can't be sure which will be max and which min
C129 Make a better estimate of max and min values
      GMAX= SQRT(1+RMS)
      R1=(1.+RMS +POLUP*GMAX*QL)/(1.+(POLDW*GMAX*QL)+RMS)
      R2=(1.-(POLUP*GMAX*QL)+RMS)/(1.-(POLDW*GMAX*QL)+RMS)
C129 Allow for negative Pup -> R1<1
      IF (R(1).GT.1. .AND. R(1).GT. AMAX1(R1,R2)) THEN
        G(1) = GMAX*QQ
C129 set error large when near a turning point
        G(2)=G(1)/5.
        GO TO 100
      ELSE IF (R(1).LT. 1. .AND. R(1).LT.AMIN1(R1,R2)) THEN
        G(1) = -(GMAX*QQ)
        G(2)=G(1)/5.
        GO TO 100
      ENDIF
      GLIM=SIGN(1.,G(1))
      A=AMIN1(GLIM,G(1))
      B=AMAX1(GLIM,G(1))
      ERR=G(2)/PREC
      K=0
    5 CALL NB01A(K,A,B,ERR,X,Y,ITER)
      GO TO (1,2,3,4) ,K
C
    3 WRITE (LPT,3000) A,B
3000  FORMAT (' No zero found in the range from',F8.4,' to',F8.4)
      IERR=1
      GO TO 100
C
   4  CALL ERRIN2(ITER,1,
     & 'Gamma value not converged after','iterations')
      IERR=2
      GO TO 100
C
C  CALCULATE R FOM GAMMA
    1 FF=1.+(QQ*X)**2
      F2=2.*QQ*QL*X
      F(1)=FF+F2
      F(2)=FF-F2
      IF (F(2).LT.0) F(2)=0.
      ANUM=0.
      DEN=0.
      DO 20 I=1,2
      FMOD=SQRT(F(I))*FC
      CALL EXTINC(2,FMOD)
      YY=EXTCOR**2
      ANUM=ANUM+YY*F(I)*PP(I)
      DEN=DEN+YY*F(I)*PP(2+I)
   20 CONTINUE
      Y=R(1)-(ANUM+RMS)/(DEN+RMS)
      GO TO 5
C
C  HERE AFTER CONVERGENCE
    2 G(1)=X
C
  100 RETURN
      END
C
C
C
C
C LEVEL 3      SUBROUTINE GAUSPT(NN,GPT,GWT)
      SUBROUTINE GAUSPT(NN,GPT,GWT)
C
C *** GAUSPT by JCM 26 Sep 85 ***
C
CX
CC 2A
CH Sets up Gauss points and weights for use in 3D integration.
CA On entry NN=number of Gauss points & weights required.
CA On exit the array GPT contains the necessary Gauss points
CA and the array GWT contains the corresponding weights.
C
CD The array GTABLE contains n-1 numbers for each n allowed.  If n is even,
CD these are X1, W1, X2, W2, . . Xm (where 2m=n), and if n is odd they are
CD X1, W1, X2, W2, . . Xm, Wm (where 2m=n-1).
CD
CD This subroutine generates the two full arrays GPT(1:n) from the Xi and
CD GWT(1:n) from the Wi.  For all except the 'centre' points the algorithm
CD is simple:
CD
CD i<m     Xi, Wi as stored;
CD i>m+1:  Xi=1-Xj and Wi=Wj, where i+j=n+1
CD
CD For the 'centre' points:
CD For n odd:  i=m    Xi, Wi as stored;
CD             i=m+1  Xi=0.5, Wi=1-sum of previous weights*2
CD     n even: i=m    Xi as stored, Wi=0.5-sum of previous weights.
CD
CN The allowed values of n are 1-11 inclusive, 14, 17, 20, 24, 32, 40
C
      LOGICAL EVEN
      DIMENSION GPT(NN),GWT(NN)
      DIMENSION GTABLE(196),IST(17),NGPT(6)
C
C N=2:
      DATA GTABLE(1)/.2886751346/
C N=3:
      DATA GTABLE(2),GTABLE(3)/.1127016654,  .2777777778/
C N=4:
      DATA GTABLE(4),GTABLE(5)/.0694318441,  .1739274225/
      DATA GTABLE(6)/.3300094782/
C N=5:
      DATA GTABLE(7),GTABLE(8)/.0469100770,  .1184634425/
      DATA GTABLE(9),GTABLE(10)/.2307653450,  .2393143353/
C N=6:
      DATA GTABLE(11),GTABLE(12)/.0337652429,  .0856622462/
      DATA GTABLE(13),GTABLE(14)/.1669395307,  .1803807865/
      DATA GTABLE(15)/.3806904069/
C N=7:
      DATA GTABLE(16),GTABLE(17)/.0254460439,  .0647424831/
      DATA GTABLE(18),GTABLE(19)/.1292344072,  .1398526957/
      DATA GTABLE(20),GTABLE(21)/.2970774243,  .1909150252/
C N=8:
      DATA GTABLE(22),GTABLE(23)/.0198550718,  .0506142681/
      DATA GTABLE(24),GTABLE(25)/.1016667613,  .1111905172/
      DATA GTABLE(26),GTABLE(27)/.2372337950,  .1568533229/
      DATA GTABLE(28)/.4082826788/
C N=9:
      DATA GTABLE(29),GTABLE(30)/.0159198803,  .0406371941/
      DATA GTABLE(31),GTABLE(32)/.0819844463,  .0903240804/
      DATA GTABLE(33),GTABLE(34)/.1933142837,  .1303053482/
      DATA GTABLE(35),GTABLE(36)/.3378732883,  .1561735385/
C N=10:
      DATA GTABLE(37),GTABLE(38)/.0130467358,  .0333356721/
      DATA GTABLE(39),GTABLE(40)/.0674683166,  .0747256746/
      DATA GTABLE(41),GTABLE(42)/.1602952159,  .1095431812/
      DATA GTABLE(43),GTABLE(44)/.2833023030,  .1346333597/
      DATA GTABLE(45)/.4255628305/
C N=11:
C TO BE ENTERED TO (46)-(55)
C N=14:
C TO BE ENTERED TO (56)-(68)
C N=17:
C TO BE ENTERED TO (69)-(84)
C N=20:
C TO BE ENTERED TO (85)-(103)
C N=24:
C TO BE ENTERED TO (104)-(126)
C N=32:
C TO BE ENTERED TO (127)-(157)
C N=40:
C TO BE ENTERED TO (158)-(196)
C
      DATA IST/0,1,2,4,7,11,16,22,29,37,46,56,69,85,104,127,158/
      DATA NGPT/14,17,20,24,32,40/
C
      N=NN
C CHECK N IS IN ALLOWED VOCABULARY:
      L=N-10
      IF (N .LE. 11) GO TO 5
      L=NFIND(N,NGPT,6)
      IF (L .EQ. 0) CALL ERRIN2(N,0,' ',
     & ' points not allowed in Gauss table')
C
C IPT POINTS TO FIRST GTABLE ENTRY FOR THIS N:
   5  IPT=IST(L+10)
      IF (N .GT. 1) GO TO 9
      GPT(1)=0.5
      GWT(1)=1.0
      GO TO 100
C
C SET EVEN TO BE TRUE IF N IS EVEN. M=N/2 IF N EVEN, (N-1)/2 IF N ODD.
   9  CALL PARITY(N,M,EVEN)
      DO 1 I=1,N
      IF (I .GE. M) GO TO 2
C
C FIRST POINTS AND WEIGHTS ARE STORED READY TO USE:
   4  GWT(I)=GTABLE(IPT+2*I-1)
      GPT(I)=GTABLE(IPT+2*I-2)
      GO TO 1
C
C I HAS REACHED AT LEAST M:
   2  IF (I .GT. M) GO TO 3
C IF N ODD, ARE AT (N-1)/2 WHICH IS AS ABOVE:
      IF (.NOT. EVEN) GO TO 4
C
C IF N EVEN, CENTRE TWO POINTS ARE AS ABOVE, BUT WEIGHTS ARE CALCULATED FROM
C THE FACT THAT THEIR SUM IS 1:
      GPT(I)=GTABLE(IPT+2*I-2)
C CHECK ADDRESSING **
      CALL SUMVEC(GTABLE(IPT),2,N-2,2,WSUM)
      GWT(I)=0.5 - WSUM
      GO TO 1
C
C I IS PAST M:
   3  IF (I .GT. M+1) GO TO 6
      IF (EVEN) GO TO 6
C
C MIDPOINT FOR N ODD:
C CHECK ADDRESSING **
      CALL SUMVEC(GTABLE(IPT),2,N-1,2,WSUM)
      GWT(I)=1.-2.*WSUM
      GPT(I)=0.5
      GO TO 1
C
C PAST MIDDLE:
   6  J=N+1-I
      GWT(I)=GWT(J)
      GPT(I)=1.-GPT(J)
   1  CONTINUE
 100  RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE GENELM(NSUB,ISGEN)
      SUBROUTINE GENELM(NSUB,ISGEN)
C
C *** GENELM corrected by JCM 18 Sep 89 ***
C
CX
CC 1B
CH Finds the generators of a subgroup of a space group.
CA On entry NSUB is an integer array holding the orders of the elements of the
CA               subgroup, with zeros for those elements not in the subgroup.
CA          ISGEN(1) is the multiplicity of the subgroup
CA On exit  ISGEN(2) (and (3) if necessary) contain the labels of the
CA               generators.
C
      LOGICAL FIRST
%      DIMENSION NSUB(%SYMO%),ISGEN(3),ISIG(2)
/NSYM/
/SYMTAB/
C
C  JUMP OUT FOR P1 OR P-1:
      ISGEN(2)=1
      ISGEN(3)=0
      IF (IABS(ISGEN(1)).EQ. 1) GO TO 100
C PUT ZEROS INTO NSUB FOR MULTIPLE OPERATIONS OF A SINGLE OPERATOR:
      DO 1 NO=2,NOPC
      M=NSUB(NO)
      IF (M.EQ.0) GO TO 1
      N=NO
      DO 2 J=3,IABS(M)
      N=MULTAB(NO,N)
    2 NSUB(N)=0
    1 CONTINUE
C
      NGEN=1
C
C COUNT DOWN THROUGH ORDERS OF POSSIBLE SYMMETRY ELEMENTS:
      DO 4 NN=1,5
      IORD=7-NN
      IF (IORD.EQ.5) GO TO 4
C  OPERATORS OF ORDER 5 DONT OCCUR
      FIRST=.TRUE.
      DO 5 NNN=1,NOPC
      IF (IABS(NSUB(NNN)).NE.IORD) GO TO 5
C  OPERATOR OF ORDER IORD FOUND - MARK IT USED, KEEPING ITS SIGN:
      ISIG(NGEN)=ISIGN(1,NSUB(NNN))
      NSUB(NNN)=0
C
C IF NOT FIRST OF THIS ORDER, WE NEED A SECOND GENERATOR TO PRODUCE IT - JUMP:
      IF (.NOT.FIRST) GO TO 6
C THE FIRST OPERATOR OF THIS ORDER:
C JUMP IF ALREADY HAVE A GENERATOR OF HIGHER ORDER:
      IF (NGEN.EQ.2) GO TO 10
      FIRST=.FALSE.
      ISGEN(2)=NNN*ISIG(1)
      ISG=NNN
      NGEN=2
      GO TO 5
C  HERE IF NOT FIRST OF THIS ORDER:
    6 DO 8 M=1,NOP
C FIND IN M THE OPERATOR WHICH MAKES CURRENT ONE FROM FIRST GENERATOR:
      IF (MULTAB(ISG,M).EQ.NNN) GO TO 3
    8 CONTINUE
C I THINK IT IS AN ERROR IF WE GET HERE?
      GO TO 100
    5 CONTINUE
    4 CONTINUE
C
C  NO SECOND GENERATOR - RETURN
      GO TO 100
C
C  SET SECOND GENERATOR:
   10 ISGEN(3)=NNN*ISIG(2)
      GO TO 100
C
    3 ISGEN(3)=M*ISIG(1)*ISIG(2)
C
  100 RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE GENGRP(ITAB,JTAB,IJTAB,MODE,PRODCT)
      SUBROUTINE GENGRP(ITAB,JTAB,IJTAB,MODE,PRODCT)
C
C *** GENGRP new by PJB C137 April  2005
C
CC 1A
CH Generates the product of two subgroups of the space group in SYMTAB
CA On Entry ITAB is a teble in which ITAB(I) is non-zero if element I is
CA              in the first subgroup.
CA              a negative value for ITAB(I) indicates that it is the centro
CA          JTAB gives the same information for the second subgroup
CA          PRODCT is the name of a subroutine which will execute a product
CA                 operation if MODE=1
CA          If MODE=0, no product operation is executed and PRODCT should
CA                 be set to DUMMY.
CA On Exit IJTABis a teble in which IJTAB(I) is non-zero if element I is
CA              in the  product group.
CN a negative value for ITAB(I), JTAB(I) or IJTAB(I) indicates that it
CN is the centro-symmetric partner to element I which is in the group.

      DIMENSION ITAB(24),JTAB(24),IJTAB(24)
      LOGICAL NEW
/IOUNIT/
/NSYM/
/SYMTAB/
C
C Combine the elements of ITAB and JTAB
      do 1 i=1,nopc
      if (itab(i).eq.0) then
        ijtab(i)=jtab(i)
      else if (jtab(i).eq.0) then
        ijtab(i)=itab(i)
      else if (itab(i)*jtab(i) .lt.0) then
        ijtab(i)=1
        ijtab(1)=-1
      else
        ijtab(i)=itab(i)
      endif
    1 continue
C Complete the product group
    2 NEW=.FALSE.
      DO 7 K=2,NOPC
      IF (IJTAB(K) .EQ. 0) GO TO 7
      DO 8 J=2,NOPC
      IF (ITAB(J) .EQ. 0) GO TO 8
      JK=MULTAB(J,K)
      IF (IJTAB(JK) .NE. 0) GO TO 8
      NEW=.TRUE.
C To get the sign right
      IJTAB(JK)=IJTAB(J)*IJTAB(K)
      if (MODE .NE. 0) CALL PRODCT(J,K,JK)
   8  CONTINUE
   7  CONTINUE
      IF (NEW) GO TO 2
C
      RETURN
      END
C
C
C
C
C LEVEL 5      SUBROUTINE GENMAG(H,NOMORE,MUL,SMAX,NFLAG)
      SUBROUTINE GENMAG(H,NOMORE,MUL,SMAX,NFLAG)
C
C *** GENMAG updated by JCM 6 May 92 ***
C
CX
CC 17C
CH Generates the next set of magnetic h,k,l, scanning the asymmetric unit.
CA On entry NFLAG=-9999 if this is the very first entry
CA    if IPROP is non-zero this entry makes a magnetic asymmetric unit
CA    and sets things up for subsequent calls.
CA    otherwise NFLAG is left severely alone and just presented again
CA    on each subsequent entry.
CA On exit H is a real 1x3 array holding the next h,k,l (unless none)
CA         NOMORE is a LOGICAL saying whether or not no more generated
CA         MUL is the multiplicity of H
CP PROPER must have been called to fill in /SATELL/
C
      LOGICAL NOMORE
      DIMENSION H(3),HT(3)
/SATELL/
      COMMON /TEMGEN/HF(3)
C
      IF (NFLAG .EQ. -9999) THEN
C INITIAL ENTRY:
C
        IF (NKSTAR.GT.1) THEN
          CALL SUBSYM(KSTAB)
          CALL SYMUNI
        ENDIF
C  INCREASE SINTHETA LIMIT TO ALLOW FOR PROPAGATION VECTOR
        SDIF=VCTMOD(0.5,PROP,2)
        SLIM=SMAX+SDIF
        CALL SETGEN(SLIM)
C FIRST PRESENT 0,0,0 AS FUNDAMENTAL:
        CALL GMZER(HF,1,3)
        NOMORE=.FALSE.
C
C ENTRIES OTHER THAN INITIAL - EXPECT NFLAG SET:
      ELSE IF (NFLAG.EQ.0) THEN
        CALL GETGEN(HF,NOMORE)
        IF (NOMORE) GO TO 100
      ELSE
        CALL GMSUB(HF,PROP,H,3,1)
        NFLAG=0
        GO TO 3
      ENDIF
C  ADD STAR VECTOR TO FUNDAMENTAL
      CALL GMADD(HF,PROP,H,3,1)
C  TAKE CARE OF SPECIAL CASES WHEN PROP IS HALF A RLV
      IF (IABS(IPROP).EQ.2) THEN
        CALL GMADD(H,PROP,HT,3,1)
        M=MULBOX(HT)
        IF (M.NE.0) NFLAG=0
      ENDIF
      NFLAG=1
   3  CALL ASUNIT(H,HT,N,MUL)
      CALL GMEQ(HT,H,3,1)
 100  RETURN
      END
C
C
C
C
C LEVEL 4      SUBROUTINE GENMUL(H,NOMORE,M)
      SUBROUTINE GENMUL(H,NOMORE,M)
C
C *** GENMUL by JCM 18 Jun 85 ***
C
CX
CC 3B
CH Gives next useful set of h,k,l and multiplicity, scanning the asymmetric
CH unit of reciprocal space.
C
CA On exit  H is a 1x3 real vector holding next generated values of h,k,l
CA          NOMORE is TRUE if there are no more to be found
CA          M is the multiplicity of the found reflection.
CP SYMOP should have read the space group symmetry.
CP SYMUNI should have found the asymmetric unit of reciprocal space.
CP SETGEN should have set up stepping over asymmetric unit in /HKLGEN
C
CD Uses "previous" h,k,l in PT in /HKLGEN to move to a new one.
CD Rejects lattice absences (but not space group absences - do those outside
CD         using ISPABS if required),
CD         h,k,l outside asymmetric unit,
CD         h,k,l for which sin theta/lambda is greater than STHLMX,
CD         and h,k,l for which sin theta is around zero (to reject 0,0,0)
CD
CD Allows for non-primitive stepping vectors in array STEP, by use of inter-
CD mediate primitive steps as calculated by PRMTIV on leaving SETGEN.
CD
CD Leaves value of sin theta/lambda in STHL in /BRAGG
CN Exactly like GETGEN, but sends out M and STHL also
C
      LOGICAL NOMORE,LATABS
      DIMENSION H(3),C(2),VEC(3)
/BRAGG/
/HKLGEN/
C
      NOMORE = .FALSE.
    4 DO 1 L = 1,3
      CALL GMADD(PT(1,L),STEP(1,L),H,1,3)
      IF (SCALPR(H,VECEND(1,L))-1.) 2,2,1
    1 CONTINUE
C
C NEXT 3D LATTICE IF NON-PRIMITIVE:
C SIMULATE 'DO MCOUNT(1)=1,LFAC(1)'
      MCOUNT(1)=MCOUNT(1)+1
      IF (MCOUNT(1) .LE. LFAC(1)) GO TO 8
      MCOUNT(1)=1
C SIMULATE 'DO MCOUNT(2)=1,LFAC(2)
      MCOUNT(2)=MCOUNT(2)+1
      IF (MCOUNT(2) .GT. LFAC(2)) GO TO 101
C
C MAKE COEFFICIENTS OF STEP VECTORS FOR NEXT PRIMITIVE STEP:
   8  DO 7 I=1,2
       C(I)=FLOAT(MOD((MCOUNT(1)-1)*NPRIM(I,1)*LFAC(2)+(MCOUNT(2)-1)*
     & NPRIM(I,2)*LFAC(1),NP))/FLOAT(NP)
   7  CONTINUE
C
      DO 10 I=1,3
  10  VEC(I)=C(1)*STEP(I,1)+C(2)*STEP(I,2)+FLOAT(MCOUNT(2)-1)
     & *STEP(I,3)/FLOAT(LFAC(2))
      DO 9 L=1,3
      CALL GMADD(PRPT(1,L),VEC,PT(1,L),1,3)
   9  CONTINUE
      GO TO 4
C
C  NEW VALUES ARE IN H; RESET PT
    2 DO 3 J = 1,L
   3  CALL GMEQ(H,PT(1,J),1,3)
      M=MULBOX(H)
      IF (M .EQ. 0) GO TO 4
      STHL = VCTMOD(0.5,H,2)
      IF (STHL-STHLMX) 6,6,4
    6 IF (STHL-10.E-5) 4,5,5
    5 IF (LATABS(H)) GO TO 4
      GO TO 100
C
C  IF HERE HAVE NO MORE VALUES OF H,K,L TO OFFER
 101  NOMORE = .TRUE.
 100  RETURN
      END
C
C
C
C
C LEVEL 2      CHARACTER *4 FUNCTION GENNAM(NAME)
      CHARACTER *4 FUNCTION GENNAM(NAME)
C
C *** GENNAM by JCM 26 Mar 91 ***
C
CX
CC 13C
CH Finds all the starting letters of an atom name.
CA On entry NAME is an A4 CHARACTER variable
CA On exit  GENNAM is an A4 CHARACTER variable being all the leftmost letters
CA          of NAME
C
      CHARACTER *4 NAME
C
      GENNAM=' '
      DO 1 I=1,4
      IF (LETTER(NAME(I:I)) .LE. 0) GO TO 100
      GENNAM=NAME(1:I)
   1  CONTINUE
 100  RETURN
      END
C
C
C
C
C LEVEL 6      SUBROUTINE GEOMCO(N)
      SUBROUTINE GEOMCO(N)
C
C *** GEOMCO updated by JCM 24 Jan 90 ***
C
CX
CC 6C
CH Multiple entry routine for geometric slack constraints.
C
CA N on entry specifies action required:
CA    N=1 initialise: copy out constraint information for access later
CA        and read print instructions from I PRSK (this is used by Pawley
CA        slacks as well).
CA    N=2 entered from APSHSF: recalculate actual coordinates at bond ends
CA        after shift application to position coordinates
CA    N=3 entered from NWINSF: put out new L ATOM card
C
CP Slack constraints must have been set up in /SLKGEO/ via GEOMIN
CP Parameters and variables must be set up via PARSSF
C
      LOGICAL ONCARD
      CHARACTER *4 NAME
/ATNAM/
/CELFIX/
/CELPAR/
/IOUNIT/
/NEWOLD/
/POINTS/
/REFINE/
/SLAKDA/
/SLKGEC/
/SLKGEO/
C
C NOT IF NO SLACK CONSTRAINTS:
      IF (NSLAK(1) .EQ. 0) GO TO 100
C
      GO TO (1,2,3) , N
C
C SETTING UP ENTRY:
   1  IPRNT(8)=0
      IF (ONCARD('I','PRSK',A)) IPRNT(8)=JFIX(A)
      CALL MESS(LPT,1,'Printing of bond "obs" and calc values wanted')
      CALL DEPRIN(IPRNT(8))
C
C SET UP MATRIX TO CONVERT DERIVATIVES WRT A,B,C ETC TO DERIVATIVES
C WRT A*, B*, C* ETC:
      CALL CELMAT(TOSTAR)
C
C SET UP THE MATRIX OF 1S AND COSINES FOR THESE DERIVATIVES:
      CALL GMUNI(COSIN,3)
      COSIN(1,2)=CELL(3,2,1)
      COSIN(2,1)=CELL(3,2,1)
      COSIN(1,3)=CELL(2,2,1)
      COSIN(3,1)=CELL(2,2,1)
      COSIN(2,3)=CELL(1,2,1)
      COSIN(3,2)=CELL(1,2,1)
C
      GO TO 100
C
C ENTRY FROM APSHSF AFTER ALL SHIFTS APPLIED TO POSITION COORDINATES:
   2  DO 31 I=1,NTARNM
  31  CALL XTRANS(IABASE(I),XSLAK(1,I),ISYM(I),ILAT(I),
     & CELLTR(1,I))
      GO TO 100
C
C ENTRY FROM NWINSF ON FINDING L ATOM CARD - IDENTIFY ATOM:
   3  CALL RDWORD(NAME,LEN,7,IPT,80,0,IER)
      L=NCFIND(NAME,ATTNAM,NTARNM)
C C106 CELLTR(I,N) to CELLTR(I,L) in GEOMCO from KS diff.
      WRITE (NEWIN,2000) NAME,ATNAME(IABASE(L)),ISYM(L),ILAT(L),
     & (CELLTR(I,L),I=1,3)
2000  FORMAT ('L ATOM ',1X,A4,1X,A4,2I5,3F4.0)
      GO TO 100
C
 100  RETURN
      END
C
C
C
C
C LEVEL 6      SUBROUTINE GEOMIN(N)
      SUBROUTINE GEOMIN(N)
C
C *** GEOMIN updated by JCM 8 Mar 91 ***
C
CX
CC 6A
CH Reads L cards for bond slack constraints.
CA On entry N=0 if this is an initial, very early entry to read the L SLAK
CA            card and decide whether there are any slack constraints.
CA          N=1 for all other cards
C
CD For N=0 reads and interprets first a possible L SLAK card, setting in
CD particular SLONLY if there are ONLY slack constraints, and NO observations.
CD For N=1 reads possibly several cards starting:
CD    L ATOM  define named atom not on A card for use in constraints,
CD    L BOND  define named bond between 2 given atoms;
CD            also used for type 1, bond=given length with sigma,
CD    L ANGL  define named angle between 2 given bonds, and implying the
CD            use of a third bond;
CD            also used for type 2, angle = given size in degrees, with sigma
CD    L EQUB  type 3, 2 bonds are of equal length, with sigma
CD    L LINE  type 4, 2 bonds are in a straight line (angle=180 degrees), with
CD            sigma,
CD    L TORS  define named torsion angle  between 2 non-intersecting bonds,
CD            needing to be given a bond joining the two, and implying
CD            the use of the 3 further bonds joining the 4 atoms;
CD            also used for type 5, torsion angle between 2 non-intersecting
CD            bonds = given size in degrees, with sigma
CD    L EQUA  type 6, 2 angles (each between 2 bonds) are equal, with sigma
CD    L PLAN  type 7;  an experimental type which for the moment requests that
CD            the atoms which follow (4 or more of them) are to be planar, with
CD            sigma.
C
      CHARACTER *4 NAME,ANAME,BNAME
%      DIMENSION XS(3),CS(3),NEND(2),NIN(%PLAN%)
/ATNAM/
/CARDRC/
/CELPAR/
/IOUNIT/
/POSNS/
/SLAKDA/
/SLKGEC/
/SLKGEO/
C
      GO TO (91,92) , N+1
C SET UP AS IF NO GEOMETRIC SLACK CONSTRAINTS:
  91  NSLAK(1)=0
      NUMBON=0
      NTARNM=0
      NUMANG=0
      NUMTOR=0
      SLONLY=.FALSE.
C
C SEEK L SLAK CARD:
      CALL FINDCD('L','SLAK',4,0,L)
      IF (L .LE. 0) THEN
        CALL MESS(LPT,1,'No geometric slack constraints')
        GO TO 100
      ENDIF
C
C FOR NOW READ TYPE (WHETHER OR NOT TO EXPECT CONVENTIONAL LSQ OBSERVATIONS
C AS WELL AS SLACK CONSTRAINTS), AND EXTRA MULTIPLICATIVE WEIGHTING
C FACTOR IF TYPE 2 -  EVENTUALLY MAY BE MORE ON THIS CARD
      CALL RDINTG(NSTYP,7,IPT,80,IER)
C UNITS DIGIT OF NSTYP IS 1 FOR BOND ALONE, 2 FOR LSQ OBS PLUS BONDS
C TENS DIGIT OF NSTYP IS WEIGHTING TYPE SPECIFICALLY FOR GEOMETRIC:
C   10=UNIT WEIGHTS (NOT NORMALLY SENSIBLE)
C   20=WEIGHTS TO BE USED AS READ (IE READ 1/SIGMA SQRD)
C   30=READ SIGMA, USE WEIGHT=1/SIGMA SQRD
C
      NST1=NSTYP/10
      SLONLY=NSTYP-NST1*10 .EQ. 1
      IF (SLONLY) THEN
        CALL MESS(LPT,1,'Refinement using bond slack constraints '//
     &  'only')
        CALL MESS(LPT,0,'If irrelevant L cards (REFI, MODE, WGHT, '//
     &  'TFAC, SCAL) have been given they will be ignored')
        SLAKWT(1)=1.
        GO TO 40
      ELSE
        CALL MESS(LPT,1,'Refinement using bond slack constraints '//
     &  'and conventional observations')
        GO TO 20
      ENDIF
C
  98  CALL ERRIN2(NSTYP,2,'slack constraint type','not allowed')
      GO TO 100
C
  20  CALL RDREAL(SLAKWT(1),IPT,IPT,80,IER)
      IF (SLAKWT(1) .EQ. 0.) SLAKWT(1)=1.
      WRITE (LPT,2005) SLAKWT(1)
2005  FORMAT (' Extra weighting factor = ',F12.4)
C HOLD IT AS SQRT, WHICH IS HOW IT IS NEEDED:
      SLAKWT(1)=SQRT(SLAKWT(1))
C
  40  IF (NST1 .LE. 0 .OR. NST1 .GT. 3) GO TO 98
      GO TO (41,42,43) ,NST1
  41  CALL MESS(LPT,0,'Unit weights')
      GO TO 100
C
  42  CALL MESS(LPT,0,'Weights used directly as read')
      GO TO 100
C
  43  CALL MESS(LPT,0,'Read sigma, weight by 1/(sigma sqrd)')
      GO TO 100
C
C READ L ATOM CARDS:
  92  K=0
  81  CALL FINDCD('L','ATOM',4,K,L)
      K=L
      IF (L .LE. 0) GO TO 51
C
C READ TARGET ATOM NAME:
      CALL RDWORD(NAME,LEN,7,IPT,80,0,IER)
C READ ATOM SPECIFICATION;  FIND RELATED ATOM IN ASSY UNIT:
      CALL RDATOM(IPT,IA,XS,IS,IL,CS)
C ADD NAME AND ATOM SPEC TO LISTS:
      CALL ADDATM(NAME,IA,XS,IS,IL,CS,ITMP)
      GO TO 81
C
C READ L BOND CARDS:
  51  K=0
   2  CALL FINDCD('L','BOND',4,K,L)
      K=L
      IF (L .LE. 0) GO TO 52
C
C READ NAME OF BOND:
      CALL RDWORD(BNAME,LEN,7,IPT,80,0,IER)
C
C READ ATOM NAMES AT 2 ENDS:
      CALL RDBOND(IPT,NEND,IE)
      IF (IE .NE. 0) GO TO 2
C
C ADD BOND TO LIST:
      CALL ADDBON(BNAME,NEND(1),NEND(2),NB)
C
C READ REQUIRED "OBSERVED" BOND, AND ITS ESD:
      CALL RDREAL(BOBS(NSLAK(1)+1),IPT,IPT,80,IER)
      IF (IER .EQ. 100) GO TO 2
%      CALL ERRCHK(2,NSLAK(1),%SLAK%,0,'geometric slack constraints')
      CALL RDREAL(EOBS(NSLAK(1)),IPT,IPT,80,IER)
C COUNT ALSO TOTAL CONSTRAINTS:
      NSKTOT=NSKTOT+1
C TYPE 1 GEOMETRIC SLACK CONSTRAINTS: BOND=CONSTANT
      ITYPSK(NSLAK(1))=1
C 1 BOND INVOLVED:
      NINVB(NSLAK(1))=1
C AND WHICH ONE IT IS:
      INVBON(1,NSLAK(1))=NB
C
      WRITE (LPT,2001) BONNAM(NB),ATTNAM(IATM(NB,1)),
     & ATTNAM(IATM(NB,2))
2001  FORMAT (/' BOND slack constraint ',A4,' between atoms ',
     & 1X,A4,' and ',A4,':')
      WRITE (LPT,2002)(XSLAK(J,IATM(NB,1)),J=1,3),
     & (XSLAK(J,IATM(NB,2)),J=1,3),BOBS(NSLAK(1)),EOBS(NSLAK(1))
2002  FORMAT (' Actual  coordinates are:',3F10.5,' and ',3F10.5/
     & '           "Observed" bond =',F10.4,' with esd ',F10.5)
      GO TO 2
C
C READ L ANGL CARDS:
  52  IF (NUMBON .EQ. 0) GO TO 100
      K=0
   6  CALL FINDCD('L','ANGL',4,K,L)
      K=L
      IF (L .LE. 0) GO TO 53
C READ NAME OF ANGLE:
      CALL RDWORD(ANAME,LEN,7,IPT,80,0,IER)
C
C READ 2 BOND NAMES TO DEFINE ANGLE, AND FIND THE THIRD SIDE OF TRIANGLE:
      CALL RDANGL(IPT,N1,N2,N3,NCOM,IE)
      IF (IE .NE. 0) GO TO 6
C ADD ANGLE TO LIST:
      CALL ADDANG(ANAME,N1,N2,N3,NA,IE)
      IF (IE .NE. 0) GO TO 6
C
C RECORD CONSTRAINT - THE "OPPOSITE" SIDE COMES FIRST:
      CALL RDREAL(BOBS(NSLAK(1)+1),IPT,IPT,80,IER)
      IF (IER .EQ. 100) GO TO 6
%      CALL ERRCHK(2,NSLAK(1),%SLAK%,0,'geometric slack constraints')
      CALL RDREAL(EOBS(NSLAK(1)),IPT,IPT,80,IER)
C COUNT ALSO TOTAL CONSTRAINTS:
      NSKTOT=NSKTOT+1
C TYPE 2 GEOMETRIC SLACK CONSTRAINT - ANGLE=CONSTANT, NOT 0 OR 180
      ITYPSK(NSLAK(1))=2
C 3 BONDS INVOLVED (THOUGH ONLY 2 READ):
      NINVB(NSLAK(1))=3
      INVBON(1,NSLAK(1))=N1
      INVBON(2,NSLAK(1))=N2
      INVBON(3,NSLAK(1))=N3
      WRITE (LPT,2021) ANAME,BONNAM(N2),BONNAM(N3)
2021  FORMAT (/' ANGL slack constraint ',A4,' between bonds ',
     & 1X,A4,' and ',A4,':')
      WRITE (LPT,2022) ATTNAM(NCOM),BOBS(NSLAK(1)),EOBS(NSLAK(1))
2022  FORMAT ('            At atom ',A4/
     & '           "Observed" angle =',F10.1,' with esd ',F10.2)
      GO TO 6
C
C READ L EQUB CARDS:
  53  K=0
  63  CALL FINDCD('L','EQUB',4,K,L)
      K=L
      IF (L .LE. 0) GO TO 54
C READ FIRST BOND NAME:
      CALL RDWORD(BNAME,LEN,7,IPT,80,0,IER)
      N1=NCFIND(BNAME,BONNAM,NUMBON)
      IF (N1 .LE. 0) GO TO 11
C READ SECOND BOND NAME:
      CALL RDWORD(BNAME,LEN,IPT,IPT,80,0,IER)
      N2=NCFIND(BNAME,BONNAM,NUMBON)
      IF (N2 .GT. 0) GO TO 12
C
  11  CALL ERRCH2(BNAME,2,' ','is not a bond name')
      GO TO 63
C
C RECORD CONSTRAINT
%  12  CALL ERRCHK(2,NSLAK(1),%SLAK%,0,'geometric slack constraints')
C THE OBS IS ZERO HERE:
      BOBS(NSLAK(1))=0.
      CALL RDREAL(EOBS(NSLAK(1)),IPT,IPT,80,IER)
C COUNT ALSO TOTAL CONSTRAINTS:
      NSKTOT=NSKTOT+1
C TYPE 3 GEOMETRIC SLACK CONSTRAINT - EQUAL BONDS:
      ITYPSK(NSLAK(1))=3
C 2 BONDS INVOLVED:
      NINVB(NSLAK(1))=2
      INVBON(1,NSLAK(1))=N1
      INVBON(2,NSLAK(1))=N2
      WRITE (LPT,2031) BONNAM(N1),BONNAM(N2),EOBS(NSLAK(1))
2031  FORMAT (/' EQUB slack constraint - bond ',A4,' approx = bond ',
     &  A4,' with esd ',F10.5)
      GO TO 63
C
C READ L LINE CARDS:
  54  K=0
  64  CALL FINDCD('L','LINE',4,K,L)
      K=L
      IF (L .LE. 0) GO TO 55
      IPT=7
      CALL RDANGL(IPT,N1,N2,N3,NCOM,IE)
      IF (IE .NE. 0) GO TO 64
C
C RECORD CONSTRAINT:
%      CALL ERRCHK(2,NSLAK(1),%SLAK%,0,'geometric slack constraints')
      BOBS(NSLAK(1))=0.
      CALL RDREAL(EOBS(NSLAK(1)),IPT,IPT,80,IER)
C COUNT ALSO TOTAL CONSTRAINTS:
      NSKTOT=NSKTOT+1
C TYPE 4 GEOMETRIC SLACK CONSTRAINT - BOND=SUM OF 2 OTHERS:
      ITYPSK(NSLAK(1))=4
C 3 BONDS INVOLVED (THOUGH ONLY 2 READ):
      NINVB(NSLAK(1))=3
      INVBON(1,NSLAK(1))=N1
      INVBON(2,NSLAK(1))=N2
      INVBON(3,NSLAK(1))=N3
      WRITE (LPT,2041) BONNAM(N2),BONNAM(N3),EOBS(NSLAK(1))
2041  FORMAT (/' LINE slack constraint - bonds ',A4,' and ',A4,
     &  'in an approximate straight line with esd ',F10.5)
      GO TO 64
C
C READ L TORS CARDS:
  55  K=0
  65  CALL FINDCD('L','TORS',4,K,L)
      K=L
      IF (L .LE. 0) GO TO 56
C READ NAME OF TORSION ANGLE:
      CALL RDWORD(ANAME,LEN,7,IPT,80,0,IER)
C
C READ 3 BOND NAMES TO DEFINE ANGLE:
C READ FIRST BOND NAME:
      CALL RDWORD(BNAME,LEN,IPT,IPT,80,0,IER)
      N1=NCFIND(BNAME,BONNAM,NUMBON)
      IF (N1 .LE. 0) GO TO 22
C READ SECOND BOND NAME:
      CALL RDWORD(BNAME,LEN,IPT,IPT,80,0,IER)
      N2=NCFIND(BNAME,BONNAM,NUMBON)
      IF (N2 .LE. 0) GO TO 22
C READ THIRD BOND NAME:
      CALL RDWORD(BNAME,LEN,IPT,IPT,80,0,IER)
      N3=NCFIND(BNAME,BONNAM,NUMBON)
      IF (N3 .GT. 0) GO TO 23
C
  22  CALL ERRCH2(BNAME,2,' ','is not a bond name')
      GO TO 65
C
C ADD ANGLE TO LIST:
  23  CALL ADDTOR(ANAME,N1,N2,N3,N4,N5,N6,NT,IE)
      IF (IE .GT. 0) GO TO 65
C
C RECORD CONSTRAINT :
      CALL RDREAL(BOBS(NSLAK(1)+1),IPT,IPT,80,IER)
      IF (IER .EQ. 100) GO TO 65
%      CALL ERRCHK(2,NSLAK(1),%SLAK%,0,'geometric slack constraints')
      CALL RDREAL(EOBS(NSLAK(1)),IPT,IPT,80,IER)
C COUNT ALSO TOTAL CONSTRAINTS:
      NSKTOT=NSKTOT+1
C TYPE 5 GEOMETRIC SLACK CONSTRAINT - TORSION ANGLE=CONSTANT, NOT 0 OR 180
      ITYPSK(NSLAK(1))=5
C 6 BONDS INVOLVED (THOUGH ONLY 3 READ):
      NINVB(NSLAK(1))=6
      INVBON(1,NSLAK(1))=N1
      INVBON(2,NSLAK(1))=N2
      INVBON(3,NSLAK(1))=N3
      INVBON(4,NSLAK(1))=N4
      INVBON(5,NSLAK(1))=N5
      INVBON(6,NSLAK(1))=N6
      WRITE (LPT,2051) ANAME,BONNAM(N1),BONNAM(N3)
2051  FORMAT (/' TORS slack constraint ',A4,' between bonds ',
     & 1X,A4,' and ',A4,':')
      WRITE (LPT,2052) BONNAM(N2),BOBS(NSLAK(1)),EOBS(NSLAK(1))
2052  FORMAT ('   with common axis ',A4/
     & '           "Observed" angle =',F10.1,' with esd ',F10.2)
      GO TO 65
C
C READ L EQUA CARDS:
  56  K=0
  66  CALL FINDCD('L','EQUA',4,K,L)
      K=L
      IF (L .LE. 0) GO TO 57
C
C READ FIRST ANGLE NAME:
      CALL RDWORD(ANAME,LEN,7,IPT,80,0,IER)
      K1=NCFIND(ANAME,ANGNAM,NUMANG)
      IF (K1 .LE. 0) GO TO 24
C READ SECOND ANGLE NAME:
      CALL RDWORD(ANAME,LEN,IPT,IPT,80,0,IER)
      K2=NCFIND(ANAME,ANGNAM,NUMANG)
      IF (K2 .GT. 0) GO TO 25
C
  24  CALL ERRCH2(ANAME,2,' ','is not a bond angle name')
      GO TO 66
C
C RECORD CONSTRAINT
%  25  CALL ERRCHK(2,NSLAK(1),%SLAK%,0,'geometric slack constraints')
C THE OBS IS ZERO HERE:
      BOBS(NSLAK(1))=0.
      CALL RDREAL(EOBS(NSLAK(1)),IPT,IPT,80,IER)
C COUNT ALSO TOTAL CONSTRAINTS:
      NSKTOT=NSKTOT+1
C TYPE 3 GEOMETRIC SLACK CONSTRAINT - EQUAL BONDS:
      ITYPSK(NSLAK(1))=6
C 6 BONDS INVOLVED (THOUGH THEY MAY NOT ALL BE DISTINCT):
      NINVB(NSLAK(1))=6
      INVBON(1,NSLAK(1))=INANG(K1,1)
      INVBON(2,NSLAK(1))=INANG(K1,2)
      INVBON(3,NSLAK(1))=INANG(K1,3)
      INVBON(4,NSLAK(1))=INANG(K2,1)
      INVBON(5,NSLAK(1))=INANG(K2,2)
      INVBON(6,NSLAK(1))=INANG(K2,3)
      WRITE (LPT,2061) ANGNAM(K1),ANGNAM(K2),EOBS(NSLAK(1))
2061  FORMAT (/' EQUA slack constraint - angle ',A4,' approx = angle ',
     &  A4,' with esd ',F10.5)
      GO TO 66
C
C READ L PLAN CARDS:
  57  K=0
  67  CALL FINDCD('L','PLAN',4,K,L)
      K=L
      IF (L .LE. 0) GO TO 100
C
C DISCOVER HOW MANY ATOMS INVOLVED:
      N=0
      IPT=7
  31  CALL RDWORD(ANAME,LEN,IPT,IPT,80,0,IER)
** USE THE ENTRY WHICH DETECTS A READ NUMBER, & SET EOBS
      IF (IER .EQ. 100) GO TO 32
%      CALL ERRCHK(2,N,%PLAN%,0,'atoms constrained to be planar')
      NIN(N)=NCFIND(ANAME,ATTNAM,NTARNM)
      IF (NIN(N) .EQ. 0) THEN
        CALL ERRATM(ANAME,2,'L PLAN card')
        GO TO 67
      ENDIF
      GO TO 31
C
  32  CALL ADDPLN(NIN,N)
**      ITYPSK( ETC TO BE SET EITHER HERE OR IN ADDPLN
      GO TO 67
C
 100  RETURN
      END
C
C
C
C
C LEVEL 4      SUBROUTINE GEOMLS(ALSQ,MATSZ)
      SUBROUTINE GEOMLS(ALSQ,MATSZ)
C
C *** GEOMLS updated by JCM 2 Oct 90 ***
C
CX
CC 6B
CH Calculates bond lengths and derivatives for geometrical slack
CH constraints.
C
CA ALSQ and MATSZ are handed all through LSQ programs in this fashion
CA      - they are needed here for the call of MATTOT
C
CP On entry, COMMON /SLKGEO/ should contain:
CP      XSLAK holding actual x,y,z coordinates for all atoms involved in
CP            bonds
CP      ISYM holding the number of the symmetry operator which takes
CP      original coords into actual, -ve if by -x,-y,-z also
CP      ILAT holding the number of the lattice translation
CP      CELLTR the cell translations
CP
CP The symmetry must have been set up in SYMOP, and the original positions
CP      read from the A cards by ATOPOS.  The cell parameters must have
CP      been read by RECIP.
C
CD Called from MAIN programs to add to the LSQ matrix once per cycle.
CD First, for every involved bond, calculates the bond length and its
CD 12 derivatives, remembering that the actual position coordinates involved
CD may be related to those which are being refined.
CD
CD Then scans all geometrical constraints, forming calculated function
CD (which for types 1, 2, bonds, angles, are already there).
CD Proceeds exactly as though these are conventional observations and
CD calculated functions;  makes basic variable derivatives, gets weights,
CD and adds totals in to LSQ matrix.
CO Prints obs and calc list if requested on I card.
C
C
      CHARACTER *5 F1
      CHARACTER *20 F2,F4,F5,F7
      CHARACTER *22 F3
      CHARACTER *10 F6
      CHARACTER *24 F8
      CHARACTER *100 FORMA
      LOGICAL PRNCYC,RADS,HEAD,TESTOV,PRIN
      DIMENSION ALSQ(MATSZ)
      DIMENSION DETH2(3),DETH3(3)
/CELPAR/
/DERVAR/
/IOUNIT/
/OBSCAL/
/POSNS/
/SLAKDA/
/SLKGEC/
/SLKGEO/
      DATA F1,F2,F3,F4,F5,F6,F7,F8/
     & '  No.',
     & '   Obs       Calc   ',
     & '    Diff      Esd     ',
     & '    Atom1     Atom2',
     & '    Bond1     Bond2',
     & ' Bond sum ',
     & '   Angle1     Angle2',
     & ' Ang1 bonds   Ang2 bonds'/
C
C OUT IF NO SLACK CONSTRAINTS:
      IF (NSLAK(1) .EQ. 0) GO TO 100
C
C HEADING FOR OBS/CALC BOND PRINTING IF REQUESTED:
      PRIN=PRNCYC(8)
      IF (PRIN) CALL MESS(LPT,1,'  Slack Constraints:')
C
C TYPE 1, GEOMETRICAL SLACK CONSTRAINTS - TYPE 3 IS PAWLEY-TYPE:
      ISLKTP=1
C COUNT ALL INVOLVED BONDS:
      DO 5 IB=1,NUMBON
   5  CALL BONDER(IB)
C
C COUNT ALL GEOMETRICAL SLACK CONSTRAINTS:
      DO 1 ISK=1,NSLAK(1)
C
C CLEAR WHOLE DERIVATIVE VECTOR - ONLY A FEW ITEMS WILL BE FILLED BY
C ANY PARTICULAR BOND:
      IF (LVARV .GT. 0) CALL GMZER(DERIVV,1,LVARV)
C
C SET UP POINTERS TO INVOLVED BONDS:
      DO 2 I=1,NINVB(ISK)
   2  NVB(I)=INVBON(I,ISK)
C
C WHICH TYPE IS THIS CONSTRAINT?
      GO TO (31,32,33,34,35,36,37) , ITYPSK(ISK)
C
** ERROR - TYPE NOT IMPLEMENTED
C
C BOND LENGTH:
  31  YCALC=BCALC(NVB(1))
      DERBON(1)=1.
      GO TO 50
C
C TYPE 2 - ANGLE BETWEEN 2 BONDS:
  32  B1=BCALC(NVB(1))
      B2=BCALC(NVB(2))
      B3=BCALC(NVB(3))
C YCALC = THETA RADIANS:
      CALL BONCOS(B1,B2,B3,YCALC,COSTH,SINTH,DERBON)
      GO TO 50
C
C TYPE 3 - EQUAL BONDS:
  33  YCALC=BCALC(NVB(1))-BCALC(NVB(2))
      DERBON(1)=1.
      DERBON(2)=-1.
      GO TO 50
C
C TYPE 4 - LINE:
  34  YCALC=BCALC(NVB(1))-BCALC(NVB(2))-BCALC(NVB(3))
      DERBON(1)=1.
      DERBON(2)=-1.
      DERBON(3)=-1.
      GO TO 50
C
C TYPE 5 - TORS:
  35  B1=BCALC(NVB(1))
      B2=BCALC(NVB(2))
      B3=BCALC(NVB(3))
      B4=BCALC(NVB(4))
      B5=BCALC(NVB(5))
      B6=BCALC(NVB(6))
C DEFINE ANGLE THETA2 BETWEEN B1 & B2:
      CALL BONCOS(B5,B1,B2,TEMP,COSTH2,SINTH2,DETH2)
C AND ANGLE THETA3 BETWEEN B2 AND B3:
      CALL BONCOS(B6,B2,B3,TEMP,COSTH3,SINTH3,DETH3)
      COTTH2=COSTH2/SINTH2
      COTTH3=COSTH3/SINTH3
C
C THE EXPRESSION FOR COS PHI, THE TORSION ANGLE, IS NOW
C C=B/D + COT THETA2 * COT THETA3, WHERE THE NUMERATOR, B, AND DENOMINATOR,
C                                  D, ARE GIVEN BY:
      B=B5*B5-B4*B4+B6*B6-B2*B2
      D=2.*B1*B3*SINTH2*SINTH3
      C=B/D+COTTH2*COTTH3
      CALL SINCOS(C,S,'GEOMLS')
      YCALC=ARCCOS(C)
C
C DERIVATIVES OF C WRT ALL 6 BONDS:
      CSEQ2=1./(SINTH2*SINTH2)
      CSEQ3=1./(SINTH3*SINTH3)
      X2=B*COTTH2 + COTTH3*CSEQ2
      X3=B*COTTH3 + COTTH2*CSEQ3
C
      DERBON(1)=-(B/B1)-(DETH2(2)*X2)
      DERBON(2)=-(2.*B1/D)-(DETH2(3)*X2)-(DETH3(2)*X3)
      DERBON(3)=-(B/B3)-(DETH3(3)*X3)
      DERBON(4)=-(2.*B4/D)
      DERBON(5)=2.*B5/D-DETH2(1)*X2
      DERBON(6)=2.*B6/D-DETH3(1)*X3
C CONVERT TO BEING DERIVATIVES OF PHI:
      DO 51 I=1,6
  51  DERBON(I)=-(DERBON(I)/S)
      GO TO 50
C
C TYPE 6 - EQUAL ANGLES:
  36  B1=BCALC(NVB(1))
      B2=BCALC(NVB(2))
      B3=BCALC(NVB(3))
      B4=BCALC(NVB(4))
      B5=BCALC(NVB(5))
      B6=BCALC(NVB(6))
      CALL BONCOS(B1,B2,B3,TH1,COSTH1,SINTH1,DERBON)
      CALL BONCOS(B4,B5,B6,TH2,COSTH2,SINTH2,DETH2)
      YCALC=TH1-TH2
      DO 52 I=1,3
  52  DERBON(I+3)=-DETH2(I)
      GO TO 50
C
C TYPE 7 - PLANE:
  37  GO TO 50
C
C JOIN HERE WITH YCALC, AND DERBON= D(YCALC)/EACH INVOLVED BOND -
C MAKE DERIVATIVES OF YCALC WRT ANY RELEVANT VARIABLE:
  50  DO 41 I=1,6
C MAKE 6 DERIVATIVES OF YCALC WRT 6 RECIPROCAL CELL QUADRATIC PARS:
      L=KCPARS(I)
      IF (L .GT. 0) THEN
        S=0.
        DO 49 J=1,NINVB(ISK)
  49    S=S+DERBON(J)*DERCEL(I,NVB(J))
        DERIVV(L)=S
      ENDIF
  41  CONTINUE
C
C DERIVATIVES OF YCALC WRT THE POSITION COORDS OF THE 3 ATOMS:
C COUNT INVOLVED BONDS:
      DO 42 IB=1,NINVB(ISK)
C COUNT X,Y,Z
      DO 42 I=1,3
C COUNT BOTH ENDS OF A BOND:
      DO 42 J=1,2
      L=KX(I,IABASE(IATM(NVB(IB),J)))
      IF (L.GT.0) DERIVV(L) = DERIVV(L)+
     & DERPOS(I,NVB(IB),J)*DERBON(IB)
  42  CONTINUE
C
      CALL RELATE
      OBS=BOBS(ISK)
C FOR ANGLES, USER TALKS IN DEGREES, PROGRAM WORKS IN RADIANS:
      RADS = (ITYPSK(ISK).EQ.2 .OR. ITYPSK(ISK).EQ.5 .OR.
     &  ITYPSK(ISK).EQ.6)
      IF (RADS) OBS=RADIAN(OBS)
      DIFF=OBS-YCALC
C
C WEIGHT
      GO TO (21,22,23) ,NST1
  21  SQRTWT=1.
      GO TO 20
C
  22  SQRTWT=SQRT(EOBS(ISK))
      GO TO 29
C
  23  IF (TESTOV(1.,EOBS(ISK))) THEN
        SQRTWT=0.
      ELSE
        SQRTWT=1./EOBS(ISK)
      ENDIF
  29  IF (RADS) SQRTWT=DEGREE(SQRTWT)
  20  IF (.NOT. SLONLY) SQRTWT=SQRTWT*SLAKWT(1)
      WT=SQRTWT*SQRTWT
      WDIFF=SQRTWT*DIFF
      IF (PRIN) THEN
        IF (ISK .EQ. 1) THEN
          HEAD = .TRUE.
        ELSE
          HEAD =(ITYPSK(ISK) .NE. ITYPSK(ISK-1))
          F1=' '
          F3=' '
        ENDIF
        GO TO (61,62,63,64,65,66,67) , ITYPSK(ISK)
C
  61    IF (HEAD) THEN
          FORMA='('''//F1//F2//F3//F4//''')'
          WRITE(LPT,FORMA)
        ENDIF
        WRITE(LPT,2001) BONNAM(NVB(1)),OBS,YCALC,DIFF,EOBS(ISK),
     &   ATTNAM(IATM(NVB(1),1)),ATTNAM(IATM(NVB(1),2))
2001    FORMAT (1X,A4,F10.4,F10.4,F10.5,G12.4,6X,A4,6X,A4)
        GO TO 60
C
  62    IF (HEAD)  THEN
          FORMA='('''//F1//F2//F3//F5//''')'
          WRITE(LPT,FORMA)
        ENDIF
        CALL ADDANG('    ',NVB(1),NVB(2),NVB(3),IA,IE)
        WRITE(LPT,2009) ANGNAM(IA),BOBS(ISK),DEGREE(YCALC),DEGREE(DIFF),
     &   EOBS(ISK),BONNAM(NVB(2)),BONNAM(NVB(3))
2009    FORMAT (1X,A4,F10.2,F10.2,F10.3,G12.4,6X,A4,6X,A4)
        GO TO 60
C
  63    IF (HEAD) THEN
          FORMA='('''//F1//F5//F3//F5//''')'
          WRITE(LPT,FORMA)
        ENDIF
        WRITE(LPT,2011) BCALC(NVB(1)),BCALC(NVB(2)),DIFF,EOBS(ISK),
     &   BONNAM(NVB(1)),BONNAM(NVB(2))
2011    FORMAT (1X,'EQUB',F10.4,F10.4,F10.5,G12.4,6X,A4,6X,A4)
        GO TO 60
C
  64    IF (HEAD) THEN
          FORMA='('''//F1//F5//F3//F6//F5//''')'
          WRITE (LPT,FORMA)
        ENDIF
        WRITE(LPT,2002) ISK,BCALC(NVB(2)),BCALC(NVB(3)),
     &   DIFF,EOBS(ISK),BCALC(NVB(1)),BONNAM(NVB(2)),BONNAM(NVB(3))
2002    FORMAT (1X,'LINE',3F10.4,F10.5,G12.4,6X,A4,6X,A4)
        GO TO 60
C
  65    IF (HEAD) THEN
          FORMA='('''//F1//F2//F3//F5//''')'
          WRITE (LPT,FORMA)
        ENDIF
        CALL ADDTOR('    ',NVB(1),NVB(2),NVB(3),NVB(4),NVB(5),NVB(6),
     &  IT,IE)
        WRITE(LPT,2009) TORNAM(IT),BOBS(ISK),DEGREE(YCALC),DEGREE(DIFF),
     &  EOBS(ISK),BONNAM(NVB(1)),BONNAM(NVB(3))
        GO TO 60
C
  66    IF (HEAD) THEN
          FORMA='('''//F1//F7//F3//F8//''')'
          WRITE(LPT,FORMA)
        ENDIF
        WRITE(LPT,2003) DEGREE(TH1),DEGREE(TH2),DEGREE(DIFF),
     &  EOBS(ISK),BONNAM(NVB(2)),BONNAM(NVB(3)),
     &  BONNAM(NVB(5)),BONNAM(NVB(6))
2003    FORMAT (1X,'EQUA',2F10.2,F10.3,G12.4,2(2X,A4,'^ ',A4,2X))
        GO TO 60
C
  67  GO TO 60
C
      ENDIF
  60  CALL MATTOT(ALSQ,MATSZ)
C
C ADD IN BOND-TYPE SLACK CONSTRAINT STATISTICS:
      CALL RFACS(4)
   1  CONTINUE
C PRINT BOND-TYPE SLACK CONSTRAINT STATISTICS:
      CALL RFACS(5)
 100  RETURN
      END
C
C
C
C
C LEVEL 3      SUBROUTINE GETDC(H,DIREC)
      SUBROUTINE GETDC(H,DIREC)
C
C *** updated by PJB 24-Apr-1995 ***
C
CX
CC 2B
CH Calculates direction cosines of the incident and diffracted beams
CH used by absorption correction type integrals
CA On entry H is a 1x3 real vector holding h,k,l
CA On exit  DIREC is a (3,2) real array holding the direction cosines
CA                of the incident (in (,1)) and diffracted (in (,2)) beams
CP SETDC should have set up the calculation by interpreting "D" cards.
CD Calculates the direction cosines with respect to the CCSL orthogonal axes.
C
      DIMENSION H(3),DIREC(3,2),P(2),W(3),U(6)
/BRAGG/
/DGEOM/
/SCRACH/
C
C SGNROT to be applied to given angles to get conventional rotations
      SGNROT=FLOAT(3-2*IABS(NLR))
C SGNDIF to be applied to calculated angles which depend on which side
C the diffracted beam comes out
      SGNDIF=-FLOAT(ISIGN(1,NLR))
C
      GO TO (21,21,21,50,50,22,22,22,50,50,22,22),IGEOM
C
  50  CALL ERRIN2(IGEOM,0,'GETDC does not deal with type',
     & '- only types 1,2,3,6,7,8,11 and 12')
C
C TYPES 6,7,8 11 AND 12 NEED Z DIFFRACTOMETER AXIS
  22  DO 23 I=1,3
  23  U(I)=UM(I)
      GO TO 24
C
C TYPES 1,2,3 NEED Z UP AXIS
  21  CALL GMEQ(UM(1),U(1),1,3)
C
  24  CALL ORTHO(H,U(4),2)
      CALL UNIVEC(U(4),DSTAR)
C PUT THE CORRECT SIGN ON THETA
      SINTH=SGNDIF*WLGTH*DSTAR*0.5
      CALL SINCOS(SINTH,COSTH,'GETDC1')
      P(1)=SCALPR(U(1),U(4))

      CALL SINCOS(P(1),P(2),'GETDC2')
C
      IF (IGEOM.EQ.12) GO TO 30
C DEFAULT FOR 4-CIRCLE BISECTING AND EQUIINCLINATION
      CSY=0.
      SNY=SGNDIF
      GO TO (1,2,3,50,50,3,4,1,50,50,3),IGEOM
C
C NORMAL BEAM (MAXIM AND D3) GEOMETRY
   1  CSY=(SINTH*P(1))/(COSTH*P(2))
      CALL SINCOS(CSY,SNY,'GETDC3')
      SNY=SNY*SGNDIF
      GO TO 3
C
C GENERAL 5-CIRCLE
   30 COSRHO=SIN(DIFANG(5))/(2.*ABS(SINTH))
C ASSUME NU ALWAYS MEASURED + PARALLEL TO "Z"
      CALL SINCOS(COSRHO,SINRHO,'GETDC6')
      SINX=SINTH/SINRHO
      CALL SINCOS(SINX,COSX,'GETDC9')
C FOR NEGATIVE DIFFRACTION ANGLES NEED 180-X
      COSX=COSX*SGNDIF
      XANG=ATAN2(SINX,COSX)
      SGNB=SIGN(1.,XANG-SGNROT*DIFANG(2))
      COSA=SINTH*COSRHO/(COSTH*SINRHO)
      CALL SINCOS(SINA,COSA,'GETDC7')
      CALL TRIAN1(COS(DIFANG(3)),P(1),COSRHO,COSB,1)
      CALL SINCOS(COSB,SINB,'GETDC8')
      COSY=COSA*COSB-SGNB*SINA*SINB
      SINY=SINA*COSB+SGNB*COSA*SINB
      GO TO 3

C GENERAL 4-CIRCLE
    4 DIFF=SINTH-SIN(DIFANG(1)/2)
      IF (ABS(DIFF).GT..01) THEN
        WRITE (MESSAG,1000) h,DIFF
 1000 FORMAT ('Calculated and observed sintheta''s for',
     &3F6.2, 'differ by',F8.4)
        CALL ERRMES(1,-1,MESSAG)
      ENDIF
      A=((DIFANG(1)/2)-DIFANG(2))*SGNROT
      SNY=SGNDIF*SIN(A)*SIN(DIFANG(3))
      CALL SINCOS(SNY,CSY,'GETDC5')
C
C 4-CIRCLE BISECTING AND EQUI-INC JOIN HERE
   3  CALL VECPRD(U(1),U(4),W)
C  FOR HIGH CHI
      IF (IGEOM.EQ.11) CALL GMREV(W,W,3,1)
      GO TO 2
C
C NORMAL BEAM EQUATORIAL (MINIM) JOINS HERE
   2  DO 11 I=1,3
      CALL TRIAN1(U(I),P(1),U(3+I),CSA,1)
      CALL SINCOS(CSA,SNA,'GETDC4')
      GO TO (7,8,7,50,50,7,7,7,50),IGEOM
C
    7 SNA=SIGN(SNA,W(I))
      CSA=CSA*CSY-SNA*SNY
      GO TO 9
C
C MINIM (NORMAL BEAM EQUATORIAL)
   8  CSA=SGNDIF*CSA
C MAXIM, D3, 4-CIRCLE BISECTING AND EQUI ALL JOIN
   9  DO 10 J=1,2
      CALL TRIAN1(DIREC(I,J),U(I+3),SINTH,CSA,2)
  10  CSA=-CSA
  11  CONTINUE
      RETURN
      END
C
C
C
C
C LEVEL 4      SUBROUTINE GETGEN(H,NOMORE)
      SUBROUTINE GETGEN(H,NOMORE)
C
C *** GETGEN by PJB 27 Jun 84 ***
C
CX
CC 3B
CH Gives the next useful set of h,k,l scanning the asymmetric unit of
CH reciprocal space.
C
CA On exit  H is a 1x3 real vector holding next generated values of h,k,l
CA          NOMORE is TRUE if there are no more to be found
CP SYMOP should have read the space group symmetry.
CP SYMUNI should have found the asymmetric unit of reciprocal space.
CP SETGEN should have set up stepping over asymmetric unit in /HKLGEN
C
CD Uses "previous" h,k,l in PT in /HKLGEN to move to a new one.
CD Rejects lattice absences (but not space group absences - do those outside
CD    using ISPABS if required),
CD         h,k,l outside asymmetric unit,
CD         h,k,l for which sin theta/lambda is greater than STHLMX,
CD         and h,k,l for which sin theta is around zero (to reject 0,0,0)
CD
CD Allows for non-primitive stepping vectors in array STEP, by use of inter-
CD mediate primitive steps as calculated by PRMTIV on leaving SETGEN.
CN There also exists GENMUL which sends out M also
C
      LOGICAL NOMORE,LATABS
      DIMENSION H(3),C(2),VEC(3)
/BRAGG/
/HKLGEN/
C
      NOMORE = .FALSE.
    4 DO 1 L = 1,3
      CALL GMADD(PT(1,L),STEP(1,L),H,1,3)
      IF (SCALPR(H,VECEND(1,L))-1.) 2,2,1
    1 CONTINUE
C
C NEXT 3D LATTICE IF NON-PRIMITIVE:
C SIMULATE 'DO MCOUNT(1)=1,LFAC(1)'
      MCOUNT(1)=MCOUNT(1)+1
      IF (MCOUNT(1) .LE. LFAC(1)) GO TO 8
      MCOUNT(1)=1
C SIMULATE 'DO MCOUNT(2)=1,LFAC(2)
      MCOUNT(2)=MCOUNT(2)+1
      IF (MCOUNT(2) .GT. LFAC(2)) GO TO 101
C
C MAKE COEFFICIENTS OF STEP VECTORS FOR NEXT PRIMITIVE STEP:
   8  DO 7 I=1,2
       C(I)=FLOAT(MOD((MCOUNT(1)-1)*NPRIM(I,1)*LFAC(2)+(MCOUNT(2)-1)*
     & NPRIM(I,2)*LFAC(1),NP))/FLOAT(NP)
   7  CONTINUE
C
      DO 10 I=1,3
  10  VEC(I)=C(1)*STEP(I,1)+C(2)*STEP(I,2)+FLOAT(MCOUNT(2)-1)
     & *STEP(I,3)/FLOAT(LFAC(2))
      DO 9 L=1,3
      CALL GMADD(PRPT(1,L),VEC,PT(1,L),1,3)
   9  CONTINUE
      GO TO 4
C
C  NEW VALUES ARE IN H; RESET PT
    2 DO 3 J = 1,L
   3  CALL GMEQ(H,PT(1,J),1,3)
      IF (MULBOX(H) .EQ. 0) GO TO 4
      STHL = VCTMOD(0.5,H,2)
      IF (STHL-STHLMX) 6,6,4
    6 IF (STHL-10.E-5) 4,5,5
    5 IF (LATABS(H)) GO TO 4
      GO TO 100
C
C  IF HERE HAVE NO MORE VALUES OF H,K,L TO OFFER
 101  NOMORE = .TRUE.
 100  RETURN
      END
C
C
C
C
C LEVEL 3      SUBROUTINE GETMAP
      SUBROUTINE GETMAP
C
C *** GETMAP updated C19 by JCM 22 Aug 86 ***
C
CX
CC 5B
CH Retrieves 1 Fourier map previously filed using SAVMAP.
CP Assumes unit IDUMPG is positioned so that reading from it will
CP produce the "next" map dumped there.
CP
CP The required Z value must be set in OUTLIM(1,3)
C
CD Continues reading down maps until it finds one for the given Z.
CD
CD If no map is dumped for this value of Z, will eventually read the
CD trailer record of file IDUMPG and complain.
C
/IOUNIT/
/MAPDA/
/MAPGT/
C
   1  READ(IDUMPG) ZI,NOBSIN,NUSED,NXX,NYY
      IF (NXX .EQ. NX .AND. NYY .EQ. NY) GO TO 3
      WRITE (LPT,3001) NXX,NYY,NX,NY
      WRITE (ITO,3001) NXX,NYY,NX,NY
3001  FORMAT (/' ERROR ** MAP TO BE READ OF SIZE',I3,' BY',I3,
     & ' BUT CURRENT SET SIZE IS',I3,' BY',I3)
      STOP
C
C CHECK NOT READING TRAILER:
   3  IF (ZI .GE. 99998.) CALL ERRRE2(OUTLIM(1,3),0,
     & 'no dumped map for z=',' ')
C
C READ RECTANGULAR ARRAY OF PREVIOUSLY CALCULATED MAP:
      I=0
      DO 4 IY=1,NY
      READ (IDUMPG) (DENS(I+J),J=1,NX)
   4  I=I+NX
C
C IF WRONG VALUE OF Z, BACK FOR NEXT:
      IF (ABS(OUTLIM(1,3)-ZI) .GT. 10.E-5) GO TO 1
      WRITE (LPT,2000) OUTLIM(1,3),NX,NY
2000  FORMAT(/' For Z=',F10.4,' map of size',I4,' by',I4,
     & ' read')
      RETURN
      END
C
C
C
C
C LEVEL 2      SUBROUTINE GETSCL(VMIN,VMAX,L)
      SUBROUTINE GETSCL(VMIN,VMAX,L)
C
C *** GETSCL updated by PJB Sep 87 ***
C
CX
CC 14A
CH Chooses a sensible scale for a graph.
CA On entry VMIN is minimum value to be plotted
CA          VMAX is maximum value to be plotted
CA          L=1 for x axis
CA            2 for y axis
CP X(L,2) must be set up as below:
CD The vector X(I,J) in /PLTS defines how the graph will be drawn.
CD           I=1  for X-axis, I=2 for Y-axis.
CD           J=1  length of axis in user units
CD           J=2  length of axis in cms.
CD           J=3  division of axis in user units
CD           J=4  minimum value in user units
CD           J=5  position of plotted axis in user units
CD Sets X(L,J) for J=1,3,4,5.
CO If VMAX and VMIN are not sensible, complains and stops.
C
/IOUNIT/
/PLTS/
C
      AMAX=VMAX
      AMIN=VMIN
      XX=AMAX-AMIN
      I=0
C
    1 IF (XX.GT.10.) GO TO 2
    4 IF (XX.GT.1.) GO TO 3
      I=I-1
      IF (I.LT.-8) THEN
        WRITE (ITO,3000) AMAX,AMIN
3000  FORMAT (' Range from ',E12.4,' to ',E12.4,' too small for GETSCL')
        STOP
      ENDIF
      XX=XX*10.
      GO TO 4
C
    2 I=I+1
      IF (I.GT.8) THEN
        WRITE(ITO,3001) AMAX,AMIN
3001  FORMAT (' Range from ',E12.4,' to ',E12.4,' too big for GETSCL')
        STOP
      ENDIF
      XX=XX/10.
      GO TO 1
C
    3 AMUL=10.**I
      STEP=2.
      IF (XX.LE.5.) STEP=1.
      IF (XX.LE.2.5) STEP=.5
      IF (XX.LE.1.4) STEP=.2
      BIGSTP=AMUL*STEP
      STEPX=BIGSTP/5.
      BIT=STEPX*0.49
C  SET POSITION OF AXIS TO BE PLOTTED
C BIGSTP USED INSTEAD OF ZERO FOR COSMETIC REASONS:
      IF (AMIN.LE.BIGSTP  .AND. AMAX.GE.-BIGSTP) THEN
        X(L,5)=0.
        IF (AMIN .GT. 0.) AMIN=0.
        IF (AMAX .LT. 0.) AMAX=0.
      ELSE
C  ORIGIN OUTSIDE GRAPH
        IF (AMIN .LE. 0.) THEN
          X(L,5)=FLOAT(IFIX(AMIN/BIGSTP))*BIGSTP
        ELSE
          X(L,5)=FLOAT(IFIX((AMIN-BIT)/BIGSTP)+1)*BIGSTP
        ENDIF
      ENDIF
      NDIVS(L,1)=JFIX((ABS(AMIN-X(L,5))+BIT)/STEPX)
      NDIVS(L,2)=JFIX((ABS(AMAX-X(L,5))+BIT)/STEPX)
      X(L,1)=FLOAT(NDIVS(L,1)+NDIVS(L,2))*STEPX
      X(L,3)=BIGSTP
      X(L,4)=X(L,5)-FLOAT(NDIVS(L,1))*STEPX
      ISIG(L)=I
      IF (STEP.LT.1) ISIG(L)=I-1
      RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE GETSQ(A,T,X,I,J,MM,NN)
      SUBROUTINE GETSQ(A,T,X,I,J,MM,NN)
C
C *** GETSQ by JCM 24 Nov 83 ***
C
CX
CC 15C
CH Works out where a contour crosses the sides of a square of function
CH values.
CA On entry array A holds the rectangular array of function values.
CA    MM,NN are the dimensions of A.
CA    I,J specify the point under consideration.
CA On exit array T has been set up to indicate where in the square
CA the  contour will go.
C
      DIMENSION A(MM,NN),T(6)
C
      T(1) = A(I,J) - X
      T(2) = A(I,J+1) - X
      T(3) = A(I+1,J+1) - X
      T(4) = A(I+1,J) - X
      T(5) = T(1)
      BIG = T(1)
      SMALL = T(1)
      SUM = T(1)
      DO 1 K=2,4
      IF (T(K) .GT. BIG)  BIG=T(K)
      IF (T(K) .LT. SMALL)  SMALL = T(K)
   1  SUM = SUM + T(K)
      T(6) = (SUM - BIG - SMALL)*0.5
      RETURN
      END
C
C
C
C
C LEVEL 4      BLOCK DATA GFDEFS
      BLOCK DATA GFDEFS
C
C *** GFDEFS integrated from dispersed data by PJB Jan 2017 ***
CX
CC 14C
CH DEFINES all colors and symbols used in CCSL graphics
C
CN Colours and symbols are defined here and are accessed through
CN tables mapping these to those available in each graphic library.
C
/GFWRDS/
/GFNUMS/
      DATA NGFCOL,NGFSYM,NGFTYP,NGFLS/15,11,2,5/
C TABLE MAPPING MAP SYMBOL NAMES TO GPLOT ONES
      DATA GFCOLS/'bla','red','gre','blu','cya','mag',
     &'yel','ora','spr','sea','aqu','pur','pin','dkg','ltg'/
      DATA RGBWRD/'#000000','#FF0000','#00FF00','#0000FF',
     &  '#00FFFF','#FF00FF','#FFFF00','#FFA500','#00FF7F',
     &  '#2E8B57','#87CEEB','#800080','#FFC0CB','#A9A9A9',
     &  '#D3D3D3'/
C Symbols with numbers 1-4 AND 7-9 than 3 are fillable
      DATA GFSYMS/'plussi','xcross','asteri','square','circle','uptria',
     & 'dwntri','diamon','star','eggtim','bowtie'/
      DATA GFTYPS/'open','fill'/
      DATA GFLSTY /'full','dash','dado','dott','dadd'/
      END
C
C
C
C
C LEVEL 1      SUBROUTINE GMADD(A,B,C,NI,NJ)
      SUBROUTINE GMADD(A,B,C,NI,NJ)
C
C *** GMADD by JCM ***
C
CX
CC 12C
CH Sets matrix C = matrix A plus matrix B.
CA On entry A and B are real matrices of dimension (NIxNJ)
CA On exit  C is a real matrix which is their sum.
CN NI and NJ must be at least 1
C
      DIMENSION A(NI,NJ),B(NI,NJ),C(NI,NJ)
      DO 1 I= 1,NI
      DO 1 J=1,NJ
   1  C(I,J) = A(I,J) + B(I,J)
      RETURN
      END
C
C
C
C
C LEVEL 1      LOGICAL FUNCTION GMATCH(A,B,NA,NB)
      LOGICAL FUNCTION GMATCH(A,B,NA,NB)
C
C *** GMATCH corrected by PJB 4-Apr-2001 ***
CX
CC 12C
CH To determine whether the two real matrices A and B are the same
CA A and B are real matices of dimension NAxNB
CD Return .TRUE. if all equivalent elements of the two matrices differ by less
CD than 10E-5, returns .FALSE, otherwise
C
      DIMENSION A(1),B(1)
C
      GMATCH=.FALSE.
      N=NA*NB
      DO 1 I=1,N
      IF (ABS(A(I)-B(I)).GT. 10E-5) GO TO 100
    1 CONTINUE
      GMATCH=.TRUE.
  100 RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE GMEQ(A,B,NI,NJ)
      SUBROUTINE GMEQ(A,B,NI,NJ)
C
C *** GMEQ by PJB/JCM 28 Jun 83 ***
C
CX
CC 12C
CH Sets matrix B = matrix A.
CA On entry A is a real matrix of dimension NIxNJ
CA On exit  B is a real matrix equal to A
CN NI and NJ must be at least 1
C
      DIMENSION A(NI,NJ),B(NI,NJ)
      DO 1 I=1,NI
      DO 1 J=1,NJ
    1 B(I,J)=A(I,J)
      RETURN
      END
C
C
C
C
C LEVEL 3      SUBROUTINE GMINV(A,B,N)
      SUBROUTINE GMINV(A,B,N)
C
C *** GMINV by JCM from SID 11 Oct 88 ***
C
CX
CC 12C
CH Inverts matrix A into matrix B.
CA On entry A is a square NxN real matrix
CA On exit  B is its inverse
CD Based on SID
C
      DIMENSION II(100),IL(100),IG(100),A(N,N),B(N,N)
C
      CALL GMEQ(A,B,N,N)
      D=1.
      IS=N-1
      DO 10 K=1,N
      IL(K)=0
   10 IG(K)=K
C
      DO 150 K=1,N
      R=0.
      DO 40 I=1,N
      IF (IL(I) .NE. 0) GO TO 40
      W=B(I,K)
      X=ABS(W)
      IF (R .GT. X) GO TO 40
      R=X
      P=W
      KF=I
   40 CONTINUE
      II(K)=KF
      IL(KF)=KF
      D=D*P
      IF (D .EQ. 0.) CALL ERRMES(1,0,'Zero determinant')
C
      DO 80 I=1,N
      IF (I .EQ. KF) THEN
      B(I,K)=1./P
      ELSE
      B(I,K)=-(B(I,K)/P)
      ENDIF
   80 CONTINUE
C
      DO 140 J=1,N
      IF (J .EQ. K) GO TO 140
      W=B(KF,J)
      IF (W .EQ. 0.) GO TO 140
      DO 130 I=1,N
      IF (I .EQ. KF) THEN
      B(I,J)=W/P
      ELSE
      B(I,J)=B(I,J)+W*B(I,K)
      ENDIF
  130 CONTINUE
  140 CONTINUE
C
  150 CONTINUE
C.....
C
      DO 190 K=1,IS
      KF=II(K)
      KL=IL(KF)
      KG=IG(K)
      IF(KF .EQ. KG) GO TO 190
      DO 170 I=1,N
      R=B(I,KF)
      B(I,KF)=B(I,KG)
  170 B(I,KG)=R
      DO 180 J=1,N
      R=B(K,J)
      B(K,J)=B(KL,J)
  180 B(KL,J)=R
      IL(KF)=K
      IL(KG)=KL
      IG(KL)=IG(K)
      IG(K)=KF
      D=-D
  190 CONTINUE
      RETURN
      END
C
C
C
C
C
C LEVEL 2       SUBROUTINE GMNORM(A,B,II,JJ)
       SUBROUTINE GMNORM(A,B,II,JJ)
C
C *** GMNORM by PJB ***
C
CX
CC 12C
CH Normalises the rows of a matrix.
CA On entry A is an IIxJJ real matrix
CA On exit A has been normalised using B, A(I,J) out = A(I,J) in / B(J)
CA         B holds the normalising coefficients
C
      DIMENSION A(II,JJ),B(JJ)
C
      DO 1 J=1,JJ
      CALL GMPRD(A(1,J),A(1,J),B(J),1,II,1)
      IF (B(J).GT..0001) THEN
        B(J)=SQRT(B(J))
        ANORM=1./B(J)
        CALL GMSCA(A(1,J),A(1,J),ANORM,II,1)
      ENDIF
    1 CONTINUE
      RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE GMPRD(A,B,C,NI,NJ,NK)
      SUBROUTINE GMPRD(A,B,C,NI,NJ,NK)
C
C *** GMPRD by JCM ***
C
CX
CC 12C
CH Sets matrix C = matrix A times matrix B.
CA On entry A is a real NIxNJ matrix
CA          B is a real NJxNK matrix
CA On exit  C is a real NIxNK matrix holding A times B
C
      DIMENSION A(1),B(1),C(1)
      DO 2 I = 1,NI
      IK = I
      JK = 1
      DO 2 K = 1,NK
      IJ = I
      C(IK) = 0.
      DO 1 J = 1,NJ
      C(IK) = C(IK) + A(IJ)*B(JK)
      IJ = IJ + NI
    1 JK = JK + 1
    2 IK = IK + NI
      RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE GMREV(A,B,NI,NJ)
      SUBROUTINE GMREV(A,B,NI,NJ)
C
C *** GMREV by PJB/JCM 28 Jun 83 ***
C
CX
CC 12C
CH Reverses the signs of the elements of an NI X NJ matrix.
CA On entry A is a real matrix of dimension NIxNJ
CA On exit  B is a real matrix holding -A
CN A and B may be the same matrix
C
      DIMENSION A(NI,NJ),B(NI,NJ)
      DO 1 I=1,NI
      DO 1 J=1,NJ
    1 B(I,J)=-A(I,J)
      RETURN
      END
C
C
C
C
C LEVEL 1      LOGICAL FUNCTION GMSAME(A,B,N,TOLER)
      LOGICAL FUNCTION GMSAME(A,B,N,TOLER)
C
C *** GMSAME by JCM 22 Oct 86 ***
C
CX
CC 11C
CH Tells whether one vector is the same as another, to a given tolerance.
C
CA A on entry is an N-sized array, to be compared with:
CA B, also an N-sized array (A and B may of course be parts of larger arrays)
CA N on entry is the number of elements of A and B to compare
CA TOLER on entry is the number within which all the elements of A and B
CA      must agree
CA
CA GMSAME will be set .TRUE. if all elements of A and B agree within TOLER,
CA      and .FALSE. otherwise
C
      DIMENSION A(N),B(N)
C
      GMSAME=.FALSE.
      DO 1 I=1,N
      IF (ABS(A(I)-B(I)) .GT. TOLER) GO TO 100
   1  CONTINUE
      GMSAME=.TRUE.
 100  RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE GMSCA(A,B,SCALE,NI,NJ)
      SUBROUTINE GMSCA(A,B,SCALE,NI,NJ)
C
C *** GMSCA by JCM 22 Nov 84 ***
C
CX
CC 12C
CH Multiplies every element of the matrix A by the scalar SCALE.
CA On entry A is a real matrix of dimension NIxNJ
CA          SCALE is the required multiplying scale
CA On exit  B is a real matrix whose elements are those of A times SCALE.
CN A and B may be the same matrix
C
      DIMENSION A(1),B(1)
      NIJ=NI*NJ
      DO 1 I=1,NIJ
    1 B(I)=SCALE*A(I)
      RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE GMSUB(A,B,C,NI,NJ)
      SUBROUTINE GMSUB(A,B,C,NI,NJ)
C
C *** GMSUB by PJB/JCM 28 Jun 83 ***
C
CX
CC 12C
CH Sets matrix C = matrix A minus matrix B.
CA On entry A and B are real matrices of dimension NIxNJ
CA On exit  C is a real matrix whose elements are those of A-B
C
      DIMENSION A(1),B(1),C(1)
      NIJ=NI*NJ
      DO 1 I= 1,NIJ
   1  C(I) = A(I) - B(I)
      RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE GMTRAN(A,B,JJ,II)
      SUBROUTINE GMTRAN(A,B,JJ,II)
C
C *** GMTRAN by PJB ***
C
CX
CC 12C
CH Transposes a JJxII matrix A into B.
CA On entry A is a real matrix of dimension (JJxII)
CA On exit  B is a real matrix of dimension (IIxJJ) which is the transpose of A
C
      DIMENSION A(JJ,II),B(II,JJ)
C
      DO 1 J=1,JJ
      DO 1 I=1,II
      B(I,J)=A(J,I)
    1 CONTINUE
      RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE GMUNI(A,NI)
      SUBROUTINE GMUNI(A,NI)
C
C *** GMUNI by JCM 7 Jul 83 ***
C
CX
CC 12C
CH Writes a unit matrix into the square matrix A.
CA On entry NI is the dimension of the required matrix
CA On exit  A is a square real matrix of dimension NIxNI, set to a unit matrix
C
      DIMENSION A(NI,NI)
      DO 1 I=1,NI
      A(I,I)=1.
      I1=I+1
      IF (I1 .GT. NI) GO TO 100
      DO 1 J=I1,NI
      A(I,J)=0.
   1  A(J,I)=0.
 100  RETURN
      END
C
C
C
C
C LEVEL 6      SUBROUTINE GNUSYM(NUM,IGSYM,SIZE,X,Y,ICOL,FILL,ASPCTM,PS)
      SUBROUTINE GNUSYM(NUM,IGSYM,SIZE,X,Y,ICOL,FILL,ASPCTM,PS)
C
C *** GNUSYM New by PJB Aug 2017  C4.38 ***
C
CX
CC 14B
CH To write instructions to draw a symbol on the gnuplot command file IPLO
C
CA NUM  the current Gnuplot label number
CA IGSYM the number of the symbol in table LPGTAB
CA SIZE the symbol size in gnuplot 'first' coordinates (Angstroms for fourier maps)
CA X,Y the position for the symbol in gnuplot 'graph' coordinates
CA ICOL the number of the color from table  RGBWRD
CA FILL logical, TRUE if the symbol should be filled.
CA ASPCTM The aspect ratio x/y of the plot scales
CA PS logical TRUE for eps  output
C
      EXTERNAL GFDEFS
      LOGICAL FILL,PS
      CHARACTER *2 BSL
      DIMENSION IVECS(2,5,6),ISTAR(2,6)
      DIMENSION ITYPE(11),RPTS(2,4),LGPTAB(11)
/CONSTA/
/GFWRDS/
/GPLMAP/
/IOUNIT/
C TABLE MAPPING MAP SYMBOL NAMES TO GPLOT ONES
      DATA LGPTAB  /1, 2, 3, 5, 4, 7, 8, 6, 11, 9, 10/
C        igsym = 1 'plussi' ISYM = 1
C        igsym = 2 'xcross' ISYM = 2
C        igsym = 3 'asterx' ISYM = 3
C        igsym = 4 'square' ISYM = 5  a=0.5.b=a   2
C        igsym = 5 'circle' ISYM = 4  a=2*atan2(1,0) 1 1
C        igsym = 6 'uptria' ISYM = 7  a=1./(sqrt(sqrt(3))) b=a/sqrt(3)
C        igsym = 7 'dwntri' ISYM = 8  a=1./(sqrt(sqrt(3))) b=a/sqrt(3)
C        igsym = 8 'diamon' ISYM = 6  a=1./sqrt(2),b=a obj 3
C        igsym = 9 'star'   ISYM = 11  a=0.5./(sqrt(sqrt(3))) b=a/sqrt(3)
C        igsym =10 'eggtim' ISYM = 9 a=0.5.b=a
C        igsym =11 'bowtie  ISYM =10 S a=0.5.b=a
      DATA IVECS /1 ,1,  0, 2, -2, 0,  2,-2,  2,0,    !square
     &            1, 0, -1,-1, -1, 1,  1, 1,  1,-1,   !diamond
     &            0, 1,  1,-2, -2, 0,  1, 2, 99,99,   !uptri
     &            0,-1, -1, 2,  2, 0, -1,-2, 99,99,   !dwntri
     &            1, 1, -2,-2,  2, 0,  -2, 2, 2, 0,   !eggtimer
     &            1, 1,  0,-2, -2, 2,  0,-2,  2,2/    !bowtie
      DATA ISTAR  /1,1, 2,0, -1,1, 1,1,-2,0,-1,1 /    !star
      DATA ITYPE /4,4,4,1,2,5,3,3,6,6,6/
      ISYM=LGPTAB(IGSYM)
C      WRITE (ITO,5000) NUM,IGSYM,ISYM,ITYPE(ISYM),SIZE,X,Y,ICOL,FILL
C 5000 FORMAT('ENTRY TO GPSYM ',4I3,3F10.4,I4,2X,L)
C MAKE OBJECTS HAVE EQUAL AREAS A**2
      GO TO (1,2,3,4,3,3), ITYPE(ISYM)
C CIRCLE
    1   A= SIZE/SQRT(PI)
        WRITE (IPLO,2000) NUM,X,Y,A
 2000 format('set object ',i2,' circle at graph',F8.3,',',f8.3,
     &' size graph ',f8.3)
         GO TO 5
C SQUARE
    2   A=0.5*SIZE
        B=A*ASPCTM
        WRITE (IPLO,2001) NUM,X-A,Y-B,2.*A,2.*B
 2001    format('set object ',i3,' rectangle from graph ',F8.3,',',f8.3,
     &   ' rto graph ',F8.3,',',f8.3)
         GOTO 5
C POLYGON
    3 IF (ITYPE(ISYM).EQ.3) THEN  !TRIANGLES
        A=SIZE/(SQRT(SQRT(3.)))
        B=0.5*A*ASPCTM*SQRT(3.)
        NV=3
      ELSE IF (ISYM.EQ. 6) THEN ! DIAMOND
          A=SIZE*SQRT(0.5)
       	  B=A*ASPCTM
       	  NV=4
      ELSE IF (ISYM.EQ. 11) THEN ! STAR
          A=SIZE/6.
          B=0.5*SIZE*ASPCTM/SQRT(3.)
          GO TO 7
      ELSE
       	  A=0.5*SIZE  !EGGTIMER AND BOWTIE
       	  B=A*ASPCTM
       	  NV=4
      ENDIF
      JSYM=ISYM-4
      WRITE (IPLO,2002) NUM,X+A*FLOAT(IVECS(1,1,JSYM)),
     &  Y+B*FLOAT(IVECS(2,1,JSYM))
 2002 format ('set object ',I2,' polygon from graph ',
     &F8.3,',',f8.3, '\')
      CALL GMZER (RPTS,2,4)
      DO 6 N=2,NV+1
        RPTS(1,N-1)=A*FLOAT(IVECS(1,N,JSYM))
        RPTS(2,N-1)=B*FLOAT(IVECS(2,N,JSYM))
    6 CONTINUE

      IF (ISYM .EQ. 11) GO TO 7
      IF (NV.EQ.3) THEN
        WRITE (IPLO,2003) ((RPTS(I,N),I=1,2),N=1,3)
 2003   format (3(' rto graph ',f8.3,',',f8.3))
      else
        WRITE (IPLO,2004) ((RPTS(I,N),I=1,2),N=1,4)
 2004   format (4(' rto graph ',f8.4,',',f8.4))
      endif
      go to 5
C star
    7 WRITE (IPLO,2002) NUM,X,Y+2*B
      BSL= ' \'
      DO J=-1,1,2
        DO N=1,6
          RPTS(1,N)=A*FLOAT(J*ISTAR(1,N))
          RPTS(2,N)=B*FLOAT(J*ISTAR(2,N))
        ENDDO
        WRITE (IPLO,2008) ((RPTS(L,N),L=1,2),N=1,6),BSL
        BSL='  '
 2008   format (6(' rto graph ',f8.4,',',f8.4),a2)
      ENDDO
      GO TO 5
    5 IF (FILL) THEN
        WRITE (IPLO,2006) NUM,RGBWRD(ICOL)
 2006   format ('set object ',I2,' front noclip fc rgb "',a,
     &   '" fillstyle solid 1.0 border lt -1')
      ELSE
        WRITE (IPLO,2007) NUM,RGBWRD(ICOL)
 2007   format ('set object ',I2,'front noclip  lc rgb "',a,
     &  '" fillstyle empty border lt 1')
      ENDIF
      GO TO 100
C
C HERE FOR 'POINT' STYLE SYMBOLS
    4 SSIZE=SIZE*100
      IF (PS) SSIZE=SSIZE*2.
      WRITE (IPLO,2005) NUM,X*WIDMAP,Y*HGTMAP,ISYM,SSIZE,
     & RGBWRD(ICOL)
 2005 format ('set label ',I2,' front at',F8.3,',',f8.3,
     &   ' " " point pt ',i2,' ps ',f6.2,' lw 4 lc rgb "',A,'"')
      GO TO 100
C
  100 RETURN
      END
C
C
C
c
C LEVEL 1      SUBROUTINE GMZER(A,NI,NJ)
      SUBROUTINE GMZER(A,NI,NJ)
C
C *** GMZER by JCM 7 Jul 83 ***
C
CX
CC 12C
CH Clears to zero the matrix A.
CA On entry NI and NJ specify A to be of dimension NIxNJ
CA On exit  A is a real matrix of dimension NIxNJ all cleared to zero.
C
      DIMENSION A(1)
      NIJ=NI*NJ
      DO 1 I=1,NIJ
   1  A(I)=0.
      RETURN
      END
C
C
C
C
      SUBROUTINE GRAFOF
C
C *** DUMMY
C
      RETURN
      END
C
C
C
C
      SUBROUTINE GRAFON
C
C *** DUMMY
C
      RETURN
      END
C
C
C
C
C LEVEL 4      CHARACTER *40 FUNCTION HCNAME(EXT)
      CHARACTER *40 FUNCTION HCNAME(EXT)
C
C    **** HCNAME new by PJB Jan 2017 ****
CX
CC 14C
CH Creates a new filename for hard copy output of graphics (replaces pgfile0
C
      CHARACTER EXT*3,FILNOM*10,CRY*10
      LOGICAL THERE
CH BUILD THE FILE NAME FOR PRINTED OUTPUT
/CARDRC/
/IOUNIT/
/WHEN/
      DATA NUM/-1/
      SAVE NUM
C
      LM=LENGT(MAIN)
      HCNAME=MAIN(1:LM)
      CALL UPONE(HCNAME,2)
   10 FORMAT (A)
       IF (ICRYDA.GT.0 ) THEN   ! should be -9999 if not opened
        CRY=FILNOM(ICRYDA)
        LC=INDEX(CRY,'.') -1
        IF (LC .LT.0) LC=LENGT(CRY)
        WRITE (HCNAME(LM+1:),10) '_'//CRY(1:LC)
        LM=LM+LC+2
      ELSE IF (LUNI.GT.0) THEN
        CRY=FILNOM(LUNI)
        LC=INDEX(CRY,'.')-1
        IF (LC .LT.0) LC=LENGT(CRY)
        WRITE (HCNAME(LM+1:),10) '_'//CRY(1:LC)
        LM=LM+LC+2
      ENDIF
      LE=LENGT(EXT)
      LT=LM+LE+3
    1 NUM=NUM+1
      IF (NUM.GT.99) NUM=0
   11 FORMAT ('_'I2.2,'.',A)
      WRITE (HCNAME(LM:),11) NUM,EXT(1:LE)
      INQUIRE(FILE=HCNAME(1:lengt(HCNAME)),EXIST=THERE)
      IF (THERE) GO TO 1
      RETURN
      END
C
C
C
C
C LEVEL 8      SUBROUTINE HDROUT(LUNIT,NOUT,MODE)
      SUBROUTINE HDROUT(LUNIT,NOUT,MODE)
C
C *** HDROUT UPDATED BY PJB Nov 2010 C4.22 ***
C
CC 2A
CH common module to write headers on files for input to LSQ
C
CA on Input LUNIT an array of length NUNIT, giving the units on which to write
CA          MODE an integer whose binary bits indicate which special data is
CA               to be added to the header
CA             1 Absorption coefficient
CA             2 Polarisation direction and efficiencies
C
      DIMENSION LUNIT(NOUT)
      LOGICAL ABS,POLAR,BINDIG,SAYS
C
/ABSDAT/
/CARDRC/
/DGEOM/
/IOUNIT/
/POLDA/
/SCRACH/

C POLARISATION DEPENDENT DATA?
      POLAR=BINDIG(MODE,2)
      ABS=BINDIG(MODE,1)
C Write header on output files
    1 IF (IPLO.NE.0) THEN
        READ (IPLO,2005,END=2) MESSAG
 2005   FORMAT (A100)
        DO 3 N=1,NOUT
C4.21  Don't print wavelength or UBmatrix if SETDC has been called
        IF ((SAYS('#WAVEL') .OR. SAYS('#UBMAT')) .AND.
     &  INREAD(4).LE.0) GO TO 3
        WRITE (LUNIT(N),2005) MESSAG
    3   CONTINUE
        GO TO 1
    2   CALL CLOFIL(IPLO)
      ENDIF
C4.21 In case SETDC has been called
      DO 4 N=1,NOUT
      IF (INREAD(4).LE.0) THEN
        WRITE (MESSAG,2003) WLGTH
        IF (ALAM2.GT.10E-6) WRITE (MESSAG(22:),2006) ALAM2
 2003 FORMAT ('#Wavelength',2F10.4)
 2006 FORMAT (' HalfWave',F10.4)
        WRITE (LUNIT(N),2005) MESSAG
        WRITE (LUNIT(N),2002) UM
      ENDIF
      IF (ABS) WRITE (LUNIT(N),2004) AMU
 2004 FORMAT ('#Absorption',f10.4)
 2002 FORMAT ('#Orientation',9F8.4)
      IF (POLAR) WRITE (LUNIT(N),2001) POLND,POLUP,POLDW
 2001 FORMAT ('#Polarisation',5F10.4)
    4 CONTINUE
C
      RETURN
      END
C
C
C
C
C LEVEL 2      FUNCTION IATOM(ANAME)
      FUNCTION IATOM(ANAME)
C
C *** IATOM updated for MK4 by JCM 8 Feb 9 ***
C
CX
CC 11C
CH Identifies an atom name in a given list.
CA On entry ANAME is an A4 CHARACTER atom name, left justified
CA On exit  IATOM=0 if this is not a name in the existing list, or
CA               =a positive integer, being the number of the atom whose
CA                name this is, if found.
CP The list must be set up in array ATNAME in /ATNAM by, e.g. ATOPOS
      CHARACTER *4 ANAME
/ATNAM/
/POSNS/
C
      IF (NATOM .EQ. 0) THEN
        IATOM=0
      ELSE
        IATOM=NCFIND(ANAME,ATNAME,NATOM)
      ENDIF
      RETURN
      END
C
C
C
C
C LEVEL 6      SUBROUTINE ICDINC
      SUBROUTINE ICDINC
C
C *** ICDINC modified for AKSTAR in common SATELL C4.35 March 2017***
C
CX
CC 2C
CH  TO READ I CARDS WITH INCOMENSURATE WAVE-VECTOR INFO
C
      DIMENSION H(3),HI(3),HR(3),K(3),Y(3),PVEC(3)
      LOGICAL LATABS,INMULT
/ARRDAT/
/CARDRC/
/IINFO/
/IINFOW/
/IOUNIT/
/INCDAT/
/SATELL/
/WHEN/
C
      CALL FINDCD('Q','PROP',4,0,LCD)
      IF (LCD.EQ.0) CALL ERRMES(3,0,'Q PROP')
      CALL RDNUMS(PVEC,7,3,NUM,IER)
      IF (IER .NE.0 .OR. NUM .NE. 3) CALL ERRMES(1,0,
     & ' reading Q PROP card')
      CALL PROPER(PVEC)
      INC=(IPROP.GT.0)
      IF (INC) THEN
        MULINT=0
        FMULT=1.
        FMUL(1)=1.
        FMUL(2)=1.
        FMUL(3)=1.
C4.29 program name  from common WHEN allows insetion in library
        IF (IIN.LE.0) CALL ERRMES(1,0,'I card needed in '//MAIN)
        I=NCFIND('MULP',IIREAD,IIN)
        IF (I.NE.0) THEN
          FMULT=ACOEFF(I)
          MULINT=-1
        ELSE
          I=NCFIND('MULX',IIREAD,IIN)
          IF (I.NE.0)  FMUL(1)=ACOEFF(I)
          MULINT=I
          I=NCFIND('MULY',IIREAD,IIN)
          IF (I.NE.0)  FMUL(2)=ACOEFF(I)
          MULINT=MULINT+I
          I=NCFIND('MULZ',IIREAD,IIN)
          IF (I.NE.0)  FMUL(3)=ACOEFF(I)
          MULINT=MULINT+I
        ENDIF
        IF (IFOR(1).LT.4 .AND. MULINT.EQ.0)
     &  CALL ERRMES(3,0,'I MULP,MULX,MULY or MULZ ')
C
        IF (MULINT.LT.0) WRITE (LPT,1001) FMULT
 1001   FORMAT (/' Indices as read to be divided by',F5.1,//)
        IF (MULINT.GT.0) WRITE (LPT,1002) FMUL
 1002   FORMAT (/' h, k, l as read to be divided by',3F5.1,//)
      ENDIF
      GO TO 100
C
C ENTRY TO FIND FUNDAMENTAL FROM INCOMENSURATE HI
      ENTRY INDFND(H,K,HI,JS)
      ACC=.001
      INMULT=.FALSE.
      GO TO 11
C
C ENTRY WITH MULTIPLIED H, RETURN FUNDAMENTAL H AND IS
      ENTRY INCMUL(H,HR,HI,JS)
      INMULT=.TRUE.
      IF (MULINT.LT.0) GO TO 9
      IF (MULINT.EQ.0) THEN
        CALL GMEQ(HR,HI,3,1)
      ELSE
        DO 8 I=1,3
        HI(I)=HR(I)/FMUL(I)
    8   CONTINUE
      ENDIF
      ACC=0.006
      GO TO 11
    9 DO 1 I=1,3
    1 HI(I)=HR(I)/FMULT
      ACC=1.01/FMULT
      GO TO 11
C
      ENTRY INCFUN(H,K,HI,JS)
      INMULT=.FALSE.
      ACC=.0001
C
   11 IF (.NOT. LATABS(HI)) THEN
        CALL GMEQ(HI,H,3,1)
        IS=0
      ELSE
        ISIG=1
        DO 3 IC=1,KCENT
        DO 2 IS=1,NKC
        DO 4 I=1,3
        Y(I)=HI(I)-AKSTAR(I,IS)*ISIG
        H(I)=FLOAT(JFIX(Y(I)))
        IF (ABS(H(I)-Y(I)).GT.ACC) GO TO 2
    4   CONTINUE
        IF (.NOT.LATABS(H)) GO TO 6
    2   CONTINUE
        ISIG=-ISIG
    3   CONTINUE
C
C  ERROR
        WRITE (LPT,3000) HI,(AKSTAR(I,1),I=1,3)
 3000   FORMAT (' Can''t find fundamental corresponding to ',3F6.3,
     &   'with propagation vector ',3F6.3)
        IS=999
        GO TO 7
C
      ENDIF
    6 IF (IS.EQ.0) GO TO 7
      IF (ISIG.GT.0) THEN
        CALL GMADD(H,AKSTAR(1,IS),HI,3,1)
      ELSE
        CALL GMSUB(H,AKSTAR(1,IS),HI,3,1)
      ENDIF
      IS=IS*ISIG
    7 JS=IS
      IF (.NOT. INMULT) CALL INDFIX(H,K)
      GO TO 100
C
C  ENTRY WITH COMENSURATE K RETURN INCOMENSURATE HI
      ENTRY INCFLO(H,K,HI,JS)
      CALL INDFLO(H,K)
C
C  ENTRY WITH FUNDAMENTAL H RETURN INCOMENSURATE HI
      ENTRY INCIND(H,K,HI,JS)
      IS=JS
      IF (IS.EQ.0) THEN
        CALL GMEQ(H,HI,3,1)
      ELSE IF (IS.GT.0) THEN
        CALL GMADD(H,AKSTAR(1,IS),HI,3,1)
      ELSE
        CALL GMSUB(H,AKSTAR(1,-IS),HI,3,1)
      ENDIF
      GO TO 100
C
  100 RETURN
      END
C
C
C
C
4

C LEVEL 6      SUBROUTINE ICDFMT(INC,ITEMS)
      SUBROUTINE ICDFMT(INC,ITEMS)
C
C *** ICDFMT corrected by PJB C4.4.25 January 2012  ***
C
CX
CC 2A
CH Interprets I and Q PROP cards for programs reading ARRNGE type data".
CA Returns ICD=0 for integer and 1 for non-integer indices,
CA and the number of items stored per reflection  in ITEMS.
C
C4.2 NANGS and DATWRD added
      DIMENSION APROP(3),NANGS(9)
      CHARACTER*12 DATWRD *18
      CHARACTER *4 INEED(3)
      LOGICAL ONCARD
      EXTERNAL VARFMT
/IOUNIT/
/SATELL/
      COMMON/VARFOR/RLINE1,RLINE2
      CHARACTER*20 RLINE2
      CHARACTER*16 RLINE1
C
      DATA INEED/'RNUM','DTYP','ANGL'/
C4.2 NANGS gives different number of angles recorded for each geometry
      DATA NANGS/3,4,4,4,0,4,3,4,3/
C
C4.3 Method of calculating ITEMS improved
      ITEMS=2
      DO 1 J=1,3
      IF (ONCARD('I',INEED(J),A)) GO TO 3
C
C  WORD NOT PRESENT
      GO TO (4,6,20) ,J
C
    3 IICD=JFIX(A)
      GO TO (5,8,21),J
C  NO RECORD NUMBERS WRITTEN
    4 CALL MESS(LPT,1,'No record numbers on input file')
C4.3 RLINE2 simplified, ALTLIN no longer needed
      GO TO 1
C
    5 IF (IICD.LT.1) GO TO 4
      CALL MESS(LPT,1,'Record numbers read from input file')
      ITEMS=ITEMS+1
      GO TO 1
C
    8 NDTYP=IICD
      IF (IICD.EQ.5) THEN
        RLINE2(11:11)='4'
        WRITE (LPT,2001) IICD
 2001 FORMAT (' DTYP =',I3,' SXD:'/' records contain Fsqrsd, DFsqrd,',
     & 'wavelength and pathlength'/)
C4.20  leave space for items: wavelength and pathlength
      ITEMS=ITEMS+2
C 145 Improve output message
      ELSE IF (NDTYP.EQ.1 .OR. IICD .EQ.9) THEN
        DATWRD = 'Flipping R and dR,'
      ELSE IF (NDTYP.EQ.10 ) THEN
C4.3 report new types
        DATWRD = 'Asymmetry A & dA, '
      ELSE IF (NDTYP.EQ. 11 .OR. NDTYP .EQ. 12 ) THEN
        WRITE (LPT,2005) NDTYP
 2005 FORMAT (' DTYP =',I3,
     &' records contain Pmat(IJ) ,DPmat(IJ) and IJ')
       ITEMS=ITEMS+1
      ELSE
        DATWRD = 'Fsqrsd and DFsqrd,'
      ENDIF
      GO TO 1
C
C ARE ANGLES RECORDED
   20 IF (NDTYP.NE.5 .AND. NDTYP .LE. 10) THEN
        WRITE (LPT,2000) NDTYP,DATWRD
 2000 FORMAT (' DTYP =',I3,' records contain ',A18,' only'/)
        GO TO 1
      ENDIF
  21  IF (IICD.EQ.0) GO TO 20
C 145 Report angles recorded
      IF (NANGS(NDTYP).EQ.4) THEN
        WRITE (LPT,2002) NDTYP,DATWRD
 2002 FORMAT (' DTYP =',I3,' records contain ',A18,
     &' 2theta omega chi and phi'/)
      ELSE IF (NANGS(NDTYP).EQ.3) THEN
        WRITE (LPT,2004) NDTYP,DATWRD
 2004 FORMAT (' DTYP =',I3,' records contain ',A18,
     &' 2theta omega and nu'/)
      ENDIF
C4.25 Items to be recalculated outside IF clause
      ITEMS=ITEMS+NANGS(NDTYP)
    1 CONTINUE
      WRITE (RLINE2(5:6),2006) ITEMS
 2006 FORMAT (I2)
C
C  COMMENSURATE OR INCOMMENSURATE?
      CALL FINDCD('Q','PROP',4,0,LCD)
      IF (LCD .LE.0) GO TO 6
      CALL RDNUMS(APROP,7,3,N,IER)
      IF (N.EQ.3) THEN
        CALL PROPER(APROP)
        IF (IPROP.GT.0) GO TO 9
      ENDIF
    6 CALL MESS(LPT,1,'Propagation vector not given or integer:'//
     & 'expect integer indices')
      INC=0
      GO TO 10
    9 WRITE (LPT,2003) PROP
2003  FORMAT (/'Propagation vector',3F8.3/' Expect floating ',
     & '(incommensurate) indices'/)
      INC=1
      RLINE1(7:9)='8.3'
C
   10 RETURN
      END
C
C
C
C
      BLOCK DATA VARFMT
      COMMON/VARFOR/RLINE1,RLINE2
      CHARACTER*20 RLINE2
      CHARACTER*16 RLINE1
C
      DATA RLINE1,RLINE2/'(5X,3F5.0,I5,I5)','(5X, 3F10.2)'/
      END
C
C
C
C
C LEVEL 6      SUBROUTINE IICD1
      SUBROUTINE IICD1
C
C *** IICD1 updated by JCM 7 Aug 92 ***
C
CX
CC 6A
CH Interprets basic I cards to drive any LSQ.
C
CD Deals with defaults, recognises words on I cards, reads values after them,
CD and prints out the information.
CD
CD Vocabulary recognised:
CD NCYC <number of cycles of refinement wanted> : default 3
CD CYC1 <number to be given to first cycle> : default 1
CD PRIN <request for general printing on the LPT file>
CD        followed by an integer giving the frequency of printing:
CD           0= never
CD           1=first cycle
CD           2=last cycle
CD           3= first and last cycles
CD           4= every cycle
CD MCOR <maximum correlation>
CD       or 0 for "print whole matrix"
CD       or -ve number for "print nothing"
CD PRDM <integer> ; a non-zero integer requests Deposited Material printing
CD in the same cycle that a new crystal data file is output.
CD CONV <real> to stop LSQ cycling if max (shift/esd) < CONV : default 0.01
C
      CHARACTER *4 INEED(6)
      LOGICAL ONCARD
/IOUNIT/
/REFINE/
      DATA INEED/'NCYC','CYC1','PRIN','MCOR','PRDM','CONV'/
C
C SET UP DEFAULTS FOR VALUES POSSIBLY TO BE READ FROM I CARDS:
      NCYC=3
      NCYC1=1
      IPRNT(1)=2
      MAXCOR=70
      IPRNT(7)=0
      CONV=0.01
C
C INTERPRET ANY QUANTITIES GIVEN ON I CARD:
      DO 18 I=1,6
      IF (.NOT. ONCARD('I',INEED(I),A)) GO TO 18
C
C WORD RECOGNISED - BRANCH ON WHAT TO DO WITH DATA:
      GO TO (11,12,13,14,15,16) , I
C
C NCYC:
  11  NCYC=JFIX(A)
      GO TO 18
C
C CYC1:
  12  NCYC1=JFIX(A)
      GO TO 18
C
C PRIN:
  13  IPRNT(1)=JFIX(A)
      GO TO 18
C
C MCOR:
  14  MAXCOR=JFIX(A)
      GO TO 18
C
C PRDM:
  15  IPRNT(7)=JFIX(A)
      GO TO 18
C
C CONV:
  16  CONV=A
      GO TO 18
C
  18  CONTINUE
C
C ARRANGE LAST CYCLE NUMBER, AND WHETHER SIMPLY SIMUATION:
      SIMUL=.FALSE.
      LASTCY=NCYC1+NCYC-1
      IF (LASTCY .LT. NCYC1) THEN
        LASTCY=NCYC1
        SIMUL=.TRUE.
      ENDIF
C WRITE OUT VALUES FROM POTENTIAL I CARD:
      IF (.NOT. SIMUL) THEN
      WRITE (LPT,2001) NCYC,NCYC1
2001  FORMAT (/1X,I4,' cycles of refinement with first numbered',I4)
      ELSE
      WRITE (LPT,2011) NCYC1
2011  FORMAT (/' Cycle number ',I4,' is a simulation')
      ENDIF
      CALL MESS(LPT,1,'Printing of obs and calc values wanted')
      N=IPRNT(1)
      CALL DEPRIN(N)
C
      IF (MAXCOR.LT.0) CALL MESS(LPT,1,'No correlations to be printed')
C
      IF (MAXCOR .EQ. 0) CALL MESS(LPT,1,
     & 'Whole correlation matrix to be printed')
C
      IF (MAXCOR .GT. 0) WRITE (LPT,2005) MAXCOR
2005  FORMAT (/' Correlations exceeding',I4,' per cent to be printed')
C
      WRITE (LPT,2006) CONV
2006  FORMAT (/' Cycles to stop if max(shift/esd) < ',F10.4)
C
      IF (IPRNT(7) .NE. 0) CALL MESS(LPT,1,'File for Deposited'//
     & ' Material to be output on same cycle as new CDF')
C
      RETURN
      END
C
C
C
C
C LEVEL 6      SUBROUTINE IICD3
      SUBROUTINE IICD3
C
C *** IICD3 updated by PJB 23-June-1995 ***
C
CX
CC 2A
CH Interprets I cards for ARRNGE-type MAIN programs, and sets them up.
C
CD Sets up the array IFOR in /ARRDAT/ to hold input switches
CD as may be read from I card:
CD    IFOR(1) gives the input format; see ARREAD for the various
CD            possibilities.
CD
CD    IFOR(2) is -ve for 'do not print unique reflections', +ve for 'print
CD             all reflections'.  This does not affect the filed output.
CD
CD    IFOR(3) is 0 for 'do not output record numbers to file' or 1 for
CD            'output record numbers both to file and printer'.
CD
CD    IFOR(4) gives the weighting scheme requested:
CD        IFOR(4) = 0 - unit weights for individual measurements, and
CD                  mean of equivalents weighted according to their
CD                  esds.
CD        IFOR(4) = 1 - statistical weights used for the means of individual
CD                   measurements, and esds used in weighting for mean of
CD                   equivalents.
CD        IFOR(4) = 2 - unit weights throughout.
CD
CD        IFOR(5) = whether or not a rejection list is to be given, 0 or 1.
CD
CD        IFOR(6) >= 1 if angles are to be read and stored
C
CI Reads an I card if necessary.
C
CO Writes its findings on unit LPT.
C
      CHARACTER *4 INEED(6)
      LOGICAL ONCARD
/ARRDAT/
/CARDRC/
/IOUNIT/
      DATA INEED/'DTYP','PRIN','RNUM','WGHT','REJ','ANGL'/
C
      DO 21 I=1,6
      IF (ONCARD('I',INEED(I),A)) GO TO 23
C
C WORD NOT PRESENT - BRANCH FOR DEFAULTS:
      GO TO (41,42,43,44,45,46) , I
C
C NO DTYP:
  41  CALL ERRMES(2,1,'DTYP on I card')
      GO TO 21
C
C DEFAULT NO PRIN:
  42  IFOR(2)=1
      GO TO 52
C
C DEFAULT NO RNUM:
  43  IFOR(3)=0
      GO TO 53
C
C DEFAULT NO WGHT:
  44  IFOR(4)=0
      GO TO 54
C
C DEFAULT NO REJ:
  45  IFOR(5)=0
      GO TO 55
C
C DEFAULT DONT STORE ANGLES
  46  IFOR(6)=0
      GO TO 21
C
C WORD RECOGNISED:
  23  GO TO (31,32,33,34,35,36) , I
C
C DTYP:
C IFOR(1) - INPUT FORMAT
  31  IFOR(1)=JFIX(A)
      GO TO 21
C
C PRIN:
C IFOR(2) - CONTROL OF OUTPUT FORMAT
  32  IFOR(2)=JFIX(A)
      IF (IFOR(2) .EQ. 0) IFOR(2)=-1
      IF (IFOR(2) .LT. 0) CALL MESS(LPT,1,
     & 'Unique reflections omitted from printed output')
  52  IF (IFOR(2) .GT. 0) CALL MESS(LPT,1,'All reflections printed')
      GO TO 21
C
C RNUM:
C IFOR(3) -     RECORD NUMBERS
  33  IFOR(3) = JFIX(A)
  53  IF (IFOR(3) .EQ. 0) CALL MESS(LPT,1,
     & 'Record numbers as read written to printer only')
      IF (IFOR(3) .EQ. 1) CALL MESS(LPT,1,
     & 'Record numbers as read writen to printer and file')
      GO TO 21
C
C WGHT:
C IFOR(4) = 0,1 OR 2 FOR WEIGHTING REQUIRED
  34  IFOR(4)=JFIX(A)
  54  IF (IFOR(4) .EQ. 0) THEN
        CALL MESS(LPT,1,'Unit weights for individual measurements')
        CALL MESS(LPT,0,
     & 'Mean of equivalents weighted according to their ESDs')
      ELSE IF (IFOR(4) .EQ. 1) THEN
        CALL MESS(LPT,1,'Statistical weights used for '//
     &  'the means of individual measurements')
        CALL MESS(LPT,0,'ESDs used in weighting for mean of'//
     &  ' equivalents')
      ELSE IF (IFOR(4) .EQ. 2) THEN
        CALL MESS(LPT,1,'Unit weights')
      ENDIF
      GO TO 21
C
C REJ:
C IFOR(5) HOLDS WHETHER OR NOT REJECTIONS ARE ON FILE ITEM7:
  35  IFOR(5)=JFIX(A)
  55  IF (IFOR(5) .EQ. 0) CALL MESS(LPT,1,
     & 'No reflections to be rejected')
C IF THERE IS A FILE ITEM7, WAIT TILL IT IS NAMED TO SAY SO:
      GO TO 21
C
C ANGL:
  36  IFOR(6)=JFIX(A)
      IF (IFOR(6) .EQ. 0) GO TO 21
C
      WRITE (LPT,2061)
2061  FORMAT (' Diffractometer angles to be read and stored ')
      GO TO 21
C
  21  CONTINUE
C
C
      RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE INBOX(H,IN)
      SUBROUTINE INBOX(H,IN)
C
C *** INBOX by PJB/JCM 3 Aug 83 ***
C
CX
CC 3B
CH Determines whether the given reflection is inside, on, or outside
CH the reciprocal space asymmetric unit.
CA On entry H holds h,k,l
CA On exit  IN = -1 if outside asymmetric unit
CA                0 if inside it
CA              = number of plane if on a plane
CA              = 10+number of edge if on an edge
CP SYMOP must have read the space group
CP SYMUNI must have set up the asymmetric unit
CN Assumes that NASYM (number of planes bounding the asymmetric unit) is not
CN greater than 3
C
      DIMENSION H(3)
/FUNIT/
C
      I=0
      IN=0
      IE=3
      IF (NASYM .EQ. 0) GO TO 100
      DO 1 J=1,NASYM
      TEST=(ASYM(1,J)*H(1)+ASYM(2,J)*H(2)+ASYM(3,J)*H(3))
      IF (ABS(TEST).LT.10.E-4) TEST=0.0
      IF (TEST) 2,3,4
   2  IN=-1
      GO TO 100
   3  I=I+1
      IP=J
      GO TO 1
    4 IE=J
   1  CONTINUE
      IF (I.EQ.2) IN=IE+10
      IF (I.EQ.1) IN=IP
 100  RETURN
      END
C
C
C
C
C LEVEL 4      SUBROUTINE INCELL(X,P,SHIFT)
      SUBROUTINE INCELL(X,P,SHIFT)
C
C *** INCELL updated to give shift by PJB C4.26 March 2013 ***
C
CX
CC 8B
CH Sets P to be the position in the central cell equivalent to X.
CA On entry X is a 1x3 array which holds fractional coordinates of a point in
CA            a unit cell (not necessarily in the "central" cell)
CA On exit  P is a 1x3 array which holds the fractional coordinates of an
CA            equivalent point all in range 0=<  x < 1
CA      SHIFT is the shift needed P-X.
C
      DIMENSION X(3),P(3),SHIFT(3)
C
      CALL GMEQ(X,P,1,3)
      CALL FRAC3(P)
      call gmsub(p,x,shift,3,1)
C
      RETURN
      END
C
C
C
C
C LEVEL 2      SUBROUTINE INCREM(IFNS,IFNL)
      SUBROUTINE INCREM(IFNS,IFNL)
C
C *** INCREM updated by PJB 20-April-2000 ***
C
CX
CC 13C
CH Increments a file name.
CA On entry IFNS is an A10 short file name
CA          IFNL is a full file name expected to contain IFNS
CA On exit  both file names have been incremented;  that is, the character
CA          before the . has been advanced by 1, counting 1-9, A-Z
C
      CHARACTER*10 IFNS
      CHARACTER*(*) IFNL
      CHARACTER*1 CH(6)
/GLOBAL/
C
      DATA CH/'9','A','Z','0','z','0'/
C
C CHOOSE UPPER OR LOWER CASE LETTERS ACCORDING TO SYSTEM
      CALL UPONE(CH(2),3)
C  POSITION SHORT NAME IN LONG NAME
C
      NP=INDEX(IFNL,IFNS)
      IF (NP.EQ.0) GO TO 100
C
C  CHECK FOR EXTN
      L=INDEX(IFNS,'.')-1
      IF (L.LE.0) L=LENG(IFNS,10)
C
      DO 1 I=L,1,-1
      DO 2 J=1,5,2
      IF (IFNS(I:I).NE.CH(J)) GO TO 2
      IFNS(I:I)=CH(J+1)
      IF (J.GE.2) GO TO 1
      GO TO 3
    2 CONTINUE
      IFNS(I:I)=CHAR(ICHAR(IFNS(I:I))+1)
C CHOOSE UPPER OR LOWER CASE A ACCORDING TO SYSTEM
      CALL UPONE(IFNS(I:I),3)
      GO TO 3
    1 CONTINUE
    3 IFNL(NP:NP+L)=IFNS
  100 RETURN
      END
C
C
C
C
C LEVEL 2      SUBROUTINE INDFIX(H,K)
      SUBROUTINE INDFIX(H,K)
C
C *** INDFIX by JCM 20 Jul 83 ***
C
CX
CC 3C
CH Converts 3 real items in H to be integers in K.
CA On entry H is a 1x3 real vector
CA On exit  K is a 1x3 integer vector containing the numbers in H, rounded.
C
      DIMENSION H(3),K(3)
C
      DO 1 I=1,3
   1  K(I)=JFIX(H(I))
      RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE INDFLO(H,K)
      SUBROUTINE INDFLO(H,K)
C
C *** INDFLO by JCM 22 Nov 83 ***
C
CX
CC 3C
CH Converts 3 integers in K into floating point reals in H.
CA On entry K is a 1x3 integer vector
CA On exit  H is a 1x3 real vector containing the elements of K floated.
C
      DIMENSION H(3),K(3)
C
      DO 1 I=1,3
   1  H(I)=FLOAT(K(I))
      RETURN
      END
C
C
C
C
C LEVEL      FUNCTION INDOM(H)
      FUNCTION INDOM(H)
C
C *** INDOM added to library by PJB  August 2016 ***
C
CC 17C
C
CH Determines domain number of H relative  to its equivalent in the asymmetric unit
C
CD Returns the number of the domain to which reflection with indices H(3) belongs
CP Requires the magnetic symmetry to be set up by DOMAG1(1) or  DOMAG1(3)
C
      DIMENSION H(3),RH(3)
/IOUNIT/
/SYMMAG/
/NSYM/
C
      INDOM=0
      DO 1 I=1,NOP
        CALL ROTSYM(H,RH,I,2)
        CALL INBOX(RH,IN)
        IF (IN.GE. 0) THEN
          IDOP=MSTAB(I)
          INDOM=NFIND(IDOP,MSTAB,NOP)
          GO TO 100
        ENDIF
    1 CONTINUE
  100 RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE INITIL(PROGRM)
      SUBROUTINE INITIL(PROGRM)
C
C *** INITIL corrected by PJB use of UPONE 21-April 2000 ***
C
CX
CC 13C
CH Initialises the CCSL system.
CA On entry PROGRM holds A6 name of calling program
CD INITIL is obeyed at the start of a job, either by an explicit call or
CD (more usually) from a call of PREFIN.
CD It sets up various default start conditions, some of which are machine
CD dependent.  The user may wish to override some of these later.
CD
CD The symbols permitted on input are copied into /CHARS;  this will one day be
CD done in a BLOCK DATA statement.
CD  The system is set up to be not BATCH, already ini tialised.
CD The MAIN program name is kept;  the hardware (RVAX, DIVA etc) is kept; the
CD wordlength is set;  the filenames are cleared;  the file unit numbers are
CD initialised.
CD
CD For DIVA, unit LPT is opened automatically to <Program name>.LIS
CD For other systems, the name for unit LPT is requested, and it is then opened
CD
CD The constants pi, log2 etc are put into /CONSTA
CO The banner headline is put out on LPT
C
      LOGICAL ISOPEN
      CHARACTER *23 STARS
      CHARACTER *(*) PROGRM
      CHARACTER *1 IDIGI1,LETTS,ISMBO1,ISPC1
      DIMENSION IDIGI1(10),LETTS(52),ISMBO1(21)
/CARDRC/
/CHARS/
/CONSTA/
/FINAME/
/GLOBAL/
/IOUNIT/
/LENINT/
/LOONEY/
/MAPGT/
/MAPRD/
/MAPSV/
/NEWOLD/
/PHASE/
/PRSTAT/
/REFINE/
/SCRACH/
/SOURCE/
/WHEN/
      DATA IDIGI1/'1','2','3','4','5','6','7','8','9','0'/
      DATA LETTS /'A','B','C','D','E','F','G','H','I','J','K','L',
     & 'M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z','a','b',
     & 'c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r',
     & 's','t','u','v','w','x','y','z'/
      DATA ISPC1/' '/
      DATA ISMBO1/'.',',',':',';','!','?','''','"','$','/','(',
     & ')','|','-','+','=','*','#','&','>','<'/
C
C FOR THE CONVENIENCE OF THOSE WHO FIND THE ABOVE STATEMENT EYE-CROSSING,
C THE ELEMENTS OF THE ARRAY ISMBOL WILL BE:
C  1 IS .  (FULL STOP OR DECIMAL POINT  OR DOT)
C  2 IS ,  (COMMA)
C  3 IS :  (COLON OR TWO DOTS)
C  4 IS ;  (SEMI-COLON OR DOT AND COMMA)
C  5 IS !  (EXCLAMATION MARK OR SHRIEK)
C  6 IS ?  (QUESTION MARK OR QUERY)
C  7 IS '  (APOSTROPHE OR SINGLE QUOTE)
C  8 IS "  (DOUBLE QUOTES OR CONVERSATION MARKS)
C  9 IS $  (DOLLAR)
C 10 IS /  (SLASH OR OBLIQUE OR STROKE OR SOLIDUS)
C 11 IS (  (OPENING PARENTHESIS OR LEFT BRACKET)
C 12 IS )  (CLOSING PARENTHESIS OR RIGHT BRACKET)
C 13 IS |  (VERTICAL BAR OR LOGICAL "OR")
C 14 IS -  (MINUS OR DASH)
C 15 IS +  (PLUS)
C 16 IS =  (EQUALS)
C 17 IS *  (STAR OR ASTERISK OR MULTIPLICATION SIGN)
C 18 IS #  (SHARP OR HASH)
C 19 IS &  (AMPERSAND OR AND)
C 20 IS >  (GREATER THAN OR CLOSING ANGLE BRACKET)
C 21 IS <  (LESS THAN OR OPENING ANGLE BRACKET)
C
C THE SEQUENCE ABOVE HAS BEEN TAKEN FROM THE CAMBRIDGE IBM 3081 NEW
C SOFTWARE FOR PLOTTERS, AND THE PLOTTING OF CHARACTERS IN THIS PACKAGE WILL
C USE TABLES FROM THAT SOFTWARE.  THE LAST TWO CHARACTERS DO NOT OCCUR IN
C THAT TABLE.
C
C IF THE SYSTEM IS IMPLEMENTED ON A NEW MACHINE, IT IS AS WELL TO CHECK THAT
C THE ABOVE TABLE MAKES SENSE - E.G. THAT WHERE THE WORD SAYS "DOLLAR" THE
C SYMBOL IS AN S WITH A VERTICAL LINE THROUGH IT, ETC.  IF NOT, SOME
C ADJUSTMENTS WILL HAVE TO BE MADE.  CHARACTER NUMBER 9 WILL ALWAYS PLOT AS
C DOLLAR, BUT IF THE ABOVE TABLE IS NOT RIGHT THE PRINTING SYMBOL WILL BE
C DIFFERENT.  THIS SHOULD ONLY HAPPEN WITH LESSER USED CHARACTERS, NOT LETTERS,
C DIGITS ETC.
C
C DO NOT OBEY INITIL TWICE IN ONE JOB, UNLESS FORCED TO BY MAIN:
      IF (NINIT .EQ. 42) GO TO 100
C SET THAT INITIL HAS BEEN OBEYED;  THIS RELIES ON NINIT ** NOT **
C BEING SET TO 42 BY ANY OTHER METHOD:
      NINIT=42
C
C SET NOT IN BATCH;  BATCH JOBS MUST "CALL BATCH" ** AFTER ** THEIR
C "CALL INITIL"
C
C SAVE NAME OF CALLING PROGRAM
      MAIN=PROGRM
C
C SET UP CHARACTERS INTO COMMON:
      DO 1 I=1,26
      LETUP(I)=LETTS(I)
   1  LETLOW(I)=LETTS(I+26)
      DO 2 I=1,10
   2  IDIGIT(I)=IDIGI1(I)
      ISPCE=ISPC1
      DO 3 I=1,21
   3  ISMBOL(I)=ISMBO1(I)
C
C SET UP "SINGLE PHASE":
      NPHASE=1
      IPHASE=1
      JPHASE=1
      KPHASE=1
      MULFAS=.FALSE.
      MULONE=.FALSE.
C AND "SINGLE SOURCE":
      NSOURC=1
      JSOURC=1
      KSOURC=1
      MULSOU=.FALSE.
C4.26 Set all refine type logicals to FALSE
      SIMUL=.FALSE.
      MAG=.FALSE.
      MPL=.FALSE.
      CHI=.FALSE.
      TWIN=.FALSE.
C
C
C  SET UP DEFAULTS FOR MACHINE DEPENDENT QUANTITIES:
C SET (FOR RUN TIME) THE SYSTEM FOR WHICH CCSL WAS GENERATED:
      NSYSTM=0
CS VMS      NSYSTM=1
CS UNIX      NSYSTM=2
CS PICKY      NSYSTM=4
C
C NUMBER OF BITS IN AN INTEGER (OR WORD) MINUS AT LEAST 1:
      NBITS=31
C
C DEFAULTS FOR MULTIPHASE, MULTISOURCE - SET NEITHER OF THESE:
      MULFAS=.FALSE.
      MULSOU=.FALSE.
C
C DEAL WITH THE LINE PRINTER OUTPUT FILE, LPT.
C  AND INPUT OUTPUT TABLES FOR USE BY OPNFIL AND NOPFIL:
%      DO 4 I=1,%FILE%
      IOTAB(I)=0
C  CLEAR FILE-NAMES
      FILNAM(I)=' '
    4 LUNTAB(I)=19+I
CS RAL      LUNTAB(3)=40
C
C  SET RESERVED IOUNITS
C
C TELETYPE IN:
      ITI=5
C TELETYPE OUT:
      ITO=6
C PLOTTER, IF NEEDED EVER:
      IPLO=0
C LPT IS SPECIAL BECAUSE WE NEED TO WRITE TO IT HERE AND NOW, WITHOUT
C GIVING THE MAIN PROGRAM A CHANCE TO ALTER ITS VALUE.  OTHER UNITS WILL BE
C CLEARED HERE, BUT MAY BE SET LATER BY MAIN, BEFORE THEY ARE FIRST USED.
C WE NEED TO CATER FOR A PROGRAM WHICH STARTS:
C      LPT=8
C      CALL INITIL(PROGRM)
C FOR RVAX, IF BOTH LPT > 0 AND UNIT LPT OPEN, USE THAT VALUE OF
C LPT, AND DO NOT REOPEN IT.  OTHERWISE, USE LPT=12
      NAMFIL='.LIS'
CS UNIX       CALL UPONE(NAMFIL,3)
      IF (LPT .GT. 0) THEN
CS LAX      INQUIRE(LPT,OPENED=ISOPEN)
CS LAX      IF (.NOT. ISOPEN) CALL OPNFIL(LPT,2142)
CS PICKY      CALL OPNFIL(LPT,3)
      ELSE
      LPT=12
CS ILL      MESSAG=PROGRM
CS ILL      CALL UPONE(MESSAG,3)
CS ILL      CALL OPNFIL(LPT,2132)
CS RAL      CALL OPNFIL(LPT,2142)
CS PICKY      CALL OPNFIL(LPT,2243)
      ENDIF
C
C CLEAR ALL OTHER NAMED UNITS, SO THAT IF THEY ARE SET BY MAIN OR
C BATCH WE WILL NOTICE THIS:
      ICRYDA=-9999
      NEWIN=-9999
      LKH=-9999
      LUNI=-9999
      IDUMPR=-9999
      IDUMPG=-9999
      NDUMPS=-9999
      IOP1=-9999
      IOP2=-9999
C
      STARS='* * * * * * * * * * * *'
      DO 88 I=1,LENGT(MAIN)
      STARS(5+2*I:5+2*I)=MAIN(I:I)
  88  CONTINUE
      WRITE (LPT,2000) STARS
2000  FORMAT (/20X,A23//8X,' Cambridge Crystallography Subroutine',
%     &' Library   Mark %MARK%.%VERS% Update:%UPDT%')
C OBTAIN DATE AND TIME:
CS VMS      CALL DATE(DATIM)
CS VMS      CALL TIME(DATIM(14:)
CS UNIX      CALL FDATE(DATIM)
CS LAX      WRITE (LPT,2001) DATIM
CS LAX 2001 FORMAT (/20X,'Job run on ',A24)
C
C CONSTANTS TO MACHINE ACCURACY:
      PI=4.0*ATAN(1.0)
      RAD=PI/180.
      DEG=180./PI
      TWOPI=2.*PI
      FOURPI=4.*PI
      PIBY2=PI/2.
      ALOG2=ALOG(2.)
      SQL2X8=SQRT(8.*ALOG2)
      VALMUB=0.2695
 100  RETURN
      END
C
C
C
C
C LEVEL 5      SUBROUTINE INOBGR(ISCR)
      SUBROUTINE INOBGR(ISCR)
C
C *** INOBGR by JCM 15 Feb 85 ***
C
CX
CC 7A
CH Performs a preliminary pass of observations for GRLSQ,
CH (group refinement, integrated intensity LSQ).
CA On entry ISCR is the number of a unit set up as a scratch file.
CD Accepts user's input on unit LUNI, collects together groups of h,k,l and
CD counts them, forms multiplicity and D, and sends out this information
CD on unit ISCR ready for repeated reinput to the cycling LSQ.
CD
CD Expects each observation to be preceded by sets of relevant h,k,l.  Reads
CD until an OBS containing a decimal point, then takes remainder of that line
CD to be the observation, allowing various "MODER" formats, as in SFLSQ.
C
      DIMENSION K(3,100),H(3),H1(3)
      DIMENSION CEXT(4)
/IOUNIT/
/REFINE/
/SCRACH/
C
C OPEN UNIT LUNI TO READ USER'S REFLECTION DATA:
      MESSAG='Reflection data'
      CALL OPNFIL(LUNI,11)
C
C OPEN SCRATCH UNIT ON WHICH TO HAND OVER PREPROCESSED REFLECTION DATA:
      ISCR=NOPFIL(1005)
C IP COUNTS SETS OF INDICES FOR THIS ONE OBSERVATION:
   5  IP=0
C IPT MOVES ALONG ONE CARD:
   2  IPT=1
      READ(LUNI,1000,END=100) ICARD
1000  FORMAT (A80)
   6  IPKEEP=IPT
      CALL RDINTG(K(1,IP+1),IPT,IPT,80,IER)
C IS IT CARD END?
      IF (IER .EQ. 100) GO TO 2
C WAS IT ACTUALLY OBS?
      IF (IER .NE. 0) GO TO 4
C
C READ K AND L:
%      CALL ERRCHK(2,IP,100,0,'sets of indices')
      CALL RDINTG(K(2,IP),IPT,IPT,80,IER)
      CALL RDINTG(K(3,IP),IPT,IPT,80,IER)
C NEXT SET OF INDICES:
      GO TO 6
C
   4  IPT=IPKEEP
      ISCALE=0
      ICODE=1
      IF (MODER.EQ.4 .OR. MODER.EQ.6) CALL RDREAL(GCAL,IPT,IPT,80,IER)
      IF (MODER.EQ.6) CALL RDREAL(BCAL,IPT,IPT,80,IER)
      CALL RDREAL(OBS,IPT,IPT,80,IER)
      IF (MODER .NE. 1) CALL RDREAL(DOBS,IPT,IPT,80,IER)
      IF (MODER .NE. 5) GO TO 9
      DO 8 I=1,4
   8  CALL RDREAL(CEXT(I),IPT,IPT,80,IER)
      GO TO 10
   9  CALL RDINTG(ISCALE,IPT,IPT,80,IER)
      CALL RDINTG(ICODE,IPT,IPT,80,IER)
  10  IF (ISCALE .EQ. 0) ISCALE=1
      IF (ICODE .EQ. 0) ICODE=1
      WRITE (ISCR) IP,OBS,DOBS,ISCALE,ICODE
      IF (MODER .EQ. 5) WRITE (ISCR) CEXT
      DO 7 I=1,IP
      CALL INDFLO(H,K(1,I))
C DISCOVER MULTIPLICITY, ALLOWING FOR REFLECTION NOT BEING IN DEFINED UNIT:
      CALL ASUNIT(H,H1,N,M)
      S=VCTMOD(1.,H,2)
      D4=1./(S*S*S*S)
      FMD=FLOAT(M)*D4
   7  WRITE (ISCR) (K(J,I),J=1,3),FMD
C NEXT OBSERVATION - BACK TO RESTART COUNT OF INDICES:
      GO TO 5
C
 100  RETURN
      END
C
C
C
C
C LEVEL 8      SUBROUTINE INPLSF
       SUBROUTINE INPLSF
C
C   **** INPLSF corrected by PJB  C4.23 June 2011 ****
C
CX
CC 6A
CH Reads in (nearly) all L cards for the particular LSQ type 'SF', for
CH single crystal work.
C
CD Is not concerned with L FIX, LRELA, L VARY, L SLAK, L ATOM, L BOND
CD cards, so ignores them.
CD
CD Otherwise, records information off the following L cards:
CD    TFAC   An overall temperature factor
CD    SCAL   Scale factors, one per zone
CD    REFI   Function 'on which to refine'
CD    MODE   Mode of presentation of input reflection data
CD           All MODE dependent code in RREFSF (C134)
CD    WGHT   Weighting scheme.
CD    DATA   Source of data for multi-source refinement
CD           DATA is followed by  <WORD> (up to 4 characters) used as an
CD           identifier then the file-name either as an absolute path or
CD           relative to the current working directory
CD    SORC  <WORD> where <word> appears on an L DATA card, followed
CD           by <word> <number> pairs giving REFI, MODE and WGHT the
CD           refining function, data format, and weight to be given to
CD           this data set.
CD    SORC  <WORD> folowed by either SCAL or DPOP and a list of scale factors
CD           or domain populations for this data set. There may be several
CD           such cards.
C
CI Reads all L cards.
CO Writes its findings to unit LPT.
C
CN For Profile LSQ the equivalent routine is INPLPR.
C
%      DIMENSION MODOB(%DSRC%),ISPEC(3)
%      CHARACTER *4 LWD,LTABLE(%LCRD%),FNAME*100
      LOGICAL LERCHK,THERE
/CARDRC/
/DSOURC/
/DSRCNM/
/IOUNIT/
/LREAD/
/OBSCAL/
/REFINE/
/SCLDAT/
/SCRACH/
/SLAKDA/
/SLKGEO/
/WDSPC/
/WORDS/
      DATA LTABLE/'TFAC','SCAL','REFI','MODE','WGHT','DATA','SORC',
     & 'DPOP',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',
     & ' '/
C
C SET 'NO L CARDS READ':
%      CALL JGMZER(ILREAD,1,%LCRD%)
C
C INTIIALISE JSRC,NUMSRC,IPSCL
      JSRC=0
      NUMSRC=0
%      CALL JGMZER(IPSCAL,%DSRC%,1)
C4.9 set L WGHT not read yet
      IWGHT=0
C INITIALISE COUNTS OF ITEMS WHICH MAY COME ON MORE THAN 1 CARD:
      NSCALE=0
      NSLAK(1)=0
      NUMBON=0
      NSKTOT=0
%        CALL JGMZER(NSLAK,1,%SKTP%)
C
C READ ALL 'L' CARDS:
      INREAD(12)=-IABS(INREAD(12))
      ID=IABS(INREAD(12))
      NCARD=ICDNO(12)
      IF (NCARD .LE. 0) THEN
        CALL MESS(LPT,1,'No "L" cards given')
        GO TO 100
      ENDIF
C
      DO 3 ICD=1,NCARD
      CALL CARDIN(ID)
      ID=ID+NYZ
      CALL RDWORD(LWD,LEN,3,IPT,80,0,IER)
  42  L=NCFIND(LWD,LTABLE,7)
C IGNORE L CARD IF NOT ONE OF THE 7 WE WANT:
      IF (L .LE. 0) GO TO 3
C
      if (L .LE. 6) ILREAD(L)=ILREAD(L)+1
      GO TO (11,12,13,14,15,16,17) , L
C
C L TFAC:
C SHORTLY TO BE ABLE TO READ SEVERAL TFACS
  11  CALL LLTFAC(1)
      GO TO 3
C
C L SCAL - MAY BE SEVERAL:
  12  IF (L.EQ.7)  ICARD(7:) = ICARD(ipt:)
       CALL LLSCAL(1)
      IF (L.EQ.7)  IPSCAL(JSRC)=NSCALE
      GO TO 3
C
C L REFI:
  13  CALL RDINTG(IREF,IPT,IPT,80,IER)
      IF (L.EQ.7) then
        MSRC(2,JSRC)=IREF
        GO TO 50
      ELSE
        CALL REPREF(IREF)
      ENDIF
      GO TO 43
C
C L MODE:
  14  CALL RDINTG(MODER,IPT,IPT,80,IER)
C HUNDREDS SET MEANS DATA ARE FSQR NOT F
      MODEOB(1)=MODER/100
      MODER = MOD(MODER,100)
      IF (L.NE.7) GO TO 43
      MSRC(1,JSRC)=MODER
      MODOB(JSRC)=MODEOB(1)
      GO TO 50
C
C L WGHT:
  15  CALL RDINTG(IWGHT,IPT,IPT,80,IER)
      GO TO (41,40) , IWGHT
C
      WRITE (LPT,3002) IWGHT
      WRITE (ITO,3002) IWGHT
3002  FORMAT (/' ** WARNING * WEIGHTING SCHEME',I4,
     & ' NOT ALLOWED IN SNPLSQ - TYPE 2 SUBSTITUTED')
      IWGHT=2
      GO TO 40
C
  41  CALL MESS(LPT,1,'Unit weights')
      GO TO 43
C
  40  CALL MESS(LPT,1,'Weights to be read with reflection data')
      GO TO 43
C
C4.7 New section to deal with L DATA and LSORC cars
C L DATA: 2char identifier then file-name
  16  CALL RDWORD(LWD,LEN,IPT,IPT,80,-1,IER)
      ITRY=0
   30 CALL RDWORD(FNAME,LEN,IPT,IPT,80,-1,IER)
      IF (IER.EQ.100) THEN
        IF (ITRY .GT.1) GO TO 43
        CALL ASK('Name of file with data '//LWD)
        ITRY=ITRY+1
        IPT=1
        GO TO 30
      ENDIF
      IF (IER.EQ.0) THEN
C Expand if environment variable
        IF (FNAME(1:1).EQ.'$') THEN
          NAMFIL=FNAME
          CALL EXPAND(NAMFIL,FNAME)
        ENDIF
        INQUIRE(FILE=FNAME,EXIST=THERE)
        IF (.NOT. THERE) THEN
          L=LENGT(FNAME)
          CALL ERRMES(1,1,'File '//FNAME(1:L)//' not found')
          GO TO 17
        ENDIF
        JSRC=NCFIND(LWD,IDEN,NUMSRC)
        IF (JSRC.EQ.0) THEN
          IF (.NOT. LERCHK(2,NUMSRC,4,1,'Sources of data')) GO TO 43
         JSRC=NUMSRC
        ENDIF
        IDEN(JSRC)=LWD(1:4)
        DNAME(JSRC)=FNAME
        GO TO 43
      ELSE
        IERR=IERR+1
      ENDIF
      GO TO 43
C
C L SORC: SNAME then,MODE,REFI,SCALE,DPOP OR WGHT
   17 CALL RDWORD(LWD,LEN,IPT,IPT,80,-1,IER)
      JSRC=NCFIND(LWD,IDEN,NUMSRC)
      IF (JSRC.EQ.0) THEN
        IF (.NOT. LERCHK(2,NUMSRC,4,1,'Sources of Data')) GO TO 43
        JSRC=NUMSRC
        IDEN(JSRC)=LWD(1:4)
      ENDIF
   50 CALL RDWORD(LWD,LEN,IPT,IPT,80,0,IER)
      IF (IER.EQ.100) GO TO 3
      LL=NCFIND(LWD,LTABLE(2),7) +1
      if (LL.LE.1) go to 49
C4.23 Don't count as L WGHT if reading SORC card
      if (LL.NE. 5) ILREAD(LL)=ILREAD(LL)+1
      GO TO (12,13,14,51,49,49,52)  LL-1
   49 Call errmes(1,1,'Word '//LWD//' on L DATA card not recognised')
      go to 3
C
C Weight for this data set
   51 CALL RDREAL(SRCWT(JSRC),IPT,IPT,80,IER)
      IERR=IERR+IER
      GO TO 50
C
C List of dpops
   52 CALL LLDPOP(1,ipt)
      GO TO 3
C
C AFTER READING <WORD> <NUMBER> PAIR:
  43  CALL RDWORD(LWD,LEN,IPT,IPT,80,0,IER)
      IF (IER .EQ. 100) GO TO 3
      GO TO 42
   3  CONTINUE
      IF (NUMSRC.EQ.0) GO TO 100
C
C Here when all cards read, leave reading of the data files to MAIN
C set the domain and provisional scale pointers
      CALL LLDPOP(2,0)
      CALL LDSCAL(2,0)
      NUMS=0
      NUMDP=0
C      WRITE (LPT,223) (IPSCAL(I),I=1,NUMSRC)
C  223 FORMAT ('Scale Pointers ',6I5)
C      WRITE (LPT,222) (IPDOM(I),I=1,NUMSRC)
C  222 FORMAT ('Domain Pointers',6I5)
      ISPEC(1)=3
      ISPEC(3)=0
      IP=0
      DO 55 JS=1,NUMSRC
      ISPEC(2)=JS
      CALL VOCAB(IDEN(JS),ISPEC,1)
      JSRC=JS
      IREF=MSRC(2,JS)
      L=LENGT(DNAME(JS))
      WRITE (LPT,3006) JS,IDEN(JS),(DNAME(JS)(I:I),I=1,L)
 3006 FORMAT (/'Data set',I2,' Named ',A4,':To be Read from ',100A1)
      IF (IREF.NE. 8) THEN
        IF (JSRC.EQ.1) THEN
          ISTART=0
        ELSE
          ISTART=IPSCAL(JSRC-1)+1
        ENDIF
        ISTOP=IPSCAL(JSRC)
        WRITE (LPT,3007)  ('SC',I, SCALE(I),I=ISTART,ISTOP)
 3007   FORMAT (' Scale Factors:     ',4(2X,A2,I2.2,F8.3)/
     & (20X,4(2X,A2,I2.2,F8.3)) )
      ENDIF
      NUMD=IPDOM(JS)-NUMDP
      CALL NDPOPS(IREF,NEED,MISS)
      IF (NUMD .EQ. 0 .AND. NEED .EQ.1) GO TO 55
      IF (NEED.NE.NUMD) CALL ERRIN2(NEED,1,
     &'Not  the rignt number of DPOPS given for '
     &//DNAME(JSRC),' needed')
C4.16 IP replaced by NUMDP  for correct counting
      WRITE (LPT,3008) ('DP',MISS*(I-1)+1,DPOP(I+NUMDP),
     &I=1,NUMD)
 3008 FORMAT (' Domain Populations:',4(2x,A2,i2.2,F6.3)/
     &(20x,2x,A2,i2.2,F6.3,2x,A2,i2.2,F6.3,2x,A2,i2.2,F6.3,
     &2x,A2,i2.2,F6.3))
      NUMDP=IPDOM(JS)
   55 CONTINUE
C
 100  RETURN
      END
C
C
C
C LEVEL 4      SUBROUTINE INPSYM(IPAR,MAXP,OK)
      SUBROUTINE INPSYM(IPAR,MAXP,OK)
C
C *** INPSYM separated from STATPA by PJB August 2016 ***
CH reads and interprets a Q PSYM card giving the averaging scheme for
CH SNP data
C
CD The data on the card should be either 1 or 18 integers
CD If only 1 number is read it is IOPT defining the expected symmetry of the
CD polarisation matrix
CD IOPT=0 No averaging, all matrix elements independent,
CD IOPT positive (must be less than 5
CD    IOPT=1 Simple magnetic only XX=-XX=-1,
CD                                YY=-(-YY)=-(ZZ)=-ZZ
CD                                YZ=ZY=-(-YZ)=-(-ZY)
CD                                XY=YX=XZ=ZX=-(-XY)=-(-YX)=-(-XZ)=-(-ZX)=0
CD
CD    IOPT=2 Chiral magnetic only XX=-XX=-1;
CD                                XY=XZ=-XY=-XZ=0;
CD                                YX=-YX;  ZX=-ZX;
CD                                YY=-(-YY)=-(ZZ)=-ZZ;
CD                                YZ=ZY=-(-YZ)=-(-ZY)
CD
CD  IOPT=3 Magnetic in quadrature XX=-XX;
CD         with nuclear           XY=-YX=-(-XY)=(-YX);
CD                                XZ=-ZX=-(-XZ)=(-ZX);
CD                                YY=-(-YY); -(ZZ)=-ZZ;
CD                                YZ=ZY=-(-YZ)=-(-ZY)
CD
CD  IOPT=4 Magnetic in phase      XX=-XX;
CD         with nuclear           YX=-ZX=-YX=-YX=0;
CD                                XY=-XY;
CD                                XZ=-XZ;
CD                                YY,YZ,ZY,ZZ,-YY,-YZ,-ZY,-ZZ independent
CD                                YZ=ZY=-(-YZ)=-(-ZY)
CD If 18 integer are read these define the averaging mode. Read directly into KAV(18)
CD  For each independent component I of the polarisation matrix
CD  KAV(J)=+/-KAV(I)=+/-I with I and J =3*(In-1)+Out (In/Out=1,2,3 for X,Y,Z)
CD for all elements J related to I.
CP On exit OK isset .TRUE if the symmetry was set successfully
CP         MAXP is the number of independent components
CP         IPAR(18) holds the parameter number associated with each component,
CP                  negative if the sign should be reversed.
      LOGICAL OK
      DIMENSION A(18),kav(18),IPAR(*),MODEAV(18,4)
      CHARACTER *1 AXIS(3)
/IOUNIT/
/SCRACH/
C IPAR(18)   GIVES THE PARAMETER NUMBER FOR EACH ELEMENT
      DATA MODEAV/ 1, 0, 0, 0, 5, 6, 0, 6,-5,-1, 0, 0, 0,-5,-6, 0,-6,5,
     &             1, 0, 0, 4, 5, 6, 4, 6,-5,-1, 0, 0, 4,-5,-6, 4,-6,5,
     &             1,2, 3,-2, 5, 6,-3, 6, 9,-1,-2,-3, 2,-5,-6, 3, -6,-9,
     &             1,2, 3, 0, 5, 6, 0, 8, 9,-1, 11,12,0,14,15,0,17,18/
      DATA AXIS/'X','Y','Z'/
C


C READ AND INTERPRET PSYM CARD
      OK=.FALSE.
      CALL FINDCD('Q','PSYM',4,0,IP)
      iF (IP.LE.0) THEN
        CALL ERRMES(1,2,
     &'Q PSYM card giving the symmetry of the polarisation matrices')
        GO TO 100
      ENDIF
      CALL RDNUMS(A,7,18,NUM,IER)
      IF (NUM.EQ.1)THEN
        IOPT=NINT(A(1))
        IF ( IOPT .LT.0 .OR. IOPT .GT.4) THEN
          CALL ERRMES(1,1,
     &'on Q PSYM card the symmetry type must be betweeen 0 and 4'//
     & '(else 18 numbers)')
          GO TO 100
        ELSE IF (IOPT.EQ.0) THEN
          WRITE (LPT,1002)
 1002     FORMAT ('No symmetry assumed between matrix elements')
        ELSE
          CALL JGMEQ(MODEAV(1,iopt),KAV,18,1)
          WRITE (LPT,1001) IOPT,KAV
 1001     FORMAT ('Symmetry used in  averaging matrix elements type'
     &     ,i2,':'//18I4)
        ENDIF
      ELSE IF (NUM.EQ.18) THEN
        IOPT=-1
        DO 21 I=1,18
        KAV(I)=NINT(A(I))
        IF (IABS(KAV(I)).GT.18) THEN
          CALL ERRIN2(I,2,'At number',' on PSYM card.')
          GO TO 100
        ENDIF
   21   CONTINUE
        WRITE (LPT,1003) KAV
 1003   FORMAT ('Symmetry used in  averaging matrix elements - ',
     &  'User Defined:'/18I4)
      ELSE
        CALL ERRMES(1,1,
     &  'on Q PSYM card it should give 1 or 18 numbers')
        GO TO 100
      ENDIF
C FIND THE SET OF INDEPENDENT ELEMENTS
      CALL JGMZER(IPAR,18,1)
      MAXP=0
      DO 2 IJ=1,18
      IF (IOPT.EQ.0)  KAV(IJ)=IJ
      IF (KAV(IJ).NE.0) THEN
      	N=IABS(KAV(IJ))
      	J=NFIND(N,KAV,IJ-1)
      	IF (J.EQ.0) THEN
      	  MAXP=MAXP+1
      	  IPAR(IJ)=ISIGN(MAXP,KAV(IJ))
        ELSE
          IPAR(IJ)=ISIGN(IPAR(J),KAV(IJ))
        ENDIF
      ENDIF
C       WRITE (LPT,5001)IJ, N,J,MAXP,IPAR(J)
C        WRITE (LPT,5000) MAXP,(IPAR(I),I=1,18)
C 5000 FORMAT ('IPARS',I1,1X,18I4)
    2 CONTINUE
      OK=.TRUE.
  100 RETURN
      END


C
C
C
C
C LEVEL 3      FUNCTION INPUAR(M,LUN)
      FUNCTION INPUAR(M,LUN)
C
C *** INPUAR updated by PJB October 2008 C4.12 Skip header ***  ***
C
CX
CC 2C
CH Reads the data from files made by ARRNGE and other similar programs.
CA On entry M is 1 or 2 indicating the unit from which to read
CA          LUN is a 1x2 integer array holding the logical unit numbers
CA              of two data streams
CA On exit INPUAR indicates whether end of either file has been reached
CD The call reads one set of equivalent reflections into the COMMON /REFS/
CD from the file on UNIT number LUN(M)
C
      DIMENSION LUN(2)
/REFS/
/SCRACH/
      COMMON/VARFOR/RLINE1,RLINE2
      CHARACTER*20 RLINE2
      CHARACTER*16 RLINE1
C
      IEND=0
      IF (M.EQ.0) THEN
      MS=1
      ME=2
      ELSE
      MS=M
      ME=M
      ENDIF
      DO 1 IS=MS,ME
C COUNT HKLS WHICH FORM A RELATED GROUP:
      NR=1
      II=0
C
C4.12 Skip the header lines, they have been read by ARRHED
    2 READ (LUN(IS),10,END=4) MESSAG
   10 FORMAT (A100)
      IF (MESSAG(1:1).EQ.'#') GO TO 2
C READ IN EITHER 'I5' (F5.0) OR F8.3:
      READ (MESSAG,RLINE1)(R(II+I,IS),I=1,3),JJ(NR,IS),L
      LL(NR,IS)=L
C IF ONLY 3 READ, THESE ARE THE DEFINITIVE INDICES FOR THE GROUP:
      IF (L.EQ.3) GO TO 3
C IF > 3, PAIRS OF X, DX FOR THIS PARTICULAR H,K,L:
      J=4
   42 READ (LUN(IS),RLINE2)(R(II+I,IS),I=J,J+ITEMS-1)
      J=J+ITEMS
      IF (J.LT.L) GO TO 42
C
C IF MERGING, SCALE - IF COMPARING, SCALE() SET TO 1.0
      DO 6 I=4,L,ITEMS
      R(II+I,IS)=SCALE(IS)*R(II+I,IS)
    6 R(II+I+1,IS)=SCALE(IS)*R(II+I+1,IS)
C
C  LEAVE ROOM FOR STORAGE OF MEANS
      II=II+L+2
      NR=NR+1
      GO TO 2
C
C END OF A GROUP OF EQUIVALENTS - COPY DEFINITIVE HKL BOTH FIXED & FLOATING
    3 CALL INDFIX(R(II+1,IS),K(1,IS))
      CALL GMEQ(R(II+1,IS),FF(1,IS),1,3)
      GO TO 1
C
C END OF DATA ON EITHER STREAM:
    4 IEND=IEND+IS
C
    1 CONTINUE
      INPUAR=IEND
      RETURN
      END
C
C
C
C
C LEVEL 4      SUBROUTINE INPUTA(ID,LABA,LBALEN,LABS,LBSLEN,X,T,S,IER)
      SUBROUTINE INPUTA(ID,LABA,LBALEN,LABS,LBSLEN,X,T,S,IER)
C
C *** INPUTA updated by JCM 26 Sep 89 ***
C
CX
CC 4A
CH Reads an A card and prepares it for further processing.
CA On entry ID points to the card on unit IO10.  If ID=0 it is assumed
CA             that the card is already in ICARD in /SCRACH
CA On exit LABA is the A4 label of the atom, starting with a letter
CA         LBALEN is the number of characters in LABA
CA         LABS is the A4 label of the scattering factor expected
CA         LBSLEN is the number of characters in LABS
CA         X(1:3) holds EITHER the x,y,z fractional coordinates of the atom
CA                      OR (if the card starts "C SD") their standard
CA                          deviations.
CA         T similarly holds EITHER the isotropic temperature factor
CA                           OR (if the card starts "C SD") its esd
CA         S similarly holds EITHER the site occupation factor
CA                           OR (if the card starts "C SD") its esd
CA         IER=number of errors detected
CD Items must occur in the sequence "C" optional "SD" <label>
CD x,y,z itf, optional DIFFERENT scattering factor label, optional site
CD occupation factor.
CD If the site is left blank, S=1. is assumed.
C
      CHARACTER *4 LABA,LABS
      DIMENSION X(3)
/CARDRC/
/SCRACH/
C
      IER=0
C IF ID=0 ON ENTRY, CARD EXPECTED ALREADY IN /SCRACH/; OTHERWISE READ IT:
      IF (ID .NE. 0) CALL CARDIN(ID)
      SDREAD=(ICARD(3:5) .EQ. 'SD ')
C IPT MOVES ALONG CARD AS ITEMS TAKEN FROM IT:
      IPT=3
      IF (SDREAD) IPT=6
      CALL RDWORD(LABA,LBALEN,IPT,IPT,80,0,IE)
C**I THINK THIS IS BELT AND BRACES . .
      IF (IE .NE. 0) GO TO 8
      IF (LETTER(LABA(1:1)) .NE. 0) GO TO 1
   8  CALL ERRCH2(LABA,-2,' ',
     & 'as an atom label does not start with a letter')
      IER=IER+1
C
   1  DO 2 I=1,3
      IPKEEP=IPT
      CALL RDREAL(X(I),IPT,IPT,80,IE)
      IF ((IE .NE. 0) .AND. (IE .NE. 100)) THEN
        CALL ERRCH2(ICARD(IPKEEP:IPT-1),-2,'in coordinate',
     &   'on A card')
        IER=IER+1
      ENDIF
   2  CONTINUE
      CALL RDREAL (T,IPT,IPT,80,IE)
      IF ((IE .NE. 0) .AND. (IE .NE. 100)) THEN
        CALL ERRCH2(ICARD(IPKEEP:IPT-1),-2,'in isotropic t f',
     &   'on A card')
        IER=IER+1
      ENDIF
      IPKEEP=IPT
C SET EXPLICIT SITE=0. SO THAT WE KNOW IF WE HAVE READ ONE:
      S=0.
C
C NOW LOOK FOR SCATTERING FACTOR LABEL AND/OR SITE OCCUPATION FACTOR:
      CALL RDWORD(LABS,LBSLEN,IPT,IPT,80,0,IE)
C IF NOTHING MORE ON CARD, GO TO SET S=1 AND DEDUCE SCAT LABEL:
      IF (IE .EQ. 100) GO TO 3
C IF SOMETHING ON CARD, BUT NOT A LABEL, REREAD IT AS SITE:
      IF (IE .NE. 0) IPT=IPKEEP
      CALL RDREAL(S,IPT,IPT,80,IE)
      IF ((IE .NE. 0) .AND. (IE .NE. 100)) THEN
        CALL ERRCH2(ICARD(IPKEEP:IPT-1),-2,'in site occ factor',
     &   'on A card')
        IER=IER+1
      ENDIF
C
C A SITE OF ZERO, OR ABSENT, INDICATES 1:
C C106 Fix to read in zero esd if nothing found for site.
   3  IF (S .EQ. 0.) THEN
        IF (SDREAD)       S=0.
        IF (.NOT. SDREAD) S=1.0
      ENDIF
C
C IF SCAT LABEL READ, FINISH:
      IF (LBSLEN .GT. 0) GO TO 100
C NO EXPLICIT LABEL, SO MUST TAKE FIRST LETTERS OF ATOM LABEL:
      L=0
   6  L=L+1
      IF (L .GT. LBALEN) GO TO 7
      IF (LETTER(LABA(L:L)) .EQ. 0) GO TO 7
      LABS(L:L)=LABA(L:L)
      GO TO 6
C
C IF SCAT LABEL TAKEN AS FIRST LETTERS OF ATOM LABEL, SHOW BY -VE LENGTH:
   7  LBSLEN=1-L
C
 100  RETURN
      END
C
C
C
C
C LEVEL 4      SUBROUTINE INPUTC(ID,CELL)
      SUBROUTINE INPUTC(ID,CELL)
C
C *** INPUTC updated by PJB  26-Aug-1998 ***
C
CX
CC 1A
CH Reads one "C" card.
CA On entry ID points to the card on file IO10
CA On exit if there is no "SD" following the "C " CELL(1:6) holds
CA a,b,c, alpha degrees, beta degrees, gamma degrees.
CA If "SD" is present CELL is not filled in and the data on the card
CA remain in ICARD for further processing by RECISD
C
      DIMENSION CELL(6)
/CARDRC/
/SCRACH/
C
      CALL CARDIN(ID)
      IPT=3
      SDREAD=(ICARD(3:4) .EQ. 'SD')
      IF (SDREAD) go to 100
      CALL GMZER(CELL,1,6)
      DO 1 J=1,6
      IPKEEP=IPT
      CALL RDREAL(CELL(J),IPT,IPT,80,IER)
      IF (IER .EQ. 100) GO TO 100
      IF (IER .EQ. 0) GO TO 1
      CALL ERRCH2(ICARD(IPKEEP:IPT-1),-2,'in cell parameter',
     & 'on "C" card')
   1  CONTINUE
 100  RETURN
      END
C
C
C
C
C LEVEL 5      SUBROUTINE INPUTD
      SUBROUTINE INPUTD
C
C *** INPUTD updated by PJB C4.19 March 2010 ***
C
C4.23 Prefer UB from data header when present to that on D cards
C
CX
CC 2A
CH Reads and interprets all D cards, for general diffraction information.
C
CD Absorbs all the D cards given.  It will normally be called by a
CD setting up routine (e.g. SETDC) which then checks whether it has had
CD enough D cards to make sense, and gives default values for those missing.
CD
CD The syntax of D cards is thus like that of M, G, L cards;  a word of up
CD to 4 symbols (usually letters, and the first must be a letter) follows the
CD "D space" which starts the card, and what follows after that depends on
CD the word.  Possible words recognised are:
C
CD D GEOM followed by an integer, IGEOM.
CD   Possible values for IGEOM are:
CD     1 = normal beam
CD     2 = normal beam equatorial
CD     3 = equi-inclination Weissenberg
CD     4 = precession (no further code for this)
CD     5 = anti equi-inclination Weissenberg
CD     6 = 4 circle diffractometer, bisecting geometry
CD     7 = 4 circle diffractometer, angles given
CD     8 = normal beam, general orientation
CD    10 = powder data, X-rays
CD    11 = 4 circle diffractometer, high chi geometry
CD    12 = SXD geometry
CD
CD D WVLN followed by the wavelength, in same units as the lattice constants
CD        (possibly several wavelength values)
CD
CD D L/R  followed by an integer, the 'left or right' indicator:
CD        +ve means incident beam diffracted to the right,
CD        -ve means to the left. Value 1 means  that angles are
CD        measured clockwise about positive diffractometer axes, and 2
CD        means anti-clockwise.
CD
CD D TH2M followed by the value of 2theta monochromator, in degrees.
CD
CD D UMAT followed by 9 numbers, giving the UB matrix (as defined in the
CD        Manual under D cards).  If all 9 do not fit one card,
CD        several cards may be given;  for example, on 3 cards each with
CD        3 numbers.
CD
CD D UMBL followed by 9 numbers, giving the UB matrix (as defined by
CD        Busing and Levy).  If all 9 do not fit one card,
CD        several cards may be given;  for example, on 3 cards each with
CD        3 numbers.
CD
CD D ANGP followed by the precession angle in degrees.
CD
CD D ROTA for types 1-5, followed by 3 indices, being the zone-axis symbols
CD        of the zone parallel to the rotation axis.
CD
CD D CHIA for type 2 only, followed by 3 integers and a real;  the integers
CD        give another axis, perpendicular to that on the "D ROTA" card, and
CD        the real is the angle between this and the normal to the chi circle,
CD        in degrees.
CD Optional D LAM2 followed by the \$\lambda/2\$ contamination as the fraction
CD          \$I(\lambda)/I(\lambda\over2)\$
C
CI Reads all D cards
C
CO Writes its findings to unit LPT
C
      CHARACTER *27 X27
%      CHARACTER *4 DTABLE(%DCRD%),DWD
      DIMENSION ITEMP(9),UMAT(9),ULMAT(9)
      LOGICAL SAYS
/CARDRC/
/DGEOM/
/DREAD/
/IOUNIT/
/SCRACH/
      DATA DTABLE/'GEOM','WVLN','L/R','TH2M','UMAT','ANGP',
     & 'ROTA','CHIA','LAM2','UMBL'/
      DATA X27/'                           '/
C
C SET "NO D CARDS READ":
%      CALL JGMZER(IDREAD,1,%DCRD%)
C
C CLEAR COUNT OF UB MATRIX ELEMENTS READ:
      NMAT=0
      LMAT=0
C Set no lambda/2
      ALAM2=0.
C
C READ ALL D CARDS:
      INREAD(4)=-IABS(INREAD(4))
      ID=IABS(INREAD(4))
      NCARD=ICDNO(4)
      IF (NCARD .LE. 0) THEN
        CALL MESS(LPT,1,'No D cards given')
        GO TO 100
      ENDIF
C
      DO 3 ICD=1,NCARD
C
C UNLIKE MK2, MK3 READS ITS D CARDS IN SEQUENCE AND DECIDES WHAT TO DO THEN
C ON THE EVIDENCE OF WHICH 4 LETTER WORD FOLLOWS THE D.
C
      CALL CARDIN(ID)
      ID=ID+NYZ
      CALL RDWORD(DWD,LEN,3,IPT,80,0,IER)
%  42  L=NCFIND(DWD,DTABLE,%DCRD%)
      IF (L .LE. 0) THEN
        CALL ERRCH2(DWD,2,'word','on D card not recognised')
        GO TO 3
      ENDIF
C
C SET "HAVE READ PARTICULAR WORD" (COUNTING NUMBER OF CARDS), THEN BRANCH:
      IDREAD(L)=IDREAD(L)+1
C4.12 Ignore D cards not needed; values already read from data header
C4.19 But check wavelength since it may influence other parameters
      IF (L.NE. 2 .AND. .NOT. DNEEDS(L)) GO TO 3
      GO TO (31,32,33,34,35,36,37,38,39,40) , L
C
C D GEOM:
  31  CALL RDINTG(IGEOM,IPT,IPT,80,IER)
      IF (IGEOM .GT. 0 .AND. IGEOM .LT. 12) GO TO 8
      CALL ERRIN2(IGEOM,2,'data type','not allowed')
      GO TO 3
C
   8  WRITE (LPT,2020) IGEOM
      DNEEDS(1)=.FALSE.
2020  FORMAT (/' Data geometry type',I5,' -')
      GO TO (11,12,13,14,15,16,17,18,19,20,21), IGEOM
  11  CALL MESS(LPT,0,X27//'normal beam')
      GO TO 43
  12  CALL MESS(LPT,0,X27//'normal beam equatorial')
      GO TO 43
  13  CALL MESS(LPT,0,X27//'equi-inclination Weissenberg')
      GO TO 43
  14  CALL MESS(LPT,0,X27//'precession camera')
      GO TO 43
  15  CALL MESS(LPT,0,X27//'anti-equinclination Weissenberg')
      GO TO 43
  16  CALL MESS(LPT,0,X27//'4 circle diffractometer bisecting geometry')
      GO TO 43
   17 CALL MESS(LPT,0,X27//'4 circle diffractometer angles to be given')
      GO TO 43
  18  CALL MESS(LPT,0,X27//'D3 polarised neutron diffractometer')
      GO TO 43
  19  CALL MESS(LPT,0,X27//'powder data - neutrons')
      GO TO 43
  20  CALL MESS(LPT,0,X27//'powder data - X rays')
      GO TO 43
   21 CALL MESS(LPT,0,X27//'4-circle diffractometer: high chi setting')
      GO TO 43
C
C WVLN:
  32  IF (.NOT. DNEEDS(2)) HDRWAV=WLGTH
      CALL RDREAL(WLGTH,IPT,IPT,IPT+10,IER)
      IF (IER .NE . 0) GO TO 53
      NLAMB=1
      L=LENGT(ICARD)
      DO 54 I=IPT,L
      IF (ICARD(I:I).EQ.' ') GO TO 54
C Expecting either LAM2 or another number
        IF (LETTER(ICARD(I:I)).EQ.12) THEN
          CALL RDWORD(DWD,L,I,IPT,I+4,0,IER)
          IF (DWD.NE.'LAM2') GO TO 53
        ELSE
%          CALL RDNUMS(ALAMBD(2,1),IPT,%LAMB%-1,NLAMB,IER)
          IF (IER .NE . 0) GO TO 53
          NLAMB=NLAMB+1
        ENDIF
        GO TO 52
  54    CONTINUE
C
  52  IF (NLAMB .GT. 1) WRITE (LPT,2011) (ALAMBD(I,1),I=1,NLAMB)
2011  FORMAT (/' Wavelength values',5F12.5)
      IF (.NOT. DNEEDS(2).AND. ABS(WLGTH-HDRWAV) .GT. 0.001)  THEN
        WRITE (LPT,1001) WLGTH,HDRWAV
        WRITE (ITO,1001) WLGTH,HDRWAV
 1001 format ('Wavelength ',f6.3,' from DCARDS doesn''t match '
     &,f6.3,' from data header')
        CALL ASK('Check polarisation and lambda/2, OK Y/N (def N)')
        IF (.NOT. SAYS('Y')) STOP 'for correction of D cards'
        WLGTH=HDRWAV
      ENDIF
      IF (NLAMB .EQ. 1) WRITE (LPT,2012) WLGTH
2012  FORMAT (/' Wavelength =',F12.5)
      DNEEDS(2)=.FALSE.
      IF (DWD.EQ.'LAM2') GO TO 39
      GO TO 3

   53 CALL ERRMES(1,1,' reading D WVLN card')
      GO TO 3

C
C L/R:
  33  CALL RDINTG(NLR,IPT,IPT,80,IER)
      IF (IABS(NLR) .LE. 2) GO TO 51
      CALL ERRIN2(NLR,2,'left/right indicator is',
     & 'and should be +/-1 or +/-2')
      GO TO 43
C
  51  IF (NLR .GT. 0) CALL MESS(LPT,1,'Beam diffracted to right')
      IF (NLR .LT. 0) CALL MESS(LPT,1,'Beam diffracted to left')
      IF (IABS(NLR).GT.1) THEN
        CALL MESS(LPT,0,X27//'positive angles correspond to'//
     &  ' anti-clockwise rotations')
      ELSE
        CALL MESS(LPT,0,X27//'positive angles correspond to'//
     &  ' clockwise rotations')
      ENDIF
      DNEEDS(3)=.FALSE.
      GO TO 43
C
C TH2M:
  34  CALL RDREAL(ANGLIN(2),IPT,IPT,80,IER)
      WRITE (LPT,2041) ANGLIN(2)
2041  FORMAT(' Monochromator 2theta = ',F10.4,' degrees')
      ANGLIN(2)=COS(RADIAN(ANGLIN(2)))
      DNEEDS(4)=.FALSE.
      GO TO 43
C
C UMAT:
  35  CALL RDNUMS(UMAT(NMAT+1),IPT,9,NM,IER)
      NMAT=NMAT+NM
C CANNOT CHECK TILL ALL THERE
      GO TO 3
C
C UMBL:
  40  CALL RDNUMS(ULMAT(LMAT+1),IPT,9,NM,IER)
      LMAT=LMAT+NM
C CANNOT CHECK TILL ALL THERE
      GO TO 3
C
C ANGP:
  36  CALL RDREAL(ANGLIN(1),IPT,IPT,80,IER)
      WRITE (LPT,2061) ANGLIN(1)
2061  FORMAT(' Precession angle = ',F10.4,' degrees')
C FOR NOW WE DO NO MORE WITH PRECESSSION
      DNEEDS(6)=.FALSE.
      GO TO 43
C
C ROTA:
  37  CALL RDNUMS(UM,IPT,3,N,IER)
      CALL INDFIX(UM,ITEMP)
      WRITE (LPT,2071) (ITEMP(I),I=1,3)
2071  FORMAT (/' Zone axis parallel to rotation axis is',3I5)
      GO TO 3
C
C CHIA:
  38  CALL RDNUMS(UM(4),IPT,4,N,IER)
      CALL INDFIX(UM(4),ITEMP)
      WRITE (LPT,2081) (ITEMP(I),I=1,3),ANGLIN(1)
2081  FORMAT (/' Axis',3I5,' makes angle',F10.4,' with chi circle')
C
C KEEP ANGLE IN RADIANS:
      ANGLIN(1)=RADIAN(UM(7))
      DNEEDS(7)=.FALSE.
      GO TO 3
C
C Lambda/2 contamination
  39  CALL RDREAL(ALAM2,IPT,IPT,80,IER)
      WRITE (LPT,2091) ALAM2
2091  FORMAT(' Half wavelength contamination = ',F10.4)
      DNEEDS(8)=.FALSE.
      GO TO 43
C
C
C HERE WHEN ONE ITEM OF THE <WORD> <NUMBER> TYPE READ - LOOK FOR OTHERS:
  43  CALL RDWORD(DWD,LEN,IPT,IPT,80,0,IER)
      IF (IER .EQ. 0) GO TO 42
      IF (IER .NE. 100) CALL ERRIN2(IPT,2,'word expected at point',
     & 'on D card')
   3  CONTINUE
C
C ALL D CARDS READ:
C4.23
      IF (NMAT .NE. 0 .AND. DNEEDS(5)) THEN
C CHECK IF ANY UB MATRIX ELEMENTS AT ALL, HAVE HAD 9:
        IF (NMAT .NE. 9) THEN
          CALL ERRIN2(NMAT,2,'only','elements of CCSL UB matrix read')
        ELSE
          CALL GMEQ(UMAT,UM,3,3)
          WRITE (LPT,2051) UM
2051      FORMAT (/' CCSL UB Matrix: ',3F10.5/2(17X,3F10.5/))
        ENDIF
          DNEEDS(5)=.FALSE.

      ELSE
C4.23
        IF (LMAT .NE.0 .AND. DNEEDS(5)) THEN
C CHECK IF ANY UB MATRIX ELEMENTS AT ALL, HAVE HAD 9:
          IF (LMAT .NE. 9) THEN
            CALL ERRIN2(NMAT,2,'only',
     &      'elements of Busing Levy UB matrix read')
          ELSE
            WRITE (LPT,2052) ULMAT
2052      FORMAT (/' Busing Levy UB Matrix: ',3F10.5/2(24X,3F10.5/))
C Convert to CCSL form
            UM(1)=ULMAT(4)
            UM(2)=-ULMAT(1)
            UM(3)=ULMAT(7)
            UM(4)=ULMAT(5)
            UM(5)=-ULMAT(2)
            UM(6)=ULMAT(8)
            UM(7)=ULMAT(6)
            UM(8)=-ULMAT(3)
            UM(9)=ULMAT(9)
            WRITE (LPT,2051) UM
            DNEEDS(10)=.FALSE.
          ENDIF
        ENDIF
      ENDIF
C
 100  RETURN
      END
C
C
C
C
C LEVEL 5      SUBROUTINE INPUTE
      SUBROUTINE INPUTE
C
C *** INPUTE updated by JCM 29 Aug 91 ***
C
CX
CC 2A
CH Reads and interprets an E card, and sets up extinction calculations.
CD The card gives IEXTYP, an integer giving the extinction model to be used:
CD     IEXTYP = 1 Becker and Coppens Lorentzian model, 1 DOMR
CD     IEXTYP = 2 Becker and Coppens Gaussian model, 1 DOMR
CD     IEXTYP = 3 Becker and Coppens Lorentzian model, 3 DOMRs, FOVLP
CD     IEXTYP = 4 Becker and Coppens Gaussian model, 1 DOMRs, FOVLP
CD Sets LOGICALs LOREN and GAUSS.
CD After IEXTYP come the parameters of the model.  In the present options
CD 1,2 these are DOMR ("r" in the theory) and MOSC ("g" in the theory), the
CD domain radius and mosaic spread parameters.
CD For options 3,4 reads 3 values for DOMR, then MOSC and FOVLP, in the case
CD where coherence between nuclear and magnetic scattering must be taken
CD into account.
CI Reads an E card.
CO Writes its findings on unit LPT.
C
      DIMENSION A(5)
C
/CARDRC/
/EXTN/
/EXTRAE/
/IOUNIT/
C
      INREAD(5) = -IABS(INREAD(5))
      GO TO (1,2) , ICDNO(5)+1
      CALL ERRMES(1,0,'only one E card allowed')
C
   1  IEXTYP=0
      GO TO 10
C
   2  CALL GMZER(DOMRI,3,1)
      CALL CARDIN(IABS(INREAD(5)))
      CALL RDINTG(IEXTYP,2,IPT,80,IER)
  10  LOREN=(IEXTYP.EQ.1 .OR. IEXTYP .EQ.3)
      GAUSS=(IEXTYP.EQ.2 .OR. IEXTYP .EQ.4)
      IF (IEXTYP .EQ. 0) THEN
        CALL MESS(LPT,1,'No extinction correction')
        GO TO 100
      ELSE IF (IEXTYP .EQ. 1 .OR. IEXTYP .EQ. 2) THEN
        CALL RDREAL(DOMR,IPT,IPT,80,IER)
        CALL RDREAL(AMOSC,IPT,IPT,80,IER)
      ELSE IF (IEXTYP .EQ. 3 .OR. IEXTYP .EQ. 4) THEN
        CALL RDNUMS(A,IPT,5,NUM,IER)
        IF (NUM .NE. 5) THEN
          CALL ERRIN2(NUM,1,'Too few numbers on E card - 5 needed',
     &     'were read')
          GO TO 100
        ELSE
          CALL GMEQ(A,DOMRI,3,1)
** IN CASE YOU WERE RELYING ON IT:
          DOMR=DOMRI(1)
          AMOSC=A(4)
          FOVLP=A(5)
        ENDIF
C
      ELSE
        CALL ERRIN2(IEXTYP,-2,'extinction type',
     &   'not defined - assuming no extinction')
        IEXTYP = 0
        GO TO 100
      ENDIF
C
      IF (LOREN) WRITE (LPT,2002) IEXTYP
2002  FORMAT (/' Extinction type is',I3,' Becker and Coppens',
     & ' Lorentzian model')
      IF (GAUSS)  WRITE (LPT,2003) IEXTYP
2003  FORMAT (/' Extinction type is',I3,' Becker and Coppens',
     & ' Gaussian model')
      IF (IEXTYP .LE. 2) WRITE (LPT,2004) DOMR,AMOSC
2004  FORMAT ('  Domain radius =',F10.4,'  Mosaic spread =',F10.4)
      IF (IEXTYP .EQ. 3 .OR. IEXTYP .EQ. 4) WRITE (LPT,2005) A
2005  FORMAT (' Domain radii:',3F10.4,' Mosaic spread:',F10.4,
     &  ' Coherent overlap fraction:',F10.4)
C
 100  RETURN
      END
C
C
C
C
C LEVEL 4      SUBROUTINE INPUTF(ID,LABF,LBFLEN,NTYP,IPT,IER)
      SUBROUTINE INPUTF(ID,LABF,LBFLEN,NTYP,IPT,IER)
C
C *** INPUTF by JCM 1 Mar 84 ***
C
CX
CC 4A
CH Reads and partially interprets an "F" card.
CA On entry ID points in the binary copy of the Crystal Data File to the
CA required "F" card, or iz 0, indicating that the card must be read here.
CA On exit:
CA    LABF, A4,  contains a scattering factor label
CA    LBFLEN is the number of actual characters in LABF
CA    NTYP is an integer giving the type of factor expected
CA    IPT points in the card in /SCRACH/ to the next data item
CA    IER is an error indicator, =0 if no errors.
C
      CHARACTER *4 LABF
/SCRACH/
C
      IER=0
      IF (ID .NE. 0) CALL CARDIN(ID)
C IPT MOVES ALONG CARD AS ITEMS TAKEN FROM IT:
      CALL RDWORD(LABF,LBFLEN,3,IPT,80,0,IE)
      IF (IE .NE. 0) GO TO 8
      IF (LETTER(LABF(1:1)) .NE. 0) GO TO 1
   8  CALL ERRCH2(ICARD(3:6),-2,' ',
     & 'read from "F" card where label expected')
      IER=IER+1
C
   1  IPKEEP=IPT
      CALL RDINTG(NTYP,IPT,IPT,80,IE)
      IF ((IE .NE. 0) .AND. (IE .NE. 100)) THEN
        IER=IER+1
        CALL ERRCH2(ICARD(IPKEEP:IPT-1),-2,'in form factor type',
     &   'on "F" card')
      ENDIF
      RETURN
      END
C
C
C
C
C LEVEL 4      SUBROUTINE INPUTG
      SUBROUTINE INPUTG
C
C *** INPUTG updated by JCM 14 Oct 86 ***
C
CX
CC 2A
CH Reads and interprets all "G" cards, for Gaussian integration of various
CH integrals over a crystal defined by its plane faces.
C
CD Absorbs all the "G" cards given.  It will normally be called by a
CD setting up routine (e.g. SETABS) which then checks whether it has had
CD enough "G" cards to make sense, and gives default values for any missing.
CD
CD The syntax of "G" cards is thus like that of M, D, L cards; a word of up to
CD 4 symbols (usually letters, and the first must be a letter) follows the
CD "G space" which starts the card, and what follows after that depends on
CD the word.  Possible words recognised are:
CD
CD G FACE followed by an integer and other numbers: a specification of a plane
CD        face of the crystal, according to the integer.
CD        (1 means read A,B,C,D in the equation AX+BY+CZ>=D)
CD
CD G PNTS followed by 3 integers which are the number of Gauss points required
CD        for integration in the x, y, and z directions.  These may be any
CD        integer in the range 1-20,32,40 (the list is being extended.)
CD
CD        The MAIN program may wish to alter these during a run.  This would
CD        involve resetting NL,NM and NN in COMMON /GAUSS/, and obeying
CD        SETGAU again.
CD
CD        If no G PNTS card is given, 5 points will be taken in all 3 directions
CD
CD G MU followed by the coefficient of absorption.  Its units must tie up with
CD        A,B,C,D above. (This card is not essential; if the MAIN program
CD        calls for different values of mu, these are simply written to AMU
CD        in the COMMON /ABSDAT/)
CD
CD G MODE followed by an integer which gives mode of use of ABSOR or ABMULT,
CD        i.e. which integral(s) are to be calculated.
C
CI Reads in all "G" cards.
CO Writes its findings to unit LPT.
C
%      CHARACTER *4 GWD,GTABLE(%GCRD%)
/ABSDAT/
/CARDRC/
/CPLANE/
/GAUSS/
/IOUNIT/
/GREAD/
      DATA GTABLE/'FACE','PNTS','MU','MODE'/
C
C SET "NO G CARDS READ":
%      CALL JGMZER(IGREAD,1,%GCRD%)
C
C INITIALISE COUNTS OF ITEMS WHICH MAY COME ON MORE THAN 1 CARD:
      NP=0
C
C READ ALL "G" CARDS:
      INREAD(7)=-IABS(INREAD(7))
      ID=IABS(INREAD(7))
      NCARD=ICDNO(7)
      IF (NCARD .LE. 0) CALL ERRMES(2,0,'"G" cards')
C
      DO 3 ICD=1,NCARD
C
      CALL CARDIN(ID)
      ID=ID+NYZ
      CALL RDWORD(GWD,LEN,3,IPT,80,0,IER)
%  42  L=NCFIND(GWD,GTABLE,%GCRD%)
      IF (L .LE. 0) THEN
        CALL ERRCH2(GWD,2,'cannot recognise word',
     &   'on "G" card')
        GO TO 3
      ENDIF
C
C SET "HAVE READ PARTICULAR WORD" (COUNTING NUMBER OF CARDS), THEN BRANCH:
      IGREAD(L)=IGREAD(L)+1
      GO TO (31,32,33,34) , L
C
C FACE:
  31  IER=IERR
%      CALL ERRCHK(2,NP,%CPLN%,0,'plane faces')
      IF (IER .NE. IERR) GO TO 3
C
      CALL RDREAL(AA(NP),IPT,IPT,80,IER)
      CALL RDREAL(BB(NP),IPT,IPT,80,IER)
      CALL RDREAL(CC(NP),IPT,IPT,80,IER)
      CALL RDREAL(DD(NP),IPT,IPT,80,IER)
      IF (DD(NP) .GT. 0.) GO TO 3
      AA(NP)=-AA(NP)
      BB(NP)=-BB(NP)
      CC(NP)=-CC(NP)
      DD(NP)=-DD(NP)
      GO TO 3
C
C PNTS:
  32  CALL RDINTG(NL,IPT,IPT,80,IER)
      CALL RDINTG(NM,IPT,IPT,80,IER)
      CALL RDINTG(NN,IPT,IPT,80,IER)
      WRITE (LPT,2000) NL,NM,NN
2000  FORMAT (/' Gauss points for integration in x,y and ',
     & 'z directions are',3I5)
      GO TO 3
C
C MU:
  33  CALL RDREAL(AMU,IPT,IPT,80,IER)
      WRITE (LPT,2003) AMU
2003  FORMAT (/' Coefficient of absorption is ',F10.5)
      GO TO 43
C
C MODE:
  34  CALL RDINTG(MODEA,IPT,IPT,80,IER)
      WRITE (LPT,2004) MODEA
2004  FORMAT (/' Absorption integral mode',I3)
      IF (MODEA .GT. 0 .AND. MODEA .LT. 8) GO TO 29
      CALL ERRMES(1,1,'No integral of this number')
      GO TO 43
C
  29  GO TO (21,22,23,24,25,26,27) , MODEA
C
  21  CALL MESS(LPT,0,'Conventional absorption correction')
      GO TO 43
  22  CALL MESS(LPT,0,'Depolarisation - integral using path in only')
      GO TO 43
  23  CALL MESS(LPT,0,'Extinction - derivative integral')
      GO TO 43
  24  CALL MESS(LPT,0,'Absorption+depolarisation')
      GO TO 43
  25  CALL MESS(LPT,0,'Absorption+extinction')
      GO TO 43
  26  CALL MESS(LPT,0,'Depolarisation+extinction')
      GO TO 43
  27  CALL MESS(LPT,0,'Absorption,depolarisation and extinction')
      GO TO 43
C
C HERE TO CONTINUE READING AFTER <WORD> <NUMBER> FORMAT:
  43  CALL RDWORD(GWD,LEN,IPT,IPT,80,0,IER)
      IF (IER .EQ. 100) GO TO 3
      GO TO 42
   3  CONTINUE
C
      WRITE (LPT,2001) NP
2001  FORMAT (/' Equations of',I3,' faces (with no + signs):')
      DO 7 I=1,NP
      WRITE (LPT,2002) AA(I),BB(I),CC(I),DD(I)
2002  FORMAT (1X,F10.5,'x',F10.5,'y',F10.5,'z >=',F10.5)
   7  CONTINUE
      RETURN
      END
C
C
C
C
C LEVEL 4      SUBROUTINE INPUTI
      SUBROUTINE INPUTI
C
C *** INPUTI updated by JCM 14 Jul 86 ***
C
CX
CC 13C
CH Gathers information from a user's interactive instruction card.
CD Absorbs into COMMON /IINFO/ sets of information from all I cards.
CD Sets IIN=number of items found on all cards.
CD
CD To be read by INPUTI, the I card must be of the form:
CD   I WORD1  NUM1  WORD2  NUM2  WORD3  NUM3  etc
CD (so if the user wants some other form he must read the card himself).
CD
CD The "NUMS" may be reals or integers.  They will be read to reals, but may be
CD fixed later according to their "WORDS".
CD
CD It does not matter what the vocabulary of words is.  INPUTI can
CD read any set of instructions in this format, and is expected to be called
CD for least squares application, for ARRNGE and for an increasing number of
CD MAIN programs requiring to be driven this way.
CD
CD An example of an I card for SFLSQ (structure factor least squares) is:
CD      I NCYC 6  CYC1  1     PRIN 2  MCOR  55
CD for which INPUTI simply produces 4 sets of (WORD, REAL) in COMMON, and
CD it is up to its calling routine (in this case STLSSF) to interpret these to
CD mean 6 cycles, first one numbered 1, print structure factor listing at last
CD cycle and correlations of over 55 per cent.
C
CI Reads all I cards.
C
/CARDRC/
/IINFO/
/IINFOW/
C
      INREAD(9)=-IABS(INREAD(9))
      NCARDS=ICDNO(9)
C IIN=NUMBER OF ITEMS READ FROM I CARDS:
      IIN=0
      IF (NCARDS .LE. 0) GO TO 100
      ID=IABS(INREAD(9))
      DO 2 I=1,NCARDS
      CALL CARDIN(ID)
      ID=ID+NYZ
      IPT=2
C
%   3  IF (IIN .LE. %ICRD%) GO TO 4
%      CALL ERRMES(1,1,'more than %ICRD% items on I cards')
      GO TO 100
C
   4  CALL RDWORD(IIREAD(IIN+1),NTEMP,IPT,IPT,80,0,IER)
      IF (IER .EQ. 100) GO TO 2
      IIN=IIN+1
      CALL RDREAL(ACOEFF(IIN),IPT,IPT,80,IER)
      GO TO 3
   2  CONTINUE
C
 100  RETURN
      END
C
C
C
C
C LEVEL 4      SUBROUTINE INPUTJ(ID,NTYP,IAT,IPT,IER)
      SUBROUTINE INPUTJ(ID,NTYP,IAT,IPT,IER)
C
C *** INPUTJ corrected by PJB c17 17 Sept 1993 ***
C
CX
CC 18A
CH Reads individual J cards.
CA On entry ID is the position in the CDF of the J card, or 0 (= card present)
CA On exit NTYP = a number indicating what kind of J card was read:
CA      NTYP=1 for MPOL ( l,m and amplitudes of its + and - combinations)
CA      NTYP=2 for FORM names of <jL> form factors with L values
CA On exit IAT = number corresponding to the atom or form factor la bel,
CA               if one was read.
CA On exit IPT = the next column on the card to be interpreted.
CA On exit IER = the error indicator, = 0 for no error.
C
      CHARACTER*4 WORD,WORD1,JWORD(2)
/IOUNIT/
/SCRACH/
      DATA NWRD/2/
      DATA JWORD/'MPOL','FORM'/
C
C
C SET NO ERROR
      IER=0
      ITYP=0
C
C IF ID=0, EXPECT CARD ALREADY PRESENT:
      IF (ID.NE.0) CALL CARDIN(ID)
      IPT1=3
      CALL RDWORD(WORD,LWORD,IPT1,IPT,80,0,IE)
      IF (IE.EQ.0) THEN
        JAT=ISCAT(WORD)
        IAT=IATOM(WORD)
        CALL RDWORD(WORD1,LWORD,IPT,IPT,80,0,IE)
        NTYP=NCFIND(WORD1,JWORD,NWRD)
        IF (NTYP.EQ.0) THEN
          CALL ERRCH2(WORD1,2,'The word "',
     &    '" on a J card is not an allowed J word ')
          GO TO 99
        ENDIF
        IF (IAT.EQ.0.AND.NTYP.EQ.1) THEN
          CALL ERRCH2(WORD,2,'The first word "',
     &    '" on a J MPOL card is not an atom name ')
          GO TO 99
        ENDIF
        IF (JAT.EQ.0.AND.NTYP.EQ.2) THEN
          CALL ERRCH2(WORD,2,'The first word "',
     &    '" on a J FORM card is not a form-factor name ')
          GO TO 99
        ENDIF
        IF (NTYP .EQ. 2) IAT=JAT
        GO TO 100
      ELSE
        CALL ERRCH2(ICARD(IPT1:IPT-1),2,'Illegal word','on J card')
      ENDIF
C
   99 IER=IER+1
C
  100 RETURN
      END
C
C
C
C
C LEVEL 5      SUBROUTINE INPUTM
      SUBROUTINE INPUTM
C
C *** INPUTM updated by PJB AUG 2017 C4.38 ***
C
CX
CC 5A
CH Reads and interprets all "M" cards.
CD Takes the information from "M" cards into the map or contouring COMMON,
CD usually as a prelude to a Fourier calculation
CD "M" cards have a significant word in columns 3,4,5,6.  Possible words are:
CD    M NDIM     Number of dimensions for Fourier, 2 (projection), 3 (3D)
CD               or 4 (bounded section).
CD    M FTYP     Fourier type (see below).
CD    M MESH     Output mesh - 6 numbers, being:
CD               X(START) X(END) X(STEP), and the same in Y
CD    M AXES     Matrix of 9 integers turning the Fourier to a different
CD               orientation, or 9 reals asking for a plane section.
CD    M PRIN     By itself means "print calculated map".  Followed by a
CD               list of Z values, means "print only at these selected
CD               Z values".  If absent, the default is not to print anything,
CD               so if there are no "M PRIN", "M PLOT" or "M SAVE" cards the
CD               run will not tell the user much.
CD    M PLOT     Present if plotting required - also gives values of Z at which
CD               plotting is required if NDIM=3, on several cards if necessary.
CD    M CM/A     If plotting, number of centimetres of plotter paper per
CD               Angstrom.
CD    M CONT     If plotting, list of required contour values (may be several
CD               cards, all starting M CONT)
CD    M SAVE     Save the calculated map(s) on a named file in such a way that
CD               a subsequent run with an "M GET" card will retrieve it/them
CD               with a view to drawing another contour map.  Details in the
CD               specification of SUBROUTINE FORIER.
CD    M GET      Do not calculate a map at all - read an already calculated map
CD               from unit IDUMPG, and interpret only those cards which make
CD               sense - e.g. the user may alter contours, scale of map in
CD               cms/Angstrom, etc, but he may not alter cell dimensions, space
CD               group, theta maximum etc.
CD    M DTYP     data input type
CD    M DELT     delta for resolution function
CD    M SCAL     scale to multiply Fourier coefficients
CD    M SMAX     sin theta/lambda maximun for this particular run
CD    M READ     do not calculate map - take the crystal data cards on trust,
CD               and read from a binary file some pre-calculated map.
C143 New words added to vaocab
CD    M MAXE     Options for maximum entropy calculation MSTOP: stopping
CD               criterion, MODEL: type of default model, and if MODEL=0 or 2
CD                DEFVAL: the value for the constant density.
CD    M GRID     Grid for Maximum entropy calculation, 6 (2D) or 9(3D) numbers,
CD               being: X(START) X(END) X(STEP), and the same in Y and (Z)
CD    M AXME     Axes of Maximum entropy calculation
CD    M LABL     Symbols to mark atomic positions
CD               each has <atom name> <symbol> <color> <type>
C
CI Reads all "M" cards
CO Writes its findings on unit LPT.
C
      EXTERNAL GFDEFS
%      CHARACTER *4 MWD,MTABLE(%MCRD%)
      DIMENSION IU(3,3),MULTI(7)
      LOGICAL LERCHK,SAID
C
/CARDRC/
/CONTUR/
/GFNUMS/
/GFWRDS/
/IOUNIT/
/MAPLAB/
/MAPDA/
/MAPGT/
/MAPPR/
/MAPRD/
/MAPSV/
/MREAD/
/PLOMAP/
/SCRACH/
/XENDA/
      DATA MTABLE/'NDIM','FTYP','MESH','AXES','PRIN','PLOT',
     & 'CM/A','CONT','SAVE','READ','DTYP','DELT','SCAL','GET',
     & 'SMAX','GRID','AXME','LABL','MAXE'/
      DATA NMULTI,MULTI/7,1,2,7,11,12,13,15/
C
C
C INITIALISE COUNTS OF ITEMS WHICH MAY COME ON MORE THAN 1 CARD:
      IZPR=0
      IZPL=0
      IZSV=0
      IZGT=0
      IZRD=0
      NCONT=0
      NLABS=0
C
C READ ALL "M" CARDS:
      INREAD(13)=-IABS(INREAD(13))
      ID=IABS(INREAD(13))
      NCARD=ICDNO(13)
      IF (NCARD .LE. 0) THEN
        CALL MESS(LPT,1,'No "M" cards given')
        GO TO 100
      ENDIF
C
      DO 3 ICD=1,NCARD
      CALL CARDIN(ID)
      ID=ID+NYZ
      CALL RDWORD(MWD,LEN,3,IPT,80,0,IER)
%  62  L=NCFIND(MWD,MTABLE,%MCRD%)
      IF (L .LE. 0) THEN
        CALL ERRCH2(MWD,2,'cannot recognise word','on "M" card')
        GO TO 3
      ENDIF
C
C Skip if this card is not relevant
      IF (IMREAD(L).LT.0) THEN
        IF (NFIND(L,MULTI,NMULTI) .GT.0) THEN
C SKIP VALUE
          CALL RDREAL(AJUNK,IPT,IPT,80,IER)
          GO TO 63
        ENDIF
        GO TO 3
      ENDIF
C SET "HAVE READ PARTICULAR WORD" (COUNTING NUMBER OF CARDS), THEN BRANCH:
      IMREAD(L)=IMREAD(L)+1
C
      GO TO (31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,70,71,73,74)
     & ,L
C
C M NDIM:
C READ 1 INTEGER BEING NUMBER OF DIMENSIONS FOR FOURIER, 2 OR 3:
C NDIM=4 MEANS CALCULATE BOUNDED SECTIONS
  31  CALL RDINTG(NDIM,IPT,IPT,80,IER)
      IF (NDIM .EQ. 2) THEN
        CALL MESS(LPT,1,'Fourier projection required')
      ELSE IF (NDIM .EQ. 3) THEN
        CALL MESS(LPT,1,'3D Fourier required')
      ELSE IF (NDIM .EQ. 4) THEN
        CALL MESS(LPT,1,'Bounded sections of Fourier required')
      ELSE
        CALL ERRIN2(NDIM,2,'Number of dimensions on M NDIM card =',
     &  ' - only 2, 3 or 4 allowed')
      ENDIF
      GO TO 63
C
C M FTYP:
C READ 1 INTEGER GIVING TYPE OF FOURIER CALCULATION REQUIRED:
  32  CALL RDINTG(MODEF,IPT,IPT,80,IER)
      IF (MODEF .GE.1 .OR. MODEF .LT.8) GO TO 7
      CALL ERRIN2(MODEF,2,'Fourier type on M FTYP card =',
     & ' - only 1-7 allowed')
      GO TO 63
   7  WRITE (LPT,2003) MODEF
2003  FORMAT (/' Fourier type ',I3,' -')
      GO TO (21,22,23,24,25,26,27) , MODEF
C
  21  CALL MESS(LPT,0,'coeffs are F(cal)')
      GO TO 63
C
  22  CALL MESS(LPT,0,'coeffs are F(obs)')
      GO TO 63
C
  23  CALL MESS(LPT,0,'coeffs are mod(F(obs)*phase F(cal)')
      GO TO 63
C
  24  CALL MESS(LPT,0,'coeffs are F(obs)-F(cal)')
      GO TO 63
C
  25  CALL MESS(LPT,0,'coeffs are (mod(F(obs)-mod(F(cal))'//
     & ' * phase(F(cal))')
      GO TO 63
C
  26  CALL MESS(LPT,0,'coeffs are F(obs) sqrd '//
     & '(for Patterson function)')
      GO TO 63
C
  27  CALL MESS(LPT,0,'standard deviation of electron density')
      GO TO 63
C
C M MESH:
C READ 6 NUMBERS GIVING OUTPUT MESH IN X AND Y:
  33  DO 8 I=1,2
      DO 8 J=1,3
      CALL RDREAL(OUTLIM(J,I),IPT,IPT,80,IER)
      IF (IER .NE. 0 .AND. IER .NE. 100) IERR=IERR+1
   8  CONTINUE
      WRITE (LPT,2004) ((OUTLIM(I,J),I=1,3),J=1,2)
2004  FORMAT (/' Mesh for output of map is:  Initial     Final   Step'/
     & 2(26X,3F10.5/))
      GO TO 3
C
C M AXES:
C READ 9 INTEGERS  (OR 9 REALS) GIVING MATRIX TO TURN FOURIER MAP:
  34  IPKEEP=IPT
      DO 10 I=1,3
      DO 10 J=1,3
      CALL RDINTG(IU(J,I),IPT,IPT,80,IER)
C DETECT DECIMAL POINT:
      IF (IER .EQ. -1) GO TO 60
      IF (IER .NE. 0 .AND. IER .NE. 100) IERR=IERR+1
      U(J,I)=FLOAT(IU(J,I))
  10  CONTINUE
C
      WRITE (LPT,2005) IU
2005  FORMAT (/' Orientation matrix:'/3(4X,3I5/))
      MODET=1
      GO TO 3
C
C  HERE FOR GENERAL ORIENTATION
   60 IPT=IPKEEP
      DO 61 I=1,3
      DO 61 J=1,3
      CALL RDREAL(U(J,I),IPT,IPT,80,IER)
      IF (IER.NE.0 .AND. IER .NE.100) IERR=IERR+1
   61 CONTINUE
      WRITE (LPT,2020) U
 2020 FORMAT (/' General Fourier section with x parallel to',3F8.4/
     & 31X,'y         to',3F8.4/31X,'z         to',3F8.4)
      MODET=2
      GO TO 3
C
C M PRIN:
C READ PRINTING INSTRUCTIONS - A NUMBER OF Z VALUES (OR NOTHING) - MAY BE MORE
C THAN 1 CARD:
  35  IZKEEP=IZPR+1
%      CALL RDNUMS(ZPRVAL(IZKEEP),IPT,%PRIN%,NUM,IER)
      IF (IER .NE. 0) IERR=IERR+1
      IZPR=IZPR+NUM
      IF (NUM .NE. 0) GO TO 3
      CALL MESS(LPT,1,'Print map')
      IZPR=1
      GO TO 3
C
C M PLOT:
C  READ NUMBER OF VALUES OF Z AT WHICH TO PLOT - MAY BE MORE THAN
C  ONE CARD:
  36  IZKEEP=IZPL+1
%      CALL RDNUMS(ZPLVAL(IZKEEP),IPT,%PLOT%,NUM,IER)
      IF (IER .NE. 0) IERR=IERR+1
      IZPL=IZPL+NUM
      IF (NUM .NE. 0) GO TO 3
      CALL MESS(LPT,1,'Plot map')
      IZPL=1
      GO TO 3
C
C M CM/A - READ 1 REAL BEING THE SCALE OF PLOTTED MAPS IN CMS/ANGSTROM.
  37  CALL RDREAL(SCALMP,IPT,IPT,80,IER)
      IF (IER .NE. 0) IERR=IERR+1
      WRITE (LPT,2010) SCALMP
2010  FORMAT (/' Plot in',F10.4,' cms/Angstrom')
      GO TO 63
C
C M CONT - READ SOME CONTOURS TO PLOT - MAY BE MORE THAN 1 CARD:
  38  IZKEEP=NCONT+1
%      CALL RDNUMS(CONT(IZKEEP),IPT,%CONT%,NUM,IER)
      IF (IER .NE. 0) IERR=IERR+1
      NCONT=NCONT+NUM
      IF (NUM .EQ. 0) GO TO 16
      CALL MESS(LPT,1,'Contour values')
      CALL PRILIS(CONT,IZKEEP,NCONT)
      GO TO 3
  16  CALL MESS(LPT,1,'No contours on card')
      GO TO 3
C
C M SAVE - READ Z VALUES IF GIVEN, AND KEEP INSTRUCTION TO DUMP
  39  IZKEEP=IZSV+1
%      CALL RDNUMS(ZSVVAL(IZKEEP),IPT,%SAVE%,NUM,IER)
      IF (IER .NE. 0) IERR=IERR+1
      IZSV=IZSV+NUM
      IF (NUM .NE. 0) GO TO 3
      CALL MESS(LPT,1,'Save calculated map')
      IZSV=1
      GO TO 3
C
C M GET:
C READ NUMBER OF Z VALUES FOR WHICH MAPS REQUIRED TO BE GOT FROM SAVED FILE:
  44  IZKEEP=IZGT+1
%      CALL RDNUMS(ZGTVAL(IZKEEP),IPT,%GETM%,NUM,IER)
      IF (IER .NE. 0) IERR=IERR+1
      IZGT=IZGT+NUM
      IF (NUM .GT. 0) THEN
        CALL MESS(LPT,1,
     &  'Undump previously calculated map for z values ')
        CALL PRILIS(ZGTVAL,IZKEEP,IZGT)
        GO TO 3
      ENDIF
      CALL MESS(LPT,1,'Undump previously calculated map')
      IZGT=1
      GO TO 3
C
C M READ:
C READ NUMBER OF Z VALUES FOR WHICH MAPS REQUIRED TO BE READ FROM BINARY:
  40  IZKEEP=IZRD+1
%      CALL RDNUMS(ZRDVAL(IZKEEP),IPT,%READ%,NUM,IER)
      IF (IER .NE. 0) IERR=IERR+1
      IZRD=IZRD+NUM
      IF (NUM .GT. 0) THEN
        CALL MESS(LPT,1,'Read previously calculated map for z values ')
        CALL PRILIS(ZRDVAL,IZKEEP,IZRD)
        GO TO 3
      ENDIF
      CALL MESS(LPT,1,'Read previously calculated map')
      IZRD=1
      GO TO 3
C
C M DTYP:
C READ 1 INTEGER INTO MODED
  41  CALL RDINTG(MODED,IPT,IPT,80,IER)
      IF (IER .NE. 0 .AND. IER .NE. 100) IERR=IERR+1
      WRITE (LPT,2030) MODED
2030  FORMAT (/' Data input format type',I3)
      IF ((MODED .LT. 0) .OR. (MODED .GE. 5)) THEN
        CALL ERRMES(1,1,'Type is unacceptable')
        GO TO 63
      ENDIF
C
C MODED CHECKED OK - PRINT:
      GO TO (50,51,52,53,54) , MODED+1
C MODE 0 MEANS USER WILL SUPPLY INPUT ROUTINE TO READ OWN FORMAT:
  50  CALL MESS(LPT,0,'User to supply SUBROUTINE QFOUIN(K,F,ALPHA)'//
     & ' to read own format of data')
      GO TO 63
C
C MODES 1-4 AS IN MK2:
  51  CALL MESS (LPT,0,'h,k,l, F(cal), F(obs), possible Diff')
      GO TO 13
C
  52  CALL MESS(LPT,0,'h,k,l, mod F(cal), phase, F(obs)')
      GO TO 13
C
  53  CALL MESS(LPT,0,'h,k,l, A(cal), B(cal), F(obs)')
      GO TO 13
C
  54  CALL MESS(LPT,0,'h,k,l, F')
      GO TO 13
C
  13  CALL MESS(LPT,0,'In format 3I5,several F')
      GO TO 63
C
C M DELT:
C READ 1 REAL TO DELTA
  42  CALL RDREAL(DELTA,IPT,IPT,80,IER)
      D2=DELTA*2.
      WRITE (LPT,2011) D2
2011  FORMAT (/' Data to be averaged over a cube of edge ',F10.4)
      GO TO 63
C
C M SCAL:
C READ 1 REAL AS SCALE FACTOR TO APPLY TO INCOMING FOURIER COEFFICIENTS:
  43  CALL RDREAL(SCALF1,IPT,IPT,80,IER)
      IF (IER .NE. 0) IERR=IERR+1
      WRITE (LPT,2019) SCALF1
2019  FORMAT (/' Multiply data values by ',F10.4)
      GO TO 63
C
C M SMAX:
C READ SIN THETA/ LAMBDA MAXIMUM
  45  CALL RDREAL(SMAX,IPT,IPT,80,IER)
      IF (IER .NE. 0) IERR=IERR+1
      WRITE (LPT,2018) SMAX
2018  FORMAT (/' Maximum sin theta/lambda for this map =',F10.4)
      GO TO 63
C
C M GRID
   70 call rdnums(xlim,ipt,9,ndimen,ier)
      IF (IER .NE. 0) IERR=IERR+1
      GO TO 3
C M AXME
   71 DO 72 I=1,3
      DO 72 J=1,3
      CALL RDINTG(II,IPT,IPT,80,IER)
      IF (IER .NE. 0 .AND. IER .NE. 100) IERR=IERR+1
      UU(J,I,1)=FLOAT(II)
   72 CONTINUE
      GO TO 3
C M LABL
   73 CALL RDWORD(MWD,LWORD,IPT,IPT,80,0,IE)
      IF (IE.NE.0) THEN
        CALL ERRMES(1,1,'reading atom name on on M LABL card ')
        GO TO 3
      ENDIF
      IAT=IATOM(MWD)
      IF (IAT.EQ.0) THEN
        CALL ERRMES(1,1,MWD//'on M LABL card is not an atom name')
        GO TO 3
      ENDIF
      CALL RDREAL(SIZE,IPT,IPT,80,IE)
      IF (IE.NE.0) THEN
        CALL ERRMES(1,1,'reading symbol size on on M LABL card ')
        GO TO 3
      ENDIF
      CALL RDWORD(NAMFIL,LWORD,IPT,IPT,80,0,IE)
      IF (IE.NE.0 .OR. LWORD .LT.3) THEN
        CALL ERRMES(1,1,'reading symbol colour on on M LABL card ')
        GO TO 3
      ENDIF
      ICOL=LGFCOL(NAMFIL)
      CALL RDWORD(NAMFIL,LWORD,IPT,IPT,80,0,IE)
      IF (IE.NE.0 .OR. LWORD .LT.4) THEN
        CALL ERRMES(1,1,'reading symbol name on on M LABL card ')
        GO TO 3
      ENDIF
      LSY=LGFSYM(NAMFIL(1:6))
      CALL RDWORD(NAMFIL,LWORD,IPT,IPT,80,0,IE)
      IF (IE .EQ.100) THEN
        NAMFIL=''
      ELSE IF (IE.NE.0 .OR. LWORD .LT.4) THEN
        CALL ERRMES(1,1,'reading symbol type on on M LABL card ')
        GO TO 3
      ENDIF
%      IF (LERCHK(2,NLABS,%MLAB%,'Atoms to label',-1)) THEN
       FILL(NLABS)= (SAID (NAMFIL(1:4) ,'fill') )
        LABAT(NLABS)=IAT
        SYSIZE(NLABS)=SIZE
        MCOLOR(NLABS)=ICOL
        LSYMB(NLABS)=LSY
      ENDIF
      GO TO 3
C M MAXE
C Options for maximum entropy
   74 CALL RDINTG(MSTOP,IPT,IPT,80,IER)
      IF (IER.NE.0) go to 75
      CALL RDINTG(MODEL,IPT,IPT,80,IER)
      IF (IER.NE.0) go to 75
      CALL RDREAL(DEFVAL,IPT,IPT,80,IER)
      if (ier .eq. 100) then
        defval= 0.0
      else
        IF (IER.NE.0) go to 75
      endif
      GO TO 3
   75 CALL ERRMES(1,1,'reading Options on on M MAXE card ')
      go to 3
C
C HERE AFTER ONE <WORD> <NUMBER> PAIR:
  63  CALL RDWORD(MWD,LEN,IPT,IPT,80,0,IER)
      IF (IER .NE. 100) GO TO 62
   3  CONTINUE
C FOR GNUPLOT CONTOURING WE JUST WANT  THE NUMBER OF CONTOURS
      IF (NCONT .EQ.1) NCONT=INT(CONT(1))
      IF (IZSV.NE.0) THEN
        IF (NDIM.EQ.4) THEN
          CALL MESS(LPT,1,'Save sections bounded by z values ')
          WRITE (LPT,2115) (ZSVVAL(I),I=1,IZSV)
2115      FORMAT ('+',33X,F8.4,' to',F8.4,/(34X,F8.4,' to',F8.4))
        ELSE
          CALL MESS(LPT,1,'Save calculated map at z values ')
          CALL PRILIS(ZSVVAL,IZKEEP,IZSV)
        ENDIF
      ENDIF
      IF (IZPL.NE.0) THEN
        IF (NDIM.EQ.4) THEN
          CALL MESS(LPT,1,'Plot sections bounded by z values ')
          WRITE (LPT,2115) (ZPLVAL(I),I=1,IZPL)
        ELSE
          CALL MESS(LPT,1,'Plot at z values ')
          CALL PRILIS(ZPLVAL,IZKEEP,IZPL)
        ENDIF
      ENDIF
      IF (IZPR.NE.0) THEN
        IF (NDIM.EQ.4) THEN
          CALL MESS(LPT,1,'Print sections bounded by z values ')
          WRITE (LPT,2115) (ZPRVAL(I),I=1,IZPR)
        ELSE
          CALL MESS(LPT,1,'Print at z values ')
          CALL PRILIS(ZPRVAL,IZKEEP,IZPR)
        ENDIF
      ENDIF
C
 100  RETURN
      END
C
C
C
C
C LEVEL 4      SUBROUTINE INPUTN(NOUT)
      SUBROUTINE INPUTN(NOUT)
C
C *** INPUTN updated by JCM 6 Apr 89 ***
C
CX
CC 13C
CH Deals with the "N" card giving the Crystal Data File title.
CA On entry NOUT= an output unit number on to which to write the title
CA                or -1 to indicate title already present in /SCRACH
CD Puts title into ITITLE and the number of characters in it to NTITLE
CI The first time in a run INPUTN is called with +ve NOUT, it reads a single
CI card starting N, and takes the next 79 chars as a title to be put out where
CI the user chooses.  In particular it is written on plotted Fourier maps.
C
CO At this first and every other call of INPUTN, it will write out the title
CO on unit NOUT, unless NOUT=-1 when it is written to unit LPT.
C
CN The "N" is not held in ITITLE
C
      CHARACTER *8 NOTTLE
/CARDRC/
/IOUNIT/
/NTITL/
/TITLE/
/SCRACH/
      DATA NOTTLE/'UNTITLED'/
C
C IF NOUT=-1, COPY TITLE FROM SCRACH:
      IF (NOUT .EQ. -1) THEN
        NTITLE=LENGT(ICARD)
        ITITLE(1:NTITLE)=ICARD(1:NTITLE)
        GO TO 101
      ENDIF
C
C IF TITLE BEEN INPUT BY PREVIOUS CALL, JUST COPY OUT:
      IF (INREAD(14) .LT. 0) GO TO 101
C
C SET "N CARD READ ONCE":
      INREAD(14) =  -IABS(INREAD(14))
C
C IF NO "N" CARD GO TO PUT IN "UNTITLED":
      IF (ICDNO(14) .LT. 1) THEN
        ITITLE=NOTTLE
        NTITLE=8
        GO TO 100
      ENDIF
C
C READ N CARD:
      CALL CARDIN(IABS(INREAD(14)))
C NTITLE GIVES NO. OF PRINTING CHARS IN TITLE:
      NTITLE=LENGT(ICARD)-1
      ITITLE(1:NTITLE)=ICARD(2:NTITLE+1)
 101  IF (NOUT .GE. 0)WRITE (NOUT,2000) (ITITLE(I:I),I=1,NTITLE)
      IF (NOUT .LT. 0)WRITE (LPT,2000) (ITITLE(I:I),I=1,NTITLE)
2000  FORMAT(1X,79A1)
 100  RETURN
      END
C
C
C
C
C LEVEL 4      SUBROUTINE INPUTQ(ID,NTYP,IAT,IPT,IER)
      SUBROUTINE INPUTQ(ID,NTYP,IAT,IPT,IER)
C
C *** INPUTQ updated by PJB C4.26 Add Q words  SORD ,RVEC March 2013 ***
C
CX
CC 17A
CH Reads individual "Q" cards
CA On entry ID is the position in the CDF of the "Q" card, or 0 (= card present)
CA On exit NTYP = a number indicating what kind of "Q" card was read:
CA      NTYP=1 for STYP (magnetic structure type)
CA      NTYP=2 for PROP the propagation vector
CA      NTYP=3 for MSYM a magnetic symmetry operator
CA      NTYP=4 for NSYM a non-symmetric rotation
CA      NTYP=5 for FORM (a form factor label should be read first).
CA      NTYP=6 for MU   (Magnetic moment: an atom label should be read first).
CA      NTYP=7 for SDIR (Spin directions: an atom label should be read first).
CA      NTYP=8 for PSI  (Relative phases of helices: an atom label should be
CA                       read first).
CA      NTYP=9 for CHI  (Susceptibility tensor: an atom label should be
CA                       read first).
CA      NTYP=10 for PSYM symmetry relations between polarisation matrix
CA                       coefficients
CA      NTYP=11 for SORD Complex order parameters (may be more than 1)
CA      NTYP=12 for RVEC Complex moment vectors one for each
CA                       independent sub-lattice and order parameter
CA On exit IAT = number corresponding to the atom or form factor label,
CA               if one was read.
CA On exit IPT = the next column on the card to be interpreted.
CA On exit IER = the error indicator, = 0 for no error.
C
      CHARACTER*4 WORD,WORD1,QWORD(12)
/FONAM/
/FORMDA/
/SCRACH/
      DATA NWRD/12/
C4.26 Add Q words  SORD ,RVEC
      DATA QWORD/'STYP','PROP','MSYM','NSYM','FORM','MU','SDIR',
     &'PSI','CHI','PSYM','SORD','RVEC'/
C
C SET NO ERROR
      IER=0
C
C IF ID=0, EXPECT CARD ALREADY PRESENT:
      IF (ID.NE.0) CALL CARDIN(ID)
      CALL RDWORD(WORD,LWORD,3,IPT,80,0,IE)
      IF (IE.EQ.0) THEN
        IAT=IATOM(WORD)
        IF (IAT.EQ.0) THEN
          NTYP=NCFIND(WORD,QWORD,NWRD)
          IF (NTYP.NE.0) GO TO 100
        ENDIF
        IPT1=IPT
        CALL RDWORD(WORD1,LWORD,IPT1,IPT,80,0,IE)
        NTYP=NCFIND(WORD1,QWORD,NWRD)
        IF (NTYP.EQ.0) THEN
C4.3 Error changed to warning to allow special Q cards treated elsewhere
        CALL ERRMES(4,-1,'Word '//WORD//
     &  ' on "Q" card not recognised by DOMAG1')
        NTYP=NWRD+1
        ELSE
%          IF (NTYP.EQ.5)IAT=LMATCH(WORD,FONAME,NUMFNM,%FORM%)
          GO TO 100
        ENDIF
      ELSE
        CALL ERRCH2(ICARD(3:6),-2,'cannot recogise word',
     &   'on "Q" card')
        IER=IER+1
      ENDIF
C
  100 RETURN
      END
C
C
C
C
C LEVEL 4      SUBROUTINE INPUTS(ID,R,T)
      SUBROUTINE INPUTS(ID,R,T)
C
C *** INPUTS improved by JCM 30 Aug 92 ***
C
CX
CC 1A
CH Reads and interprets one "S" card containing a space group operator.
CH Can also interpret an S GRUP card containing a space group specification.
CA On entry ID points to an "S" card in the binary copy of the Crystal Data
CA file, or if 0 indicates that the card is already present in /SCRACH/,
CA       or if -ve indicates a scratch unit on which to find S cards.
CA On exit R is a 3x3 matrix containing the rotation, and T is a 1x3 vector
CA containing the translation.
CD Interprets symmetry operators within the character set:
CD         X Y Z x y z 1 2 3 4 5 6 + - / ,
CD and ignores characters outside that set.
CD
CD Within fixed format:
CD An operator has 3 fields, being in columns 2-21,22-41 and 42-61, and within
CD each field the element of the space group symmetry operator is given.  A
CD fraction is given as digit/digit, and any reasonable looking combination
CD (within the vocabulary above) is interpreted.
CD
CD It is also possible to override the need to use 20 columns per field,
CD by finishing a field with a comma, e.g.
CD    S  -X,-Y,Z
C
CI Reads an "S" card
CN The findings of SYMOP (which repeatedly calls INPUTS) may be printed by
CN a call of OPSYM.
C
      DIMENSION R(3,3),T(3)
/CARDRC/
/CHARS/
/IOUNIT/
/SCRACH/
C
C CLEAR R AND T TO ZERO
      CALL GMZER(R,3,3)
      CALL GMZER(T,1,3)
C SET NO ERRORS & READ IN CARD:
      IER=0
      IF (ID .LT. 0) READ (-ID,1000) ICARD
1000  FORMAT(A80)
      IF (ID .GT. 0) CALL CARDIN(ID)
C
C L COUNTS ALONG CARD, EITHER IN FIELDS OF 20 OR TO NEXT COMMA
      L=1
      DO 1 J = 1,3
      SIGN = 1.
      A = 0.
      B = 0.
      DO 2 K = 1,20
      L = L + 1
      DO 3 M = 1,6
      IF (ICARD(L:L) .NE. IDIGIT(M)) GO TO 3
      A=FLOAT(M)
      GO TO 2
   3  CONTINUE
      IF (ICARD(L:L) .EQ. '/') B = A*SIGN
      DO 6 IXYZ=24,26
      IF ((ICARD(L:L).EQ.LETUP(IXYZ)) .OR. (ICARD(L:L).EQ.LETLOW(IXYZ)))
     &  R(J,IXYZ-23) = SIGN
   6  CONTINUE
      IF (ICARD(L:L) .EQ. '+') SIGN = 1.
      IF (ICARD(L:L) .EQ. '-') SIGN = -1.0
      IF (ICARD(L:L) .EQ. ',') GO TO 4
   2  CONTINUE
   4  IF (A .NE. 0.) T(J) = B/A
C CHECK THAT SOMETHING HAS BEEN PUT INTO THE ROTATION MATRIX ROW:
      IF ((ABS(R(J,1))+ABS(R(J,2))+ABS(R(J,3))) .EQ. 0.) IER=IER+1
   1  CONTINUE
C
C CHECK THAT ROTATION MATRIX HAS NO ZERO COLUMN:
      DO 5 I=1,3
      IF ((ABS(R(1,I))+ABS(R(2,I))+ABS(R(3,I))) .EQ. 0.) IER=IER+1
   5  CONTINUE
C
C IF ERRORS, REPORT & SET IERR
      IF (IER .EQ. 0) GO TO 100
      WRITE (LPT,3000) R,T,ICARD
      WRITE (ITO,3000) R,T,ICARD
3000  FORMAT (/' ERROR ** on S card resulting in matrix',
     & 3(3F5.1/),' and vector',3F5.1,' from card saying'/A80)
      IERR=IERR+1
 100  RETURN
      END
C
C
C
C
C LEVEL 4      SUBROUTINE INPUTT(ID,LABA,LBALEN,NTYP,A,IER)
      SUBROUTINE INPUTT(ID,LABA,LBALEN,NTYP,A,IER)
C
C *** INPUTT by JCM 8 Feb 84 ***
C
CX
CC 4A
CH Reads and interprets one "T" card.
CA On entry ID points to the required card in the bionary copy of the Crystal
CA data file, or if 0 indicates that the card is already present in /SCRACH/.
CA On exit:
CA    LABA, A4, holds the label read after "T space"
CA    LBALEN is the number of characters in LABA
CA    NTYP is an integer giving the type of factor expected
CA    A is a 1x6 array of coefficients, in the standard sequence:
CA             A11, A22, A33, A23, A13, A12
CA    IER is an error indicator, =0 if no errors.
C
CD The exact interpretation of the 6 coefficients is left to the SUBROUTINE
CD (usually SETANI), which calls INPUTT.
CI Reads a "T" card.
C
      CHARACTER *4 LABA
      DIMENSION A(6)
/SCRACH/
C
      IER=0
      IF (ID .NE. 0) CALL CARDIN(ID)
C IPT MOVES ALONG CARD AS ITEMS TAKEN FROM IT:
      CALL RDWORD(LABA,LBALEN,3,IPT,80,0,IE)
      IF (IE .NE. 0  .OR. LETTER(LABA(1:1)) .EQ. 0) THEN
        CALL ERRATM(ICARD(3:6),-2,'"T" card')
      GO TO 101
      ENDIF
C
      IPKEEP=IPT
      CALL RDINTG(NTYP,IPT,IPT,80,IE)
      IF ((IE .NE. 0) .AND. (IE .NE. 100)) THEN
      CALL ERRCH2(ICARD(IPKEEP:IPT-1),-2,' ','read for atf type')
      GO TO 101
      ENDIF
      DO 2 I=1,6
      CALL RDREAL(A(I),IPT,IPT,80,IE)
      IF ((IE .NE. 0) .AND. (IE .NE. 100)) THEN
      CALL ERRCH2(ICARD(IPKEEP:IPT-1),-2,' ','read for atf coeff')
      GO TO 101
      ENDIF
   2  CONTINUE
      GO TO 100
C
 101  IER=IER+1
 100  RETURN
      END
C
C
C
C
C LEVEL 4      SUBROUTINE INPUTU(HT)
      SUBROUTINE INPUTU(HT)
C
C *** INPUTU by JCM 22 Nov 84 ***
C
CX
CC 1A
CH Reads and interprets a "U" card, giving a typical reflection to define
CH the reciprocal asymmetric unit.
CA On exit HT is a 1x3 vector holding the 3 indices.
CD Reads a single "U" card, giving 3 real numbers for h,k,l, the indices
CD of the typical reflection which the user wishes to be inside the chosen
CD asymmetric unit.
CD
CD If no "U" card is given, 13,11,10 is assumed (being all positive, with
CD h > k > l).  If the given indices are special, they will be on the edge
CD of an asymmetric unit, and the chosen unit might not be exactly as
CD wished.
C
CI Reads one "U" card.
CO Writes its findings to unit LPT.
C
      DIMENSION HT(3),K(3)
/CARDRC/
/IOUNIT/
C
      INREAD(21)=-IABS(INREAD(21))
      HT(1)=13.
      HT(2)=11.
      HT(3)=10.
C IF NO "U" CARD, USE DEFAULT 13,11,10:
      IF (ICDNO(21) .EQ. 0) GO TO 101
C
C READ U CARD:
      IER1=0
      CALL CARDIN(IABS(INREAD(21)))
C
C SCAN ALONG CARD FINDING 3 NUMBERS:
      L=2
      DO 1 J=1,3
      CALL RDREAL(HT(J),L,L,80,IER)
C IF READ ALL SPACES (UP TO FIXED FORMAT FIELD BARRIER) ASSUME 0:
      IF (IER .EQ. 100) IER=0
C OTHERWISE, IF IER CAME NON-ZERO, WE MET AN UNEXPECTED CHARACTER:
      IF (IER .NE. 0) CALL ERRIN2(J,2,'reading index number',
     &  'on U card')
   1  CONTINUE
C
C CHECK NOT 0,0,0 READ WHICH WOULD BE NO HELP:
      IF (HT(1)*HT(2)*HT(3) .NE. 0.) GO TO 101
      CALL ERRMES(1,-1,'indices 0,0,0 read from "U" card')
      GO TO 100
C
 101  CALL INDFIX(HT,K)
      WRITE (LPT,2000) K
2000  FORMAT (/' Indices',3I4,' to be used for typical reflection ',
     & 'inside asymmetric unit')
 100  RETURN
      END
C
C
C
C
C LEVEL 4       SUBROUTINE INPUTW(IAT,XWORD,ID,IPT)
      SUBROUTINE INPUTW(IAT,XWORD,ID,IPT)
C
C *** INPUTW updated by PJB Sept 2002 C118 ***
C
CX
CC 4A
CH To read the "W" card indicated by ID, as far as atom label and word.
CA IAT on exit is which atom label, or scattering factor label identified
CA WORD is A4, on exit holding which word read after atom label
CA ID on entry points to card to read
CA IPT on exit points to next position on card to read
CD If the word is 'RADF', expects the label to be a scattering factor
CD label.
C
      CHARACTER*4 WORD,XWORD
/CARDRC/
C
      CALL CARDIN(ID)
C  IN CASE COMMENT CARDS MIXED IN
      ID=ID+NYZ
      CALL RDWORD(WORD,LWORD,2,IPT1,80,0,IER)
      IF (IER.NE.0) GO TO 101
      CALL RDWORD(XWORD,LWORD,IPT1,IPT,80,0,IER)
      IF (IER.NE.0) GO TO 101
C118  Read next word before interpreting atom name
      IF (XWORD .EQ. 'RADF') THEN
        IAT=ISCAT(WORD)
        IF (IAT.EQ.0) CALL ERRMES(1,2,'Word '//WORD//' read on W RADF'
     &//' card is not a scattering factor name')
      ELSE
        IAT=IATOM(WORD)
        IF (IAT.EQ.0) CALL ERRMES(1,2,'Word '//WORD//' read on W '
     &//XWORD//' card is not an atom name')
      ENDIF
        GO TO 100
  101 CALL ERRMES(1,2,'reading W card')
  100 RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE INTCHR(IDIG,NDIG,ICHR,NCHR,MODE)
      SUBROUTINE INTCHR(IDIG,NDIG,ICHR,NCHR,MODE)
C
C *** INTCHR updated by JCM 12 Nov 89 ***
C
CX
CC 13C
CH Converts digits to characters, either left- or right-justified.
CA On entry IDIG is an integer array holding NDIG digits
CA          NCHR is the number of characters in ICHR
CA          MODE=0 requests left justification
CA               1 requests right justification
CA On exit  ICHR is a character string holding NDIG characters, which
CA               correspond to the digits in IDIG, properly justified.
C
      CHARACTER *(*) ICHR
      DIMENSION IDIG(NDIG)
/CHARS/
/IOUNIT/
C
      IF (NDIG .LE. NCHR) GO TO 1
      WRITE (LPT,3000) NDIG,NCHR
      WRITE (ITO,3000) NDIG,NCHR
3000  FORMAT (/' ERROR ** in INTCHR -',I4,' digits into',I4,
     & ' chars')
      STOP
C
   1  NLEN=LEN(ICHR)
      J=0
      IF (MODE .EQ. 1) J=NLEN-NCHR
      ICHR=' '
      DO 2 I=1,NDIG
      J=J+1
      K=IDIG(I)
      IF (K .EQ. 0) K=10
   2  ICHR(J:J)=IDIGIT(K)
      RETURN
      END
C
C
C
C
C LEVEL 3      SUBROUTINE INTDIG(N,IDIG,NDIG)
      SUBROUTINE INTDIG(N,IDIG,NDIG)
C
C *** INTDIG by JCM 8 Jun 82 ***
C
CX
CC 13C
CH Unpacks an integer into its individual digits.
CA On entry N is the integer to be unpacked
CA On exit  IDIG is an integer array holding the individual digits of abs(N)
CA          NDIG is the number of elements of NDIG, maximum 5
C
CO If the integer is too big, says so & exits with nothing stored
C
      DIMENSION IDIG(5),ITENS(4)
/IOUNIT/
      DATA ITENS/10,100,1000,10000/
C
      IN=IABS(N)
      ND=1
      K=4
   3  IF ((IN .LT. ITENS(K)) .AND. (ND .EQ. 1)) GO TO 1
      IDIG(ND) = IN/ITENS(K)
      IF (IDIG(ND) .GE. 10) THEN
        CALL ERRIN2(N,2,'integer','too large for INTDIG')
        GO TO 100
      ENDIF
      IN = IN-IDIG(ND)*ITENS(K)
      ND=ND+1
   1  K=K-1
      IF (K .NE. 0) GO TO 3
      IDIG(ND)=IN
      NDIG=ND
 100  RETURN
      END
C
C
C
C
C LEVEL  2      LOGICAL FUNCTION INTIND(H,K)
      LOGICAL FUNCTION INTIND(H,K)
C
C *** New by PJB 14-Mar-1997 ***
CC 3C
CH True if the indices H(3) are integer
CA K(3) returned as the integer values
C
      DIMENSION H(3),K(3),HI(3)
      LOGICAL INTIN
C
      CALL INDFIX(H,K)
      CALL INDFLO(HI,K)
      DO 1 I=1,3
      INTIN=ABS(H(I)-HI(I)).LT..0001
      IF (.NOT. INTIN) GO TO 2
    1 CONTINUE
    2 INTIND=INTIN
      RETURN
      END
C
C
C
C
C LEVEL 3      SUBROUTINE INVENT(U,H,ANS)
      SUBROUTINE INVENT(U,H,ANS)
C
C *** INVENT by PJB/JCM 8 Aug 83 ***
C
CX
CC 1C
CH Given a plane U and an axis H, produces a direction ANS which is in the
CH plane but not parallel to the axis.
C
      DIMENSION U(3),H(3),ANS(3),VEC(3,2),COMPA(3,2)
/IOUNIT/
C
C SET UP DEFAULT VALUES:
      CALL GMZER(VEC,3,2)
C EXAMINE ELEMENTS OF INCOMING PLANE;  NZ=NO. OF ZEROS+1,
C LZ POINTS TO ZERO IF ONE OF THEM ONLY, LN POINTS TO NON-ZERO
C IF TWO ZEROS:
      NZ=1
      DO 4 I=1,3
      IF (JFIX(U(I)) .NE. 0.) GO TO 5
      NZ=NZ+1
      LZ=I
      GO TO 4
   5  LN=I
   4  CONTINUE
C
C SET IH,IK,IL TO POINT CYCLICALLY 1,2,3 AS APPROPRIATE
      IF (NZ .GT. 3) CALL ERRMES(-1,0,'zero vector given to INVENT')
      IH=LN
      IF (NZ .EQ. 2) IH=LZ
      IK=MOD(IH,3)+1
      IL=MOD(IK,3)+1
      GO TO (1,2,3) , NZ
C BRANCH TO SET UP TWO POSSIBLE VECTORS FOR ANS IN VEC
C
C NO ZEROS AT ALL:
   1  VEC(IH,1)=-U(IK)
      VEC(IK,1)= U(IH)
      VEC(IK,2)=-U(IL)
      VEC(IL,2)= U(IK)
      GO TO 7
C
C ONE ZERO PRECISELY:
   2  VEC(IH,1)=1.
      VEC(IK,2)=-U(IL)
      VEC(IL,2)= U(IK)
      GO TO 7
C
C TWO ZEROS PRECISELY:
   3  VEC(IK,1)=1.
      VEC(IL,2)=1.
C
C JOIN HERE TO PICK GOOD ONE:
   7  CALL GMEQ(H,COMPA(1,1),1,3)
      CALL GMREV(H,COMPA(1,2),1,3)
      DO 6 N=1,2
      CALL GMEQ(VEC(1,N),ANS,1,3)
C PUT POTENTIAL ANSWER IN
      CALL INBOX(ANS,IN)
      IF (IN .LT. 0) CALL GMREV(ANS,ANS,1,3)
C IF VECTOR OUTSIDE ASYMMETRIC UNIT, REVERSE IT
      CALL FCTOR(ANS,NOPU)
      CALL EQVEC(COMPA,ANS,2,M,0)
      IF (M .EQ. 3) GO TO 100
C IF RESULT IS NOT COINCIDENT WITH GIVEN H, OK - EXIT
   6  CONTINUE
C
C IF HERE, BOTH POTENTIAL ANSWERS HAVE PROVED PARALLEL TO H
      WRITE (LPT,3001) U,H,VEC
      WRITE (ITO,3001) U,H,VEC
3001  FORMAT (/' ERROR ** IN INVENT - PLANE',3F10.2,' AND ',
     & 'EXCLUDED AXIS',3F10.4,' HAVE GIVEN VECTORS:'/2(3F10.4/))
      STOP
C
 100  RETURN
      END
C
C
C
C
C LEVEL 2      LOGICAL FUNCTION IPDONE(CHAR)
      LOGICAL FUNCTION IPDONE(CHAR)
C
C *** IPDONE new by PJB 27-Feb-1997 ***
C
CC 13C
CH Checks whether a the cards labelled CHAR have been read
CD Returns TRUE if the CHAR cards have already been read FALSE otherwise
C
      CHARACTER *1 CHAR
/CARDRC/
C
      I=LETTER(CHAR)
      IF (I.GT.0) THEN
        IPDONE=(INREAD(I).LT.0)
      ELSE
        IPDONE=.FALSE.
      ENDIF
      RETURN
      END
C
C
C
C
C LEVEL 1      FUNCTION IPOPE(N)
      FUNCTION IPOPE(N)
C
C
C *** IPOPE rewritten by PJB July 1993 ***
C
CX
CC 13C
CH Machine specific routine to interpret error codes during file opening.
CA On entry N=an error code produced as a result of trying to open a file.
CA On exit IPOPE is set as follows:
CA    1 for an 'old' file which does not exist
CA    2 for a 'new' file which does exist
CA    3 for a bad file name
CA    4 file already open
CA    0 for anything else
C
      DIMENSION IOS(4),NSWI(4)
CS UNIX      DATA NERR,NSWI,IOS/3, 1,2,3,3, 2,126,107,145/
CS VMS      DATA NERR,NSWI,IOS/3, 1,2,3,0, 29,43,30,0/

      I=NFIND(N,IOS,NERR)
      IF (I.NE.0) I=NSWI(I)
      IPOPE=I
      RETURN
      END
C
C
C
C
C LEVEL 2      FUNCTION ISCAT(FNAME)
      FUNCTION ISCAT(FNAME)
C
C *** ISCAT updated by JCM 23 Sep 86 ***
C
CX
CC 11C
CH Searches for a potential scattering factor name in the table.
CA On entry FNAME is an A4 CHARACTER name, which could be a scattering factor
CA                name, left justified
CA On exit  ISCAT =0 if FNAME does not occur in the list in /FONAME
CA                =position in the list if found.
CP The scattering factor list must have been set up by, say, ATOPOS
C
      CHARACTER *4 FNAME
/FONAM/
/FORMDA/
C
      IF (NUMFNM .EQ. 0) THEN
        ISCAT=0
      ELSE
        ISCAT=NCFIND(FNAME,FONAME,NUMFNM)
      ENDIF
      RETURN
      END
C
C
C
C
C LEVEL 3      LOGICAL FUNCTION ISPABS(H)
      LOGICAL FUNCTION ISPABS(H)
C
C *** ISPABS corrected by WIFD Jan 87 ***
C
CX
CC 1B
CH Checks space group absences.
CA H on entry is a 3-sized array containing h,k,l for a reflection
CA ISPABS on exit is .TRUE. if the hkl reflection is absent, .FALSE. if present
CP The symmetry must have been previously set up by SYMOP
C
      DIMENSION H(3),EH(3)
/NSYM/
/SYMDA/
C
C IF P1 OR P BAR1, NO ABSENCES:
      IF (NOPC .EQ. 1) GO TO 101
      ISPABS=.TRUE.
      DO 1 IC=1,NCENT
      DO 1 I=1,NOPC
      CALL ROTSYM(H,EH,I,-1)
      IF (IC .EQ. 2) CALL GMREV(EH,EH,1,3)
      DO 2 J=1,3
      IF (ABS(H(J)-EH(J)) .GT. 10.E-4) GO TO 1
   2  CONTINUE
C
C REFLECTION TRANSFORMS INTO ITSELF - CHECK TRANSLATION
      A=SCALPR(TRANS(1,I),H)
      IF (ABS(AMOD((ABS(A)+0.01),1.)) .GT. 0.1) GO TO 100
   1  CONTINUE
C
C PRESENT:
 101  ISPABS=.FALSE.
 100  RETURN
      END
C
C
C
C
C LEVEL 1      FUNCTION ITPOS(IPOS)
      FUNCTION ITPOS(IPOS)
C
C *** ITPOS 24 Nov 82 by JCM ***
C
CX
CC 15C
CH Sets ITPOS=a single bit (a one), in position IPOS, counting from the right.
CA IPOS is assumed non-zero on entry, and is unchanged.
CN It is also assumed that IPOS is not so large that integer
CN overflow will occur.  If it does, try reducing the number of
CN bits used in an integer (e.g.avoid the last, sign, bit) by reducing
CN the value of NBITS in COMMON /CONTUR/
C
      ITPOS=1
      IF (IPOS .EQ. 1) GO TO 100
      DO 1 I=2,IPOS
   1  ITPOS = 2*ITPOS
 100  RETURN
      END
C
C
C
C
C LEVEL 1      FUNCTION JFIX(X)
      FUNCTION JFIX(X)
C
C *** JFIX by JCM ***
C
CX
CC 16C
CH Rounds a real to be an integer.
CA On entry X is a real
CA On exit  JFIX is an integer with the value X, rounded not truncated
C
CN Note that the FORTRAN function IFIX truncates
C
      JFIX=IFIX(X+SIGN(0.5,X))
      RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE JGMADD(JA,JB,JC,NI,NJ)
      SUBROUTINE JGMADD(JA,JB,JC,NI,NJ)
C
C *** JGMADD by JCM Jun 88 ***
C
CX
CC 12C
CH In integers, sets matrix C = matrix A plus matrix B.
CA On entry JA and JB are integer matrices both of dimension NIxNJ
CA On exit  JC=JA+JB also NIxNJ
C
      DIMENSION JA(NI,NJ),JB(NI,NJ),JC(NI,NJ)
      DO 1 I= 1,NI
      DO 1 J=1,NJ
   1  JC(I,J) = JA(I,J) + JB(I,J)
      RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE JGMEQ(JA,JB,NI,NJ)
      SUBROUTINE JGMEQ(JA,JB,NI,NJ)
C
C *** JGMEQ by JCM  Jun 88 ***
C
CX
CC 12C
CH Equates an integer matrix to a given integer matrix.
CA On entry JA is an integer matrix of dimension NIxNJ
CA On exit  JB = integer matrix being a copy of JA
C
      DIMENSION JA(NI,NJ),JB(NI,NJ)
      DO 1 I=1,NI
      DO 1 J=1,NJ
    1 JB(I,J)=JA(I,J)
      RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE JGMPRD(JA,JB,JC,NI,NJ,NK)
      SUBROUTINE JGMPRD(JA,JB,JC,NI,NJ,NK)
C
C *** JGMPRD by JCM Jun 88 ***
C
CX
CC 12C
CH In integers, sets matrix C = matrix A times matrix B.
CA On entry JA is an integer matrix of dimension NIxNJ
CA          JB is an integer matrix of dimension NJxNK
CA On exit  JC is an integer matrix of dimension NIxNK, being JA times JB
C
      DIMENSION JA(1),JB(1),JC(1)
      DO 2 I = 1,NI
      IK = I
      JK = 1
      DO 2 K = 1,NK
      IJ = I
      JC(IK) = 0
      DO 1 J = 1,NJ
      JC(IK) = JC(IK) + JA(IJ)*JB(JK)
      IJ = IJ + NI
    1 JK = JK + 1
    2 IK = IK + NI
      RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE JGMREV(JA,JB,NI,NJ)
      SUBROUTINE JGMREV(JA,JB,NI,NJ)
C
C *** JGMREV by JCM Jun 88 ***
C
CX
CC 12C
CH Reverses the signs of the elements of an integer matrix.
CA On entry JA is an integer matrix of dimension NIxNJ
CA On exit  JB is an integer matrix, being a copy of JA with reversed signs.
CN JB may be the same as JA.
C
      DIMENSION JA(NI,NJ),JB(NI,NJ)
      DO 1 I=1,NI
      DO 1 J=1,NJ
    1 JB(I,J)=-JA(I,J)
      RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE JGMSUB(JA,JB,JC,NI,NJ)
      SUBROUTINE JGMSUB(JA,JB,JC,NI,NJ)
C
C *** JGMSUB by JCM Jun 88 ***
C
CX
CC 12C
CH In integers, sets matrix C = matrix A minus matrix B.
CA On entry JA and JB are integer matrices of dimension NIxNJ
CA On exit  JC is an integer matrix = JA - JB
C
      DIMENSION JA(1),JB(1),JC(1)
      NIJ=NI*NJ
      DO 1 I= 1,NIJ
   1  JC(I) = JA(I) - JB(I)
      RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE JGMZER(JA,NI,NJ)
      SUBROUTINE JGMZER(JA,NI,NJ)
C
C *** JGMZER by JCM Jun 88 ***
C
CX
CC 12C
CH Clears an integer matrix to zero.
CA On entry NI and NJ are the dimensions of the required matrix
CA On exit  the integer matrix JA, of dimensions NIxNJ is cleared to zero.
C
      DIMENSION JA(1)
      NIJ=NI*NJ
      DO 1 I=1,NIJ
   1  JA(I)=0
      RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE JMPOL
      SUBROUTINE JMPOL
C
C *** JMPOL by JCM 11 Feb 91 ***
C
CX
CC 7B
CH Writes to unit NEWIN all J MPOL cards after a multipole refinement.
C
      DIMENSION N2(4)
/ATNAM/
/MPODA/
/MPODAC/
/NEWOLD/
C
C
      DO 1 MP=1,NMPAT
      N1=MPATAB(MP)
      N3=0
      DO 2 J=MPTAB(MP),MPTAB(MP+1)-1
      N3=N3+1
      IF (N3 .GT. 4) THEN
        WRITE (NEWIN,2000) ATNAME(N1),
     &  (MPNAM(N2(I)),POLAMP(N2(I),1),I=1,4)
2000    FORMAT ('J ',A4,' MPOL',4(1X,A4,F10.4))
        N3=1
      ENDIF
      N2(N3)=J
   2  CONTINUE
      IF (N3 .GT. 0) WRITE (NEWIN,2000) ATNAME(N1),
     & (MPNAM(N2(I)),POLAMP(N2(I),1),I=1,N3)
   1  CONTINUE
C
      RETURN
      END
C
C
C
C
C LEVEL 4      SUBROUTINE JTERMS(G,R,H,S)
      SUBROUTINE JTERMS(G,R,H,S)
C
C *** JTERMS by PJB 17 Jan 85 ***
C
CX
CC 9C
CH Calculates the terms in the 2D averaged spherically symmetric form factor
CH summation which depend on S,K, and R only.
C
/CONSTA/
C
C     TEST FOR SPECIAL CASES:
      IF (H .LT .001) GO TO 1
      IF (S .LT. .001) GO TO 2
      IF (ABS(H-S) .LT. .001) GO TO 3
      G = H*BJ(1,H*R)*BJ(0,S*R) - S*BJ(1,S*R)*BJ(0,H*R)
      G = TWOPI*G*R/(H*H-S*S)
      GO TO 100
    1 IF (S .LT. .001) GO TO 4
      G = TWOPI*R*BJ(1,S*R)/S
      GO TO 100
    2 G = TWOPI*R*BJ(1,H*R)/H
      GO TO 100
    3 G = PI*R*R*(BJ(1,H*R)*BJ(1,S*R) + BJ(0,H*R)*BJ(0,S*R))
      GO TO 100
    4 G = PI*R*R
 100  RETURN
      END
C
C
C
C
C LEVEL 5      SUBROUTINE KANGA1(X,Y,MODE)
      SUBROUTINE KANGA1(X,Y,MODE)
C
C *** KANGA1 by JCM 24 Nov 83 ***
C
CX
CC 14C
CH Moves plotter pen (or equivalent) to X,Y in current coordinates.
CA On entry X,Y give the required destination of the pen.
CA          MODE indicates whether the pen is to be up or down while moving
CA          MODE=1 leaves pen in state it was last time
CA          MODE=2 lowers pen
CA          MODE=3 raises pen
CP Plotting must have been set up by, e.g., STPLOT.  In particular the
CP transformation PTRAN must be held in /PLTRAN to take current coordinates
CP into the basic hardware coordinates.
C
/PLTRAN/
C
      M=MODE
C LEAVE M AS ONLY 2 OR 3, NOT 1, BECAUSE SPECIFIC PLOTTER SOFTWARE LIBRARIES
C MAY WELL NOT CATER FOR M=1:
      IF (M .EQ. 1) M=MPEN
      MPEN=M
C
C CONVERT CURRENT COORDINATES X,Y INTO PLOTTER'S COORDINATES X1,Y1:
      X1=X*PTRAN(1,1,1) + Y*PTRAN(1,2,1) + PTRAN(1,3,1)
      Y1=X*PTRAN(2,1,1) + Y*PTRAN(2,2,1) + PTRAN(2,3,1)
      CALL PIGLET(X1,Y1,M)
      RETURN
      END
C
C
C
C
C LEVEL 6      SUBROUTINE KANGA2(X0,Y0,XF,ICHARS,NCHAR)
      SUBROUTINE KANGA2(X0,Y0,XF,ICHARS,NCHAR)
C
C *** KANGA2 updated by JCM 12 Nov 89 **
C
CX
CC 14C
CH Writes on a plot a string of characters, or simulates this in order
CH to measure the length of the string.
CA On entry ICHARS is a character string
CA          NCHAR is the number of characters in ICHARS;  if NCHAR is given
CA                negatively, KANGA2 goes through the motions of writing but
CA                does not actually plot anything.  This facility is for
CA                measuring strings.
CA          X0, Y0 give where, in the current (character) space, to start
CA                 writing (i.e. the bottom left hand side of the first letter)
CA On exit XF has been updated to be the X position for the "next" character,
CA                 it is adjusted (by the subtraction of X0) so that it is the
CA                 length of the string in character units.
C
CP Plotting must have already been set up by, e.g., STPLOT, and we must
CP already be in "character" space, though this may be of one of various
CP types of character previously set up.
C
CD Instructions to plot the characters are held in the array LINES.
CD A character is described on a 30 by 30 grid.  The X direction is numbered
CD 0 to 30 (including both ends), but the Y direction is -8 to 22.  The line
CD on which the character looks to be written is thus the X axis.  Lower case
CD letters with descenders use the 0 to -8 range.
CD
CD The array LINES holds for each character in turn:
CD     First element = width of character as an integer (in character coords)
CD     Subsequent elements are instructions, packed one per element.  If MPACK
CD     is an instruction, then its sign says whether pen should be up or down
CD     (+ve=up, -ve=down) and the modulus of MPACK is X*32 + Y+8 (where this
CD     is an instruction to move to (X,Y).)
C
CN The character # (hash) is a special character, signalling that the
CN one character which follows it is in a special alphabet (so far, Greek,
CN and so far only theta and lambda allowed, requested by #T and #L)
CN
CN Unidentifiable characters are converted to spaces.
C
      CHARACTER *80 ICHARS
      CHARACTER *1 IALCHR
      LOGICAL GREEK
      DIMENSION IALCHR(84),ITBLCH(96),LINES(1030),LINE1(130),LINE2(130)
      DIMENSION LINE3(130),LINE4(130),LINE5(130),LINE6(130),LINE7(130)
      DIMENSION LINE8(82)
/CHARS/
      EQUIVALENCE (IALCHR(1),LETUP(1)),(LINE1(1),LINES(1))
      EQUIVALENCE (LINE2(1),LINES(131)),(LINE3(1),LINES(261))
      EQUIVALENCE (LINE4(1),LINES(391)),(LINE5(1),LINES(521))
      EQUIVALENCE (LINE6(1),LINES(651)),(LINE7(1),LINES(781))
      EQUIVALENCE (LINE8(1),LINES(911))
      DATA ITBLCH/1,8,30,49,64,73,80,102,109,112,123,130,135,
     & 144,151,173,186,210,225,246,251,262,267,276,281,287,
     & 294,311,328,343,360,378,386,408,418,426,437,444,447,
     & 464,474,492,509,526,534,552,560,570,575,584,589,598,
     & 605,606,611,626,642,648,666,690,695,725,749,767,773,
     & 782,793,807,815,835,838,843,868,871,882,893,896,899,
     & 904,909,916,925,960,964,968,968,968,968,968,968,968,968,
     & 988,988,988,993/
      DATA LINE1/18,317,-40,317,-552,143,-463,21,157,-136,157,-445,-540,
     & -571,-601,-599,-565,-532,-435,147,-435,-530,-561,-591,-588,-554,
     & -521,-424,-136,21,600,-570,-508,-445,-317,-252,-186,-152,-117,
     & -112,-141,-171,-233,-296,-424,-489,-555,-589,21,157,-136,157,
     & -381,-476,-538,-568,-597,-592,-557,-523,-457,-360,-136,19,157,
     & -136,157,-573,147,-403,136,-552,18,157,-136,157,-573,147,
     & -403,21,600,-570,-508,-445,-317,-252,-186,-152,-117,-112,-141,
     & -171,-233,-296,-424,-489,-555,-589,-592,432,-592,22,157,-136,
     & 605,-584,147,-595,8,157,-136,16,413,-397,-362,-329,-264,
     & -200,-137,-106,-77,-79,21,157,-136,605,-143,308,-584,17/
      DATA LINE2/157,-136,136,-520,24,157,-136,157,-392,669,-392,669,
     & -648,22,157,-136,157,-584,605,-584,22,317,-252,-186,-152,-117,
     & -112,-141,-171,-233,-296,-424,-489,-555,-589,-624,-629,-600,-570,
     & -508,-445,-317,21,157,-136,157,-445,-540,-571,-601,-598,-564,
     & -531,-434,-146,22,317,-252,-186,-152,-117,-112,-141,-171,-233,
     & -296,-424,-489,-555,-589,-624,-629,-600,-570,-508,-445,-317,396,
     & -582,21,157,-136,157,-445,-540,-571,-601,-599,-565,-532,-435,
     & -147,371,-584,20,570,-508,-413,-285,-188,-122,-120,-150,-181,
     & -244,-434,-497,-528,-558,-555,-489,-392,-264,-169,-107,16,285,
     & -264,61,-509,22,157,-142,-171,-233,-328,-392,-489,-555,-590/
      DATA LINE3/-605,18,61,-296,573,-296,24,93,-232,413,-232,413,
     & -552,733,-552,20,125,-552,573,-104,18,61,-307,-296,573,-307,
     & 20,573,-104,125,-573,104,-552,19,502,-488,499,-437,-374,
     & -278,-213,-147,-112,-110,-139,-201,-264,-360,-425,-491,19,157,
     & -136,147,-213,-278,-374,-437,-499,-528,-526,-491,-425,-360,-264,
     & -201,-139,18,499,-437,-374,-278,-213,-147,-112,-110,-139,-201,
     & -264,-360,-425,-491,19,509,-488,499,-437,-374,-278,-213,-147,
     & -112,-110,-139,-201,-264,-360,-425,-491,18,112,-496,-498,-468,
     & -437,-374,-278,-213,-147,-112,-110,-139,-201,-264,-360,-425,-491,
     & 12,349,-285,-220,-185,-168,86,-310,19,502,-486,-451,-418/
      DATA LINE4/-353,-257,-194,499,-437,-374,-278,-213,-147,-112,-110,
     & -139,-201,-264,-360,-425,-491,19,157,-136,146,-245,-310,-406,
     & -469,-498,-488,8,125,-156,-189,-158,-125,150,-136,10,189,-220,
     & -253,-222,-189,214,-197,-162,-97,-33,17,157,-136,470,-140,272,
     & -488,8,157,-136,30,150,-136,146,-245,-310,-406,-469,-498,
     & -488,498,-597,-662,-758,-821,-850,-840,19,150,-136,146,-245,
     & -310,-406,-469,-498,-488,19,278,-213,-147,-112,-110,-139,-201,
     & -264,-360,-425,-491,-526,-528,-499,-437,-374,-278,19,150,-129,
     & 147,-213,-278,-374,-437,-499,-528,-526,-491,-425,-360,-264,-201,
     & -139,19,502,-481,499,-437,-374,-278,-213,-147,-112,-110,-139/
      DATA LINE5/-201,-264,-360,-425,-491,13,150,-136,144,-179,-245,
     & -310,-406,17,467,-437,-342,-246,-149,-115,-145,-208,-367,-430,
     & -460,-459,-425,-328,-232,-137,-107,12,189,-172,-201,-264,-328,86,
     & -310,19,150,-140,-169,-232,-328,-393,-492,502,-488,16,86,-264,
     & 470,-264,22,118,-232,374,-232,374,-488,630,-488,17,118,
     & -456,470,-104,16,86,-264,470,-264,-196,-130,-65,-33,17,
     & 470,-104,118,-470,104,-456,16,20,217,-282,-381,-360,20,
     & 152,-153,-187,-220,-285,-413,-476,-507,-537,-535,-501,-434,-104,
     & -552,20,189,-541,-341,-437,-500,-531,-560,-558,-523,-457,-360,
     & -264,-169,-138,-108,20,445,-111,-591,445,-424,20,509,-189/
      DATA LINE6/-148,-181,-278,-374,-469,-531,-560,-558,-523,-457,
     & -360,-264,-169,-138,-108,20,538,-508,-413,-349,-252,-185,-148,
     & -143,-171,-233,-328,-360,-457,-523,-558,-559,-530,-468,-373,
     & -341,-244,-178,-143,20,573,-232,125,-573,20,285,-188,-154,-152,
     & -182,-245,-372,-467,-529,-559,-556,-522,-489,-392,-264,-169,
     & -138,-108,-111,-145,-211,-308,-437,-502,-536,-538,-508,-413,-285,
     & 20,534,-499,-433,-336,-304,-209,-147,-118,-119,-154,-220,-317,
     & -349,-444,-506,-534,-529,-492,-425,-328,-264,-169,-139,20,317,
     & -220,-153,-116,-113,-140,-201,-296,-360,-457,-524,-561,-564,-537,
     & -476,-381,-317,10,170,-137,-168,-201,-170,10,201,-168,-137,-170,
     & -201,-199,-165/
      DATA LINE7/-132,10,182,-149,-180,-213,-182,170,-137,-168,-201,
     &-170,10,182,-149,-180,-213,-182,201,-168,-137,-170,-201,-199,-165,
     & -132,10,189,-175,170,-137,-168,-201,-170,18,120,-121,-155,-188,
     & -253,-381,-444,-475,-505,-503,-469,-436,-306,-303,298,-265,-296,
     & -329,-298,8,157,-150,16,157,-150,413,-406,20,286,-262,
     & 414,-390,570,-508,-413,-285,-188,-122,-120,-150,-181,-244,-434,
     & -497,-528,-558,-555,-489,-392,-264,-169,-107,22,670,-68,14,
     & 318,-285,-252,-184,-147,-143,-170,-230,-261,-292,14,190,-221,
     & -252,-312,-339,-335,-298,-230,-197,-164,8,158,-131,26,145,
     & -721,26,442,-424,145,-721,26,148,-724,142,-718,16,279/
      DATA LINE8/-267,116,-430,436,-110,21,382,-131,574,-323,148,-596,
     &110,-558,26,756,-757,-726,-694,-661,-627,-558,-491,-425,-360,-232,
     & -169,-138,-108,-110,-144,-177,-405,-438,-472,-474,-444,-381,-316,
     & -282,-280,-309,-370,-523,-585,-648,-712,-745,-746,26,734,-19,
     & -30,26,30,-723,-8,20,317,-220,-153,-116,-113,-140,-201,-296,
     & -360,-457,-524,-561,-564,-537,-476,-381,-317,115,-563,22,
     & 286,-648,404,-136/
C
C SET NOT IN FUNNY CHARACTER SET:
      GREEK=.FALSE.
C
C XF FOLLOWS CHARACTERS ALONG LINE:
      XF=X0
C
      IF (NCHAR .EQ. 0) GO TO 100
      MODNC=IABS(NCHAR)
      DO 1 I=1,MODNC
C
C IDENTIFY CHARACTER  - IF UNKNOWN TO TABLES, SET SPACE (NUMBER 53)
      DO 2 J=1,84
      IF (IALCHR(J) .EQ. ICHARS(I:I)) GO TO 3
   2  CONTINUE
      J=53
C
C IF HASH, SET THAT NEXT CHARACTER WILL BE IN FUNNY SET:
   3  IF (J .NE. 81) GO TO 6
      GREEK=.TRUE.
      GO TO 1
C
C ARE WE ALREADY IN FUNNY CHARACTER SET?
   6  IF (.NOT. GREEK) GO TO 7
      GREEK=.FALSE.
      IF (J .EQ. 46) J=92
      IF (J .EQ. 38) J=95
C J=WHICH CHARACTER - SET K=START OF ITS INSTRUCTIONS IN ARRAY LINES
   7  K=ITBLCH(J)
      L=ITBLCH(J+1)
C IF ONLY MEASURING, NO NEED TO UNPACK INSTRUCTIONS:
      IF (NCHAR .LT. 0) GO TO 4
C
C WITH M SCAN EACH PACKED INSTRUCTION FOR THIS CHARACTER
      M=K+1
   5  IF (M .GE. L) GO TO 4
      MPACK=LINES(M)
      IPEN=2
      IF (MPACK .GT. 0) IPEN=3
      MP=IABS(MPACK)
      M1=MP/32
      M2=MP-M1*32-8
      X=FLOAT(M1)+XF
      Y=FLOAT(M2)+Y0
      CALL KANGA1(X,Y,IPEN)
      M=M+1
      GO TO 5
C
C CHARACTER WRITTEN - ADJUST XF
   4  XWIDE=FLOAT(LINES(K))
      XF=XF+XWIDE
   1  CONTINUE
      XF=XF-X0
 100  RETURN
      END
C
C
C
C
C LEVEL 5      SUBROUTINE KANGA3(X,Y,SIZE,MSYM)
      SUBROUTINE KANGA3(X,Y,SIZE,KSYM)
C
C *** KANGA3 updated by PJB Aug 2017 C4 ***
C
CX
CC 14C
CH Plots a special symbol.
CA On entry X,Y give the position in current coordinates of the CENTRE of the
CA              symbol.  The current space will usually be graph or map space.
CA          MSYM is negative if the symbol should be "filled in";
CA               its absolute value indicates which symbol is required:
CA      4    MSYM=1   square
CA      6    MSYM=2   triangle, apex up
CA      7    MSYM=3   triangle, apex down
CA      5    MSYM=4   hexagon (which if drawn small will make a circle)
CA      2    MSYM=5   cross like X
CA      1    MSYM=6   cross like +
CA     10    MSYM=7   cross like X with top and bottom (egg-timer)
CA     11    MSYM=8   cross like X with sides (bowtie)
CA      8    MSYM=9   diamond
CA      3    NSYM=10  asterix
CA      9    NSYM=1i  star
CA                   The symbols are "the right way up" for CCSL space.
CA On entry SIZE is set so that the symbol is drawn within a notional square
CA               of side SIZE cms. (Cms are CCSL units).
CP Plotting must be set up by, e.g., STPLOT, and a suitable space set by SPCSET
C
CN This is distinct from KANGA2, which can also draw symbols if they can
CN be represented as A1 characters, but expects them to be part of a
CN sentence, and draws them on a 30 x 30 character space grid with origin
CN at a point part way up the left hand side.  KANGA3 centres the symbol.
C
      LOGICAL SOLID,FOUND
      DIMENSION LGF2CC(11)
      DIMENSION SMPTS(2,12),MLINE(59),MPOINT(12),S(8),C(8)
/PLTRAN/
      DATA SMPTS/-2.,2.,2.,2.,2.,-2.,-2.,-2.,-2.,0.,0.,2.,2.,0.,0.,
     & -2.,-2.,-1.,-2.,1.,2.,1.,2.,-1./
      DATA MPOINT/1,6,10,14,21,25,29,34,39,44,52,60/
      DATA MLINE/ 1, -2, -3, -4 ,-1,  9,-6,-12,-9,  8,-10,-11,-8,     !13
     &            6,-11,-12,-8,-9,-10,-6,  1,-3,2,-4,  6,-8,5,-7,     !28
     &            1,-2,-4,-3,-1,      1,-4,-2,-3,-1,   6,-7,-8,-5,-6, !43
     &            1,-3,2,-4, 6,-8,5,-7,  9,-6,-12,-9, 8,-10,-11,-8/   !59
C Maos the complete set pf graphic symbols onto those drawn by this subroutine
      data LGF2CC/6,5,10,1,4,2,3,9,11,7,8/
C
      S4=SIZE/4.
C
C TRANSLATE FROM GRAF SYMBOLS
      JSYM=IABS(KSYM)
      SOLID = (KSYM.LT.0)
      MSYMB=LGF2CC(JSYM)
      IF (SOLID) THEN
        YSTEP=1./(100.*S4)
        XMIN=0.
        XMAX=0.
        YMIN=0.
        YMAX=0.
      ENDIF
C
      GO TO (2,3,3,3,2,4,2,2,4) ,MSYMB
C
C TIMES 1 OVER ROOT 2:
   2  S4=S4*0.7071
      GO TO 4
C
C TIMES ROOT 3 OVER 2:
   3  S4=S4*0.8660
C CONVERT POINT AT SYMBOL CENTRE TO BE IN PLOTTER SPACE:
   4  CALL PLCONV(X,Y,0,X0,Y0,1)
C MAKE UNIT VECTORS IN BOTH DIRECTIONS IN PLOTTER SPACE:
      CALL PLCONV(0.,0.,2,XX0,YY0,1)
      CALL PLCONV(S4,0.,2,XX1,YY1,1)
      CALL PLCONV(0.,S4,2,XX2,YY2,1)
      XX1=XX1-XX0
      YY1=YY1-YY0
      XX2=XX2-XX0
      YY2=YY2-YY0
      K=MPOINT(MSYMB)
      L=MPOINT(MSYMB+1)-1
      DO 1 I=K,L
      M=MLINE(I)
      MPEN=2
      IF (M .GT. 0) MPEN=3
      M=IABS(M)
      XIN=SMPTS(1,M)*XX1+SMPTS(2,M)*XX2+X0
      YIN=SMPTS(1,M)*YY1+SMPTS(2,M)*YY2+Y0
      CALL PIGLET(XIN,YIN,MPEN)
      IF (SOLID .AND. I.LT.L) THEN
        J=I+1
        IF (SMPTS(1,M).GT.XMAX) XMAX=SMPTS(1,M)
        IF (SMPTS(1,M).LT.XMIN) XMIN=SMPTS(1,M)
        IF (SMPTS(2,M).GT.YMAX) YMAX=SMPTS(2,M)
        IF (SMPTS(2,M).LT.YMIN) YMIN=SMPTS(2,M)
C GET SLOPES AND INTERCEPTS OF LINES JOINING POINTS
        MM=IABS(MLINE(J))
        DEN=(SMPTS(2,MM)-SMPTS(2,M))
        IF (ABS(DEN).LT.10E-6) THEN
          S(I-K+1)=1.1*10E6
        ELSE
          S(I-K+1)=(SMPTS(1,MM)-SMPTS(1,M))/DEN
          C(I-K+1)=(SMPTS(2,MM)*SMPTS(1,M)-SMPTS(2,M)*SMPTS(1,MM))
     &     /DEN
        ENDIF
      ENDIF
    1 CONTINUE
      IF (SOLID) THEN
        NY=IFIX((YMAX-YMIN)/YSTEP)
        MPEN=3
        YPT=YMIN
C FIND THE SMALLEST POSITIVE X ON AN EDGE
        DO 5 IY=1,NY
        YPT=YPT+YSTEP
        FOUND=.FALSE.
        XP=XMAX
        DO 6 I=1,L-K
        IF (S(I).GT.10.E6) GO TO 6
        XPT=YPT*S(I)+C(I)
        IF (XPT.GT. 0. .AND. XPT.LT.XP) XP=XPT
   6    CONTINUE
C USE THE SYMMETRY ABOUT X=0
          XIN=-(XP*XX1)+YPT*XX2+X0
          YIN=-(XP*YY1)+YPT*YY2+Y0
          CALL PIGLET(XIN,YIN,MPEN)
          MPEN=2
          XIN=XP*XX1+YPT*XX2+X0
          YIN=XP*YY1+YPT*YY2+Y0
          CALL PIGLET(XIN,YIN,MPEN)
   5    CONTINUE
      ENDIF
      RETURN
      END
C
C
C
C
C LEVEL 4      FUNCTION KPAK(IFAM,IGEN,ISPC,KP,KS)
      FUNCTION KPAK(IFAM,IGEN,ISPC,KP,KS)
C
C *** KPAK for MK4 by JCM 7 Nov 90 ***
C
CX
CC 6C
CH Pack a LSQ parameter specification on to integer.
CA On entry IFAM = family number
CA          IGEN = genus number
CA          ISPC = species number
CA          KP = Phase number (1 if single phase, but packed as 0)
CA          KS = Source number (1 if single source, but packed as 0)
CA On exit KPAK contains IFAM, IGEN, ISPC, (and KP and KS if multi)
CA         packed according to LSQ conventions
CP LSETUP must have set up the packing scheme
CN there is an inverse routine KUNPAK
C
      DIMENSION LPAK(5)
/GLOBAL/
/LSQPAK/
C
      N=3
      LPAK(1)=IFAM
      LPAK(2)=IGEN
      LPAK(3)=ISPC
      IF (MULONE) THEN
        LPAK(4)=KP
        LPAK(5)=KS
        N=5
      ENDIF
      CALL NPACK(KPAK,LPAK,N,1,KKPACK)
      RETURN
      END
C
C
C
C
C LEVEL 6      LOGICAL FUNCTION KSAME(KK1,KK2)
      LOGICAL FUNCTION KSAME(KK1,KK2)
C
C *** KSAME updated for MK4 by JCM 10 Feb 90
C
CX
CC 6C
CH Tells if two LSQ parameter specifications are the same, allowing wild
CH card elements.
CA On entry KK1 is a parameter spec, possibly incomplete
CA          KK2 is a parameter spec, possibly incomplete
CA On exit KSAME is .TRUE. if all the unpacked elements in the two
CA    specifications are the same, with 0 being the same as anything
C
       LOGICAL KWHOLE,KW1,KW2
       DIMENSION K1(5),K2(5)
/GLOBAL/
C
      IF (KK1 .EQ. KK2) GO TO 101
      KSAME=.FALSE.
      KW1=KWHOLE(KK1,K1)
      KW2=KWHOLE(KK2,K2)
      IF (KW1 .AND. KW2) GO TO 100
C ONE OF THEM AT LEAST HAS WILD CARDS:
      N=3
      IF (MULONE) N=5
      DO 3 I=1,N
      IF (K1(I) .EQ. 0) GO TO 3
      IF (K2(I) .EQ. 0) GO TO 3
      IF (K1(I) .EQ. K2(I)) GO TO 3
      GO TO 100
   3  CONTINUE
 101  KSAME=.TRUE.
 100  RETURN
      END
C
C
C
C
C LEVEL 4      SUBROUTINE KUNPAK(KK,IFAM,IGEN,ISPC,KP,KS)
      SUBROUTINE KUNPAK(KK,IFAM,IGEN,ISPC,KP,KS)
C
C *** KUNPAK by JCM 8 Nov 90 ***
C
CX
CC 6C
CH Unpacks a LSQ parameter specification from single integer.
CA On entry KK holds packed parameter specification
CA On exit IFAM holds family number
CA         IGEN holds genus number
CA         ISPC holds species number
CA         KP holds phase (unless single phase, when 1)
CA         KS holds source(unless single source, when 1)
CP KK  must have been made via a call of KPAK set up by LSETUP
CD Unpacks KK according to bases previously set
CN There is an inverse routine KPAK, and a routine PUNPAK which takes no
CN account of phase and source.
C
      DIMENSION LPAK(5)
/GLOBAL/
/LSQPAK/
C
      N=3
      IF (MULONE) N=5
      CALL NPACK(KK,LPAK,N,2,KKPACK)
      IFAM=LPAK(1)
      IGEN=LPAK(2)
      ISPC=LPAK(3)
      KP=1
      KS=1
      IF (MULFAS) KP=LPAK(4)
      IF (MULSOU) KS=LPAK(5)
      RETURN
      END
C
C
C
C
C LEVEL 5      LOGICAL FUNCTION KWHOLE(KK,K)
      LOGICAL FUNCTION KWHOLE(KK,K)
C
C *** KWHOLE updated by JCM 4 Dec 91 ***
C
CX
CC 6C
CH Says if KK is a whole packed parameter specification, or whether there
CH are wild card elements.
CA On entry KK is a parameter specification, possibly with zeros
CA On exit array K has the unpacked elements of KK
C
CD A complete KK will contain phase and source information.  As these will
CD often be zero (in the cases "not multiphase"/"not multisource") they are
CD treated differently from the other elements.
CD If "not multiphase" then no account is taken of the phase element
CD If "not multisource" then no account is taken of the source element
CD Otherwise, on exit KWHOLE is .TRUE. if all unpacked elements are non-zero
CD and otherwise .FALSE.
C
      DIMENSION K(5)
/GLOBAL/
C
C UNPACK:
* USED TO UNPACK PHASE & SOURCE INTO KP & KS - NOW DOES NOT - MAY DISCOVER WHY.
      CALL KUNPAK(KK,K(1),K(2),K(3),K(4),K(5))
      KWHOLE=.TRUE.
      DO 1 I=1,3
      IF (K(I) .EQ. 0) KWHOLE=.FALSE.
   1  CONTINUE
      IF (MULFAS .AND. K(4) .EQ. 0) KWHOLE=.FALSE.
      IF (MULSOU .AND. K(5) .EQ. 0) KWHOLE=.FALSE.
      RETURN
      END
C
C
C
C
C LEVEL 3      LOGICAL FUNCTION LATABS(H)
      LOGICAL FUNCTION LATABS(H)
C
C *** LATABS updated by PJB Sep 87 ***
C
CX
CC 1B
CH Checks h,k,l for being a (nuclear) lattice absence.
CA On entry H is 1x3 real array of h,k,l
CA On exit  LATABS = .TRUE. if h,k,l absent, .FALSE. if present
CP SYMOP should have set up the lattice information in /SYMDA, /NSYM
C
CN Deals with non-integral h,k,l also, giving the answer "absent"
C
C C106 replace use of JFIX with NINT
      DIMENSION H(3)
/NSYM/
/SYMDA/
C
C MAKE SURE INDICES ARE INTEGERS
      LATABS=.TRUE.
      DO 3 I=1,3
      IF (ABS(FLOAT(NINT(H(I)))-H(I)).GT..0001) GO TO 100
    3 CONTINUE
      IF (NLAT .EQ. 1) GO TO 2
C
C  SPECIAL ABSENCES FOR NON-PRIMITIVE LATTICES
      DO 1 I=2,NLAT
      A=SCALPR(H,ALAT(1,I))
      IF (ABS(FLOAT(NINT(A))-A) .GT. 0.0001) GO TO 100
   1  CONTINUE
   2  LATABS=.FALSE.
 100  RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE LATGEN(KI,K,KLIM,DONE,ISW,ISWO)
      SUBROUTINE LATGEN(KI,K,KLIM,DONE,ISW,ISWO)
C
C *** LATGEN by PJB 23 Apr 92 ***
C
CX
CC 1B
CH Generates points on a lattice.
CA On entry: KI(3) is the previous point generated
CA           KLIM(3,2) gives the limits over which points should be generated
CA           ISW is a switch indicating for which axes the a point on the upper
CA               limit is required. The point is required for the nth axis if t
CA               nth bit is set in ISW.
CA On exit: K  contains the next point generated.
CA          DONE is .TRUE. if there are no more points
CA          ISWO indicates whether the point generated is at any of the limits.
CA               The nth bit is set if the point is at the limit for the nth
CA               axis.
CN Use KLIM(1:3,1) for the first point, set KI(1:3)=KLIM(1:3,1) for the
CN first call to LATGEN, for subsequent calls set KI=K and continue until
CN DONE is .TRUE.
C
      DIMENSION KI(3),K(3),KLIM(3,2)
      LOGICAL DONE
C
      DONE=.FALSE.
      CALL JGMEQ(KI,K,3,1)
      IS=ISW
      ISWO=0
      J=1
C
      DO 1 I=1,3
      K(I)=K(I)+1
      IB=MOD(IS,2)
      IS=IS-IB
      IF (K(I).LT.KLIM(I,2)) THEN
        GO TO 100
      ELSE IF (IB.NE.0 .AND. K(I).EQ.KLIM(I,2)) THEN
        ISWO=ISWO+J
        GO TO 100
      ENDIF
      IF (I.EQ.3) DONE=.TRUE.
      K(I)=KLIM(I,1)
      IS=IS/2
      J=J*2
    1 CONTINUE
C
  100 RETURN
      END
C
C
C
C
C LEVEL 3      SUBROUTINE LATVCS(STEP,AVEC,NPRIM)
      SUBROUTINE LATVCS(STEP,AVEC,NPRIM)
C
C *** LATVCS new by PJB June 2006 C143  ***
C
CX
CC 1B
CH Determines whether STEP defines a primitive lattice and if
CH not returns the non-primitive vectors.
C
CA On Input STEP contains 3 3-vectors which will be used to generate
CA               points in a lattice
CA On exit NPRIM gives the number of lattice points in the cell defined by STEP
CA         AVEC are the vectors joining these points to the origin
CN The first entry in AVEC is always a zero vector.
C
      DIMENSION STEP(3,3),VECS(3,4),VEC(3,2),AVEC(3,4)
/IOUNIT/
C
      NPRIM=1
      CALL GMZER(VECS,3,1)
      CALL GMZER(AVEC,3,1)
C  CHECK WHETHER PRIMITIVE
      NP=NINT(DETER3(STEP))
      IF (NP.LT.0) CALL GMREV(STEP(1,3),STEP(1,3),3,1)
      IF (NP.EQ.1) GO TO 100
      CALL ERRCHK(1,NP-1,3,0,'non-primitive stepping vectors')
C  CHECK WHETHER BASE PLANE IS PRIMITIVE
      CALL VECPRD(STEP(1,1),STEP(1,2),VEC)
      CALL FCTOR(VEC(1,1),M)
      IF (M.EQ.1) GO TO 4
      CALL GMEQ(STEP(1,2),VEC(1,1),1,3)
      DO 1 N1=2,M
      CALL GMADD(VEC(1,1),STEP(1,1),VEC(1,1),1,3)
      CALL FCTOR(VEC(1,1),J)
      IF (J.EQ.M) GO TO 2
    1 CONTINUE
      WRITE (LPT,3000)M,J,(VEC(I,1),I=1,3),STEP
      WRITE (ITO,3000)M,J,(VEC(I,1),I=1,3),STEP
3000  FORMAT (/' ERROR ** IN LATVCS finding base plane vector - ',
     & ' M,J=',2I4,' VEC1=',3F5.1,' STEP array is'/1X,9F5.1)
      STOP
C
    2 DO 3 I=1,M-1
      NPRIM=NPRIM+1
      CALL GMSCA(VEC,AVEC(1,NPRIM),FLOAT(I),3,1)
   3  CONTINUE
      IF (NPRIM.GE.NP) GO TO 100
C
C  INTERVENING LAYERS ON THIRD AXIS:
    4 L=NP/NPRIM
      CALL GMEQ(STEP(1,3),VEC(1,2),1,3)
      DO 5 N2=1,L
      CALL GMEQ(VEC(1,2),VEC(1,1),1,3)
      DO 6 N1=1,L
      CALL FCTOR(VEC(1,1),J)
      IF (J .GT.1) THEN
        DO 7 I=1,J-1
        NPRIM=NPRIM+1
        CALL GMSCA(VEC(1,1),AVEC(1,NPRIM),FLOAT(I),3,1)
        IF (NPRIM .GE.NP) GO TO 100
    7   CONTINUE
        GO TO 5
      ENDIF
    6 CALL GMADD(VEC(1,1),STEP(1,1),VEC(1,1),1,3)
    5 CALL GMADD(VEC(1,2),STEP(1,2),VEC(1,2),1,3)
C  ERROR IF WE GET HERE
      WRITE (LPT,3001)L,M,J,STEP,((AVEC(I,II),I=1,3),II=1,NPRIM)
      WRITE (ITO,3001)L,M,J,STEP,((AVEC(I,II),I=1,3),II=1,NPRIM)
3001  FORMAT (/' ERROR ** in LATVCS making out of plane vectors',
     & ' - L,M,J=',3I4/' Step array is',9F5.1,
     &' Vectors so far are:',4(3F5.1,2x))
      STOP
 100  return
      end
C
C
C
C
C LEVEL 1      LOGICAL FUNCTION LATVEC(X)
      LOGICAL FUNCTION LATVEC(X)
C
C *** LATVEC by PJB 5 Nov 84 ***
C
CX
CC 1B
CH Tests for the presence of a lattice vector.
CA On entry X is a real 1x3 vector
CA On exit  LATVEC is. TRUE. if X is a lattice vector, .FALSE. otherwise
CP SYMOP must have set up the lattice information in /SYMDA, /NSYM
C
      DIMENSION X(3)
/NSYM/
/SYMDA/
C
      DO 1 I=1,NLAT
      DO 2 J=1,3
      A = AMOD(ABS(ALAT(J,I)-X(J)),1.)
      IF ((A .GT. .0001) .AND. (A .LT. .9999))GO TO 1
    2 CONTINUE
      LATVEC=.TRUE.
C MATCH FOUND - JUMP:
      GO TO 100
    1 CONTINUE
C
      LATVEC=.FALSE.
  100 RETURN
      END
C
C
C
C
C LEVEL 7      SUBROUTINE LDSCAL(N,IPT)
      SUBROUTINE LDSCAL(N,IPT)
C
C *** LDSCAL new by PJB March 2008 ***
C
CX
CC 6A
CH Multiple entry routine to deal with output of new L SORC SCAL cards
CH in multiisource  Least Squares.
CA   N=2 CLEARS UP AT END OF L CARDS
CA   N=4 writes out a new L SORC SCAL card to unit NEWIN.

      DIMENSION A(24),IPTR(4),ITEMP(4)
      CHARACTER *4 LWD
/DSOURC/
/NEWOLD/
/SCLDAT/
/SCRACH/
      SAVE IPTR
C
      GO TO (100,2,100,4),N
C CLEAR UP AT END OF LCARDS, first reorder in case cards were mixed
    2 CALL SORTN(IPSCAL,IPTR,NUMSRC)
      CALL JGMEQ(IPSCAL,ITEMP,NUMSRC,1)
      JP=0
      DO 20 JS=1,NUMSRC
      IF (ITEMP(JS).EQ.0) GO TO 20
      IP=0
      J=NFIND(JS,IPTR,NUMSRC)
      IF (J.GT.1) IP=ITEMP(IPTR(J-1))
      NUM=ITEMP(JS)-IP
      CALL GMEQ(SCALE(IP+1),A(JP+1),NUM,1)
      JP=JP+NUM
      IPSCAL(JS)=JP
   20 CONTINUE
      CALL GMEQ(A,SCALE,NSCALE,1)
      IP=0
      DO 3 JS=1,NUMSRC
      IF (IPSCAL(JS).EQ.0) IPSCAL(JS)=IP
      IP=IPSCAL(JS)
    3 CONTINUE
C SET BACK TO ZERO READY FOR N=4
      CALL JGMZER(IPTR,NUMSRC,1)
      GO TO 100
C
C THIS ENTRY TO WRITE UPDATED SCALE FACTORS
   4  CALL RDWORD(LWD,LEN,7,IPT1,13,0,IER)
      IF (IER.NE.0) GO TO 99
      CALL TBLFND(LWD,IANS,IFAM,IGEN,ISPC,KP,KS)
      IF (IANS .LE.0 .OR. IFAM .NE.3) GO TO 99
      IF (IPTR(IGEN) .NE. 0) THEN
C THIS ONE HAS ALREADY BEEN DONE
        IF (IPT .GT.17) WRITE (NEWIN,2004) (ICARD(I:),I=1,IPT-1)
        GO TO 100
      ENDIF
C MARK USED
      IPTR(IGEN)=1;
      IP=0
      IF (IGEN.GT.1) IP=IPSCAL(IGEN-1)
      NUM=IPSCAL(IGEN)-IP
      NP=(80-IPT)/10
      IF (NUM .LT.NP) NP=NUM
      WRITE (ICARD(IPT:),2003) (SCALE(I),I=IP+1,IP+NP)
 2003 FORMAT (8F10.4)
      WRITE (NEWIN,2004) (ICARD(I:),I=1,LENGT(ICARD))
 2004 FORMAT (80A1)
    5 IP=IP+NP
      NUM=NUM-NP
      IF (NUM.LE.0) GO TO 100
      NP=6
      IF (NUM .LT.6) NP=NUM
      WRITE (NEWIN,2005) LWD,(SCALE(I),I=IP+1,IP+NP)
2005  FORMAT ('L SORC ',A4,' SCAL',8F8.4)
      GO TO 5
C
C ERROR RETURN
  99  IPT=-1
C NORMAL RETURN
 100  RETURN
      END
C
C
C
C
C LEVEL 1      LOGICAL FUNCTION LDUMMY(NN,MODE)
      LOGICAL FUNCTION LDUMMY(NN,MODE)
C
C *** LDUMMY new by PJB C105 April-2001
C
CX
CC 7A
CH A dummy function to be called by APSHSF,VARSSF etc in simple structure
CH factor LSQ
CD It always returns false
C
      LDUMMY = .FALSE.
      IF (LDUMMY) THEN
        NN = NN
        MODE = MODE
      ENDIF
      RETURN
      END
C
C
C
C
C LEVEL 1      FUNCTION LENG(NTEXT,L)
      FUNCTION LENG(NTEXT,L)
C
C *** LENG by PJB 13 Apr 85 ***
C
CX
CC 13C
CH Determines the length of a text string, omitting trailing spaces.
CA On entry NTEXT is an A1 character array of dimension L
CA On exit  LEN is the number of visible characters in NTEXT
C
      CHARACTER*1 NTEXT
      DIMENSION NTEXT(L)
C
      I=L+1
   1  I=I-1
      IF (I .LE. 0) GO TO 101
      IF (NTEXT(I) .EQ. ' ') GO TO 1
  101 LENG=I
      RETURN
      END
C
C
C
C
C LEVEL 1      FUNCTION LENGT(CHAR)
      FUNCTION LENGT(CHAR)
C
C *** LENGT updated by pjb June 2017 ***
C4.38 Catch character variable padded with zeros
C
CX
CC 13C
CH Determines the length of a character variable, omitting the final spaces.
CA On entry CHAR is a character variable
CA On exit  LENGT is the number of visible characters in CHAR
C
      CHARACTER*(*) CHAR
C
      I=LEN(CHAR)+1
   1  I=I-1
      IF (I .LE. 0) GO TO 101
      IF (CHAR(I:I) .EQ. ' ' .or. ichar(char(I:I)).eq.0) GO TO 1
  101 LENGT=I
      RETURN
      END
C
C
C
C
C LEVEL 2      LOGICAL FUNCTION LERCHK(NTYP,NVALUE,NBOUND,NACT,MESS)
      LOGICAL FUNCTION LERCHK(NTYP,NVALUE,NBOUND,NACT,MESS)
C
C *** LERCHK from ERRCHK by PJB 15-Nov-95 ***
C
CX
CC 13C
CH FALSE or TRUE according to whether NVALUE (possibly incremented)
CH is greater than NBOUND
CA On entry NTYP=type of check required:
CA    NTYP=1 simply check NVALUE for being NOT GREATER THAN NBOUND
CA    NTYP=2 increment NVALUE by 1, then as type 1
CA On entry NVALUE is the integer to be checked
CA          NBOUND is its upper bound
CA On entry NACT says which action is required if the test fails:
CA    NACT +ve means increase IERR in /CARDRC/ by 1, complain and exit
CA    NACT -ve means complain and exit
CA    NACT =0 means complain and stop
CA On entry MESS is the message specific to this error state
C
CD returns TRUE if NVALUE <= NBOUND FALSE otherwise. If FALSE
CD NVALUE is set back to the value it had on entry.
CD The error message starts " ERROR ** ", and finishes with MESS.
CD If NTYP=1, NVALUE is printed.
CO Outputs the required message on units LPT and ITO
C
      CHARACTER *(*) MESS
/CARDRC/
/IOUNIT/
C
      IF (NTYP .NE. 1) NVALUE=NVALUE+1
      LERCHK=NVALUE .LE. NBOUND
      IF (LERCHK) GO TO 100
C
      IF (NACT .GT. 0) IERR=IERR+1
      L=LENGT(MESS)
      IF (NTYP .EQ. 1) THEN
        WRITE (LPT,3001) NVALUE,(MESS(I:I),I=1,L)
        WRITE (ITO,3001) NVALUE,(MESS(I:I),I=1,L)
3001    FORMAT (/' ',I6,80A1)
      ELSE
        NVALUE=NVALUE-1
      ENDIF
      WRITE (LPT,3000) NBOUND,(MESS(I:I),I=1,L)
      WRITE (ITO,3000) NBOUND,(MESS(I:I),I=1,L)
3000  FORMAT (/' ERROR ** there is an upper limit of',I6,
     & ' on number of ',80A1)
      IF (NACT .EQ. 0) STOP
 100  RETURN
      END
C
C
C
C
C LEVEL 1      FUNCTION LETTER(I)
      FUNCTION LETTER(I)
C
C *** LETTER by JCM 7 Oct 83 ***
C
CX
CC 13C
CH Determines whether a character is a letter.
CA On entry I is an A1 character
CA On exit  LETTER=0 if I is not a letter, otherwise which letter in range 1-26
CN Small letters and capitals treated alike.
C
      CHARACTER *1 I
/CHARS/
C
      DO 1 J=1,26
      IF (I .EQ. LETUP(J)) GO TO 2
      IF (I .EQ. LETLOW(J)) GO TO 2
   1  CONTINUE
      J=0
   2  LETTER=J
      RETURN
      END
C
C
C
C
C LEVEL 4      SUBROUTINE LFCALC(H)
      SUBROUTINE LFCALC(H)
C
C *** LFCALC updated by JCM 22 Sep 87 ***
C
CX
CC 6B
CH Calculates a nuclear structure factor and its derivatives.
CA On entry H is a 1x3 array containing h,k,l
CP RECIP, SYMOP, SETANI, and SETFOR must have been obeyed to set up
CP the structure factor calculations.  (These are contained in SETFC).
CP The LSQ environment must have been set up by a suitable MAIN program (like
CP SFLSQ) which has called LSETUP and VARMAK.
CP
CD On exit in /FCAL/
CD    FC is the complex structure factor
CD    FCMOD is its modulus
CD    COSAL is the cosine of its phase
CD    SINAL is the sine of its phase
CD    FCDERS is an array of derivatives of FCMOD wrt all family 2 (structure
CD           parameters.  These are NOT multiplied or divided by anything
CD           else;  compare LMCALC
CD The above will all be zero if h,k,l gives a lattice absence;  note that
CD such would not be true of FCALC, the similar routine which does not cater
CD for LSQ
C
      COMPLEX SUM1,TERM,FORM,HR,FORMFA
      LOGICAL TESTOV,LATABS
      DIMENSION RH(3),H(3)
/ANISO/
/BRAGG/
/CONSTA/
/FCAL/
/FORMDA/
/NSYM/
/PHASE/
/POINTS/
/POSNS/
/PRBLEM/
/SYMDA/
C
C CLEAR ANSWERS IN CASE ABSENT:
C
C  FC COLLECTS THE CONVENTIONAL STRUCTURE FACTOR, COMPLEX:
      FC=CMPLX(0.,0.)
C CLEAR MODULUS AND ANGLES:
      FCMOD=0.
      COSAL=0.
      SINAL=0.
C CLEAR DERIVATIVES:
      L2=NVARF(2,JPHASE,1)
      IF (L2 .GT. 0) CALL GMZER(FCDERS,1,L2)
C
C OUT IF ABSENT:
      IF (LATABS(H)) GO TO 100
C
C SET FIRST SCATTERING FACTOR:
      IFF=0
C
C GET OFFSET TO REACH THESE VARIABLES:
      LO=LVFST1(2,JPHASE,1)
C
C CLEAR DERIVATIVE VECTOR:
      IF (L2 .GT. 0) CALL CGMZER(DERIVT,1,L2)
C
C CYCLE OVER INDEPENDENT ATOMS:
      DO 1 IR=1,NATOM
      SUM1=CMPLX(0.,0.)
      IF (NFORMF(IR) .NE. IFF) THEN
        IFF=NFORMF(IR)
        FORM=FORMFA(STHL,IFF)
      ENDIF
C
C INNER LOOP OVER SYMMETRY EQUIVALENTS:
      DO 3 IS=1,NOPC
      CALL ROTSYM(H,RH,IS,-1)
      F1=TWOPI*(SCALPR(X(1,IR),RH)+SCALPR(TRANS(1,IS),H))
      ERS=ANITF(RH,IR)
C ANISOTROPIC T F (=1. IF NOT THERE) NEEDED SEPARATELY FOR LSQ:
      ARS=COS(F1)*ERS
      BRS=SIN(F1)*ERS
      TERM=CMPLX(ARS,BRS)
      SUM1=SUM1+TERM
C
C  NOW WE DO THE INNERMOST SUMS FOR THE DERIVATIVES OF MODFC WRT
C VARIABLES XYZ AND ALL BIJ.  WE USE THE
C COMPLEX VECTOR DERIVT FOR THE DERIVATIVES OF THE REAL & IMAGINARY PARTS
C OF THE COMPLEX FC WRT EACH VARIABLE IN TURN.
C
      DO 7 I=1,3
      L=KX(I,IR)
      IF (L .NE. 0) DERIVT(L-LO)=RH(I)*CMPLX(-BRS,ARS) + DERIVT(L-LO)
   7  CONTINUE
C
C IF ANY ATF (NOT A LOOP, FOR SPEED):
      IA=IAPT(IR)
      IF (IA .NE. 0) THEN
        L=KATF(1,IA)
        IF (L.NE.0) DERIVT(L-LO)=RH(1)*RH(1)*TERM + DERIVT(L-LO)
        L=KATF(2,IA)
        IF (L.NE.0) DERIVT(L-LO)=RH(2)*RH(2)*TERM + DERIVT(L-LO)
        L=KATF(3,IA)
        IF (L.NE.0) DERIVT(L-LO)=RH(3)*RH(3)*TERM + DERIVT(L-LO)
        L=KATF(4,IA)
        IF (L.NE.0) DERIVT(L-LO)=RH(3)*RH(2)*TERM + DERIVT(L-LO)
        L=KATF(5,IA)
        IF (L.NE.0) DERIVT(L-LO)=RH(1)*RH(3)*TERM + DERIVT(L-LO)
        L=KATF(6,IA)
        IF (L.NE.0) DERIVT(L-LO)=RH(1)*RH(2)*TERM + DERIVT(L-LO)
      ENDIF
   3  CONTINUE
C END OF INNERMOST CYCLE OVER SYMMETRY
C
C IF CENTROSYMMETRIC, COMPENSATE FOR USING ONLY HALF NUMBER OF OPERATORS:
      IF (CENTRC) SUM1=SUM1+CONJG(SUM1)
C
      FAC=AMULT(IR)*EXP(-(TF(IR)*SSQRD))
      HR=FAC*FORM*SITE(IR)
C HR IS PRODUCT OF ATOM DEPENDENT BUT SYMMETRY INDEPENDENT FACTORS
      FC=FC + HR*SUM1
C
C  NOW WE TIDY UP THE XYZ AND BIJ DERIVATIVES, ALLOWING FOR CENTRE:
      DO 8 I=1,3
      L=KX(I,IR)
      IF (L.GT.0) THEN
        DERIVT(L-LO)=TWOPI*HR*DERIVT(L-LO)
        IF (CENTRC) DERIVT(L-LO)=DERIVT(L-LO)+CONJG(DERIVT(L-LO))
      ENDIF
      IF (IA .NE. 0) THEN
        L=KATF(I,IA)
        IF (L.GT.0) THEN
          DERIVT(L-LO)=-(HR*DERIVT(L-LO))
          IF (CENTRC) DERIVT(L-LO)=DERIVT(L-LO)+CONJG(DERIVT(L-LO))
        ENDIF
        L=KATF(I+3,IA)
        IF (L.GT.0) THEN
          DERIVT(L-LO)=-(HR*2.*DERIVT(L-LO))
          IF (CENTRC) DERIVT(L-LO)=DERIVT(L-LO)+CONJG(DERIVT(L-LO))
        ENDIF
      ENDIF
   8  CONTINUE
C FORM FACTOR:
      L=KCMULT(IR)
C4.18 DERIVATIVE FOR MULTIPLIER ONLY
C WAS      IF (L.GT.0) DERIVT(L-LO)=SITE(IR)*FAC*SUM1
      IF (L.GT.0) DERIVT(L-LO)=SITE(IR)*FAC*SUM1*FORM/CMULT(IR)
C SITE OCCUPATION:
      L=KSITE(IR)
      IF (L.GT.0) DERIVT(L-LO)=FORM*FAC*SUM1
C ISOTROPIC TEMPERATURE FACTOR:
      L=KTF(IR)
      IF (L.GT.0) DERIVT(L-LO)=-(SSQRD*HR*SUM1)
   1  CONTINUE
C END OF CYCLE OVER ATOMIC POSITIONS
C
C  TIDY FCALC AND COLLECT TRUE D(MODFC)/D(VARIABLE)
C
      A = REAL(FC)
      B = AIMAG(FC)
      FCMOD = SQRT(A*A+B*B)
      IF (.NOT. TESTOV(A,FCMOD)) THEN
        COSAL=A/FCMOD
        SINAL=B/FCMOD
      ENDIF
C
      DO 6 I=1,L2
C NO SUMMING - THESE ARE THE ACTUAL DERIVATIVES NOT DIVIDED BY ANYTHING, AS
C THEY ARE SUBJECT TO THE CHAIN RULE NEXT, NOT LOGARITHMIC DIFFERENTIATION:
      FCDERS(I)=REAL(DERIVT(I))*COSAL + AIMAG(DERIVT(I))*SINAL
   6  CONTINUE
 100  RETURN
      END
C
C
C
C
C LEVEL 2      FUNCTION LGFCOL(NAME)
      FUNCTION LGFCOL(NAME)
C
CX
CC 14B
CH Returns the number of color NAME, or 0 if  NAME not in GFWRDS
C
      CHARACTER *(*) name,word *10
C
/GFWRDS/
/GFNUMS/
      EXTERNAL GFDEFS
/IOUNIT/
C
      WORD = NAME
      CALL UPONE(WORD,2)
      LGFCOL=NCFIND(WORD(1:3),GFCOLS,NGFCOL)
      IF (LGFCOL .EQ.0) THEN
         CALL ERRMES(1,1,WORD(1:LENGT(WORD))//
     &  ' is not a defined colour')
      write (ito,5000) WORD(1:3),(GFCOLS(i),i=1,NGFCOL)
 5000 format ('Looking for ',a, ' in'/(15(a,2x)))
      ENDIF
      RETURN
      END
C
C
C
C
C LEVEL 2      FUNCTION LGFSYM(NAME)
      FUNCTION LGFSYM(NAME,FILL)
C
C *** LGFSYM  replaces LPGSYM PJB Jan 2017 ***
CX
CC 14B
CH Returns the symbol type as defined by KANGA3 for NAME and FILL
C
      CHARACTER *(*) NAME
      CHARACTER *10 WORD
C
/GFWRDS/
/GFNUMS/
      WORD = NAME
      LS=LEN(GFSYMS(1))
      CALL UPONE(WORD,2)
      ISYM=NCFIND(WORD(1:LS),GFSYMS,NGFSYM)
      IF (ISYM.EQ.0) THEN
        WORD = NAME
        CALL ERRMES(1,1,WORD(1:LENGT(WORD))//
     &  ' is not a symbol name')
      ENDIF
  100 LGFSYM=ISYM
       RETURN
       END
C
C
C
C
C LEVEL  3      FUNCTION LISPEC(PATHIN,ICYC,NUMOR,TEXT,ITEXT,IPARS,NINTS,FPARS,
C     &                 NREALS,SCAN,NSPTS)
      FUNCTION LISPEC(PATHIN,ICYC,NUMOR,TEXT,ITEXT,IPARS,NINTS,FPARS,
     &                 NREALS,SCAN,NSPTS)
C *** Updated by PJB 27-Aug-1998 ***
CC 2C
CH Reads files from the ILL data base
C
      DIMENSION IPARS(*),FPARS(*),SCAN(*)
      LOGICAL THERE,NOSCAN,EXPAND
      CHARACTER*80 PATHIN,INST*4,CYC*8
      CHARACTER *100 VFMT
      CHARACTER *80 LINE,TEXT(*)*72
      CHARACTER *6 IDENT(5),DATNAM
C      EQUIVALENCE (LINE,JDENT)
/LOONEY/
/SCRACH/
      DATA IDENT/'RRRRRR','AAAAAA','IIIIII','FFFFFF','SSSSSS'/
C
C Set no error
      LISPEC=0
      ITEXT=0
      NOSCAN=.TRUE.
      EXPAND=.FALSE.
C
C THEN OPEN FILE
      L=LENGT(PATHIN)
C Can't be an instrument or path is it MADDATA?
      IF (L.LE.1) THEN
        CALL GETENV('MADDATA',MESSAG)
        IF (LENGT(MESSAG).LE.1) GO TO 97
      ELSE IF (L.GT.4) THEN
C Should be a path
        MESSAG=PATHIN
      ELSE
        GO TO 8
      ENDIF
      WRITE (MESSAG(L+1:),18) NUMOR
   18 FORMAT ('/',I6.6)
      GO TO 3
C ELSE CONSTRUCT THE PATH NAME
    8 INST=PATHIN(1:L)
      IF (ICYC.LE.0) THEN
        CYC='data/'
        LC=5
        IF (ICYC.LT.0) THEN
          CYC='data-1/'
          LC=7
        ENDIF
      ELSE
        WRITE(CYC,10) ICYC
   10 FORMAT (I3,'/')
        LC=4
      ENDIF
      IF (INST.EQ.'d10 ') THEN
        WRITE (VFMT,14) LC,L
   14 FORMAT ('(''/usr/illdata/'',A',I1,',A',I1,',''/'',I6.6)')
        WRITE (MESSAG,VFMT) CYC(1:LC),INST,NUMOR
      ELSE
        NUM=NUMOR/10000
        LN=1
        IF (NUM.GE.10) LN=2
        WRITE (VFMT,15) LC,L,L,LN
   15 FORMAT ('(''/usr/illdata/'',A',I1,',A',I1,',''/'',A',
     & I1,',''_'',I',I1,',''/'',I6.6,)')
        WRITE (MESSAG,VFMT) CYC,INST,INST,NUM,NUMOR
      ENDIF
      INQUIRE(FILE=MESSAG,EXIST=THERE)
      IF (.NOT. THERE) THEN
        L=LENGT(MESSAG)
        MESSAG=MESSAG(1:L)//'.Z'
        L=L+2
        WRITE (DATNAM,16) NUMOR
   16 FORMAT (I6.6)
        INQUIRE(FILE=MESSAG,EXIST=THERE)
        IF (.NOT. THERE) THEN
          LISPEC=-1
          GO TO 100
        ENDIF
        CALL SYSTEM('cp '//MESSAG(1:L)//' .')
        CALL SYSTEM('uncompress '//DATNAM)
        EXPAND=.TRUE.
        MESSAG=DATNAM
      ENDIF
C
   3  LUN=NOPFIL(231)
      IF (LUN.LE.0) THEN
        LISPEC=-1
        GO TO 100
      ENDIF
C
C READ DATA
    1 READ (LUN,13,END=99) LINE
      DO 2 I=1,5
      IF (IDENT(I).NE.LINE(1:6)) GO TO 2
      ILINE=I
      GO TO 5
    2 CONTINUE
      GO TO 1
    5 READ (LUN,13,END=99) LINE
      IF (LENGT(LINE).LT. 16) THEN
        READ (LINE,11) NP
      ELSE
        READ (LINE,11) NP,NL
C SKIP INFO LINES
        DO 4 I=1,NL
        READ (LUN,13) LINE
    4   CONTINUE
   11 FORMAT (5I8)
      ENDIF
      GO TO (20,30,40,50,60) ILINE
      LISPEC=1
      GO TO 100
C
C Record number
   20 IF (NP.NE.NUMOR) THEN
        LISPEC=2
        GO TO 100
      ENDIF
      GO TO 1
C
C Text lines
   30 ITEXT=ITEXT+1
      READ (LUN,13,END=99,ERR=98) TEXT(ITEXT)
   13 FORMAT (A72)
      GO TO 1
C
C Integer parameters
   40 READ (LUN,17,END=99,ERR=98) (IPARS(I),I=1,NP)
   17 FORMAT (10I8)
      NINTS=NP
      GO TO 1
C
C Floating parameters and scan values
   50 IF (NOSCAN) THEN
        READ (LUN,12,END=99,ERR=98) (FPARS(I),I=1,NP)
        NREALS=NP
        GO TO 1
      ELSE
        READ (LUN,12,END=99,ERR=98) (SCAN(I),I=1,NP)
        NSPTS=NP
      ENDIF
   12 FORMAT (5E16.8)
      GO TO 80
C
C Scan header
   60 NOSCAN=.FALSE.
      IF (NSPTS.EQ.0) GO TO 80
      GO TO 1
C
C Bad PATH indicator
   97 LISPEC=-4
      GO TO 100
C
C Read error return -3
   98 LISPEC=-3
      GO TO 80
C
C Unexpected end of data return -2
   99 LISPEC=-2
      GO TO 80
C
C DELETE EXPANDED FILES
   80 IF (EXPAND) CALL SYSTEM('rm '//DATNAM)
      GO TO 100
C
C CLOSE FILE
  100 CALL CLOFIL(LUN)
      RETURN
      END
C
C
C
C
C LEVEL 7      SUBROUTINE LLDPOP(N,IPT)
      SUBROUTINE LLDPOP(N,IPT)
C
C *** LLDPOP  New by PJB March 2008 ***
C
CX
CC 6A
CH Multiple entry routine which deals with domain populations in
CH multiisource  Least Squares.
C
CA On entry, N indicates the required action:
CA N=1 reads in an L DPOP card and records the POPULATIONS from it.
CA N=2 Clears up at end of L cards
CA N=4 writes out a new L SORC DPOP card to unit NEWIN.
C
%      DIMENSION A(%DPOP%),IPTR(%DSRC%),ITEMP(%DSRC%)
      character *4 lwd
/CARDRC/
/DSOURC/
/IOUNIT/
/LREAD/
/NEWOLD/
/SCRACH/
      SAVE ISKEEP,NDPOP,IPTR
C

      GO TO (1,2,100,4),N
C
    1 IF (ILREAD(8) .EQ. 1) THEN
%         CALL JGMZER(NDPOP,%DSRC%,1)
         NDPOP=0
      ENDIF
      ISKEEP=NDPOP+1
%      NTOT=%DPOP%-ISKEEP
      CALL RDNUMS(DPOP(ISKEEP),IPT,NTOT,NUM,IER)
      IF (IER.EQ.2) CALL ERRMES(1,1,'Too many domain populations read')
      IF (IER .NE. 0) then
        IERR=IERR+1
        GO TO 100
      ENDIF
      NDPOP=NDPOP+NUM
      IPDOM(JSRC)=NDPOP
C
      GO TO 100
C
C CLEAR UP AT END OF LCARDS;
    2 CALL SORTN(IPDOM,IPTR,NUMSRC)
      CALL JGMEQ(IPDOM,ITEMP,NUMSRC,1)
      JP=0
      DO 20 JS=1,NUMSRC
      IF (ITEMP(JS).EQ.0) GO TO 20
      IP=0
      J=NFIND(JS,IPTR,NUMSRC)
      IF (J.GT.1) IP=ITEMP(IPTR(J-1))
      NUM=ITEMP(JS)-IP
      CALL GMEQ(DPOP(IP+1),A(JP+1),NUM,1)
      JP=JP+NUM
      IPDOM(JS)=JP
   20 CONTINUE
      CALL GMEQ(A,DPOP,NDPOP,1)
      IP=0
      DO 3 JS=1,NUMSRC
      IF (IPDOM(JS).EQ.0) IPDOM(JS)=IP
      IP=IPDOM(JS)
    3 CONTINUE
C SET BACK TO ZERO READY FOR N=4
      CALL JGMZER(IPTR,NUMSRC,1)
      GO TO 100
C
C NEW L SORC DPOP CARD:

C FIND OUT HOW MANY TO WRITE
   4  CALL RDWORD(LWD,LEN,7,IPT1,13,0,IER)
      IF (IER.NE.0) GO TO 99
      CALL TBLFND(LWD,IANS,IFAM,IGEN,ISPC,KP,KS)
      IF (IANS .LE.0 .OR. IFAM .NE.3) GO TO 99
      IF (IPTR(IGEN) .NE. 0) THEN
C THIS ONE HAS ALREADY BEEN DONE
        IF (IPT .GT.17) WRITE (NEWIN,2004) (ICARD(I:),I=1,IPT-1)
        GO TO 100
      ENDIF
      IPTR(IGEN)=1;
      IP=0
      IF (IGEN.GT.1) IP=IPDOM(IGEN-1)
      NUM=IPDOM(IGEN)-IP
      NP=(80-IPT)/10
      IF (NUM .LT.NP) NP=NUM
      WRITE (ICARD(IPT:),2003) (DPOP(I),I=IP+1,IP+NP)
 2003 FORMAT (8F10.4)
      WRITE (NEWIN,2004) (ICARD(I:),I=1,LENGT(ICARD))
 2004 FORMAT (80A1)
    5 IP=IP+NP
      NUM=NUM-NP
      IF (NUM.LE.0) GO TO 100
      NP=6
      IF (NUM .LT.6) NP=NUM
      WRITE (NEWIN,2005) LWD,(DPOP(I),I=IP+1,IP+NP)
2005  FORMAT ('L SORC ',A4,' DPOP',8F8.4)
      GO TO 5
C
C ERROR RETURN
  99  IPT=-1
C NORMAL RETURN
 100  RETURN
      END
C
C
C
C
C LEVEL 7      SUBROUTINE LLSCAL(N)
      SUBROUTINE LLSCAL(N)
C
C *** LLSCAL updated by JCM 10 Feb 87 ***
C
CX
CC 6A
CH Multiple entry routine which deals with scale factors in Least Squares.
C
CA On entry, N indicates the required action:
CA N=0 deals with the introduction of a single scale factor with the value 1,
CA     to be refined, when no L SCAL cards are given.
CA N=1 reads in an L SCAL card and records the scale factors from it.
CA N=2 is not assigned.
CA N=3 applies a shift to a specific SCALE(ISPC), with ISPC in /NEWOLD/.
CA N=4 writes out a new L SCAL card to unit NEWIN.
C
/CARDRC/
/IOUNIT/
/LREAD/
/NEWOLD/
/SCLDAT/
C
      IF (N) 11,10,12
C
C N=0 - DEAL WITH NO SCAL CARDS:
  10  NSCALE=1
      SCALE(1)=1.0
      CALL MESS(LPT,1,
     & 'No L SCAL cards given - one scale factor of 1. assumed')
      GO TO 100
C
C N=-4 - IF A SCALE FACTOR WAS INRODUCED, MAKE NEW SCAL CARD:
  11  IF (ILREAD(2) .NE. 0) GO TO 100
C THIS IS NEVER CALLED, I THINK, BUT POSSIBLY SHOULD BE
      WRITE (NEWIN,2001) SCALE(1)
2001  FORMAT ('L SCAL',F10.5)
      GO TO 100
C
  12  GO TO (1,100,3,4) , N
C
   1  IF (ILREAD(2) .EQ. 1) NSCALE=0
      IF (ILREAD(2) .EQ. 1) NSCL=0
      NSCL=NSCL+1
      ISKEEP=NSCALE+1
      LSCD(NSCL)=ISKEEP
%      CALL RDNUMS(SCALE(ISKEEP),7,%SCAL%,NUM,IER)
      IF (IER .NE. 0) IERR=IERR+1
      NSCALE=NSCALE+NUM
      IER=IERR
%      CALL ERRCHK(1,NSCALE,%SCAL%,1,'scale factors')
      IF (IER .NE. IERR) GO TO 100
C
      LSCD(NSCL+1)=NSCALE+1
      CALL MESS(LPT,1,'Scale factor(s) :')
      CALL PRILIS(SCALE,ISKEEP,NSCALE)
      GO TO 100
C
   3  CALL ADJUST(SCALE(ISPC))
      GO TO 100
C
C NEW L SCAL CARD:
C WE NEED TO KNOW WHICH FACTORS WERE INVOLVED ON THIS CARD.  IT IS PROBABLY
C SENSIBLE TO HANG ON TO THIS INFORMATION AT THE POINT AT WHICH WE HAVE IT,
C THAT IS, WHEN THE CARD IS FIRST INPUT.  ARRAY LSCD(I) HOLDS SERIAL NUMBER
C OF FIRST FACTOR ON I'TH CARD;  LSCD(NSCL+1)=1 OFF END;  THERE ARE NSCL
C L SCAL CARDS.
C
C WHEN A CARD HAS BEEN OUTPUT, THIS IS INDICATED BY TURNING LSCD() NEGATIVE.
C
   4  DO 19 I=1,NSCL
      IF (LSCD(I) .GT. 0) GO TO 18
  19  CONTINUE
      WRITE (LPT,3001) LSCD,NSCL
      WRITE (ITO,3001) LSCD,NSCL
3001  FORMAT (/' *** PROGRAM ERROR IN LLSCAL - TRYING TO WRITE MORE',
     & ' CARDS THAN THERE WERE - NSCL, LSCD=',I4,10I3)
      STOP
  18  N1=LSCD(I)
      N2=LSCD(I+1)-1
      LSCD(I)=-LSCD(I)
      WRITE (NEWIN,2005) (SCALE(J),J=N1,N2)
2005  FORMAT ('L SCAL',8F10.5)
      GO TO 100
C
      ENTRY LSCAL8(NP,NV)
      KSCALE(NP)=NV
      GO TO 100
C
      ENTRY LSCAL9
      DO 9 I=1,NSCALE
   9  KSCALE(I)=0
 100  RETURN
      END
C
C
C
C
C LEVEL 7      SUBROUTINE LLTFAC(N)
      SUBROUTINE LLTFAC(N)
C
C *** LLTFAC updated JCM 13 Jan 88 ***
C
CX
CC 6A
CH Multiple entry routine which deals with overall isotropic temperature
CH factors in Least Squares.
C
CA On entry N indicates the action required:
CA N=1 reads in L TFAC card and stores value of overall isotropic
CA     temperature factor in TFAC.
CA N=2 is not assigned.
CA N=3 applies a shift to TFAC.
CA N=4 writes out a new L TFAC card.
CA N=5 deals with the default if no L TFAC card is given.
CA N=6 fixes a zero TFAC which is implied by the absence of an L TFAC card.
CA ENTRY LTFAC8(NV) sets KTFAC to indicate TFAC is variable number NV
CA ENTRY LTFAC9 sets KTFAC to indicate TFAC fixed
C
/CARDRC/
/IOUNIT/
/NEWOLD/
/OVER/
/PHASE/
C
      GO TO (1,100,3,4,5,6) , N
C
C INTERPRET L TFAC CARD ALREADY IN ICARD:
   1  CALL RDREAL(TFAC,7,IPT,80,IER)
      IF (IER .NE. 0) IERR=IERR+1
      NTFAC=1
      WRITE (LPT,2000) TFAC
2000  FORMAT (/' Overall isotropic temperature factor =',F10.4)
      GO TO 100
C
C APPLY SHIFT:
   3  CALL ADJUST(TFAC)
      GO TO 100
C
C NEW L TFAC CARD:
   4  WRITE (NEWIN,2001) TFAC
2001  FORMAT ('L TFAC',F10.4)
      GO TO 100
C
C NO L TFAC CARD:
   5  TFAC=0.
      CALL MESS(LPT,1,
     & 'No L TFAC card read - assuming TFAC=0. and fixed')
      NTFAC=0
      GO TO 100
C
C FIX TFAC IF NONE GIVEN:
   6  IF (NTFAC .EQ. 0) CALL ADDFX5(IFAM,IGEN,ISPC,JPHASE,1,4)
      GO TO 100
C
      ENTRY LTFAC8(NV)
C
C SET TFAC VARIED:
      KTFAC=NV
      GO TO 100
C
      ENTRY LTFAC9
C
C SET TFAC FIXED:
      KTFAC=0
 100  RETURN
      END
C
C
C
C
C LEVEL 1      FUNCTION LMAGPR(IP,IM,IR)
      FUNCTION LMAGPR(IP,IM,IR)
C
C *** LMAGPR updated for INCM by PJB C4.26 March 2013 ***
C
CX
CC 17B
CH Gives the fix/vary information for one of the family 2 parameters for
CH magnetic atoms.
CA On entry IP = which species required, in the range 1-24
CA          IM = which magnetic atom (if IP > 12)
CA          IR = which atom
CA On exit  LMAGPR = 0 if the parameter is fixed
CA                 = which variable it is if it is varied.
CD This function is necessary now we hold the fix/vary information with the
CD parameter (e.g. KX with X, KATF with ATF) instead of in a single array
CD regardless of the physical meaning of the parameter.
CN One could use this for non-magnetic applications, if IP =< 12
C
/ANISO/
/POSNS/
/MAGDAT/
/SYMMAG/
C
      L=0
      IF (IP .LE. 3) L=KX(IP,IR)
      IA=IAPT(IR)
      IF ((IP .GE. 4 .AND. IP .LE. 9) .AND. IA .GT. 0) L=KATF(IP-3,IA)
C C106 In lmagpr added a line for pr on magnetic and atomic pars
      IF ((IP .GE. 4 .AND. IP .LE. 9) .AND. IA .EQ. 0) L=0
C THIS IS FOR MAG - IF USED GENERALLY, REPLACE BY KSCAT & MAKE SURE IT STILL
C WORKS WITH MAG:
      IF (IP .EQ. 10) L=0
      IF (IP .EQ. 11) L=KSITE(IR)
      IF (IP .EQ. 12) L=KTF(IR)
      if (IP .le. 12) go to 99
C4.26 There is a different parameter numbering for INCM structure type
      IF (.NOT. CPVEC) THEN
        IF (IP .GE. 13 .AND. IP .LE. 16) L=KPHIH(IP-12,IM)
        IF (IP .GE. 17 .AND. IP .LE. 20) L=KANGM(IP-16,IM)
        IF (IP .GE. 21) L=KSMOD(IP-20,IM)
      ELSE
        JP=IP-12
        JA=1+(JP-1)/6
        JP=MOD(JP-1,6)
        JR=1+JP/3
        I=1+MOD(JP,3)
        L=KRVEC(I,JR,JA,IM)
      ENDIF
   99 LMAGPR=L
      RETURN
      END
C
C
C
C
C LEVEL 2      FUNCTION LMATCH(LABEL,NAMTAB,NUM,NBOUND)
      FUNCTION LMATCH(LABEL,NAMTAB,NUM,NBOUND)
C
C *** LMATCH updated by JCM 23 Sep 86 ***
C
CX
CC 11C
CH Matches an A4 item in given table, adding it if it is not there already.
C
CA On entry LABEL is the A4 item to be matched
CA          NAMTAB is the A4 array in which to search (and add)
CA          NUM is the number of entries so far (0 is allowed)
CA          NBOUND is the dimension of NAMTAB
CA On exit LMATCH is set to the address of LABEL in NAMTAB
CA          NUM is increased by 1 if an entry is added.
CO Writes an error message if the table becomes overfull.
C
      CHARACTER *4 LABEL,NAMTAB
      DIMENSION NAMTAB(NBOUND)
/IOUNIT/
C
C IF NO ENTRIES, NO MATCH:
      IF (NUM .EQ. 0) GO TO 2
C
      L=NCFIND(LABEL,NAMTAB,NUM)
      IF (L .GT. 0) GO TO 101
C NO MATCH - ADD NEW NAME TO TABLE:
   2  IF (NUM .LT. NBOUND) GO TO 3
      WRITE (LPT,3000) NBOUND,LABEL
      WRITE (ITO,3000) NBOUND,LABEL
3000  FORMAT (/' ERROR ** IN LMATCH - TABLE WITH',I5,' ENTRIES',
     & ' FULL - TRYING TO ADD ',A4)
      STOP
C
   3  NUM=NUM+1
      L=NUM
      NAMTAB(NUM)=LABEL
 101  LMATCH=L
      RETURN
      END
C
C
C
C
C LEVEL 6      SUBROUTINE LMCALC(H)
      SUBROUTINE LMCALC(H)
C
C *** LMCALC Updated  C4.7 March 2008 ***
C
CX
CC 17B
CH Calculates a magnetic structure factor and its derivatives.
CA On entry H is the 1x3 vector containing h,k,l
CP RECIP, SYMOP, SETANI, SETFOR and DOMAG1 must have been obeyed to set up
CP the structure factor calculation. (They are all called by SETFCM)
CP The LSQ environment must have been set up by a suitable MAIN program (like
CP SFLSQ) which has called LSETUP and VARMAK.
CP
CD On exit, in /MCAL/:
CD    FMCMOD = modulus of FMC
CD    FMCSQR = squared modulus of FMC
CD    FMCDER is an array containing the derivatives of FMCMOD wrt the family
CD           2 (structure) parameters, ALL MULTIPLIED BY FMCMOD.
CD    (Note the difference from the specification of LFCALC's derivatives)
CD On exit, in /QCAL/:
CD    Q is an array containing the magnetic interaction vectors for each domain
CD      in general there will be NDOM*KCENT domains
CD On exit, in /QCALD/:
CD    FQCDER is an array containing the derivatives of the Q's with respect to
CD           all the family 2 parameters.
CD
CD All the above will be zero if h,k,l is a magnetic absence
CN Note the existence also of LFCALC (nuclear structure factors for LSQ)
CN                            FMCALC (magnetic structure factors)
CN                            FCALC  (nuclear structure factors)
CN LMCALC Updated for PSI's C141 March 2006
C
%      COMPLEX DERIVM(3,%F2VA%),SUM1(3),TERM,TVEC(3),FORM,HR,FORMFA,P(3)
      COMPLEX CFAC,TEMP,PSIFAC,PSIFCC,TDERS(3,16),TTVEC(3),TDVEC(3)
      COMPLEX FMC(3)
      LOGICAL SKIP,MAGABS,BINDIG
      DIMENSION RH(3),H(3),RS(3,3),HD(3,3),SDOM(3,3)
/ANISO/
/BRAGG/
/CONSTA/
/IOUNIT/
/MAGDAT/
/MCAL/
/NSYM/
/PHASE/
/POINTS/
/POLDA/
/POSNS/
/PRBLEM/
/QCAL/
/QCALD/
/SATELL/
/SYMDA/
/SYMMAG/
/SYMTAB/
%      DATA NPSI/%PSIS%/
C
C CLEAR ALL ANSWERS IN CASE ABSENT:
C
C CLEAR MODULUS AND SQUARE:
      FMCMOD=0.
      FMCSQR=0.
C SIN THETA/LAMBDA
      STHL=VCTMOD(0.5,H,2)
      SSQRD=STHL*STHL
C
C CLEAR DERIVATIVES:
      L2=NVARF(2,JPHASE,1)
      IF (L2 .GT. 0) CALL GMZER(FMCDER,1,L2)
C
C OUT IF ABSENT:
      IF (MAGABS(H,IK)) GO TO 100
      TAU=-FLOAT(IK)
C
C  CYCLE OVER DOMAINS
      ND=0
      IHELIX=1
      IF (HELI) THEN
        IHELIX=2
C4.7  CHIRALITY DOMAINS, structure factors are complex conjugate
C  no need to calculate separately
C        IF (IABS(IPROP).EQ.1 .AND. CENTRC) ICHIR=2
      ENDIF
      SKIP=.FALSE.
      DO 15 IDOMOP=1, NOPC
      IF ((FERO .OR. FERA) .AND. IDOMOP .NE.1) GO TO 18
C DOMAINS EXIST FOR ALL ELEMENTS NOT IN THE MAGNETIC GROUP
      IF (IDOMOP.NE.1 .AND. IABS(MSTAB(IDOMOP)).NE.IDOMOP) GO TO 15
C FMC COLLECTS THE MAGNETIC STRUCTURE FACTOR, A COMPLEX VECTOR,
C ZEROED BEFORE CALCULATING THE VALUE FOR EACH DOMAIN
      CALL CGMZER(FMC,1,3)
C
C FIRST SCATTERING FACTOR:
      IFF=0
C
C OFFSET TO REACH THESE FAMILY 2 VARIABLES:
      LO=LVFST1(2,JPHASE,1)
C CLEAR DERIVATIVE VECTOR FOR ALL FAMILY 2:
      DO 82 I=1,L2
      DO 82 J=1,3
  82  DERIVM(J,I)=0.
C
C
C CYCLE OVER MAGNETIC ATOMS:
      DO 1 IM=1,NMAG
      IR=JMAGAT(IM)
C
C GET NEW FORM FACTOR IF DIFFERENT FROM THE PREVIOUS ONE
      IF (NMFORM(IM) .NE. IFF) THEN
        IFF=NMFORM(IM)
        FORM=FORMFA(STHL,IFF)
      ENDIF
C
C CYCLE OVER COMPONENTS OF HELIX
      DO 30 ICOMP=1,IHELIX
      CALL CGMZER(SUM1,3,1)
      CALL CGMZER(TDERS,3,16)
C IF IHELIX=1, THIS ONLY EVER DOES IC=0, & REFERS TO SPECIES 17 & 18 FOR ANGM,
C AND SPECIES 21 FOR SMOD(1)
C IF IHELIX=2, IC IS FIRST 0 (SPECIES 17 & 18) THEN 2 (SPECIES 19 & 20) FOR
C ANGM, AND SPECIES 21 THEN 22 FOR SMOD(1) THEN SMOD(2)
      IC=2*(ICOMP-1)
C
C PREPARE TO COUNT OPERATORS USED
      NOPU=0
C SYMMETRY CYCLE OVER SYMMETRIC AND NON-SYMMETRIC ROTATIONS:
      DO 3 IS=1,NOPC
C ONLY USE OPERATORS WHICH LEAVE THE PROPAGATION DIRECTION INVARIANT
      IF (IS.NE.1 .AND. IABS(KSTAB(IS)).NE.1) GO TO 3
C THE OPERATOR TO USE IS THE PRODUCT OF'IS' WITH THAT CREATING THE DOMAIN
      IROP=MULTAB(IDOMOP,IS)
      IF (MODUL) THEN
C INSYM IS THE NUMBER OF THE CO-SET ELEMENT INVOLVED (FROM THE CO-SET NSYM)
C IT MAY BE NEGATIVE IF INVERSION IS INCLUDED
        IF (IROP.EQ.1) THEN
          INSYM=1
        ELSE
          INSYM=MSTAB(IROP)
        ENDIF
C ISBGN IS THE NUMBER OF THE SUBLATTICE GENERATED BY INSYM
        ISBGN=IPTAB(IABS(INSYM),IM)
C THE NUMBBERS IN LPHI MAY ALSO BE NEGATIVE IF INVERSION IS INVOLVED
C SKIP IF IROP DOESN'T GENERATE A DISTINCT SUB-LATTICE
        IF (LPHI(ISBGN,IM).NE.INSYM) GO TO 3
      ENDIF
      CALL ROTSYM(H,RH,IROP,-1)
      IF (IDOMOP.NE.1 .AND. MSTAB(IDOMOP).LT.0) CALL GMREV(RH,RH,3,1)
C ANISOTROPIC T F (=1. IF NOT THERE) NEEDED SEPARATELY FOR LSQ:
      F1=TWOPI*(SCALPR(X(1,IR),RH)+SCALPR(TRANS(1,IROP),H))
      ERS=ANITF(RH,IR)
      ARS=COS(F1)*ERS
      BRS=SIN(F1)*ERS
      TERM=CMPLX(ARS,BRS)
      IF (FERA ) THEN
C4.1 FOR FERA THE SPIN IS PARALLEL TO THE POLARISATION
         CALL GMEQ(POLND,RS,3,1)
C4.1 THE DERIVATIVE PARTS SET TO ZERO (CAN'T REFINE ORIENTATION)
         CALL GMZER(RS(1,2),3,2)
      ELSE
C FIND OUT WHAT THE SYMMETRY DOES TO THE SPIN DIRECTION
        CALL ROTMAG(SPIND(1,1,ICOMP,IM),SDOM,IS)
C  GET THE SPIN DIRECTION FOR THIS DOMAIN
        DO 2 I=1,3
    2   CALL ROTOSM(SDOM(1,I),RS(1,I),IDOMOP,1)
      ENDIF
      CALL C1MSCA(RS,TVEC,TERM,3,1)
      PSIFAC=CMPLX(1.,0)
      PSIFCC=CMPLX(1.,0)
      IF (MODUL) THEN
C INCLUDE A PHASE SHIFT FOR THIS SUB-LATTICE IF NECESSARY
        IP=IPTAB(IROP,IM)
        TEST=TAU*(RADIAN(PHIH(IP,IM)))
        PSIFAC=CEXP(CMPLX(0.,TEST))
C141 Logical FCENT now used to determine whether to set phase shifts
        IF (FCENT(IM)) THEN
          IPP=IPTAB(IROP+NOPC,IM)
          TEST=TAU*(RADIAN(PHIH(IPP,IM)))
          PSIFCC=CEXP(CMPLX(0.,TEST))
        ENDIF
      ENDIF
C  OTRSYM(NOPC+1) SHOULD CONTAIN THE MATRIX RELATING THE MAGNETIC COMPONENTS
C  OF ATOMS RELATED BY THE CENTRE OF SYMMETRY, WHETHER THIS IS IN THE
C  MAGNETIC GROUP OR NOT.
C141 Logic around call to CENDIF and CENTRO simplified because PSIFAC and
C PSICEN are now always set
      IF (CENTRC) THEN
        CALL CENDIF(TVEC,TVEC,TTVEC,TDVEC,OTRSYM(1,1,NOPC+1),
     &               PSIFAC,PSIFCC)
C  DERIVATIVES WITH REPECT TO PHASES
C  WE DO THESE HERE BECAUSE WE NEED THE TERMS BEFORE THE ACTION OF THE CENTRE
        IF (MODUL) THEN
          J=12+IP
          IF (KPHIH(IP,IM) .GT. 0) THEN
            CALL CGMSUB(TTVEC,TDVEC,TTVEC,1,3)
            CALL CGMSCA(TTVEC,TTVEC,CMPLX(0.,RADIAN(TAU)),1,3)
            CALL CGMADD(TDERS(1,J),TTVEC,TDERS(1,J),1,3)
          ENDIF
          IF (FCENT(IM) .AND.KPHIH(IPP,IM) .GT. 0) THEN
            J=12+IPP
            CALL CGMSCA(TDVEC,TDVEC,CMPLX(0.,RADIAN(TAU)),1,3)
            CALL CGMADD(TDERS(1,J),TDVEC,TDERS(1,J),1,3)
          ENDIF
        ENDIF
      ELSE
        IF (MODUL) THEN
          CALL CGMSCA(TVEC,TVEC,PSIFAC,3,1)
          J=12+IP
          IF (KPHIH(IP,IM) .GT. 0) THEN
            CALL CGMSCA(TVEC,TTVEC,CMPLX(0.,RADIAN(TAU)),1,3)
            CALL CGMADD(TDERS(1,J),TTVEC,TDERS(1,J),1,3)
          ENDIF
        ENDIF
      ENDIF
      CALL CGMADD(SUM1,TVEC,SUM1,1,3)
C
C NOW WE DO THE INNERMOST SUMS FOR THE DERIVATIVES OF FMCMOD WRT
C VARIABLES XYZ AND ALL BIJ.  WE USE THE
C COMPLEX VECTOR DERIVM TO ACCUMULATE THE DERIVATIVES OF THE REAL &
C IMAGINARY PARTS OF THE COMPLEX FC WRT EACH VARIABLE IN TURN.
C
C TDERS IS USED FOR THOSE PARTS WHICH MUST BE ACCUMULATED SEPARATELY
C FOR THE TWO COMPONENTS OF A SPIRAL
C
      DO 7 I=1,3
      IF (KX(I,IR) .GT. 0) THEN
        CALL C1MSCA(RS,TVEC,RH(I)*CMPLX(-BRS,ARS),3,1)
        IF (CENTRC) THEN
          CALL CENTRO(TVEC,TVEC,OTRSYM(1,1,NOPC+1),PSIFAC,PSIFCC)
        ELSE
          IF (MODUL) CALL CGMSCA(TVEC,TVEC,PSIFAC,3,1)
        ENDIF
        CALL CGMADD(TDERS(1,I),TVEC,TDERS(1,I),1,3)
      ENDIF
   7  CONTINUE
C
C JUMP IF NOT ATF AT ALL:
      IA=IAPT(IR)
      IF (IA .EQ. 0) GO TO 6
      IF (KATF(1,IA) .GT. 0) THEN
        CALL C1MSCA(RS,TVEC,RH(1)*RH(1)*TERM,3,1)
        IF (CENTRC) THEN
          CALL CENTRO(TVEC,TVEC,OTRSYM(1,1,NOPC+1),PSIFAC,PSIFCC)
        ELSE
          IF (MODUL) CALL CGMSCA(TVEC,TVEC,PSIFAC,3,1)
        ENDIF
        CALL CGMADD(TDERS(1,4),TVEC,TDERS(1,4),1,3)
      ENDIF
      IF (KATF(2,IA) .GT. 0) THEN
        CALL C1MSCA(RS,TVEC,RH(2)*RH(2)*TERM,3,1)
        IF (CENTRC) THEN
          CALL CENTRO(TVEC,TVEC,OTRSYM(1,1,NOPC+1),PSIFAC,PSIFCC)
        ELSE
          IF (MODUL) CALL CGMSCA(TVEC,TVEC,PSIFAC,3,1)
        ENDIF
        CALL CGMADD(TDERS(1,5),TVEC,TDERS(1,5),1,3)
      ENDIF
      IF (KATF(3,IA) .GT. 0) THEN
        CALL C1MSCA(RS,TVEC,RH(3)*RH(3)*TERM,3,1)
        IF (CENTRC) THEN
          CALL CENTRO(TVEC,TVEC,OTRSYM(1,1,NOPC+1),PSIFAC,PSIFCC)
        ELSE
          IF (MODUL) CALL CGMSCA(TVEC,TVEC,PSIFAC,3,1)
        ENDIF
        CALL CGMADD(TDERS(1,6),TVEC,TDERS(1,6),1,3)
      ENDIF
      IF (KATF(4,IA) .GT. 0) THEN
        CALL C1MSCA(RS,TVEC,RH(3)*RH(2)*TERM,1,3)
        IF (CENTRC) THEN
          CALL CENTRO(TVEC,TVEC,OTRSYM(1,1,NOPC+1),PSIFAC,PSIFCC)
        ELSE
          IF (MODUL) CALL CGMSCA(TVEC,TVEC,PSIFAC,3,1)
        ENDIF
        CALL CGMADD(TDERS(1,7),TVEC,TDERS(1,7),1,3)
      ENDIF
      IF (KATF(5,IA) .GT. 0) THEN
        CALL C1MSCA(RS,TVEC,RH(1)*RH(3)*TERM,3,1)
        IF (CENTRC) THEN
          CALL CENTRO(TVEC,TVEC,OTRSYM(1,1,NOPC+1),PSIFAC,PSIFCC)
        ELSE
          IF (MODUL) CALL CGMSCA(TVEC,TVEC,PSIFAC,3,1)
        ENDIF
        CALL CGMADD(TDERS(1,8),TVEC,TDERS(1,8),1,3)
      ENDIF
      IF (KATF(6,IA) .GT. 0) THEN
        CALL C1MSCA(RS,TVEC,RH(1)*RH(2)*TERM,3,1)
        IF (CENTRC) THEN
          CALL CENTRO(TVEC,TVEC,OTRSYM(1,1,NOPC+1),PSIFAC,PSIFCC)
        ELSE
          IF (MODUL) CALL CGMSCA(TVEC,TVEC,PSIFAC,3,1)
        ENDIF
        CALL CGMADD(TDERS(1,9),TVEC,TDERS(1,9),1,3)
      ENDIF
C NOW DERIVATIVES FOR ORIENTATION PARS
    6 DO 14 I=1,2
      L=KANGM(IC+I,IM)
      IF (L .GT. 0) THEN
        CALL C1MSCA(RS(1,I+1),TVEC,TERM,1,3)
        IF (CENTRC) THEN
          CALL CENTRO(TVEC,TVEC,OTRSYM(1,1,NOPC+1),PSIFAC,PSIFCC)
        ELSE
          IF (MODUL) CALL CGMSCA(TVEC,TVEC,PSIFAC,3,1)
        ENDIF
        CALL CGMADD(DERIVM(1,L-LO),TVEC,DERIVM(1,L-LO),1,3)
      ENDIF
   14 CONTINUE
C
C INCREMENT COUNT OF OPERATORS USED
      NOPU=NOPU+1
   3  CONTINUE
C END OF INNERMOST CYCLE OVER SYMMETRY
C
C  SET UP THE PHASE SHIFTS FOR EACH COMPONENT
      IF (ICOMP.EQ.1) THEN
        CFAC=CMPLX(1.,0.)
      ELSE
C4.03 Sign of TAU changed to match FMCALC
        CFAC=CMPLX(0.,TAU)
      ENDIF
      CFAC=CFAC*AMULT(IR)*EXP(-(TF(IR)*SSQRD))
C COMPENSATE FOR NOT USING ALL SYMMETRY ELEMENTS
      FACTOR=FLOAT(NOPC)/FLOAT(NOPU)
      CFAC=CFAC*FACTOR
C SCALE MOMENT TO CMS-12
      SM=SMOD(ICOMP,IM)*VALMUB
      HR=CFAC*FORM*SITE(IR)*SM
C HR IS PRODUCT OF ATOM DEPENDENT BUT SYMMETRY INDEPENDENT FACTORS
      CALL CGMSCA(SUM1,TVEC,HR,3,1)
      CALL CGMADD(FMC,TVEC,FMC,1,3)
C
C  NOW WE TIDY UP THE XYZ AND BIJ DERIVATIVES, AND MAKE ITF, SITE
C  AND MU
      DO 8 I=1,3
      IF (KX(I,IR) .GT. 0)
     & CALL CGMSCA(TDERS(1,I),TDERS(1,I),TWOPI*HR,3,1)
      IF (IA .GT. 0) THEN
        IF (KATF(I,IA) .GT. 0)
     &  CALL CGMSCA(TDERS(1,I+3),TDERS(1,I+3),-HR,3,1)
        IF (KATF(I+3,IA) .GT. 0)
     &  CALL CGMSCA(TDERS(1,I+6),TDERS(1,I+6),-(HR*2.),3,1)
      ENDIF
   8  CONTINUE
C
C SKIP SCAT (PARAMETER 10)
      IF (KSITE(IR) .GT. 0)
     & CALL CGMSCA(SUM1,TDERS(1,11),FORM*CFAC*SM,3,1)
      IF (KTF(IR) .GT. 0)
     & CALL CGMSCA(SUM1,TDERS(1,12),-(SSQRD*HR),3,1)
C RESCALE PSI DERIVATIVES
      DO 17 I=1,NPSI
      J=12+I
      IF (KPHIH(I,IM) .GT. 0) CALL CGMSCA(TDERS(1,J),TDERS(1,J),HR,3,1)
   17 CONTINUE
C RESCALE ORIENTATION DERIVATIVES
      DO 19 I=1,2
      L=KANGM(IC+I,IM)
      IF (L .GT. 0) CALL CGMSCA(DERIVM(1,L-LO),DERIVM(1,L-LO),HR,3,1)
   19 CONTINUE
C DERIVATIVES WITH RESPECT TO MUS
      L=KSMOD(ICOMP,IM)
      IF (L .GT. 0) THEN
        TEMP=HR/SMOD(ICOMP,IM)
        CALL CGMSCA(SUM1,DERIVM(1,L-LO),TEMP,3,1)
      ENDIF
C ADD THE TWO COMPONENTS (BUT NOT FOR ANGM OR SMOD):
C (IS THIS WHY THE PSIS ARE 13,14,15 . . ?)
      DO 9 I=1,16
C FOR THE MOMENT, LMAGPR IS A FUNCTION.  WHEN THINGS HAVE SETTLED DOWN IT CAN
C BE AN ARRAY, FOR SPEED.
      L=LMAGPR(I,IM,IR)
      IF (L.GT.0)
     & CALL CGMADD(TDERS(1,I),DERIVM(1,L-LO),DERIVM(1,L-LO),3,1)
    9 CONTINUE
   30 CONTINUE
C END OF A CYCLE OVER 1,2 IF IHELIX=2
C
   1  CONTINUE
C END OF CYCLE OVER ATOMIC POSITIONS
C
C     COMPENSATE FOR THE MULTIPLICITY OF THE STAR
      CALL CMRSCA(FMC,FMC,FKSTAR,3,1)
C
C NOW THE CYCLE FOR THE DOMAIN AVERAGE
   18 IF (IDOMOP .EQ.1 .OR. FERO) CALL MAGDOM(H,HD,IDOMOP,SKIP)
C134 Skip rotation for FERA  removed C4.1
C      IF (FERA) THEN
C        CALL CGMEQ(FMC,P,3,1)
C      ELSE
        CALL RCMPRD(HD,FMC,P,3,3,1)
C      ENDIF
      FMCSQR=FMCSQR+RSCALP(P,P)
      IF (.NOT.SKIP) ND=ND+1
      IF (FERO) THEN
C  PUT Q BACK INTO UNROTATED FRAME
        CALL CROTO(P,Q(1,ND),IS,1)
      ELSE
        CALL CGMEQ(P,Q(1,ND),3,1)
      ENDIF
C
C  TEST OUTPUT
      IF (IOUT.GT.100) WRITE (LPT,4000) ND,P
 4000 FORMAT (/' Q for domain',I2,4X,3(2F8.4,2X))
C
C WORK OVER ALL MAGNETIC ATOMS GETTING MODULI OF DERIVATIVES
      DO 16 IM=1,NMAG
      IR=JMAGAT(IM)
      DO 16 IP=1,22
      L=LMAGPR(IP,IM,IR)
      IF (L .EQ. 0) GO TO 16
      LL=L-LO
C134 Skip rotation for FERA  removed C4.1
C      IF (FERA) THEN
C        CALL CGMEQ(DERIVM(1,LL),TVEC,3,1)
C      ELSE
        CALL RCMPRD(HD,DERIVM(1,LL),TVEC,3,3,1)
C      ENDIF
      FMCDER(LL)=FMCDER(LL)+RSCALP(P,TVEC)
      IF (FERO) THEN
C  DERIVATIVES INTO UNROTATED FRAME
        CALL CROTO(TVEC,TTVEC,IS,-1)
      ELSE
        CALL CGMEQ(TVEC,TTVEC,3,1)
      ENDIF
      CALL CMRSCA(TTVEC,FQCDER(1,ND,LL),FKSTAR,3,1)
C  TEST OUTPUT
      IF (BINDIG(IOUT,128)) WRITE (LPT,4001) L,(FQCDER(I,ND,LL),I=1,3)
 4001 FORMAT (' dQ/dp for p=',I2,4X,3(2F8.4,2X))
   16 CONTINUE
C4.1 Only a single domain if FERA
      IF (FERA) GO TO 21
C
   15 CONTINUE
C
C  END OF THE DOMAIN LOOP, DO THE DOMAIN AVERAGE
C  DIVIDE BY NDOM AS REQUIRED AND RETURN Fm*DFm/DPar IN FMCDER
   21 DO 20 IM=1,NMAG
      IR=JMAGAT(IM)
      DO 20 IP=1,22
      L=LMAGPR(IP,IM,IR)
      IF (L.EQ.0) GO TO 20
      LL=L-LO
      FMCDER(LL)=FKSTAR*FMCDER(LL)/FLOAT(ND)
C  TEST OUTPUT
      IF (BINDIG(IOUT,64)) WRITE (LPT,4002) L,FMCDER(LL)
 4002 FORMAT (' Fm*dFm/dp for p=',I2,4X,3(2E12.4,2X))
   20 CONTINUE
C
      FMCSQR=FMCSQR/FLOAT(ND)
      FMCMOD=SQRT(FMCSQR)
C
 100  RETURN
      END
C
C
C
C
C LEVEL 7      SUBROUTINE LMMPCA(H)
      SUBROUTINE LMMPCA(H)
C
C *** LMMPCA updated by PJB C128 Feb 2004***
C
CX
CC 18B
CH Calculates magnetic structure factor and its derivatives using
CH multipole description of the form factors.
CA On entry H is the 1x3 vector containing h,k,l
CP RECIP, SYMOP, SETANI, SETFOR and DOMAG1 must have been obeyed to set up
CP the structure factor calculation. (They are all called by SETFCM)
CP The LSQ environment must have been set up by a suitable MAIN program (like
CP MPLSQ) which has called LSETUP and VARMAK.
CP
CD On exit, in /MCAL/:
CD    FMCMOD = modulus of FMC
CD    FMCSQR = squared modulus of FMC
CD    FMCDER is an array containing the derivatives of FMCMOD wrt the family
CD           2 (structure) and family 5 (multipole) parameters, ALL
CD           MULTIPLIED BY FMCMOD.
CD    (Note the difference from the specification of LFCALC's derivatives)
CD    FVCDER is an array containing the derivatives of FMC with respect to
CD           all the family 2 parameters.
CD
CD On exit, in /QCAL/:
CD    Q is an array containing the magnetic interaction vectors for each domain
CD      in general there will be NDOM*KCENT domains
CD On exit, in /QCALD/:
CD    FQCDER is an array containing the derivatives of the Q's with respect to
CD           all the family 2 parameters.
CD
CD All the above will be zero if h,k,l is a magnetic absence
CN Note the existence also of LFCALC (nuclear structure factors for LSQ)
CN                            FMCALC (magnetic structure factors)
CN                            FCALC  (nuclear structure factors)
CN                            LMCALC (magnetic structure factors for  LSQ)
C
       COMPLEX DERIVM,SUM1(3),TERM,TVEC(3),HR,P(3),TEMP,TERVEC(3)
       COMPLEX CFAC,PSIFAC,PSIFCC,TDERS(3,16),TTVEC(3),TDVEC(3)
       COMPLEX FMC(3),PFACS(50),TERMF,PSUM,FORMFA
       LOGICAL SKIP,MAGABS,BINDIG
%      DIMENSION DERIVM(3,%F2VA%),RH(3),H(3),RS(3,3),HD(3,3),SDOM(3,3)
/ANISO/
/BRAGG/
/CONSTA/
/DERVAR/
/FORMDA/
/IOUNIT/
/MAGDAT/
/MCAL/
/MPODA/
/MPODAC/
/NSYM/
/PHASE/
/POINTS/
/POLFOR/
/POLDA/
/POSNS/
/PRBLEM/
/QCAL/
/QCALD/
/SATELL/
/SYMDA/
/SYMMAG/
/SYMTAB/
%      DATA NPSI/%PSIS%/
C
C CLEAR ALL ANSWERS IN CASE ABSENT:
C
C CLEAR MODULUS AND SQUARE:
      FMCMOD=0.
      FMCSQR=0.
C SIN THETA/LAMBDA
      STHL=VCTMOD(0.5,H,2)
      SSQRD=STHL*STHL
C
C CLEAR DERIVATIVES:
      L2=NVARF(2,1,1)
      L25=L2+NVARF(5,1,1)
      IF (L25 .GT. 0) THEN
        CALL GMZER(FMCDER,1,L25)
        DO 88 I=1,L25
        DO 88 J=1,3
  88    DERIVM(J,I)=CMPLX(0.,0.)
      ENDIF
C
C OUT IF ABSENT:
      IF (MAGABS(H,IK)) GO TO 100
      TAU=-FLOAT(IK)
C
C  CYCLE OVER DOMAINS
      ND=0
      IHELIX=1
      IF (HELI) IHELIX=2
      SKIP=.FALSE.
      DO 15 IDOMOP=1, NOPC
      IF ((FERO .OR. FERA).AND. IDOMOP .NE.1) GO TO 18
C DOMAINS EXIST FOR ALL ELEMENTS NOT IN THE MAGNETIC GROUP
C WE MUST ONLY USE OPERATORS BELONGING TO THE CURRENT DOMAIN
      IF (IDOMOP.NE.1 .AND. IABS(MSTAB(IDOMOP)).NE.IDOMOP) GO TO 15
C FMC COLLECTS THE MAGNETIC STRUCTURE FACTOR, A COMPLEX VECTOR,
C ZEROED BEFORE CALCULATING THE VALUE FOR EACH DOMAIN
      CALL CGMZER(FMC,1,3)
C
C OFFSETS TO REACH FAMILY 2 & FAMILY 5 VARIABLES (ASSUMED CONSECUTIVE):
      LO=LVFST1(2,1,1)
      IF (LO .EQ. -1) LO=LVFST1(5,1,1)
      LO5=LO+L2
C
C CYCLE OVER MAGNETIC ATOMS:
      DO 1 IM=1,NMAG
      IR=JMAGAT(IM)
      CALL CGMZER(SUM1,3,1)
C
C128 get the multipole form factor number for this atom
      IMPFOR =MPFOR(NMFORM(IM))
C  SET MP TO THE MULTIPOLE ATOM AND NMP1, NMP2 TO SCAN ITS MULTIPOLES:
      MP=MPNMTB(IR)
      IF (MP.EQ.0) THEN
        NMP1=0
        NMP2=-1
C128 form factors for non-multipole atoms
        IF (IMPFOR .NE.0 .AND. MPLFOR(1,IMPFOR).EQ.-999) THEN
          AKK = FOURPI*STHL
          PSUM=FORMFC(AKK,0,0,NMFORM(IM))
        ELSE
          PSUM=FORMFA(STHL,NMFORM(IM))
        ENDIF
      ELSE
        NMP1=MPTAB(MP)
        NMP2=MPTAB(MP+1)-1
C128 RADIAL FORM FACTORS: only for multipole atoms
        CALL PFORMF(H,MP,PSUM,PFACS,0)
      ENDIF
C
C CYCLE OVER COMPONENTS OF HELIX
      DO 30 ICOMP=1,IHELIX
      CALL CGMZER(SUM1,3,1)
      CALL CGMZER(TDERS,3,16)
C IF IHELIX=1, THIS ONLY EVER DOES IC=0, & REFERS TO SPECIES 17 & 18 FOR ANGM,
C AND SPECIES 21 FOR SMOD(1)
C IF IHELIX=2, IC IS FIRST 0 (SPECIES 17 & 18) THEN 2 (SPECIES 19 & 20) FOR
C ANGM, AND SPECIES 21 THEN 22 FOR SMOD(1) THEN SMOD(2)
      IC=2*(ICOMP-1)
C
C PREPARE TO COUNT OPERATORS USED
      NOPU=0
C SYMMETRY CYCLE OVER SYMMETRIC AND NON-SYMMETRIC ROTATIONS:
      DO 3 IS=1,NOPC
C ONLY USE OPERATORS WHICH LEAVE THE PROPAGATION DIRECTION INVARIANT
      IF (IS.NE.1 .AND. IABS(KSTAB(IS)).NE.1) GO TO 3
C THE OPERATOR TO USE IS THE PRODUCT OF'IS' WITH THAT CREATING THE DOMAIN
      IROP=MULTAB(IDOMOP,IS)
      IF (MODUL) THEN
C INSYM IS THE NUMBER OF THE CO-SET ELEMENT INVOLVED (FROM THE CO-SET NSYM)
C IT MAY BE NEGATIVE IF INVERSION IS INCLUDED
        IF (IROP.EQ.1) THEN
          INSYM=1
        ELSE
          INSYM=MSTAB(IROP)
        ENDIF
C ISBGN IS THE NUMBER OF THE SUBLATTICE GENERATED BY INSYM
        ISBGN=IPTAB(IABS(INSYM),IM)
C THE NUMBBERS IN LPHI MAY ALSO BE NEGATIVE IF INVERSION IS INVOLVED
C SKIP IF IROP DOESN'T GENERATE A DISTINCT SUB-LATTICE
        IF (LPHI(ISBGN,IM).NE.INSYM) GO TO 3
      ENDIF
      CALL ROTSYM(H,RH,IROP,-1)
      IF (IDOMOP.NE.1 .AND. MSTAB(IDOMOP).LT.0) CALL GMREV(RH,RH,3,1)
C128  NON-SPHERICAL FORM FACTORS: only for multipole atoms
      IF (MP .NE.0) CALL PFORMF(RH,MP,PSUM,PFACS,1)
C ANISOTROPIC T F (=1. IF NOT THERE) NEEDED SEPARATELY FOR LSQ:
      F1=TWOPI*(SCALPR(X(1,IR),RH)+SCALPR(TRANS(1,IROP),H))
      ERS=ANITF(RH,IR)
      ARS=COS(F1)*ERS
      BRS=SIN(F1)*ERS
      TERM=CMPLX(ARS,BRS)
C APPLY FORM FACTOR HERE (IN SIMPLER APPLICATIONS IT IS OUTSIDE THE
C SYMMETRY LOOP):
      TERMF=TERM*PSUM
      IF (FERA ) THEN
C4.1 FOR FERA THE SPIN IS PARALLEL TO THE POLARISATION
         CALL GMEQ(POLND,RS,3,1)
C4.1 THE DERIVATIVE PARTS SET TO ZERO (CAN'T REFINE ORIENTATION)
         CALL GMZER(RS(1,2),3,2)
      ELSE
C  FIND OUT WHAT THE SYMMETRY DOES TO THE SPIN DIRECTION
        CALL ROTMAG(SPIND(1,1,1,IM),SDOM,IS)
C  GET THE SPIN DIRECTION FOR THIS DOMAIN
        DO 2 I=1,3
    2   CALL ROTOSM(SDOM(1,I),RS(1,I),IDOMOP,1)
      ENDIF
      CALL C1MSCA(RS,TERVEC,TERM,3,1)
      CALL CGMSCA(TERVEC,TVEC,PSUM,3,1)
      PSIFAC=CMPLX(1.,0)
      PSIFCC=CMPLX(1.,0)
      IF (MODUL) THEN
C INCLUDE A PHASE SHIFT FOR THIS SUB-LATTICE IF NECESSARY
        IP=IPTAB(IROP,IM)
        TEST=TAU*(RADIAN(PHIH(IP,IM)))
        PSIFAC=CEXP(CMPLX(0.,TEST))
        IF (FCENT(IM)) THEN
          IPP=IPTAB(IROP+NOPC,IM)
          TEST=TAU*(RADIAN(PHIH(IPP,IM)))
          PSIFCC=CEXP(CMPLX(0.,TEST))
        ENDIF
      ENDIF
C  OTRSYM(NOPC+1) SHOULD CONTAIN THE MATRIX RELATING THE MAGNETIC COMPONENTS
C  OF ATOMS RELATED BY THE CENTRE OF SYMMETRY, WHETHER THIS IS IN THE
C  MAGNETIC GROUP OR NOT.
      IF (CENTRC) THEN
        CALL CENDIF(TVEC,TVEC,TTVEC,TDVEC,OTRSYM(1,1,NOPC+1),
     &               PSIFAC,PSIFCC)
C  DERIVATIVES WITH REPECT TO PHASES
C  WE DO THESE HERE BECAUSE WE NEED THE TERMS BEFORE THE ACTION OF THE CENTRE
        IF (MODUL) THEN
          J=12+IP
          IF (KPHIH(IP,IM) .GT. 0) THEN
            CALL CGMSUB(TTVEC,TDVEC,TTVEC,1,3)
            CALL CGMSCA(TTVEC,TTVEC,CMPLX(0.,RADIAN(TAU)),1,3)
            CALL CGMADD(TDERS(1,J),TTVEC,TDERS(1,J),1,3)
          ENDIF
          IF (FCENT(IM) .AND.KPHIH(IPP,IM) .GT. 0) THEN
            J=12+IPP
            CALL CGMSCA(TDVEC,TDVEC,CMPLX(0.,RADIAN(TAU)),1,3)
            CALL CGMADD(TDERS(1,J),TDVEC,TDERS(1,J),1,3)
          ENDIF
        ENDIF
      ELSE
        IF (MODUL) THEN
          CALL CGMSCA(TVEC,TVEC,PSIFAC,3,1)
          J=12+IP
          IF (KPHIH(IP,IM) .GT. 0) THEN
            CALL CGMSCA(TVEC,TTVEC,CMPLX(0.,RADIAN(TAU)),1,3)
            CALL CGMADD(TDERS(1,J),TTVEC,TDERS(1,J),1,3)
          ENDIF
        ENDIF
      ENDIF
      CALL CGMADD(SUM1,TVEC,SUM1,1,3)
C
C NOW WE DO THE INNERMOST SUMS FOR THE DERIVATIVES OF FMCMOD WRT
C VARIABLES XYZ AND ALL BIJ.  WE USE THE
C COMPLEX VECTOR DERIVM FOR THE DERIVATIVES OF THE REAL & IMAGINARY PARTS
C OF THE COMPLEX FMC WRT EACH VARIABLE IN TURN.
C
C TDERS IS USED FOR THOSE PARTS WHICH MUST BE ACCUMULATED SEPARATELY
C FOR THE TWO COMPONENTS OF A SPIRAL
C
      DO 7 I=1,3
      IF (KX(I,IR) .GT. 0) THEN
        CALL C1MSCA(RS,TVEC,RH(I)*CMPLX(-BRS,ARS),3,1)
        IF (CENTRC) THEN
          CALL CENTRO(TVEC,TVEC,OTRSYM(1,1,NOPC+1),PSIFAC,PSIFCC)
        ELSE
          IF (MODUL) CALL CGMSCA(TVEC,TVEC,PSIFAC,3,1)
        ENDIF
        CALL CGMADD(TDERS(1,I),TVEC,TDERS(1,I),1,3)
      ENDIF
   7  CONTINUE
C
C JUMP IF NOT ATF AT ALL:
      IA=IAPT(IR)
      IF (IA .EQ. 0) GO TO 6
      IF (KATF(1,IA) .GT. 0) THEN
        CALL C1MSCA(RS,TVEC,RH(1)*RH(1)*TERMF,3,1)
        IF (CENTRC) THEN
          CALL CENTRO(TVEC,TVEC,OTRSYM(1,1,NOPC+1),PSIFAC,PSIFCC)
        ELSE
          IF (MODUL) CALL CGMSCA(TVEC,TVEC,PSIFAC,3,1)
        ENDIF
        CALL CGMADD(TDERS(1,4),TVEC,TDERS(1,4),1,3)
      ENDIF
      IF (KATF(2,IA) .GT. 0) THEN
        CALL C1MSCA(RS,TVEC,RH(2)*RH(2)*TERMF,3,1)
        IF (CENTRC) THEN
          CALL CENTRO(TVEC,TVEC,OTRSYM(1,1,NOPC+1),PSIFAC,PSIFCC)
        ELSE
          IF (MODUL) CALL CGMSCA(TVEC,TVEC,PSIFAC,3,1)
        ENDIF
        CALL CGMADD(TDERS(1,5),TVEC,TDERS(1,5),1,3)
      ENDIF
      IF (KATF(3,IA) .GT. 0) THEN
        CALL C1MSCA(RS,TVEC,RH(3)*RH(3)*TERMF,3,1)
        IF (CENTRC) THEN
          CALL CENTRO(TVEC,TVEC,OTRSYM(1,1,NOPC+1),PSIFAC,PSIFCC)
        ELSE
          IF (MODUL) CALL CGMSCA(TVEC,TVEC,PSIFAC,3,1)
        ENDIF
        CALL CGMADD(TDERS(1,6),TVEC,TDERS(1,6),1,3)
      ENDIF
      IF (KATF(4,IA) .GT. 0) THEN
        CALL C1MSCA(RS,TVEC,RH(3)*RH(2)*TERMF,1,3)
        IF (CENTRC) THEN
          CALL CENTRO(TVEC,TVEC,OTRSYM(1,1,NOPC+1),PSIFAC,PSIFCC)
        ELSE
          IF (MODUL) CALL CGMSCA(TVEC,TVEC,PSIFAC,3,1)
        ENDIF
        CALL CGMADD(TDERS(1,7),TVEC,TDERS(1,7),1,3)
      ENDIF
      IF (KATF(5,IA) .GT. 0) THEN
        CALL C1MSCA(RS,TVEC,RH(1)*RH(3)*TERMF,3,1)
        IF (CENTRC) THEN
          CALL CENTRO(TVEC,TVEC,OTRSYM(1,1,NOPC+1),PSIFAC,PSIFCC)
        ELSE
          IF (MODUL) CALL CGMSCA(TVEC,TVEC,PSIFAC,3,1)
        ENDIF
        CALL CGMADD(TDERS(1,8),TVEC,TDERS(1,8),1,3)
      ENDIF
      IF (KATF(6,IA) .GT. 0) THEN
        CALL C1MSCA(RS,TVEC,RH(1)*RH(2)*TERMF,3,1)
        IF (CENTRC) THEN
          CALL CENTRO(TVEC,TVEC,OTRSYM(1,1,NOPC+1),PSIFAC,PSIFCC)
        ELSE
          IF (MODUL) CALL CGMSCA(TVEC,TVEC,PSIFAC,3,1)
        ENDIF
        CALL CGMADD(TDERS(1,9),TVEC,TDERS(1,9),1,3)
      ENDIF
C
C FOR MAGNETIC MULTIPOLES, FORM CALCULATIONS ARE WITHIN SYMMETRY CYCLE:
** IS THIS RIGHT HERE?
      L=KCMULT(IR)
      IF (L.GT.0) CALL CGMADD(DERIVM(1,L-LO),TERVEC,DERIVM(1,L-LO),1,3)
C
C NOW DERIVATIVES FOR ORIENTATION PARS
    6 DO 14 I=1,2
      L=KANGM(IC+I,IM)
      IF (L .GT. 0) THEN
        CALL C1MSCA(RS(1,I+1),TVEC,TERMF,1,3)
        IF (CENTRC) THEN
          CALL CENTRO(TVEC,TVEC,OTRSYM(1,1,NOPC+1),PSIFAC,PSIFCC)
        ELSE
          IF (MODUL) CALL CGMSCA(TVEC,TVEC,PSIFAC,3,1)
        ENDIF
        CALL CGMADD(DERIVM(1,L-LO),TVEC,DERIVM(1,L-LO),1,3)
      ENDIF
   14 CONTINUE
C
C NOW MULTIPOLES:
      DO 21 I=NMP1,NMP2
      L=KPOLMP(I)
      IF (L.GT.0) THEN
        CALL CGMSCA(TERVEC,TVEC,PFACS(I-NMP1+1),1,3)
        IF (CENTRC) THEN
          CALL CENTRO(TVEC,TVEC,OTRSYM(1,1,NOPC+1),PSIFAC,PSIFCC)
        ELSE
          IF (MODUL) CALL CGMSCA(TVEC,TVEC,PSIFAC,3,1)
        ENDIF
C4.1 replace LO5 by LO
        CALL CGMADD(DERIVM(1,L-LO),TVEC,DERIVM(1,L-LO),1,3)
      ENDIF
  21  CONTINUE
C
C INCREMENT COUNT OF OPERATORS USED
      NOPU=NOPU+1
   3  CONTINUE
C END OF INNERMOST CYCLE OVER SYMMETRY
C
C  SET UP THE PHASE SHIFTS FOR EACH COMPONENT
      IF (ICOMP.EQ.1) THEN
        CFAC=CMPLX(1.,0.)
      ELSE
        CFAC=CMPLX(0.,-TAU)
      ENDIF
      CFAC=CFAC*AMULT(IR)*EXP(-(TF(IR)*SSQRD))
C COMPENSATE FOR NOT USING ALL SYMMETRY ELEMENTS
      FACTOR=FLOAT(NOPC)/FLOAT(NOPU)
      CFAC=CFAC*FACTOR
C
C SCALE MOMENT TO CMS-12
      SM=SMOD(ICOMP,IM)*VALMUB
C HR FOR MAGNETIC MULTIPOLES DOES NOT CONTAIN FORM, WHICH IS ALREADY
C IN PSUM (IN SUM1 AND ALL DERIVM FOR FAMILY 2 SO FAR)
      HR=CFAC*SITE(IR)*SM
C HR IS PRODUCT OF ATOM DEPENDENT BUT SYMMETRY INDEPENDENT FACTORS
      CALL CGMSCA(SUM1,TVEC,HR,3,1)
      CALL CGMADD(FMC,TVEC,FMC,1,3)
C
C  NOW WE TIDY UP THE XYZ AND BIJ DERIVATIVES, AND MAKE ITF, SITE
C  AND MU
      DO 8 I=1,3
      IF (KX(I,IR) .GT. 0)
     &CALL CGMSCA(TDERS(1,I),TDERS(1,I),TWOPI*HR,3,1)
      IF (IA .GT. 0) THEN
        IF (KATF(I,IA) .GT. 0)
     &CALL CGMSCA(TDERS(1,I+3),TDERS(1,I+3),-HR,3,1)
        IF (KATF(I+3,IA) .GT. 0)
     &CALL CGMSCA(TDERS(1,I+6),TDERS(1,I+6),-(HR*2.),3,1)
      ENDIF
   8  CONTINUE
C
C DERIV FOR FORM FACTOR (IN THIS APPLICATION ONLY, HAS BEEN STARTED
C WITHIN SYMMETRY CYCLE):
      L=KCMULT(IR)
      IF (L.GT.0) THEN
        CALL CGMSCA(DERIVM(1,L-LO),DERIVM(1,L-LO),HR,3,1)
        IF (CENTRC) THEN
          CALL CMCONJ(DERIVM(1,L-LO),TVEC,1,3)
          CALL RCMPRD(OTRSYM(1,1,NOPC+1),TVEC,P,3,3,1)
          CALL CGMADD(DERIVM(1,L-LO),P,DERIVM(1,L-LO),1,3)
        ENDIF
      ENDIF
C
C SKIP SCAT (PARAMETER 10)
      IF (KSITE(IR) .GT. 0)
     &CALL CGMSCA(SUM1,TDERS(1,11),CFAC*SM,3,1)
      IF (KTF(IR) .GT. 0)
     &CALL CGMSCA(SUM1,TDERS(1,12),-(SSQRD*HR),3,1)
C RESCALE PSI DERIVATIVES
      DO 17 I=1,NPSI
      J=12+I
      IF (KPHIH(I,IM) .GT. 0) CALL CGMSCA(TDERS(1,J),TDERS(1,J),HR,3,1)
   17 CONTINUE
C RESCALE ORIENTATION DERIVATIVES
      DO 19 I=1,2
      L=KANGM(IC+I,IM)
      IF (L .GT. 0) CALL CGMSCA(DERIVM(1,L-LO),DERIVM(1,L-LO),HR,3,1)
   19 CONTINUE
C DERIVATIVES WITH RESPECT TO MUS
      L=KSMOD(ICOMP,IM)
      IF (L .GT. 0) THEN
        TEMP=HR/SMOD(ICOMP,IM)
        CALL CGMSCA(SUM1,DERIVM(1,L-LO),TEMP,3,1)
      ENDIF
C
C MULTIPOLE DERIVATIVES:
      DO 22 I=NMP1,NMP2
      L=KPOLMP(I)
      IF (L.GT.0) THEN
C4.1        CALL CGMSCA(DERIVM(1,L-LO5),DERIVM(1,L-LO5),HR,3,1)
        CALL CGMSCA(DERIVM(1,L-LO),DERIVM(1,L-LO),HR,3,1)
      ENDIF
  22  CONTINUE
C
C ADD THE TWO COMPONENTS (BUT NOT FOR ANGM OR SMOD):
C (IS THIS WHY THE PSIS ARE 13,14,15 . . ?)
      DO 9 I=1,16
C FOR THE MOMENT, LMAGPR IS A FUNCTION.  WHEN THINGS HAVE SETTLED DOWN IT CAN
C BE AN ARRAY, FOR SPEED.
      L=LMAGPR(I,IM,IR)
      IF (L.GT.0)
     &CALL CGMADD(TDERS(1,I),DERIVM(1,L-LO),DERIVM(1,L-LO),3,1)
    9 CONTINUE
   30 CONTINUE
C END OF A CYCLE OVER 1,2 IF IHELIX=2
C
   1  CONTINUE
C END OF CYCLE OVER ATOMIC POSITIONS
C
C     COMPENSATE FOR THE MULTIPLICITY OF THE STAR
      CALL CMRSCA(FMC,FMC,FKSTAR,3,1)
C
C NOW THE CYCLE FOR THE DOMAIN AVERAGE
C
   18 IF (IDOMOP .EQ.1 .OR. FERO) CALL MAGDOM(H,HD,IDOMOP,SKIP)
C134 Skip rotation for FERA C4.1   revert
C      IF (FERA) THEN
C        CALL CGMEQ(FMC,P,3,1)
C      ELSE
        CALL RCMPRD(HD,FMC,P,3,3,1)
C      ENDIF
      FMCSQR=FMCSQR+RSCALP(P,P)
      IF (.NOT.SKIP) ND=ND+1
      IF (FERO) THEN
C  PUT Q BACK INTO UNROTATED FRAME
        CALL CROTO(P,Q(1,ND),IS,1)
      ELSE
        CALL CGMEQ(P,Q(1,ND),3,1)
      ENDIF
C
C  TEST OUTPUT
      IF (IOUT.GT.100) WRITE (LPT,4000) ND,P
 4000 FORMAT (/' Q for domain',I2,4X,3(2F8.4,2X))
C
C WORK OVER ALL MAGNETIC ATOMS GETTING MODULI OF DERIVATIVES
      DO 16 IM=1,NMAG
      IR=JMAGAT(IM)
C  SET MP TO THE MULTIPOLE ATOM AND NMP1, NMP2 TO SCAN ITS MULTIPOLES:
      MP=MPNMTB(IR)
      IF (MP.EQ.0) THEN
        NMP1=0
        NMP2=-1
      ELSE
        NMP1=MPTAB(MP)
        NMP2=MPTAB(MP+1)-1
      ENDIF
      IPP=22+NMP2-NMP1+1
      LOF=LO
      DO 16 IP=1,IPP
      IF (IP.LE.22) THEN
        L=LMAGPR(IP,IM,IR)
      ELSE IF (IP.EQ.23) THEN
        JP=NMP1
        L=KPOLMP(JP)
        LOF=LO5
       ELSE
        JP=JP+1
        L=KPOLMP(JP)
       ENDIF
      IF (L .EQ. 0) GO TO 16
      LL=L-LO
C134 Skip rotation for FERA  removed C4.1
C      IF (FERA) THEN
C        CALL CGMEQ(DERIVM(1,LL),TVEC,3,1)
C      ELSE
        CALL RCMPRD(HD,DERIVM(1,LL),TVEC,3,3,1)
C      ENDIF
      FMCDER(LL)=FMCDER(LL)+RSCALP(P,TVEC)
      IF (FERO) THEN
C  DERIVATIVES INTO UNROTATED FRAME
        CALL CROTO(TVEC,TTVEC,IS,-1)
      ELSE
        CALL CGMEQ(TVEC,TTVEC,3,1)
      ENDIF
      CALL CMRSCA(TTVEC,FQCDER(1,ND,LL),FKSTAR,3,1)
C  TEST OUTPUT
      IF (BINDIG(IOUT,128)) WRITE (LPT,4001) LL,(FQCDER(I,ND,LL),I=1,3)
 4001 FORMAT (' dQ/dp for p=',I2,4X,3(2F8.4,2X))
   16 CONTINUE
C4.1 Only a single domain if FERA
      IF (FERA) GO TO 31
C
   15 CONTINUE
C
C  END OF THE DOMAIN LOOP, DO THE DOMAIN AVERAGE
C  DIVIDE BY NDOM AS REQUIRED AND RETURN Fm*DFm/DPar IN FMCDER
   31 DO 20 IM=1,NMAG
      IR=JMAGAT(IM)
C  SET MP TO THE MULTIPOLE ATOM AND NMP1, NMP2 TO SCAN ITS MULTIPOLES:
      MP=MPNMTB(IR)
      IF (MP.EQ.0) THEN
        NMP1=0
        NMP2=-1
      ELSE
        NMP1=MPTAB(MP)
        NMP2=MPTAB(MP+1)-1
      ENDIF
      IPP=22+NMP2-NMP1+1
      LOF=LO
      DO 20 IP=1,IPP
      IF (IP.LE.22) THEN
        L=LMAGPR(IP,IM,IR)
      ELSE IF (IP.EQ.23) THEN
        JP=NMP1
        L=KPOLMP(JP)
        LOF=LO5
      ELSE
        JP=JP+1
        L=KPOLMP(JP)
      ENDIF
      IF (L.EQ.0) GO TO 20
      LL=L-LO
      FMCDER(LL)=FKSTAR*FMCDER(LL)/FLOAT(ND)
C  TEST OUTPUT
      IF (BINDIG(IOUT,64)) WRITE (LPT,4002) LL,FMCDER(LL)
 4002 FORMAT (' Fm*dFm/dp for p=',I2,4X,3(2E12.4,2X))
   20 CONTINUE
C
      FMCSQR=FMCSQR/FLOAT(ND)
      FMCMOD=SQRT(FMCSQR)
C
 100  RETURN
      END
C
C
C
C
C LEVEL 7      SUBROUTINE LMPCAL(H)
      SUBROUTINE LMPCAL(H)
C
C *** LMPCAL corrected by PJB C4.1 December 2006 ***
C
CX
CC 7B
CH Calculates a structure factor and its derivatives using a multipole
CH description of the form factors.
CA On entry H is a 1x3 array containing h,k,l
CD On exit in /FCAL/
CD    FC is the complex structure factor
CD    FCMOD is its modulus
CD    COSAL is the cosine of its phase
CD    SINAL is the sine of its phase
CD    FCDERS is an array of derivatives of FCMOD wrt all family 2 (structure
CD           parameters and family 5 (multipole).  These are NOT multiplied
CD           or divided by anything else;  compare LMCALC
CD The above will all be zero if h,k,l gives a lattice absence;  note that
CD such would not be true of FCALC
C
      COMPLEX SUM1,TERM,HR,CRS,PSUM,PFACS(50),FORMFA
      LOGICAL TESTOV,LATABS
      DIMENSION RH(3),H(3)
/ANISO/
/BRAGG/
/CONSTA/
/DERVAR/
/FCAL/
/FORMDA/
/MPODA/
/MPODAC/
/NSYM/
/POINTS/
/POLFOR/
/POSNS/
/PRBLEM/
/SYMDA/
C
C CLEAR ANSWERS IN CASE ABSENT:
C
C  FC COLLECTS THE CONVENTIONAL STRUCTURE FACTOR, COMPLEX:
      FC=CMPLX(0.,0.)
C CLEAR MODULUS AND ANGLES:
      FCMOD=0.
      COSAL=0.
      SINAL=0.
C
C STHL HOLDS SIN THETA/LAMBDA:
      STHL=VCTMOD(0.5,H,2)
      SSQRD=STHL*STHL
C
      L2=NVARF(2,1,1)
      L25=L2+NVARF(5,1,1)
      LO=LVFST1(2,1,1)
      IF (LO .EQ. -1) LO=LVFST1(5,1,1)
      LO5=LO+L2
C CLEAR DERIVATIVES:
      IF (L25.GT.0) THEN
        CALL GMZER(FCDERS,1,L25)
        CALL CGMZER(DERIVT,1,L25)
      ENDIF
C
C OUT IF ABSENT:
      IF (LATABS(H)) GO TO 100
C
C CYCLE OVER INDEPENDENT ATOMS:
      DO 1 IR=1,NATOM
C
C128 get the multipole form factor number for this atom
      IMPFOR =MPFOR(NFORMF(IR))
C  SET MP TO THE MULTIPOLE ATOM AND NMP1, NMP2 TO SCAN ITS MULTIPOLES:
      MP=MPNMTB(IR)
      IF (MP.EQ.0) THEN
        NMP1=0
        NMP2=-1
C128 get form factors for non-multipole atoms
        IF (IMPFOR .NE.0 .AND. MPLFOR(1,IMPFOR).EQ.-999) THEN
          AKK = FOURPI*STHL
          PSUM=FORMFC(AKK,0,0,NFORMF(IR))
        ELSE
          PSUM=FORMFA(STHL,NFORMF(IR))
        ENDIF
      ELSE
        NMP1=MPTAB(MP)
        NMP2=MPTAB(MP+1)-1
C128  CALCULATE RADIAL FORM-FACTORS now only for multipole atoms
        CALL PFORMF(H,MP,PSUM,PFACS,0)
      ENDIF
C
      SUM1=CMPLX(0.,0.)
C
C INNER LOOP OVER SYMMETRY EQUIVALENTS:
      DO 3 IS=1,NOPC
      CALL ROTSYM(H,RH,IS,-1)
C128 CALCULATE NON-SPHERICAL FORM FACTORS now only for multipole atoms
      IF (MP.NE.0) CALL PFORMF(RH,MP,PSUM,PFACS,1)
      F1=TWOPI*(SCALPR(X(1,IR),RH)+SCALPR(TRANS(1,IS),H))
      ERS=ANITF(RH,IR)
C ANISOTROPIC T F (=1. IF NOT THERE) NEEDED SEPARATELY FOR LSQ:
      CRS=CEXP(CMPLX(0.,F1))*ERS
      TERM=CRS*PSUM
      ARS=REAL(TERM)
      BRS=AIMAG(TERM)
      SUM1=SUM1+TERM
C
C  NOW WE DO THE INNERMOST SUMS FOR THE DERIVATIVES OF MODFC WRT
C VARIABLES XYZ AND ALL BIJ.  WE USE THE
C COMPLEX VECTOR DERIVT FOR THE DERIVATIVES OF THE REAL & IMAGINARY PARTS
C OF THE COMPLEX FMC WRT EACH VARIABLE IN TURN.
C
      DO 7 I=1,3
      L=KX(I,IR)
      IF (L .NE. 0) DERIVT(L-LO)=RH(I)*CMPLX(-BRS,ARS) + DERIVT(L-LO)
   7  CONTINUE
C
C IF ANY ATF (NOT A LOOP, FOR SPEED):
      IA=IAPT(IR)
      IF (IA .NE. 0) THEN
        L=KATF(1,IA)
        IF (L.NE.0) DERIVT(L-LO)=RH(1)*RH(1)*TERM + DERIVT(L-LO)
        L=KATF(2,IA)
        IF (L.NE.0) DERIVT(L-LO)=RH(2)*RH(2)*TERM + DERIVT(L-LO)
        L=KATF(3,IA)
        IF (L.NE.0) DERIVT(L-LO)=RH(3)*RH(3)*TERM + DERIVT(L-LO)
        L=KATF(4,IA)
        IF (L.NE.0) DERIVT(L-LO)=RH(3)*RH(2)*TERM + DERIVT(L-LO)
        L=KATF(5,IA)
        IF (L.NE.0) DERIVT(L-LO)=RH(1)*RH(3)*TERM + DERIVT(L-LO)
        L=KATF(6,IA)
        IF (L.NE.0) DERIVT(L-LO)=RH(1)*RH(2)*TERM + DERIVT(L-LO)
      ENDIF
C
C DERIVATIVES OF FORM ("SCAT"):
      L=KCMULT(IR)
C4.1 LO replaces LO5 twice
      IF (L.GT.0) DERIVT(L-LO)=CRS+DERIVT(L-LO)
C
C  DERIVATIVES OF MULTIPOLES:
      DO 21 I=NMP1,NMP2
      L=KPOLMP(I)
      IF (L.GT.0) DERIVT(L-LO)=PFACS(I-NMP1+1)*CRS +DERIVT(L-LO)
   21 CONTINUE
   3  CONTINUE
C END OF INNERMOST CYCLE OVER SYMMETRY
C
C IF CENTROSYMMETRIC, COMPENSATE FOR USING ONLY HALF NUMBER OF OPERATORS:
      IF (CENTRC) SUM1=SUM1+CONJG(SUM1)
      FAC=AMULT(IR)*EXP(-(TF(IR)*SSQRD))
      HR=FAC*SITE(IR)
C HR IS PRODUCT OF ATOM DEPENDENT BUT SYMMETRY INDEPENDENT FACTORS (BUT NOTE
C FORM ABSENT FROM USUAL EXPRESSION AS PSUM HAS BEEN MULTIPLIED IN EARLIER)
      FC=FC + HR*SUM1
C
C  NOW WE TIDY UP THE XYZ BIJ AND MP DERIVATIVES, ALLOWING FOR CENTRE:
      DO 8 I=1,3
      L=KX(I,IR)
      IF (L.GT.0) THEN
        DERIVT(L-LO)=TWOPI*HR*DERIVT(L-LO)
        IF (CENTRC) DERIVT(L-LO)=DERIVT(L-LO)+CONJG(DERIVT(L-LO))
      ENDIF
      IF (IA .NE. 0) THEN
        L=KATF(I,IA)
        IF (L.GT.0) THEN
          DERIVT(L-LO)=-(HR*DERIVT(L-LO))
          IF (CENTRC) DERIVT(L-LO)=DERIVT(L-LO)+CONJG(DERIVT(L-LO))
        ENDIF
        L=KATF(I+3,IA)
        IF (L.GT.0) THEN
          DERIVT(L-LO)=-(HR*2.*DERIVT(L-LO))
          IF (CENTRC) DERIVT(L-LO)=DERIVT(L-LO)+CONJG(DERIVT(L-LO))
        ENDIF
      ENDIF
   8  CONTINUE
C
C FORM FACTOR (PARTLY FORMED WITHIN THE SYMMETRY LOOP):
      L=KCMULT(IR)
      IF (L.GT.0) THEN
        DERIVT(L-LO)=HR*DERIVT(L-LO)
        IF (CENTRC) DERIVT(L-LO)=DERIVT(L-LO)+CONJG(DERIVT(L-LO))
      ENDIF
C SITE OCCUPATION FACTOR:
      L=KSITE(IR)
      IF (L.GT.0) DERIVT(L-LO)=FAC*SUM1
C ISOTROPIC TEMPERATURE FACTOR:
      L=KTF(IR)
      IF (L.GT.0) DERIVT(L-LO)=-(SSQRD*HR*SUM1)
C MULTIPOLE PARAMETERS (PARTLY FORMED WITHIN THE SYMMETRY LOOP):
      DO 24 I=NMP1,NMP2
      L=KPOLMP(I)
      IF (L.GT.0) THEN
C4.1 LO replaces LO5 5 times
        DERIVT(L-LO)=HR*DERIVT(L-LO)
        IF (CENTRC) DERIVT(L-LO)=DERIVT(L-LO)+CONJG(DERIVT(L-LO))
      ENDIF
  24  CONTINUE
   1  CONTINUE
C END OF CYCLE OVER ATOMIC POSITIONS
C
C  TIDY FCALC AND COLLECT TRUE D(MODFC)/D(VARIABLE)
      A = REAL(FC)
      B = AIMAG(FC)
      FCMOD = SQRT(A*A+B*B)
      IF (.NOT. TESTOV(A,FCMOD)) THEN
        COSAL=A/FCMOD
        SINAL=B/FCMOD
      ENDIF
      DO 6 I=1,L25
C NO SUMMING - THESE ARE THE ACTUAL DERIVATIVES NOT DIVIDED BY ANYTHING, AS
C THEY ARE SUBJECT TO THE CHAIN RULE NEXT, NOT LOGARITHMIC DIFFERENTIATION:
      FCDERS(I)=REAL(DERIVT(I))*COSAL + AIMAG(DERIVT(I))*SINAL
   6  CONTINUE
 100  RETURN
      END
C
C
C
C
C LEVEL 6      SUBROUTINE LMTCAL(HU)
      SUBROUTINE LMTCAL(HU)
C
C *** LMCALC Updated FERA C4.1 December 2006 ***
C
CX
CC 17B
CH Calculates a magnetic structure factor and its derivatives.
CA On entry H is the 1x3 vector containing h,k,l
CP RECIP, SYMOP, SETANI, SETFOR and DOMAG1 must have been obeyed to set up
CP the structure factor calculation. (They are all called by SETFCM)
CP The LSQ environment must have been set up by a suitable MAIN program (like
CP SFLSQ) which has called LSETUP and VARMAK.
CP
CD On exit, in /MCAL/:
CD    FMCMOD = modulus of FMC
CD    FMCSQR = squared modulus of FMC
CD    FMCDER is an array containing the derivatives of FMCMOD wrt the family
CD           2 (structure) parameters, ALL MULTIPLIED BY FMCMOD.
CD    (Note the difference from the specification of LFCALC's derivatives)
CD On exit, in /QCAL/:
CD    Q is an array containing the magnetic interaction vectors for each domain
CD      in general there will be NDOM*KCENT domains
CD On exit, in /QCALD/:
CD    FQCDER is an array containing the derivatives of the Q's with respect to
CD           all the family 2 parameters.
CD
CD All the above will be zero if h,k,l is a magnetic absence
CN Note the existence also of LFCALC (nuclear structure factors for LSQ)
CN                            FMCALC (magnetic structure factors)
CN                            FCALC  (nuclear structure factors)
CN LMCALC Updated for PSI's C141 March 2006
C
%      COMPLEX DERIVM(3,%F2VA%),SUM1(3),TERM,TVEC(3),FORM,HR,FORMFA,P(3)
      COMPLEX CFAC,TEMP,PSIFAC,PSIFCC,TDERS(3,16),TTVEC(3),TDVEC(3)
      COMPLEX FMC(3),TRVEC(3)
      LOGICAL SKIP,MAGABS,BINDIG
      DIMENSION RH(3),H(3),RS(3,3),HD(3,3),SDOM(3,3),HU(3),OH(3)
/ANISO/
/BRAGG/
/CONSTA/
/IOUNIT/
/MAGDAT/
/MCAL/
/NSYM/
/PHASE/
/POINTS/
/POLDA/
/POSNS/
/PRBLEM/
/QCAL/
/QCALD/
/SATELL/
/SYMDA/
/SYMMAG/
/SYMTAB/
%      DATA NPSI/%PSIS%/
/TWIN/
C
C CLEAR ALL ANSWERS IN CASE ABSENT:
C
C CLEAR MODULUS AND SQUARE:
      FMCMOD=0.
      FMCSQR=0.
C SIN THETA/LAMBDA
        call ortho(hu,oh,2)
        call univec(oh,ds)
      STHL=ds/2
      SSQRD=STHL*STHL
C
C CLEAR DERIVATIVES:
      L2=NVARF(2,JPHASE,1)
      IF (L2 .GT. 0) CALL GMZER(FMCDER,1,L2)
C
C OUT IF ABSENT:
      IF (MAGABS(HU,IK)) GO TO 100
C      TAU=-FLOAT(IK)
C
C  CYCLE OVER DOMAINS
      ND=0
      IHELIX=1
      IF (HELI) THEN
        IHELIX=2
      ENDIF
      SKIP=.FALSE.
      DO 115 ITWIN=1,NTWIN
C      call gmeq(hu,h,3,1)
      CALL GMPRD(HU,TWMAT(1,1,ITWIN),H,1,3,3)
      IF (MAGABS(H,IK)) GO TO 100
      TAU=-FLOAT(IK)
      DO 15 IDOMOP=1, NOPC
      IF ((FERO .OR. FERA) .AND. IDOMOP .NE.1) GO TO 18
C DOMAINS EXIST FOR ALL ELEMENTS NOT IN THE MAGNETIC GROUP
      IF (IDOMOP.NE.1 .AND. IABS(MSTAB(IDOMOP)).NE.IDOMOP) GO TO 15
C FMC COLLECTS THE MAGNETIC STRUCTURE FACTOR, A COMPLEX VECTOR,
C ZEROED BEFORE CALCULATING THE VALUE FOR EACH DOMAIN
      CALL CGMZER(FMC,1,3)
C
C FIRST SCATTERING FACTOR:
      IFF=0
C
C OFFSET TO REACH THESE FAMILY 2 VARIABLES:
      LO=LVFST1(2,JPHASE,1)
C CLEAR DERIVATIVE VECTOR FOR ALL FAMILY 2:
      DO 82 I=1,L2
      DO 82 J=1,3
  82  DERIVM(J,I)=0.
C
C
C CYCLE OVER MAGNETIC ATOMS:
      DO 1 IM=1,NMAG
      IR=JMAGAT(IM)
C
C GET NEW FORM FACTOR IF DIFFERENT FROM THE PREVIOUS ONE
      IF (NMFORM(IM) .NE. IFF) THEN
        IFF=NMFORM(IM)
        FORM=FORMFA(STHL,IFF)
      ENDIF
C
C CYCLE OVER COMPONENTS OF HELIX
      DO 30 ICOMP=1,IHELIX
      CALL CGMZER(SUM1,3,1)
      CALL CGMZER(TDERS,3,16)
C IF IHELIX=1, THIS ONLY EVER DOES IC=0, & REFERS TO SPECIES 17 & 18 FOR ANGM,
C AND SPECIES 21 FOR SMOD(1)
C IF IHELIX=2, IC IS FIRST 0 (SPECIES 17 & 18) THEN 2 (SPECIES 19 & 20) FOR
C ANGM, AND SPECIES 21 THEN 22 FOR SMOD(1) THEN SMOD(2)
      IC=2*(ICOMP-1)
C
C PREPARE TO COUNT OPERATORS USED
      NOPU=0
C SYMMETRY CYCLE OVER SYMMETRIC AND NON-SYMMETRIC ROTATIONS:
      DO 3 IS=1,NOPC
C ONLY USE OPERATORS WHICH LEAVE THE PROPAGATION DIRECTION INVARIANT
      IF (IS.NE.1 .AND. IABS(KSTAB(IS)).NE.1) GO TO 3
C THE OPERATOR TO USE IS THE PRODUCT OF'IS' WITH THAT CREATING THE DOMAIN
      IROP=MULTAB(IDOMOP,IS)
      IF (MODUL) THEN
C INSYM IS THE NUMBER OF THE CO-SET ELEMENT INVOLVED (FROM THE CO-SET NSYM)
C IT MAY BE NEGATIVE IF INVERSION IS INCLUDED
        IF (IROP.EQ.1) THEN
          INSYM=1
        ELSE
          INSYM=MSTAB(IROP)
        ENDIF
C ISBGN IS THE NUMBER OF THE SUBLATTICE GENERATED BY INSYM
        ISBGN=IPTAB(IABS(INSYM),IM)
C THE NUMBBERS IN LPHI MAY ALSO BE NEGATIVE IF INVERSION IS INVOLVED
C SKIP IF IROP DOESN'T GENERATE A DISTINCT SUB-LATTICE
        IF (LPHI(ISBGN,IM).NE.INSYM) GO TO 3
      ENDIF
      CALL ROTSYM(H,RH,IROP,-1)
      IF (IDOMOP.NE.1 .AND. MSTAB(IDOMOP).LT.0) CALL GMREV(RH,RH,3,1)
C ANISOTROPIC T F (=1. IF NOT THERE) NEEDED SEPARATELY FOR LSQ:
      F1=TWOPI*(SCALPR(X(1,IR),RH)+SCALPR(TRANS(1,IROP),H))
      ERS=ANITF(RH,IR)
      ARS=COS(F1)*ERS
      BRS=SIN(F1)*ERS
      TERM=CMPLX(ARS,BRS)
      IF (FERA ) THEN
C4.1 FOR FERA THE SPIN IS PARALLEL TO THE POLARISATION
         CALL GMEQ(POLND,RS,3,1)
C4.1 THE DERIVATIVE PARTS SET TO ZERO (CAN'T REFINE ORIENTATION)
         CALL GMZER(RS(1,2),3,2)
      ELSE
C FIND OUT WHAT THE SYMMETRY DOES TO THE SPIN DIRECTION
        CALL ROTMAG(SPIND(1,1,ICOMP,IM),SDOM,IS)
C  GET THE SPIN DIRECTION FOR THIS DOMAIN
        DO 2 I=1,3
    2   CALL ROTOSM(SDOM(1,I),RS(1,I),IDOMOP,1)
      ENDIF
      CALL C1MSCA(RS,TVEC,TERM,3,1)
      PSIFAC=CMPLX(1.,0)
      PSIFCC=CMPLX(1.,0)
      IF (MODUL) THEN
C INCLUDE A PHASE SHIFT FOR THIS SUB-LATTICE IF NECESSARY
        IP=IPTAB(IROP,IM)
        TEST=TAU*(RADIAN(PHIH(IP,IM)))
        PSIFAC=CEXP(CMPLX(0.,TEST))
C141 Logical FCENT now used to determine whether to set phase shifts
        IF (FCENT(IM)) THEN
          IPP=IPTAB(IROP+NOPC,IM)
          TEST=TAU*(RADIAN(PHIH(IPP,IM)))
          PSIFCC=CEXP(CMPLX(0.,TEST))
        ENDIF
      ENDIF
C  OTRSYM(NOPC+1) SHOULD CONTAIN THE MATRIX RELATING THE MAGNETIC COMPONENTS
C  OF ATOMS RELATED BY THE CENTRE OF SYMMETRY, WHETHER THIS IS IN THE
C  MAGNETIC GROUP OR NOT.
C141 Logic around call to CENDIF and CENTRO simplified because PSIFAC and
C PSICEN are now always set
      IF (CENTRC) THEN
        CALL CENDIF(TVEC,TVEC,TTVEC,TDVEC,OTRSYM(1,1,NOPC+1),
     &               PSIFAC,PSIFCC)
C  DERIVATIVES WITH REPECT TO PHASES
C  WE DO THESE HERE BECAUSE WE NEED THE TERMS BEFORE THE ACTION OF THE CENTRE
        IF (MODUL) THEN
          J=12+IP
          IF (KPHIH(IP,IM) .GT. 0) THEN
            CALL CGMSUB(TTVEC,TDVEC,TTVEC,1,3)
            CALL CGMSCA(TTVEC,TTVEC,CMPLX(0.,RADIAN(TAU)),1,3)
            CALL CGMADD(TDERS(1,J),TTVEC,TDERS(1,J),1,3)
          ENDIF
          IF (FCENT(IM) .AND.KPHIH(IPP,IM) .GT. 0) THEN
            J=12+IPP
            CALL CGMSCA(TDVEC,TDVEC,CMPLX(0.,RADIAN(TAU)),1,3)
            CALL CGMADD(TDERS(1,J),TDVEC,TDERS(1,J),1,3)
          ENDIF
        ENDIF
      ELSE
        IF (MODUL) THEN
          CALL CGMSCA(TVEC,TVEC,PSIFAC,3,1)
          J=12+IP
          IF (KPHIH(IP,IM) .GT. 0) THEN
            CALL CGMSCA(TVEC,TTVEC,CMPLX(0.,RADIAN(TAU)),1,3)
            CALL CGMADD(TDERS(1,J),TTVEC,TDERS(1,J),1,3)
          ENDIF
        ENDIF
      ENDIF
      CALL CGMADD(SUM1,TVEC,SUM1,1,3)
C
C NOW WE DO THE INNERMOST SUMS FOR THE DERIVATIVES OF FMCMOD WRT
C VARIABLES XYZ AND ALL BIJ.  WE USE THE
C COMPLEX VECTOR DERIVM TO ACCUMULATE THE DERIVATIVES OF THE REAL &
C IMAGINARY PARTS OF THE COMPLEX FC WRT EACH VARIABLE IN TURN.
C
C TDERS IS USED FOR THOSE PARTS WHICH MUST BE ACCUMULATED SEPARATELY
C FOR THE TWO COMPONENTS OF A SPIRAL
C
      DO 7 I=1,3
      IF (KX(I,IR) .GT. 0) THEN
        CALL C1MSCA(RS,TVEC,RH(I)*CMPLX(-BRS,ARS),3,1)
        IF (CENTRC) THEN
          CALL CENTRO(TVEC,TVEC,OTRSYM(1,1,NOPC+1),PSIFAC,PSIFCC)
        ELSE
          IF (MODUL) CALL CGMSCA(TVEC,TVEC,PSIFAC,3,1)
        ENDIF
        CALL CGMADD(TDERS(1,I),TVEC,TDERS(1,I),1,3)
      ENDIF
   7  CONTINUE
C
C JUMP IF NOT ATF AT ALL:
      IA=IAPT(IR)
      IF (IA .EQ. 0) GO TO 6
      IF (KATF(1,IA) .GT. 0) THEN
        CALL C1MSCA(RS,TVEC,RH(1)*RH(1)*TERM,3,1)
        IF (CENTRC) THEN
          CALL CENTRO(TVEC,TVEC,OTRSYM(1,1,NOPC+1),PSIFAC,PSIFCC)
        ELSE
          IF (MODUL) CALL CGMSCA(TVEC,TVEC,PSIFAC,3,1)
        ENDIF
        CALL CGMADD(TDERS(1,4),TVEC,TDERS(1,4),1,3)
      ENDIF
      IF (KATF(2,IA) .GT. 0) THEN
        CALL C1MSCA(RS,TVEC,RH(2)*RH(2)*TERM,3,1)
        IF (CENTRC) THEN
          CALL CENTRO(TVEC,TVEC,OTRSYM(1,1,NOPC+1),PSIFAC,PSIFCC)
        ELSE
          IF (MODUL) CALL CGMSCA(TVEC,TVEC,PSIFAC,3,1)
        ENDIF
        CALL CGMADD(TDERS(1,5),TVEC,TDERS(1,5),1,3)
      ENDIF
      IF (KATF(3,IA) .GT. 0) THEN
        CALL C1MSCA(RS,TVEC,RH(3)*RH(3)*TERM,3,1)
        IF (CENTRC) THEN
          CALL CENTRO(TVEC,TVEC,OTRSYM(1,1,NOPC+1),PSIFAC,PSIFCC)
        ELSE
          IF (MODUL) CALL CGMSCA(TVEC,TVEC,PSIFAC,3,1)
        ENDIF
        CALL CGMADD(TDERS(1,6),TVEC,TDERS(1,6),1,3)
      ENDIF
      IF (KATF(4,IA) .GT. 0) THEN
        CALL C1MSCA(RS,TVEC,RH(3)*RH(2)*TERM,1,3)
        IF (CENTRC) THEN
          CALL CENTRO(TVEC,TVEC,OTRSYM(1,1,NOPC+1),PSIFAC,PSIFCC)
        ELSE
          IF (MODUL) CALL CGMSCA(TVEC,TVEC,PSIFAC,3,1)
        ENDIF
        CALL CGMADD(TDERS(1,7),TVEC,TDERS(1,7),1,3)
      ENDIF
      IF (KATF(5,IA) .GT. 0) THEN
        CALL C1MSCA(RS,TVEC,RH(1)*RH(3)*TERM,3,1)
        IF (CENTRC) THEN
          CALL CENTRO(TVEC,TVEC,OTRSYM(1,1,NOPC+1),PSIFAC,PSIFCC)
        ELSE
          IF (MODUL) CALL CGMSCA(TVEC,TVEC,PSIFAC,3,1)
        ENDIF
        CALL CGMADD(TDERS(1,8),TVEC,TDERS(1,8),1,3)
      ENDIF
      IF (KATF(6,IA) .GT. 0) THEN
        CALL C1MSCA(RS,TVEC,RH(1)*RH(2)*TERM,3,1)
        IF (CENTRC) THEN
          CALL CENTRO(TVEC,TVEC,OTRSYM(1,1,NOPC+1),PSIFAC,PSIFCC)
        ELSE
          IF (MODUL) CALL CGMSCA(TVEC,TVEC,PSIFAC,3,1)
        ENDIF
        CALL CGMADD(TDERS(1,9),TVEC,TDERS(1,9),1,3)
      ENDIF
C NOW DERIVATIVES FOR ORIENTATION PARS
    6 DO 14 I=1,2
      L=KANGM(IC+I,IM)
      IF (L .GT. 0) THEN
        CALL C1MSCA(RS(1,I+1),TVEC,TERM,1,3)
        IF (CENTRC) THEN
          CALL CENTRO(TVEC,TVEC,OTRSYM(1,1,NOPC+1),PSIFAC,PSIFCC)
        ELSE
          IF (MODUL) CALL CGMSCA(TVEC,TVEC,PSIFAC,3,1)
        ENDIF
        CALL CGMADD(DERIVM(1,L-LO),TVEC,DERIVM(1,L-LO),1,3)
      ENDIF
   14 CONTINUE
C
C INCREMENT COUNT OF OPERATORS USED
      NOPU=NOPU+1
   3  CONTINUE
C END OF INNERMOST CYCLE OVER SYMMETRY
C
C  SET UP THE PHASE SHIFTS FOR EACH COMPONENT
      IF (ICOMP.EQ.1) THEN
        CFAC=CMPLX(1.,0.)
      ELSE
        CFAC=CMPLX(0.,-TAU)
      ENDIF
      CFAC=CFAC*AMULT(IR)*EXP(-(TF(IR)*SSQRD))
C COMPENSATE FOR NOT USING ALL SYMMETRY ELEMENTS
      FACTOR=FLOAT(NOPC)/FLOAT(NOPU)
      CFAC=CFAC*FACTOR
C SCALE MOMENT TO CMS-12
      SM=SMOD(ICOMP,IM)*VALMUB
      HR=CFAC*FORM*SITE(IR)*SM
C HR IS PRODUCT OF ATOM DEPENDENT BUT SYMMETRY INDEPENDENT FACTORS
      CALL CGMSCA(SUM1,TVEC,HR,3,1)
      CALL CGMADD(FMC,TVEC,FMC,1,3)
C
C  NOW WE TIDY UP THE XYZ AND BIJ DERIVATIVES, AND MAKE ITF, SITE
C  AND MU
      DO 8 I=1,3
      IF (KX(I,IR) .GT. 0)
     & CALL CGMSCA(TDERS(1,I),TDERS(1,I),TWOPI*HR,3,1)
      IF (IA .GT. 0) THEN
        IF (KATF(I,IA) .GT. 0)
     &  CALL CGMSCA(TDERS(1,I+3),TDERS(1,I+3),-HR,3,1)
        IF (KATF(I+3,IA) .GT. 0)
     &  CALL CGMSCA(TDERS(1,I+6),TDERS(1,I+6),-(HR*2.),3,1)
      ENDIF
   8  CONTINUE
C
C SKIP SCAT (PARAMETER 10)
      IF (KSITE(IR) .GT. 0)
     & CALL CGMSCA(SUM1,TDERS(1,11),FORM*CFAC*SM,3,1)
      IF (KTF(IR) .GT. 0)
     & CALL CGMSCA(SUM1,TDERS(1,12),-(SSQRD*HR),3,1)
C RESCALE PSI DERIVATIVES
      DO 17 I=1,NPSI
      J=12+I
      IF (KPHIH(I,IM) .GT. 0) CALL CGMSCA(TDERS(1,J),TDERS(1,J),HR,3,1)
   17 CONTINUE
C RESCALE ORIENTATION DERIVATIVES
      DO 19 I=1,2
      L=KANGM(IC+I,IM)
      IF (L .GT. 0) CALL CGMSCA(DERIVM(1,L-LO),DERIVM(1,L-LO),HR,3,1)
   19 CONTINUE
C DERIVATIVES WITH RESPECT TO MUS
      L=KSMOD(ICOMP,IM)
      IF (L .GT. 0) THEN
        TEMP=HR/SMOD(ICOMP,IM)
        CALL CGMSCA(SUM1,DERIVM(1,L-LO),TEMP,3,1)
      ENDIF
C ADD THE TWO COMPONENTS (BUT NOT FOR ANGM OR SMOD):
C (IS THIS WHY THE PSIS ARE 13,14,15 . . ?)
      DO 9 I=1,16
C FOR THE MOMENT, LMAGPR IS A FUNCTION.  WHEN THINGS HAVE SETTLED DOWN IT CAN
C BE AN ARRAY, FOR SPEED.
      L=LMAGPR(I,IM,IR)
      IF (L.GT.0)
     & CALL CGMADD(TDERS(1,I),DERIVM(1,L-LO),DERIVM(1,L-LO),3,1)
    9 CONTINUE
   30 CONTINUE
C END OF A CYCLE OVER 1,2 IF IHELIX=2
C
   1  CONTINUE
C END OF CYCLE OVER ATOMIC POSITIONS
C
C     COMPENSATE FOR THE MULTIPLICITY OF THE STAR
      CALL CMRSCA(FMC,FMC,FKSTAR,3,1)
C
C NOW THE CYCLE FOR THE DOMAIN AVERAGE
   18 IF (IDOMOP .EQ.1 .OR. FERO) then
        CALL MAGDOM(H,HD,IDOMOP,SKIP)
C        write (lpt, 4012) h,hd
      ENDIF
C 4012 format (3F8.3,2X,3F8.4,2(/26X,3F8.4))
C134 Skip rotation for FERA  removed C4.1
C      IF (FERA) THEN
C        CALL CGMEQ(FMC,P,3,1)
C      ELSE
        CALL RCMPRD(HD,FMC,P,3,3,1)
C      ENDIF
      QSQR=RSCALP(P,P)
      FMCSQR=FMCSQR+QSQR
      IF (.NOT.SKIP) ND=ND+1
      IF (FERO) THEN
C  PUT Q BACK INTO UNROTATED FRAME
        CALL CROTO(P,TRVEC,IS,1)
      ELSE
        CALL CGMEQ(P,TRVEC,3,1)
      ENDIF
C Rotate onto untwinned axes
      CALL RCMPRD(TWMAT(1,1,ITWIN),TRVEC,Q(1,ND),3,3,1)
C      CALL CGMEQ(TRVEC,Q(1,ND),3,1)
CC
C  TEST OUTPUT
C      IF (IOUT.GT.100) WRITE (LPT,4000) ND,(Q(J,ND),J=1,3),QSQR
      IF (IOUT.GT.100) WRITE (LPT,4000) ND,FMC,QSQR
 4000 FORMAT (/' Q for domain',I2,3(2F8.4,2X),F8.4)
C
C WORK OVER ALL MAGNETIC ATOMS GETTING MODULI OF DERIVATIVES
      DO 16 IM=1,NMAG
      IR=JMAGAT(IM)
      DO 16 IP=1,22
      L=LMAGPR(IP,IM,IR)
      IF (L .EQ. 0) GO TO 16
      LL=L-LO
C134 Skip rotation for FERA  removed C4.1
C      IF (FERA) THEN
C        CALL CGMEQ(DERIVM(1,LL),TVEC,3,1)
C      ELSE
        CALL RCMPRD(HD,DERIVM(1,LL),TVEC,3,3,1)
C      ENDIF
      FMCDER(LL)=FMCDER(LL)+RSCALP(P,TVEC)
      IF (FERO) THEN
C  DERIVATIVES INTO UNROTATED FRAME
        CALL CROTO(TVEC,TTVEC,IS,-1)
      ELSE
        CALL CGMEQ(TVEC,TTVEC,3,1)
      ENDIF
      CALL CMRSCA(TTVEC,TRVEC,FKSTAR,3,1)
C Rotate onto untwinned axes
      CALL RCMPRD(TWMAT(1,1,ITWIN),TRVEC,FQCDER(1,ND,LL),3,3,1)
C      CALL CGMEQ(TRVEC,FQCDER(1,ND,LL),3,1)
C  TEST OUTPUT
      IF (BINDIG(IOUT,128)) WRITE (LPT,4001) L,(FQCDER(I,ND,LL),I=1,3)
 4001 FORMAT (' dQ/dp for p=',I2,4X,3(2F8.4,2X))
   16 CONTINUE
C4.1 Only a single domain if FERA
      IF (FERA) GO TO 21
C
C      CTEST= CRSCLP(Q(1,ND),OH)
C      WRITE (LPT,4010) ND,H,(REAL(Q(I,ND)),I=1,3),
C     &(IMAG(Q(I,ND)),I=1,3),CTEST
C 4010 FORMAT(I4,3F8.3,2X,2(3F8.4,2X),2X,2F8.4)
C 4011 FORMAT(30X,2(3F8.4,2X),2X,2F8.4)
   15 CONTINUE
  115 continue
C      WRITE (LPT,4010)
C
C  END OF THE DOMAIN LOOP, DO THE DOMAIN AVERAGE
C  DIVIDE BY NDOM AS REQUIRED AND RETURN Fm*DFm/DPar IN FMCDER
   21 DO 20 IM=1,NMAG
      IR=JMAGAT(IM)
      DO 20 IP=1,22
      L=LMAGPR(IP,IM,IR)
      IF (L.EQ.0) GO TO 20
      LL=L-LO
      FMCDER(LL)=FKSTAR*FMCDER(LL)/FLOAT(ND)
C  TEST OUTPUT
      IF (BINDIG(IOUT,64)) WRITE (LPT,4002) L,FMCDER(LL)
 4002 FORMAT (' Fm*dFm/dp for p=',I2,4X,3(2E12.4,2X))
   20 CONTINUE
C
      FMCSQR=FMCSQR/FLOAT(ND)
      FMCMOD=SQRT(FMCSQR)
C
 100  RETURN
      END
C
C
C
C
C LEVEL 2      SUBROUTINE LOCBIT(I,J,NR,NC,ISIDE,M,N)
      SUBROUTINE LOCBIT(I,J,NR,NC,ISIDE,M,N)
C
C *** LOCBIT by JCM 24 Nov 83 ***
C
CX
CC 15C
CH A specialist routine for contour plotting, which finds the "next" bit in
CH the bit-map, removes it, and indicates where on the picture it was.
CA On entry I=which bit within a word in the bit-map,
CA          J=which word in the bit-map
CA          M,N give the size of the bit-map
CA On exit ISIDE=1,2,3 or 4 to indicate side of picture,
CA         NR,NC are set to indicate the top left of the relevant square.
CD Finds whether the indicated bit is 0 or 1, and in any case removes it.
CP The bit-map must be set up in IBIT in /BITMAP/
CP NBITS must be set up as at most the number of bits in an integer.
C
/BITMAP/
/IOUNIT/
/LENINT/
C
      IF (J .GT. NWORDS) THEN
        WRITE (LPT,3000) J,NWORDS
        WRITE (ITO,3000) J,NWORDS
3000    FORMAT (' ERROR ** IN LOCBIT - INTEGER',I4,' CALLED FOR, ',
     &  ' BUT ONLY',I4,' AVAILABLE')
        STOP
      ENDIF
C
      ISIDE = I
      IF (I .GT. 4) ISIDE = 1
      MM=1
      IB=1
   5  IF (LOGAND(IBIT(I,J),MM) .NE. 0) GO TO 6
      MM=MM*2
C NB IF THIS GIVES INTEGER OVERFLOW, REDUCE THE VALUE OF NBITS IN COMMON
C CONTUR SO THAT THE SIGN BIT OF AN INTEGER IS NOT USED
      IB=IB+1
      GO TO 5
   6  IBIT(I,J)=IBIT(I,J)-MM
      GO TO(1,2,3,4),ISIDE
    1 NR = I
      IF (I .GT. 4) NR = I-3
      NC = (J-1)*NBITS +IB
      GO TO 100
    2 NC = N-1
      NR = (J-1)*NBITS + IB
      GO TO 100
    3 NR = M-1
      NC = N - (J-1)*NBITS - IB
      GO TO 100
    4 NC = 1
      NR = M - (J-1)*NBITS - IB
 100  RETURN
      END
C
C
C
C
C LEVEL 1      FUNCTION LOGAND(I,J)
      FUNCTION LOGAND(I,J)
C
C *** LOGAND IN FORTRAN by JCM 10 Oct 83 ***
C
CC 15C
CH Performs logical "and" on 2 whole integers.
CA On entry I and J are the integers whose "and" is wanted.
CA On exit LOGAND is I and J, taken bit by bit.
CD Takes the logical "and" of all of the bits in I and J, except the sign
CD digit, relying on the value of NBITS in /LENINT/ being set to one fewer
CD than the number of bits in an integer (at most).  NBITS is set in INITIL
CD as a machine specific quantity.
CN This is now part of standard FORTRAN
C
      LOGICAL DIFFI,DIFFJ
/IOUNIT/
/LENINT/
C
      IF ((I .LT. 0) .OR. (J .LT. 0)) THEN
        WRITE (LPT,3000) I,J,NBITS
        WRITE (ITO,3000) I,J,NBITS
3000    FORMAT (' ERROR ** in FUNCTION LOGAND - attempt to use',
     &   ' sign bit - check value of NBITS in COMMON /LENINT/ - ',
     &   'I,J,NBITS =',3I5)
        STOP
      ENDIF
C
C FORM ANSWER IN IANS.  PUT SAMPLE BIT INTO IBT:
      IANS=0
      IBT=1
      II=I
      JJ=J
C
C COUNT OVER POSSIBLE BITS:
      DO 1 IB=1,NBITS
      DIFFI= .FALSE.
      I1=II/2
      I2=2*I1
C IF HALVING THEN DOUBLING HAS PRODUCED NO CHANGE, II WAS EVEN:
      IF (I2-II) 2,3,4
C JUST IN CASE SOME MACHINE ROUNDS IT UP:
   4  I1=I1-1
   2  DIFFI= .TRUE.
C
C SAME FOR JJ:
   3  DIFFJ= .FALSE.
      J1=JJ/2
      J2=2*J1
      IF (J2-JJ) 5,6,7
   7  J1=J1-1
   5  DIFFJ= .TRUE.
C
C IF INDIVIDUAL BITS BEING EXAMINED ARE THE SAME, ADD IN BIT TO ANSWER
   6  IF (DIFFI .AND. DIFFJ) IANS=IANS+IBT
      IF (IB .NE. NBITS) IBT=IBT*2
C WE OMIT DOUBLING LAST TIME ROUND IN CASE OF OVERFLOW
      II=I1
      JJ=J1
   1  CONTINUE
      LOGAND=IANS
      RETURN
      END
C
C
C
C
C LEVEL 3      SUBROUTINE LOGMAG
      SUBROUTINE LOGMAG
C
C *** LOGMAG FANI and CPVEC added by PJB March 2012 C4.26 ***
C
CX
CC 17A
CH Sets mnemonic logicals from the type of magnetic structure.
CA On entry MTYP gives the type of structure, usually read from a Q STYP
CA               card.
CD Complains and stops if MTYP is not between 1 and 6.
CD Sets only one of FERO, FERA, HELI, AMOD, ANTI and PARA to be TRUE and the
CD rest to be FALSE.  Sets MODUL to be TRUE if either HELI or AMOD.
C
/SYMMAG/
C
      IF (MTYP .LT. 1 .OR. MTYP .GT. 8) CALL ERRMES(1,0,
     &  'Type of magnetic structure not recognised')
      FERO=MTYP.EQ.1
      FERA=MTYP.EQ.2
      HELI=MTYP.EQ.3
      AMOD=MTYP.EQ.4
      ANTI=MTYP.EQ.5
      PARA=MTYP.EQ.6
      FANI=MTYP.EQ.7
      CPVEC=MTYP.EQ.8
      MODUL=HELI .OR. AMOD
      RETURN
      END
C
C
C
C
C LEVEL 1      FUNCTION LOGOR(I,J)
      FUNCTION LOGOR(I,J)
C
C *** LOGOR IN FORTRAN by JCM 10 Oct 83 ***
C
CC 15C
CH Performs logical "or" on 2 whole integers.
CA On entry I and J are the integers whose "or" is wanted.
CA On exit LOGAND is I or J, taken bit by bit.
CD Takes the logical "or" of all of the bits in I and J, except the sign
CD digit, relying on the value of NBITS in /LENINT/ being set to one fewer
CD than the number of bits in an integer (at most).  NBITS is set in INITIL
CD as a machine specific quantity.
CN This is now part of standard FORTRAN
C
      LOGICAL DIFFI,DIFFJ
/IOUNIT/
/LENINT/
C
      IF ((I .LT. 0) .OR. (J .LT. 0)) THEN
        WRITE (LPT,3000) I,J,NBITS
        WRITE (ITO,3000) I,J,NBITS
3000    FORMAT (' ERROR ** in FUNCTION LOGOR - attempt to use',
     &   ' sign bit - check value of NBITS in COMMON /LENINT/ - ',
     &   'I,J,NBITS =',3I5)
        STOP
      ENDIF
C
C FORM ANSWER IN IANS.  PUT SAMPLE BIT INTO IBT:
      IANS=0
      IBT=1
      II=I
      JJ=J
C
C COUNT OVER POSSIBLE BITS:
      DO 1 IB=1,NBITS
      DIFFI= .FALSE.
      I1=II/2
      I2=2*I1
C IF HALVING THEN DOUBLING HAS PRODUCED NO CHANGE, II WAS EVEN:
      IF (I2-II) 2,3,4
C JUST IN CASE SOME MACHINE ROUNDS IT UP:
   4  I1=I1-1
   2  DIFFI= .TRUE.
C
C SAME FOR JJ:
   3  DIFFJ= .FALSE.
      J1=JJ/2
      J2=2*J1
      IF (J2-JJ) 5,6,7
   7  J1=J1-1
   5  DIFFJ= .TRUE.
C
C IF INDIVIDUAL BITS BEING EXAMINED HAVE A 1, ADD IN BIT TO ANSWER
   6  IF (DIFFI .OR. DIFFJ) IANS=IANS+IBT
      IF (IB .NE. NBITS) IBT=IBT*2
C WE OMIT DOUBLING LAST TIME ROUND IN CASE OF OVERFLOW
      II=I1
      JJ=J1
   1  CONTINUE
      LOGOR=IANS
      RETURN
      END
C
C
C
C
C LEVEL 6      SUBROUTINE LPVCAL(H)
      SUBROUTINE LPVCAL(H)
C
C *** LPVCAL Structure factors and derivatives for COMPLEX VECTOR MODEL ***
C
CX
CC 17B
CH Calculates magnetic interaction vectors, structure factors and their
CH derivatives for INCM structures
CA On entry H is the 1x3 vector containing h,k,l
CA On exit   FMCMOD = domain average of the lengths of the m.i. vector
CA           FMCSQR = square of the above
CD On exit Q(1:3,1:NDOM) in COMMON QCAL contains the magnetic interaction
CD vectors for each of the partners in each of NDOM domains.
CP STHL in /BRAGG should hold sin theta/lambda
CP NKSTAR in /SATELL should have been set up by routine KSTAR
CP
CP The setting up routines:
CP     RECIP  (for the cell parameters)
CP     SYMOP  (for the space group symmetry)
CP     SETFOR (for the scattering factors, both nuclear and magnetic)
CP     SETANI (for the anisotropic temperature factors)
CP     DOMAG1(1) and (2) (for the magnetic structure) and
CP     DOINC1 (for special INCM parameters)
CP should all have been obeyed to set up the structure.
CD Sets SSQRD in /BRAGG to be STHL squared
CD Gives zero as answers for magnetic absences
CN All atom positions are as generated by the symops
C
%      COMPLEX DERIVM(3,2,%F2VA%),TDERS(3,2,12),DRVEC(3,4),
     &DERA(3,2),DERP(3,2),DVEC(3,2),DPVEC(3,2),SP(2),SUM2(3,2)
      COMPLEX CRVEC(3,2),CVEC(3,2),CCVEC(3,2),cxpic,cxpik
      COMPLEX FORMC,FORMFA,HR,TERM,FMC(3,2),P(3,2)
      LOGICAL SKIP,MAGABS,BINDIG
      DIMENSION RH(3),H(3),HD(3,3),pvec(3)
/ANISO/
/BRAGG/
/CONSTA/
/IOUNIT/
/MAGDAT/
/MCAL/
/NSYM/
/PHASE/
/POINTS/
/POLDA/
/POSNS/
/PRBLEM/
/QCAL/
/QCALD/
/SATELL/
/SYMDA/
/SYMMAG/
/SYMTAB/
C
C
C ERROR if NOT INCMAG (complex modulated)
      if (.not. CPVEC)
     &call errmes(1,0,'LPVCAL only for INCM structure type')
C CLEAR ALL ANSWERS IN CASE ABSENT:
      ND=0
C CLEAR MODULUS AND SQUARE:
      FMCMOD=0.
      FMCSQR=0.
      SSQRD=STHL*STHL
C
C      write (lpt,5010) (k,(j,(spnvec(i,j,k),i=1,3),j=1,nopc),k=1,nmag)
C 5010 format (2i4,6f8.3)
C      stop
C CLEAR DERIVATIVES:
      L2=NVARF(2,JPHASE,1) +2
      IF (L2 .GT. 0) CALL GMZER(FMCDER,1,L2)
C
C OUT IF ABSENT:
      IF (MAGABS(H,IK)) GO TO 100
      TAU=-FLOAT(IK)
      cxpik=cmplx(0.,float(IK))
C
C  CYCLE OVER DOMAINS )(are there any?)
      DO 15 IDOMOP=1,NDOM
C DOMAINS EXIST FOR ALL ELEMENTS NOT IN THE MAGNETIC GROUP
      IF (IDOMOP.NE.1 .AND. IABS(MSTAB(IDOMOP)).NE.IDOMOP) GO TO 15
C FMC COLLECTS THE MAGNETIC STRUCTURE FACTOR, A COMPLEX VECTOR,
C ZEROED BEFORE CALCULATING THE VALUE FOR EACH DOMAIN
      CALL CGMZER(FMC,3,2)
C FIRST SCATTERING FACTOR:
      IFF=0
C
C OFFSET TO REACH THE FAMILY 2 VARIABLES:
      LO=LVFST1(2,JPHASE,1)
C CLEAR DERIVATIVE VECTOR FOR ALL FAMILY 2:
      call cgmzer(DERIVM,6,L2)
C
C CYCLE OVER MAGNETIC ATOMS:
      DO 1 IM=1,NMAG
      IR=JMAGAT(IM)
      CALL CGMZER(SUM2,3,2)
C
C JUMP IF FORM/SCATTERING FACTOR THE SAME AS BEFORE
      IF (NMFORM(IM) .EQ. IFF) GO TO 2
C IF NOT, GET IT
      IFF=NMFORM(IM)
      FORMC=FORMFA(STHL,IFF)
C
C PREPARE TO COUNT OPERATORS USED
    2 NOPU=0
C Clear summed quantities
C INNER LOOP OVER SYMMETRY EQUIVALENTS:
      call cgmzer(tders,3,12)
      DO 3 IS=1,NOPC
Cycle over centre needed for CPVEC
      DO 23 IC=1,-1,-2
      ISS=IS*IC
      SIC=float(ic)
      cxpic=cmplx(0.,sic)
C  ONLY USE OPERATORS WHICH LEAVE THE PROPAGATION DIRECTION INVARIANT
      IF (IS.NE.1 .AND.IABS(KSTAB(IS)).NE.1) GO TO 3
C  THE OPERATOR TO USE IS THE PRODUCT OF IS WITH THAT CREATING THE DOMAIN
      IROP=MULTAB(IDOMOP,IS)
      CALL ROTSYM(H,RH,IROP,2)
       if (ic*IK.lt.0) CALL GMREV(rh,rh,3,1)
      CALL ROTSYM(X(1,IR),pvec,IROP,2)
C Trig factor: FX for position only
      Fx=TWOPI*(SCALPR(h,pvec))
      FX=ranger(fx,pi,-pi)
      if (ic.lt.0) fx=-fx
C FT h dependent part due to translation
      FT=ranger(TWOPI*SCALPR(h,trans(1,irop)),pi,-pi)
      FG=TWOPI*scalpr(prop,trans(1,irop))
      fg=ranger(fg,pi,-pi)
      if (IK.lt.0) fg=-fg
C F1 is the phase shift at this position for the reflection h=g +/- tau
      FF=ranger(FT-FG,pi,-pi)
      F1=ranger(FX+FT-FG,pi,-pi)
C  ANISOTROPIC T F (=1. IF NOT THERE) NEEDED SEPARATELY FOR LSQ:
      ERS=ANITF(RH,IR)
      ARS=COS(F1)*ERS
      BRS=SIN(F1)*ERS
      TERM=CMPLX(ARS,BRS)
C Get the Fourier component of the spin vector for this atom and
C Rotate with the symmetry operator
      call rotcmg(rvec(1,1,im),crvec,iss)
      if (IK.lt.0)call cmconj(crvec,crvec,3,2)
      call cgmsca(crvec,ccvec,cexp(cmplx(0.,FF)),3,2)
      call cgmsca(crvec,cvec,term,3,2)
C Then add in to the irep dependent structure factor sum
      call cgmadd(sum2,cvec,sum2,3,2)
C
C MAGNETIC DERIVATIVES
      DO 14 IREP=1,2
      DO 14 I=1,3
      LA=KRVEC(i,irep,1,IM)
      LP=KRVEC(i,irep,2,IM)
      IF (LA .NE.0 .or. LP .NE. 0) THEN
        call cgmzer(drvec,3,2)
        drvec(i,irep)=rvec(i,irep,im)
        call rotcmg(drvec,derp,IC*IROP)
        if (IK.lt.0) call cmconj(derp,derp,3,2)
C          write (lpt,6002) 2,iss,IK,drvec(i,irep),
C     &(derp(3,irp),irp=1,2),(derp(3,irp),irp=1,2),term
C Include Phase shift for atomic position
        call CGMSCA(derp,derp,term,3,2)
        IF (LA .NE.0 ) then
          call cgmeq(derp,dera,3,2)
          call cmrsca(dera,dera,1./cabs(rvec(i,irep,im)),3,2)
          call cgmadd(derivm(1,1,LA),dera,derivm(1,1,LA),3,2)
        endif
        IF (LP .NE.0) then
          LL=LA-LO
          call cgmsca(derp,derp,SIC*cxpik,3,2)
          call cgmadd(derivm(1,1,LP),derp(1,1),derivm(1,1,LP),3,2)
C          if (derp(3,2).ne.0) write (lpt,6002) 9,iss,irep,cvec(3,2),
C     &    derp(3,2)
C          if (derp(3,2).ne.0) write (lpt,6002) 10,LP,irep,sum2(3,2),
C     &    derivm(3,2,lp),cvec(3,2), derp(3,2)
        endif
      endif
   14 continue
C
C NOW THE DERIVATIVES OF FMCMOD WRT VARIABLES XYZ AND ALL BIJ.
C WE USE THE VECTOR DERIVM TO ACCUMULATE THE DERIVATIVES OF THE
C THE COMPLEX FC WRT EACH VARIABLE IN TURN.
      DO 7 I=1,3
      IF (KX(I,IR) .GT. 0) THEN
        CALL CGMSCA(crvec,dera,RH(I)*cxpic,3,2)
        CALL CGMADD(TDERS(1,1,I),dera,TDERS(1,1,I),3,2)
      ENDIF
   7  CONTINUE
C
C JUMP IF NO ATF AT ALL:
      IA=IAPT(IR)
      IF (IA .EQ. 0) GO TO 6
      J=2
      L=3
      do 8 i=1,3
      IF (KATF(I,IA) .GT. 0) THEN
        CALL CGMSCA(crvec,dera,RH(I)*RH(I),3,2)
        CALL CGMADD(TDERS(1,1,I+3),TVEC1,TDERS(1,1,I+3),3,1)
      ENDIF
      IF (KATF(I+3,IA) .GT. 0) THEN
        CALL CGMSCA(CRVEC,dera,RH(J)*RH(L),3,1)
        CALL CGMADD(TDERS(1,1,I+6),dera,TDERS(1,1,I+6),3,1)
      ENDIF
      J=L
      L=I
    8 CONTINUE
C
    6 continue
C INCREMENT COUNT OF OPERATORS USED
      NOPU=NOPU+1
   23 continue
    3 CONTINUE
C END OF INNERMOST CYCLE OVER SYMMETRY
C
      FAC=AMULT(IR)*EXP(-(TF(IR)*SSQRD))
C COMPENSATE FOR NOT USING ALL SYMMETRY ELEMENTS
      FACTOR=FLOAT(NOP)/FLOAT(NOPU)
C SCALE MOMENT TO CMS-12
      FAC=FAC*FACTOR*VALMUB
C HR IS PRODUCT OF ATOM DEPENDENT BUT SYMMETRY INDEPENDENT FACTORS
      HR=FAC*FORMC*SITE(IR)
C  TIDY UP THE XYZ AND BIJ DERIVATIVES, AND MAKE ITF AND SITE
      DO 9 I=1,3
      IF (KX(I,IR) .GT. 0) CALL CGMSCA(TDERS(1,1,I),TDERS(1,1,I),
     &TWOPI*HR,3,2)
      IF (IA .GT. 0) THEN
        IF (KATF(I,IA) .GT. 0)CALL CGMSCA(TDERS(1,1,I+3),
     &  TDERS(1,1,I+3),-HR,3,2)
        IF (KATF(I+3,IA) .GT. 0) CALL CGMSCA(TDERS(1,1,I+6),
     &  TDERS(1,1,I+6),-2.*HR,3,2)
      ENDIF
   9  CONTINUE
C SKIP SCAT (PARAMETER 10)
C DO SITE PAR 11
      IF (KSITE(IR) .GT. 0)
     & CALL CGMSCA(SUM1,TDERS(1,1,11),FORMC*FAC,3,2)
      IF (KTF(IR) .GT. 0)
     & CALL CGMSCA(SUM1,TDERS(1,1,12),-(SSQRD*HR),3,2)
C Rescale structure factor term
      CALL CGMSCA(SUM2,SUM2,HR,3,2)
C RESCALE MAGNETC DERIVATIVES
      DO 19 I=1,3
      DO 19 IREP=1,2
      DO 19 IAP=1,2
      L=KRVEC(I,IREP,IAP,IM)
      IF (L.GT.0) then
        LL=L-LO
        call cgmsca(derivm(1,1,LL),derivm(1,1,LL),hr,3,2)
C        write (lpt,6002) 4,I,IREP,sum2(i,irep),derivm(i,irep,ll)
      ENDIF
C      write (lpt,6004) 5,I,IREP,IAP,IM,L,LL,derivm(1,1)
   19 CONTINUE
      CALL CGMADD(FMC,SUM2,FMC,3,2)
C      if (derivm(3,2,1) .ne.0)
C      write (lpt,6002) 15, IXX,JG,SUM2(ixx,IRr),derivm(IXX,IRr,1)

    1 CONTINUE
C      if (derivm(IXX,1,1) .ne.0)
C     & write (lpt,6002) 161, I,IM,FMC(IXX,1),derivm(IXX,1,1)
C      if (derivm(IXX,2,1) .ne.0)
C     & write (lpt,6002) 162, I,IM,FMC(IXX,2),derivm(IXX,2,1)


C END OF CYCLE OVER ATOMIC POSITIONS
C      write (lpt,6002) 5, I,1,FMC
C      write (lpt,6002) 51, IXX,IRR,FMC(IXX,1),derivm(IXX,1,1)
C      write (lpt,6002) 52, IXX,IRR,FMC(IXX,2),derivm(IXX,1,2)
C
C  COMPENSATE FOR MULTIPLICITY OF THE STAR
      CALL CMRSCA(FMC,FMC,FKSTAR,3,2)
C
C THE procedure FOR THE DOMAIN AVERAGE
C FMC holds the magnetic structure factor for 2 reps , we now calculate
C the interaction vectors from it
      IF (IDOMOP .EQ.1) CALL MAGDOM(H,HD,IDOMOP,SKIP)
C      write (lpt,5008) h,hd
C 5008 format (3f8.3,2x,9f8.3)
C Multiply by the order parameters
      call cgmeq(spord,sp,2,1)
C Conjugated if Ik is	negative
      if (IK.lt.0) call cmconj(sp,sp,2,1)
      call cgmsca(FMC(1,1),cvec(1,1),sp(1),3,1)
      call cgmsca(FMC(1,2),CVEC(1,2),sp(2),3,1)
      CALL RCMPRD(HD,CVEC,p,3,3,2)
C for CPVEC reps 1 and 2 go in ND=1,2
      CALL CGMEQ(P,Q(1,ND+1),3,2)
      fmcsqr=rscalp(p(1,1),p(1,1))+rscalp(p(1,2),p(1,2))
C      write (lpt,6002) 8,1, nd,((q(i,nd+j),i=1,3),j=1,2),fmcsqr
C      write (lpt,6002) 81,1, nd,fmc(ixx,1),cvec(ixx,1),sp(1),fmcsqr
C      write (lpt,6002) 82,1, nd,fmc(ixx,2),cvec(ixx,2),sp(2),fmcsqr
C
C Derivatives with respect to order parameters
      DO 30 irep=1,2
      do 31 IAP = 1,2
      l=kspord(IREP,IAP)
      if (l.eq.0) go to 31
      if (IAP.eq.1) then
        samp=1./cabs(spord(irep))
        call cmrsca(cvec(1,irep),dera(1,irep),samp,3,1)
        call cgmadd(derivm(1,IREP,L),dera(1,irep),derivm(1,IREP,L),3,1)
C        write (lpt,6002) 201,iap,irep,cvec(ixx,irep),dera(ixx,IREP),
C     &spord,samp
      else
        call cgmsca(p(1,irep),derp(1,irep),-cxpik,3,1)
        call cgmadd(derivm(1,1,L),derp(1,irep),derivm(1,IREP,L),3,1)
C        write (lpt,6002) 202,iap,irep,p(ixx,IREP),derp(ixx,IREP),cxpik
      endif
C      CALL CMRSCA(DERIVM(1,IREP,L),DVEC,FKSTAR,3,2)
      CALL RCMPRD(HD,DERIVM(1,1,L),DPVEC(1,1),3,3,2)
C      write (lpt,6002) 204,iap,irep,p(1,irep),dpvec(1,IREP),fmcsqr
      FMCDER(l)=FMCDER(l)+rscalp(p(1,irep),dpvec(1,irep))
      call cgmeq(dpvec,fqcder(1,ND+1,l),3,2)
C        write (lpt,6000) 1,L,IK,FMCDER(L),FMCSQR
   31 continue
   30 continue
C
C WORK OVER ALL MAGNETIC ATOMS GETTING MODULI OF DERIVATIVES
      DO 16 IM=1,NMAG
      IR=JMAGAT(IM)
      DO 16 IP=1,24
      L=LMAGPR(IP,IM,IR)
      IF (L .EQ. 0) GO TO 16
      LL=L
      CALL CMRSCA(DERIVM(1,1,LL),DVEC,FKSTAR,3,2)
C      write (lpt,6002) 51, LL,L,FMC(IXX,1),DVEC(Ixx,1),FKSTAR
C      write (lpt,6002) 52, LL,L,FMC(IXX,2),DVEC(IXX,2),FKSTAR
      CALL RCMPRD(HD,DVEC(1,1),DPVEC,3,3,2)
C      write (lpt,6002) 7, LL,L,cvec(3,2),dpvec(3,2),fmcsqr
C Multiply by the order parameters
      call cgmsca(dpvec(1,1),dpvec(1,1),sp(1),3,1)
      call cgmsca(dpvec(1,2),dpvec(1,2),sp(2),3,1)
C      write (lpt,6002) 111, LL,L,p(ixx,1),dpvec(ixx,1)
C      write (lpt,6002) 112, LL,L,p(ixx,2),dpvec(ixx,2)
      CALL CGMEQ(DPVEC,FQCDER(1,ND+1,L),3,2)
      FMCDER(L)=(FMCDER(L) + RSCALP(P(1,1),DPVEC(1,1)) +
     & RSCALP(P(1,2),DPVEC(1,2)))
C      write (lpt,6002) 61, LL,L,p(ixx,1),dpvec(ixx,1),fmc(ixx,1)
C    write (lpt,6002) 62, LL,L,p(ixx,2),dpvec(ixx,2),fmc(ixx,2)
c      write (lpt,6002) 70, LL,L,FMCSQR,1.0,2.*FMCDER(l),1.0
C        write (lpt,6000) -1,L,LL,2*FMCDER(LL),FMCSQR
C  TEST OUTPUT
      IF (BINDIG(IOUT,128)) WRITE (LPT,4001)FMCSQR,
     &L,FMCDER(l)
 4001 FORMAT ('FMCSQR',f8.4,' d(fmsqr)/dp for p=',I2,4X,3(2F8.4,2X))
   16 CONTINUE

C 6000 format ('Deriv ',3i4,f10.4,' FMCSQR',f10.4,2(2f10.4,1x))
C
      IF (.NOT.SKIP) ND=ND+2
   15 CONTINUE
C
C  END OF THE DOMAIN LOOP, DO THE DOMAIN AVERAGE
C  DIVIDE BY NDOM AS REQUIRED AND RETURN Fm*DFm/DPar IN FMCDER
      DO 20 IM=1,NMAG
      IR=JMAGAT(IM)
      DO 20 IP=1,24
      L=LMAGPR(IP,IM,IR)
      IF (L.EQ.0) GO TO 20
      LL=L-LO
      FMCDER(L)=FMCDER(L)/(FKSTAR*FLOAT(ND/2))
C  TEST OUTPUT
      IF (BINDIG(IOUT,64)) WRITE (LPT,4002) L,FMCDER(L)
 4002 FORMAT (' Fm*dFm/dp for p=',I2,4X,3(2E12.4,2X))
   20 CONTINUE
C NOW THE DOMAIN AVERAGE FOR FMCSQR
        FMCSQR=FMCSQR/(FKSTAR*FLOAT(ND/2))
        FMCMOD=SQRT(FMCSQR)
C finally the order parameters
      DO 32 irep=1,2
      do 32 IAP = 1,2
      l=kspord(IREP,IAP)
      if (l .ne.0) then
        FMCDER(L)=FMCDER(L)/(FKSTAR*FLOAT(ND/2))
      endif
   32 continue
C
 100  RETURN
      END
C
C
C
C
C LEVEL 4      SUBROUTINE LSETSF(NW,LSPEC,LWORDS)
      SUBROUTINE LSETSF(NW,LSPEC,LWORDS)
C
C *** LSETSF Updated for INCM words by PJB C4.26 March 2013 ***
C
CX
CC 6A
CH Sets up vocabulary for a specific LSQ problem involving structure factors.
CA NW on entry is the number of words in this problem's specific vocabulary
CA LSPEC on entry is an array specifying the meaning of the words
CA       with 3 integers per word - family, genus, species
CA LWORDS on entry is an A4 array of words in this problem's vocabulary
CP The problem must have already been specified to the extent of:
CP    NFAM=number of families
CP    NGENS(I)=number of genera in family I
CP    NSPC(I)=number of species in each genus of family I
CD Sets up the packing of IFAM, IGEN, ISPC into one integer
CD Packs the LSPEC integers to 1 word
CD First sets up the standard Structure Factor LSQ vocabulary for family 2
CD parameters (and cell from family 1).
CD Copies both arrays LSPEC and LWORDS into standard arrays IWDSPC  and
CD LSQWD in /WDSPEC/ and /WORDS/.
C
CN Because of its use of the standard family 2 names and numbers, it determines
CN these to be the same in every application (e.g. B11 is always species 4).
CN If this is not what is wanted, use LSETUP and give it the entire vocabulary.
C
      EXTERNAL F2PARS
      CHARACTER *4 LWORDS(NW),MWORDS(38)
      DIMENSION LSPEC(3,NW),LPAK(3),MSPEC(3,22)
/F2NAMS/
/F2NUMS/
/LINKAG/
/LSQPAK/
/PRBLEM/
C109 Add common REFINE to make MAG available
/REFINE/
/WDSPC/
/WORDS/
C
C125 Force inclusion of BLOCK DATA F2NAME
      CALL F2PARP
C CHECK NFAM:
%      CALL ERRCHK(1,NFAM,%FAMS%,0,'LSQ families of parameters')
C
      MGEN=0
      MSPC=0
      DO 1 I=1,NFAM
      IF (NGENS(I) .GT. MGEN) MGEN=NGENS(I)
      IF (NSPC(I) .GT. MSPC) MSPC=NSPC(I)
   1  CONTINUE
      IF (MGEN .LE. 0) CALL ERRMES(1,0,
     & 'maximum genera in any family is 0')
      IF (MSPC .LE. 0) CALL ERRMES(1,0,
     & 'maximum species in any genus is 0')
C
C SET UP PACKING OF IFAM,IGEN,ISPC:
      LPAK(1)=NFAM
      LPAK(2)=MGEN
      LPAK(3)=MSPC
      CALL NPACK(N,LPAK,3,0,KKPACK)
C
C WORDS RELEVANT TO THIS PROBLEM FROM DATA INTO COMM0N:
C
      IWDNUM=0
      NMWRDS=0
C FIRST PUT IN STANDARD FAMILY 2 PARAMETERS, AND CELL:
%      NPARS = %F2PR%
C4.26 CVPARS makes vocab for INCM type if required
      IF (MAG) CALL CVPARS(NMWRDS,MWORDS,MSPEC)
%      IF ((NMWRDS.ne.0) .OR. .NOT. MAG .OR. CHI) NPARS = NPARS-%MPAR%
      CALL VOCAB(F2NAME,NF2NUM,NPARS)
      IF (NMWRDS .GT. 0) CALL VOCAB(MWORDS,MSPEC,NMWRDS)
C NOW THE SPECIAL ADDITIONAL VOCABULARY:
      CALL VOCAB(LWORDS,LSPEC,NW)
C
C PREPARE FIX LIST AND CONSTRAINT LIST FOR CALLS OF ADDFIX, ADDCON
      NUMFV=0
      NUMPAK=0
      NUMCON=0
      KPTCON(1)=1
      RETURN
      END
C
C
C
C
C LEVEL 4      SUBROUTINE LSETUP(NW,LSPEC,LWORDS)
      SUBROUTINE LSETUP(NW,LSPEC,LWORDS)
C
C *** LSETUP updated by JCM 26 Jun 89 ***
C
CX
CC 6A
CH Sets up specific LSQ problem - copies the vocabulary to standard COMMON.
CA NW on entry is the number of words in this problem's vocabulary
CA LSPEC on entry is an array specifying the meaning of the words
CA       with 3 integers per word - family, genus, species
CA LWORDS on entry is an A4 array of words in this problem's vocabulary
CP The problem must have already been specified to the extent of:
CP    NFAM=number of families
CP    NGENS(I)=number of genera in family I
CP    NSPC(I)=number of species in each genus of family I
CD Packs the LSPEC integers to 1 word
CD Copies both arrays LSPEC and LWORDS into standard arrays IWDSPC  and
CD LSQWD in /WDSPEC/ and /WORDS/.
CD Sets up the packing of IFAM, IGEN, ISPC into one integer
C
      CHARACTER *4 LWORDS(NW)
      DIMENSION LSPEC(3,NW),LPAK(3)
/LINKAG/
/LSQPAK/
/PRBLEM/
/WDSPC/
/WORDS/
C
C CHECK NFAM:
%      CALL ERRCHK(1,NFAM,%FAMS%,0,'LSQ families of parameters')
C
      MGEN=0
      MSPC=0
      DO 1 I=1,NFAM
      IF (NGENS(I) .GT. MGEN) MGEN=NGENS(I)
      IF (NSPC(I) .GT. MSPC) MSPC=NSPC(I)
   1  CONTINUE
C
C SET UP PACKING OF IFAM,IGEN,ISPC:
      IWDNUM=NW
C CHECK ARRAY SIZES:
%      CALL ERRCHK(1,NW,%WORD%,0,'words specifying LSQ problem')
      IF (MGEN .LE. 0) CALL ERRMES(1,0,
     & 'maximum genera in any family is 0')
      IF (MSPC .LE. 0) CALL ERRMES(1,0,
     & 'maximum species in any genus is 0')
C
      LPAK(1)=NFAM
      LPAK(2)=MGEN
      LPAK(3)=MSPC
      CALL NPACK(N,LPAK,3,0,KKPACK)
C
C WORDS RELEVANT TO THIS PROBLEM FROM DATA INTO COMM0N:
      DO 2 I=1,IWDNUM
      DO 7 J=1,3
   7  LPAK(J)=LSPEC(J,I)
      IF (LPAK(1) .LT. 0) IWDSPC(I)=LPAK(1)
      IF (LPAK(1) .GE. 0) CALL NPACK(IWDSPC(I),LPAK,3,1,KKPACK)
   2  LSQWD(I)=LWORDS(I)
C
C PREPARE FIX LIST AND CONSTRAINT LIST FOR CALLS OF ADDFIX, ADDCON
      NUMFV=0
      NUMPAK=0
      NUMCON=0
      KPTCON(1)=1
      RETURN
      END
C
C
C
C
C LEVEL 9      SUBROUTINE LSQCYC(ALSQ,MATSZ,QFCALC,QMCALC)
      SUBROUTINE LSQCYC(ALSQ,MATSZ,QFCALC,QMCALC)
C
C *** LSQCYC updated  by PJB C4.26/7 for REFI 10 and 11 April 2013 ***
CCX
CC 7B
CH Does the least squares cycles for most structure factor least squares programs
C
CA ALSQ is the least squares matrix
CA MATSZ its dimension
CA QFCALC is the name of the routine to get nuclear structure factors and derivatives
CA QMCALC is the name of the routine to get magnetic structure factors and derivatives
CP Structure factor data must have been set up in various COMMON blocks
CP by SYMOP RECIP ATOPOS, SETFOR, SETANI
CP LSETUP, PARSSF, VARMAK must have set up the Least Squares.
CP STLSSF must have read the L cards
CD Most of this code used to be separatelly in each least squares main program. It
CD has been made into a single subroutine  to facilitate maintenance of the
CD multisource code.

      EXTERNAL QFCALC,QMCALC
      DIMENSION K(3),IPDIR(2),ALSQ(MATSZ)
%      CHARACTER *120 HEADRS(%DSRC%), FRMATS(%DSRC%) *(60)
      LOGICAL PRNCYC,PRINT
      LOGICAL FIXI,SNP,POWP,POL,QXQ
      CHARACTER *120  HEADER,FMTLST*60
      CHARACTER *24 BUFF

/DERBAS/
/DEPMAT/
/DGEOM/
/DSOURC/
/EXTN/
/FCAL/
/IOUNIT/
/MAGCHI/
/MCAL/
/NSYM/
/OBSCAL/
/POLDA/
/REFINE/
/SATELL/
/SCLDAT/
/SFDATA/
/SFHEDP/
/SLAKDA/
/SLKGEO/
/SYMMAG/

      SAVE CHISUM,MSAVE,HEADRS,FRMATS
C Least squares cycles
C SET UP POINTERS IN TRIANGULAR MATRIX AND CLEAR OUT LSQ MATRIX AND RHS:
      CALL MATSET(ALSQ,MATSZ)
      CHISUM=0.
      WRITE (ITO,2042) ICYC
2042  FORMAT(' >>> Starting cycle ',I3)
C AVOID STRUCTURE FACTOR PART IF TYPE 1:
      IF (SLONLY) GO TO 19
C IS PRINTING OF STRUCTURE FACTOR LIST REQUESTED THIS CYCLE?
      PRINT=PRNCYC(1)
C
      NSTART=1
C CYCLES OVER SOURCES
      DO 4 JSRC=1,NUMSRC
      IREF=(MSRC(2,JSRC))
      MDAT=(MSRC(1,JSRC))
      FIXI=(.NOT. MAG .OR. IPROP.LE.0)
      SNP=(IREF .EQ. 8)
      POWP=(IREF.EQ.9 .OR. IREF.EQ.10)
      POL=(IREF.EQ.5 .OR. IREF .EQ.7 .OR.
     &((IREF .GE. 9) .AND. (IREF .LE.11)))
C4.26 New logical QXQ for polarised Q X Q* refinement
      QXQ=(IREF.eq.11)
      IF (ICYC.EQ.NCYC1) THEN
        IF (FIXI) THEN
          HEADER='     h    k    l.'
          FMTLST='(1X,A15,'
        ELSE
          HEADER='      h       k       l  .'
        FMTLST='(1X,a24,'
        ENDIF
        LEN=LENGT(HEADER)
        LEF=LENGT(FMTLST)+1
        IF (SNP) THEN
          HEADER(LEN:)='   Pi  Pa .'
          FMTLST(LEF:)='1X,2I4,'
          LEN=LENGT(HEADER)
          LEF=LENGT(FMTLST)+1
        ENDIF
        HEADER(LEN:)='    G(obs)   G(calc)     Diff'
        LEN=LENGT(HEADER)+1
        IF (SNP) THEN
          HEADER(LEN:)='    |Fnuc|    |Fmag|    WDifSqr   '
          FMTLST(LEF:)='3f10.3,2f10.4,E12.3,'
        ELSE IF (POWP) THEN
          HEADER(LEN:)='    F(nucl)    F(mag)    N M.P      Scale'
          FMTLST(LEF:)='3f10.1,4f10.4,'
        ELSE IF (POL) THEN
          HEADER(LEN:)='    F(nucl)    F(mag)    Xterm     DePoln'
          FMTLST(LEF:)='7F10.4,'
        ELSE IF (MAG) THEN
          HEADER(LEN:)='    |Fnuc|    |Fmag|      |Fc|      Scale'
          FMTLST(LEF:)='3f10.3,3f10.4,1X,f10.3,'
        ELSE IF (CENTRC) THEN
          HEADER(LEN:)='    Sgnd Fc     Scale'
          FMTLST(LEF:)='3f10.3,f10.4,F10.3,'
        ELSE
          HEADER(LEN:)='      F(nucl)     Scale'
C4.28  Format for acentric structure factors corrected  to 2f10.4
          FMTLST(LEF:)='3f10.3,2f10.4,F10.3,'
        ENDIF
        LEN=LENGT(HEADER)+1
        LEF=LENGT(FMTLST)+1
        HEADER(LEN:)='   Weight      IREF'
        FMTLST(LEF:)='G12.4,I5)'
        FRMATS(JSRC)=FMTLST
        HEADRS(JSRC)=HEADER
      ELSE IF (PRINT) THEN
        FMTLST= FRMATS(JSRC)
        HEADER=HEADRS(JSRC)
      ENDIF
C
C4.26 Set Up multisource chisq
      IF (JSRC .EQ.1) THEN
        CALL RFACS(21)
      ELSE
        CALL RFACS(11)
      ENDIF
C
C Always try to read wavelength and lamhf
      IF (SRCPAR(LHEAD(2),JSRC) .GT.0) THEN
        WLGTH=SRCPAR(LHEAD(2),JSRC)
        ALAM2=SRCPAR(LHEAD(2)+1,JSRC)
      ENDIF
      IF (POL) THEN
        POLUP=SRCPAR(1,JSRC)
        POLDW=SRCPAR(2,JSRC)
        if (.NOT. POWP) THEN
          CALL GMEQ(SRCPAR(3,JSRC),POLND,3,1)
        IF (QXQ) go to 20
C May need to switch to FERA for polarised data
C Should only be necessary when change in data source
          IF (.NOT. FERA .AND. .NOT. PARA .AND. .NOT. ANTI) THEN
             MSAVE = MTYP
            MTYP = 2
            CALL LOGMAG
          ENDIF
        ELSE
          IF (FERA) THEN
            MTYP=MSAVE
            CALL LOGMAG
          ENDIF
        ENDIF
      ENDIF
C NEED THE FIELD VALUE AND DIRECTION IF PARAMAGNETIC
      IF (PARA) THEN
        FIELD=SRCPAR(LHEAD(NHEAD),JSRC)
        CALL GMEQ(SRCPAR(3,JSRC),POLND,3,1)
C        WRITE (LPT,5002) FIELD
C 5002  FORMAT ('MAGNETIC FIELD' ,F8.3)
      ENDIF
C
   20 IF (PRINT)  WRITE (LPT,2000) (HEADER(I:I),I=1,LENGT(HEADER))
2000  FORMAT(//' Structure factor listing :'/120A1)
C
      NEND=NOBSRC(JSRC)
      DO 5 N=NSTART,NEND
      OBS=GOBS(N)
      WT=WGTS(N)
      ICODE=ICODES(N)
      IF (IEXTYP .NE.0) THEN
        CALL GMEQ(CPARS(1,N),CEXT,4,1)
        IPOS=5
      ELSE
        IPOS=1
      ENDIF
      ISCALE=JSCALE(N)
C Pick up other parameters attached to the data
      IF (SNP) THEN
        IPDIR(1)=NINT(CPARS(1,N))
        IPDIR(2)=NINT(CPARS(2,N))
        POLND(1)=SRCPAR(11,JSRC)
        POLND(2)=SRCPAR(14,JSRC)
        POLND(3)=SRCPAR(17,JSRC)
        IPOS=3
      ENDIF
C
C CALCULATE FUNCTION TO MATCH OBSERVED, AND ITS DERIVATIVES:
      IF (POWP) THEN
C        write (lpt,5000) n,(hs(i,n),i=1,3), OBS,WT,ICODES(N)
C 5000 format (i4,3f5.0,f8.1,G12.4,i4)
        CALL CALPOW(HS(1,N),ICODES(N),CPARS(1,N),QFCALC,QMCALC)
      ELSE IF (SNP) THEN
C      WRITE (LPT,4000) N,(HS(I,N),I=1,3),obs,wt,IPDIR,ICODE
C 4000 FORMAT (i4,3F8.3,2f10.4,3I5)
        CALL CALCPA(HS(1,N),IPDIR,QFCALC,QMCALC)
      ELSE IF (POL) THEN
C4.26 Call to new CALCQX
        IF (QXQ) THEN
          CALL CALCQX(HS(1,N),QMCALC)
        else
          CALL CALCFR(HS(1,N),QFCALC,QMCALC)
        endif
      ELSE IF (IREF .EQ. 6) THEN
        CALL CALCGM(HS(1,N),QFCALC,QMCALC)
      ELSE IF (MAG) THEN
        CALL CALCMG(HS(1,N),QFCALC,QMCALC)
      ELSE
        CALL CALCSF(HS(1,N),QFCALC)
      ENDIF
C CALCXX FORMS GCALC,  PUTS DG/DV INTO DERIVV FOR ALL VARIABLES, AND SETS UP
C ALL REQUIRED QUANTITIES IN OBSCAL FOR SUBSEQUENT CALLS OF MATREF AND RFACS
C
C MAKE DERIVATIVES WRT BASIC VARIABLES FROM THOSE WRT VARIABLES:
      CALL RELATE
C
C DIFFERENCES AND WEIGHTS:
      DIFF = OBS - GCALC
      CALL WGHTSF
C GETS WEIGHT AND SQRTWT INTO COMMON
C
C STRUCTURE FACTOR LISTING IF REQUIRED:
      IF (PRINT) THEN
        IF (FIXI) THEN
          CALL INDFIX(HS(1,N),K)
          WRITE (BUFF,2001) K
 2001     FORMAT (3I5)
        ELSE
          WRITE (BUFF,2002) (HS(I,N),I=1,3)
 2002     FORMAT (3F8.3)
        ENDIF
        IF (SNP) THEN
          WRITE (LPT,FMTLST)BUFF,IPDIR,OBS,GCALC,DIFF,FCMOD,FMCMOD,
     &    WDIFF2,WT,IREF
        ELSE IF (MAG) THEN
          WRITE (LPT,FMTLST) BUFF,OBS,GCALC,DIFF,FCMOD,FMCMOD,
     &    YCALC,SCALE(ISCALE),WT,IREF
        ELSE IF (CENTRC) THEN
          WRITE (LPT,FMTLST) BUFF,OBS,GCALC,DIFF,REAL(FC),
     &    SCALE(ISCALE),WT,IREF
        ELSE
          WRITE (LPT,FMTLST) BUFF,OBS,GCALC,DIFF,FC,
     &    SCALE(ISCALE),WT,IREF
C DEPOSITED MATERIAL:
          IF (ICYC .EQ. LASTCY .AND. IPRNT(7) .NE. 0) WRITE (LDEP,
     &     2010) K,OBS,DOBS,GCALC
2010  FORMAT (3I5,F10.3,F10.4,F10.3)
        ENDIF
      ENDIF
C
C ADD IN TO R FACTORS:
      CALL RFACS(12)
C ADD DERIVATIVES IN TO LSQ MATRIX:
      CALL MATTOT(ALSQ,MATSZ)
C NEXT OBSERVATION:
    5 CONTINUE
C Do R factor output for each data set
      CALL RFACS(3)
      NSTART=NEND+1
C Save the intermediate chisqr total
      CHISUM=CHISUM+SUMWD
C NEXT DATA SET
    4 CONTINUE
C
C END OF DATA
C IF SLACK CONSTRAINTS, ADD IN:  and PRINT COMBINED CHI SQUARED
   19 IF (NSLAK(1) .GT. 0)  THEN
        CALL GEOMLS(ALSQ,MATSZ)
        CALL RFACS(6)
      ENDIF
C
C 4.26 Collect total over different data sets
      CALL RFACS(13)
      IF (NUMSRC .GT.1) THEN
        CHI22=CHISUM/(NDATA-LVARB)
        WRITE (LPT,2006) NUMSRC,CHI22,NDATA,LVARB
 2006 FORMAT (/' Chisqrd over all',I3,' data sets:',F8.1,
     &' for',I6,' observations and',I5,' parameters')
      ENDIF
C INVERT MATRIX:
      CALL MATINV(ALSQ,MATSZ)
C CALCULATE SHIFTS AND ESD'S:
      CALL MATSHF(ALSQ,MATSZ)

C NEXT OBSERVATION:
      RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE LSTCTS(C,D,TMORTS)
      SUBROUTINE LSTCTS(C,D,TMORTS)
C
C *** LSTCTS into Library Nov 1997 ***
C
CC 2C
CH Calculates a dead time correction
CD Calculates the correction to be applied to a counting rate R due to
CD detector non-linearity. The corrected rate \$R_c\$ is given by
CD \$\$R_c=R/(1-rt_1-r^2t_2)\$\$
CA On entry:
CA       C is the uncorrected count-rate
CA       TMORTS(1) and TMORTS(2) the constants \$t_1\$ and \$2_2\$ and
CA       TMORTS(3) and TMORTS(4) their esd's
CA   On exit:
CA       C is the correction factor by which the observed count should be
CA       multiplied
CA       D is its esd
C
CN Used by DOP97 and CRYPAD
C
      DIMENSION TMORTS(4)
      R=C
      R2=R*R
      V=D
      C=1./(1.-R*TMORTS(1)-R2*TMORTS(2))
      C2=C*C
C      D=C2*(1.+ R2*C2*(TMORTS(3)**2+(R2*TMORTS(4)**2)))
       D=C2*(R2*C2*(TMORTS(3)**2+(R2*TMORTS(4)**2)))
      RETURN
      END
C
C
C
C
C
C
C
C
C LEVEL 4      LOGICAL FUNCTION MAGABS(H,IK)
      LOGICAL FUNCTION MAGABS(H,IK)
C
C *** MAGABS updated by PJB C4.26 Don't need common MAGDAT  March 2013 ***
CX
CC 17B
CH Tests for systematic absence of magnetic reflections.
CA On entry H is a 1x3 array holding h,k,l
CA On exit MAGABS = .TRUE. if absent, .FALSE. if present
CA         IK is +1 if the indices correspond to a r.l.v + the
CA            propagation vector ie h=g+k
CA         IK is -1 if h=g-k
CA         IK is 0 if this is irrelevant.
CP The space group symmetry should have been set up by SYMOP
CP The propagation vector PROP should have been set up by DOMAG1
C
      DIMENSION H(3),TEST(3)
      LOGICAL M,LATABS
/SATELL/
C
      IK=0
      IF (IPROP.EQ.0) THEN
        M=LATABS(H)
      ELSE
        CALL GMADD(H,PROP,TEST,3,1)
        M=LATABS(TEST)
        IF (M) THEN
          CALL GMSUB(H,PROP,TEST,3,1)
          M=LATABS(TEST)
          IF (.NOT. M) IK=1
        ELSE
          IK=-1
        ENDIF
      ENDIF
      MAGABS=M
      RETURN
      END
C
C
C
C
C LEVEL 5      SUBROUTINE MAGCNC
      SUBROUTINE MAGCNC
C
C *** MAGCNC Updated for INCM March 2013 ***
C
CX
CC 17A
CH To find magnetic constraints in a non-least squares calculation.
CP The magnetic symmetry must have been set up by calls to SYMOP and
CP DOMAG1
C
      DIMENSION FIX(12),NFIX(12)
      LOGICAL LMFIX(3),FIRST
/MAGDAT/
/SYMMAG/
C
      FIRST=.TRUE.
      DO 1 MAT=1,NMAG
C4.26 for INCM
      IF (CPVEC) THEN
       CALL CPVCON(MAT,12,FIRST,NFIX,FIX)
C IF FERROMAGNETIC NO CONSTRAINTS
      ELSE IF (.NOT. (FERO .OR. FERA)) THEN
        CALL MAGCON(MAT,LMFIX,FIRST)
      ENDIF
C141 PSICON now called from within MAGCON
C SET UP SPHERICAL POLARS:
      CALL SPHPOL(ANGM(1,MAT),ANGM(2,MAT),SPIND(1,1,1,MAT),1)
      IF (HELI) THEN
        CALL SPHPOL(ANGM(3,MAT),ANGM(4,MAT),SPIND(1,1,2,MAT),1)
        CALL SPHELI(MAT,0)
      ENDIF
    1 CONTINUE
      RETURN
      END
C
C
C
C
C LEVEL 9      SUBROUTINE MAGCNL
      SUBROUTINE MAGCNL
C
C *** MAGCNL Updated for INCM c4.26 March 2013 ***
C
CX
CC 17A
CH Does the fixing associated with constraints found by MAGCON and PSICON.
C
      LOGICAL LMFIX(3),FIRST,FIRSTP
      DIMENSION KKLIST(12),FIX(12),NFIX(12)
/IOUNIT/
/MAGDAT/
/PHASE/
/POSNS/
/SYMMAG/
%      DATA NSTYPE,NPSI/8,%PSIS%/
C
      FIRST=.TRUE.
      FIRSTP=.TRUE.
C  WORK OVER ALL ATOMS
      DO 1 IAT=1,NATOM
      IATO=MAGAT(IAT)
C FIX THE MAGNETIC PARAMETERS FOR THE NON-MAGNETIC ATOMS:
      IF (IATO .EQ. 0) THEN
        DO 42 I=13,22
        CALL ADDFX5(2,IAT,I,JPHASE,1,5)
  42    CONTINUE
      ELSE
C  IF FERROMAGNETIC NO CONSTRAINTS:
        IF (FERO .OR. FERA) THEN
C A single moment is the only variable parameter
          DO 6 I=13,20
          CALL ADDFX5(2,IAT,I,JPHASE,1,5)
    6     CONTINUE
          CALL ADDFX5(2,IAT,22,JPHASE,1,5)
          GO TO 3
C CONSTRAINTS FOR THIS ATOM:
        ELSE IF (CPVEC) THEN
C4.26 Added for INCM type
          CALL CPVCON(IATO,12,FIRST,NFIX,FIX)
          FIRST=.FALSE.
          DO 20 N=1,12
          KKLIST(N)=KPAK(2,IAT,N+12,1,1)
   20     CONTINUE
          CALL FIXREL(12,NFIX,FIX,KKLIST,5)
          GO TO 1
        ENDIF
C141 PSICON now called from within MAGCON
        CALL MAGCON(IATO,LMFIX,FIRST)
C KEEP IN CASE THESE ARE LSQ PARAMETERS:
        DO 2 I=1,2
        IF (LMFIX(I)) CALL ADDFX5(2,IAT,12+NPSI+I,JPHASE,1,5)
    2   CONTINUE
        IF (LMFIX(3)) CALL ADDFX5(2,IAT,17+NPSI,JPHASE,1,5)
C FILL IN DIFFERENTIALS PARTS OF SD
   3    CALL SPHPOL(ANGM(1,IATO),ANGM(2,IATO),SPIND(1,1,1,IATO),3)
        IF (HELI) THEN
C PUT CONSTRAINTS ON SECOND COMPONENT
          DO 5 I=1,2
          IF (LMFIX(I)) CALL ADDFX5(2,IAT,14+NPSI+I,JPHASE,1,5)
    5     CONTINUE
          IF (LMFIX(3)) CALL ADDFX5(2,IAT,18+NPSI,JPHASE,1,5)
C  AND SET THE PERPENDICULARITY CONSTRAINTS
          CALL SPHPOL(ANGM(3,IATO),ANGM(4,IATO),SPIND(1,1,2,IATO),3)
          CALL SPHELI(IATO,1)
        ENDIF
C  FIX THE PSI'S IF REQUIRED
        IF (.NOT.MODUL) NPHI(IATO)=0
        DO 4 I=1,NPSI
        IF (I .GT. NPHI(IATO)) THEN
          CALL ADDFX5(2,IATO,12+I,JPHASE,1,5)
        ELSE IF (FIRSTP) THEN
C  ONE (the first) PSI must be fixed
          CALL ADDFX5(2,IATO,12+I,JPHASE,1,5)
          FIRSTP=.FALSE.
        ENDIF
    4   CONTINUE
      ENDIF
    1 CONTINUE
C
      RETURN
      END
C
C
C
C
C LEVEL 4      SUBROUTINE MAGCON(IATO,LMFIX,FIRST)
      SUBROUTINE MAGCON(IATO,LMFIX,FIRST)
C
C *** MAGCON corrected FCENT PJB December 2006 ***
C reoraganised for PSI's by PJB C141 March 2006 *** ***
C
CX
CC 17A
CH Finds and reports the symmetry constraints on magnetic parameters.
CA IATO is the number of the magnetic atom in question
CA LMFIX(I) is set to TRUE if parameter I for this atom is fixed by symmetry
CA FIRST is TRUE if no constraints have yet been found
C
      EXTERNAL DUMMY,RANGER
      LOGICAL FIRST,LMFIX(3),NONE
%      DIMENSION IATAB(%SYMO%),NFIX(3),FIX(3)
      DIMENSION VEC(3),TVEC(3,2),RMAT(3,3),RX(3),SCON(3)
/ATNAM/
/CONSTA/
/IOUNIT/
/MAGDAT/
/NSYM/
/POSNS/
/SATELL/
/SCRACH/
/SYMDA/
/SYMMAG/
/SYMTAB/
C
      IAT=JMAGAT(IATO)
C141 Full factorisation of the atom group now done here
      CALL MAKGRP(ISGEN(1,IAT),IATAB,0,DUMMY)
      CALL FACGRP(IATAB,IATAB,NFAC)
C4.1 FCENT true when structure centric, magnetic and groups are  not
      FCENT(IATO)=(CENTRC .AND. MSTAB(NOPC+1) .EQ.0
     & .AND.ISGEN(1,IAT).GT.0)
C  CHECK THAT STRUCTURE AND SYMMETRY ARE COMPATIBLE WITH THE
C  PROPAGATION VECTOR
      DO 28 N=2,NOPC
      IF (IABS(KSTAB(N)).NE.1 .AND. IATAB(N).EQ.0) THEN
        WRITE (ITO,2800) N
        WRITE (LPT,2800) N
 2800   FORMAT (/' ERROR ** Structure symmetry is reduced by ',
     &   'that of the propagation vector (operator #',I2,').'/
     &  ' **** Change S cards ****')
        STOP
      ENDIF
   28 CONTINUE
C
      CANG1=ANGM(1,IATO)
      CANG2=ANGM(2,IATO)
      DO 29 J=1,3
      LMFIX(J)=.FALSE.
  29  NFIX(J)=9999
      N=ISGEN(1,IAT)
C  JUMP IF NOT SPECIAL
      NONE = N.EQ.1
      IF (NONE) GO TO 17
C
      IF (N.LT.0) THEN
C CENTRE OF SYMMETRY PRESENT: IF ATOM IS NOT AT ORIGIN WHAT
C LATTICE VECTOR IS INVOLVED
        CALL GMREV(X(1,IAT),TVEC,1,3)
C120 ADD changed to SUB Oct 2002
        CALL GMSUB(X(1,IAT),TVEC,VEC,3,1)
C  CHECK THE PHASE SHIFT
        PH=2.*SCALPR(PROP,VEC)
        DPHI=(PH-NINT(PH))
        IF (ABS(DPHI).GT. 0.001) THEN
          CALL ERRCH2(ATNAME(IAT),1,
     & 'The centre of symmetry is not consistent with a moment on',
     & 'for this propagation vector')
        ELSE
C MC SHOULD BE + 0R - 1
          MC=1-IABS(2*MOD(NINT(PH),2))
C MAGNETIC GROUP CENTRIC OR ANTICENTRIC
          IF (MC.EQ. MTSYM(NOPC+1)) GO TO 30
          IF (MSTAB(NOPC+1).GT.0) THEN
C  CAN HAVE NO MOMENT:
            NFIXED=3
            DO 2 I=1,3
   2        LMFIX(I)=.TRUE.
            SMOD(1,IATO)=0.
            CANG1=0.
            CANG2=0.
            GO TO 17
          ENDIF
C HERE IF CENTRE IS AN NSYM
          CALL GMEQ(OTRSYM(1,1,NOPC+1),RMAT,3,3)
          IF (MC.LT.0) CALL GMREV(RMAT,RMAT,3,3)
          CALL RELSM3(RMAT,NFIX,FIX)
        ENDIF
      ENDIF
C
C  LOOK TO SEE WHICH ELEMENTS OF THE ATOM SUB-GROUP ARE
C  IN THE MAGNETIC SYMMETRY GROUP
   30 DO 3 K=2,NOPC
      IF (IABS(IATAB(K)).NE.1) GO TO 3
C112 SKIP ELEMENTS NOT IN THE LITTLE GROUP
      IF (IABS(KSTAB(K)).NE.1) GO TO 3
      CALL GMEQ(OTRSYM(1,1,K),RMAT,3,3)
C  REVERSE THE MATRIX IF OPERATION IS COMBINED WITH INVERSION, AND
C  THE INVERSION IS TIME-REVERSING
      IF (IATAB(K) .LT.0 .AND. MTSYM(NOPC+1).LT.0)
     &  CALL GMREV(RMAT,RMAT,3,3)
C IN CASE OF SHIFT BY A LATTICE VECTOR:
      IF (IPROP .NE. 0) THEN
        CALL ROTSYM(X(1,IAT),RX,K,1)
        CALL GMADD(RX,TRANS(1,K),RX,3,1)
C87 REVERSE IF CENTROSYMETRIC OPERATOR REQUIRED
        IF (IATAB(K) .LT. 0) CALL GMREV(RX,RX,3,1)
        CALL GMSUB(RX,X(1,IAT),RX,3,1)
C  GET THE PHASE SHIFT
        PH=2.*SCALPR(PROP,RX)
C        write (lpt,1000) k,rx,ph
C 1000 format (i3,3f8.4,2x,f8.3)
        DPHI=(PH-NINT(PH))
        IF (ABS(DPHI).GT. 0.001) THEN
          KK=K*IATAB(K)
          CALL ERRIN2(KK,-1,'Operator',
     &   'is not consistent with a moment on '//ATNAME(IAT)//
     &   'for this propagation vector')
          GO TO 3
        ELSE
C MC SHOULD BE + 0R - 1
          MC=1-IABS(2*MOD(NINT(PH),2))
          IF (MC.LT.0) CALL GMREV(RMAT,RMAT,3,3)
        ENDIF
      ENDIF
      CALL RELSM3(RMAT,NFIX,FIX)
    3 CONTINUE
C
C  NOW CONVERT XYZ CONSTRAINTS TO SPHERICAL POLAR ONES
C  COUNT FIXED PARS
      NFIXED=0
      NREL=0
      DO 5 I=1,3
      IF (NFIX(I).EQ.0) THEN
        NFIXED=NFIXED+1
      ELSE
C CHECK THAT THIS 9999 IS STILL OK:
        IF (NFIX(I).LT.9999) NREL=NREL+1
      ENDIF
    5 CONTINUE
C
      GO TO (10,11,12,13) NFIXED+1
C
C ALL FIXED
   13 DO 6 I=1,3
   6  LMFIX(I)=.TRUE.
      GO TO 17
C
C  TWO FIXED - FIND WHICH
   12 IF (NFIX(1).EQ.0 .AND. NFIX(2).EQ.0) THEN
        CANG1=0.
      ELSE
        CANG1=90.
      ENDIF
      LMFIX(1)=.TRUE.
    7 IF (NFIX(1).EQ.0) CANG2=90.
      IF (NFIX(2).EQ.0) CANG2=0.
      LMFIX(2)=.TRUE.
      GO TO 10
C
C  ONE FIXED
   11 IF (NFIX(3).NE.0) GO TO 7
      CANG1=90.
      LMFIX(1)=.TRUE.
C
C  NOW RELATIONSHIPS
   10 GO TO (8,8,15,16) NREL+1
C NONE
    8 NONE = NFIXED.EQ.0
      GO TO 17
C
C  ALL THREE RELATED - FIX BOTH ANGLES
   16 CANG2=ATAN2(FIX(1),FIX(2))
C127 this was      CANG1=DEGREE(ATAN2(FIX(1)*COS(CANG2),FIX(3)))
      CANG1=DEGREE(ATAN2(FIX(1),FIX(3)*COS(CANG2)))
      LMFIX(1)=.TRUE.
      GO TO 14
C
C  IF TWO PARS RELATED THEY SHOULD BE 1 AND 2 IF THE THIRD IS FREE
   15 IF (NFIX(3).NE.9999 .AND. NFIXED.NE.1) THEN
        WRITE (LPT,3000) NFIX
        WRITE (ITO,3000) NFIX
 3000   FORMAT (' *** PROGRAM ERROR IN MAGCON ***'/' NFIX =',3I5/
     &   ' I thought this couldn''t happen! PJB')
        STOP
      ENDIF
C
      GO TO (20,17,21,20) NFIX(1)+1
C
   21 CANG2=ATAN2(FIX(1),FIX(2))
  14  LMFIX(2)=.TRUE.
      CANG2=DEGREE(CANG2)
      GO TO 17
   20 CANG1=DEGREE(ATAN2(FIX(3),FIX(NFIX(3))))
      LMFIX(1)=.TRUE.
C
   17 IF (FIRST) CALL MESS(LPT,1,
     & 'Symmetry constraints on magnetic moments:')
      FIRST=.FALSE.
      WRITE (ICARD,2001) ATNAME(IAT)
2001  FORMAT (1X,A4,' None')
      IF  (NONE) THEN
        CALL MESS(LPT,0,ICARD)
      ELSE
C
C4.22  CHOOSE BEST DIRECTION angle constraints are +/- 180
        CALL SPHPOL(ANGM(1,IATO),ANGM(2,IATO),VEC,1)
        if (LMFIX(1)) ANGM(1,IATO)=RANGER(CANG1,0,180.)
        if (LMFIX(2)) ANGM(2,IATO)=RANGER(CANG2,0,180.)
        CALL SPHPOL(ANGM(1,IATO),ANGM(2,IATO),SCON,1)
C        write (lpt,4000)  LMFIX(1),LMFIX(2),cang1,cang2,ANGM(1,IATO),
C     &    ANGM(2,IATO)
        IF (LMFIX(1) .AND. (SCON(3)*VEC(3) .LT.-0.01)) THEN
          ANGM(1,IATO)=180.-ANGM(1,IATO)
          ANGM(2,IATO)=180.-ANGM(2,IATO)
          CALL GMREV(SCON,SCON,3,1)
        ELSE IF  (LMFIX(2) .AND. (SCON(2)*VEC(2) .LT.-0.01)) THEN
          ANGM(2,IATO)=ANGM(2,IATO)-180.
        ELSE IF  (LMFIX(2) .AND. (SCON(1)*VEC(1) .LT.0)) THEN
          ANGM(2,IATO)=ANGM(2,IATO)-180.
        ENDIF
C        write (lpt,4000) LMFIX(1),LMFIX(2),cang1,cang2,ANGM(1,IATO),
C     &   ANGM(2,IATO)
C 4000 format ('Angles: ',2l4,4f8.2)
        J=6
        IF (LMFIX(3)) THEN
C135 If the moment is constrained it must be zero
          SMOD(1,IATO)=0
          WRITE (ICARD(J:),2003) 'MU',SMOD(1,IATO)
          J=J+16
        ENDIF
        IF (LMFIX(1)) THEN
          WRITE (ICARD(J:),2002) 'THET',ANGM(1,IATO)
          J=J+16
        ENDIF
        IF (LMFIX(2)) THEN
          WRITE (ICARD(J:),2002) 'PHI',ANGM(2,IATO)
          J=J+16
        ENDIF
 2002   FORMAT (1X,A4,' =',F9.2)
 2003   FORMAT (1X,A4,' =',F9.4)
        CALL MESS(LPT,0,ICARD)
        ICARD=' '
      ENDIF
C  THE CONSTRAINTS ARE THE SAME FOR BOTH COMPONENTS OF A HELIX
      IF (HELI) THEN
        IF (LMFIX(1)) ANGM(3,IATO)=ANGM(1,IATO)
        IF (LMFIX(2)) ANGM(4,IATO)=ANGM(2,IATO)
        IF (LMFIX(3)) SMOD(2,IATO)=SMOD(1,IATO)
      ENDIF
C141 Finally call PSICON if required
      IF (MODUL)  CALL PSICON(IATO,IATAB)
      RETURN
      END
C
C
C
C
C LEVEL 6      SUBROUTINE MAGDIR(H,QLAM,QQ)
      SUBROUTINE MAGDIR(H,QLAM,QQ)
C
C *** MAGDIR corrected by PJB  12-Sept-1998 ***
C
CX
CC 17B
CA On exit QLAM is the cosine of the angle between the scattering vector
CA         and the polarisation direction.
CA         QQ is the sine of the angle between the magnetisation direction
CA         and the scattering vector.
CH Calculates various geometric corrections for various magnetic states.
CH The ENTRY ENTMAG sets up the COMMON.
CD ENTMAG sets up /MOMDIR/ to contain the magnetisation direction in AMD,
CD and MM to specify the option:
CD      MM = 1 magnetisation parallel to the omega axis
CD      MM = 2 magnetisation parallel to an axis given on an I card
CD      MM = 3 magnetisation between 1 and 2 at cos-1(csphi) to 2
CD      MM = 4 Schwinger scattering
C
      DIMENSION H(3),OH(3),EASY(3),Q(3),Q1(3)
      CHARACTER*4 INEED(4)
      LOGICAL ONCARD
/DGEOM/
/IOUNIT/
      COMMON /MOMDIR/S(3),UU(3),MM
      DATA INEED/'X','Y','Z','PHI'/
C
      CALL ORTHO(H,OH,2)
      CALL UNIVEC(OH,D)
      IF (MM.EQ.4) GO TO 31
C
      CALL VECPRD(S,OH,Q1)
      CALL VECPRD(OH,Q1,Q)
      CALL UNIVEC(Q,QQ)
      QLAM=SCALPR(Q,UU)
      GO TO 100
C
C  SCHWINGER SCATTERING
   31 SINTH=0.5*WLGTH*D
      CALL SINCOS(SINTH,B,'MAGDI3')
      D=SCALPR(OH,UU)/B
      CALL SINCOS(D,QLAM,'MAGDI2')
C FACTOR COT(THETA)/2
      QQ=(0.5*B)/SINTH
      GO TO 100
C
C  SETTING UP ENTRY
C  SETS S TO BE THE SPIN DIRECTION AND UU THE Z DIFFRACTOMETER AXIS
C  BOTH AS UNIT VECTORS ON ORTHOGONAL CRYSTAL AXES
      ENTRY ENTMAG
      UU(1)=UM(3)
      UU(2)=UM(6)
      UU(3)=UM(9)
      CALL UNIVEC(UU,D)
      IF (ONCARD('I','MAGD',AA)) GO TO 21
C  NO I MAGD CARD FOUND ASSUME MAGNETISATION PARALLEL TO POLARIZATION
      CALL MESS(LPT,1,
     & 'No I MAGD card - assume magnetistion parallel to omega axis')
      MM=1
      GO TO 23
C
   21 MM=JFIX(AA)
      GO TO (24,25,25,30) ,MM
C
C  MAGNETISATION PARALLEL TO POLARIZATION
   24 WRITE (LPT,11) MM
   11 FORMAT (/'MAGD =',I2,' magnetisation parallel to omega axis')
   23 CALL GMEQ(UU,S,3,1)
      GO TO 99
C
C  MAGNETISATION DIRECTION TO BE GIVEN
   25 JM=MM+1
      DO 26 J=1,JM
      IF (ONCARD('I',INEED(J),AA)) GO TO 28
C
C  SOMETHING MISSING
      WRITE (LPT,12) INEED(J)
   12 FORMAT (1X,A4,' direction data missing on I card')
      IERR=IERR+1
      GO TO 26
C
   28 IF (J.GT.3) GO TO 29
      Q(J)=AA
      GO TO 26
C
   29 ANGL=AA
      COSA=COS(RADIAN(ANGL))
      SINA=SIN(RADIAN(ANGL))
   26 CONTINUE
      CALL ORTHO(Q,EASY,1)
      CALL UNIVEC(EASY,D)
      IF (MM.EQ.2) THEN
        CALL GMEQ(EASY,S,3,1)
        WRITE (LPT,14) MM,Q
   14   FORMAT (/'MAGD =',I2,
     &  ' magnetisation direction parallel to',3F5.2)
      ENDIF
      IF (MM.EQ.3) THEN
        WRITE (LPT,15) MM,ANGL,Q
   15 FORMAT (/'MAGD =',I2,' Magnetisation direction at an angle',F7.2
     & ,' to the easy direction',3F5.2)
        CALL VECPRD(UU,EASY,Q)
        CALL UNIVEC(Q,D)
        CALL VECPRD(EASY,Q,Q1)
        CALL UNIVEC(Q1,D)
        CALL GMSCA(EASY,Q,COSA,3,1)
        CALL GMSCA(Q1,Q1,SINA,3,1)
        CALL GMADD(Q1,Q,S,3,1)
      ENDIF
      EANG=DEGREE(ACOS(UU(3)))
      WRITE (LPT,17) EANG
   17 FORMAT (' The easy direction is inclined at',F6.2,
     & ' degrees to the omega axis')
      GO TO 99
   99 CALL UNIVEC(S,D)
      GO TO 100
C
   30 WRITE (LPT,16) MM
   16 FORMAT (/'MAGD =',I2,' Schwinger Scattering')
  100 RETURN
      END
C
C
C
C
C LEVEL 3      SUBROUTINE MAGDOM(H,HK,IOP,SKIP)
      SUBROUTINE MAGDOM(H,HK,IOP,SKIP)
C
C *** MAGDOM by PJB Apr 87 ***
C
CX
CC 17B
CH In Least Squares refinement with magnetic scattering, forms the matrix
CH needed for derivatives of Q with respect to a spin direction.
CA On entry H is the scattering vector
CA          IOP is the symmetry operator to be used on H
CA On exit the 3x3 matrix HK contains the required matrix.
CA         LOGICAL SKIP is set to indicate
CP MTYP must indicate the type of magnetic structure.
CP NORD, MSTAB and KSTAB entries for IOP must be set.
CD  HK is formed, such that Q=KxSxK=S[HK]
C
      DIMENSION H(3),RH(3),OH(3),HK(3,3)
      LOGICAL SKIP
/SATELL/
/SYMMAG/
/SYMTAB/
C
C  FOR FERROMAGNETIC USE THE WHOLE GROUP
      IF (FERO) GO TO 2
C
      IF (IOP.NE.1 .AND. (MSTAB(IOP).NE.1.OR.KSTAB(IOP).NE.1))THEN
        SKIP = .TRUE.
        GO TO 100
      ENDIF
    2 SKIP=.FALSE.
C
      CALL ROTSYM(H,RH,IOP,2)
C  REVERSE IF IMPROPER ROTATION
      IF (NORD(IOP).LT.0) CALL GMREV(RH,RH,3,1)
      CALL ORTHO(RH,OH,2)
      CALL UNIVEC(OH,D)
      J=2
      K=3
      DO 1 I=1,3
      HK(I,I)=OH(J)*OH(J)+OH(K)*OH(K)
      HK(I,J)=-(OH(I)*OH(J))
      HK(I,K)=-(OH(I)*OH(K))
      J=K
      K=I
    1 CONTINUE
C
  100 RETURN
      END
C
C
C
C
C LEVEL 3      SUBROUTINE MAGSYM(MODE)
      SUBROUTINE MAGSYM(MODE)
C
C *** MAGSYM updated for INCM up by PJB C4.26 March 2013 ***
C
CX
CC 17B
CH Routine with 4 named entry points, MAGSYM, MELIN, NELIN and ROTMAG, to deal
CH generally with magnetic symmetry.  MAGSYM sets magnetic symmetry, MELIN puts
CH in an operator for a generator, NELIN puts in non-symmetric rotation and
CH ROTMAG rotates with a magnetic operator.
CA On entry to MAGSYM MODE = 0 to initialise
CA                           1 to generate the remaining operators and the
CA                             orthogonal spin rotations in OTRSYM
CA On entry to MELIN  IOP = which operator
CA                    VAL = + or - 1, its value
CA On entry to ROTMAG S is the 3x3 array to be rotated
CA                    IOP = which operator
CA On exit from ROTMAG RS is the 3x3 rotated array
CA On Entry to ROTCMG CS is the complex 3x2 vector to transform
CA                    IOP is which operator
CA On Exit from to ROTCMG CRS is the transformed complex 3x2 vector
CA On entry to NELIN  IOP = which operator
C                     SROT = the rotation matrix for the spin
C
      EXTERNAL MTPROD
      DIMENSION S(3,3),RS(3,3),TEMP(3,3),SROT(3,3),SMAT(2,2)
      COMPLEX CS(3,2),CRS(3,2),CTEMP(3,2)
%      DIMENSION NSTAB(%SY+1%),MJTAB(%SY+1%),IJTAB(%SY+1%)
/CARDRC/
/CELPAR/
/CONSTA/
/IOUNIT/
/NSYM/
/SATELL/
/SYMDA/
/SYMMAG/
/SYMTAB/
C
      IF (MODE.EQ.1) GO TO 20
C
C  INITIALISE
      CALL JGMZER(MTSYM,1,NOPC+1)
      MTSYM(1)=1
      CALL JGMZER(MSTAB,1,NOPC+1)
      CALL JGMZER(MCTAB,1,NOPC+1)
      MSTAB(1)=1
      CALL GMUNI(OTRSYM(1,1,1),3,3)
C
      GO TO 100
C
C  ENTRY TO PUT IN ONE MAGNETIC SYMMETRY OPERATOR
      ENTRY MELIN(IOP,VAL)
      IF (IOP.EQ.-1) IOP=NOPC+1
      IO=IABS(IOP)
      IF (ABS(VAL).LT..0001) THEN
        CALL ERRIN2(IOP,1,'Zero value for magnetic symmetry operator',
     &  ' ')
        GO TO 100
      ENDIF
C  RECORD WHETHER THE OPERATOR INVOLVED INVERSION
      MSTAB(IO)=ISIGN(1,IOP)
      MTSYM(IO)=IFIX(VAL)
      GO TO 100
C
C  ENTRY TO ADD A NON-SYMMETRIC ROTATION
      ENTRY NELIN(IOP,SROT)
      IF (IOP.EQ.-1) IOP=NOPC+1
      IO=IABS(IOP)
      CALL GMEQ(SROT,OTRSYM(1,1,IO),3,3)
C  MARK NON-SYMMETRIC OPERATORS
      MSTAB(IOP)=100
      GO TO 100
C
C FORM THE REST OF THE MAGNETIC OPERATORS FROM THE MULTIPLICATION TABLE
   20 ISERR=0
      DO 21 IO=2,NOPC+1
      IF (MSTAB(IO).EQ.100) THEN
        NSTAB(IO)=1
        MSTAB(IO)=0
      ELSE
        NSTAB(IO)=0
      ENDIF
   21 CONTINUE
      IF (FERO .OR. FERA) THEN
        CALL GMUNI(OTRSYM(1,1,NOPC+1),3)
        GO TO 100
      ENDIF
      IF (CENTRC) THEN
        IF (MSTAB(NOPC+1).EQ.0.) THEN
          CALL MESS(LPT,1,'No centre of symmetry in the magnetic group')
          IF (NSTAB(NOPC+1).EQ.0) THEN
            CALL ERRMES(1,2,
     &   'No spin rotation given for centrosymmetrically related atoms')
          ELSE
            WRITE (LPT,2031) ((OTRSYM(I,J,NOPC+1),I=1,3),J=1,3)
 2031       FORMAT (/' Spin rotation for centro-symmetrically related',
     &      ' atoms is: ',3F6.2,2(/58X,3F6.2))
          ENDIF
        ELSE
          CALL GMUNI(OTRSYM(1,1,NOPC+1),3)
          IF (MTSYM(NOPC+1).LT.0) CALL
     &    GMREV(OTRSYM(1,1,NOPC+1),OTRSYM(1,1,NOPC+1),3,3)
        ENDIF
      ENDIF
C

      CALL JGMEQ(MSTAB,MJTAB,NOPC+1,1)
C MAKE THE MAGNETIC SUBGROUP
      CALL GENGRP(MJTAB,MJTAB,MSTAB,1,MTPROD)
      WRITE (LPT,2001) (ISIGN(I,MSTAB(I)),MTSYM(I),I=1,NOPC)
 2001 FORMAT (/' Magnetic symmetry operators: ',12(I3,'=',I3,';')/31X
     &12(I3,'=',I3,';'))
      I=NOPC+1
      IF (CENTRC) WRITE (LPT,2005) ISIGN(I,MSTAB(I)),MTSYM(I)
 2005 FORMAT ('Centre of Symmetry:',I3,' =',I3)
C EXTRACT THE FACTOR GROUPS
      CALL FACGRP(MSTAB,MSTAB,NDOM)
      WRITE (LPT,5001) NDOM
 5001 format (i4,' Domains')
C
C PUT SPIN ROTATIONS ONTO ORTHOGONAL AXES
C USE OTRSYM(,,1) TEMPORARILY FOR TRANSPOSE:
      CALL GMEQ(ORTH(1,1,1),OTRSYM(1,1,1),3,3)
      CALL TRANSQ(OTRSYM(1,1,1),3)
      DO 27 NO=2,NOPC
      CALL GMPRD(SYM(1,1,NO),ORTH(1,1,2),TEMP,3,3,3)
      IREV=NORD(NO)
C115 Use ordinary symmetry operator for elements in the little group
C    but not in the magnetic group
      IF (MTSYM(NO).EQ.0 .AND. IABS(KSTAB(NO)) .EQ.1)  GO TO 27
C4.26 Take account of magnetic symmetry for others if not CPVEC
      if (.NOT. CPVEC) THEN
        IREV=IREV*MTSYM(NO)
        IF (IREV .LT.0.) CALL GMREV(TEMP,TEMP,3,3)
      ENDIF
      CALL GMPRD(OTRSYM(1,1,1),TEMP,OTRSYM(1,1,NO),3,3,3)
C OPERATE WITH CENTRE OF SYMMETRY IF REQUIRED
      IF (MSTAB(NO) .LT.0) THEN
        CALL GMEQ(OTRSYM(1,1,NO),TEMP,3,3)
        CALL GMPRD(OTRSYM(1,1,NOPC+1),TEMP,OTRSYM(1,1,NO),3,3,3)
      ENDIF
   27 CONTINUE
      CALL GMUNI(OTRSYM(1,1,1),3)
C Haven't checked that non-symmetric rotations work with CPVEC
      if (CPVEC) go to 29
C
      ISERR=0
      IF (NDOM.EQ.1) GO TO 5
C  NOW DEAL WITH NON-SYMMETRIC ROTATIONS
      DO 1 I=2,NOPC
C Skip elements not in the little group
      IF (IABS(KSTAB(I)) .NE.1) GO TO 1
      if (IABS(MSTAB(I)).ne.I) go to 1
C141 Allow the rotation for any member of the coset to be given
C GET THE COSET OF I
      CALL COSET(I,IJTAB,NG,MSTAB,NOPC)
      DO 2 II=1,NG
      J = IJTAB(II)
C Skip elements not in the little group
      IF (IABS(KSTAB(j)) .NE.1) GO TO 2
      IF (NSTAB(j).EQ.0) GO TO 2
      WRITE(LPT,2004) j,((OTRSYM(IK,JK,J),JK=1,3),IK=1,3)
 2004 FORMAT (/' Non-symmetric spin rotation for element number',
     &I3,' is:  ',3F6.2,2(/56X,3F6.2))
C THE ELEMENT WHICH GENERATES THIS MEMBER OF THE COSET
      IX=MULTAB(I,INVERS(J))
      INV=INVERS(IX)
      CALL GMPRD(OTRSYM(1,1,INVERS(IX)),OTRSYM(1,1,J),TEMP,
     &3,3,3)
C IN CASE THE PRODUCT IS THE SAME AS ONE OF THE FACTORS
      CALL GMEQ(TEMP,OTRSYM(1,1,I),3,3)
      DO 3 III=1,NG
      IF (III.EQ.II) GO TO 3
      JJ = IJTAB(III)
      IXX=MULTAB(JJ,INVERS(I))
      CALL GMPRD(OTRSYM(1,1,IXX),OTRSYM(1,1,I),TEMP,3,3,3)
C IN CASE THE PRODUCT IS THE SAME AS ONE OF THE FACTORS
      CALL GMEQ(TEMP,OTRSYM(1,1,JJ),3,3)
    3 CONTINUE
      GO TO 1
    2 CONTINUE
C MISSING ELEMENTS
      CALL ERRIN2(I,1,
     &'Missing non-symmetric spin rotation for element number',' ')
      ISERR=ISERR+1
    1 CONTINUE

    5 WRITE (LPT,2008) (I,MSTAB(I),I=1,NOPC+1)
 2008 FORMAT (/' Magnetic symmetry table :  ',12(I3,'=',I3,';')/28X
     & ,12(I3,'=',I3,';'))
      go to 28
C
C4.26 Only for CPVEC
   29 IF (CENTRC) THEN
        CALL GMEQ(OTRSYM(1,1,1),OTRSYM(1,1,NOPC+1),3,3)
        DO 40 IO=2,NOPC
        CALL MTPROD(NOPC+1,IO,NOPC+IO)
   40   CONTINUE
        ENDIF
        GO TO 28
C
   28 IF (ISERR .EQ.0) CALL OPMSYM
      IERR=IERR+ISERR
      GO TO 100
C
C  ENTRY TO OPERATE WITH MAGNETIC SYMMETRY
      ENTRY ROTMAG(S,RS,IOP)
C  DONT ROTATE IF FERROMAGNETIC
      IF (FERO .OR. FERA) THEN
        CALL GMEQ(S,RS,3,3)
      ELSE
        DO 30 I=1,3
        CALL GMPRD(OTRSYM(1,1,IOP),S(1,I),RS(1,I),3,3,1)
   30   CONTINUE
      ENDIF
      GO TO 100
C
C   OPERATE WITH MAGNETIC SYMMETRY On Complex vector
      ENTRY ROTCMG(CS,CRS,IOP)
      IO=IABS(IOP)
      CALL RCMPRD(OTRSYM(1,1,IO),CS,CTEMP,3,3,2)
      IF (IOP .GT.0) THEN
        CALL GMEQ(SIGMAT(1,1,IO),SMAT,2,2)
      ELSE
        CALL GMPRD(SIGMAT(1,1,NOPC+1),SIGMAT(1,1,IO),SMAT,2,2,2)
      ENDIF
      CALL CRMPRD(CTEMP,SMAT,CRS,3,2,2)
      IF (IOP.LT.0) THEN
        CALL CMCONJ(CRS(1,1),CRS,3,2)
      ENDIF
      CALL CGMSCA(CRS,CRS,CEXP(CMPLX(0.,PHIK(IO))),3,2)
      GO TO 100
C
  100 RETURN
      END

C
C
C
C
C LEVEL 1      SUBROUTINE MAGVAR(IG,IS,NV)
      SUBROUTINE MAGVAR(IG,IS,NV)
C
C *** MAGVAR updated by JCM 3 Jun 92 ***
C
CX
CC 17B
CH Records the initial fixing, or subsequent varying of magnetic parameters.
CA On entry IG is the genus of the parameter (which atom)
CA          IS is the species (13-16 PHIH, 17-20 ANGM, 21,22 SMOD)
CA          NV is 0 if the while lot of parameters are to be initially fixed
CA                the number of the variable, if it is to be varied.
C
/MAGDAT/
C
      IF (NV .EQ. 0) THEN
C ENTRY 0 IS TO FIX ALL PARAMETERS:
C
C COUNT ALL MAGNETIC ATOMS:
        DO 4 I=1,NMAG
        DO 3 J=1,2
   3    KSMOD(J,I)=0
        DO 1 J=1,4
   1    KANGM(J,I)=0
%        DO 2 J=1,%PSIS%
   2    KPHIH(J,I)=0
   4    CONTINUE
      ELSE
C RECORD ONE VARIABLE:
        IM=MAGAT(IG)
        IF (IS .GE. 13 .AND. IS .LE. 16) KPHIH(IS-12,IM)=NV
        IF (IS .GE. 17 .AND. IS .LE. 20) KANGM(IS-16,IM)=NV
        IF (IS .GE. 21 .AND. IS .LE. 22) KSMOD(IS-20,IM)=NV
      ENDIF
C
      RETURN
      END
C
C
C
C
C LEVEL 5      SUBROUTINE MAJUST
      SUBROUTINE MAJUST
C
C *** MAJUST updated by JCM May 88 ***
C
CC 5A
CH A specialist routine used in the input of the Crystal Data File needing
CH previously stored Fourier maps.
CD MAJUST is called from PREFIN, on discovering that the user has given an
CD "M GET" card.  It adjusts file IO10 so that it contains mainly cards from the
CD previously dumped run (to be found on named file), updated to include
CD any new "M" cards presented for this run.  The rule for "M" cards belonging
CD to the "old" and "new" sets is:
CD   take only new cards for PRIN, PLOT, SAVE and GET;
CD   take only old cards for NDIM, FTYP, MESH, DTYP, DELT, SCAL, SMAX and AXES.
CD   For CM/A and CONT:
CD     if the card type occurs in "old" but not "new", accept it
CD     if card type occurs in "new" but not "old", accept it
CD     if card type occurs in both, accept the "new" only.
CD Also takes a new "N" card, unless there is only an old one.
C
CN All the cards capable of being telescoped happen to occur in the "take only
CN old" category, so should not pose a problem by hiding something other than
CN in columns 3-6, but - care will be needed with any newly defined cards.
C
C
      LOGICAL NONEWN
      CHARACTER *4 MWORD,MTBL1(8),MTBL2(4),MNEW(20)
      CHARACTER *80 MCARD(20),NEWNCD
      CHARACTER *10 FILNOM
/CARDRC/
/IOUNIT/
/MAPGT/
/SCRACH/
      DATA MTBL1/'NDIM','FTYP','MESH','AXES','DELT','SCAL',
     & 'SMAX','DTYP'/
      DATA MTBL2/'PRIN','PLOT','SAVE','GET'/
C
C
C IF THERE IS A NEW 'N' CARD, SAVE IT:
      NONEWN=.TRUE.
      IF (ICDNO(14) .EQ. 0) GO TO 16
      CALL CARDIN(IABS(INREAD(14)))
      NEWNCD=ICARD
      NONEWN=.FALSE.
C
C SAVE NEW M CARDS FOR CONT, CM/A,  PRIN, PLOT, READ OR SAVE:
   16 NEWMC=ICDNO(13)
      MSTART=INREAD(13)
      J=0
      ID=IABS(MSTART)
      DO 1 I=1,NEWMC
      CALL CARDIN(ID)
      ID=ID+NYZ
      CALL RDWORD(MWORD,ITEMP1,3,ITEMP2,80,0,IER)
C IGNORE IF ONE OF NDIM, AXES, MESH, FTYP, DTYP, DELT, SCAL, SMAX:
      DO 10 K=1,8
      IF (MWORD .EQ. MTBL1(K)) GO TO 1
  10  CONTINUE
      J=J+1
      MCARD(J)=ICARD
      MNEW(J)=MWORD
   1  CONTINUE
C RESET NUMBER OF NEW M CARDS:
      NEWMC=J
C
C COPY CARDS FROM UNIT IDUMPG, UNFORMATTED, ADDING NEW M CARDS:
      MESSAG='File containing saved Fourier '
      NAMFIL='.SAV'
      CALL OPNFIL(IDUMPG,1111)
      INEW=1
C RESTORE OLD VALUES FOR ARRAYS OF COUNTS AND START POINTERS FOR CARDS:
      READ (IDUMPG) INREAD,ICDNO,NCDS
C ENSURE ALL POINTERS INITIALISED POSITIVE:
      DO 2 I=1,26
   2  INREAD(I)=IABS(INREAD(I))
C
C COPY CARDS ACROSS FROM IDUMPG TO IO10 NOTING WHEN M BLOCK REACHED:
      I=0
      LET=-1
   3  I=I+1
      IF (I .GT. NCDS) GO TO 101
      READ(IDUMPG) ICARD
  14  LETNEW=LETTER(ICARD(1:1))
      IF (LETNEW .EQ. LET) GO TO 5
C
C NEW BATCH - ADJUST STARTING POINTER:
      INREAD(LETNEW)=INEW
      LET=LETNEW
C NOTE WHEN ABOUT TO DEAL WITH M CARDS, AND JUMP:
      IF (I .EQ. INREAD(13)) GO TO 4
C
C WRITE OUT CARD OTHER THAN ONE STARTING "M":
   5  INEW=INEW+1
C IF ABOUT TO WRITE AN 'N' CARD, SEE IF THERE IS A NEW ONE:
      IF (ICARD(1:1) .NE. 'N') GO TO 15
      IF (NONEWN) GO TO 15
      ICARD=NEWNCD
  15  WRITE (IO10,2000) ICARD
2000  FORMAT (A80)
C COUNT AS THOUGH A "DO" LOOP OVER I (BUT ALLOWING FOR MOVING I FURTHER DOWN)
      GO TO 3
C
C HERE ON FIRST OLD "M" CARD - SCAN ALL OLD CARDS:
   4  MEND=ICDNO(13)
      DO 6 K=1,MEND
      CALL RDWORD(MWORD,ITEMP1,3,ITEMP2,80,0,IER)
C REFUSE TO COPY PRIN, PLOT, SAVE, GET:
      DO 12 II=1,4
      IF (MWORD .EQ. MTBL2(II)) GO TO 9
  12  CONTINUE
C
C INSIST ON COPYING NDIM, AXES, FTYP, MESH:
      DO 13 II=1,4
      IF (MWORD .EQ. MTBL1(II)) GO TO 8
  13  CONTINUE
C
C THIS LEAVES CONT AND CM/A;  ONLY COPY IF THEY ARE OLD BUT NOT NEW:
      DO 7 J=1,NEWMC
      IF (MWORD .EQ. MNEW(J)) GO TO 9
   7  CONTINUE
C
C OLD CARD STILL WANTED:
   8  INEW=INEW+1
      WRITE (IO10,2000) ICARD
C
C OLD CARD OCCURS AGAIN IN NEW SET - DISCARD OLD:
C COUNT INPUT OLD CARDS
   9  I=I+1
      IF (I .GT. NCDS) GO TO 101
      READ(IDUMPG) ICARD
   6  CONTINUE
C
C END OF SCANNING OLD M CARDS - NOW ADD ALL NEW ONES:
      DO 11 K=1,NEWMC
      INEW=INEW+1
  11  WRITE (IO10,2000) MCARD(K)
      ICDNO(13)=INEW-INREAD(13)
      GO TO 14
C
 101  IF (ICDNO(14) .NE. 0 .OR. NONEWN) GO TO 100
      INREAD(14) = INEW
      INEW=INEW+1
      WRITE (IO10,2000) NEWNCD
      ICDNO(14)=1
 100  WRITE (LPT,2001) FILNOM(IDUMPG)
2001  FORMAT (/' "M GET" card given;  crystal data read from ',
     & A10,' and given relevant new M cards')
      RETURN
      END
C
C
C
C
C LEVEL 3      SUBROUTINE MAKEBM(I,A,C,M,N)
      SUBROUTINE MAKEBM(I,A,C,M,N)
C
C *** MAKEBM by JCM 24 Nov 82 ***
C
CX
CC 15C
CH A specialist contour plotting routine which makes a bit map to show where
CH the contours are.
C
      LOGICAL ABOVE,ABVE,TEST
      DIMENSION A(M,N)
      IC=1
      IR=0
      NB=N-1
      NR=I-3
      NC=1
      IF (NR .GT. 1) GO TO 6
      GO TO (1,2,3,4), I
   1  NR=1
      GO TO 6
   2  NR=1
      NC=N
      IR=1
      GO TO 5
   3  NR=M
      NC=N
      IC=-1
      GO TO 6
   4  NR=M
      NC=1
      IR=-1
   5  IC=0
      NB=M-1
   6  ABOVE = A(NR,NC) .GE. C
      DO 10 IB=1,NB
      NR = NR + IR
      NC = NC + IC
      ABVE = A(NR,NC) .GE. C
      IF (ABOVE .AND. ABVE .OR. .NOT.(ABOVE .OR. ABVE)) GO TO 10
      ABOVE = ABVE
      CALL BITSET (I,IB,TEST,.TRUE.)
  10  CONTINUE
      RETURN
      END
C
C
C
C
C LEVEL 2       SUBROUTINE MAKGRP(IGSB,IOPS,MODE,PRODCT)
      SUBROUTINE MAKGRP(IGSB,IOPS,MODE,PRODCT)
C
C *** MAKGRP modified by PJB 31-May-1994 ***
C
CX
CC 1A
CH Generates the subgroup of a space group from the given generators.
CA On entry, IGSB holds the generators
CA    IABS(IGSB(1)) is the number of operators in the subgroup, divided
CA                  by 2 if the group contains a centre of symmetry.
CA                  If 1 it may indicate that the number of operators in
CA                  the sub-group is not known and should be calculated
CA                  by the subroutine
CA    IGSB(1)       is negative if the group contains a centre of symmetry
CA    IGSB(2)       is the identifying number of the first generator; it is
CA                  negative if it is the centrosymmetrically related one.
CA    IGSB(3)       is as IGSB(2) but for the second generator if there is one
CA    If MODE=1     the subroutine PRODCT is called with to allow evaluation
CA                  of a possible representation of the group.
CA    PRODCT        is an externally defined subroutine. May be DUMMY.
CA On exit, IOPS is a table which contains an entry for each operator of the
CA               full group. It is positive and non-zero if the operator
CA               belongs to the sub-group, and negative if it is only the
CA               centro-symmetric  operator which is in the sub-group.
CA   IGSB(1)     is set as above using the multiplicity of the sub-group
CA               found by the sub-routine.
CP SYMOP
C
      EXTERNAL PRODCT
      DIMENSION IGSB(3),IOPS(24),JOPS(24)
      LOGICAL PERM
/NSYM/
/SYMTAB/
C
C SETUP
      CALL JGMZER(IOPS,1,NOPC)
      CALL JGMZER(JOPS,1,NOPC)
      JOPS(1)=1
      IOPS(1)=1
      NO=1
C
C  EXTRACT INFORMATION ABOUT GENERATORS
      NOPG=IABS(IGSB(1))
      IF (NOPG.EQ.1) NOPG=NOPC
      NG1=IABS(IGSB(2))
      IF (NG1.EQ.1) GO TO 101
      NO1=IABS(NORD(NG1))
      IF (NO1.GT.100) NO1=NO1-100
      NG2=IABS(IGSB(3))
C  PUT IN GENERATORS
      JOPS(2)=NG1
      IOPS(NG1)=ISIGN(1,IGSB(2))
      JOPS(NO1+1)=NG2
      IF (NG2.NE.0) IOPS(NG2)=ISIGN(1,IGSB(3))
C  AND MULTIPLES OF FIRST GENERATOR
      ISIG=IOPS(NG1)
      DO 2 NO=3,NO1
      I=MULTAB(JOPS(NO-1),NG1)
      ISIG=ISIG*IOPS(NG1)
      JOPS(NO)=I
      IF (MODE.EQ.1) CALL PRODCT(JOPS(NO-1),NG1,I)
    2 IOPS(I)=ISIG
      NO=NO1
      IF (NG2.EQ.0) GO TO 101
C
C  GENERATE THE REST OF THE SUB-GROUP
      N1=2
      N2=NO1+1
      NO=N2
C
    5 J=JOPS(N1)
    4 JJ=JOPS(N2)
      PERM=.TRUE.
      I=MULTAB(J,JJ)
      ISIG=IOPS(J)*IOPS(JJ)
    3 IF (IOPS(I).EQ.0) THEN
        NO=NO+1
        JOPS(NO)=I
        IF (MODE.EQ.1) THEN
          IF (PERM) THEN
            CALL PRODCT(J,JJ,I)
          ELSE
            CALL PRODCT(JJ,J,I)
          ENDIF
        ENDIF
        IOPS(I)=ISIG
        IF (NO.GE.NOPG) GO TO 101
      ENDIF
      IF (PERM) THEN
        PERM=.FALSE.
        I=MULTAB(JJ,J)
        GO TO 3
      ENDIF
      N2=N2+1
      IF (N2.LE.NO) GO TO 4
      N1=N1+1
      N2=MAX(NO1+1,N1)
      IF (N1.LE.NO) GO TO 5
C
C SET THE MULTIPLICITY TO THAT FOUND
  101 IGSB(1)=ISIGN(NO,IGSB(1))
      RETURN
      END
C
C
C
C
C LEVEL 1      CHARACTER *4 FUNCTION MAKNAM(CHAR,N)
      CHARACTER *4 FUNCTION MAKNAM(CHAR,N)
C
C *** MAKNAM BY JCM 8 JUL 91 ***
C
CX
CC 13C
CH Makes an A4 name from the given character and the digits of the given number.
CA On entry CHAR holds either a single character, to fill the name from the
CA               left, repeatedly, or 2,3 or 4 characters, which are used to
CA               fill in on the left unchanged.
CA          N is an integer
CA On exit MAKNAM is a *4 name with the digits of N at the right hand side,
CA          filled with the characters from CHAR.
C
      CHARACTER *4 NAME,CH
      CHARACTER *(*) CHAR
C
      CH=CHAR
      IF (LEN(CHAR) .EQ. 1) CH=CHAR//CHAR//CHAR//CHAR
      WRITE (NAME,2000) N
2000  FORMAT (I4)
      DO 1 I=1,4
      IF (NAME(I:I) .EQ. ' ') NAME(I:I)=CH(I:I)
   1  CONTINUE
      MAKNAM=NAME
      RETURN
      END
C
C
C
C
C LEVEL 4       SUBROUTINE MAPBOX(AVEC,RVEC,CLIM,NP,NMAX,BORDER)
       SUBROUTINE MAPBOX(AVEC,RVEC,CLIM,NP,NMAX,BORDER)
C
C *** MAPBOX new by PJB Nov 2016 ***
CX
CC11C
CH Finds a point RVEC equivalent to AVEC lying inside  a 2D box.

CA on input AVEC(3) give the coordinates of the given point
CA On exit RVEC holds the coordinates of the NP equivalent points
CA within the 2D boundaries CLIM(1,I)<= RVEC(I)<=CLIM(2,I)
CA If BORDER is TRUE points on the borders are included, otherwise not
CA NMAX is the maximum number of points allowed
CP The geometry of the map is defined by the matrix UM(3,3) in common MAPMAP
C
      DIMENSION AVEC(3),BVEC(3),CVEC(3),RVEC(3,NMAX),V(3),
     &CLIM(2,2),MUL(2)
      LOGICAL BORDER
/IOUNIT/
/MAPMAP/
C
      CALL FLUSH
      CALL GMEQ(AVEC,BVEC,3,1)
      DO 1 I=1,2
      T=SCALPR(AVEC,UM(1,I))/AXLEN(I)
      FRAC=CLIM(1,I)-T
      AMUL=AINT(FRAC)
      IF (FRAC.LT.0 .OR.(BORDER .AND.ABS(FRAC).LT. .0001)) AMUL=AMUL-1.
      CALL GMSCA(UM(1,I),V,AMUL,3,1)
      CALL GMADD(BVEC,V,BVEC,3,1)
      T1=T+AMUL
      MUL(I)=INT(CLIM(2,I)-T1)
      IF (BORDER .AND. ABS(CLIM(2,I)-T).LT..0001) MUL(I)=MUL(I)+1
    1 CONTINUE
C
      NP=0
       DO 2 NX=1,MUL(1)
      CALL GMADD(BVEC,UM(1,1),BVEC,3,1)
      CALL GMEQ(BVEC,CVEC,3,1)
      DO 3 NY=1,MUL(2)
      CALL GMADD(CVEC,UM(1,2),CVEC,3,1)
      CALL ERRCHK(2,NP,NMAX,'Points within MAPBOX boundaries',0)
      CALL GMEQ(CVEC,RVEC(1,NP),3,1)
    3 CONTINUE
    2 CONTINUE
      RETURN
      END

C
C
C
C
C LEVEL 5      SUBROUTINE MAPBX(CPOS,POSNS,NIN,BORDER)
      SUBROUTINE MAPBX(CPOS,POSNS,NIN,BORDER)
C
C ***  MAPBX NEW PJB Aug 2017 C4.38  ***
C
CX
CC 5C
CH Finds all positions equivalent to CPOS inside the 2D box defined by OUTLIM
C
CA  On input  CPOS is a 2D vector in the plane defined by U(1:3,1) andU(1:3,2)
CA  On Output POSNS contains a list of vectors defining the NIN positions
CA  related to CPOS by lattice translations for which
CA  outlim(1,i)<=posn(i,..) < outlim(2,i),
CA  If BORDER is TRUE points on the outer limit are included
C
CP  Expects /MAPDA/ to have been set up by INPUTM

      DIMENSION POS(2),POSNS(3,10),NN(2),CPOS(2)
      DIMENSION TPOS(2,5)
      LOGICAL LERCHK,BORD,BORDER
/IOUNIT/
/MAPDA/
       DATA DEL/0.001/
C
C THESE ARE CRYST MAP COORDINATES
      CALL GMZER(POSNS,3,10)
      CALL GMEQ(CPOS,POS,2,1)
      DO 1 I=1,2
       N=0
       SPAN=(OUTLIM(2,I)-OUTLIM(1,I))
       BORD=ABS(SPAN-ANINT(SPAN)).LT.DEL
       NSPAN=INT(SPAN)
       if (.not. BORD) NSPAN=INT(SPAN)+1

C FIRST GET CPOS INTO THE ORIGIN CELL
        ALEFT=(POS(I)-OUTLIM(1,I))
        ISG=1
        IF (ABS(ALEFT) .LT. DEL) GO TO 2
        IF (ALEFT.LT.0) POS(I)=POS(I)-AINT(ALEFT)+1.
        RIGHT=(POS(I)-OUTLIM(2,I))
        ISG=-1
        IF (ABS(RIGHT) .LT. DEL) GO TO 2
        IF (RIGHT.GT.0) POS(I)=POS(I)-(AINT(RIGHT) +1.)
        ANEXT=(POS(I)-OUTLIM(1,I))
        IF (ABS(ANEXT) .LT. DEL) ANEXT=0
C        write (lpt,5000) i,cpos,pos,aleft,right,anext,nspan
C 5000   format (I2'In:',2f8.3,' Now',2f8.3,' Tests:',3(f8.3,2x),i4)
        IF (ANEXT)  6,2,3
        IF (ANEXT)  6,2,3
    2   IF (BORD .AND. BORDER) THEN
          N=N+1
          TPOS(I,N)=POS(I)+ISG
        ENDIF
    3   DO 7 IS=1,NSPAN
          N=N+1
          TPOS(I,N)=POS(I)
          POS(I)=POS(I)+1
    7   CONTINUE
    6   NN(I)=N
    1 CONTINUE
      NIN=NN(1)*NN(2)
      IF (NIN.EQ.0) GO TO 100
      NIN=0
      DO 4 I=1,NN(1)
        DO 5 J=1,NN(2)
          IF (.NOT. LERCHK(2,NIN,10,1,
     &   'NUMBER OF ATOMS IN BOX')) GO TO 100
          POSNS(1,NIN)=TPOS(1,I)
          POSNS(2,NIN)=TPOS(2,J)
    5   CONTINUE
    4 CONTINUE
      WRITE(LPT,1000) NIN,((POSNS(I,N),I=1,2),N=1,NIN)
 1000 FORMAT (I3,' ATOMS IN BOX:',10(2F8.4,2X))
  100 RETURN
      END
C
C
C
C
C LEVEL 7      SUBROUTINE MAPCON(CFOUND,IC,IBMAX,IFMAX)
      SUBROUTINE MAPCON(CFOUND,IC,IBMAX,IFMAX)
C
C *** MAPCON by JCM 22 Aug 86 ***
C
CX
CC 5B
CH After a Fourier map has been plotted, sends to the plotter the list of
CH contours which were plotted, with a frame.
C
CA On entry CFOUND is a real array containing the contour values to write,
CA          IC is the number of elements in CFOUND,
CA          IBMAX and IFMAX are handed over to indicate general size of numbers.
C
CP STPLOT shuld set this up, and MPPLOT should call it, having made the list
C
      DIMENSION CFOUND(IC),PTEMP(2,3)
      CHARACTER *8 NUMBUF
/PLODAT/
/PLOMAP/
/PLTRAN/
C
C WRITE CONTOUR LIST IF ANY FOUND:
C IF VALUES SO WIDELY DIFFERENT THAT COULD NOT ALL BE WRITTEN, EXIT:
      IF (IBMAX .GT. 8) GO TO 100
C BLACK PEN AGAIN:
      CALL PIGLET(0.,0.,-1)
C NOW CHARACTER TYPE 3 - CONTOUR LIST PANEL - WE KNOW THIS TO BE 10 CHARS WIDE:
C WE NOW KNOW SIZE OF LIST - IC NUMBERS PLUS A TITLE:
      A=FLOAT(IC+1)*2.*CHUNIT
      CHSCAL(2,3)=(HGTMAP+5.*YWHITE+HGTTXT)/A
C DO NOT ALLOW TYPE 3 TO BECOME LARGER THAN TYPE 1:
      IF (CHSCAL(2,3) .GT. CHSCAL(2,1)) CHSCAL(2,3)=CHSCAL(2,1)
      CHSCAL(1,3)=CHSCAL(2,3)/ASPECT
C A DIGIT IS 20 PLOTTER UNITS WIDE:
      WIDCON=220.*CHSCAL(1,3)
      HGTCON=A*CHSCAL(2,3)
C
C PUT IN PLACE THE TRANSFORMATION FOR CHARACTER TYPE 3:
      CALL GMZER(PTEMP,2,2)
      PTEMP(1,1)=CHSCAL(1,3)
      PTEMP(2,2)=CHSCAL(2,3)
      PTEMP(1,3)=WIDPIC-XMARG-WIDCON
      PTEMP(2,3)=(PMTRIX(2,3,3)+YMARG-HGTCON)/2.
      CALL PLTRIN(PTEMP,7,3)
C
C SET CHARACTER TYPE 3 SPACE:
      CALL SPCSET(7)
      CALL FRAME(0.,0.,220.,A)
      B=A-2.*CHUNIT
      CALL KANGA1(0.,B,3)
      CALL KANGA1(220.,B,2)
C WRITE 'CONTOURS'
      CALL KANGA2(CHUNIT,B+CHUNIT/2.,TEMP,'CONTOURS',8)
C
C SELECT FIELD WIDTH:
      IBMAX=IBMAX+IFMAX
      IF (IFMAX .EQ. 0) IBMAX=IBMAX-1
      IW=IBMAX/2 + 4
      IF (IW .GT. 8) IFMAX=IFMAX-IW+8
C
C LIST VALUES PLOTTED:
      B=B+CHUNIT/2.
      DO 5 I=1,IC
      B=B-2.*CHUNIT
      CALL NUMA1(CFOUND(I),IW,IFMAX,8,NUMBUF)
   5  CALL KANGA2(CHUNIT,B,TEMP,NUMBUF,8)
 100  RETURN
      END
C
C
C
C
C LEVEL 8      SUBROUTINE MAPDRW(CFOUND,IC,IBMAX,IFMAX)
      SUBROUTINE MAPDRW(CFOUND,IC,IBMAX,IFMAX)
C
C *** MAPDRW by JCM 22 Aug 86 ***
C
CX
CC 5B
CH Draws an unframed contour map, in predetermined place.
C
CA On exit CFOUND is a real array which holds all the found contour values.
CA         IC is the number of found contours.
CA         IBMAX and IFMAX are sensible sizes for later contour list printing.
C
CP STPLOT must have set up the map contouring
C
      LOGICAL MORE,FOUND
%      DIMENSION CFOUND(%CONT%)
/CONTUR/
/IOUNIT/
/MAPDA/
C
C SET MAP SPACE:
      CALL SPCSET(4)
C
C INITIALISE IC=COUNT OF FOUND CONTOURS, IBMAX AND IFMAX WHICH CONTROL THE
C DETAILS OF PRINTING THE CONTOUR LIST, AND ICON WHICH COUNTS CONTOURS SOUGHT:
      IC=0
      IBMAX=0
      IFMAX=0
      ICON=0
      MORE=.TRUE.
C
C NEXT CONTOUR:
   1  CALL NEXCON(C,ICON,MORE)
      IF (.NOT. MORE) GO TO 100
      CALL PLOTCT(C,DENS,FOUND,NX,NY)
      IF (.NOT. FOUND) GO TO 3
C
C CONTOUR FOUND - KEEP:
      IC=IC+1
      CFOUND(IC)=C
C ADJUST IFMAX AND IBMAX SO THAT THE RESULTING LIST LOOKS NICE:
      CALL FETTLE(C,IF1,IF2)
      IB=IF1-IF2
      IF (IF2 .EQ. 0) IB=IB+1
      IF (IB .GT. IBMAX) IBMAX=IB
      IF (IF2 .GT. IFMAX) IFMAX=IF2
      WRITE (LPT,2000) C
2000  FORMAT (' Contour at',F12.4,' drawn')
      IF (NCONT .EQ. 0) WRITE(ITO,2000) C
%      IF (IC .GE. %CONT%) GO TO 100
C
C JOIN IF REQUESTED CONTOUR NOT FOUND:
   3  MORE=FOUND
C BACK FOR NEXT CONTOUR VALUE:
      GO TO 1
 100  RETURN
      END
C
C
C
C
C LEVEL 7      SUBROUTINE MAPFRA
      SUBROUTINE MAPFRA
C
C *** MAPFRA by JCM 22 Aug 86 ***
C
CX
CC 5B
CH Draws a black frame round a potential contoured map, adding the labels
CH X Y and a 1A scale.
C
CP Needs to be set up within a whole picture by STPLOT
C
CO Causes (possibly skew) frame to be drawn via PIGLET, with labels X and
CO Y (and therefore implicit origin), and a one-angstrom scale underneath.
C
/MAPDA/
/PLODAT/
/PLOMAP/
C
C MOVE INTO MAP SPACE:
      CALL SPCSET(4)
C
C BLACK PEN:
      CALL PIGLET(0.,0.,-1)
C DRAW FRAME ROUND MAP:
      FX=FLOAT(NX-1)
      FY=FLOAT(NY-1)
      CALL FRAME(0.,0.,FX,FY)
C
C POSITIONS FOR 'X' AND 'Y' LABELS:
      CALL PLCONV(FX/2.,0.,4,X1,X2,5)
      CALL PLCONV(0.,FY/2.,4,Y1,Y2,5)
C POSITION FOR 1 ANGSTROM LINE, IN BOTH CHARACTER 1 AND PICTURE COORDS:
      CALL PLCONV(FX,FY/2.,4,C1,C2,5)
      CALL PLCONV(FX,FY/2.,4,P1,P2,3)
C
C BRIEF SOJURN IN PICTURE SPACE TO DRAW 1 ANGSTROM LINE:
      CALL SPCSET(3)
      CALL KANGA1(P1-SCALMP/2.,P2-YWHITE*1.5,3)
      CALL KANGA1(P1-SCALMP/2.,P2-YWHITE*2.,2)
      CALL KANGA1(P1+SCALMP/2.,P2-YWHITE*2.,2)
      CALL KANGA1(P1+SCALMP/2.,P2-YWHITE*1.5,2)
C MOVE INTO CHARACTER TYPE 1 SPACE, WITH X1,X2 AND Y1,Y2 SET AS POSITIONS TO
C WRITE 'X' AND 'Y' AND C1,C2 MIDDLE POINT FOR '1A':
      CALL SPCSET(5)
      CALL KANGA2(C1-CHUNIT,C2-1.8*CHUNIT,TEMP,'1A',2)
      CALL KANGA2(X1-1.5*CHUNIT,X2,TEMP,'X',1)
      CALL KANGA2(Y1-CHUNIT/2.,Y2+CHUNIT/2.,TEMP,'Y',1)
      RETURN
      END
C
C
C
C
C LEVEL 7 SUBROUTINE MAPGP(VALIM)
      SUBROUTINE MAPGP(VALIM)
C
C   **** MATGP New by PJB June 2017  C 4.38  ****
C
CX
CC 5C
CH writes the map.dat file used by the GNUPLOT contouring procedure
C
CP FOUR1Z to calculate the map heights to be plotted. Values in DENS
CA On  exit VALIM contains the maximum and minimum values read from dens and LDAT
      DIMENSION VALIM(2)
/CONTUR/
/GPLMAP/
/IOUNIT/
/MAPDA/
/SCRACH/
C
      VALIM(1)=10E6
      VALIM(2)=-valim(1)
      MESSAG='map.dat'
      LDAT=NOPFIL(226)
      WRITE (ITO,1002) MESSAG
      WRITE (LPT,1002) MESSAG
 1002  FORMAT ('Creating gnuplot map file  ',A)
C DENS stored in NY Rows of contant y (XG),  NX x, (NY YG values per row'
C To contour non-orthogonal maps must record the data in blocks with one
C column constant
      A=1.
      B=COSPHI/SINPHI
C Steps in 'first' coordinates between points
      STEPXG=WIDBOX*WIDMAP/FLOAT(NY-1)
      STEPYG=HGTMAP/FLOAT(NX-1)
      N=1
      FY=0
C IY  counts steps in YG coordinate (x cryst)
C Do rows 0f constant YG (x cryst)
      DO 1 IX=1,NX
        FX=0
        N=IX
        DO 2 IY=1,NY
C Transform FRAC CRYST TO to gnuplot 'first'  coordinates Xg Yg
          YG=HGTMAP-FY
          XG=A*FX + B*FY + XORIG*WIDMAP
          WRITE (LDAT,1000) XG,YG,DENS(N),FX,FY,IY,IX,N
          IF (DENS(N).GT.VALIM(2))VALIM(2)=DENS(N)
          IF (DENS(N).LT.VALIM(1))VALIM(1)=DENS(N)
 1000     FORMAT (5(F10.4,2X),2I4,I8)
          FX=FX+STEPXG
          N=N+NX
    2  CONTINUE
         WRITE (LDAT,1000)
         FY=FY+STEPYG
    1 CONTINUE
      CALL CLOFIL(LDAT)
      RETURN
      END





C
C
C
C
C LEVEL 7      SUBROUTINE MAPKEY(IFND,NFND,JP)
      SUBROUTINE MAPKEY(IFND,NFND,JP)
C
C *** MAPKEY updated by JCM Sep 91 ***
C
CX
CC 5B
CH Plots a key to the atoms found by ATMPLO.
C
      DIMENSION IFND(4),JP(4),PTEMP(2,3)
/ATNAM/
/MAPDA/
/PLODAT/
/PLOMAP/
/PLTRAN/
C
C FIT THE KEY TO NAMES OF ATOMS IN THE SPACE NORMALLY USED FOR CONTOUR VALUES
      IF (NFND.LE.0) GO TO 100
C  SET BLACK PEN
      CALL PIGLET(0.,0.,-1)
C
C  LIST TO CONTAIN NFND ENTRIES PLUS HEADING
C A=HEIGHT OF LIST IN CHARACTER UNITS:
      A=FLOAT(NFND+1)*2.*CHUNIT
C CONVERT MIDPOINT OF RHS OF MAP FRAME INTO PICTURE COORDS:
      FX=FLOAT(NX-1)/2.
      FY=FLOAT(NY-1)
      CALL PLCONV(FX,FY,4,X,Y,3)
C NOW CHARACTER TYPE 3 - ATOM LIST PANEL - WE SET THIS TO BE 10 CHARS WIDE:
       CHSCAL(2,3)=(HGTMAP+5.*YWHITE+HGTTXT)/A
C DO NOT ALLOW TYPE 3 TO BECOME LARGER THAN TYPE 1:
      IF (CHSCAL(2,3) .GT. CHSCAL(2,1)) CHSCAL(2,3)=CHSCAL(2,1)
      CHSCAL(1,3)=CHSCAL(2,3)/ASPECT
C A DIGIT IS 20 PLOTTER UNITS WIDE:
      WIDCON=240.*CHSCAL(1,3)
      HGTCON=A*CHSCAL(2,3)
C
C PUT IN PLACE THE TRANSFORMATION FOR CHARACTER TYPE 3:
      CALL GMZER(PTEMP,2,2)
      PTEMP(1,1)=CHSCAL(1,3)
      PTEMP(2,2)=CHSCAL(2,3)
      PTEMP(1,3)=WIDPIC-XMARG-WIDCON
      PTEMP(2,3)=Y-HGTCON*0.5
      CALL PLTRIN(PTEMP,7,3)
C
C  CHARACTER 3 SPACE COMPLETED - SET IT
      CALL SPCSET(7)
      CALL FRAME(0.,0.,240.,A)
      B=A-2.*CHUNIT
      CALL KANGA1(0.,B,3)
      CALL KANGA1(240.,B,2)
C  WRITE 'KEY'
      CALL KANGA2(88.,B+CHUNIT/2.,TEMP,'KEY',3)
C  NOW LIST OF ATOMS FOUND
      B=B+CHUNIT/2.
      DO 5 I=1,NFND
      B=B-2.*CHUNIT
C  PLOT APPROPRIATE CHARACTER
      CALL KANGA3(55.,B+.5*CHUNIT,1.5*CHUNIT*CHSCAL(2,3),JP(I))
C  THEN NAME OF CORRESPONDING ATOM
      CALL KANGA2(5.*CHUNIT,B,TEMP,ATNAME(IFND(I)),4)
    5 CONTINUE
C
  100 RETURN
      END
C
C
C
C
C LEVEL 7      SUBROUTINE MAPTIT
      SUBROUTINE MAPTIT
C
C *** MAPTIT by JCM 22 Aug 86 ***
C
CX
CC 5B
CH Writes a title over a plotted map, with a frame.
C
CP The picture must be initialised by a call of STPLOT, setting up in particular
CP space 6 to be "character type 2" space, measured for suitability for title.
CP The title must have been read by INPUTN.
C
/NTITL/
/PLODAT/
/TITLE/
C
C MOVE TO CHARACTER TYPE 2 SPACE (TITLE CHARACTERS):
      CALL SPCSET(6)
C WRITE TITLE, ONE CHARACTER IN AND HALF CHARACTER UP:
      CALL KANGA2(CHUNIT,CHUNIT/2.,TEMP,ITITLE,NTITLE)
C AND PUT FRAME ROUND IT:
      CALL FRAME(0.,0.,TEMP+2.*CHUNIT,2.*CHUNIT)
      RETURN
      END
C
C
C
C
C LEVEL 4      SUBROUTINE MATCEL(ALSQ,MATSZ)
      SUBROUTINE MATCEL(ALSQ,MATSZ)
C
C *** MATCEL corrected by PJB 2-Jan-96 ***
C
CX
CC 6B
CH After a cycle of LSQ gives variance-covariance matrix for cell A* B* etc
CH in both real and reciprocal space, and the same for abc, alpha,beta,gamma.
CA The Least Squares matrix ALSQ(MATSZ) must be handed throughout the system
CA as the argument of routine calls in order to make it easily altered.
CP  The LSQ matrix ALSQ is assumed to hold the inverse matrix after a
CP cycle of refinement.
CD Fills in array CELESD(6,6,2) for the variance-covariances of the
CD quadratic products in both spaces, and CELLSD(6,6) for a,b,etc.
C
      DIMENSION ALSQ(MATSZ)
/CELFIX/
/CELPAR/
/CONSTR/
/POINTS/
      DIMENSION TOSTAR(6,6),TOSTTR(6,6),CELTMP(6,6),
     & BGTOSM(6,6),SMTOBG(6,6),SMBGTR(6,6)
C
C CLEAR OUT ALL ANSWERS
      CALL GMZER(CELESD(1,1,2),6,6)
C FIRST DO DIAGONALS, WHICH MAY BE NEEDED FOR OFF-DIAGONALS:
      DO 1 I=1,6
      LI=KCPARS(I)
C DO NOTHING IF ELEMENT I IS NOT A VARIABLE:
      IF (LI .GT. 0) THEN
        II=LVRBS(LI)
        A=1.
C DEAL WITH CASE OF REDUNDANT VARIABLE:
        IF (II .LT. 0) THEN
          A=AMOUNT(JROWPT(-II))
          II=JCMAT(JROWPT(-II))
        ENDIF
        CELESD(I,I,2)=ELEMAT(ALSQ,MATSZ,II,II)*A*A
      ENDIF
   1  CONTINUE
C
C OFF-DIAGONAL TERMS:
      DO 2 I=1,5
      LI=KCPARS(I)
C ONLY IF I'TH IS A VARIABLE;
      IF (LI .GT. 0) THEN
        II=LVRBS(LI)
        AI=1.
C DEAL WITH I'TH BEING REDUNDANT:
        IF (II .LT. 0) THEN
          AI=AMOUNT(JROWPT(-II))
          II=JCMAT(JROWPT(-II))
        ENDIF
        DO 3 J=I+1,6
        LJ=KCPARS(J)
C ONLY IF J'TH IS A VARIABLE;
        IF (LJ .GT. 0) THEN
          JJ=LBSVR(LJ)
          AJ=1.
C DEAL WITH J'TH BEING REDUNDANT:
          IF (JJ .LT. 0) THEN
            AJ=AMOUNT(JROWPT(-JJ))
            JJ=JCMAT(JROWPT(-JJ))
          ENDIF
C
          IF (II .NE. JJ) THEN
            CELESD(I,J,2)=ELEMAT(ALSQ,MATSZ,II,JJ)*AI*AJ
          ELSE
C IF BOTH I AND J ARE REDUNDANT AND RELATED TO SAME BASIC:
            CELESD(I,J,2)=SQRT(CELESD(I,I,2)*CELESD(J,J,2))
          ENDIF
C SYMMETRICALLY RELATED MATRIX ELEMENT:
          CELESD(J,I,2)=CELESD(I,J,2)
        ENDIF
   3    CONTINUE
      ENDIF
   2  CONTINUE
C
C SET UP MATRIX TO CONVERT DERIVATIVES WRT A,B,C ETC TO DERIVATIVES
C WRT A* B* C* ETC:
      CALL CELMAT(TOSTAR)
C
C GET THE TRANSPOSE OF TOSTAR (TOSTTR):
      CALL GMTRAN(TOSTAR,TOSTTR,6,6)
C CELESD(I,J,1)=TOSTAR(I,K)*CELESD(K,L,2)*TOSTTR(L,J)
      CALL GMPRD(CELESD(1,1,2),TOSTTR,CELTMP,6,6,6)
      CALL GMPRD(TOSTAR,CELTMP,CELESD,6,6,6)
C EVALUATE THE VARIANCE-COVARIANCE MATRIX FOR A B C ALPHA BETA GAMMA
C FIRSTLY FORM LITTLE A,B,C
      ASMALL=CELL(1,1,1)
      BSMALL=CELL(2,1,1)
      CSMALL=CELL(3,1,1)
C
      CALL GMZER(BGTOSM,6,6)
      BGTOSM(1,1)=2.*ASMALL
      BGTOSM(2,2)=2.*BSMALL
      BGTOSM(3,3)=2.*CSMALL
C     BGTOSM(4,4) HAS THE FORM -(180/PI)*B*C*SIN(ALPHA) ETC.
      BGTOSM(4,4)=-RADIAN(BSMALL*CSMALL*CELL(1,3,1))
      BGTOSM(5,5)=-RADIAN(ASMALL*CSMALL*CELL(2,3,1))
      BGTOSM(6,6)=-RADIAN(ASMALL*BSMALL*CELL(3,3,1))
      BGTOSM(2,4)=CPARS(4,1)/BSMALL
      BGTOSM(3,4)=CPARS(4,1)/CSMALL
      BGTOSM(1,5)=CPARS(5,1)/ASMALL
      BGTOSM(3,5)=CPARS(5,1)/CSMALL
      BGTOSM(1,6)=CPARS(6,1)/ASMALL
      BGTOSM(2,6)=CPARS(6,1)/BSMALL
      CALL GMINV(BGTOSM,SMTOBG,6)
      CALL GMTRAN(SMTOBG,SMBGTR,6,6)
C CELLSD(I,J)=SMTOBG(I,K)*CELESD(K,L,1)*SMBGTR(L,J)
      CALL GMPRD(CELESD,SMBGTR,CELTMP,6,6,6)
      CALL GMPRD(SMTOBG,CELTMP,CELLSD,6,6,6)
C
      RETURN
      END
C
C
C
C
C LEVEL 1      FUNCTION MATCH(K)
      FUNCTION MATCH(K)
C
C *** MATCH by PJB 1 Jul 86 ***
C
CX
CC 3C
CH Checks to see whether two sets of reflection indices match.
CA On entry K(3,2) holds the two sets of indices, hkl1 hkl2.
CD The function is set to zero if the indices match
CD                     to 1 if hkl1 comes before hkl2 in the standard order
CD                          of reflection indices in which h varies fastest
CD                          then k then l
CD                     to 2 if hkl2 comes before hkl1
CN See also MATCHF for floating indices
C
      DIMENSION K(3,2)
C
      DO 1 I=3,1,-1
      IF (K(I,1)-K(I,2)) 3,1,2
    1 CONTINUE
C
C  INDICES MATCH
      MATCH=0
      GO TO 100
C  POSITIVE DIFFERENCE STREAM 1 AHEAD
    2 MATCH=2
      GO TO 100
C  NEGATIVE DIFFERENCE STREAM 2 AHEAD
    3 MATCH=1
C
  100 RETURN
      END
C
C
C
C
C LEVEL 1      FUNCTION MATCHF(F)
      FUNCTION MATCHF(F)
C
C *** MATCHF by JBF 19 Jun 87 ***
C
CX
CC 3C
CH Checks to see whether two sets of floating point reflection indices match.
CA On entry F(3,2) holds the two sets of indices, hkl1 hkl2.
CD The function is set to zero if the indices match
CD                     to 1 if hkl1 comes before hkl2 in the standard order
CD                          of reflection indices in which h varies fastest
CD                          then k then l
CD                     to 2 if hkl2 comes before hkl1
CN See MATCH for fixed point indices
C
      DIMENSION F(3,2)
C
      DO 1 I=3,1,-1
      IF (F(I,1)-F(I,2).GT.0.001) GO TO 2
      IF (F(I,1)-F(I,2).LT.-0.001) GO TO 3
    1 CONTINUE
C
C  INDICES MATCH
      MATCHF=0
      GO TO 100
C  POSITIVE DIFFERENCE STREAM 1 AHEAD
    2 MATCHF=2
      GO TO 100
C  NEGATIVE DIFFERENCE STREAM 2 AHEAD
    3 MATCHF=1
C
  100 RETURN
      END
C
C
C
C
C
C LEVEL 7      SUBROUTINE MATCOR(ALSQ,MATSZ)
      SUBROUTINE MATCOR(ALSQ,MATSZ)
C
C *** MATCOR updated by JCM 11 Aug 88 **
C
CX
CC 6C
CH After a Least Squares cycle, prints correlations from the inverse matrix.
C
CA The matrix ALSQ is dimensioned everywhere except in MAIN programs as
CA ALSQ(MATSZ), and handed through as a routine argument.
C
%      CHARACTER *4 IPNAM1(2),IPNAM2(2),IUPPER(%BVAR%),LOWER(%BVAR%)
%      DIMENSION ALSQ(MATSZ),MM(%BVAR%),ICORR(%BVAR%)
/DERBAS/
/IOUNIT/
/MATDAT/
/REFINE/
      EQUIVALENCE (MM(1),MATPNT(2))
C
      IF (SIMUL) GO TO 100
C IF MAXCOR  -VE, NO PRINTING AT ALL:
       IF (MAXCOR .LT. 0) GO TO 100
      DO 1 I=1,LVARB
   1  BLSQ(I)=1./SQRT(ALSQ(MM(I)+I))
C BLSQ USED TEMPORARILY TO HOLD DIAGONAL - NOT NEEDED AS RHS NOW
C
C MAXCOR=0 ASKS FOR WHOLE CORRELATION MATRIX:
      IF (MAXCOR .EQ. 0) GO TO 2
C
C HERE TO PRINT CORRELATION ABOVE MAXCOR PER CENT:
      IHEAD=0
      DO 3 I=1,LVARB
      I1=I+1
      DO 3 J=I1,LVARB
      IND=MM(I)+J
      ICOR=JFIX(100.*ALSQ(IND)*BLSQ(I)*BLSQ(J))
      IF (IABS(ICOR) .LT. MAXCOR) GO TO 3
C WRITE HEADING BEFORE FIRST CORRELATION FOUND TO BE LARGE ENOUGH:
      IF (IHEAD .EQ. 0) WRITE (LPT,2004) MAXCOR
2004  FORMAT (/' Correlations above',I4,' per cent:')
      IHEAD=1
** PROVISION FOR PHASE AND SOURCE CHANGES:
      CALL PARNAM(IPNAM1(1),IPNAM1(2),1,I)
      CALL PARNAM(IPNAM2(1),IPNAM2(2),1,J)
      WRITE (LPT,2005) IPNAM1(1),IPNAM1(2),
     & IPNAM2(1),IPNAM2(2),ICOR
2005  FORMAT (' ',2(1X,A4),' - ',2(1X,A4),'    ',I4)
   3  CONTINUE
      IF (IHEAD .EQ. 0) WRITE (LPT,2006) MAXCOR
2006  FORMAT (/' No correlations found above',I4,' per cent')
      GO TO 100
C
C WHOLE MATRIX:
   2  CALL MESS(LPT,1,'Correlation matrix :')
      CALL NEWLIN(LPT)
      DO 4 I=1,LVARB
C PUT INTO IUPPER AND LOWER THE PRINTING NAMES OF ALL BASIC VARIABLES:
      CALL PARNAM(IUPPER(I),LOWER(I),1,I)
   4  CONTINUE
C
      NV=0
   7  NV=NV+20
      NST=NV-19
      IF (NV .GT. LVARB) NV=LVARB
      NO=NV-NST+1
C NST=STARTING POINT, NV=END POINT, NO=NUMBER OF ITEMS IN THIS PRINTING
C WRITE HEADING FOR ONE PRINTING ON TWO LINES:
      WRITE (LPT,2001) (IUPPER(I),I=NST,NV)
2001  FORMAT (' ',10X,20(1X,A4))
      WRITE (LPT,2003) (LOWER(I),I=NST,NV)
2003  FORMAT (' ',12X,20(1X,A4))
C
      DO 9 I=1,LVARB
      K=NST-1
      DO 5 J=1,NO
      K=K+1
      ICORR(J)=JFIX(100.*ELEMAT(ALSQ,MATSZ,I,K)*BLSQ(I)*BLSQ(K))
   5  CONTINUE
C
      WRITE (LPT,2002) (IUPPER(I),(LOWER(I)),J=1,2),
     & (ICORR(J),J=1,NO)
2002  FORMAT (' ',2(1X,A4),T112,2(1X,A4),T12,20I5)
   9  CONTINUE
C END OF ONE PRINTING
C
      IF (NV .LT. LVARB) GO TO 7
 100  RETURN
      END
C
C
C
C
C LEVEL 7      SUBROUTINE MATINV(ALSQ,MATSZ)
      SUBROUTINE MATINV(ALSQ,MATSZ)
C
C *** MATINV updated by JCM 2 Jun 89 ***
C
CX
CC 6C
CH Inverts the matrix in ALSQ, of which the upper triangle only is held.
CA ALSQ has the dimension MATSZ, which is set in MAIN programs and handed down
CA to here as a parameter of the routine calls.
C
CN No interchanges are done - a positive definite matrix should not need them.
C
CN This should be modified some day to operate on the right hand side BLSQ also.
C
CN It is intended to replace it by a QR inversion routine.
C
      CHARACTER *4 BS,VR
      LOGICAL TESTOV,OVER
      DIMENSION ALSQ(MATSZ)
/DERBAS/
/IOUNIT/
/MATDAT/
/PHASE/
/REFINE/
/SOURCE/
C
      IF (SIMUL) GO TO 100
C DIMENSION OF MATRIX:
      N=LVARB
      IF (N) 100,100,11
C
C SCALE MATRIX TO ALLOW FOR PARAMETERS OF DIFFERING SCALES:
  11  DO 21 I=1,N
      IR=MATPNT(I+1)
      OVER=TESTOV(1.,ALSQ(IR+I))
      IF (OVER) THEN
        CALL PARNAM(BS,VR,1,I)
C 106 Write out phase and source of variable as well.
        WRITE (LPT,3000) I,BS,VR,KSOURC,KPHASE
        WRITE (ITO,3000) I,BS,VR,KSOURC,KPHASE
3000    FORMAT(/' WARNING ** zero diagonal element for basic',
     &   ' variable number',I5,2X,A4,1X,A4,1X,'*S',I1,1X,'*P',I1)
        DERIVB(I)=0.
      ELSE
        DERIVB(I)=1./SQRT(ALSQ(IR+I))
      ENDIF
      DO 22 J=1,I
      IS=MATPNT(J+1)
  22  ALSQ(IS+I)=ALSQ(IS+I)*DERIVB(I)
      DO 23 J=I,N
  23  ALSQ(IR+J)=ALSQ(IR+J)*DERIVB(I)
      IF (OVER) THEN
        DERIVB(I)=1.
        ALSQ(IR+I)=1.
        BLSQ(I)=0.
      ENDIF
  21  CONTINUE
C
      DO 1 I=1,N
      I1=I+1
      IR=MATPNT(I1)
      IS=MATPNT(I)
      ALSQ(IR+I) = 1./ALSQ(IR+I)
C NEXT      BLSQ(I)=BLSQ(I)*ALSQ(IR+I)
      IF (I .EQ. N) GO TO 1
C OR NEXT DO LOOP WILL FAIL
      DO 2 K=I1,N
      ALSQ(IS+K)=-(ALSQ(IR+I)*ALSQ(IR+K))
   2  CONTINUE
      DO 3 J=I1,N
      IQ=MATPNT(J+1)
C
C NEXT      BLSQ(J)=BLSQ(J)-BLSQ(I)*ALSQ(IR+J)
      DO 4 K=J,N
   4  ALSQ(IQ+K) = ALSQ(IQ+K) + ALSQ(IS+K)*ALSQ(IR+J)
   3  CONTINUE
   1  CONTINUE
      IF (N-1) 101,101,12
C
C INVERSE OF ALSQ:
  12  N1=N-1
      DO 5 IFOR=1,N1
      I=N-IFOR
      I1=I+1
      IR=MATPNT(I1)
      IS=MATPNT(I)
      DO 6 J=I1,N
   6  ALSQ(IR+J) = 0.
      DO 7 J=I1,N
      IQ=MATPNT(J+1)
      DO 8 K=J,N
      ALSQ(IR+K) = ALSQ(IR+K) + ALSQ(IS+J)*ALSQ(IQ+K)
      IF (J .NE. K) ALSQ(IR+J) = ALSQ(IR+J) + ALSQ(IS+K)*ALSQ(IQ+K)
   8  CONTINUE
      ALSQ(IR+I) = ALSQ(IR+I) + ALSQ(IS+J)*ALSQ(IR+J)
   7  CONTINUE
   5  CONTINUE
C
C BACK SUBSTITUTE FOR BLSQ (MAY BE INTENDED FOR LABEL 12):
C NEXT      DO 13 IFOR=1,N1
C NEXT      I=N+IFOR
C NEXT      I1=I+1
C NEXT      IR=MATPNT(I)
C NEXT      DO 14 J=I1,N
C NEXT      BLSQ(I)=BLSQ(I)-ALSQ(IR+J)*BLSQ(J)
C NEXT  14  CONTINUE
C NEXT  13  CONTINUE
C
C RESCALE MATRIX TO ALLOW FOR PARAMETERS OF DIFFERING SCALES:
 101  DO 31 I=1,N
      IR=MATPNT(I+1)
      DO 32 J=1,I
      IS=MATPNT(J+1)
  32  ALSQ(IS+I)=ALSQ(IS+I)*DERIVB(I)
      DO 33 J=I,N
  33  ALSQ(IR+J)=ALSQ(IR+J)*DERIVB(I)
  31  CONTINUE
 100  RETURN
      END
C
C
C
C
C LEVEL 2      SUBROUTINE MATSET(ALSQ,MATSZ)
      SUBROUTINE MATSET(ALSQ,MATSZ)
C
C *** MATSET updated by JCM 11 Aug 88 ***
C
CX
CC 6C
CH Sets up pointers into a Least Squares matrix, and clears the matrix and the
CH corresponding right hand side vector.
CA The matrix ALSQ is dimensioned everywhere except in MAIN programs as
CA ALSQ(MATSZ).
C
      DIMENSION ALSQ(MATSZ)
/DERBAS/
/IOUNIT/
/MATDAT/
/REFINE/
C
      IF (SIMUL) GO TO 100
C SET UP POINTERS:
      MATPNT(1)=0
      DO 2 I=1,LVARB
      MATPNT(I+1)=MATPNT(I)+LVARB-I+1
   2  CONTINUE
      NMAT=(LVARB+1)*(LVARB+2)/2
      IF (MATSZ .LT. NMAT) THEN
        WRITE (LPT,3000) MATSZ, NMAT,LVARB
        WRITE (ITO,3000) MATSZ, NMAT,LVARB
3000    FORMAT(/' ERROR ** MATSZ given as',I6,' and needs to be',
     &  '  at least',I6,' for',I5,' basic variables')
        STOP
      ENDIF
C
C CLEAR MATRIX AND RHS:
      CALL GMZER(ALSQ,1,MATSZ)
      CALL GMZER(BLSQ,1,LVARB)
 100  RETURN
      END
C
C
C
C
C LEVEL 7      SUBROUTINE MATSHF(ALSQ,MATSZ)
      SUBROUTINE MATSHF(ALSQ,MATSZ)
C
C *** MATSHF updated by PJB C4.26 Chisq for multi-source March 2013***
C
CX
CC 6C
CH From an inverted Least Squares matrix, calculates shifts in basic variables.
CA The Least Squares matrix ALSQ is dimensioned everywhere except in MAIN
CA programs as ALSQ(MATSZ), and both ALSQ and MATSZ are then handed through the
CA system as the arguments of routines.
CA On entry ALSQ must contain the inverse of the LSQ matrix.
C
CP The vector BLSQ must hold the rhs of the Least Squares equations.
CP SUMWD in /OBSCAL/ holds the sum of weighted differences,
CP NOBS in /OBSCAL/ = number of observations used,
CP LVARB in /DERBAS/= number of basic variables.
C
CD Calculates shifts from the inverse matrix (ALSQ) and the rhs (BLSQ),
CD putting the answers in BLSQ and the esds in DERIVB.
C
CN Eventually MATINV will modify BLSQ to give shifts, but for now we must
CN form them separately.
C
      CHARACTER *4 BS,VR
%      DIMENSION ALSQ(MATSZ),MM(%BVAR%),SHIFTS(%BVAR%)
/DERBAS/
/IOUNIT/
/MATDAT/
/OBSCAL/
/REFINE/
/RSTATS/
/SLAKDA/
      EQUIVALENCE (MM(1),MATPNT(2))
C
      IF (SIMUL) GO TO 100
C SCALE FOR ESD'S:
      CHI2=SWDTOT/(NBSTOT-LVARB)
      CHITOT=CHI2
      IF (NSKTOT .NE. 0) CHITOT=CSQTOT
C
      DO 1 I=1,LVARB
      IR=MM(I)
      SHIFTS(I)=0.
      IF (ALSQ(IR+I) .LT. 0.) THEN
        CALL PARNAM(BS,VR,1,I)
        WRITE (LPT,3000) I,BS,VR
        WRITE (ITO,3000) I,BS,VR
3000    FORMAT (/' ERROR ** ill-conditioning starts at basic variable',
     & ' number',I5,2X,A4,1X,A4)
        STOP
      ENDIF
C
      DERIVB(I)=SQRT(CHITOT*ALSQ(IR+I))
C
      DO 2 J=I,LVARB
   2  SHIFTS(I) = SHIFTS(I) + BLSQ(J)*ALSQ(IR+J)
      I1=I-1
      IF (I1) 1,1,4
   4  DO 5 J=1,I1
   5  SHIFTS(I) = SHIFTS(I) + BLSQ(J)*ALSQ(MM(J)+I)
   1  CONTINUE
C
C FOR NOW:
      DO 3 I=1,LVARB
   3  BLSQ(I)=SHIFTS(I)
 100  RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE MATTOT(ALSQ,MATSZ)
      SUBROUTINE MATTOT(ALSQ,MATSZ)
C
C *** MATTOT updated by JCM 17 Oct 89 ***
C
CX
CC 6C
CH Add in contributions to LSQ matrix and RHS for one observation.
CA All reference to the lsq matrix ALSQ is made through routines with
CA arguments ALSQ and MATSZ.
CA This enables ALSQ to be dimensioned everywhere except in MAIN as ALSQ(MATSZ)
C
CP On entry DERIVB holds the derivatives wrt all basic variables
CP          DIFF holds OBS-CALC
CP          SQRTWT holds the square root of the weight
CP          SIMUL is TRUE if this is only a simulation cycle
C
%      DIMENSION ALSQ(MATSZ),MM(%BVAR%)
/DERBAS/
/MATDAT/
/OBSCAL/
/REFINE/
      EQUIVALENCE (MM(1),MATPNT(2))
C
      IF (SIMUL) GO TO 100
      SQWDIF=SQRTWT*DIFF
      DO 3 I=1,LVARB
   3  DERIVB(I)=SQRTWT*DERIVB(I)
      DO 1 I=1,LVARB
      IF (DERIVB(I) .EQ. 0.) GO TO 1
      IR=MM(I)
      DO 2 J=I,LVARB
   2  ALSQ(IR+J)=ALSQ(IR+J)+DERIVB(I)*DERIVB(J)
      BLSQ(I)=BLSQ(I)+SQWDIF*DERIVB(I)
   1  CONTINUE
 100  RETURN
      END
C
C
C
C
C LEVEL 3      SUBROUTINE MB11A(M,N,A,IA,W)
      SUBROUTINE MB11A(M,N,A,IA,W)
C
C *** MB11A from HARWELL 25 May 79 ***
C
CC 12C
CH Inverts a rectangular matrix whose order is the smaller dimension;
CH used by the Harwell refinement routine VA05A.
C
      DIMENSION A(IA,1),W(1)
C     PARTITION THE WORKING SPACE ARRAY W
C     THE FIRST PARTITION HOLDS THE FIRST COMPONENTS OF THE VECTORS OF
C     THE ELEMENTARY TRANSFORMATIONS
      NRW=M
C     THE SECOND PARTITION RECORDS ROW INTERCHANGES
      NCW=M+M
C     THE THIRD PARTITION RECORDS COLUMN INTERCHANGES
C     SET THE INITIAL RECORDS OF ROW AND COLUMN INTERCHANGES
      DO 1 I=1,M
      N1=NRW+I
      W(N1)=0.5+FLOAT(I)
    1 CONTINUE
      DO 2 I=1,N
      N1=NCW+I
      W(N1)=0.5+FLOAT(I)
    2 CONTINUE
C     'KK' COUNTS THE SEPARATE ELEMENTARY TRANSFORMATIONS
      KK=1
C     FIND LARGEST ROW AND MAKE ROW INTERCHANGES
    3 RMAX=0.0
      DO 4 I=KK,M
      SUM=0.
      DO 5 J=KK,N
      SUM=SUM+A(I,J)**2
    5 CONTINUE
      IF (RMAX .LT. SUM) THEN
      RMAX=SUM
      IR=I
      ENDIF
    4 CONTINUE
      IF(RMAX.EQ.0.0) CALL ERRIN2(M-KK,0,'in MB11A:',
     & 'reduced rows found to be zero')
      IF (IR .LE. KK) GO TO 7
      N3=NRW+KK
      SUM=W(N3)
      N4=NRW+IR
      W(N3)=W(N4)
      W(N4)=SUM
      DO 9 J=1,N
      SUM=A(KK,J)
      A(KK,J)=A(IR,J)
      A(IR,J)=SUM
    9 CONTINUE
C     FIND LARGEST ELEMENT OF PIVOTAL ROW, AND MAKE COLUMN INTERCHANGES
    7 RMAX=0.
      SUM=0.
      DO 10 J=KK,N
      SUM=SUM+A(KK,J)**2
      IF (RMAX .GE. ABS(A(KK,J))) GO TO 10
      RMAX=ABS(A(KK,J))
      IR=J
   10 CONTINUE
      IF (IR .LE. KK) GO TO 12
      N5=NCW+KK
      RMAX=W(N5)
      N6=NCW+IR
      W(N5)=W(N6)
      W(N6)=RMAX
      DO 14 I=1,M
      RMAX=A(I,KK)
      A(I,KK)=A(I,IR)
      A(I,IR)=RMAX
   14 CONTINUE
C     REPLACE THE PIVOTAL ROW BY THE VECTOR OF THE TRANSFORMATION
   12 SIGMA=SQRT(SUM)
      BSQ=SQRT(SUM+SIGMA*ABS(A(KK,KK)))
      W(KK)=SIGN(SIGMA+ABS(A(KK,KK)),A(KK,KK))/BSQ
      A(KK,KK)=-SIGN(SIGMA,A(KK,KK))
      KP=KK+1
      IF (KP .GT. N) GO TO 16
      DO 17 J=KP,N
      A(KK,J)=A(KK,J)/BSQ
   17 CONTINUE
C     APPLY THE TRANSFORMATION TO THE REMAINING ROWS OF A
      IF (KP .GT. M) GO TO 16
      DO 19 I=KP,M
      SUM=W(KK)*A(I,KK)
      DO 20 J=KP,N
      SUM=SUM+A(KK,J)*A(I,J)
   20 CONTINUE
      A(I,KK)=A(I,KK)-SUM*W(KK)
      DO 21 J=KP,N
      A(I,J)=A(I,J)-SUM*A(KK,J)
   21 CONTINUE
   19 CONTINUE
      KK=KP
      GO TO 3
C     AT THIS STAGE THE REDUCTION OF A IS COMPLETE
C     NOW WE BUILD UP THE GENERALIZED INVERSE
C     APPLY THE FIRST ELEMENTARY TRANSFORMATION
   16 KK=M
      KP=M+1
      SUM=W(M)/A(M,M)
      IF (N .LE. M) GO TO 33
      DO 35 J=KP,N
      A(M,J)=-(SUM*A(M,J))
   35 CONTINUE
   33 A(M,M)=1./A(M,M)-SUM*W(M)
C     NOW APPLY THE OTHER (M-1) TRANSFORMATIONS
   36 KP=KK
      KK=KP-1
      IF (KK .LE. 0) GO TO 37
C     FIRST TRANSFORM THE LAST (M-KK) ROWS
      DO 39 I=KP,M
      SUM=0.
      DO 40 J=KP,N
      SUM=SUM+A(KK,J)*A(I,J)
   40 CONTINUE
      DO 41 J=KP,N
      A(I,J)=A(I,J)-SUM*A(KK,J)
   41 CONTINUE
      W(I)=-(SUM*W(KK))
   39 CONTINUE
C     THEN CALCULATE THE NEW ROW IN POSITION KK
      DO 42 J=KP,N
      SUM=-(W(KK)*A(KK,J))
      DO 43 I=KP,M
      SUM=SUM-A(I,KK)*A(I,J)
   43 CONTINUE
      A(KK,J)=SUM/A(KK,KK)
   42 CONTINUE
C     AND REVISE THE COLUMN IN POSITION KK
      SUM=1.-W(KK)**2
      DO 44 I=KP,M
      SUM=SUM-A(I,KK)*W(I)
      A(I,KK)=W(I)
   44 CONTINUE
      A(KK,KK)=SUM/A(KK,KK)
      GO TO 36
C     RESTORE THE ROW INTERCHANGES
   37 DO 45 I=1,M
   46 N1=NRW+I
      IR=IFIX(W(N1))
      IF (I .GE. IR) GO TO 45
      SUM=W(N1)
      N2=NRW+IR
      W(N1)=W(N2)
      W(N2)=SUM
      DO 48 J=1,N
      SUM=A(I,J)
      A(I,J)=A(IR,J)
      A(IR,J)=SUM
   48 CONTINUE
      GO TO 46
   45 CONTINUE
C     RESTORE THE COLUMN INTERCHANGES
      DO 49 J=1,N
   50 N1=NCW+J
      IR=IFIX(W(N1))
      IF (J .GE. IR) GO TO 49
      SUM=W(N1)
      N2=NCW+IR
      W(N1)=W(N2)
      W(N2)=SUM
      DO 52 I=1,M
      SUM=A(I,J)
      A(I,J)=A(I,IR)
      A(I,IR)=SUM
   52 CONTINUE
      GO TO 50
   49 CONTINUE
      RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE MC04B(A,ALPHA,BETA,M,IA,Q)
      SUBROUTINE MC04B(A,ALPHA,BETA,M,IA,Q)
CX
CC 9C
CH Harwell routine to perform Householder reduction of a symmetric matrix to
CH tri-diagonal form.
CN Called by EA06C when  finding eigenvalues
C######DATE   01 JAN 1984     COPYRIGHT UKAEA, HARWELL.
C######ALIAS MC04B
      REAL             A(IA,M),ALPHA(M),BETA(M),H,Q(M),PP,PP1
      REAL             QW1,QW2,ZERO,HREC,ONE,BETA1,P5,AIK,QK
      DATA ZERO/0.0E0/,ONE/1.0E0/,P5/0.5D0/
      ALPHA(1)=A(1,1)
      DO 21 J=2,M
      J1=J-1
      DO 22 I=1,J1
      A(I,J)=A(J,I)
   22 CONTINUE
      ALPHA(J)=A(J,J)
   21 CONTINUE
      DO 1 I=1,M-2
      PP=ZERO
      DO 2 J=I+1,M
      PP=PP+A(I,J)**2
      BETA(J)=A(I,J)
    2 CONTINUE
      PP1= SQRT(PP)
      IF(A(I,I+1).GE.ZERO)THEN
        BETA1=-PP1
      ELSE
        BETA1=PP1
      ENDIF
      IF(PP.GT.ZERO)THEN
        H=PP-BETA1*A(I,I+1)
        A(I,I+1)=A(I,I+1)-BETA1
        BETA(I+1)=A(I,I+1)
        HREC=ONE/H
      DO 207 K=I+1,M
      QK=ZERO
      DO 208 L=I+1,K
      QK=QK+BETA(L)*A(L,K)
  208 CONTINUE
      Q(K)=QK
  207 CONTINUE
      DO 7 K=I+2,M
      AIK=BETA(K)
      DO 8 L=I+1,K-1
      Q(L)=Q(L)+AIK*A(L,K)
    8 CONTINUE
    7 CONTINUE
      PP=ZERO
      DO 118 K=I+1,M
      Q(K)=HREC*Q(K)
      PP=PP+BETA(K)*Q(K)
  118 CONTINUE
      PP=-(PP*P5*HREC)
      DO 11 KI=I+1,M
      Q(KI)=Q(KI)+PP*BETA(KI)
      QW1=-Q(KI)
      QW2=-BETA(KI)
      DO 12 KJ=I+1,KI
      A(KJ,KI)=A(KJ,KI)+QW1*BETA(KJ)+QW2*Q(KJ)
   12 CONTINUE
   11 CONTINUE
      ENDIF
      BETA(I+1)=BETA1
    1 CONTINUE
      DO 23 I=2,M
      H=ALPHA(I)
      ALPHA(I)=A(I,I)
      A(I,I)=H
   23 CONTINUE
      BETA(M)=A(M-1,M)
      RETURN
      END
C
C
C
C
C LEVEL 2      SUBROUTINE MESS(LUNIT,N,TXT)
      SUBROUTINE MESS(LUNIT,N,TXT)
C
C *** MESS updated by JCM 12 Sep 92 ***
C
CX
CC 13C
CH Writes on unit LUNIT the given message, preceded by N empty lines.
CA On entry TXT is a CHARACTER variable holding the message,
CA          N is in integer requesting N empty lines before the message, and
CA            may be 0, for no lines
CA            or > 98, for a page throw.
CO Writes to unit LUNIT N empty lines or a page throw, then the given text with
CO a "space" carriage control.
C
      CHARACTER *(*) TXT
C
      IF (N .LT. 99) THEN
        DO 1 I=1,N
   1    WRITE (LUNIT,2000)
2000    FORMAT (1X)
      ELSE
        WRITE (LUNIT,2002)
2002    FORMAT ('1')
      ENDIF
      WRITE (LUNIT,2001) (TXT(I:I),I=1,LENGT(TXT))
2001  FORMAT (1X,200A1)
      RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE MF5ADD(ISPC,IG,IS,N)
      SUBROUTINE MF5ADD(ISPC,IG,IS,N)
C
C *** MF5ADD by JCM 13 Jun 88 ***
C
CX
CC 18B
CH A specialist routine to deal with the refinement of multipoles.
CH Converts each type of LSQ family 5 (multipoles) addressing to the other.
CA On entry N=1  requests "give answer in in ISPC genus 1 from IG,IS"
CA          N=-1 requests "give answers as IG, IS from species ISPC"
CA So for N=1 IG, IS are set on entry to genus and species
CA    for N=-1, ISPC is set on entry to contain "species" in one long genus.
CP Table MPNAM must have been set up to contain species names, and
CP       MPTAB to point in it for each genus of family 5.
C
/MPODA/
C
      IF (N .LT. 0) GO TO 1
C IG, IS GIVEN ; SET ISPC:
      ISPC=MPTAB(IG)+IS
      GO TO 100
C
C ISPC GIVEN; SET IS,IG:
   1  DO 2 I=1,NMPAT
      IF (MPTAB(I+1) .GT. ISPC) GO TO 3
   2  CONTINUE
C
      STOP 'ERROR ** IN MF5ADD'
   3  IG=I
      IS=ISPC-MPTAB(I)+1
 100  RETURN
      END
C
C
C
C
C LEVEL 1      FUNCTION MINIM(LIST,N,M)
      FUNCTION MINIM(LIST,N,M)
C
C *** MINIM by JCM 15 Jan 88 ***
C
CX
CC 11C
CH Finds the position and value of the minimum in a list of integers.
CA On entry LIST is a list of integers
CA          N is the number of entries in the list
CA On exit  MINIM is set to the value of the smallest menber of LIST
CA      where LIST(M)=MINIM
C
      DIMENSION LIST(N)
/LENINT/
C
      MIN=2**(NBITS-1)-1
      DO 1 I=1,N
      IF (LIST(I) .GE. MIN) GO TO 1
      MIN=LIST(I)
      IKEEP=I
   1  CONTINUE
      MINIM=MIN
      M=IKEEP
      RETURN
      END
C
C
C
C
C LEVEL 4      SUBROUTINE MOLORB(IAT,IPTI)
      SUBROUTINE MOLORB(IAT,IPTI)
C
C *** MOLORB by PJB 6 Apr 87 ***
C
CX
CC 17B
CH To read molecular orbital wave-functions from "W atom-name FUNC" card.
C
CA IAT on entry gives which atom
CA IPTI on entry is the pointer in ICARD in /SCRACH/ from which to read
CA      unless IPTI=-ve, when it signals a request for initialisation
CA      or IPTI=0, which asks for the functions to be checked and printed
C
/CARDRC/
/IOUNIT/
/POSNS/
/SCRACH/
%      COMMON/SCRAT/MODE(%MPAT%),IROT(%MPAT%),TEMP(3,3),MFUN(10,%MPAT%)
/WAVCHR/
/WAVEFN/
      DIMENSION AMPLI(140,5)
      EQUIVALENCE (AMP(1,1),AMPLI(1,1))
C
      IF (IPTI) 30,20,1
C INITIALISE FUNCTION COUNT
  30  CALL JGMZER(NEIG,1,NATOM)
      GO TO 100
C
C ENTRY TO READ REST OF W <ATOM> FUNC CARD:
    1 NEIG(IAT)=NEIG(IAT)+1
      CALL RDWORD(IFUN(NEIG(IAT),IAT),LWORD,IPTI,IPT1,80,0,IER)
      IF (IER.NE.0) GO TO 50
      DO 3 I=1,2
      L=M
      IPT=IPT1
      CALL RDINTG(M,IPT,IPT1,80,IER)
      IF (IER.NE.0) GO TO 50
    3 CONTINUE
      NFUN(NEIG(IAT),IAT)=L
      MFUN(NEIG(IAT),IAT)=M
      LAB=(L*(L+1)+2*M)*2
      II=4
      IF (M.EQ.0) II=2
      DO 4 I=1,II
      IPT=IPT1
      CALL RDREAL(AMPLI(LAB+I,IAT),IPT,IPT1,80,IER)
      IF (IER.EQ.0) GO TO 4
      IF (IER.NE.100) GO TO 50
      AMP(LAB+I,IAT)=0.
    4 CONTINUE
      GO TO 100
C
C  ENTRY TO CHECK AND WRITE OUT FUNCTIONS
   20 IF (NEIG(IAT).EQ.0) GO TO 52
      II=NEIG(IAT)
      CALL MESS(LPT,1,'Molecular Orbital Wave-Functions:')
      DO 21 I=1,II
      L=NFUN(I,IAT)
      M=MFUN(I,IAT)
      IF (M.GT.L) GO TO 53
      LAB=(L*(L+1)+2*M)*2
      JJ=4
      IF (M.EQ.0) JJ=2
      WRITE (LPT,13) IFUN(I,IAT),L,M,(AMPLI(LAB+J,IAT),J=1,JJ)
   13 FORMAT (1X,'Function: ',A4,' L =',I3,' M =',I3,' Amplitudes:',2
     & (2F8.5,2X))
   21 CONTINUE
      GO TO 100
C
C  REPORT ERRORS
   50 WRITE (LPT,3000)IER,IPT,IPT1, ICARD
      WRITE (ITO,3000)IER,IPT,IPT1, ICARD
3000  FORMAT (' Error (IER=',I4,' in field',I3,'-',I2,') inter',
     & 'preting the card which reads:'/1X,80A1)
      GO TO 101
  52  CALL ERRMES(1,-1,'Molecular orbital wave-function not found')
      GO TO 101
   53 WRITE (LPT,3002) IFUN(I,IAT),L,M
      WRITE (ITO,3002) IFUN(I,IAT),L,M
3002  FORMAT (/' Implausible quantum numbers for function ',A4,
     & ' L =',I3,', M = ',I3)
      GO TO 101
C
  101 IERR=IERR+1
  100 RETURN
      END
C
C
C
C
C LEVEL 5      SUBROUTINE MPCON(MAT,KMAX)
      SUBROUTINE MPCON(MAT,KMAX)
C
C *** MPCON by PJB ***
C
CX
CC 18A
CH Finds the symmetry constraints on multipoles.
CA MAT the multipole atom number
CA KMAX =  2l+1
C
      EXTERNAL DUMMY
      DIMENSION ANG(3),ROTN(3,3)
C
/ATNAM/
/CELPAR/
/IOUNIT/
/MPODA/
/NSYM/
/POSNS/
/QROT/
      COMMON/SCRAT2/OROT(3,3,2),ISUB(24),MATP,ORMAT(169),
     & FUN(169),ORT(169),ANOR(13),USED(13),INDX(13),JNDX(13),DIJ(196)
      LOGICAL USED,LODD
      COMPLEX DIJ
/SYMDA/
/SYMTAB/
C
      IODD=2-MOD(KMAX/2,2)
      NPTS=KMAX*KMAX
      IAT=MPATAB(MAT)
      IF (MAT.EQ.MATP) GO TO 9
C  NEW ATOM
      MATP=MAT
      CALL GMEQ(ROT(1,1,MAT),OROT(1,1,1),3,3)
      CALL GMEQ(ROT(1,1,MAT),OROT(1,1,2),3,3)
      CALL TRINV3(OROT(1,1,2),D)
      CALL TRANSQ(OROT(1,1,2),3)
      CALL MAKGRP(ISGEN(1,IAT),ISUB,0,DUMMY)
      WRITE (LPT,110) (I*ISUB(I),I=1,NOPC)
  110 FORMAT (//' Elements of Sub-group: '/1X,24I5)
    9 CALL GMZER(FUN,NPTS,2)
      DO 1 N=1,NOPC
      IF (ISUB(N).EQ.0) GO TO 1
      ISIG=NORD(N)*ISUB(N)
C  REMEMBER THE QUANTUM ROTATIONS ARE SET FOR RECIPROCAL SPACE
      CALL GMEQ(SYM(1,1,INVERS(N)),ROTN,3,3)
      CALL TRANSQ(ROTN,3)
C  USE ONLY PROPER ROTATIONS
      IF (NORD(N).LT.0) CALL GMREV(ROTN,ROTN,3,3)
      CALL EULSYM(ANG,ROTN,OROT)
      CALL DIJROT(DIJ,ANG(1),ANG(2),ANG(3),KMAX)
      IF (IOUT.GT.150) WRITE (LPT,4016) KMAX/2,N,
     & (DEGREE(ANG(I)),I=1,3)
4016  FORMAT (/' L =',I2,' Operator No:',I3,' Euler Angles:',3F8.2)
      L=0
      LODD=MOD(KMAX/2,2).EQ.1
      DO 2 J=1,KMAX
C  REMOVE L ODD  IF CENTROSYMMETRIC
      IF (LODD .AND. ISGEN(1,IAT).LT.0) THEN
        DO 5 I=1,KMAX
    5   DIJ(L+I)=CMPLX(0.,0.)
      ELSE
C FOR IMPROPER ROTATIONS reverse signs IF L is odd
        IF (ISIG.LT.0 .AND. LODD) THEN
          DO 4 I=1,KMAX
    4     DIJ(L+I)=-DIJ(L+I)
        ENDIF
      ENDIF
      IF (IOUT.GT.200) WRITE(LPT,4010) (DIJ(L+I),I=1,KMAX)
4010  FORMAT (12(1X,7(2F8.4,2X)/))
      L=L+KMAX
    2 CONTINUE
      CALL REAORB(DIJ,ORT,KMAX)
      IF (IOUT.GT.200) THEN
      CALL MESS(LPT,1,'Dij matrix for real functions:')
      L=0
        DO 60 I=1,KMAX
        WRITE (LPT,4012) (ORT(J),J=L+1,L+KMAX)
        L=L+KMAX
   60   CONTINUE
      ENDIF
      CALL GMADD(FUN,ORT,FUN,1,NPTS)
    1 CONTINUE
      IF (IOUT .GT.100) CALL MESS(LPT,2,'Sum Matrix')
      FAC=1./FLOAT(IABS(ISGEN(1,IAT)))
      CALL GMSCA(FUN,FUN,FAC,1,NPTS)
      L=0
      IF (IOUT.GT.100)THEN
        DO 25 I=1,KMAX
        WRITE (LPT,4012) (FUN(J),J=L+1,L+KMAX)
        L=L+KMAX
   25   CONTINUE
      ENDIF
      CALL GMNORM(FUN,ANOR,KMAX,KMAX)
      CALL GMEQ(FUN,ORT,KMAX,KMAX)
      CALL TRANSQ(ORT,KMAX)
      CALL GMPRD(ORT,FUN,ORMAT,KMAX,KMAX,KMAX)
      IF (IOUT.GT.180) THEN
        CALL MESS(LPT,1,'Normalised sum matrix:')
        L=0
        DO 27 I=1,KMAX
        WRITE (LPT,4012) (FUN(J),J=L+1,L+KMAX)
        L=L+KMAX
   27   CONTINUE
        CALL MESS(LPT,1,'Product Matrix:')
        L=0
        DO 26 I=1,KMAX
        WRITE (LPT,4012) (ORMAT(L+J),J=1,KMAX)
4012    FORMAT (1X,15F8.4)
        L=L+KMAX
   26   CONTINUE
      ENDIF
      RETURN
      END
C
C
C
C
C LEVEL 5      SUBROUTINE MPFORM(IDT,NJ)
      SUBROUTINE MPFORM(IDT,NJ)
C
C *** MPFORM updated by PJB C128 Feb 2004 ***
C
CX
CC 18A
CH Finds out which radial form factors to apply to which atom and L value.
CP ATOPOS etc.
CA IDT is the position in the CDF of the first J card
CA NJ the number of J cards
CD Called normally by PFSET
CD factor to use for multipole atom I and L value J, if negative a radial
CD wave function is to be used to compute the form factors
C
      CHARACTER*4 WORD
      LOGICAL FIRST,LERCHK
C128 Common ATNAM now included
/ATNAM/
/CARDRC/
/FORMDA/
/FONAM/
/MAGDAT/
/MPODA/
/POLFOR/
/POSNS/
/REFINE/
C
%      CALL JGMZER(MPLFOR,%MPFL%,%MPFO%)
      NAMFRE=NUMFNM+1
      NMPFOR=0
      DO 1 J=1,NJ
      CALL INPUTJ(IDT,NTYP,IAT,IPT,IE)
C128 IMPROVES THE CHECKING
C It is a going to be a multipole form factor
      IF (NTYP.NE.2) GO TO 2
      IERR=IERR+IE
      IF (MAG) THEN
C Check that it is in the list of magnetic form factors
        MAT = NFIND(IAT,NMFORM,NMAG)
C SET MAT to the l=0 form factor number
        IF (MAT.EQ.0) THEN
          CALL ERRMES(1,1,FONAME(IAT)//
     &    'is not a magnetic form factor name ')
          GO TO 2
        ENDIF
      ENDIF

      FIRST=.TRUE.
    3 CALL RDWORD(WORD,LEN,IPT,IPT1,80,0,IE)
      IF (IE.EQ.100) GO TO 2
      IF (IE.NE.0) CALL ERRMES(1,1,' in form-factor name')
      IF (FIRST) THEN
        FIRST=.FALSE.
        IMFOR=MPFOR(IAT)
        IF (IMFOR .EQ.0) THEN
%          CALL ERRCHK(2,NMPFOR,%MPFO%,0,'Multipole form factors')
          IMFOR=NMPFOR
C128 MPFOR(IAT) gives multipole form-factor number
          MPFOR(IAT) = IMFOR
        ENDIF
        IF (WORD.EQ.'RADF') THEN
C128 MPLFOR(1,MP) = -999 indicates radial form factors for MP
          MPLFOR(1,IMFOR)=-999
          GO TO 2
        ENDIF
      ENDIF
      IFORM=ISCAT(WORD)
      CALL RDINTG(L,IPT1,IPT,80,IE)
      IF (IE.NE.0) THEN
        CALL ERRMES(1,1,' reading form-factor L value for'
     &  //FONAME(IAT))
      ELSE IF (L .EQ.0) THEN
        CALL ERRMES(4,-1, 'Form factor L=0 for '//FONAME(IAT)//
     &  ' should not be given, '//FONAME(IAT)//' is used ')
%      ELSE IF (.NOT. LERCHK(1,L,%MPFL%,0,
     & 'L value of form factor out of range')) THEN
        CONTINUE
      ELSE
        IF (IFORM.EQ.0) THEN
C128 Don't set the form factor number until after checking L
          FONAME(NAMFRE)=WORD
          IFORM=NAMFRE
%          CALL ERRCHK(2,NAMFRE,%FORM%,0,'Too many form-factors')
        ENDIF
        MPLFOR(L,IMFOR) = IFORM
      ENDIF
      GO TO 3
    2 IDT=IDT+NYZ
    1 CONTINUE
      NUMGEN=NUMFNM
      NUMFNM=NAMFRE-1
C
      RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE MPOVAR(I,J)
      SUBROUTINE MPOVAR(I,J)
C
C *** MPOVAR by JCM 9 Feb 91 ***
C
CC18A
CX
CH Records whether each multipole parameter is fixed or varied.
CA On entry I=which parameter (or 0 if it is the initial entry to fix all)
CA          J=which variable it will be (or 0 if it is the initial entry)
CD If this is the initial entry records all multipoles fixed by clearing the
CD array KPOLMP in /MPODA.  Otherwise, records there that parameter I is
CD variable J.
C
/MPODA/
      IF (J .EQ. 0) THEN
        DO 1 K=1,NMPOL
   1    KPOLMP(K)=0
      ELSE
        KPOLMP(I)=J
      ENDIF
      RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE MTPROD(I,J,N)
      SUBROUTINE MTPROD(I,J,N)
C
C *** MTPROD new by PJB Nov 90 ***
C
Cx
CC 17C
CH Puts entries into the table of time inversion operators.
CA I, J, and N are operator numbers. The entry in MTSYM for N is
CA             set to the product of that for I and J.
CN Called from MAGSYM through MAKGRP using the internal subroutine
CN name PRODCT.
C
/SYMMAG/
C
      MTSYM(N)=MTSYM(I)*MTSYM(J)
      RETURN
      END
C
C
C
C
C LEVEL 3      SUBROUTINE MUCALC(MH)
      SUBROUTINE MUCALC(MH)
C
C *** MUCALC correction fC4.9 PJB May 2008 ***
C
CX
CC 7C
CH To calculate induced moments from anisotropic susceptibilities
CH and elipsoid orientation
C
CA MH is the index of the magnetic field in SRCPAR
C
%      DIMENSION IOPG(%SYMO%),ISTAB(%SYMO%),HCHI(3),XP(3),AMAT(3,3),PCHI(3),
     &AXES(3,3),IPCHI(3),WORK(20),PVEC(3),CHISYT(6,6)
/ATNAM/
/DSOURC/
/IOUNIT/
/MAGCHI/
/MAGDAT/
      DIMENSION CHIIJ(6,20),KCHIJ(6,20)
      EQUIVALENCE (ANGM,CHIIJ),(KSMOD,KCHIJ)
/NSYM/
/POSNS/
/SYMDA/
C
      DO 1 NM = 1,NMAG
      IAT = JMAGAT(NM)
   12 FORMAT (/' Magnetisation elipsoid for ',a4/' Principal axes:',
     &5x,'chi (muB/T)    x       y       z')
      WRITE (LPT,12) ATNAME(IAT)
C Put chis into  matrix
      J=2
      K=3
      DO 3 I=1,3
      AMAT(I,I)=CHIIJ(I,NM)
      AMAT(J,K)=CHIIJ(I+3,NM)
      AMAT(K,J)=AMAT(J,K)
      J=K
      K=I
    3 CONTINUE
      CALL GMEQ(AMAT,AXES,3,3)
      CALL TRED2(AXES,3,3,PCHI,WORK,.TRUE.)
      CALL TQLI(PCHI,WORK,3,3,AXES,.TRUE.)
C Sort eigenvectors
      CALL SORTX(PCHI,IPCHI,3)
      DO 4 II=3,1,-1
      I = IPCHI(II)
      WRITE (LPT,13)  PCHI(I),(AXES(J,I),J=1,3)
   13 FORMAT (21X,F8.3,3X,3F8.3)
    4 CONTINUE
      CALL MAKGRP(ISGEN(1,IAT),ISTAB,0,DUMMY)
      CALL JGMZER(IOPG,NOPC,1)
      IF (ISGEN(1,IAT).LT.0) ISTAB(1)=1
      CALL FACGRP(ISTAB,IOPG,NFAC)
      do 5 JS=1,NUMSRC
C skip for powders since field direction not defined
      IF (MSRC(2,JS).EQ.9) GO TO 5
      CALL GMSCA(SRCPAR(3,JS),PVEC,SRCPAR(MH,JS),3,1)
       WRITE (LPT,10) SRCPAR(MH,JS),(SRCPAR(2+I,JS),I=1,3)
   10 FORMAT (/' Induced moments with field',F6.2,' T, parallel to',
     &3f8.3/' Operator      Atom Position',12X,'x       y       z')
      DO 2 IOP = 1,NOPC
C4.9 facgrp sets IOPG(IOP)=IOP for new factor group
      IF (IOPG(IOP).NE.IOP) GO TO 2
      CALL ROTSYM(X(1,IAT),XP,IOP,1)
      CALL GMADD(XP,TRANS(1,IOP),XP,3,1)
      CALL GMTRAN(CHISYM(1,1,IOP),CHISYT,6,6)
      CALL GMPRD(CHISYT,CHIIJ(1,NM),WORK,6,6,1)
      J=2
      K=3
      DO 6 L=1,3
      HCHI(L)=PVEC(L)*WORK(L) + PVEC(J)*WORK(3+K) + PVEC(K)*WORK(3+J)
      J=K
      K=L
    6 CONTINUE

      WRITE (LPT,11) IOP, XP,HCHI
   11 FORMAT (3X,I2,4X,3F8.4,2X,3F8.3)
    2 CONTINUE
    5 continue
    1 CONTINUE
      RETURN
      END
C
C
C
C
C LEVEL 3      FUNCTION MULBOX(H)
      FUNCTION MULBOX(H)
C
C *** MULBOX updated by JCM 14 Jun 88 ***
C
CX
CC 3C
CH Tests indices for being in the asymmetric unit, and gives multiplicity.
C
CA On entry H(3) is a real 1x3 vector holding the reflection indices.
CD The function is set to the multiplicity of the reflection if the reciprocal
CD lattice point represented by H is inside the exact asymmetric unit.
CD If the point is not inside the function is returned as zero.
C
      DIMENSION H(3)
/FUNIT/
/GUNIT/
C
C  DETECT 000
      MULT=1
      IBOX=999
      IF (ABS(H(1))+ABS(H(2))+ABS(H(3)).LT.10.E-5) GO TO 101
C
C  OTHERWISE START WITH MULT FOR GENERAL POSITION
      MULT=NMUL
C  VALUE FOR GENERAL POINT
C
      CALL INBOX(H,IBOX)
      IN=IBOX
      IF (IN) 102,101,3
C
    3 IF (IN.GT.10) GO TO 4
C  ON A PLANE
      M1=MARK(IN,1)+1
      GO TO (102,101,2,5,5) , M1
    2 MULT=MULT/2
      GO TO 101
C
C  WE ONLY WANT HALF THE PLANE
    5 TEST= SCALPR(H,BSYM(1,IN))
      IF (TEST+.0001 .LT.0.) GO TO 102
C  DIVIDE MULTIPLICITY IF ON DIAD AXIS
      IF (ABS(TEST).GE..0001) GO TO 101
      IF (MARK(1,1).EQ.4) GO TO 7
      MULT=MULT/2
      GO TO 101
C  BIT TO ACCEPT ONLY ONE HALF OF CENTRE LINE FOR P-1
   7  IF (SCALPR(H,BSYM(1,2)).LT.0.) GO TO 102
      GO TO 101
C
C  ON AN AXIS
    4 IN=IN-10
      IF (MARK(IN,2).EQ.0) GO TO 102
      MULT=MULT/IABS(MARK(IN,2))
      IF (MARK(IN,2).GT.0 .OR. NASYM .NE.2) GO TO 101
C  WE ONLY WANT HALF THE AXIS
      IF (SCALPR(H,EDGE(1,IN)).GE.0.) GO TO 101
C
C  HERE IF NOT STRICTLY INSIDE
 102  MULT=0
 101  MULBOX=MULT
      RETURN
      END
C
C
C
C
C LEVEL 2      SUBROUTINE MULIND(MUL)
      SUBROUTINE MULIND(MUL)
C
C  *** MULIND new by PJB  14-Nov-1997 ***
C
CC 2C
CH Used by ARRNGE for data whose indices may be submultiples of integers
CP INPUT I to set up the commons /IINFO/ and /IINFOW/.
CA MUL is a logical which is set to .TRUE. if the indices are submultiples
CA For the entries INDMUL and INDDIV the 3 component vectors  HI and HO
CA are the input and output indices respectively.
CD MULIND interprets the numbers following MULH, MULK, and MULL entries
CD on I cards to be the numbers by which to multiply H,K,L respectively
CD in order to obtain integer indices. These numbers are placed in AMUL in
CD common /MULPLY/.
CD ENTRY INDMUL returns HO(I),I=1,3 = HI(I)*AMUL(I)
CD ENTRY MULDIV returns HO(I),I=1,3 = HI(I)/AMUL(I)
      DIMENSION HI(3),HO(3)
      LOGICAL MUL,TESTOV
/IINFO/
/IINFOW/
/IOUNIT/
/MULPLY/
C
      DO 2 I=1,3
      AMUL(I)=1.
    2 CONTINUE
      DO 1 I=1,IIN
      IF (IIREAD(I)(1:3).EQ.'MUL') THEN
        IF (IIREAD(I)(4:4).EQ.'H') THEN
          AMUL(1)=ACOEFF(I)
        ELSE IF (IIREAD(I)(4:4).EQ.'K') THEN
          AMUL(2)=ACOEFF(I)
        ELSE IF (IIREAD(I)(4:4).EQ.'L') THEN
          AMUL(3)=ACOEFF(I)
        ENDIF
      ENDIF
   1  CONTINUE
      MUL=.FALSE.
      DO 5 I=1,3
      IF (TESTOV(1.,AMUL(I))) AMUL(I)=1.
      IF (ABS(AMUL(I)-1.) .GT. 0.001) MUL=.TRUE.
   5  CONTINUE
      IF (MUL) WRITE (LPT,10) (JFIX(AMUL(I)),I=1,3)
  10  FORMAT (/' Multipliers for the indices h,k,l are:',3I3)
        GO TO 100
C
      ENTRY INDMUL(HI,HO)
      DO 3 I=1,3
      HO(I)=HI(I)*AMUL(I)
    3 CONTINUE
      GO TO 100
C
      ENTRY INDDIV(HI,HO)
      DO 4 I=1,3
      HO(I)=HI(I)/AMUL(I)
    4 CONTINUE
C
  100 RETURN
      END
C
C
C
C
C LEVEL 4      FUNCTION MULPCY(H)
      FUNCTION MULPCY(H)
C
C *** MULPCY new by PJB C4.17 July 2009 ***
C
CX
CC2C
CH To calculate reflection multiplicities
CA H holds the reflection indices
CP SYMOP must hace been called

      DIMENSION H(3),HR(3)
/NSYM/

      DO 1 NO=1,NOPC
      CALL ROTSYM(H,HR,NO,2)
      M=MULBOX(HR)
      IF (M.GT.0) GO TO 2
      CALL GMREV(HR,HR,3,1)
      M=MULBOX(HR)
      IF (M.GT.0) GO TO 2
    1 CONTINUE
    2 MULPCY=M
      RETURN
      END
            C
C
C
C
C LEVEL 1      SUBROUTINE NAMPOL(NAME,K,L)
      SUBROUTINE NAMPOL(NAME,K,L)
C
C *** NAMPOL by PJB ***
C
CX
CC 18C
CH Creates the label for a given multipole.
CA On entry K=2l+1 and L goes from 1 to K for m from m+ to m-
CA On exit  NAME is the A4 label
C
      CHARACTER*4 NAME,SIG(3)*1
      DATA SIG/'+',' ','-'/
C
      IL=K/2
      M=IABS(L-IL-1)
      I=1
      IF (L.GT.IL+1) I=3
      IF (L.EQ.IL+1) I=2
      WRITE (NAME,10) IL,M,SIG(I)
   10 FORMAT ('Y',2I1,A1)
      RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE NB01A(K,AZ,BZ,E2,X,Y,MAXIT)
      SUBROUTINE NB01A(K,AZ,BZ,E2,X,Y,MAXIT)
C
C *** NB01A updated by PJB May-2007  ***
C
CX
CC 9C
CH Harwell routine NB01A to find the zero of a function.
CD Finds the value of X in the range AZ <= X <= BZ for which Y(X)=0
CA Called initially with K=0, AZ and BZ set to the minimum and maximum values
CA of X to be searched, E2 to the precision in X required and ABS(MAXIT) to
CA the maximum number of iterations allowed.
CA Subsequent calls depend on the value of K returned
CA     K=0 Initial call as above
CA     K=1 calculate Y for the value of X returned and call again
CA     K=2 The value of X retuned is the required solution
CA     K=3 No zero value of Y was found X=AZ and BZ
CA     K=4 MAXIT calls have been made without finding the zero value within the
CA         required precision
CN the private common /NB01AP  (C43) now replaced by SAVE (C4.2)
CN  to preserve the values of of A,B,IT AND THE Js between calls
C43 YA added to this common May 99
C132 M added to this common June 2004
C4.2 COMMON  NB01AP replaced with SAVE  A,B,M,H,IT,J1,J2,J3,YA,YB
      SAVE A,B,H,M,X1,IT,J1,J2,J3,Y1,YA,YB,YTEST
C
      IF(K .GT. 0)GO TO 30
C
C     CALCULATE Y(X) AT X=AZ.
      A = AZ
      B = BZ
      X = A
      X1 = 0
      Y1=0
      YTEST=0
      J1 = 1
      IT = 1
      H = 0
      M = IABS(MAXIT)
   10 K = J1
      GO TO 100
C
C     PRINT X AND Y(X) WHEN REQUESTED.
   30 IF(MAXIT .LE. 0) WRITE(6,2000)X,Y
2000  FORMAT(2X,'NB01A   X=',E16.7,'  Y(X)=',E16.7)
C
C     TEST WHETHER Y(X) IS SUFFICIENTLY SMALL.
      IF( ABS(Y) .GT. E2)GO TO 50
   45 K = 2
      GO TO 100
C
C     BRANCH DEPENDING ON THE VALUE OF J1.
   50 GO TO (60,70,88,170),J1
C
C     CALCULATE Y(X) AT X=BZ.
   60 YA = Y
      X = B
      J1 = 2
      GO TO 100
C
C     TEST WHETHER THE SIGNS OF Y(AZ) AND Y(BZ) ARE DIFFERENT.
   70 IF(YA*Y .LT. 0.)GO TO 120
C
C     BEGIN THE BINARY SUBDIVISION TO SEARCH FOR A BRACKET.
      X1 = A
      Y1 = YA
      J1 = 3
      H = B-A
      J2 = 1
   80 X2 = A+0.5*H
      J3 = 1
C
C     CHECK WHETHER MAXIT FUNCTION VALUES HAVE BEEN CALCULATED.
   90 IT = IT+1
      IF(IT .GE. M)GO TO 10
      X = X2
      GO TO 100
C
C     TEST WHETHER A BRACKET HAS BEEN FOUND.
   88 IF(YA*Y .LT. 0.)GO TO 120
C
C     CONTINUE THE SEARCH FOR A BRACKET.
      IF(J3 .GE. J2)GO TO 110
      A = X
      YA = Y
      X2 = X+H
      J3 = J3+1
      GO TO 90
  110 A = X1
      YA = Y1
      H = 0.5*H
      J2 = J2+J2
      GO TO 80
C
C     AT THIS POINT THE FIRST BRACKET HAS BEEN FOUND.
  120 B = X
      YB = Y
      J1 = 4
C
C     CALCULATE THE NEXT X BY THE SECANT METHOD BASED ON THE BRACKET.
  130 IF( ABS(YA) .LE. ABS(YB))GO TO 140
      X1 = A
      Y1 = YA
      X = B
      Y = YB
      GO TO 150
  140 X1 = B
      Y1 = YB
      X = A
      Y = YA
C
C     USE THE SECANT METHOD BASED ON THE FUNCTION VALUES Y1 AND Y.
  150 U = Y*(X-X1)/(Y-Y1)
  155 X2 = X-U
      IF(X2.EQ.X)GO TO 195
      X1 = X
      Y1 = Y
      YTEST = 0.5*AMIN1( ABS(YA), ABS(YB))
C
C     CHECK THAT X2 IS INSIDE THE INTERVAL (A,B).
      IF((X2-A)*(X2-B) .LT. 0. )GO TO 90
C
C     CALCULATE THE NEXT VALUE OF X BY BISECTION.
  160 X2 = 0.5*(A+B)
      YTEST = 0.
C
C     CHECK WHETHER THE MAXIMUM ACCURACY HAS BEEN ACHIEVED.
      IF((X2-A)*(X2-B))90,45,45
C
C     REVISE THE BRACKET (A,B).
  170 IF(YA*Y .GE. 0.)GO TO 180
      B = X
      YB = Y
      GO TO 190
  180 A = X
      YA = Y
C
C     USE YTEST TO DECIDE THE METHOD FOR THE NEXT VALUE OF X.
  190 IF(YTEST .LE. 0.)GO TO 130
      IF( ABS(Y) -YTEST)150,150,160
  195 IF(U.EQ.0.)GO TO 45
      U=U+U
      GO TO 155
C
 100  RETURN
      END
C
C
C
C
C LEVEL 1      FUNCTION NCFIND(CH,CTABLE,NBOUND)
      FUNCTION NCFIND(CH,CTABLE,NBOUND)
C
C *** NCFIND by JCM 15 Jul 86 ***
C
CX
CC 11C
CH Searches for a particular word in a table of words.
CA CH is the word for which to search
CA CTABLE is a table containing NBOUND words
CD Sets the function value to zero of CH is not in the table or
CD to the position of CH in the table if it is there.
C
      CHARACTER *(*) CH,CTABLE(NBOUND)
C
      DO 1 L=1,NBOUND
      IF (CH .EQ. CTABLE(L)) GO TO 101
   1  CONTINUE
      L=0
 101  NCFIND=L
      RETURN
      END
C
C
C
C
C LEVEL 1      FUNCTION NCHINT(CH)
      FUNCTION NCHINT(CH)
C
C *** NCHINT by JCM 27 Apr 90 ***
C
CX
CC 13C
CH Converts an ASCII character into an integer
CA On entry CH is the A1 character
CA On exit NCHINT is its decimal equivalent
C
      CHARACTER *1 CH
C
      NCHINT=ICHAR(CH)-48
      RETURN
      END
C
C
C
C
C LEVEL 1      FUNCTION NDIGIT(I)
      FUNCTION NDIGIT(I)
C
C *** NDIGIT by JCM 11 Oct 83 ***
C
CX
CC 13C
CH Identifies a character as a digit or not.
CA I is a single A1 character
CD The function is set to -1 of I is not a digit, otherwise to the digit
CD value.
C
      CHARACTER *1 I
/CHARS/
C
      DO 1 J=1,10
      IF (I .EQ. IDIGIT(J)) GO TO 2
   1  CONTINUE
      J=-1
   2  NDIGIT=J
      IF (NDIGIT .EQ. 10) NDIGIT=0
      RETURN
      END
C
C
C
C
C LEVEL 5      SUBROUTINE NDPOPS(IREF,NEED,MISS)
            SUBROUTINE NDPOPS(IREF,NEED,MISS)
C
C *** NDPOPS new by PJB Feb 2008 ***
C
CX
CC 7A
CH Returns the number of domain populations which can be refined  using
CH refinement type IREF
CA IREF is the refinement type given by 'L REFI'
CA on Exit NEED is the number of domains which can be distinguished
CA on exit MISS = 1 if chirality domains can be distinguished
CA         MISS = 2 if they cannot, so only odd numbered domain
CA                  populations  are refined
CP DOMAG1(1 and 2) to define the magnetic structure
CD Refinement types:
CD IREF=1 refine on the modulus of the structure factor Fc
CD IREF=2 refine on the square of Fc
CD IREF=4 refine on signed Fc (centrosymmetric)
CD IREF=5 refine on polarised neutron flipping ratio R (magnetic only)
CD IREF=6 refine on ratio of magnetic to nuclear structure factor: gamma
CD IREF=7 refine on polarised neutron asymmetries (magnetic only)
CD IREF=8 refine using elements of the polarisation matrix (snp only) 1
C
/SATELL/
/SYMMAG/
/TWIN/

      NEED=1
      MISS=1
C Aligned ferromagnetic
      IF (FERA)GO TO 100
C IREF 1 AND 2 INTENSITIES
      NEED=NDOM
      MISS=KCENT
C Magnetic twinning
      IF (MTWIN) NEED=NEED*NTWIN
C POLARISATION DEPENDENT INTENSITIES
C IPROP=0 MEANS 180 DEGREE DOMAINS
      IF (IREF.LT.3) GO TO 100
      IF (IPROP.EQ.0) NEED=2*NEED
      IF (IREF.LT.8) GO TO 100
C SNP DATA
      IF (IREF.EQ.8) THEN
         NEED=NEED*KCENT
         MISS=1
       ENDIF
  100 RETURN
      END
C
C
C
C
C LEVEL 5      SUBROUTINE NEWCD
      SUBROUTINE NEWCD
C
C *** NEWCD by JCM 10 Mar 86 ***
C
CX
CC 6C
CH Opens a file on to which to write a new Crystal Data File after a Least
CH Squares refinement.
CD Asks interactively for a file name, and opens this with default extension
CH .CCN at RAL, .CRY at ILL, for unit NEWIN in /NEWOLD/
C
/NEWOLD/
/SCRACH/
C
      MESSAG='New Crystal Data file '
CS RAL      NAMFIL='.CCN'
CS ILL      NAMFIL='.CRY'
      CALL OPNFIL(NEWIN,112)
      RETURN
      END
C
C
C
C
C LEVEL 3      SUBROUTINE NEWCRY(IFUN,LET,LUNO)
      SUBROUTINE NEWCRY(IFUN,LET,LUNO)
C
C *** NEWCRY corrected by PJB  C104 4-Apr-2001 ***
C
CX
CC 13C
CH Writes a new crystal data file in which the "LET" cards are modified
CA If, on entry, IFUN is zero no "LET" cards are copied to the new file
CA     if IFUN is non-zero the IFUNth record in the CDF is replaced by
CA     the contents of ICARD
CA On exit LUNO is the unit number of the new crystal data file
C
CD A new crystal data file is written in which either all the cards starting "LET"
CD are ommitted, or the single record IFUN is replaced by that found in ICARD in
CD common SCRACH on entry. The contents of ICARD are corrupted.
CD
CD Complains if record IDEN is not present.
C
      CHARACTER *1 LET
      CHARACTER *80 REPLIN
/CARDRC/
/PHASE/
/SCRACH/
C
      ILOW=1
      IF (JPHASE .GT. 1) ILOW=NTOTAL(JPHASE-1)
      IHI=NTOTAL(JPHASE)
      IF (IFUN.NE.0) THEN
        IF (IFUN.LT.ILOW .OR. IFUN .GT. IHI) CALL ERRIN2 (IFUN,
     &  -1,'Record','not in crystal data file, not replaced')
        REPLIN=ICARD
      ENDIF
      MESSAG=' New crystal data file'
      NAMFIL='.CRY'
      LUNO=NOPFIL(112)
C
C READ ALL CARDS
      DO 1 IDEN=ILOW,IHI
      READ (IO10,REC=IDEN,FMT=1001) ICARD
      IF (IFUN.EQ.0) THEN
        IF (ICARD(1:1).EQ.LET)  GO TO 1
      ELSE
        IF (IDEN.EQ.IFUN) THEN
          WRITE (LUNO,1001) REPLIN
          GO TO 1
        ENDIF
      ENDIF
      WRITE (LUNO,1001) ICARD
    1 CONTINUE
C
1001  FORMAT (A80)
      RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE NEWLIN(LUNIT)
      SUBROUTINE NEWLIN(LUNIT)
C
C *** NEWLIN by JCM 14 Sep 92 ***
C
CX
CC 13C
CH Writes a newline to the output unit LUNIT
C
      WRITE(LUNIT,2000)
2000  FORMAT (' ')
      RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE NEWPAG(LUNIT)
      SUBROUTINE NEWPAG(LUNIT)
C
C *** NEWPAG by JCM 14 Sep 92 ***
C
CX
CC 13C
CH Writes a newpage carriage control ('1') to the output unit LUNIT
C
      WRITE(LUNIT,2000)
2000  FORMAT ('1')
      RETURN
      END
C
C
C
C
C LEVEL 3      SUBROUTINE NEXCON(C,ICON,MORE)
      SUBROUTINE NEXCON(C,ICON,MORE)
C
C *** NEXCON updated by JCM 22 Aug 86 ***
C
CX
CC 5A
CH Sets up the "next" contour value to plot for Fouriers.
CA On entry LOGICAL MORE is .TRUE. if there is no reason why more contours
CA                           should not be requested,
CA                       or .FALSE. if the interactive user
CA                           has requested a contour which was not found.
CA If non-interactive, on entry ICON = which contour in the list in CONT
CA we have just tried to draw.
CA On exit C = the next contour to draw, if possible.
CA         ICON has been incremented.
CA         MORE = .TRUE. if C has been found, or .FALSE. if no more contours
CA                       are to be drawn.
C
CD If NCONT (in COMMON /CONTUR/) is zero, expects to read contour values
CD interactively.  If NCONT is non-zero, expects ICON to be a count within
CD a previously read list of contours, NCONT in total in the array CONT.
C
      LOGICAL MORE,SAYS
/CONTUR/
/IOUNIT/
C
C IF NCONT IS ZERO, INTERACTIVE WORKING:
      IF (NCONT .EQ. 0) GO TO 1
C
C NEXT C FROM LIST, UNLESS FINISHED:
C MAY BE SIMPLE LIST ITEM (ICONT=0) OR STEP (ICONT=-1):
      MORE = .FALSE.
      ICON=ICON+1
      IF (ICON .GT. NCONT) GO TO 100
      C=CONT(ICON)
      GO TO 101
C
C INTERACTIVE WORKING - IF MORE CAME IN FALSE, LAST ONE REQUESTED NOT FOUND:
   1  IF (MORE) GO TO 2
      WRITE (ITO,1001)
 1001 FORMAT (' Contour at',F12.2,' not found ')
      CALL ASK('type C to continue or X to exit')
      IF (.NOT. SAYS('X')) GO TO 2
      MORE = .FALSE.
      GO TO 100
C
   2  CALL ASK('Type contour value required')
      CALL RDREAL(C,1,IPT,80,IER)
 101  MORE = .TRUE.
 100  RETURN
      END
C
C
C
C
C LEVEL 1      FUNCTION NFIND(N,NTABLE,NBOUND)
      FUNCTION NFIND(N,NTABLE,NBOUND)
C
C *** NFIND by JCM 17 Apr 84 ***
C
CX
CC 11C
CH Searches for integer N in a table.
CA On entry N is the integer for which to search.
CA          NTABLE is an array of NBOUND integers.
CA          NBOUND is the number of entries in the table.
CD The function NFIND is set to zero if N is not in the table, or to
CD the number of the matching entry if one is found.
C
      DIMENSION NTABLE(NBOUND)
      DO 1 L=1,NBOUND
      IF (N .EQ. NTABLE(L)) GO TO 101
   1  CONTINUE
      L=0
 101  NFIND=L
      RETURN
      END
C
C
C
C
C LEVEL 1      FUNCTION NHCF(A, B)
      FUNCTION NHCF(A, B)
C
C *** NHCF added by PJB Nov 2016 ***
CX
CC9C
CH  returns Highest common factor of A and B
C
CN Returns zero if either A or B is zero
C
      IIA = IABS(NINT(A))
      IIB = IABS(NINT(B))
      IF (IIA*IIB.EQ.0) THEN
        NHCF=0
        GO TO 100
      ENDIF
    1 IF (IIB.NE.0) THEN
        ITEMP = IIA
        IIA = IIB
        IIB = MOD(ITEMP, IIB)
        GO TO 1
      ENDIF
      NHCF = IIA
  100 RETURN
      END
C
C
C
C
C LEVEL 3      FUNCTION NOPFIL(MODE)
      FUNCTION NOPFIL(MODE)
C
C *** NOPFIL udated by PJB C134 add MODE1=6  Nov 2016 ***
C
CX
CC 13C
CH Opens a file on a FORTRAN unit for the first time in this job.
C
CA On entry MODE defines the file-type and indicates how to obtain the file name
CA  MODE may have up to 5 digits:
CA      the least significant, MODE1, indicates the file-type
CA      the tens digit,        MODE2, shows how to obtain the file-name
CA      the hundreds digit,    MODE3, deals with default extensions
CA      the thousands digit,   MODE4, deals with formatted or unformatted files
CA      the most significant,  MODE5, deals with sequential or direct access,
CA                                    and odd special cases.
CA
CA  MODE1 = 1 for a read file
CA        = 2 for a write file status new
CA        = 3 for a write file status undefined (UNKNOWN)
CA        = 4 for a write file to be modified (APPEND for sequential files)
CA        = 5 for a scratch file.
CA        = 6 for a write file overwrite existing
CA
CA  MODE2 = 0 Give standard messages for read or write files; machine specific
CA            information like disc, extension and ppn may be included in
CA            the user's response.
CA        = 1 Message in MESSAG otherwise as 0
CA        = 2 Find file-name in MESSAG. Report file opened.
CA        = 3 as 2 but don't give file-opened message.
CA        = 4 as 0 but don't give file-opened message.
CA
CA  MODE3 = 0 Use default disc and ppn, default extension .DAT
CA        = 1 Use defaults for extension, disc, and ppn found in characters
CA            1-4, 5-10, and 11-30 respectively of NAMFIL. If disc or ppn
CA            are absent default as system.
CA        = 2 Use file-name exactly as given.
CA
CA  MODE4 = 0 for formatted files with no FORTRAN carriage controls
CA        = 1 for unformatted files
CA        = 2 for formatted files with FORTRAN carriage controls (line printer)
CA
CA  MODE5 = 0 for sequential file access
CA        = 1 for direct access files
CA        = 2 for the special case for GENIE of sequential, RECL=128, the VMS-
CA            specific "RECORDTYPE='FIXED'".  This will expect MODE4=1 for
CA            unformatted, and will take account of MODEs 1,2 and 3.
C
CD Opens file, if possible, according to instructions in MODE.
CD NOPFIL is set to the logical unit assigned.
CD NOPFIL=0 indicates that no data have been given in response to the
CD interactive request for a file name. This may be useful as a way
CD  of reading several files in sequence, with RETURN given as response when no
CD more are wanted.
C
CD If on exit NOPFIL=-1, an error has occurred from which recovery was not
CD possible.
CD
CD 15 units are provided by the system; the numbers by which they are known
CD to the Operating System are in the array LUNTAB.
CD The array IOTAB marks the units available; IOTAB=0 for available
CD units, IOTAB=MODE for units in use.
C
C
      DIMENSION LM(2)
      LOGICAL SAYS,BRUCE,SAID,THERE,ISOPEN
      CHARACTER *7 FILSTA(3)
      CHARACTER*10 FILACC(3)
      CHARACTER*12 FILFOR(2)
%      CHARACTER*%FNAM% DEXT
      CHARACTER*18 VFMT
      CHARACTER*40 SAVMES
      CHARACTER*26 MESS(2)
      CHARACTER*32 WFMT
      CHARACTER*80 FMT
/FINAME/
/IOUNIT/
/LOONEY/
/SCRACH/
/WHEN/
      DATA LM/13,14/
      DATA FILSTA/'OLD','NEW','UNKNOWN'/
      DATA FILACC/'SEQUENTIAL','DIRECT','APPEND'/
      DATA FILFOR/'FORMATTED','UNFORMATTED'/
      DATA MESS/'Give name of Input file  ',
     & 'Give name for Output file '/
C
C  CLEAR DEXT
      DEXT=' '
C  UNSCRAMBLE MODE
      M=MODE
      MODE5=M/10000
      M=M-MODE5*10000
      MODE4=M/1000
      M=M-MODE4*1000
      MODE3=M/100
      M=M-MODE3*100
      MODE2=M/10
      MODE1=M-MODE2*10
C
C  SET DEFAULTS FORMATTED, SEQUENTIAL, AND NEW FOR WRITE, OLD FOR READ
      IS=MODE1
      IA=1
      IF=1
C
C
C  SET FORMAT AND ACCESS
      IF (MODE1 .EQ. 4) THEN
C134 FOR APPEND SET IS = 1 INITIALLY
        IS=1
        IA=3
C 4.31 Allow to overwrite existing file without query
      ELSE IF (MODE1 .EQ. 6) THEN
        IS=2
      ENDIF
C
C ADJUST FORMATTED/UNFORMATTED
      IF (MODE4.EQ.1) IF=2
C ADJUST SEQUENTIAL/DIRECT FOR ACCESS
      IF (MODE5.EQ.1) IA=2
C IO SET FOR INPUT OR OUTPUT FILE MESSAGE
      IO=1
      IF (MODE1.GT.1) IO=2
C
C  NOW FIND A UNIT
%      DO 1 IU=1,%FILE%
      IF (IOTAB(IU).EQ.0) GO TO 2
    1 CONTINUE
      GO TO 51
    2 LUN=LUNTAB(IU)
      IF (MODE1 .EQ. 5) THEN
C
C  OPEN SCRATCH FILE
        IF (IA .EQ. 1) OPEN (UNIT=LUN,ACCESS=FILACC(IA),FORM
     &                  =FILFOR(IF),STATUS='SCRATCH')
C FOR NOW, IF DIRECT ACCESS, RECL=80 - THIS WILL NEED ATTENTION
        IF (IA .EQ. 2) OPEN (UNIT=LUN,ACCESS=FILACC(IA),FORM
     &                  =FILFOR(IF),STATUS='SCRATCH',RECL=80)
        GO TO 101
      ENDIF
C
C  OTHERWISE GET THE FILE-NAME
C  DEAL WITH EXTENSIONS
      IF (MODE3.EQ.0) DEXT='.DAT'
      IF (MODE3.EQ.1) DEXT=NAMFIL
      IF (MODE3.EQ.2) DEXT=' '
      IF (MODE2 .NE. 1) THEN
C PRESERVE FILE NAME IF IT CAME IN MESSAG
        IF (MODE2 .EQ. 2 .OR. MODE2 .EQ. 3) NAMFIL=MESSAG
C PUT ENOUGH OF STANDARD MESSAGE INTO MESSAG TO USE ALSO WHEN REPORTING
        MESSAG=MESS(IO)(LM(IO)+1:)
      ENDIF
C
%      LMES=LENG(MESSAG,%MESS%)+1
C AVOID SENDING MESSAGE IF NOT WANTED
      IF (MODE2 .EQ. 2 .OR. MODE2 .EQ. 3) GO TO 21
C  SEND MESSAGE:
        WRITE (VFMT,2000) LM(IO),LMES
CS-PICKY 2000 FORMAT ('(1X,A',I2,',A',I2,',1X,$)')
C
CS PICKY 2000 FORMAT ('(1X,A',I2,',A',I2,',1X)')
C
C JOIN HERE IF FIRST TRY FAILED, & IT MAY BE USEFUL TO TRY .CRY FOR .CCL:
    6   WRITE (ITO,VFMT) MESS(IO)(1:LM(IO)),MESSAG
CS UNIX           CALL FLUSH(ITO)
C SPECIAL BRUCE BLIP TO USE BOTH .CCL AND .CRY FILES WITHOUT KNOWING WHICH:
        BRUCE=.FALSE.
C
      READ (ITI,2001) NAMFIL
% 2001 FORMAT (A%FNAM%)
C
C  PROCESS FILE NAME
%   21 IF (LENG(NAMFIL,%FNAM%).EQ.0) GO TO 40
  89  CALL FILPRO(DEXT,IU,LNAM)
C  CHECK FOR ERROR IN FORM OF FILE-NAME
      IF (LNAM.EQ.0) GO TO 50
C SAVE MESSAGE IN SAVMES
      SAVMES=MESSAG(1:40)
C
C  OPEN FILE
   30 CONTINUE
C Check whether opening will cause an error
      INQUIRE(FILE=NAMFIL,EXIST=THERE,OPENED=ISOPEN)
CS UNIX      IF (THERE .AND. IS .EQ. 2) GO TO 53
      IF (.NOT. THERE) THEN
C134 SET NEW FOR ACCESSS APPEND
      IF (IA.EQ.3) IS=2
      IF (IS .EQ. 1) GO TO 52
      ENDIF
      IF (ISOPEN) GO TO 60
C
C IF GENIE FILE, VAX-SPECIFIC BECAUSE OF RECORDTYPE:
CS VMS      IF (MODE5 .EQ. 2) THEN
CS VMS      OPEN (UNIT=LUN,FILE=NAMFIL,ACCESS=FILACC(IA),FORM=FILFOR(IF),
CS VMS     &  STATUS=FILSTA(IS),ERR=52,IOSTAT=IOE,RECORDTYPE='FIXED',
CS VMS     &  RECL=128)
CS VMS      GO TO 22
CS VMS      ENDIF
C
CS VMS IF (MODE1.EQ.1) THEN
C MUST SPECIFY READONLY FOR READ FILES ON VAX TO AVOID PROTECTION FAILURES
C WHEN READING FROM FOREIGN DIRECTORIES
CS VMS      OPEN (UNIT=LUN,FILE=NAMFIL,ACCESS=FILACC(IA),FORM=FILFOR(IF),
CS VMS     & STATUS=FILSTA(IS),ERR=52,IOSTAT=IOE,READONLY)
CS VMS      ELSE
CS VMS      IF (MODE4 .EQ. 0) THEN
CS VMS      OPEN (UNIT=LUN,FILE=NAMFIL,ACCESS=FILACC(IA),FORM=FILFOR(IF),
CS VMS     & STATUS=FILSTA(IS),ERR=52,IOSTAT=IOE,
CS VMS     & CARRIAGECONTROL='LIST')
CS VMS     ELSE
      OPEN (UNIT=LUN,FILE=NAMFIL,ACCESS=FILACC(IA),FORM=FILFOR(IF),
     & STATUS=FILSTA(IS),ERR=52,IOSTAT=IOE)
CS VMS      ENDIF
CS VMS      ENDIF
      IF (MODE2 .EQ. 3 .OR. MODE2 .EQ. 4) GO TO 101
C
C  REPORT DONE
      IF (LMES.GT.40) LMES=40
      DO 31 J=1,LMES
      IF (SAVMES(J:J).NE.'(') GO TO 31
      IL=J-1
      GO TO 32
   31 CONTINUE
      IL=LMES
   32 WRITE (WFMT,2002) IL,LNAM
 2002 FORMAT ('(/1X,A',I2,',1X,A',I2,','' opened'')')
      WRITE (LPT,WFMT) SAVMES(1:IL),NAMFIL(1:LNAM)
      GO TO 101
C
C  NO RESPONSE - 'RETURN' TYPED
C DETECT SPECIALLY THE RESPONSE "RETURN" ON RVAX REQUEST FOR O/P FILE:
  40  IF (LUN .EQ. LPT .AND. MODE .EQ. 2142) THEN
        NAMFIL=MAIN//'.LIS'
        GO TO 89
      ENDIF
      NOPFIL=0
      GO TO 100
C
   51 CALL ERRMES(1,0,'*** ERROR No more logical units available')
C
C 'OPEN' ERROR - CHECK FIRST FOR BRUCE BLIP:
  52  IF (BRUCE .OR. MODE .NE. 111) GO TO 56
      IF (SAID(DEXT(2:4),'CRY')) THEN
        DEXT(2:4)='CCL'
        BRUCE=.TRUE.
      ELSE IF (SAID(DEXT(2:4),'CCL')) THEN
        DEXT(2:4)='CRY'
        BRUCE=.TRUE.
      ENDIF
      IF (.NOT. BRUCE) GO TO 56
      CALL UPONE(DEXT(2:4),3)
%      L1=LENG(NAMFIL,%FNAM%)
      NAMFIL(L1-2:L1)=DEXT(2:4)
      I=INDEX(FILNAM(IU),'.')
      FILNAM(IU)(I+1:I+3)=DEXT(2:4)
      GO TO 30
C
C IDENTIFY ERROR IN MACHINE DEPENDENT TABLE redundant?
C  152 IOS=IPOPE(IOE)
       GO TO (55,60,53,54,60) , IOS+1
C
C ERROR TYPE 1 - 'OLD' FILE FOUND NOT TO EXIST:
   56 WRITE (FMT,601) LNAM
 601  FORMAT ('('' File '',A',I2,','' does not exist'')')
  62  WRITE (LPT,FMT) NAMFIL(1:LNAM)
      WRITE (ITO,FMT) NAMFIL(1:LNAM)
CS UNIX
   50 IF (MODE2.LT.2 .OR. MODE2 .EQ. 4) GO TO 6
C NO WAY TO OFFER USER ANOTHER TRY:
      NOPFIL=-1
      GO TO 100
C
C ERROR TYPE 2 - 'NEW' FILE EXISTS ALREADY:
   53 IF (MODE1 .NE.6) THEN
        CALL ASK('Existing file '//NAMFIL(1:LNAM)//
     &  ' will be overwritten'//' OK? (Y/N) ')
        IF (.NOT. SAYS('Y')) GO TO 50
      ENDIF
C ALLOW TO TRY SAME FILE AGAIN WITH STATUS OLD
      IS=1
      GO TO 30
C
C ERROR TYPE 3 - BAD FILE NAME (COVERS VARIOUS SYNTACTICAL ERRORS):
   54 WRITE (FMT,603) LNAM
 603  FORMAT ('('' *** ERROR Bad file name '',A',I2,','' IOSTAT='',I4)')
      GO TO 61
C
C ERROR TYPE 4 - FILE ALREADY OPEN
  60  WRITE (FMT,604) LNAM
 604  FORMAT ('('' *** ERROR File '',A',I2,','' already open'')')
      GO TO 62
C
C ERROR TYPE 0 - OTHERS
   55 WRITE (FMT,600) LNAM
 600  FORMAT ('('' *** ERROR opening file '',A',I2,','' IOSTAT='',I4)')
  61  WRITE (ITO,FMT) NAMFIL,IOE
      WRITE (LPT,FMT) NAMFIL,IOE
      GO TO 50
C
C SUCCESSFUL EXIT
  101 NOPFIL=LUN
      IOTAB(IU)=MODE
  100 MESSAG=' '
      RETURN
      END
C
C
C
C
C LEVEL 2      FUNCTION NORDER(J)
      FUNCTION NORDER(J)
C
C *** NORDER by PJB/JCM 28 Jun 83 ***
C
CX
CC 1C
CH Returns the order of the Jth symmetry operator.
CA On entry J is the number of a symmetry operator.
CD The the absolute value of the function is set to the order of the
CD Jth symmetry operator, NORDER is negative if the rotation is an
CD improper one.
CP The symmetry operators must have been read by SYMOP, so that MULTAB is
CP filled in in /SYMTAB/ and SYM in /SYMDA/ holds the rotation matrices.
C
/SYMDA/
/SYMTAB/
C
      N=1
      I=J
    2 IF (I.EQ.1) GO TO 1
C KEEP LOOKING UP RESULT OF REPEATEDLY MULTIPLYING OPERATOR BY ITSELF
C IN THE MULTIPLICATION TABLE;  EVENTUALLY THIS WILL LEAD TO ELEMENT 1,
C THE IDENTITY OPERATOR, AND THE NUMBER OF REQUIRED MULTIPLICATIONS
C IS THE ORDER OF THE OPERATOR
      I=MULTAB(J,I)
      N=N+1
      GO TO 2
C
C N NOW THE ORDER; NEGATE IF INVERSION OPERATOR ALSO:
   1  IF (DETER3(SYM(1,1,J)) .LT. 0.) N=-N
      NORDER=N
      RETURN
      END
C
C
C
C
C LEVEL 3      SUBROUTINE NPACK(NPK,L,N,MODE,LPACK)
      SUBROUTINE NPACK(NPK,L,N,MODE,LPACK)
C
C *** NPACK updated by JCM 11 Jan 88 ***
C
CX
CC 16C
CH Deals with the packing and unpacking of up to 10 integers in/out of one
CH integer.
CA On entry MODE gives the required operation:
CA
CA   MODE=0: set up for subsequent entries.  The array L contains,
CA           for each item to be packed/unpacked, a number MAX(I).  If
CA           MAX(I) is positive, items in position I in the packing are
CA           expected to be in the range 0 to MAX(I).
CA
CA           if MAX(I) is negative, items in the I'th position in the packing
CA           are expected to be in the range MAX(I) to -MAX(I).
CA
CA           the array L is of dimension N; NPK is irrelevant.
CA           LPACK is a (10,3) array to be used as working space.
CA
CA   MODE=1: Pack an array of items given in L into the integer NPK, according
CA           to the information set up by a mode 0 entry.
CA
CA   MODE=2: Unpack into an array L the items previously packed into NPK.
C
      DIMENSION LPACK(10,3)
      DIMENSION L(N)
/IOUNIT/
/LENINT/
C
C
      IF (N .LE. 0) CALL ERRIN2(N,0,'misuse of NPACK - N=',' ')
C
      GO TO (21,22,23) , MODE+1
C
C SETTING UP:
  21  AM=1.
      DO 2 I=1,N
      LPACK(I,1)=L(I)
      IF (LPACK(I,1) .LT. 0) GO TO 10
C
C POSITIVE MAX VALUE:
      LPACK(I,2)=0
      LPACK(I,3)=LPACK(I,1)+1
      GO TO 13
C
C NEGATIVE 'MAX' VALUE:
  10  LPACK(I,2)=-LPACK(I,1)
      LPACK(I,3)=-(2*LPACK(I,1))+1
  13  AM=AM*FLOAT((IABS(LPACK(I,1))+LPACK(I,2)+1))
   2  CONTINUE
C
C TEST LARGEST POSSIBLE PACKED NUMBER WILL FIT IN MACHINE INTEGER, LESS SIGN
      IF (AM .LT. 2.**NBITS) GO TO 100
      WRITE (LPT,3002) AM,NBITS
      WRITE (ITO,3002) AM,NBITS
3002  FORMAT (/' ERROR ** LARGEST POSSIBLE PACKED NUMBER IS',
     & G14.7,' AND WILL NOT FIT INTO',I5,' BITS')
      GO TO 100
C
C MODE=1:  PACKING:
  22  NPK1=0
      DO 3 I=1,N
      LP=L(I)
      IF (LPACK(I,1) .LT. 0) LP=IABS(L(I))
      IF (0 .LE. LP .AND. LP .LE. IABS(LPACK(I,1))) GO TO 4
      WRITE (LPT,3003) L(I),LPACK(I,1)
      WRITE (ITO,3003) L(I),LPACK(I,1)
3003  FORMAT (/' ERROR ** ITEM',I8,' CANNOT BE PACKED USING',
     & ' MAX=',I8)
      GO TO 100
C
   4  NPK1=NPK1*LPACK(I,3)+L(I)+LPACK(I,2)
   3  CONTINUE
      NPK=NPK1
      GO TO 100
C
C MODE 2:  UNPACKING:
  23  NPK1=NPK
      DO 5 I=1,N
      J=N-I+1
      K=NPK1/LPACK(J,3)
      L(J)=NPK1-LPACK(J,3)*K-LPACK(J,2)
      NPK1=K
   5  CONTINUE
 100  RETURN
      END
C
C
C
C
C LEVEL 1      FUNCTION NSIGFG(DX)
      FUNCTION NSIGFG(DX)
C
C *** NSIGFG new by PJB 9 Mar 1994 ***
C
CX
CC 13C
CH Returns the number of figures to print after the decimal point based on the
CH ESD dx
CA On entry DX is n ESD
CD The value of the ESD DX is used to determine the number of figures to print
CD after the decimal point. NSIGFG is returned in the range 1-5. NSIGFG is used
CD for printing parameters, shifs and ESd's after a least squares cycle.
C
      DEL=ABS(DX)
      IFIG=1
    1 ISIG=IFIX(DEL)
      IF (ISIG.GT.0 .OR. IFIG .EQ.5) GO TO 2
      IFIG=IFIG+1
      DEL=10*DEL
      GO TO 1
  2   NSIGFG=IFIG
      RETURN
      END
C
C
C
C
C LEVEL 1      FUNCTION NSYMBL(I)
      FUNCTION NSYMBL(I)
C
C *** NSYMBL by JCM 11 Oct 83 ***
C
CX
CC 13C
CH Finds whether the character I is one of the symbols recognised by the system.
CA I is an A1 character
CD The function is set to zero if I is not one of the 21 characters held
CD in the table ISMBOL in COMMON /CHARS/, otherwise it is set to the number
CD of the matching symbol.
C
      CHARACTER *1 I
/CHARS/
C
      DO 1 J=1,21
      IF (I .EQ. ISMBOL(J)) GO TO 2
   1  CONTINUE
      J=0
   2  NSYMBL=J
      RETURN
      END
C
C
C
C
C LEVEL 1      FUNCTION NTICK(NTIME)
      FUNCTION NTICK(NTIME)
C
C *** NTICK by JCM 7 Jan 88 ***
C
CX
CC 16C
CH Advances its argument by 1 and sets the function to that value also.
CA NTIME on entry has some value, which on exit has been increased by 1
CD Used to keep track of the order of events in a job.
C
      NTIME=NTIME+1
      NTICK=NTIME
      RETURN
      END
C
C
C
C
C LEVEL 4      SUBROUTINE NUMA1(X,IFIELD,IFDIG,ITOT,IA)
      SUBROUTINE NUMA1(X,IFIELD,IFDIG,ITOT,IA)
C
C *** NUMA1 updated by JCM 12 Nov 89 ***
C
CX
CC 13C
CH Prepares a number for writing, probably on a plotter.
CA X is a floating point number to be decoded into characters
CA IA is a string variable of length at least IFIELD to receive the characters
CA IDIG is the number of digits to be given after the decimal point
CA      if IDIG is zero the decimal point is omitted.
CA The final number is right justified in a field of width ITOT
CA placed centrally in IFIELD.
CD If the number is too big to fit in IFIELD it is replaced by stars.
C
      CHARACTER *(*) IA
      DIMENSION ITEMP(5)
/CHARS/
/IOUNIT/
C
      IF=IFIELD
      IF (ITOT .GE. IF) GO TO 6
      WRITE (LPT,3001) ITOT,IF,X
      WRITE (ITO,3001) ITOT,IF,X
3001  FORMAT (/' ERROR ** IN USE OF NUMA1 - TOTAL FIELD OF',I5,
     & ' AND NUMBER FIELD OF',I5,' REQUESTED - PRINTING',F12.4)
      DO 1 I=1,ITOT
   1  IA(I:I)='*'
      GO TO 100
C
   6  IPT=IF+(ITOT-IF)/2
C IPT MOVES FROM RIGHT TO LEFT IN OUTPUT ARRAY IA
      IA=' '
      Y=ABS(X)
      IF (IFDIG) 2,2,3
C
C HERE IF THERE IS A FRACTIONAL PART
   3  CALL FRACT(Y,A,N)
      CALL INTDIG(JFIX(Y*10.**IFDIG),ITEMP,NDIG)
      L=NDIG
C COPY FRACTION BACKWARDS
      DO 4 K=1,IFDIG
      IF (ITEMP(L) .EQ. 0) ITEMP(L)=10
      IF (L .GT. 0) IA(IPT:IPT)=IDIGIT(ITEMP(L))
      IF (L .LE. 0) IA(IPT:IPT)=IDIGIT(10)
      IPT=IPT-1
      L=L-1
   4  CONTINUE
      IA(IPT:IPT)='.'
      IPT=IPT-1
      Y=A
C
C HERE TO DO INTEGER PART
   2  CALL INTDIG(JFIX(Y),ITEMP,NDIG)
      L=NDIG
      DO 7 K=1,NDIG
      IF (ITEMP(L) .EQ. 0) ITEMP(L)=10
      IA(IPT:IPT)=IDIGIT(ITEMP(L))
      IPT=IPT-1
      L=L-1
   7  CONTINUE
C
C SIGN
      IF (IFDIG .EQ. 0 .AND. JFIX(Y) .EQ. 0) GO TO 100
      IF (X .LT. 0.) IA(IPT:IPT)='-'
 100  RETURN
      END
C
C
C
C
C LEVEL 2      SUBROUTINE NUMDEN(X,N1,N2,KI,KO)
      SUBROUTINE NUMDEN(X,N1,N2,KI,KO)
C
C *** NUMDEN corrected for rounding error in X C4.13 Novemeber 2008 ***
C
CX
CC 13C
CH Converts a real number to the numerator and denominator of a fraction.
CA On entry X is a real number with absolute value normally less than 1
CA KI=0 If any range of fraction is allowed
CA  =1 If denominators of 2,3,4 and 6 only allowed
CA
CA On exit
CA KO=0 If X was 0 - in this case N1=N2=0
CA  =+1 If X was a +ve fraction < 1 . N1= numerator, N2=denominator
CA  =-1 If ABS(X) was as above but x was -ve.  N1, N2 set for ABS(X)
CA  =+2 If X WAS >1.  N1, N2 set for fractional part of X
CA  =-2 If X WAS < -1.  N1, N2 set for ABS(X)
CA  =99 If X would not convert to a fraction with single digit numerator
CA      and denominator, to 4 decimals
CA =-99 If X was as above and -ve
CN Used for printing fractions in OPSYM
C
      XX=X
      IEND=KI+9-4*KI
      N1=0
      N2=0
      KO=0
C4.13 ALLOW FOR FLOATING ROUNDING ERROR
      IF (ABS(XX) .LT. 0.0001) RETURN
C KEEP SIGN OF NUMBER IN NEG - THEN WORK WITH MODULUS:
      NEG=IFIX(SIGN(1.0,XX))
      XX=ABS(XX)
      NBIG=1
      IF (XX .LT. 1.) GO TO 1
C REDUCE TO FRACTION LESS THAN 1:
      CALL FRACT(XX,Y,J)
      NBIG=2
   1  DO 2 IDEN=2,IEND
C AVOID 5 IF ASKED TO CONSIDER ONLY 2,3,4,6:
      IF ((IEND .EQ. 6) .AND. IDEN .EQ. 5) GO TO 2
      ID1=IDEN-1
      DO 3 INUM=1,ID1
      IF (ABS((FLOAT(INUM)/FLOAT(IDEN))-XX) .LT. 0.0001) GO TO 4
      ITEMP=INUM/IDEN
      ATEMP=FLOAT(ITEMP)
      BTEMP=ATEMP-XX
      CTEMP=ABS(BTEMP)
   3  CONTINUE
   2  CONTINUE
C
C HERE NO FRACTION WILL FIT
      NBIG=99
      GO TO 5
   4  N1=INUM
      N2=IDEN
   5  KO=NBIG*NEG
      RETURN
      END
C
C
C
C
C LEVEL 1      FUNCTION NUMJGM(K,I,J)
      FUNCTION NUMJGM(K,I,J)
C
C *** NUMJGM new by PJB C137 April 2005 ***
C
CC 12C
CH Returns the number of non-zero elements in the IxJ integer matrix K
CA K is an I by J  matrix of integers
      DIMENSION K(I,J)
      N=0
      DO 1 JJ=1,J
      DO 1 II=1,I
      IF (K(II,JJ).NE.0) N=N+1
    1 CONTINUE
      NUMJGM=N
      RETURN
      END
C
C
C
C
C LEVEL 5      SUBROUTINE NWINDS
      SUBROUTINE NWINDS
C
C *** NWINDS updated by PJB 29-Sept-93  ***
C
CX
CC 7B
CH Outputs to unit NEWIN a new input dataset at the end of a refinement of
CH cell parameters and propagation vector from d spacing values.
CP The Crystal Data File must have been read by PREFIN
CD Deals with changed C, I or Q PROP cards.
CO Writes a new Crystal Data File to unit NEWIN in /NEWOLD/
C
/CARDRC/
/NEWOLD/
/SCRACH/
C
      ID=0
   1  ID=ID+1
      IF (ID .GT. NTOTAL(1)) GO TO 100
      READ (IO10,REC=ID,FMT=1000) ICARD
1000  FORMAT (A80)
      L=LETTER(ICARD(1:1))
      IF (L .EQ.3) GO TO 3
      IF (L.EQ.17) GO TO 4
      IF (L .NE. 9) GO TO 2
C
C OUTPUT NEW I CARD:
      CALL OTPUTI
      GO TO 1
C
C OUTPUT NEW C CARD WITH NEW VALUES:
   3  CALL CELNEW
      GO TO 1
C
C Q PROP CARD NEEDS TO BE REWRITTEN
   4  CALL PROPAG(4,NEWIN)
      GO TO 1
C
C COPY UNCHANGED CARD:
   2  WRITE (NEWIN,2000) (ICARD(I:I),I=1,LENGT(ICARD))
2000  FORMAT (80A1)
      GO TO 1
C
 100  RETURN
      END
C
C
C
C
C LEVEL 5      SUBROUTINE NWINFW
      SUBROUTINE NWINFW
C
C *** NWINFW updated by JCM 10 May 88 ***
C
CX
CC 7B
CH Writes out a new Crystal Data File for main program FWLSQ.
CP NWINFW should only be called in the context of FWLSQ, after one
CP cycle of refinement in which the refined parameters have been updated.
CP An old Crystal Data File should be held on the scratch unit number IO10.
C
CD Writes out new file, with new values on the L VALS card.
C
CO Outputs new file on unit NEWIN.
C
      CHARACTER *4 LTEMP
/CARDRC/
/FWVALS/
/NEWOLD/
/SCRACH/
C
C
      ID=0
   1  ID=ID+1
      IF (ID .GT. NTOTAL(1)) GO TO 100
      READ(IO10,REC=ID,FMT=1000) ICARD
1000  FORMAT (A80)
      L=LETTER(ICARD(1:1))
      IF (L .EQ.12) GO TO 3
      IF (L .NE. 9) GO TO 2
C
C OUTPUT NEW I CARD:
      CALL OTPUTI
      GO TO 1
C
C OUTPUT NEW "L" CARD
   3  CALL RDWORD(LTEMP,LEN,3,IPT,80,0,IER)
      IF (LTEMP .NE. 'VALS') GO TO 2
C NEW "L VALS" CARD:
      IF (NVALS .LT. 0) GO TO 1
      LVCARD=1
      IF (NVALS .GE. 7) LVCARD=2
      IV=0
      DO 12 I=1,LVCARD
      JEND=6
      IF (IV+6 .GT. NVALS) JEND=NVALS-IV
      WRITE (NEWIN,2000) (COEFFS(IV+J),J=1,6)
2000  FORMAT ('L VALS',6F12.5)
      IV=IV+6
  12  CONTINUE
      NVALS=-NVALS
      GO TO 1
C
C COPY UNCHANGED CARD:
   2  WRITE (NEWIN,2001) (ICARD(I:I),I=1,LENGT(ICARD))
2001  FORMAT (80A1)
      GO TO 1
C
 100  RETURN
      END
C
C
C
C
C LEVEL 8      SUBROUTINE NWINSF(MAGNEW)
      SUBROUTINE NWINSF(MAGNEW)
C
C *** NWINSF updated by PJB C4.6 April-2008 ***
C
CX
CC 7B
CH Outputs a replacement Crystal Data File after single crystal refinement.
CA On entry MAGNEW is the name of a routine which writes a new Q card,
CA if magnetic, or does nothing if not.  This is to avoid loading any of
CA the magnetic code in non-magnetic examples.
CP An old Crystal Data File should be held on the scratch unit number IO10.
CP A cycle of LSQ refinement involving structure parameters should have
CP been done.
CD In general, writes the same number of "cards" as were on the original
CD Crystal Data File.  If there was originally no L SCAL card, makes one.
CD The new cards have the latest values of the refined parameters.
CO Outputs on unit NEWIN the updated Crystal Data File.
C
      EXTERNAL MAGNEW
      LOGICAL MAGNEW
      CHARACTER *4 WORD, CHANGE(3)
/CARDRC/
/DEPMAT/
/IOUNIT/
/NEWOLD/
/REFINE/
/SCRACH/
      DATA CHANGE/'TFAC','SCAL','ATOM'/
C
      IF (SIMUL) GO TO 100
      CALL NEWCD
C SCAN CARDS ON SCRATCH, PRODUCING NEW ONES IF THEY MAY HAVE CHANGED:
      ID=0
   1  ID=ID+1
      IF (ID .GT. NTOTAL(1)) GO TO 101
      READ (IO10,REC=ID,FMT=1000) ICARD
1000  FORMAT(A80)
      L=LETTER(ICARD(1:1))
      IF (L .EQ. 12) GO TO 3
C TREAT A, F AND T ALIKE:
      IF (L .EQ. 1 .OR. L .EQ. 6 .OR. L .EQ. 20) GO TO 4
      IF (L .EQ. 5) GO TO 5
      IF (L .NE. 9) GO TO 2
C
C I CARD:
      CALL OTPUTI
      GO TO 1
C
C ANY FAMILY 2 PARAMETERS:
   4  CALL F2NEW(L)
      GO TO 1
C
C L CARD - THE OUTPUT OF THESE IS PROBLEM DEPENDENT:
   3  CALL RDWORD(WORD,LEN,3,IPT,80,0,IER)
C4.6 L changed to LL to avoid getting zero at label 2
      LL=NCFIND(WORD,CHANGE,3)
      IF (LL .LE. 0) GO TO 2
C
C CARD TO UPDATE:
      GO TO (11,12,13) , LL
C
C L TFAC:
  11  CALL LLTFAC(4)
      GO TO 1
C
C L SCAL:
  12  CALL LLSCAL(4)
      GO TO 1
C
C L ATOM:
  13  CALL GEOMCO(3)
      GO TO 1
C
C E CARD:
   5  CALL EXTINC(6,0.)
      GO TO 1
C
C TRY MAGNEW (IT MAY BE ANY LSQ PARAMETER FUNCTION)
   2  IF (MAGNEW(L,4)) GO TO 1
C
C OTHERWISE COPY CARD AS INPUT:
      WRITE (NEWIN,2000) (ICARD(I:I),I=1,LENGT(ICARD))
2000  FORMAT (80A1)
      GO TO 1
C
 101  IF (IPRNT(7) .EQ. 0) GO TO 100
C DEPOSITED MATERIAL SOURCE FILE:H,K,L,FOBS SIGMA FOBS, FCALC:
      MESSAG='Deposited Material'
      NAMFIL='.DEP'
      CALL OPNFIL(LDEP,112)
 100  RETURN
      END
C
C
C
C
C LEVEL 5      SUBROUTINE NWINT2
      SUBROUTINE NWINT2
C
C *** NWINT2 updated by JCM 10 May 88 ***
C
CX
CC 7B
CH Writes out a new Crystal Data File for main program T2LSQ.
CP Should only be called in the context of T2LSQ, after a cycle
CP of refinement in which its parameters have been adjusted.
CD Copies out the file with new values for cell parameters and an
CD L ZERO card.
C
CO Writes the new file to unit NEWIN.
C
      CHARACTER *4 WD
/CARDRC/
/NEWOLD/
/SCRACH/
/ZEROPT/
C
C
      ID=0
   1  ID=ID+1
      IF (ID .GT. NTOTAL(1)) GO TO 100
      READ (IO10,REC=ID,FMT=1000) ICARD
1000  FORMAT (A80)
      L=LETTER(ICARD(1:1))
      IF (L .EQ.3) GO TO 3
      IF (L .EQ. 12) GO TO 11
      IF (L .NE. 9) GO TO 2
C
C OUTPUT NEW I CARD:
      CALL OTPUTI
      GO TO 1
C
C OUTPUT NEW C CARD WITH NEW VALUES:
   3  CALL CELNEW
      GO TO 1
C
C L CARD - DISCOVER IF "ZERO"
  11  CALL RDWORD(WD,LEN,3,IPT,80,0,IER)
      IF (WD .NE. 'ZERO') GO TO 2
      WRITE (NEWIN,2005) ZERO
2005  FORMAT ('L ZERO',F10.4)
      GO TO 1
C
C COPY UNCHANGED CARD:
   2  WRITE (NEWIN,2000) (ICARD(I:I),I=1,LENGT(ICARD))
2000  FORMAT (80A1)
      GO TO 1
C
 100  RETURN
      END
C
C
C
C
C LEVEL 5      LOGICAL FUNCTION ONCARD(C,WORD,A)
      LOGICAL FUNCTION ONCARD(C,WORD,A)
C
C *** ONCARD corrected by JCM 6 Mar 89 ***
C
CX
CC 13C
CH Finds a card which starts with the given letter and word, and reads
CH one number from it.
C
CA On entry C is the first letter of card sought,
CA          WORD is the A4 word to be found anywhere on any card starting
CA               with the given letter C
CA On exit  A is a real number, set (if the word was found) to the number
CA               following WORD.
CD ONCARD is set .TRUE. if the word is found, otherwise .FALSE.
C
      CHARACTER *1 C
      CHARACTER *4 WORD,WD
/CARDRC/
/IINFO/
/IINFOW/
C
      ONCARD=.TRUE.
      IF (C .NE. 'I') GO TO 1
C I IS SPECIAL:
      IF (INREAD(9) .GT. 0) CALL INPUTI
      DO 2 I=1,IIN
      IF (WORD .EQ. IIREAD(I)) GO TO 3
   2  CONTINUE
      GO TO 101
C
   3  A=ACOEFF(I)
      GO TO 100
C
C OTHER THAN I:
   1  L=LETTER(C)
      ID = IABS(INREAD(L))
      NCARD=ICDNO(L)
      IF (NCARD .LE. 0) GO TO 101
      DO 4 I=1,NCARD
      CALL CARDIN(ID)
      ID=ID+NYZ
      IPT=3
C ALLOW ANYTHING TO BE A WORD - THIS MAY HIT AGAINST > 10 CHARS
   5  CALL RDWORD(WD,LEN,IPT,IPT,80,-42,IER)
      IF (WD .EQ.WORD) GO TO 6
      IF (IER .NE. 100 .AND. IPT .LE. 80) GO TO 5
   4  CONTINUE
      GO TO 101
C
C FOUND WORD - READ NUMBER:
   6  CALL RDREAL(A,IPT,IPT,80,IER)
      GO TO 100
C
 101  ONCARD=.FALSE.
 100  RETURN
      END
C
C
C
C
C LEVEL 3      SUBROUTINE OPMSYM
      SUBROUTINE OPMSYM
C
C *** OPMSYM Updated for INCN C4.26 March 2013 ***
C
CX
CC 1B
CH Prints out the magnetic symmetry operations.
CD The sequence numbers of the operators printed are
CD the same as those given by OPSYM
CO The relevant operator list is written to unit LPT.
CP DOMAG1 DOINC1 and DOMAG2 DOINC2
C
      CHARACTER *1 ISIG
      CHARACTER *2 LET(3)
      CHARACTER *1 TYPE(4)
      CHARACTER *120 BUFF
/IOUNIT/
/NSYM/
/SATELL/
/SYMMAG/
/SYMTAB/
      DATA LET/'Mx','My','Mz'/
      DATA TYPE/'K','M','N','P'/
C
C HEADING:
      CALL MESS(LPT,1,
     &'Magnetic symmetry operations (orthogonal axes) ')
      WRITE (LPT,2005) TYPE
 2005 FORMAT (' Types are:',10X,A1,' Other K-domain'/
     &21X,A1,' Magnetic symmetry operation'/
     &21X,A1,' Non-Symmetric operation, '/
     &21X,A1,' Product operation MxN')
C4.26 Addition
      IF (CPVEC) THEN
        WRITE (LPT,5003)
 5003 format(' NOp  Type    X',20X,'Y',20X,'Z',13x,'Partners',
     &2x,'Phase')
       ELSE
         WRITE (LPT,5002)
 5002 format (' NOp  Type    X',20X,'Y',20X,'Z')
      ENDIF
C
      NOPR=NOPC
      IF (CENTRC) NOPR=NOPC+1
      DO 1 NO = 1,NOPR
      IBUF=1
      DO 2 J=1,3
      DO 8 M=1,3
      CALL NUMDEN(OTRSYM(J,M,NO),N1,N2,0,KO)
      IF (KO .EQ. 0) GO TO 8
      IF (KO .LT. 0) THEN
        ISIG = '-'
      ELSE
        ISIG = '+'
        IF (IBUF .EQ. 21*(J-1)+1) ISIG=' '
      ENDIF
      IF (ABS(ABS(OTRSYM(J,M,NO))-1.0).LT. .001)  THEN
        WRITE (BUFF(IBUF:),502) ISIG,LET(M)
  502   FORMAT (A1,A2)
        IBUF = IBUF+3
      ELSE IF (IABS(KO).EQ.99) THEN
        WRITE (BUFF(IBUF:),500) ISIG,ABS(OTRSYM(J,M,NO)),LET(M)
  500   FORMAT (A1,F5.3,A2)
        IBUF = IBUF+8
      ELSE IF (N1 .GT.1) THEN
        WRITE (BUFF(IBUF:),501) ISIG,N1,LET(M),N2
  501   FORMAT (A1,I1,A2,'/',I1)
        IBUF=IBUF+6
      ELSE
         WRITE (BUFF(IBUF:),503) ISIG,LET(M),N2
  503   FORMAT (A1,A2,'/',I1)
        IBUF=IBUF+5
      ENDIF
    8 CONTINUE
      DO 4 K=IBUF+1,21*J
    4 BUFF(K:K) = ' '
      IBUF=21*J+1
    2 CONTINUE
C4.26 Write charaacter matrices and phases for INCM type
      if (CPVEC)  then
        ibuf=ibuf-7
        write (BUFF(IBUF:),504) ((sigmat(ii,jj,no),ii=1,2),jj=1,2),
     &degree(phik(no))
  504   format (2(2f5.1,2x),f8.2)
      endif
C
      if (NO.GT. NOPC ) go to 3
      IF (abs(KSTAB(NO)) .NE.1) THEN
        ISYM=1
      ELSE IF (IABS(MSTAB(NO)) .EQ.1) THEN
        ISYM=2
      ELSE IF (IABS(MSTAB(NO)) .EQ.NO) THEN
        ISYM=3
      ELSE
        ISYM=4
      ENDIF
      l=LENGT(BUFF)
      WRITE (LPT,2006)NO,TYPE(ISYM),(BUFF(I:I),I=1,L)
      go to 1
C141 MSTAB(NOPC+1) now holds info about the centre
    3 ISYM=2
      IF (MSTAB(NO) .LT. 0) ISYM=3
      IBUF=LENGT(BUFF)+1
        WRITE (LPT,2006) -1,TYPE(ISYM),(BUFF(I:I),I=1,LENGT(BUFF))
 2006  FORMAT (1X,I2,4X,A1,5X,120A1,2X)
    1 CONTINUE
      RETURN
      END
C
C
C
C
C LEVEL 4      SUBROUTINE OPNFIL(L,M)
      SUBROUTINE OPNFIL(L,M)
C
C *** OPNFIL updated by JCM 1 Aug 88 ***
C
CX
CC 13C
CH Opens file L according to requirements given in M;  L may be preset.
C
CA If on input L=-9999, behaves as L=NOPFIL(M)
CA If L >= 0, behaves similarly, but uses unit number L
CA Sets L=unit number used
CA For meanings of M, see NOPFIL
C
CO Opens unit (either L or chosen from table in IOTAB in /LOONEY)
CO Fills in tables in /LOONEY and /FINAME
C
      LOGICAL HASNAM,ISOPEN
      CHARACTER *40 FILTEM
/FINAME/
/IOUNIT/
/LOONEY/
C
      IF (L .NE. -9999) GO TO 1
      L=NOPFIL(M)
      GO TO 100
C
C REQUEST TO OPEN SPECIFIC UNIT NUMBER:
C
C L MUST BE IN TABLE SO THAT NOPFIL CAN FIND IT:
   1  LL=0
      K=0
%      DO 2 I=1,%FILE%
C SET LL TO POINT TO FOUND L:
      IF (LUNTAB(I) .EQ. L) LL=I
C SET K TO POINT TO FIRST VACANT SLOT:
      IF (IOTAB(I) .EQ. 0 .AND. K .EQ. 0) K=I
   2  CONTINUE
      IF (LL .EQ. 0) GO TO 3
C L WAS ALREADY THERE - MAKE IT THE NEXT FREE:
      ITM=LUNTAB(K)
      LUNTAB(K)=L
      IOTAB(K)=IOTAB(LL)
      LUNTAB(LL)=ITM
      IOTAB(LL)=0
      FILTEM=FILNAM(LL)
      FILNAM(LL)=FILNAM(K)
      FILNAM(K)=FILTEM(1:10)
      GO TO 4
C
C L NOT IN TABLE - CHECK SUITABILITY:
   3  IF (L .LT. 0 .OR. L .EQ. ITI .OR. L .EQ. ITO) CALL ERRIN2(
     &  L,0,'cannot open unit','in OPNFIL')
      LUNTAB(K)=L
   4  CONTINUE
CS LAX      INQUIRE (L,NAMED=HASNAM,NAME=FILTEM,OPENED=ISOPEN)
CS LAX      IOTAB(K)=0
CS LAX      IF (.NOT. ISOPEN) GO TO 7
CS LAX      IOTAB(K)=M
CS LAX      IF (HASNAM) FILNAM(K)=FILTEM(1:10)
      GO TO 100
C NOTE TO PRUNE FILTEM IF NECESSARY
   7  L1=NOPFIL(M)
      IF (L1 .EQ. L) GO TO 100
      WRITE (LPT,3001) L,L1
      WRITE (ITO,3001) L,L1
3001  FORMAT (/' *** PROGRAM ERROR ** OPNFIL CALL OF NOPFIL HAS',
     & ' RETURNED ',2I5)
      STOP
C
 100  RETURN
      END
C
C
C
C
C LEVEL 3      SUBROUTINE OPSYM(ISYM)
      SUBROUTINE OPSYM(ISYM)
C
C *** OPSYM by JCM 11 Apr 83 ***
C
CX
CC 1B
CH Prints out the symmetry operators in either real or reciprocal space.
CA If ISYM=1  Prints out the NLAT non-primitive lattice translations and
CA            the NOPC coordinates of general equivalent positions held in
CA            ALAT and SYM in COMMON /SYMDA/
CA If ISYM=2  The printing is required in reciprocal space, and equivalent
CA            reflection indices and their relative phases are printed.
CD The sequence numbers of the operators are printed.  These are useful
CD for referring to specific operators.
C
CO The relevant operator list is written to unit LPT.
C
      CHARACTER *1 ISIG
      CHARACTER *15 IPH
      CHARACTER *1 LET(3,2),IICHAR(3,9),INUM(3),IMID(3),IDEN(3)
/CHARS/
/FRIED/
/IOUNIT/
/NSYM/
%      COMMON /SCRAT/TSYM(3,3,%SY*2%),TTRANS(3,%SY*2%),
%     & MLTAB(%SY*2%,%SY*2%),TRANS1(3),TEMSYM(3,3)
/SYMDA/
/SYMTAB/
C
C SET UP X Y Z AND H K L IN ARRAY LET:
      DO 12 I=1,3
      LET(I,1)=LETLOW(I+23)
  12  LET(I,2)=LETLOW(I+9)
      LET(1,2)=LETLOW(8)
C
C SET + OR +-
      ISIG=ISPCE
      IF (CENTRC .OR. ((ISYM .EQ. 2) .AND. FRIEDL)) ISIG='-'
C
C HEADING FOR RECIPROCAL SPACE:
      IF (ISYM .EQ. 2) THEN
        WRITE (LPT,2000) ISIG
2000    FORMAT (/' Equivalent reflections are:  +',A1,20X,'with  ',
     &   'relative phases 2pi times:')
      ELSE
C
C HEADING FOR REAL SPACE:
        CALL MESS(LPT,1,'General equivalent positions are:')
        DO 13 I=1,NLAT
        DO 14 J=1,3
        INUM(J)=ISPCE
        IMID(J)=IDIGIT(10)
        IDEN(J)=ISPCE
C IN CASE IT IS ZERO
C
C NOW PREPARE PRINTING OF FRACTION IN LATTICE VECTOR
C SET 'CONSIDER ONLY DENOMINATORS OF 2,3,4,6'
        CALL NUMDEN(ALAT(J,I),NNUM,NDEN,1,IRR)
        IF (IRR .EQ. 0) GO TO 14
        IF (IRR .NE. 1) GO TO 15
C
        INUM(J)=IDIGIT(NNUM)
        IDEN(J)=IDIGIT(NDEN)
        IMID(J)='/'
  14    CONTINUE
        WRITE (LPT,2002) (INUM(J),IMID(J),IDEN(J),J=1,3),ISIG
2002    FORMAT (2X,2(4X,3A1,13X),4X,3A1,4X,'  +',A1)
        GO TO 13
C
C IN CASE ELEMENT OF LATTICE VECTOR NOT A FRACTION:
  15    WRITE (LPT,2003) (ALAT(J,I),J=1,3),ISIG
2003    FORMAT (2X,2(F10.4,10X),F10.4,4X,'  +',A1)
  13    CONTINUE
        WRITE (LPT,2004)
2004    FORMAT (1X)
C
      ENDIF
      DO 1 NO = 1,NOPC
C IP COUNTS ACROSS ARRAY OF CHARACTERS FOR PHASE, IF RECIPROCAL
      IP = 0
      IF (ISYM .EQ. 2) THEN
C
C IF RECIPROCAL SPACE, USE INVERSE MATRIX TRANSPOSED, AND THE NEGATED
C TRANSLATION VECTOR CORRESPONDING TO THAT MATRIX:
        DO 19 I=1,3
  19    TRANS1(I)=-TRANS(I,INVERS(NO))
        CALL GMEQ(SYM(1,1,INVERS(NO)),TEMSYM,3,3)
        CALL TRANSQ(TEMSYM,3)
      ELSE
C
C IF REAL SPACE , USE OPERATOR AS STORED:
        CALL GMEQ(TRANS(1,NO),TRANS1,1,3)
        CALL GMEQ(SYM(1,1,NO),TEMSYM,3,3)
      ENDIF
      DO 2 J=1,3
      L = 1
      CALL FRACT(TRANS1(J),ATEMP,ITEMP)
      IF (TRANS1(J) .GE. 0.00001) THEN
        DO 3 M=2,6
        X = FLOAT(M)*TRANS1(J) + 5.E-5
        IF (AMOD(X,1.) .GT. .0001) GO TO 3
        IQ = INT(X)
        IICHAR(J,1) = IDIGIT(IQ)
        IICHAR(J,2) = '/'
        IICHAR(J,3) = IDIGIT(M)
        L = 4
        GO TO 5
    3   CONTINUE
      ENDIF
C
    5 DO 8 M=1,3
      IF (TEMSYM(J,M) .EQ. 0) GO TO 8
      IF (TEMSYM(J,M) .LT. 0) THEN
        IICHAR(J,L) = '-'
      ELSE
        IICHAR(J,L) = '+'
         IF ((L .EQ. 1) .OR. ((ISYM .EQ. 2) .AND. (L .EQ. 4)))
     &    IICHAR(J,L)=ISPCE
      ENDIF
      IICHAR(J,L+1) = LET(M,ISYM)
      L = L+2
    8 CONTINUE
C
      IF (L .NE. 10) THEN
        DO 4 K=L,9
    4   IICHAR(J,K) = ISPCE
      ENDIF
      IF (ISYM .NE. 2) GO TO 2
      IF (MOD(L,2) .NE. 0) GO TO 2
      DO 30 IJ = 1,3
      IP = IP+1
      IPH(IP:IP) = IICHAR(J,IJ)
      DO 30 K = IJ,6,3
   30 IICHAR(J,K) = IICHAR(J,K+3)
      IP = IP+2
      IPH(IP-1:IP-1) = LET(J,2)
      IPH(IP:IP) = '+'
    2 CONTINUE
C
      IF (ISYM .EQ. 2) THEN
        IF (IP .LE. 0) THEN
          IPH(1:1) = IDIGIT(10)
          IP = 2
        ENDIF
        IPH(IP:15) = ' '
C
        WRITE (LPT,2006)NO,((IICHAR(J,K),K=1,6),J=1,3),IPH(1:14)
2006    FORMAT (1X,I2,3(5X,6A1,6X),10X,A14)
      ELSE
        WRITE (LPT,2005) NO,((IICHAR(J,K),K=1,9),J=1,3)
2005    FORMAT(1X,I2,3(5X,9A1,6X))
      ENDIF
    1 CONTINUE
      RETURN
      END
C
C
C
C
C LEVEL 4      SUBROUTINE ORTFUN(I,KMAX,VAL,MODE)
      SUBROUTINE ORTFUN(I,KMAX,VAL,MODE)
C
C *** ORTFUN corrected by PJB 2-Jan-96 ***
C
CX
CC 18A
CH Finds the best set of orthonormal functions compatible with symmetry
CH based on the users input, and hence defines the multipoles to refine.
CA On entry  KMAX = 2l+1, VAL the initial amplitude of function I
CA  MODE = 1 First function - set up
CA       > 1 Try function I
CA       = 0 No more functions - tidy up
C
      CHARACTER*4 NAME
/CARDRC/
/IOUNIT/
/MPODA/
/MPODAC/
      COMMON/SCRAT2/OROT(3,3,2),ISUB(24),MATP,ORMAT(169),
     & FUN(169),ORT(169),ANOR(13),USED(13),INDX(13),JNDX(13),DIJ(196)
      LOGICAL USED,FLAG
      COMPLEX DIJ
      SAVE JJ,NEW
C
      IF (MODE.EQ.0) GO TO 30
      IF (KMAX.EQ.1) THEN
        NEW=1
        JJ=1
        INDX(1)=1
        GO TO 99
      ENDIF
      II=KMAX*(I-1)
      IF (MODE.EQ.1) THEN
C  INITIALISE TABLES
        JJ=0
        DO 9 J=1,KMAX
        INDX(J)=0
        JNDX(J)=0
        USED(J)=(ABS(FUN(KMAX*(J-1)+J)).LT. 0.0001)
    9   CONTINUE
      ENDIF
        IF (ABS(FUN(KMAX*(I-1)+I)).LT. 0.0001)  THEN
        CALL NAMPOL(NAME,KMAX,I)
        CALL MESS(LPT,0,'Amplitude of '//NAME//' is zero from symmetry')
      ENDIF
      IF (USED(I)) THEN
      NEW=0
      GO TO 99
      ENDIF
      USED(I)=.TRUE.
      IF (MODE.EQ.1) THEN
        CALL GMEQ(FUN(II+1),ORT,KMAX,1)
        JJ=1
        INDX(1)=I
        JNDX(I)=1
        NEW=1
        GO TO 99
      ENDIF
C
C  ATTEMPT TO INSERT A GIVEN VECTOR
      AMIN=0.
      DO 10 J=1,JJ
      AMIN=AMIN+ORMAT(I+KMAX*(INDX(J)-1))**2
   10 CONTINUE
      IMIN=I
      GO TO 1
C
C  COMPLETE THE ORTHONORMAL SET
   30 IF (KMAX.EQ.1) THEN
        NCMAT=NCMAT+1
        CONMAT(NCMAT,1)=1.
        CONMAT(NCMAT,2)=1.
        NCLUMP=NCLUMP+1
        KCLUMP(NCLUMP)=1
        GO TO 100
      ENDIF
      JJIN=JJ
   31 IF (JJ.EQ.KMAX) GO TO 20
      FLAG=JJ.EQ.0
      AMIN=FLOAT(KMAX)
      DO 2 I=1,KMAX
      IF (USED(I)) GO TO 2
      FLAG=.TRUE.
      VAL=0.
      DO 3 J=1,JJ
      VAL=VAL+ORMAT(I+KMAX*(INDX(J)-1))**2
    3 CONTINUE
      IF (VAL.GT.AMIN) GO TO 2
      AMIN=VAL
      IMIN=I
    2 CONTINUE
      IF (.NOT. FLAG) GO TO 20
C
    1 ANORM=(1.-AMIN)
      IF (ANORM.LT.-.002) STOP 'Error in Normalisation'
      IF (ANORM.LE..0002) THEN
        ANORM=0.
        GO TO 20
      ENDIF
      INDX(JJ+1)=IMIN
      JNDX(IMIN)=(JJ+1)
      USED(IMIN)=.TRUE.
      ANORM=1./SQRT(ANORM)
C
      JJ1=KMAX*(JJ)
      IJJ1=KMAX*(INDX(JJ+1)-1)
      II=0
      DO 4 I=1,KMAX
      ORT(I+JJ1)=FUN(I+IJJ1)
      DO 5 J=1,JJ
      IJ=KMAX*(J-1)
      ORT(I+JJ1)=ORT(I+JJ1)-ORT(I+IJ)*ORMAT(INDX(J)+IJJ1)
    5 CONTINUE
      ORT(I+JJ1)=ORT(I+JJ1)*ANORM
    4 CONTINUE
      DO 6 I=1,KMAX
      CALL GMPRD(ORT(1+JJ1),FUN(1+II),ORMAT(I+IJJ1),1,KMAX,1)
      II=II+KMAX
    6 CONTINUE
      IF (IOUT.GT.160) THEN
        L=0
        WRITE (LPT,4001) (ORT(JJ1+I),I=1,KMAX)
        WRITE (LPT,3999)
4001    FORMAT (/' New function: '/13F9.4)
3999    FORMAT (/' New product matrix:')
        DO 600 I=1,KMAX
        WRITE (LPT,4002) JNDX(I),(ORMAT(L+J),J=1,KMAX)
4002    FORMAT (I4,13F9.4)
        L=L+KMAX
  600   CONTINUE
      ENDIF
C
      JJ=JJ+1
      IF (MODE.EQ.0) GO TO 31
      NEW=1
      GO TO 99
C
  20  IF (MODE.NE.0) THEN
        NEW=0
        GO TO 99
      ENDIF
      NEW=JJ-JJIN
      IF (IOUT.GT.120) THEN
        CALL MESS(LPT,1,'Orthonormal representation:')
        L=0
        DO 12 J=1,JJ
        WRITE (LPT,4004) INDX(J),(ORT(L+I),I=1,KMAX)
4004    FORMAT (1X,I5,12F8.4)
        L=L+KMAX
   12   CONTINUE
      ENDIF
C  CHECK THAT CONMAT WILL NOT OVERFLOW
      IF (NCMAT+JJ*JJ .GT.600) THEN
        CALL ERRMES(1,1,
     &  'Multipole matrix will overflow - increase dimension of CONMAT')
        GO TO 100
      ENDIF
      JK=JJ
      DO 21 I=1,KMAX
      IF (JNDX(I).NE.0) GO TO 21
      JK=JK+1
      INDX(JK)=I
   21 CONTINUE
C
C  DERIVE MATRICES RELATING PARAMETERS TO ACTUAL MULTIPOLES
      DO 40 I=1,JJ
      L=I
      II=KMAX*(INDX(I)-1)
      DO 41 J=1,JJ
      CONMAT(NCMAT+L,1)=FUN(INDX(J)+II)*ANOR(INDX(I))
      L=L+JJ
   41 CONTINUE
   40 CONTINUE
      CALL GMINV(CONMAT(NCMAT+1,1),CONMAT(NCMAT+1,2),JJ)
      IF (IOUT.GT.50) THEN
        WRITE (LPT,4010) (INDX(I),I=1,JJ)
 4010   FORMAT (' Inverse of Amount matrix:'/6X,12(I5,3X))
        L=0
        DO 42 I=1,JJ
        WRITE (LPT,4004) INDX(I),(CONMAT(NCMAT+L+J,1),J=1,JJ)
        L=L+JJ
   42   CONTINUE
        WRITE (LPT,4011) (INDX(I),I=1,JJ)
 4011   FORMAT (' Amount matrix:'/6X,12(I5,3X))
        L=0
        DO 44 I=1,JJ
        WRITE (LPT,4004) INDX(I),(CONMAT(NCMAT+L+J,2),J=1,JJ)
        L=L+JJ
   44   CONTINUE
      ENDIF
      NCMAT=NCMAT+JJ*JJ
      VAL=0.
C
   99 II=JJ-NEW
      DO 98 J=1,NEW
%      CALL ERRCHK(2,NMPOL,%MPOL%,0,'multipoles')
      POLAMP(NMPOL,1)=VAL
      CALL NAMPOL(MPNAM(NMPOL),KMAX,INDX(II+J))
   98 CONTINUE
      IF (MODE.NE.0) GO TO 100
      LVAL=KMAX/2
      ISTART=NMPOL-JJ+1
C
C RECORD NEW CHUNK:
%      CALL ERRCHK(2,NCLUMP,%MBLK%,0,
     &  'blocks of l values for multipoles')
      KCLUMP(NCLUMP)=JJ
      IF (JJ.NE.1) THEN
        WRITE (LPT,2001) JJ,LVAL,(MPNAM(J),J=ISTART,NMPOL)
      ELSE
        WRITE (LPT,2002) LVAL,(MPNAM(J),J=ISTART,NMPOL)
      ENDIF
 2001 FORMAT (' There are',I2,' independent functions for l =',I2/
     & ' They are obtained from:', 13(2X,A4))
 2002 FORMAT (' There is one independent function for l =',I2/
     & ' It is obtained from:', 13(2X,A4))
  100 RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE ORTHG(IOP)
      SUBROUTINE ORTHG(IOP)
C
C *** ORTHG updated by JCM 11 Aug 88 ***
C
CX
CC 1A
CH Calculates matrices for the transformation of vectors in real or reciprocal
CH space, between crystallographic and orthogonal axes.
CA On entry IOP=1 means do not print result; =2 means print
CD The orthogonal set are defined as follows:
CD    X is parallel to a*
CD    Z is parallel to c
CD    Y makes up a right handed set.
CD
CD Thus H(orth) = h(cryst) times matrix ORTH.
CD H is is real space for matrix ORTH(,,1), and reciprocal for (,,2)
C
/CELPAR/
/IOUNIT/
C
      DO 5 M=1,2
      DO 3 I = 1,3
      DO 3 J = 1,3
    3 ORTH(I,J,M) = 0.
      N=3-M
      J=5-2*M
      K=2*M-1
      ORTH(J,J,M) = CELL(J,1,M)
      ORTH(2,J,M) = CELL(K,2,M)*CELL(2,1,M)
      ORTH(2,2,M) = CELL(K,3,M)*CELL(2,1,M)
      ORTH(K,J,M) = CELL(2,2,M)*CELL(K,1,M)
      ORTH(K,2,M) = -(CELL(2,3,M)*CELL(J,2,N)*CELL(K,1,M))
      ORTH(K,K,M) = CELL(2,3,M)*CELL(J,3,N)*CELL(K,1,M)
   5  CONTINUE
      IF (IOP .EQ. 2) WRITE (LPT,2000) ORTH
2000  FORMAT (/' Matrices for transformation of vectors to',
     & ' orthogonal axes'/' Real space:'/3(3F10.4/),
     & /' Reciprocal space:'/3(3F10.4/))
      RETURN
      END
C
C
C
C
C LEVEL 2      SUBROUTINE ORTHO(H,OH,IR)
      SUBROUTINE ORTHO(H,OH,IR)
C
C *** ORTHO corrected by PJB 25 Jun 86 ***
C
CX
CC 1B
CH Carries out conversions between crystallographic and orthogonal axes.
CA H(3) is the input vector
CA OH(3) is the transformed vector
CA IR indicates which conversion is required:
CD If IR=1  H is a real space vector on crystallographic axes and OH a vector
CD          on the standard orthogonal axes
CD    IR=2  H is a reciprocal vector on crystallographic axes and OH is on
CD          the orthogonal axes
CD    IR=-1 H is on orthogonal axes and OH on real crystallographic axes
CD    IR=-2 H is on orthogonal axes and OH on reciprocal crystallographic axes
CP RECIP should have read the cell  dimensions.
CN The standard orthogonal axes are defined with x parallel to (100)
CN z parallel to [001] and y making up a righ-handed orthogonal set.
CN The matrices used in the conversions are those printed out by RECIP
C
      DIMENSION H(3),OH(3)
/CELPAR/
C
      IF (IR .GT. 0) CALL GMPRD(H,ORTH(1,1,IR),OH,1,3,3)
      IF (IR .LT. 0) CALL GMPRD(ORTH(1,1,3+IR),H,OH,3,3,1)
      RETURN
      END
C
C
C
C
C LEVEL 4      SUBROUTINE OTPUTI
      SUBROUTINE OTPUTI
C
C *** OTPUTI updated by JCM 14 Jul 86 ***
C
CX
CC 6B
CH Outputs a new I card after a LSQ refinement, updating the cycle number.
CO Writes the new card to unit NEWIN.
C
      CHARACTER *80 ITEMP
      CHARACTER *4 WORD
      DIMENSION IDIG(5)
/IINFOW/
/NEWOLD/
/REFINE/
/SCRACH/
C
%      DO 1 I=1,%ICRD%
      IF (IIREAD(I) .EQ. 'CYC1') GO TO 2
   1  CONTINUE
      GO TO 8
C
C CYC1 READ:
C REPLACE BY CURRENTLY REQUIRED CYC1
   2  IPT1=2
C SCAN CARD, AS IT MAY NOT BE THIS ONE THAT CYC1 IS ON:
    5  CALL RDWORD(WORD,NTEMP,IPT1,IPT,80,0,IER)
      IF (IER .EQ. 100) GO TO 8
C IGNORE NUMBER:
      CALL RDREAL(A,IPT,IPT1,80,IER)
      IF (WORD .NE. 'CYC1') GO TO 5
C
C FOUND CYC1:
      ITEMP(1:IPT-1)=ICARD(1:IPT-1)
      CALL INTDIG(LASTCY+1,IDIG,NDIG)
      IF (NDIG .LT. IPT1-IPT) GO TO 7
C NUMBER HAS MORE DIGITS - CHECK CARD END - IF CARD HAPPENS TO BE FULL WE
C COULD USE ANOTHER CARD, OR SHUFFLE ALONG LOOKING FOR 2 SPACES, BUT WE SHALL
C WAIT UNTIL THIS HAPPENS:
      IF (ICARD(80:80) .EQ. ' ') GO TO 7
      CALL ERRMES(-1,0,'new I card cannot be written')
      GO TO 100
C
   7  CALL INTCHR(IDIG,NDIG,ITEMP(IPT:IPT),80-IPT,0)
      ITEMP(IPT+NDIG+1:80)=ICARD(IPT1:IPT1+IPT+NDIG+1)
      ICARD=ITEMP
   8  WRITE (NEWIN,2000) (ICARD(I:I),I=1,LENGT(ICARD))
2000  FORMAT (80A1)
 100  RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE PARITY(N,M,EVEN)
      SUBROUTINE PARITY(N,M,EVEN)
C
C *** PARITY by JCM 26 Sep 85
C
CX
CC 11C
CH Finds out whether N is odd or even.
CA On entry N is the integer to be tested
CA On exit  EVEN is true if N is even, false if N is odd
CA          If N is even M=N/2; if odd M=(N-1)/2
C
      LOGICAL EVEN
C
      M1=N/2
      M2=(N-1)/2
      EVEN=(M1 .NE. M2)
      IF (N .LE. 0) EVEN = .NOT. EVEN
      M=M2
      IF (EVEN) M=M1
      RETURN
      END
C
C
C
C
C LEVEL 6      SUBROUTINE PARNAM(IPNAM1,IPNAM2,N,M)
      SUBROUTINE PARNAM(IPNAM1,IPNAM2,N,M)
C
C *** PARNAM updated by JCM 8 May 90 ***
C
CX
CC 6C
CH Obtains the printing name of a LSQ parameter.
CA On entry N specifies what the integer M is:
CA      N=1 means M is the number of a basic variable
CA      N=2 means M is the number of a variable
CA      N=3 means M is a packed parameter specification
CA On exit IPNAM1 contains the A4 genus name,
CA         IPNAM2 contains the A4 species name
CP LSETUP must have put the vocabulary into /WORDS/ etc
CP VARMAK must have set up varible structure and pointers
CD On exit KPHASE in /PHASE/ and KSOURC in /SOURCE/ have been given the
CD current values of the phase and source.
CD From family, genus and species, decides source of genus and species names
CD A large, +ve value for the species type indicates only 1 name, not 2
CD Picks up names via PRIWRD
C
      CHARACTER *4 IPNAM1,IPNAM2
      LOGICAL ONENAM
      DIMENSION LPAK(5)
/ATNAM/
/GLOBAL/
/IOUNIT/
/MPODA/
/MPODAC/
/PHASE/
/POINTS/
/PRBLEM/
/SOURCE/
C
      MM=M
      IPNAM1=' '
      IPNAM2=' '
      GO TO (1,2,3) ,N
C
C N=1 - M SPECIFIES BASIC VARIABLE - WHICH VARIABLE WAS IT?
   1  MM=LBSVR(MM)
C
C N=2 - M SPECIFIES VARIABLE - WHICH PARAMETER WAS IT?
   2  MM=LVRPR(MM)
C
C N=3 - M IS A PACKED PARAMETER - UNPACK IT:
   3  CALL KUNPAK(MM,IFAM,IGEN,ISPC,KPHASE,KSOURC)
C THIS MENDS NON-MULTI, BUR MAY NEED ADJUSTING FOR MULTI:
      IF (KPHASE .EQ. 0) KPHASE=1
      IF (KSOURC .EQ. 0) KSOURC=1
      ONENAM=(IGEN .EQ. 1 .AND. (IFAM .EQ. 1 .OR. IFAM .EQ. 6))
C
C BRANCH ON FAMILY:
      GO TO (11,12,13,14,15,16) , IFAM
C4.7 Extra diagnostic message
      CALL ERRIN2(IFAM,0,'PARNAM asked for name in family',
     &' Trying to relate non-existent parameters? ')
C
C FAMILY 3 - SET ISP TO BE ITS SPECIES TYPE:
  13  ISP=LF3SP(IGEN,KPHASE,KSOURC)
      GO TO 30
C
C FAMILY 4 - "VERY LONG VECTORS" - SET SPECIES TYPE:
  14  ISP=-NSPCPS(4,KPHASE)
      GO TO 30
C
C FAMILY 1 - SET ISP TO BE ITS SPECIES TYPE:
  11  ISP=LF1SP(IGEN)
      GO TO 30
C
C FAMILY 6 - SET ISP TO BE SPECIES TYPE:
  16  ISP=LF6SP(IGEN,KSOURC)
C
C
C COPY GENUS NAME:
  30  IF (ONENAM) THEN
        IPNAM1=' '
        GO TO 23
      ELSE
        CALL PRIWRD(IFAM,IGEN,0,IPNAM1,1)
      ENDIF
      IF (IPNAM1 .EQ. 'XXXX') GO TO 22
C
C PICK UP SPECIES NAME BY CONSULTING, FIRST, TO SEE WHAT SORT OF SPECIES.
C POSSIBILITIES FOR ISP ARE:
C    -VE MEANS SPECIES ARE POSITIVE INTEGERS, 1, 2 ETC, UP TO IABS(ISP)
C     0 MEANS THERE ARE IN FACT NO SPECIES
C    +VE MEANS THAT EACH SPECIES HAS A NAME (LIKE TFAC, ASYM, PROR  . . ,
C   OR X, Y, Z, B11 . . . OR A*, B*, . . .) TOBE FOUND IN THE GENERAL WORD TABLE
      IF (ISP) 21,22,23
C
C IF 0, COMPLAIN.
  22  WRITE (LPT,3001)M,N,IFAM,IGEN,ISPC
      WRITE (ITO,3001)M,N,IFAM,IGEN,ISPC
3001   FORMAT (/' ERROR ** PARNAM CANNOT FIND NAME - M,N,IFAM,',
     & 'IGEN,ISPC =',5I6)
      STOP
C
C IF +VE, NAME ALREADY PACKED IN MM FOR LOOK-UP IN PRIWRD:
  23  CALL PRIWRD(IFAM,IGEN,ISPC,IPNAM2,0)
C MAY NOT ALL BE PRESENT - TRY JUST SPECIES NAME IF NOT FOUND:
      IF (IPNAM2 .NE. 'XXXX') GO TO 100
      CALL PRIWRD(IFAM,0,ISPC,IPNAM2,0)
      IF (IPNAM2 .EQ. 'XXXX') GO TO 22
      GO TO 100
C
C IF -VE WANT TO TURN ISPC INTO DIGITS:
  21  CALL INTDIG(ISPC,LPAK,NDIG)
      CALL INTCHR(LPAK,NDIG,IPNAM2,4,0)
      GO TO 100
C
C FAMILY 2 IS SPECIAL BECAUSE ITS GENUS NAMES ARE ATOM NAMES:
  12  IF (MULFAS) THEN
        IPNAM1=ATNA(IGEN,KPHASE)
      ELSE
        IPNAM1=ATNAME(IGEN)
      ENDIF
C    AS IN FAMILY 1, FOR THE SPECIES WE HAVE POINTERS INTO /WORDS/.
      CALL PRIWRD(IFAM,0,ISPC,IPNAM2,0)
      GO TO 100
C
C FAMILY 5 - EXPECT 1 LONG GENUS AT FIRST:
  15  CALL MF5ADD(ISPC,IG,IS,-1)
C GENUS NAME IS ATOM NAME : IG AT PRESENT IS MULTIPOLE ATOM NAME:
      IF (MULFAS) THEN
        IPNAM1=ATNA(MPATAB(IG),KPHASE)
      ELSE
        IPNAM1=ATNAME(MPATAB(IG))
      ENDIF
C SPECIES NAME COMES FROM TABLE:
      IPNAM2=MPNAM(ISPC)
 100  RETURN
      END
C
C
C
C
C LEVEL 6      SUBROUTINE PARRD(IPT1,IPT2,K,IFAM,IGEN,ISPC)
      SUBROUTINE PARRD(IPT1,IPT2,K,IFAM,IGEN,ISPC)
C
C *** PARRD updated by PJB April 2008  ***
C
CX
CC 6C
CH Reads a LSQ parameter specification from a given card at given point.
CA On entry IPT1 points to the starting character on the card in /SCRACH/
CA On exit  IPT2 points to the next unread character on the card in /SCRACH/
CA          K is the packed parameter unless K is -ve:
CA K=-99 'ONLY' read
CA K=-100 'ALL' read as first word, in which case IFAM is expected to
CA        be set, and possibly one but not both of ISPC and IGEN
CA K=-100 and IFAM -ve means that the word after 'ALL' was composite
CA        Composite words have come from MAIN program table with -ve small
CA        entries.  For SFLSQ and the like,
CA        IFAM=-1 'ALL XYZ'
CA        IFAM=-2 'ALL BIJ'
CA        IFAM=-3 'ALL XYZT'
CA        IFAM=-4 'ALL CELL'
CA        IFAM=-5 'ALL XYZB'
CA        IFAM=-6 'ALL XYZS'
C
CA K=-101  'XYZ' as 2nd word;  1st word was genus in IGEN
CA K=-102  'BIJ' as 2nd word;  1st word was genus in IGEN
CA K=-103  'XYZT' as 2nd word;  1st word was genus in IGEN
CA K=-104  'CELL' as 2nd word;  1st word was genus in IGEN
CA K=-105  'XYZB' as 2nd word;  1st word was genus in IGEN
CA K=-106  'XYZS' as 2nd word;  1st word was genus in IGEN
C
CP The tables used must be set up by LSETUP
C
CD PARRD expects only a limited vocabulary, identified via TBLFND, being
CD    a known genus followed by a species name
CD    'ONLY'
CD    'ALL' followed by anything making sense
CD    a genus name followed by a composite word like 'XYZ', 'BIJ', 'XYZT' 'XYZB'
CD    a species name alone, in the special case of family 1 or 6, genus 1
CD    (and for PR, if SCAL is read, ignores a 1 if it follows) -
CD    wherever it makes sense.
C
      CHARACTER *4  LWD1,LWD2
/MPODA/
/MPODAC/
/PHASE/
/REFINE/
/SOURCE/
/WDSPC/
/WORDS/
C
C IN CASE MULTI, SET SOURCE AND PHASE AS DEFAULT:
      KPHASE=JPHASE
      KSOURC=JSOURC
C
C IDENTIFY FIRST NAME - READ AND OFFER TO TBLFND:
      K=0
      IFAM=0
      IGEN=0
      ISPC=0
C THIS CALL MAY FLIP KSOURC OR KPHASE:
      CALL RDWORD(LWD1,L1,IPT1,IPT,80,1,IER)
C IF EMPTY WORD, END OF LINE:
      IF (IER .EQ. 100) GO TO 100
C
C
C FIND WORD IF POSSIBLE:
      CALL TBLFND(LWD1,K,IFAM1,IGEN1,ISPC1,KP,KS)
C RECORD ANY PHASE OR SOURCE INFORMATION GLEANED BY TBLFND:
      IF (KP .NE. 0) KPHASE=KP
C C106      IF (KS .NE. 0) KSOURC=KS
C IF K IS ZERO, TBLFND COULD NOT RECOGNISE AT ALL:
      IF (K .EQ. 0) GO TO 99
C
C IF TBLFND FOUND WORD, IT HAS A PARALLEL TABLE OF INTEGERS SAYING WHAT THE
C WORDS ARE.  NEGATIVE K INDICATES A NON-PARAMETER WORD (LIKE ALL, ONLY
C - THESE TWO ARE THE ONLY ONES ALLOWED AS FIRST WORD)
C
C IF K +VE, TBLFND HAS FOUND EITHER A GENUS OR A SPECIES NAME.  IF SPECIES,
C SHOULD BELONG TO FAMILY 1 GENUS 1, AND TBLFND SHOULD HAVE DETECTED THIS
C AND SET GENUS AND FAMILY.
C
C SO ACCEPTABLE FIRST WORDS ARE:
C     A SPECIES NAME (IMPLICITLY FOR FAMILY1, GENUS 1 - READ NO MORE)
C     A GENUS NAME (SETTING IFAM & IGEN, EXPECTS TO READ SPECIES, OR BIJ OR
C                   XYZ ETC. NEXT)
C     'ALL' (EXPECTS ANOTHER WORD)
C     'ONLY' ( READ NO MORE)
C
C 'ONLY'
      IF (K .EQ. -99) GO TO 101
C
C SPECIES NAME - SPECIFICATION COMPLETE IF FAM=1 OR 6, GEN=1:
      IF ((IFAM1 .EQ. 1 .OR. IFAM1 .EQ. 6) .AND. IGEN1 .EQ. 1
     &   .AND. ISPC1 .NE. 0) THEN
        IFAM=IFAM1
        IGEN=IGEN1
        ISPC=ISPC1
C IF SCAL IGNORE ANY SUBSEQUENT 1:
        IF (IFAM .EQ. 6) THEN
          CALL RDINTG(I,IPT,IPT2,80,IER)
          IF (I .EQ. 1) IPT=IPT2
        ENDIF
        GO TO 102
      ENDIF
C
C CHECK ENOUGH INFO TO PROCEED WITH SECOND WORD:
      IF (K .LT. -102) GO TO 99
      IF ((IFAM1.EQ.0 .OR. IGEN1.EQ.0) .AND. (K .GT. 0)) GO TO 99
C
C NOW WE LOOK AT SECOND WORD AND CHECK COMPATIBLE WITH FIRST (-1 ON INPUT
C ALLOWS AN INTEGER TO BE READ AS A WORD):
      CALL RDWORD(LWD2,L2,IPT,IPT,80,-1,IER)
      IF (IER .EQ. 100) GO TO 99
      CALL TBLFND(LWD2,IANS2,IFAM2,IGEN2,ISPC2,KP,KS)
      IF (KP .NE. 0) KPHASE=KP
C 106      IF (KS .NE. 0) KSOURC=KS
C WORDS ALLOWED IN SECOND PLACE ARE:
C      A SPECIES NAME FITTING THE FIRST GENUS NAME
C      A COMPOSITE WORD FOLLOWING 'ALL' OR A GENUS NAME - THE COMPOSITE WORDS
C                  ARE 'BIJ', 'XYZ' OR 'XYZT' ETC. FOR SFLSQ
C      SOMETHING ELSE FOLLOWING 'ALL' - THIS MAY BE A FAMILY NAME,
C                  A GENUS NAME OR A SPECIES NAME
C
C ALL COMPOSITE WORDS ARE ALLOWED EXCEPT 'ALL' AND 'ONLY':
      IF (IANS2 .EQ. -100 .OR. IANS2 .EQ. -99 ) GO TO 99
C
C IF TBLFND COULD NOT FIND IT, IT MAY BELONG TO A USER'S TABLE IN FAMILY 5:
      IF (IANS2 .EQ. 0) THEN
C BUT ONLY IF MULTIPOLE:
        IF (.NOT. MPL) GO TO 99
        IF (IFAM1 .NE. 2) GO TO 99
        IFAM1=5
        IG=MPNMTB(IGEN1)
        IGEN1=1
        ISPC2=NCFIND(LWD2,MPNAM(MPTAB(IG)),MPTAB(IG+1)-MPTAB(IG))
        IF (ISPC2 .EQ. 0) GO TO 99
C COUNT FROM BEGINNING OF TABLE:
        ISPC2=ISPC2+MPTAB(IG)-1
        GO TO 5
      ENDIF
C
C IF FIRST WORD IS 'ALL':
      IF (K .EQ. -100) THEN
        IF (IANS2 .LT. 0) GO TO 4
C
C 'ALL' FOLLOWED BY GENUS OR SPECIES:
        IFAM=IFAM2
        IGEN=IGEN2
        ISPC=ISPC2
        GO TO 101
C
C BOTH WORDS ARE COMPOSITE (EG 'ALL BIJ', 'ALL XYZ')
   4    IFAM=IANS2
        GO TO 101
      ENDIF
C
C FIRST IS NOT 'ALL', SO SHOULD HAVE BEEN GENUS:
      IF (IANS2 .GT. 0) GO TO 5
C GENUS FOLLOWED BY 'XYZ' OR 'BIJ' OR 'XYZT'
      K=IANS2-100
      IFAM=IFAM1
      IGEN=IGEN1
      ISPC=ISPC1
      GO TO 101
C
C CANNOT MAKE SENSE OF PARAMETER SPEC:
  99  CALL ERRIN2(IPT,2,'cannot read parameter at point',' ')
      IPT2=81
      GO TO 100
C
C GENUS FOLLOWED BY SPECIES:
   5  IFAM=IFAM1
C4.6 Deal with possible duplicate species names
      IF ((IFAM.EQ.1) .AND. (IGEN1 .NE. IGEN2) .AND. (IGEN2 .NE.0)) THEN
        IP=NFIND(IANS2,IWDSPC,100)
        IF (IP.GT.0) THEN
          IC=NCFIND(LWD2,LSQWD(IP+1),100-IP)
          IF (IC.GT.0) THEN
            IANS2=IC+IP
            CALL KUNPAK(IANS2,IFAM,IGEN,ISPC,KP,KS)
          ENDIF
        ENDIF
        IF (IANS2.LE.0) GO TO 99
      ELSE
        IGEN=IGEN1
        ISPC=ISPC2
      ENDIF
 102  K=KPAK(IFAM,IGEN,ISPC,KPHASE,KSOURC)
 101  IPT2=IPT
 100  RETURN
      END
C
C
C
C
      subroutine tblnxt(NAME,IANS,IFAM,IGEN,ISPC,KP,KS)
      character *4 name
/WDSPC/
/WORDS/
C
      ipos=ians
      ians=0
      ip=nfind(ipos,iwdspc,100)
      if (ip.gt.0) then
        ic=ncfind(name,lsqwd(ip+1),100-ip)
        if (ic.gt.0) then
          ians=ic+ip
          CALL KUNPAK(IANS,IFAM,IGEN,ISPC,KP,KS)
        endif
      endif
      return
      end


      C
C
C
C
C LEVEL 1      SUBROUTINE PARRUN(IFAM,IGEN,ISPC)
      SUBROUTINE PARRUN(IFAM,IGEN,ISPC)
C
C *** PARRUN updated by JCM 26 Oct 89 ***
C
CX
CC 6C
CH Controls the cycling over all parameters in LSQ (not for Profile Refinement).
C
CA On entry, if IFAM=0 the cycle is to be initialised
CA       and otherwise IFAM,IGEN,ISPC contain the "previous"  values
CA On exit  IFAM contains the family of the "next" parameter,
CA               or -1 if the end has been reached.
CA          IGEN contains the genus of the "next" parameter,
CA          ISPC contains the species of the "next" parameter.
C
CP LSETUP must have set up the structure of the problem in the arrays:
CP     NGENS(I)=number of genera in family I
CP     NSPC(I) =number of species in each genus of family I
CP     LF1SP(I)=number of species in family 1, genus I.
CN There is a similar routine in the Profile Refinement section, RUNPAR,
CN which deals also with the special family 4 parameters, and multi-phase
CN and multi-source data.
C
/PRBLEM/
C
C INITIALISE ENTRY:
      IF (IFAM .EQ. 0) GO TO 5
C
C ENTRY TO ADVANCE:
      ISPC=ISPC+1
C CHECK NOT TOO MANY SPECIES FOR THIS FAMILY+GENUS:
   3  IF (ISPC .GT. NSPC(IFAM)) GO TO 2
C ALSO, FAMILY 1 HAS INDIVIDUAL GENERA OF DIFFERING LENGTHS:
      IF (IFAM .EQ. 1 .AND. ISPC .GT. IABS(LF1SP(IGEN))) GO TO 2
C
      GO TO 100
C
C NEXT GENUS:
   2  IGEN=IGEN+1
   1  ISPC=1
      IF (IGEN .LE. NGENS(IFAM)) GO TO 3
C NEXT FAMILY:
   5  IFAM=IFAM+1
      IGEN=1
C IN CASE NGENS(IFAM) = 0
      IF (IFAM .LE. NFAM) GO TO 1
      IFAM=-1
 100  RETURN
      END
C
C
C
C
C LEVEL 10      SUBROUTINE PARSDS
      SUBROUTINE PARSDS
C
C *** PARSDS updated by JCM 28 Jan 88 ***
C
CX
CC 7A
CH Collects together all parameter fixing and varying information for
CH LSQ refinement of cell parameters using d spacings.
C
CP The LSQ system must have been set up by LSETUP.  A "C" card with
CP cell parameters must have been read using RECIP.
C
CD Absorbs constraints due to symmetry for cell parameters, then reads
CD and interprets L FIX, LVARY and L RELA cards.
C
CI L FIX, LVARY and L RELA cards.
C
C ABSORB EXISTING CONSTRAINTS ON CELL PARAMETERS DUE TO SYMMETRY:
      EXTERNAL LDUMMY
      CALL CELREL(1,1,1)
C
C READ ALL 'L RELA' CARDS:
      CALL RDRELA
C READ ALL 'L FIX' AND 'L VARY' CARDS:
      CALL RDFV(LDUMMY)
      RETURN
      END
C
C
C
C
C LEVEL 7      SUBROUTINE PARSFW
      SUBROUTINE PARSFW
C
C *** PARSFW updated by JCM 12 Jan 88 ***
C
CX
CC 7A
CH An older routine to set up variables from parameters for FWLSQ.
CD All parameters are in fact both variables and basic variables, as there
CD      are no constraints on this problem
C
      CHARACTER *4 IPR1(8),IPR2(8)
/CONSTR/
/DERBAS/
/DERVAR/
/FWVALS/
/IOUNIT/
/POINTS/
C
CTHIS AVOIDS USING VARMAK FOR NO REASON AT ALL OTHER THAN HISTORY.
C IT MAY NOT STILL WORK.
C
      JCONST=0
      LVARV=NVALS
      LVARB=NVALS
      IFAM=1
      IGEN=2
      DO 1 I=1,NVALS
      LBSVR(I)=I
      LVRBS(I)=I
      LVRPR(I)=KPAK(1,2,I,0,0)
   1  CONTINUE
C
      IF (LVARB .LE. 0) THEN
        CALL MESS(LPT,1,'No variables')
        GO TO 100
      ENDIF
      WRITE (LPT,2001) LVARB
2001  FORMAT (/'0',I5,' basic variables :'/)
      IC=0
      DO  4 IB=1,LVARB
      IC=IC+1
      CALL PARNAM(IPR1(IC),IPR2(IC),1,IB)
      IF (IC .LT. 8) GO TO  4
      WRITE (LPT,2002) (IPR1(J),IPR2(J),J=1,IC)
2002  FORMAT (' ',8(A4,1X,A4,2X))
      IC=0
   4  CONTINUE
      IF (IC .NE. 0)  WRITE (LPT,2002) (IPR1(J),IPR2(J),J=1,IC)
 100  RETURN
      END
C
C
C
C
C LEVEL 10      SUBROUTINE PARSSF(MAGPAR)
      SUBROUTINE PARSSF(MAGPAR)
C
C *** PARSSF updated by PJB C4.26 3rd argument to MAGPAR March 2013 ***
C
CX
CC 7B
CH Collects all parameter fix and vary information for single crystal LSQ.
C
CD Calls other routines to:
CD Collect all symmetry implied constraints
CD Read & interpret all L FIX, L RELA and L VARY cards.
CA MAGPAR is the name of a logical function which deals with parameters
CA which are not in the basic structure factor set (F2PARS). It is
CA DOMAG2 for the standard magnetic parameters, and LDUMMY if there are
CA no extra parameters.
C
CI L FIX, L VARY and L RELA cards.
      EXTERNAL MAGPAR
C109 MAGPAR must be declared logical
      LOGICAL CLAIMD,MAGPAR
      DIMENSION ISPVEC(10),JUNK(4)
/EXTN/
/NEWOLD/
/OVER/
/SLAKDA/
C
C IN FAM1 THERE MAY BE TFAC MADE EARLIER BECAUSE NO 'L TFAC' CARD, WHICH NOW
C WANTS FIXING:
      IFAM=1
      IGEN=1
      ISPC=1
      IF (NTFAC .EQ. 0) CALL LLTFAC(6)
C
C IF NO E CARD, FIX DOMR AND MOSC:
       IF (IEXTYP .EQ. 0) THEN
        DO 1 I=8,12
   1    CALL ADDFX5(1,1,I,1,1,4)
      ENDIF
C
C SET UP ALL FAMILY 2 RELATIONS DUE TO SYMMETRY:
      ISPVEC(1)=1
      ISPVEC(2)=4
      ISPVEC(3)=10
      CALL F2RELA(2,ISPVEC)
C AND IF MAGNETIC, DO RELATIONS BETWEEN MAGNETIC PARS ALSO:
      CLAIMD = MAGPAR(0,1,JUNK)
C
C IF SLACK CONSTRAINTS, DO CELL RELATIONS:
      IF (NSLAK(1) .GT. 0) CALL CELREL(1,1,2)
C
C READ ALL 'L RELA' CARDS:
      CALL RDRELA
C READ ALL 'L FUDG' CARDS:
      CALL FUDGIN(MAGPAR)
C READ ALL 'L FIX AND 'L VARY' CARDS:
      CALL RDFV(MAGPAR)
      RETURN
      END
C
C
C
C
C LEVEL 6      SUBROUTINE PFORMF(H,MAT,PSUM,PFACS,KODE)
      SUBROUTINE PFORMF(H,MAT,PSUM,PFACS,KODE)
C
C *** PFORMF updated by PJB C128 Feb 2004 ***
C
CX
CC 18B
CH Calculates radial form factors for multipole refinement.
CA H(3) contains the indices of the reflection
CA MAT is the number assigned to the multipole atom
CA On entry KODE gives the required action:
CA     = 0. Calculate radial form factors for atom MAT and put in pformf
CA     = 1. Return sum over multipoles in PSUM
CN The basis functions Ylm+ and Ylm- are defined by:
CN         Ylm+ = sqrt(2)Real({Ylm})
CN         Ylm- = sqrt(2)Imag({Ylm})
CN  Thus Ylm+ =  1/sqrt(2)[Ylm + (-1)**m(Yl-m)]
CN       Ylm- = -i/sqrt(2)[Ylm - (-1)**m(Yl-m)]

C
      CHARACTER*1 ASIG
      DIMENSION H(3),OH(3),RH(3)
      COMPLEX Y(28),AI,PFACS(50),PSUM,FORMFA
/ATNAM/
/CONSTA/
/FORMDA/
/MAGDAT/
/MPODAC/
/MPODA/
/POLFOR/
/QROT/
/REFINE/
C
      IF (KODE.NE.0) GO TO 6
C  HERE TO CALCULATE RADIAL FORM FACTORS
      MPAT=MPATAB(MAT)
      AK = VCTMOD(0.5,H,2)
      AKK = FOURPI*AK
      CALL GMZER(PFORFA,7,1)
      LMAX=0
C Get the monopole form factor label
      IF (MAG) THEN
        KFORM = NMFORM(MAGAT(MPAT))
      ELSE
        KFORM = NFORMF(MPAT)
      ENDIF
      IMPFOR=MPFOR(KFORM)
      IF (IMPFOR.EQ.0) CALL ERRMES(-1,0,'No form factor for '//
     &ATNAME(MPAT)//' should have been caught earlier')
C Cycle over the different multipoles of this atom
      DO 5 I = MPTAB(MAT),MPTAB(MAT+1)-1
      READ (MPNAM(I),10) L
   10 FORMAT (1X,I1)
      IF (L.GT.LMAX) LMAX=L
      IF (PFORFA(L+1).NE.0) GO TO 5
C128 MPLFOR(1,MAT)=-999 signals radial wave-function given
      IF (MPLFOR(1,IMPFOR) .EQ. -999) THEN
        PFORFA(L+1)=FORMFC(AKK,L,0,KFORM)
      ELSE
        IF (L.EQ.0) THEN
C118 for L=0 the form factor number to use  is KFORM
          JFORM=KFORM
        ELSE
C128 The label in MPLFOR is the multipole number
          JFORM = MPLFOR(L,IMPFOR)
        ENDIF
        IF (JFORM .GT. 0) PFORFA(L+1)=REAL(FORMFA(AK,JFORM))
      ENDIF
    5 CONTINUE
      GO TO 100
C
C  HERE TO CALCULATE SUM OVER RADIAL FORM FACTORS * YLM
    6 CONTINUE
C  SQUARE ROOT OF -1
      AI=CMPLX(0.,1.)
      TWORTP=SQRT(FOURPI)
      ROOT2=SQRT(2.)
C
      CALL GMPRD(ROT(1,1,MAT),H,RH,3,3,1)
      CALL GMEQ(RH,OH,1,3)
      CALL UNIVEC(OH,D)
      T=ACOS(OH(3))
      P=0.
      IF (1.-ABS(OH(3)) .GT. 10E-5) P=ATAN2(OH(2),OH(1))
C  CALCULATE ALL NECESSARY SPHERICAL HARMONICS
      N=LMAX+1
      NUM=N*(N+1)/2
      CALL SPHARM(Y,T,P,N,NUM)
C
C  NOW ACCUMULATE THE NON-SPHERICAL FORM FACTOR
C123 Bring this into line with REAORB and the definition given above
      II=1
      PSUM=0.
      DO 1 I=MPTAB(MAT),MPTAB(MAT+1)-1
      READ(MPNAM(I),11) L,M,ASIG
   11 FORMAT (1X,I1,I1,A1)
      NUM=M+1+(L*(L+1)/2)
C123      ISIG = (-1)**M
      IF (ASIG.EQ.'-' )  THEN
        HARM=AIMAG(Y(NUM))
      ELSE
        HARM=REAL(Y(NUM))
      ENDIF
      IF (M.NE.0) HARM=HARM*ROOT2
      PFACS(II)=PFORFA(L+1)*HARM*TWORTP*(AI**L)
      PSUM=PSUM+PFACS(II)*POLAMP(I,2)
      II=II+1
    1 CONTINUE
C
  100 RETURN
      END
C
C
C
C
C LEVEL 6      SUBROUTINE PFOUT
      SUBROUTINE PFOUT
C
C *** PFOUT updated by PJB C139 July-4-2005 ***
C
CX
CC 18A
CH Reports the allocation of multipole form factors
C
      CHARACTER *80 BUF
C
/ATNAM/
/FORMDA/
/FONAM/
/IOUNIT/
/MAGDAT/
/MPODA/
/POLFOR/
/REFINE/
C
      WRITE (LPT,11)
   11 format (/' Form factors to be used for multipole atoms:')
      DO 1 N=1,NMPAT
      J=0
      IAT=MPATAB(N)
      IF (MAG) THEN
         MFORM=NMFORM(MAGAT(IAT))
      ELSE
        MFORM=NFORMF(IAT)
      ENDIF
      IMPFOR=MPFOR(MFORM)
      IF (IMPFOR.EQ.0) GO TO 1
C128   MPLFOR(1,N) = -999 for radial wave-function
      IF (MPLFOR(1,IMPFOR) .EQ. -999) THEN
        WRITE (LPT,12) ATNAME(IAT),FONAME(MFORM)
C139 Report whuch radial function used
   12   FORMAT(4X,A4,'  Calculated from radial wave-functions for ',A4)
      ELSE
C128 Use a buffer to form the output line
        WRITE (BUF,10) ATNAME(IAT),FONAME(MFORM)
   10   FORMAT (4X,A4,2X,'L = 0',2X,A4)
        IBUF=22
%        DO 2 I=1,%MPFL%
        IFORM = MPLFOR(I,IMPFOR)
        IF (IFORM .GT. 0) THEN
          WRITE (BUF(IBUF:),13) I-1,FONAME(IFORM)
   13     FORMAT (2X,'L =',I2,2X,A4)
          IBUF=IBUF+13
        ENDIF
    2   CONTINUE
        WRITE (LPT,14) (BUF(I:I),I=1,IBUF)
   14   FORMAT (80A1)
      ENDIF
    1 CONTINUE
      RETURN
      END
C
C
C
C
C LEVEL 6      SUBROUTINE PFSET
      SUBROUTINE PFSET
C
C *** PFSET updated by PJB C139 July-4-2005 ***
C
CX
CC 18A
CH Directs the reading of J and W cards for multipole calculations.
C
      CHARACTER*4 WORD,WWORDS(2)
      LOGICAL NOROT
/ATNAM/
/CARDRC/
      COMMON /DOMPL/JCOUNT
/FORMDA/
/FONAM/
/IOUNIT/
/MAGDAT/
/MPODA/
/MPODAC/
/POLFOR/
/RADINT/
/REFINE/
%      COMMON /SCRAT1/AMPS(%MPOL%),MPTMP(%MPOL%),LABEL(%MPOL%),LTMP(3),
     &LPK(10,3),NMPL
      DATA WWORDS/'RADF','ROTN'/
C
C SAVE CURRENT ERROR COUNT
      IERSAV=IERR
C ZERO JCOUNT at start
      JCOUNT=0
C
      IF (IOUT.GT.200) CALL OPSYM(1)
C
C128 CLEAR THE MULTIPOLE FORM FACTOR LIST
%      CALL JGMZER(MPLFOR(1,1),%MPFL%,%MPFO%)
%      CALL JGMZER(MPFOR,%FORM%,1)
C  READ IN J DATA
      NMPAT=0
      NMPL=0
      NCLUMP=0
      NJ=ICDNO(10)
      IF (NJ .EQ. 0) GO TO 32
C
      LTMP(1)=50
      LTMP(2)=7
      LTMP(3)=13
      CALL NPACK(NPK,LTMP,3,0,LPK)
C
C  READ DATA FROM  J MPOL CARDS
      IDT=IABS(INREAD(10))
      INREAD(10)=-IDT
      DO 21 J=1,NJ
      CALL INPUTJ(IDT,NTYP,IAT,IPT,IE)
      IF (NTYP.NE.1) GO TO 28
      IF (MPNMTB(IAT).EQ.0) THEN
%      CALL ERRCHK(2,NMPAT,%MPAT%,0,'atoms with multipoles')
        IF (MAG .AND. MAGAT(IAT).EQ.0) THEN
          CALL ERRMES (1,2,'Multipole atom '
     &    //ATNAME(IAT)//' is not a magnetic atom')
          GO TO 21
        ENDIF
        MPATAB(NMPAT)=IAT
        MPNMTB(IAT)=NMPAT
      ENDIF
      LTMP(1)=NMPAT
  11  CALL RDWORD(WORD,ILEN,IPT,IPT1,80,0,IE)
C IF NOTHING MORE ON CARD:
      IF (IE .EQ. 100) THEN
C128 SET THE MULTIPOLE FORM FACTOR (MAY ONLY BE MONOPOLE)
        IF (MAG) THEN
          IFORM=NMFORM(MAGAT(IAT))
        ELSE
          IFORM=NFORMF(IAT)
        ENDIF
        IF (MPFOR(IFORM) .EQ.0) THEN
%          CALL ERRCHK(2,NMPFOR,%MPFO%,0,'Multipole form factors')
          MPFOR(IFORM) = NMPFOR
        ENDIF
        GO TO 28
      ENDIF
C
      IF (IE.NE.0) GO TO 29
      LTMP(2)=NCHINT(WORD(2:2))
      IF (LTMP(2) .LT. 0 .OR. LTMP(2) .GT. 6) GO TO 29
      LT=NCHINT(WORD(3:3))
      IF (LT .LT. 0 .OR. LT .GT. LTMP(2)) GO TO 29
      IF (WORD(4:4).EQ.'-') LT=-LT
      LTMP(3)=LTMP(2)+1-LT
%      CALL ERRCHK(2,NMPL,%MPOL%,0,'multipoles')
      CALL RDREAL(AMPS(NMPL),IPT1,IPT,80,IE)
      IF (IE.NE.0) GO TO 29
      CALL NPACK(MPTMP(NMPL),LTMP,3,1,LPK)
      GO TO 11
C
  29  CALL ERRMES(1,1,'reading J MPOL card')
C  TO GET NEXT J CARD
   28 IDT=IDT+NYZ
   21 CONTINUE
C END OF J CARDS TIDY UP
      CALL SORTN(MPTMP,LABEL,NMPL)
C
  32  IF (ICDNO(10) .GT. 0) THEN
C FIND OUT WHICH FORM FACTORS ARE WHICH:
        IDT=IABS(INREAD(10))
        CALL MPFORM(IDT,NJ)
      ENDIF
C
C Initialise in any case
      CALL READRT(NMPAT,-1,WORD)
      NCARDW=ICDNO(23)
      IF (NCARDW .EQ. 0) GO TO 50
C
C  READ IN W DATA
      CALL RADFUN(NMPAT,-1)
      IDT=IABS(INREAD(23))
      DO 3 NN=1,NCARDW
      CALL INPUTW(IAT,WORD,IDT,IPT)
      GO TO (3,4,5), 1+NCFIND(WORD,WWORDS,2)
C128 Reorganise
    4 IF (MPFOR(IAT) .EQ.0) THEN
C128 This is probably a monopole form factor given as radial function
%        CALL ERRCHK(2,NMPFOR,%MPFO%,0,'Multipole form factors')
        MPFOR(IAT)=NMPFOR
        MPLFOR(1,NMPFOR)=-999
      ELSE
        IF (MPLFOR(1,MPFOR(IAT)).GT.0) THEN
          CALL ERRMES(4,-1,'Radial wave-function not expected for '//
     &    FONAME(IAT))
        ELSE
          CALL RADFUN(IAT,IPT)
        ENDIF
      ENDIF
      GO TO 3
C
    5 JATOM = MPNMTB(IAT)
      CALL READRT(JATOM,IPT,ATNAME(IAT))
    3 CONTINUE
C
C139 Entry PFEND removed, carries straight on
   50 NAT=0
      NEXT=0
C
      MAT=0
   9  NEXT=NEXT+1
      IF (NEXT.GT.NMPL) THEN
        JAT=0
      ELSE
      NTAB=LABEL(NEXT)
      NPK=MPTMP(NTAB)
      PAMP=AMPS(NTAB)
      CALL NPACK(NPK,LTMP,3,2,LPK)
      JAT=LTMP(1)
      LV=LTMP(2)
      MVAL=LTMP(3)
      ENDIF
      IF ((MAT.NE.0).AND. (MAT.NE.JAT.OR. LVAL.NE.LV))
     &CALL ORTFUN(IFUN,KNUM,DUM,0)
      IF (JAT.EQ.MAT .AND. JAT .NE. 0) GO TO 40
C  NEW ATOM
      NOROT=.TRUE.
      MPTAB(MAT+1)=NMPOL+1
      IF (MAT.NE.0)
     &WRITE (LPT,2001) ATNAME(MPATAB(MAT)),(MPNAM(J),POLAMP(J,1),
     &J=MPTAB(MAT),MPTAB(MAT+1)-1)
 2001 FORMAT (/1X,A4,' Multipoles: ',
     &5(A4,F8.4,2X)/12(13X,5(A4,F8.4,2X)/))
      IF (JAT.NE.0) THEN
        MAT=JAT
        IAT=MPATAB(MAT)
      ELSE
        IF (NAT .EQ. 0) GO TO 1
        MAT=NMPAT-NAT+1
        NAT=NAT-1
        IAT=MPATAB(MAT)
        CALL READRT(MAT,-2,ATNAME(IAT))
        PAMP=1.0
        LV=0
        MVAL=0
      ENDIF
      LVAL=-1
C FIND APPROPRIATE FORM FACTOR:
      IF (MAG) THEN
        IFORM = NMFORM(MAGAT(IAT))
      ELSE
        IFORM = NFORMF(IAT)
      ENDIF
C128 Reorganise
      IMPFOR=MPFOR(IFORM)
      IF (IMPFOR .EQ.0) THEN
        CALL ERRMES(1,1,'No multipole form factor given for '//
     &  FONAME(IFORM)//' needed by atom '//ATNAME(IAT))
      ELSE
        IF (MPLFOR(1,IMPFOR) .EQ. -999)  THEN
C139 Don't print if this has been done already for this form factor
        IF (NFIND(IFORM,IRADF,NRADF) .EQ. 0)
     &    WRITE (LPT,2002) FONAME(IFORM)
2002      FORMAT (//' *********'/' *  ',A4,' *'/' *********')
          CALL RADFUN(IFORM,0)
        ENDIF
      ENDIF
      WRITE (LPT,2002) ATNAME(IAT)
   40 IF (LV.EQ.LVAL) GO TO 41
C  NEW VALUE OF L
      LVAL=LV
      IF (LV .GT.0 .AND.NOROT) THEN
        IERCNT=IERR
        CALL READRT(MAT,0,ATNAME(IAT))
        IF (IERR .GT. IERCNT) CALL ERRMES(0,0,'in PFSET')
        NOROT=.FALSE.
      ENDIF
C128 Use MFAT as label for MPLFOR here
      IF (IMPFOR .NE.0 .AND. MPLFOR(1,IMPFOR) .NE. -999) THEN
        IF (LV .GT.0 .AND. MPLFOR(LV,IMPFOR) .EQ. 0 ) THEN
          WRITE (LPT,3000) LV,FONAME(IFORM),ATNAME(IAT)
          WRITE (ITO,3000) LV,FONAME(IFORM),ATNAME(IAT)
3000      FORMAT(/' ERROR ** No <j',I1,'> form factor given for ',A4,
     &  ' needed by atom ',A4/)
         IERR=IERR+1
        ENDIF
      ENDIF
      KNUM=2*LVAL+1
      IF (KNUM.GT.1) CALL MPCON(MAT,KNUM)
      MO=1
  41  CALL ORTFUN(MVAL,KNUM,PAMP,MO)
      MO=MO+1
      GO TO 9
    1 IF (IERR.NE.0) WRITE (ITO,10) IERR
   10 FORMAT (/I5,' Errors in input of wave-functions',
     &' and/or multipoles')
      IERR=IERR+IERSAV
C SET LSQ PARAMETERS:
      CALL CONVMP(1)
      RETURN
      END
C
C
C
C
C LEVEL 7      SUBROUTINE PICMOV
      SUBROUTINE PICMOV
C
C *** PICMOV by JCM 22 Aug 86 ***
C
CX
CC 14B
CH If plotting to Tektronix, do nothing;  if to plotter, move to next picture.
CP FROMCM in /PLODAT/ is 0 if plotting is actually to a VDU, for which
CP the scale "from cm" is irrelevant.
CP NYPIC in /PLOMAP/ is the number of pictures expected, and IYPIC is the
CP number already plotted.
CD If a large plotter is in use for several pictures plotted in sequence,
CD the matrix PMTRIX(,,2) holds the part of the transformation which
CD moves from one picture to another.  This routine deals with the moving
CD from one picture to another, advancing IYPIC and adjusting PMTRIX(,,2)
C
/PLODAT/
/PLOMAP/
/PLTRAN/
C
C USE FROMCM ALSO TO TELL WHETHER ACTUAL PLOTTER  (CALCOMP, BENSON, ZETA,
C ETC -FROMCM > 0) OR VDU (FROMCM =< 0)
      IF (FROMCM .LE. 0.) GO TO 100
C
C DEAL WITH PUTTING PICTUES NEATLY ON A LARGE PLOTTER:
      IF (IYPIC .EQ. 0) GO TO 11
      IF (IYPIC .LT. NYPIC) GO TO 12
      PMTRIX(1,3,2)=PMTRIX(1,3,2)+WIDPIC+BORDER
      PMTRIX(2,3,2)=-(HGTPIC+BORDER)
      IYPIC=0
  12  PMTRIX(2,3,2)=PMTRIX(2,3,2)+HGTPIC+BORDER
  11  IYPIC=IYPIC+1
 100  RETURN
      END
C
C
C
C LEVEL 3      SUBROUTINE PINITL
      SUBROUTINE PINITL
C
C *** PINITL by JCM 27 Jun 86 ***
C
CX
CC 14A
CH Initialises the system in order to make graphical output.
C
CD Sets up various quantities, some of them probably machine specific, to
CD enable SUBROUTINE PIGLET to be called.  PIGLET may well alter some
CD of them.  Suitable for either the plotter version or the Tektronix
C
CD  Sets    PAPERW = width of paper in cms (or no. of pixels)
CD          PAPERH = "height" of paper in cms - this is the maximum
CD                   amount allowed in direction perpendicular to the
CD                   axis of the plotter (or no. of pixels)
CD          FROMCM = the conversion factor from centimetres to hardware
CD                   units - set to 1 for now, and adjusted in PIGLET
CD                   where necessary (<0 for VDU output)
CD          CHUNIT = number of character units of a character grid which
CD                   make the height of a character (and also the maximum
CD                   width of a character, which may not use it all)
CD          ASPECT = ratio of the height of a plotted character to its width
CD          BORDER = width of border between pictures, in cms
CD          DASH = length of the dash of a dashed line, in cms
CD  Initialises the general structure of transformations in /PLODAT;
CD  does not initialise the basic 'CCSL to hardware' transformation,
CD which must be done in individual PIGLETs.
C143 Declare PGNAME to load PGNAME block data
      EXTERNAL PGNAME
      DIMENSION PTEMP(2,3)
/ADASH/
/PLODAT/
C
C RATIO OF HEIGHT OF CHARACTER TO ITS WIDTH:
      ASPECT=1.0
C   PAPERW AND PAPERH = MAXIMUM VALUES FOR WIDTH (CCSL Y DIRECTION) AND
C   HEIGHT (CCSL X DIRECTION, WHICH WOULD BE "INFINITE" IF A DRUM PLOTTER
C   IS BEING USED) EXPRESSED IN CCSL UNITS WHICH ARE ** CENTIMETRES **
C INITIALISATION IS FOR GRENOBLE BENSON:
      PAPERW = 72.
      PAPERH = 500.
C FROMCM = CONVERSION FACTOR FROM CMS TO HARDWARE UNITS:
      FROMCM=1.
C BORDER = SPACE BETWEEN ONE PICTURE AND THE NEXT IN A PLOT (SEE PIGLET
C FOR EXPLANATION)
      BORDER = 0.5
C CHUNIT IS THE NUMBER OF UNITS OF CHARACTER GRID WHICH MAKE THE HEIGHT OF A
C CHARACTER, AND THE MAXIMUM WIDTH (CHARACTERS MAY TAKE FEWER UNITS ACROSS).
      CHUNIT=30.
C Scale from CCSL cms to map cms (from pixels) for pixel based screen devices
      CHMAP=1.
C LENGTH OF A DASH IN NEGATIVE CONTOURS IN CMS:
      DASH=0.2
C
C SET UP PICTURE TO CCSL TRANSFORMATION (DEFAULT 1 PICTURE):
      CALL GMZER(PTEMP,2,3)
      CALL GMUNI(PTEMP,2)
      CALL PLTRIN(PTEMP,3,2)
C INITIALISE TRANSFORMATIONS:
      NSPCE=0
      NCON1=0
      NCON2=0
      MAXSP=2
      IDSH=0
      RETURN
      END
C
C
C
C
C LEVEL 2      SUBROUTINE PLCONV(X1,Y1,NN1,X2,Y2,NN2)
      SUBROUTINE PLCONV(X1,Y1,NN1,X2,Y2,NN2)
C
C *** PLCONV updated by PJB 4 Apr 85 ***
C
CX
CC 14B
CH Performs the transformation of coordinates between different plotter spaces.
CA On entry X1, Y1 are coordinates in coordinate system number NN1
CA On exit  X2, Y2 are the same coordinates transformed into the
CA                 coordinate system number NN2
C
CP PIGLET with N=0, PLTRIN to set up the required transformation matrices.
C
CD Coordinate systems:
CD 0=Current - The current space is held in NSPCE in COMMON /PLTRAN/
CD 1=Plotter (actual coords on a particular plotter)
CD 2=CCSL (the coords in which the programs are written)
CD Coordinate sytems 3 to 7 are for user applications, for example in plotting
CD Fourier maps they are used as follows:
CD 3=Picture (one "picture" which contains one section of the map)
CD 4=Map (The crystallographically related axes of the Fourier calculation)
CD 5=Character type 1 (a mesh of 30 by 30 on which characters are defined)
CD 6=Character type 2 (a mesh of 30 by 30 on which characters are defined)
CD 7=Character type 3 (a mesh of 30 by 30 on which characters are defined)
CD
CD Conversion involves both a translation (or origin shift) and a rotation.
CD These are combined by holding the conversion matrix as 3 by 2 with
CD the translation vector as the 3rd column.
C
      DIMENSION A(2,3),B(2,3),C(2,3)
/IOUNIT/
/PLTRAN/
C
      N1=NN1
      N2=NN2
      IF (N1 .EQ. 0) N1=NSPCE
      IF (N2 .EQ. 0) N2=NSPCE
C  DO WE NEED A NEW MATRIX?
      IF (N1.EQ.NCON1 .AND. N2.EQ.NCON2) GO TO 101
C MAKE IT:
      N=N1-1
      M=N2-1
      CALL GMZER(A,2,3)
      A(1,1)=1.
      A(2,2)=1.
      CALL GMEQ(A,B,2,3)
    1 IF (N-M) 4,3,2
C
C  SOURCE SPACE HIGHER
    2 IF (N .LE. 0) GO TO 6
      CALL PMTMUL(PMTRIX(1,1,N),A,C)
      CALL GMEQ(C,A,2,3)
      N=NTRAN(N)-1
      GO TO 1
C
C  DESTINATION HIGHER
    4 IF (M .LE. 0) GO TO 6
C CHECK WHICH WAY ROUND THIS SHOULD BE:
      CALL PMTMUL(PMTRIX(1,1,M),B,C)
      CALL GMEQ(C,B,2,3)
      M=NTRAN(M)-1
      GO TO 1
C
C  SOURCE AND DESTINATION NOW THE SAME, FORM MATRIX
    3 CALL PMTINV(B,C)
      CALL PMTMUL(C,A,PTRAN(1,1,2))
C  AND SET NEW VALUES IN NCON
      NCON1=N1
      NCON2=N2
C  GO AND DO TRANSFORMATION
      GO TO 101
C
    6 WRITE (LPT,3000) N1,N2
      WRITE (ITO,3000) N1,N2
3000  FORMAT (' ERROR ** PLCONV REQUIRED TO CONVERT FROM COORDS',
     & I3,' TO COORDS',I3)
      STOP
C
 101  X2=PTRAN(1,1,2)*X1+PTRAN(1,2,2)*Y1+PTRAN(1,3,2)
      Y2=PTRAN(2,1,2)*X1+PTRAN(2,2,2)*Y1+PTRAN(2,3,2)
      RETURN
      END
C
C
C
C
C LEVEL 6      SUBROUTINE PLN3AD(I,J,K)
      SUBROUTINE PLN3AD(I,J,K)
C
C *** PLN3AD by JCM 3 Oct 84 ***
C
CX
CC 1A
CH A specialist routine used during the formation of the reciprocal unit
CH cell, to offer up 3 planes as boundaries, in cubic space groups.
CA On entry I,J,K specify 3 planes, by pointing to symmetry elements.
CA                The array AXI(,I,,) holds the axes of these elements
CA                in reciprocal space, and these axes are normal to the
CA                planes in question
C
CD The 3 axes are first oriented so that the angles between the planes
CD are acute.
C
      DIMENSION A(3),B(3),C(3)
%      COMMON /SCRAT/AXI(3,%SYMO%,2),MIRROR(%SYMO%),D(3,3),PL1(3),PL2(3),PL3(3),
     & HT(3),ASY(3,4),NSTAT(4),NOPL,NICE,VOL,MOP1,MOP2
C
      CALL GMEQ(AXI(1,I,2),A,1,3)
      CALL GMEQ(AXI(1,J,2),B,1,3)
      CALL GMEQ(AXI(1,K,2),C,1,3)
C MAKE AN ACUTE ANGLE BETWEN A AND B:
      IF (SCALPR(A,B) .LT. 0.) CALL GMREV(B,B,1,3)
C MAKE AN ACUTE ANGLE BETWEN A AND C:
      IF (SCALPR(A,C) .LT. 0.) CALL GMREV(C,C,1,3)
      CALL VECPRD(B,C,PL1)
      CALL VECPRD(C,A,PL2)
      CALL VECPRD(A,B,PL3)
      CALL FIXUNI(PL1,3)
      CALL FIXUNI(PL2,3)
      CALL FIXUNI(PL3,3)
      RETURN
      END
C
C
C
C
C LEVEL 7      SUBROUTINE PLOTCT(C,A,FOUND,M,N)
      SUBROUTINE PLOTCT(C,A,FOUND,M,N)
C
C *** PLOTCT by JCM 24 Nov 83 ***
C
CX
CC 14B
CH Plots a single contour throughout a given array.
CA On entry C is the contour value required
CA          A is a M by N array of values in which the contour C is to be
CA            interpolated
CA On exit  FOUND is true if a contour was found and plotted, false otherwise.
CP PIGLET with N=0 and N=999, to set up the plotter.
CP The desired mesh on the plotter should be set up with PLTRIN and SPCSET
CO Output is to a plotter whose characteristics are defined in the version of
CO PIGLET linked.
C
      LOGICAL FOUND,MID,TEST
      DIMENSION A(M,N),T(6)
/BITMAP/
      FOUND = .FALSE.
      IPEN=3
      ICC=1
      IF (C) 6,7,8
   6  ICC=2
      IPEN=2
      GO TO 8
   7  IPEN=1
      ICC=14
C
C SELECT COLOUR OF PEN:
   8  CALL PIGLET(0.,0.,-IPEN)
      M2=M+2
      DO 1 I=1,M2
      DO 5 J = 1,4
    5 IBIT(I,J) = 0
      CALL MAKEBM(I,A,C,M,N)
   1  CONTINUE
      DO 2 I=1,M2
      DO 2 J=1,4
  22  IF (IBIT(I,J) .EQ. 0) GO TO 2
      FOUND = .TRUE.
      CALL LOCBIT(I,J,NR,NC,ISIDE,M,N)
C        SETS NR,NC TO TOP LEFT OF SQUARE - ISIDE = 1,2,3 OR 4
      CALL GETSQ(A,T,C,NR,NC,M,N)
      XPNT = 0.
      POINT = T(ISIDE)/(T(ISIDE) - T(ISIDE+1))
      LINE=0
      CALL DOSIDE (POINT,XPNT,ISIDE,NR,NC,X,Y)
      CALL DPLOT(X,Y,LINE)
      LINE = ICC
   4  MID = T(6) .GE. 0.
      IC = 0
      IF (MID .AND. T(ISIDE) .GE. 0. .OR. .NOT. MID .AND. T(ISIDE)
     & .LT. 0.) IC = 1
      ID = ISIDE + IC
   3  POINT = 0.5 * T(ID)/(T(ID) - T(6))
      XPNT = POINT
      IF (IC .NE. 0)  XPNT = 1.-POINT
      CALL DOSIDE (XPNT,POINT,ISIDE,NR,NC,X,Y)
      CALL DPLOT(X,Y,LINE)
      LINE = ICC
      ISIDE = ISIDE - 1 + IC + IC
      IF (ISIDE .EQ. 5)  ISIDE = 1
      IF (ISIDE .EQ. 0)  ISIDE = 4
      ID = ISIDE + IC
      IF (MID .AND. T(ID) .LT. 0. .OR. .NOT. MID .AND. T(ID)
     & .GE. 0.) GO TO 3
      XPNT = 0.
      POINT = T(ISIDE)/(T(ISIDE) - T(ISIDE+1))
      CALL DOSIDE (POINT,XPNT,ISIDE,NR,NC,X,Y)
      CALL DPLOT(X,Y,LINE)
      GO TO (11,12,13,14), ISIDE
  11  ISIDE = 3
      IF (NR .GT. 1) GO TO 21
      CALL BITSET(1,NC,TEST,.FALSE.)
  17  IF (TEST)  GO TO 22
      CALL ERRMES(-1,0,'in PLOTCT')
C
  21  NR = NR-1
      CALL BITSET(NR+4,NC,TEST,.FALSE.)
      IF (.NOT. TEST) GO TO 22
      GO TO 16
  12  NC = NC+1
      ISIDE = 4
      IF (NC .LT. N) GO TO 16
      CALL BITSET (2,NR,TEST,.FALSE.)
      GO TO 17
  13  NR = NR+1
      ISIDE = 1
      IF (NR .LT. M) GO TO 15
      CALL BITSET (3,N-NC,TEST,.FALSE.)
      GO TO 17
  14  NC = NC-1
      ISIDE = 2
      IF (NC .GT. 0) GO TO 16
      CALL BITSET(4,M-NR,TEST,.FALSE.)
      GO TO 17
  15  CALL BITSET(NR+3,NC,TEST,.FALSE.)
      IF (.NOT. TEST) GO TO 22
  16  CALL GETSQ(A,T,C,NR,NC,M,N)
      GO TO 4
   2  CONTINUE
      RETURN
      END
C
C
C
C
C LEVEL 6 SUBROUTINE PLOTGP
      SUBROUTINE PLOTGP
C
C   **** PLOTGP New by PJB June 2017  C 4.38 ****
C
C
CC 14B
CH To plot a contour map using GNUPLOT from data in MAPDA
C
CP FOUR1Z to fill in the array DENS with the data to be plotted
CP GPPREF to select the output devices
C
      CHARACTER *11 FONT,TFONT *10,HCNAME*40
      DIMENSION LFONT(3),CHMARG(2,2),smarg(2,2),VALIM(2),
     & RANGES(2,2),XTIC(6),YTIC(6),CHGRAF(2),SIZE(2),GRAPH(2),
     &ANGRAF(2)
      CHARACTER *4 XLAB(6),YLAB(6),ROTATE*10,INFO*35
      INTEGER GPLGO
      LOGICAL SAYS,FIRST,PS,there,ploted,POSNEG
/ATNAM/
/CONTUR/
/GNPLT/
/GPCHRS/
/GPLMAP/
/MAPDA/
/MAPLAB/
/IOUNIT/
/SCRACH/
/TITLE/
C
      DATA FONT,TFONT /'Times-Roman','Times-Bold'/
C FONT SIZES FOR SCREEN AND POSTSCRIPT :BASE,TICS LABELS,TITLE
      DATA LFONT /16,16,20/
C  MARGINS in character units 2nd index is the axis label
      DATA CHMARG /5.5,5.5,5.0,6.0/
      DATA PXPRPT/1.33/
C
C Set atmplt not yet called
      NFOUND=0
C Widmap and HGTmap set in stgplt
      ASPCTM=WIDMAP/HGTMAP
      RATIO=ASPCTM
      IMAX=1
C Imax the index of the bigger dimension
      IF (ASPCTM.LT.1) THEN
        IMAX=2
        RATIO=1./ASPCTM
      ENDIF
C Tic labels, those for y have to start at top left
      STEPY=(OUTLIM(2,1)-OUTLIM(1,1))/5.
      STEPX=(OUTLIM(2,2)-OUTLIM(1,2))/5.
      XTIC(1)=OUTLIM(1,2)
      YTIC(1)=OUTLIM(1,1)
      DO 1 N=2,6
      XTIC(N)=XTIC(N-1) + STEPX
      YTIC(N)=YTIC(N-1) + STEPY
    1 CONTINUE
      CALL TRIMF(YTIC,YLAB,6)
      CALL TRIMF(XTIC,XLAB,6)
C Output DENS values to map.dat file
      CALL MAPGP(VALIM)
 2000 format ('Map heights range from ',f10.3,' to' ,f10.3,
     &I4,' steps',3f10.4)
C Contour levels: FOUGPL just uses the number of levels neglecting user values
      STEPC=(VALIM(2)-VALIM(1))/FLOAT(NCONT)
      CALL ROUND(STEPC,2,RSTEP,I10)
      STEPC=RSTEP
      T=VALIM(1)/STEPC
      R=AMOD(T,1.)
      STARTC= (FLOAT(INT(T))-0.5)*STEPC
       WRITE (ITO,2000) VALIM, NCONT,STEPC,STARTC,R
      IF (R.GT.0.5) THEN
        STARTC=STARTC-0.5*STEPC
      ENDIF
      A=ABS((VALIM(2)-VALIM(1))/VALIM(2) )
C Chose whether density is basically positive or positive and negative
      POSNEG= A .GT. 1.2
C
C OPEN  FILE FOR GNUPLOT COMMANDS
      MESSAG='gplc'//TERM(1)(1:2)//'.gpl'
      IPLO=NOPFIL(226)
      WRITE (ITO,1002) MESSAG
      WRITE (LPT,1002) MESSAG
 1002  FORMAT ('Creating gnuplot command file  ',A)
C write commands independent of terminal type (RANGES(IJ) I=X,Y, J-LOWHIGH
      RANGES(1,1)=0.
      RANGES(1,2)=WIDMAP
      RANGES(2,1)=0.
      RANGES(2,2)=HGTMAP
      WRITE (IPLO,1010) ((RANGES(I,J),J=1,2),I=1,2)
 1010 FORMAT ('reset'/'set xrange ['
     &,F8.3,':',F8.3,']'/'set yrange [',F8.3,':',F8.3,']')
       WRITE (IPLO,1011)
 1011 FORMAT ('set table "cmap.dat"'/'splot "map.dat" using 1:2:3'/
     &'unset table'/);
      WRITE (IPLO,1012)
 1012 FORMAT ('set contour base'/'unset surface')
      WRITE (IPLO,1013) STARTC,STEPC,VALIM(2);
 1013 FORMAT('set cntrparam level incremental ',2(F8.3,','),f8.3)
      WRITE (IPLO,1014)
 1014 FORMAT ('set table "cont.dat"'/'splot "cmap.dat"'/'unset table'/)
C Set idev =1
      IDEV=1
      DEVF=1.
C *********************************part depending on IDEV******************************
C Scale all to Height and width of canvas in pixels
C The terminal preferences were set by gppref
C TNUMS(2,IDEV)  the terminal size for GNUPLOT
C TNUMS(1,IDEV) the width in pixels of the units in which
C TNUMS(2,IDEV) is defined 1 800 for X11 or aqua ; 95.8  7.5 for postscript
   21 CHWID=FLOAT(LFONT(1))*PXPRPT
      CALL GMSCA(CHMARG(1,1),SMARG(1,1),CHWID,2,2)
C Sizes of screen amd graph in pixels
      IMIN=3-IMAX
      SIZE(IMAX)=TNUMS(1,IDEV)*TNUMS(2,IDEV)
      GRAPH(IMAX)=SIZE(IMAX)-SMARG(1,IMAX)-SMARG(2,IMAX)
      GRAPH(IMIN)=GRAPH(IMAX)/RATIO
      SIZE(IMIN) = GRAPH(IMIN)+SMARG(1,IMIN)+SMARG(2,IMIN)
C  SET TERMINAL
      WRITE (IPLO,1018) TERM(IDEV)(1:LENGT(TERM(IDEV))),
     &TOPTS(IDEV)(1:LENGT(TOPTS(IDEV))),SIZE(1)/TNUMS(1,IDEV),
     &SIZE(2)/TNUMS(1,IDEV),FONT,NINT(FLOAT(LFONT(1))*DEVF)
 1018 FORMAT ('set terminal "',A,'" ',A,' size ',F8.3,',',f8.3,
     &' font "',A,',',I2,'"')
       PS=(INDEX(TERM(IDEV),'post' ).EQ.1)
C
C Set the margins
       WRITE (IPLO,1016) SMARG(1,2)/SIZE(2),1.-(SMARG(2,2)/SIZE(2))
 1016 FORMAT ('set bmargin at screen ',F8.3/'set tmargin at screen  '
     &,F8.3)
      WRITE (IPLO,1017)SMARG(1,1)/SIZE(1),1.-(SMARG(1,2)/SIZE(1))
 1017 FORMAT ('set lmargin at screen ',F8.3/'set rmargin at screen '
     &,F8.3)
C INITIALISE LABEL NUMBERS
      NLAB=1
C Make frame round map it may not be rectangular
      WRITE (IPLO,1023) NLAB,XORIG,1., WIDBOX,0., XPROJ,-1. ,
     &-WIDBOX,0.,-XPROJ,1.,NLAB
 1023 format ('unset border'/'set object',i3
     &,' polygon from graph ', f7.3,',',f6.2,4(' rto  graph ',
     & f6.3,',',f6.3)/'set object',i3,' fillstyle empty front')
      NLAB=NLAB+1
C
C Character widths in graph coords
      CHGRAF(1)=CHWID/GRAPH(1)
      CHGRAF(2)=CHWID/GRAPH(2)
C Scale graph units per Angstrom
      ANGRAF(1)=1./WIDMAP
      ANGRAF(2)=1./HGTMAP
C X offsets
      WIDLAB =  3.*CHGRAF(1)  ! ATOM KEY WIDTH
      ANGGAP =  2.*CHGRAF(1)  ! ANGSTROM GAP
      ARR2X  = -2.5*CHGRAF(1)  ! Y ARROW X  OFFSET
      TICYX  = -2.*CHGRAF(1)  ! Y ARROW X  OFFSET
C Y OFFSETS
      OFFTC=1.+0.75*CHGRAF(2)  ! XTICS
      ARR1Y=1.+1.5*CHGRAF(2)  ! ARROW 1 Y
      ARR2LY = 2.*CHGRAF(2)  ! ARROW 2 LABEL
      OFFANG = -1.*CHGRAF(2)  ! ANGSTROM MARKER
      OFFAT = -2.*CHGRAF(2)   ! ATOM KEY
C
C Title offset depends on terminal device
      CH=1.
      IF (PS)   CH=2.4
      IF (IDEV.EQ.2) THEN
Check whether we need a new output file
        INQUIRE(FILE=HCOUT(1:lengt(HCOUT)),EXIST=THERE)
        IF (THERE) THEN
          I=INDEX(HCOUT,'.')+1
          HCOUT=HCNAME(HCOUT(I:I+2))
        ENDIF
        WRITE (IPLO,1019) HCOUT(1:LENGT(HCOUT))
 1019   FORMAT ('set output "',a,'"')
      endif
C WRITE TITLE:
      L=(LENGT(ITITLE))
C Extra info in title
      IF (NDIM.EQ. 2) THEN
        WRITE (INFO,2003) (INT(U(I,3)),I=1,3)
 2003 format('Projection down (',3i3,')')
      ELSE
        WRITE (INFO,2001) OUTLIM(1,3),(INT(U(I,3)),I=1,3)
      ENDIF
 2001 format('Section at',f6.3,' on [',3i3,']')
      WRITE (IPLO,1015) ITITLE(1:LENGT(ITITLE)),info(1:lengt(info)),
     &CH,TFONT,NINT(FLOAT(LFONT(3))*DEVF)
 1015 FORMAT('set title "',A,1x,A,'"\'/' offset character 0,',f5.2,
     &' font "',A,',',I2,'"')
      WRITE (IPLO,1020) 1./ASPCTM
 1020 FORMAT ('set size ratio ',F8.3)
C
C To allow non-orthogonality the x and  y tics now have to be just labels
      XFAC=XPROJ
      WRITE (IPLO,1022)
 1022 FORMAT ('unset xtics '/'unset ytics')
      DO 2 I=1,6
        WRITE (IPLO,1027) NLAB, (YLAB(I)(1:LENGT(YLAB(I)))),
     &  XORIG + TICYX+ (YTIC(I)*XFAC),1.- YTIC(I)
 1027   FORMAT ('set label',i4,' "',A,'" at graph',f8.3,','f8.3,
     &' offset character 0.5,0.')
        NLAB=NLAB+1
    2 CONTINUE
      XFAC=1.-ABS(XPROJ)
      DO 3 I=1,6
        WRITE (IPLO,1021)NLAB, (XLAB(I)(1:LENGT(XLAB(I)))),
     &  XORIG + (XFAC*XTIC(I)),OFFTC
 1021 FORMAT ('set label',i4,' "',A,'" at graph',f8.3,','f8.3,
     &' offset character -1.3,0.')
        nlab=nlab+1
    3 continue
C arroW 1 POSITION
      XSTART=XORIG
      YSTART=ARR1Y
      XEND=0.45*XFAC
      WRITE (IPLO,1025)  NLAB,XSTART,YSTART,XEND,0.0
      ROTATE=''
      WRITE (IPLO,1026) NLAB,(NINT(U(I,2)),I=1,3),XSTART+XEND,
     &YSTART,1.,0.,ROTATE;
      NLAB=NLAB+1
 1026 FORMAT ('set label ',I3,' "[',3I2,']" at graph ',F5.2,',',
     &F5.2,' offset character ',f5.1,',',f5.1,' ',A,f8.2)
C
C arroW 2 POSITION
      YSTART=1.
      XSTART=XORIG +ARR2X
      XEND=XSTART+(0.45*FRACXY)
      YEND=0.55
      ROTATE='rotate by '
      ANG=DEGREE(ATAN2(SINPHI,-COSPHI))
      WRITE (IPLO,1028)  NLAB,XSTART,YSTART,XEND,YEND
 1028 FORMAT ('set arrow ',I3,' from graph ',F5.2,',',F5.2,' to ',
     &'graph ',F5.3,',',F5.3)
       XOFF=-0.052*CHGRAF(1)
       YOFF=2.3*CHGRAF(2)
       XR= XOFF +YOFF*FRACXY
       YR= YOFF
      WRITE (IPLO,1026)NLAB,(NINT(U(I,1)),I=1,3),XEND+XR,
     &YEND -YR,0.,0.,ROTATE,ANG
      NLAB=NLAB+1
C
C PLOT ATOM POSITIONS IF REQUIRED
      IF (NLABS.GT.0)  THEN
        IF (NFOUND.EQ.0)  CALL ATMPLT(OUTLIM(1,3))
        LFOUND=0
        DO 30 IL=1,NLABS
          IF (FOUNDL(IL)) LFOUND=LFOUND+1
   30   CONTINUE
        DO 4 NL=1,NFOUND
           IL=LABNO(NL)
          IF (.NOT.FOUNDL(IL))  GO TO 4
          SYMSZ=SYSIZE(IL)/WIDMAP
C Transform positions from MAP to 'GRAPH' coordinates
          XPOS=TMAP(1,1)*POSLAB(1,NL)+ TMAP(1,2)*POSLAB(2,NL) +
     &    TMAP(1,3)
          YPOS=TMAP(2,1)*POSLAB(1,NL) + TMAP(2,2)*POSLAB(2,NL) +
     &    TMAP(2,3)
          CALL GNUSYM(NLAB,LSYMB(IL),SYMSZ,XPOS,YPOS,MCOLOR(IL),
     &    FILL(IL),ASPCTM,PS)
          NLAB=NLAB+1
    4   CONTINUE
      ENDIF
      FIRST=.FALSE.
C
C Angstrom marker
      AMIDPT=(XORIG + XPROJ) + (0.5*WIDBOX)
      ALEN=0.5*((1./WIDMAP )- ANGGAP)
      XSTART=AMIDPT - 0.5*ANGGAP
      YSTART= OFFANG
      WRITE (IPLO,1025) NLAB, XSTART,YSTART,-ALEN,0.
      XSTART=AMIDPT + 0.5*ANGGAP
      NLAB=NLAB+1
      WRITE (IPLO,1025) NLAB, XSTART,YSTART,ALEN,0.
 1025 FORMAT ('set arrow ',I3,' from graph ',F5.2,',',F5.2,' rto ',
     &'graph',F5.2,',',F5.2)
      WRITE (IPLO,1030) NLAB,AMIDPT,YSTART,-0.8,0.0
 1030 FORMAT ('set encoding iso_8859_1'/'set label ',I2,
     &' "1{\305}" at graph ',F5.2,',',F5.2,' offset character ',
     &f5.1,',',f5.1)
      NLAB=NLAB+1
C Make symbol key below the map
       WIDKEY=FLOAT(LFOUND)*WIDLAB
      IF (WIDKEY .GT.1.0)  CALL ERRMES(1,0,
     &'Key Width greater than 1  need a second row')
C START OF KEYBOX X IN GRAPH COORDS
      XSTART=AMIDPT-0.5*WIDKEY
      YSTART= OFFANG
      X=XSTART
      Y=OFFAT
      DO 6 IL=1,NLABS
        IF (.NOT. FOUNDL(IL)) GO TO 6
        SYMSZ=SYSIZE(IL)/WIDMAP
        CALL GNUSYM(NLAB,LSYMB(IL),SYMSZ,X+2.*symsz,Y,MCOLOR(IL),
     &  FILL(IL),ASPCTM,PS)
        NLAB=NLAB+1
        WRITE (IPLO,1029) NLAB,ATNAME(LABAT(IL)),X+3.*symsz,Y,0.,0.
 1029   format ('set label ',I2,' "',A,'" at graph ',F5.2,',',F5.2,
     &  ' offset character ',f5.1,',',f5.1)
        NLAB=NLAB+1
        X=X+WIDLAB
    6 CONTINUE
C
      WRITE (IPLO,1031) ((RANGES(I,J),j=1,2),i=1,2);
 1031 FORMAT ('set xrange [',F8.3,':',F8.3,']'/
     &'set yrange [',F8.3,':',F8.3,']')
      WRITE (IPLO,1032)STARTC,VALIM(2)
 1032 FORMAT('unset key'/'set cbrange [',f8.2,':'f8.2,']')
C
C Section to select palette with zero white when densities are positive and negative
       IF (POSNEG) THEN
        R=valim(1)/valim(2)
        IF (-VALIM(1) .GT.VALIM(2)) THEN
          A=0
          B=0.5*(1-(1/R))
        ELSE
          A=0.5*(1+R)
          B=0.5*(1-R)
        ENDIF
        WRITE (ITO,5500) VALIM(1),VALIM(2),R,A,B
 5500 format ('Contour factors ',5f8.3)
        WRITE (IPLO,1033) A,B
 1033   FORMAT ( 'a =',f6.2/' b ='F6.2/
     &  'set palette functions 2*(1.-(1.05*(a+b*gray)))/3.,'
     &  'abs(1-2*(a+b*gray)),(1.- 0.3*cos(pi*(a+b*gray))**20)'
     &  'model HSV')
C
      ELSE
        WRITE (IPLO,1034)
 1034   FORMAT ('set palette rgb  -21,-22,-23')
      ENDIF
      WRITE (IPLO,1035)
 1035 FORMAT ('p "cmap.dat" with image, "cont.dat" w l lt -1 lw 1.5');
C
C
C EXECUTE GNUPLOT COMMANDS
      ISTAT=GPLGO(IPLO)
      PLOTED=ISTAT.EQ.0
      CALL CLOFIL(IPLO)
      IF (PLOTED .AND. IDEV.EQ.1) THEN
        CALL ASK('HARD COPY REQUIRED? (y/n)')
        IF (SAYS('Y')) THEN
C OPEN  FILE FOR GNUPLOT COMMANDS
          IDEV=2
          DEVF=100./72.
          MESSAG='gplc'//TERM(2)(1:2)//'.gpl'
          IPLO=NOPFIL(226)
          WRITE (ITO,1002) MESSAG
          WRITE (LPT,1002) MESSAG
          go to 21
        ENDIF
      ENDIF
      RETURN
      END
C
C
C
C
      SUBROUTINE ROUND(VAL,NSIG,RVAL,I)
/IOUNIT/
      I=0
      V=VAL
      ALIM=10**NSIG
    1 IF (ANINT(V).LT.ALIM) THEN
        V=V*10
        I=I+1
        GO TO 1
      ENDIF
C     GO TO 3
    2 IF (ANINT(V).GT.ALIM) THEN
        V=V/10.
        I=I-1
        GO TO 2
      ENDIF
      FAC=10.**(I)
C      IVAL=NINT(V*/FAC)
      RVAL=ANINT(V)/FAC
      RETURN
      END
C
C
C
C
      SUBROUTINE TRIMF(VAL,LAB,N)
C
C Write VAl as a string of N chars
      CHARACTER *4 LAB(N)
      LOGICAL LONG
      DIMENSION VAL(N)
/IOUNIT/
      DO I=1,N
        LONG=(ABS(NINT(10.*VAL(N))-VAL(N)) .GT.0.001)
        IF (LONG) GO TO 1
      ENDDO
      WRITE (LAB(N),10) VAL(N)
    1 DO I=1,N
        IF (LONG) THEN
          WRITE (LAB(I),11) VAL(I)
        ELSE
          WRITE (LAB(I),10) VAL(I)
        ENDIF
   10 FORMAT (F3.1)
   11 FORMAT (F4.2)
      VAL(I)=FLOAT(I-1)*0.2
      ENDDO
      RETURN
      END

C
C
C





C
C
C
C
C LEVEL 8      SUBROUTINE PLOTIT(X,NP,SIZE)
      SUBROUTINE PLOTIT(X,NP,SIZE)
C
C *** PLOTIT by PJB Sep 87 ***
C
CX
CC 14B
CH Plots the graph of given vector y against x, with esds.
CA On entry X(3,NP) holds values to be plotted
CA    X(1,1:NP)= x values
CA    X(2,1:NP) = y values
CA    X(3,1:NP) = standard deviations of y values
CA On entry NP = number of points in graph
CA          SIZE a vector of dimension 2 holds the lengths of the x and
CA                 y axes in cms.
CD This subroutine sets up the plotter as well as drawing the graph.*
CO Output to a plotter whose characteristics are defined in the version of
CO PIGLET linked.
C
      DIMENSION X(3,NP),SIZE(2)
      DIMENSION XMAX(2),XMIN(2)
C
C  FIND MAXIMUM AND MINIMUM VALUES
      DO 3 J=1,2
      XMAX(J)=X(J,1)
      XMIN(J)=X(J,1)
      DO 2 I=2,NP
      IF (XMAX(J).LT.X(J,I)) XMAX(J)=X(J,I)
      IF (XMIN(J).GT.X(J,I)) XMIN(J)=X(J,I)
    2 CONTINUE
C  SET SCALE
    3 CALL GETSCL(XMIN(J),XMAX(J),J)
C
C  DRAW AXES ETC
      CALL PLOTO(SIZE(1),SIZE(2),.8,0)
C
      DO 1 I=1,NP
      CALL PLOTO(X(1,I),X(2,I),X(3,I),2)
    1 CONTINUE
C
      RETURN
      END
C
C
C
C
C LEVEL 7      SUBROUTINE PLOTO(XX,YY,ER,MODE)
      SUBROUTINE PLOTO(XX,YY,ER,MODE)
C
C *** PLOTO updated by PJB/JCM 10 Jun 88 ***
C
CX
CC 14B
CH A multi-purpose graph-drawing routine.
CA On entry XX and YY are x and y coordinates whose meaning is defined by MODE:
CA MODE=0 Set up to draw a graph in which the lengths of the axes are x, y.
CA     >0 Line drawing: move the "pen" from its current position to x, y.
CA        If MODE = -1 the "pen" is down
CA                = -2 a dashed line is drawn. The dash interval is ER.
CA                = -3 the "pen" is up
CA        If -MODE > 10 and < 21 the symbol ABS(MODE+10) is drawn at
CA                   intervals of ER.
CA MODE>0 Plot the point x,y with an error bar of length ER. The value of
CA           MODE defines the symbol to be plotted.
CA           MODE = 1 square
CA           MODE = 2 triangle, apex up
CA           MODE = 3 triangle, apex down
CA           MODE = 4 hexagon, which if small will look like a circle
CA           MODE = 5 cross like x
CA           MODE = 6 cross like +
CA           MODE = 7 cross like x with top and bottom (egg-timer)
CA           MODE = 8 cross like x with sides (butterfly)
CA           MODE = 9 diamond
CP The vector X(I,J) held in COMMON /PLTS/ defines how the graph will be drawn
CP     I=1 for x-axis, I=2 for y-axis.
CP         J=1  length of axis in user units
CP         J=2  length of axis in cms.
CP         J=3  division of axis in user units
CP         J=4  minimum value in user units
CP         J=5  position of axis to be plotted
CP GETSCL should be called for both x and y axes, to define the ranges of
CP values to plot.
C
      DIMENSION YC(2),Y(2),XO(2),IPNT(2),ICH(2),AM(2,3)
/ADASH/
/IOUNIT/
/PLODAT/
/PLTRAN/
/PLTS/
/PLOTCH/
/SCRACH/
      EQUIVALENCE (Y(1),A),(Y(2),B)
C
      IF (MODE) 1,2,3
C
C  MODE=0 SET UP AND DRAW AXES
C
C  GET HOLD OF PLOTTER
    2 CALL PIGLET(0.,0.,0)
C  SET DASH LENGTH
      DASH=0.5
C  IF ABLE, ACCEPT TITLE (IF NOT, IT MUST BE SET UP BEFORE ENTRY):
      CALL ASK('Give title (up to 80 characters)')
      ITEXT=ICARD
C
C  SET LENGTHS OF AXES IN CMS
      X(1,2)=XX
      X(2,2)=YY
C  DETERMINE NUMBER OF FIGURES BEFORE AND AFTER DECIMAL POINT FOR
C  LABELLING AXES
      DO 21 I=1,2
      IPNT(I)=1-ISIG(I)
      ICH(I)=2+IABS(ISIG(I))
      IF (ISIG(I).EQ.0) ICH(I)=ICH(I)+1
      IF (ISIG(I).GT.1) ICH(I)=ICH(I)-1
C  SET SCALE OF GRAPH
      S(I)=X(I,2)/X(I,1)
   21 CONTINUE
C  LIMITING CHARACTER SIZE
      CLIM=1.5
      IF (ER.NE.0) CLIM=ER
C  NORMALLY CHARACTERS LABELLING AXES SHOULD TAKE HALF THE SPACE BETWEEN
C  LABELLED DIVISIONS IN THE X DIRECTION
      CH2=S(1)*X(1,3)/(2.*FLOAT(ICH(1)))
      IF (CH2.GT.CLIM) CH2=CLIM
C  ALEN IS THE LENGTH IN USER UNITS OF THE FIGURES ON THE Y-AXIS
      ALEN=(ICH(2)+3)*CH2/S(1)
C  SET XO TO BE MINIMUM VALUE IN USER UNITS INCLUDUNG SPACE FOR NUMBERS
      DO 31 I=1,2
      XO(I)=AMIN1(X(I,5)-ALEN,X(I,4))
   31 ALEN=4.*CH2/S(2)
C
C  SPACE FOR TITLE AND CHARACTER SIZE FOR TITLE
      ITITLE=LENGT(ITEXT)
      CALL KANGA2(0.,0.,TLEN,ITEXT,-ITITLE)
      TLEN=TLEN+2.*CHUNIT
      CH1=X(1,2)*CHUNIT/TLEN
      CLIM=1.5*CH2
      IF (CH1.GT.CLIM)CH1=CLIM
C  CENTRE TITLE
      ALEN=CH1*TLEN/CHUNIT
C      ALEN=((X(1,1)-XO(1))*S(1)-ALEN)/2.
       ALEN=BORDER+(X(1,4)-XO(1))*S(1)+(X(1,2)-ALEN)/2
C  ALEN IS DISTANCE IN CMS OF START OF TITLE FROM LH EDGE
C  SET SIZES OF OTHER MARKS
C  XS FOR DASHES ON AXES
      XS=0.4*CH2
C  YS FOR TOP AND BOTTOM OF ERROR BARS
      YS=0.6*CH2/S(1)
      CH=0.5*CH2
C
C  CHARACTER 1 SPACE - FOR TITLE
      AM(1,1)=CH1/CHUNIT
      AM(2,2)=AM(1,1)*ASPECT
      AM(1,2)=0.
      AM(2,1)=0.
      AM(1,3)=BORDER+ALEN
      AM(2,3)=BORDER
      CALL PLTRIN(AM,5,3)
C
C  CHARACTER 2 ROTATED BY 90 DEGREES - FOR LABEL ON Y AXIS
      A1=CH2/CHUNIT
      A2=A1*ASPECT
      AM(1,2)=-A1
      AM(2,1)=A2
      AM(1,1)=0.
      AM(2,2)=0.
      AM(1,3)=BORDER-XO(1)*S(1)
C  CHANGE HERE WHEN NO TITLE
C      AM(2,3)=BORDER-XO(2)*S(2)+5*CH1
      AM(2,3)=BORDER-XO(2)*S(2)+2.*CH1
      CALL PLTRIN(AM,6,3)
C  CHARACTER 2 SPACE - FOR NUMBERS ON AXES AND X AXIS LABEL
      AM(1,1)=A1
      AM(2,2)=A2
      AM(1,2)=0.
      AM(2,1)=0.
      CALL PLTRIN(AM,7,3)
C
C  GRAPH SPACE
      AM(1,1)=S(1)
      AM(2,2)=S(2)
      CALL PLTRIN(AM,4,3)
C  SIZE OF PLOT
      PW=X(1,2)+(X(1,4)-XO(1))*S(1)+(ICH(1)+3)*CH2+3.*BORDER
      PH=X(2,2)+(X(2,4)-XO(2))*S(2)+2.*BORDER+5.*CH1
C
      CALL PIGLET(PW,PH,999)
      CALL PIGLET(0.,0.,-1)
C
C  WRITE TITLE
      CALL SPCSET(5)
      IF (ITITLE.NE.0) THEN
      CALL KANGA2(CHUNIT,0.5*CHUNIT,TLEN,ITEXT,ITITLE)
      CALL FRAME(0.,0.,TLEN+2.*CHUNIT,2*CHUNIT)
      ENDIF
C
C  LABEL AXES
      CALL SPCSET(6)
      X1=X(1,5)
      X2=X(2,1)+X(2,4)-X(2,3)
      CALL PLCONV(X1,X2,4,YC(1),YC(2),6)
      YC(2)=YC(2)+(ICH(2)+1)*CHUNIT
      N=LENG(NTEX(2),15)
      IF (N .GT. 0) THEN
        CALL KANGA2(YC(1),YC(2),ALEN,NTEX(2),-N)
        YC(1)=YC(1)-ALEN
        CALL KANGA2(YC(1),YC(2),ALEN,NTEX(2),N)
      ENDIF
      CALL SPCSET(7)
      X1=X(1,1)+X(1,4)-X(1,3)
      X2=X(2,5)
      CALL PLCONV(X1,X2,4,YC(1),YC(2),7)
      N=LENG(NTEX(1),15)
      IF (N .GT. 0) THEN
        CALL KANGA2(YC(1),YC(2),ALEN,NTEX(1),-N)
        YC(1)=YC(1)-ALEN
        YC(2)=YC(2)-3*CHUNIT
        CALL KANGA2(YC(1),YC(2),ALEN,NTEX(1),N)
      ENDIF
C NOW LABEL THE DIVISIONS
      L=2
      DO 22 J=1,2
      VAL0=X(J,4)
      II=NDIVS(J,1)/5+NDIVS(J,2)/5 + 1
      NLFT=IFIX((ABS(X(J,4)/X(J,3)))+.001)
      VAL=SIGN(FLOAT(NLFT),X(J,4))*X(J,3)
C CASE WHERE ALL VALUES ARE POSITIVE
      IF (VAL0-VAL .GT. .01*X(J,3)) VAL=VAL+X(J,3)
      Y(J)=VAL+X(J,3)
      Y(L)=X(L,5)
      CALL PLCONV(Y(1),Y(2),4,YC(1),YC(2),7)
      STEP=YC(J)
      Y(J)=VAL
      CALL PLCONV(Y(1),Y(2),4,YC(1),YC(2),7)
      YC(L)=YC(L)-1.5*CHUNIT
      STEP=STEP-YC(J)
C
      DO 4 I=1,II
      IF (ABS(X(J,5)-VAL).LT.10E-4) GO TO 6
      IF (ABS(VAL).LT. 10E-5) GO TO 6
      CALL FETTLE(VAL,IW,IP)
      CALL NUMA1(VAL,IW,IP,IW,ITEXT)
      IW2=IW/2
      CALL KANGA2(YC(1)-IW2*CHUNIT,YC(2),ALEN,ITEXT,IW)
    6 YC(J)=YC(J)+STEP
      VAL=VAL+X(J,3)
    4 CONTINUE
      L=1
   22 CONTINUE
C
C  DRAW AXES
      L=2
      CALL SPCSET(4)
      DO 23 J=1,2
      YO=X(L,5)
      Y2=XS/S(L)
      Y1=YO+Y2
      Y2=Y1+Y2
      II=NDIVS(J,1)+NDIVS(J,2) + 1
      STEP=X(J,3)/5.
      Y(L)=YO
      Y(J)=X(J,4)
      CALL KANGA1(A,B,3)
      Y(J)=Y(J)+AMOD(X(J,4),STEP)
C
      DO 5 I=1,II
      CALL KANGA1(A,B,2)
      Y(L)=Y1
      BIT=X(J,3)/50.
      BITTLE=BIT/10.
      TEST=ABS(AMOD(ABS(Y(J))+BITTLE,X(J,3)))
      IF (TEST.LT.BIT) Y(L)=Y2
      CALL KANGA1(A,B,1)
      Y(L)=YO
      CALL KANGA1(A,B,3)
      Y(J)=Y(J)+STEP
    5 CONTINUE
      L=1
   23 CONTINUE
C
C
C USE THIS IF WANT A FRAME:
C      CALL SPCSET(2)
C      CALL FRAME(0.,0.,PW,PH)
      GO TO 100
C
C  ENTRY TO PLOT A POINT WITH AN ERROR BAR
    3 CALL SPCSET(4)
      A=XX
      B=YY
      X1=A-0.5*YS
      X2=X1+YS
C MAKE THE SYMBOLS BIGGER
      SIZ=1.5*YS*S(1)
      IF (ER.EQ.0) GO TO 20
      CALL KANGA3(A,B,SIZ,MODE)
      IF (2.*ER*S(2) .LT. SIZ) GO TO 100
      B=B+ER
      CALL KANGA1(X1,B,3)
      CALL KANGA1(X2,B,2)
      CALL KANGA1(A,B,3)
      B=B-2*ER
      CALL KANGA1(A,B,2)
      CALL KANGA1(X1,B,3)
      CALL KANGA1(X2,B,2)
      GO TO 100
C
C  ENTRY TO PLOT A VECTOR
    1 CALL SPCSET(4)
      IF (MODE.GE.-3) GO TO 40
C  SET UP FOR DASHED LINES
      DASH=ER
   40 J=IABS(MODE)
      IF (J.EQ.3) J=0
      CALL DPLOT(XX,YY,J)
      GO TO 100
C
C  CALCULATED POINT
   20 CALL KANGA3(A,B,SIZ,MODE)
 100  RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE PLREAD(H,FBUF,IEND)
      SUBROUTINE PLREAD(H,FBUF,IEND)
C
C *** PLREAD corrected by PJB C4.7 March 2008 ***
C
CX
CC 2A
CH Multiple entry routine to read SNP data for ARISNP or ARRSNP
CD Expects IICD3 to have been obeyed to read the data type DTYP. The following
CD formats are defined:
CD    DTYP =11 SNP IGOR data floating indices (ext .POL)
CD             Data read: H,3(PWORD,pol,dpol))
CD             FORMAT (3F8.3,3(A5,F10.3,F9.3))
CD    DTYP =12 SNP MAD 1 data floating indices (ext .POL)
CD             Data read: Numor H,Pin,Pout,IP,Peff,Pol,DPol,
CD             FORMAT (I6,3F6.2,2A3,I4,1x,3f8.3)
C
      DIMENSION H(3),K(3),FBUF(10),POL(9),HSAVE(3)
      CHARACTER *125 DATA,LABEL*27
      LOGICAL IEND,MINUS
      CHARACTER *40 QUERY(2)
      CHARACTER *4 EXT(2)
      CHARACTER*10 FILNOM
C
/ARRDAT/
/CARDRC/
/IOUNIT/
/SCRACH/
      DATA LABEL/'XX XY XZ YX YY YZ ZX ZY ZZ '/
      SAVE ISAVE,POL,NUML,HSAVE
C
      DATA QUERY/'File with reflections to be arranged',
     &'Next reflection file (or c/r to end)'/
      DATA EXT/'.pol','.pol'/
C
        ISTART=2
        IF (IEND) THEN
        ISAVE=0
        NUM=0
        NUML=0
        ISTART=1
        WRITE (LPT,2010) IFOR(1)
 2010   FORMAT (/' Input type',I3,' - ')
        IF (IFOR(1) .EQ.0)  GO TO 10
        IF (IFOR(1) .LT. 11)  GO TO 98
        GO TO (11,12) , IFOR(1)-10
C
   98   WRITE (ITO,2010) IFOR(1)
        CALL MESS(ITO,0,'Not allowed for SNP data')
        CALL MESS(LPT,0,'Not allowed for SNP data')
        IERR=IERR+1
        GO TO 99
C
  10    CALL MESS(LPT,0,'User to supply own routine QARRIN')
        GO TO 3
C
   11   CALL MESS(LPT,0,'SNP data, floating indices,IGOR format/'//
     &   'H,N(Pword,Pol,DPol) with N=1,3:'//
     &   ' FORMAT (3F8.3,3(A5,F10.3,f9.3))')
        GO TO 3
C
   12   CALL MESS(LPT,0,'SNP data, floating indices,MAD format/')
        CALL MESS(LPT,0,' Numor H,Pin,Pout,IP,Peff,Pol,DPol,I,dI,T')
        CALL MESS(LPT,0,' FORMAT (I6,3F6.2,2a3,I4,1x,3f8.3,2f8.1,f8.2')
        GO TO 3
      ENDIF
C
C  READ LONG LINES
    1 IF (ISAVE .GT.1) GO TO (57,61) ,IFOR(1)-10
      READ (LUNI,1000,END=2) DATA
1000  FORMAT (A125)
C Skip lines with warnings
      IF (INDEX(DATA,'*') .GT.0) GO TO 1
C IGNORE BLANK LINES:
      L=LENGT(DATA)
      IF (L .LT.6) GO TO 1
      GO TO (51,61) , IFOR(1)-10
C
C SKIP INTENSITY AND T DATA AT END OF LINE
   51 L=L-42
      READ (DATA,1001) HSAVE
 1001 FORMAT (3F8.3)
      LBUF=27
      N=1
      NUML=NUML+10
   52  IP=0
      MINUS=(DATA(LBUF:LBUF) .EQ.'-')
      LBUF=LBUF+1
      JBUF=LBUF
      JJ=INDEX(LABEL,DATA(LBUF:LBUF+2))
      LBUF=LBUF+3
      IP=(JJ+2)/3
      IF (MINUS) IP=-IP
      POL(N+2)=FLOAT(IP)
      READ ( DATA(LBUF:LBUF+18),1002) POL(N),POL(N+1)
 1002 FORMAT (F10.3,F9.3)
      LBUF=LBUF+20
      N=N+3
      IF (LBUF.GT. L) GO TO 55
      GO TO 52
   55 ISAVE=N
   57 ISAVE=ISAVE-3
      CALL GMEQ(POL(ISAVE),FBUF(2),3,1)
      NUM=NUML+Isave/3

      write (ito,5000) ISAVE,NUM,(POL(i),i=ISAVE,isave+2)
 5000 format (I3,i6,2f8.3,f6.0)
      call gmeq(hsave,h,3,1)
      GO TO 31
C
C MAD LOGFILE  DATA
   61 READ (DATA,1003) NUM,H,IP,FBUF(2),FBUF(3)
 1003 FORMAT (I6,3F6.2,6X,I4,9X,2F8.3)
      IP=IP+1
      IF (IP.GT.9) IP=9-IP
      FBUF(4)=FLOAT(IP)
      GO TO 31
C
      CALL INDFLO(H,K)
  31  IF (NREF1 .EQ.-1) NREF1=NUM
      FBUF(1)=FLOAT(NUM)
      NREFL=NUM
      GO TO 100
C
C START READING (NEXT) INPUT DATA FILE:
   2  WRITE (LPT,2005) NREF1,NREFL,FILNOM(LUNI)
2005  FORMAT (/' Reflection numbers ',I8,' to ',I8,' read from file ',
     &A10)
      CLOSE(LUNI)
   3  NUMOR=0
      MESSAG=' '
      NREF1=-1
      NAMFIL=EXT(IFOR(1)-10)
      WRITE (MESSAG,2000) QUERY(ISTART)
2000  FORMAT (A40)
      LUNI=NOPFIL(111)
      IF (LUNI .NE. 0) THEN
        IEND=.FALSE.
        ISTART=2
        GO TO 1
      ENDIF
C
  99  IEND=.TRUE.
 100  RETURN
      END
C
C
C
C
C LEVEL 2      SUBROUTINE PLTRIN(PMAT,N,M)
      SUBROUTINE PLTRIN(PMAT,N,M)
C
C *** PLTRIN by JCM 4 Apr 85 ***
C
CX
CC 14B
CH Defines a new coordinate transformation for plotting.
CA On entry PMAT is a 2 X 3 real matrix which defines the coordinate system
CA N with respect to M.
CA          PMAT(1:2,1:2) gives the scaling and rotation
CA          PMAT(1:2,3) gives the origin of space N with respect to that of
CA                      space M, in M's cordinates.
CA M must be greater than N
C
CD PMAT and N will be written as items number N-1 in PMTRIX and NTRAN in
CD COMMON /PLTRAN/. MAXSP in /PLTRAN/ holds the largest N yet given.
C
      DIMENSION PMAT(2,3)
/IOUNIT/
/PLTRAN/
C
      IF (M .LT. N .AND. M .GT. 0) GO TO 1
      WRITE (LPT,3000) N,M
      WRITE (ITO,3000) N,M
3000  FORMAT (/' ERROR ** TRYING TO TRANSFORM FROM SPACE',I4,
     & ' TO SPACE',I4,' IN PLTRIN')
      STOP
C
   1  CALL GMEQ(PMAT,PMTRIX(1,1,N-1),2,3)
      NTRAN(N-1)=M
      IF (N .GT. MAXSP) MAXSP=N
      RETURN
      END
C
C
C
C
C LEVEL 7      SUBROUTINE PLTTXT
      SUBROUTINE PLTTXT
C
C *** PLTTXT updated by JCM 29 Apr 92 ***
C
CX
CC 5B
CH Plots a block of explanatory text under a plotted Fourier map.
C
CD Plots the block of text which lists all the necessary details for
CD identification of the map.  Does this in what is for the Fourier plotting
CD "character 1 space", space number 5.
C
CO Outputs to graphical device as set up by PIGLET
C
      CHARACTER *10 MTYP(5)
      CHARACTER *1 IXCHR(2)
      CHARACTER *52 LINE1
      CHARACTER *58 LINE2
      CHARACTER *63 LINE3
      CHARACTER *50 LINE4
      CHARACTER *45 LINE5
      CHARACTER *22 LINE6
      CHARACTER *75 LINE7
      DIMENSION ITYPE(7)
/MAPDA/
/PLODAT/
      DATA IXCHR/'X','Y'/
      DATA MTYP/'  FCALC','   FOBS','FOBS-FCALC',' FOBS**2',
     & 'SIGMA FOBS'/
      DATA LINE1/'    FOURIER PROJECTION DOWN'/
      DATA LINE2/'  FOURIER SECTION AT           ON'/
      DATA LINE3/'   parallel to                         from         to
     & '/
      DATA LINE4/'Coefficients are            multiplied by'/
      DATA LINE5/'    and averaged over a cube of edge'/
      DATA LINE6/'No resolution function'/
      DATA LINE7/'Bounded section from          to          on'/
      DATA ITYPE/1,2,2,3,3,4,5/
C
C WE SHOULD BE NOW WORKING IN CHAR 1 SPACE:
      CALL SPCSET(5)
C
C BLACK PEN:
      CALL PIGLET(0.,0.,-1)
C
C COLLECT LENGTH OF LONGEST LINE FOR FRAME SIZE:
      A=0.
C
C LINES OF TEXT:
      IF (NDIM.EQ.3) GO TO 3
      IF (NDIM.EQ.4) GO TO 12
      DO 4 I=1,3
      CALL FETTLE(U(I,3),IW,IF)
   4  CALL NUMA1(U(I,3),IW,IF,8,LINE1(21+8*I:28+8*I))
      CALL KANGA2(CHUNIT,8.5*CHUNIT,TEMP,LINE1,52)
      IF (TEMP .GT. A) A=TEMP
      GO TO 5
    3 DO 6 I=1,3
      CALL FETTLE(U(I,3),IW,IF)
    6 CALL NUMA1(U(I,3),IW,IF,8,LINE2(27+8*I:34+8*I))
      CALL FETTLE(OUTLIM(1,3),IW,IF)
      CALL NUMA1(OUTLIM(1,3),IW,IF,9,LINE2(22:30))
      CALL KANGA2(CHUNIT,8.5*CHUNIT,TEMP,LINE2,58)
      IF (TEMP .GT. A) A=TEMP
      GO TO 5
C
  12  DO 13 I=1,3
      CALL FETTLE(U(I,3),IW,IF)
      IP=38+8*I
   13 CALL NUMA1(U(I,3),IW,IF,8,LINE7(IP:IP+7))
      CALL FETTLE(OUTLIM(1,3),IW,IF)
      CALL NUMA1(OUTLIM(1,3),IW,IF,9,LINE7(22:30))
      CALL FETTLE(SECEND,IW,IF)
      CALL NUMA1(SECEND,IW,IF,9,LINE7(33:41))
      CALL KANGA2(CHUNIT,8.5*CHUNIT,TEMP,LINE7,64)
      IF (TEMP .GT. A) A=TEMP
C
C LINES DESCRIBING AXES:
   5  Y=6.3*CHUNIT
      DO 1 J=1,2
      DO 8 I=1,3
      CALL FETTLE(U(I,J),IW,IF)
    8 CALL NUMA1(U(I,J),IW,IF,8,LINE3(7+8*I:14+8*I))
      DO 9 I=1,2
      CALL FETTLE(OUTLIM(I,J),IW,IF)
    9 CALL NUMA1(OUTLIM(I,J),IW,IF,7,LINE3(33+11*I:39+11*I))
      LINE3(2:2)=IXCHR(J)
      CALL KANGA2(CHUNIT,Y,TEMP,LINE3,62)
      IF (TEMP .GT. A) A=TEMP
    1 Y=Y-CHUNIT*2.
C
C COEFFICIENT TYPE AND SCALE FACTOR:
      J=ITYPE(MODEF)
      CALL FETTLE(SCALF1,IW,IF)
      CALL NUMA1(SCALF1,IW,IF,9,LINE4(42:50))
      LINE4(18:27)=MTYP(J)
      CALL KANGA2(CHUNIT,2.3*CHUNIT,TEMP,LINE4,50)
      IF (TEMP .GT. A) A=TEMP
C
C DECIDE ON MESSAGE ABOUT RESOLUTI0N FUNCTION
      IF (DELTA .NE. 0.) GO TO 11
      CALL KANGA2(8.*CHUNIT,CHUNIT/2.,TEMP,LINE6,22)
      IF (TEMP .GT. A) A=TEMP
      GO TO 101
  11  TWODEL=2.*DELTA
      CALL FETTLE(TWODEL,IW,IF)
      CALL NUMA1(TWODEL,IW,IF,8,LINE5(38:45))
      CALL KANGA2(CHUNIT,0.3*CHUNIT,TEMP,LINE5,45)
      IF (TEMP .GT. A) A=TEMP
C
C DRAW BOXES TO BE ROUND EXPLANATORY TEXT:
 101  CALL FRAME(0.,0.,A+2.*CHUNIT,10.*CHUNIT)
      CALL KANGA1(0.,4.*CHUNIT,3)
      CALL KANGA1(A+2.*CHUNIT,4.*CHUNIT,2)
      CALL KANGA1(A+2.*CHUNIT,8.*CHUNIT,3)
      CALL KANGA1(0.,8.*CHUNIT,2)
      RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE PMTINV(A,B)
      SUBROUTINE PMTINV(A,B)
C
C *** PMTINV by JCM 18 May 84 ***
C
CX
CC 14B
CH Specialist routine to invert a 2x3 matrix, such as those which transform
CH plotting coordinates from one space to another.
C
CA On entry A holds a 2x3 matrix as A(2,3)
CA On exit  B(2,3) holds the matrix representing the inverse transformation.
C
      DIMENSION A(2,3),B(2,3)
      D=1./(A(1,1)*A(2,2)-A(1,2)*A(2,1))
      B(1,1)=A(2,2)*D
      B(1,2)=-(A(1,2)*D)
      B(1,3)=(A(1,2)*A(2,3) - A(1,3)*A(2,2))*D
      B(2,1)=-(A(2,1)*D)
      B(2,2)=A(1,1)*D
      B(2,3)=(A(1,3)*A(2,1)-A(1,1)*A(2,3))*D
      RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE PMTMUL(A,B,C)
      SUBROUTINE PMTMUL(A,B,C)
C
C *** PMTMUL by JCM 1 May 84 ***
C
CX
CC 14B
CH Specialist routine to multiply together two 2x3 matrices, such as those
CH which transform plotting coordinates from one space to another.
C
CA On entry A and B are 2x3 real arrays
CA On exit  C represents the result of performing B then A.
C
      DIMENSION A(2,3),B(2,3),C(2,3)
C
      C(1,1)=A(1,1)*B(1,1)+A(1,2)*B(2,1)
      C(2,1)=A(2,1)*B(1,1)+A(2,2)*B(2,1)
      C(1,2)=A(1,1)*B(1,2)+A(1,2)*B(2,2)
      C(2,2)=A(2,1)*B(1,2)+A(2,2)*B(2,2)
      C(1,3)=A(1,1)*B(1,3)+A(1,2)*B(2,3)+A(1,3)
      C(2,3)=A(2,1)*B(1,3)+A(2,2)*B(2,3)+A(2,3)
      RETURN
      END
C
C
C
C
C LEVEL 4      SUBROUTINE POLAXE(H,PAXMAT)
      SUBROUTINE POLAXE(H,PAXMAT)
C
C *** added to library by PJB  August 2016 ***
C
CC 17C
C
CH Matrix for transformation of crystallographic to polarisation axes
CP SETDC to define the measurement geometry
CA H(3) The reflection to define the x-axis (scattering vector)
CA The matrix PAXMAT(3,3) relating orthogonal crystallographic and
CA polarisation axes x // H, z //um
      DIMENSION H(3),PAXMAT(3,3)
/DGEOM/
C
C this sets z diffractometer // z polarisation
      call gmtran(um,paxmat,3,3)
      CALL ORTHO(H,PAXMAT(1,1),2)
      CALL UNIVEC(PAXMAT(1,1),STHL)
C  GET Y POLARISATION AXIs
      CALL VECPRD(PAXMAT(1,3),PAXMAT(1,1),PAXMAT(1,2))
      CALL UNIVEC(PAXMATr,D)
C IF Z NOT PERPENDICULAR MAKE IT SO
      IF (ABS(D-1).GT..0001)
     &CALL VECPRD(PAXMAT(1,1),PAXMAT(1,2),PAXMAT(1,3))
      CALL TRANSQ(PAXMAT,3)
      RETURN
      END
C
C
C
C
C LEVEL 4      SUBROUTINE POLUNI
      SUBROUTINE POLUNI
C
C *** POLUNI by PJB 8 Aug 83 ***
C
CX
CC 1A
CH A specialist routine to "polish" the edges of a found asymmetric unit
CH by specifying exactly how its faces and edges should be treated.
C
CP POLUNI is called from the end of SYMUNI, and would not be useful
CP outside this context.
C
CD Sets the array MARK in /GUNIT/ to indicate the exact treat ment of
CD faces and edges of the reciprocal cell asymmetric unit in order to
CD deduce the multiplicites of reflections occurring on them.
C
      LOGICAL BINDIG
/CONSTA/
/FRIED/
/FUNIT/
/GUNIT/
/IOUNIT/
/NSYM/
%      COMMON /SCRAT/AXI(3,%SYMO%,2),MIRROR(%SYMO%),D(3,3),PL1(3),PL2(3),PL3(3),
     & HT(3),ASY(3,4),NSTAT(4),NOPL,NICE,VOL,MOP1,MOP2
/SYMTAB/
C
C  CLEAR MARK TO 1
      DO 10 I=1,3
      DO 10 J=1,2
   10 MARK(I,J)=1
C
C  DEAL WITH P1 AND P-1
      IF ((NOP.EQ.1) .AND. .NOT. FRIEDL) GO TO 100
      IF (NOPC.GT.1) GO TO 14
C  FIND ANY LINE IN THE PLANE
      CALL INVENT(ASYM(1,1),ASYM(1,1),BSYM(1,1))
      CALL VECPRD(ASYM(1,1),BSYM(1,1),BSYM(1,2))
      MARK(1,1)=4
      GO TO 100
C
C  WORK OVER SYMMETRY ELEMENTS
   14 DO 1 N=2,NOPC
      IF (IABS(NORD(N)).GT.100) GO TO 1
      IORD=IABS(NORD(N))
      IF (MIRROR(N).EQ.0) GO TO 2
C
C  PROCEDURE IF MIRROR PLANE,EITHER END OF AXIS WILL DO
      DO 15 IR=1,2
      CALL EQVEC(ASYM,AXI(1,N,1),NASYM,M,0)
      IF (M.GT.NASYM) GO TO 15
C
C  MARK PLANE AS MIRROR
      MARK(M,1)=2
      GO TO 16
   15 CALL GMREV(AXI(1,N,1),AXI(1,N,1),3,1)
C
C  JUMP IF NOT A DIAD AXIS
   16 IF(NORD(N).EQ.-2 .AND. .NOT. FRIEDL ) GO TO 1
C
C  PROCEDURE FOR SYMMETRY AXES
    2 CALL INBOX(AXI(1,N,2),IN)
      IF (IN) 1,3,4
C
C  SYMMETRY AXIS INSIDE UNIT - ERROR
   3  WRITE (LPT,3000)(AXI(I,N,1),I=1,3),N
      WRITE (ITO,3000)(AXI(I,N,1),I=1,3),N
3000  FORMAT (/' ERROR ** IN POLUNI - SYMMETRY AXIS ',3F5.1,
     & ' INSIDE UNIT - OPERATOR NUMBER',I4)
      STOP
C
C  AXIS IS ON UNIT
    4 IF (IN.GT.10) GO TO 5
      IF (IORD.GT.2) GO TO 3
C
C  HERE FOR DIAD AXIS ON A PLANE - NOT AT CORNER
      CALL VECPRD(ASYM(1,IN),AXI(1,N,2),BSYM(1,IN))
      MARK(IN,1)=3
C  DECIDE WHICH EDGE TO INCLUDE
      IF (NASYM .GT. 2) GO TO 8
      MARK(3,2)=-IABS(MARK(3,2))
      GO TO 1
   8  M1=MOD(IN,3)+1
      M2=MOD(M1,3)+1
      M=M1
      L=M2
      IF (SCALPR(BSYM(1,IN),EDGE(1,M)).GT.0.) GO TO 13
      M=M2
      L=M1
C  CHECK MARK NOT ZERO ALREADY
   13 IF (MARK(L,2).NE.0) MARK(M,2)=0
      GO TO 1
C
C  AXIS ON EDGE
    5 IN=IN-10
      IF (NASYM.GT.2) GO TO 11
      IF (IORD.NE.3 .OR..NOT.FRIEDL) GO TO 11
C  SPECIAL BLISTER FOR BAR 3 AXIS
      MARK(IN,2)=-(3*IABS(MARK(IN,2)))
      RANG=TWOPI/6.
      GO TO 9
   11 MARK(IN,2)=ISIGN(MARK(IN,2)*IORD,NORD(N))
      IF (MARK(IN,2).LT.0 .AND. .NOT. FRIEDL) MARK(IN,2)=MARK(IN,2)/2
      IF (IORD.EQ.2) GO TO 1
      RANG=TWOPI/IORD
      IF (NASYM.EQ.2) GO TO 9
      IF (NORD(N) .LT. 0 .AND. .NOT. FRIEDL) RANG=RANG*2.
   9  IF (ABS(RANG-ANG(IN)).GT..0001) GO TO 1
      M=MOD(IN,3)+1
C  MARK POINTS ON PLANE AND AXIS NOT TO BE USED
      IF (NASYM.LT.3) GO TO 12
C  NO EDGES
C  IS AN EDGE ALREADY MARKED ZERO?
      M1=MOD(M,3)+1
      IF (MARK(M1,2).EQ.0) GO TO 12
C  IF THAT NOT ZERO MARK THE OTHER ONE
      MARK(M,2)=0
      M=M1
   12 MARK(M,1)=0
C
    1 CONTINUE
C
C  PUT IN EXTRA DIVISION IF A MIRROR PLANE GOES THROUGH AN EDGE
      IF (NASYM.LT.2) GO TO 100
C  NO EDGES:
      J=2
      K=3
      DO 7 I=1,3
      IF (MARK(I,1).EQ.2 .OR.MARK(J,1).EQ.2) MARK(K,2)=MARK(K,2)*2
      IF (NASYM.EQ.2) GO TO 100
      J=K
      K=I
    7 CONTINUE
  100 IF (BINDIG(IOUT,16)) THEN
        WRITE (LPT,4000) ((MARK(I,J),I=1,3),J=1,2),BSYM,EDGE
        WRITE (ITO,4000) ((MARK(I,J),I=1,3),J=1,2),BSYM,EDGE
 4000   FORMAT (/' MARK :',3I5,4X,3I5/' BSYM, EDGE :'/3(/3(1X,3F8.2/)))
      ENDIF
      RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE PRBLOK
      SUBROUTINE PRBLOK
C
C *** PRBLOK updated (blocks of up to 12) 3rd-Apr-2001 ***
C
CX
CC 6C
CH Prints a block of shifts in parameters all relating to the same atom
CH in LSQ applications involving structure parameters.
CP IBUFF in /ATBLOK/ is the number of shifts to be printed. The calling
CP routine APSHxx must control IBUFF and store shift information in the
CP arrays in /ATBLOK and /ATBLOC.
C
CD If IBUFF=0 exits.  Otherwise prints shifts across the page for one specific
CD atom as stored.  Sets IBUFF=0
C
CO Prints blocks of new parameter, esd, shift, old parameter, shift/esd
CO labelled appropriately.
C
      CHARACTER *65 FBUF
      CHARACTER *6 LABEL(4)
C
/ATBLOC/
/ATBLOK/
/IOUNIT/
C
      DATA LABEL/'   NEW','   ESD',' SHIFT','   OLD'/
C
      IF (IBUFF .EQ. 0) GO TO 100
      IF (IBUFF .GT.12) THEN
        CALL ERRMES(1,-1,'Too many parameters, only 12 can be printed')
        IBUFF=8
      ENDIF
C
      WRITE (LPT,2001) NAME,(IPNAME(II),II=1,IBUFF)
2001  FORMAT (/2X,A4,12(3X,A4,2X))
      FBUF(1:4) ='(A6,'
      J=5
      DO 1 II=1,IBUFF
      WRITE (FBUF(J:),2002) NSIGFG(PESD(II))
 2002 FORMAT ('F9.',I1,',')
      J=J+5
    1 CONTINUE
      FBUF(J-1:)=')'
      WRITE (LPT,FBUF) LABEL(1),(PNEW(II),II=1,IBUFF)
      WRITE (LPT,FBUF) LABEL(2),(PESD(II),II=1,IBUFF)
      WRITE (LPT,FBUF) LABEL(3),(PSHIFT(II),II=1,IBUFF)
      WRITE (LPT,FBUF) LABEL(4),(POLD(II),II=1,IBUFF)
      WRITE (LPT,2006) (PSESD(II),II=1,IBUFF)
2006  FORMAT (' SH/SD',12F9.5)
      IBUFF=0
 100  RETURN
      END
C
C
C
C
C LEVEL 7      SUBROUTINE PREFIN(PROGRM)
      SUBROUTINE PREFIN(PROGRM)
C
C *** PREFIN updated by JCM 28 Apr 92 ***
C
CX
CC 13A
CH Makes the Crystal Data File readable in a random order by writing it
CH to a scratch file.
CA On entry PROGRM is the A6 name of the calling program, to head the output
C
CD Creates a direct access file number IO10, writes to it the given
CD Crystal Data File as A80 records, and keeps an index so that subsequently
CD any "card" may be read or re-read as required.
CD
CD Sets ICDNO(1-26) to be the number of "cards" read for each letter, except Y
CD      and Z, which are passed through anywhere (printing out the Y).
CD Sets INREAD(1-26) to be the start record for each letter chunk.
CD Sets NTOTL to be the total number of records read.
CD Sets IERR=0 so that errors later may reset it.
CD
CD Also initialises system by a call to INITIL.  Jobs wishing to intervene
CD to change parameters must say, e.g.:
CD      CALL INITIL('NAME')
CD      change whatever wanted
CD      CALL PREFIN('NAME')
C
CD PREFIN reads "cards" labelled with a letter from A-Z in column 1,  from a
CD dataset called the "crystal data".  This is read from logical unit
CD ICRYDA, which may be assigned to a specific unit number in
CD the main program, or left unassigned so that the call to OPNFIL
CD will assign a unit number and ask interactively for a file name.
CD
CD    The "cards" give information about the current problem.
CD    Letters used so far are:
CD    A   atomic positions (read by ATOPOS)
CD    B   bond length and angle instructions (read by  main program BONDS)
CD    C   cell dimensions (read by RECIP)
CD    D   diffraction or diffractometer data (read by SETDC)
CD    E   extinction correction data (read by EXTINC)
CD    F   form factors (read by SETFOR)
CD    G   Gauss integration and other data for abs corr (read by SETGAU)
CD    I   instruction "cards" (read by main programs)
CD    J   multipole information (read by INPUTJ)
CD    L   least squares refinement data (read by, e.g., INPLSF)
CD    M   data for calculation of fourier maps (read by SETFOU)
CD    N   title (a single "card, read by INPUTN)
CD    P   polarisation data (read by SETPOL)
CD    Q   data for magnetic structures (read by DOMAG1)
CD    S   symmetry "cards" (read by SYMOP)
CD    T   anisotropic temperature factors  (read bY SETANI)
CD    U   indices supplied to force use of a particular unit asymmetric
CD        unit (read by SYMUNI)
CD    V   choice of representation of the space group
CD    W   wave function data (read by INPUTW)
CD    X   entirely under user's control
CD    Y   comment repeated on ouput LPT
CD    Z   comment not repeated on output
CD
CD    All "cards" with the same initial letter must come together but the
CD    groups may be in any order.
CD
CD    Except in a few instances such as  "F" "cards", where if a table of
CD    values is given, SETFOR expects  "cards" to be in the correct sequence,
CD    the "cards" within a group may be in any order.
CD
CD    The restriction about having all "cards" of one letter together does not
CD    apply to "cards" starting Y or Z.
CD
CD    A completely blank line is ignored.
CD
CD    An end of file, or any "card" with a non letter symbol in column 1
CD    terminates a set of crystal data. Any further data in the file may
CD    be read subsequently by the user's program.
CD
CD If an "M GET" card is given, the user wishes to take his basic data, and any
CD saved Fourier maps, from a dataset supplied, not from this crystal data.  The
CD SUBROUTINE MAJUST is called to adjust his file IO10 in this case.
C
CI Reads in the Crystal Data File
CO Lists on the lineprinter output a summary of what it found.
C
      CHARACTER *(*) PROGRM
      LOGICAL ENDIP
/CARDRC/
/SCRACH/
C
C INITIALISE WHOLE SYSTEM - DATE, TIME, CONSTANTS, I/O UNIT NUMBERS ETC:
C UNLESS THAT HAS ALREADY BEEN DONE ONCE IN THE JOB
      CALL INITIL(PROGRM)
C
      GO TO 9
C
C ENTRY TO READ A NEW CRYSTAL DATA SET FROM THE SAME FILE:
C      ENTRY NEXPRE(ENDIP)
C      CALL CLOFIL(IO10)
C      GO TO 10
C
C ENTRY TO READ A NEW CRYSTAL DATA SET FROM A DIFFERENT FILE:
C      ENTRY NEWPRE
C      CALL CLOFIL(ICRYDA)
C      CALL CLOFIL(IO10)
C OPEN CRYSTAL DATA BY ASKING FOR NAME WHERE POSSIBLE:
   9  ENDIP=.FALSE.
      MESSAG='Crystal data file'
CS ILL      NAMFIL='.CRY'
CS RAL      NAMFIL='.CCL'
      CALL OPNFIL(ICRYDA,111)
C OPEN SCRATCH FILE TO HOLD COPY OF CRYSTAL DATA:
      IO10=NOPFIL(10005)
C SET NO ERRORS DETECTED ON INPUT - SYSTEM PLOUGHS ON AS LONG AS IT CAN:
      IERR=0
C START COUNT IN OUTPUT:
      ID=0
      CALL CDFIN(1,ID,ENDIP)
      NTOTL=NTOTAL(1)
      RETURN
      END
C
C
C
C
C LEVEL 5      SUBROUTINE PRIDOM
      SUBROUTINE PRIDOM
C
C *** PRIDOM new by PJB March 2008 ***
C
CX
CC 7A
CH Prints data identifying different domains
CD Describes which domain is associated with each domain parameter
CP Called after DOMAG1 and DOTWN1 have been executed.
C
      CHARACTER *100 BUFF,SIG(2)*1
/IOUNIT/
/NSYM/
/SATELL/
/SYMMAG/
/TWIN/
      DATA SIG/'+','-'/

C Aligned ferromagnetic
      IF (FERA)GO TO 100
      BUFF='';
      IDOM=0
      N180D=1
      IF (IPROP.EQ.0) N180D=2
       DO 1 I180=1,N180D
      IBUF1=1
      DO 2 IT=1,NTWIN
      IBUF2=IBUF1
      IF (NTWIN.GT.1) THEN
        WRITE (BUFF(IBUF1:),1002) IT
 1002   FORMAT ('  Tmat: ',I2 )
        IBUF2=IBUF2+10
      ENDIF
      DO 3 IOP=1,NOPC
      IBUF3=IBUF2
      IF (NDOM.GT.1) THEN
        IF (MSTAB(IOP) .NE. IOP) GO TO 3
        WRITE (BUFF(IBUF3:),1003) IOP
 1003 FORMAT ('  NSym: ',I2)
        IBUF3=IBUF3+10
      ELSE IF (IOP.GT.1) then
        GO TO 3
      ENDIF
      DO 4 IK=1,KCENT
      IBUF4=IBUF3
      IF (KCENT.EQ.2) THEN
        WRITE (BUFF(IBUF4:),1004) SIG(IK)
 1004   FORMAT ('  Chirality: ',A1)
        IBUF4=IBUF4+14
      ENDIF
      IF (IPROP.EQ.0) WRITE (BUFF(IBUF4:),1005) SIG(I180)
 1005 FORMAT ('  M180: ',A1)
      IDOM=IDOM+1
      WRITE (LPT,1006) IDOM, (BUFF(I:I),I=1,LENGT(BUFF))
 1006 FORMAT (4X,'Domain ',I2.2,' has',80A1)
    4 CONTINUE
    3 CONTINUE
    2 CONTINUE
    1 CONTINUE
  100 RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE PRILIS(AVAL,IPT1,IPT2)
      SUBROUTINE PRILIS(AVAL,IPT1,IPT2)
C
C *** PRILIS updated by JCM 22 Aug 86 ***
C
CX
CC 13C
CH Prints a list of real numbers held in an array, 5 per line.
CA On entry AVAL holds the required real numbers,
CA          IPT1 points to the first to be printed,
CA          IPT2 points to the last to be printed.
C
CO Writes out AVAL(IPT1 to IPT2), in format G12.5, 5 per line.
C
      DIMENSION AVAL(IPT2),ATEMP(20)
/IOUNIT/
C
      IN=0
      DO 1 I=IPT1,IPT2
      IN=IN+1
      IF (IN .GT. 20) THEN
        WRITE (LPT,2000) ATEMP
2000    FORMAT (4(1X,5G12.5/))
        IN=1
      ENDIF
      ATEMP(IN)=AVAL(I)
   1  CONTINUE
C
C WRITE ANY SINGLE VALUES GATHERED INTO ATEMP:
      IF (IN .GT. 0) WRITE (LPT,2000) (ATEMP(I),I=1,IN)
      RETURN
      END
C
C
C
C
C LEVEL 4       SUBROUTINE PRIMBX(AVEC,RVEC,UM,AXLEN,NP,NMAX)
       SUBROUTINE PRIMBX(AVEC,RVEC,UM,AXLEN,NP,NMAX)
C
C *** PRIMBX new by PJB Nov 2016 ***
CX
CC11C
CH Finds a point RVEC equivalent to AVEC lying inside the origin cell

CA on input AVEC(3) give the coordinates of the given point
CA UM gives the orientation of the map axes with respect to fractional crystallographic
CA On exit RVEC holds the coordinates of the NP lattice points
CA within the 2D boundaries 0 <= RVEC(I) <1.
CA NMAX is the maximum number of points allowed
CP The geometry of the map is defined by the matrix UM(3,3) in common MAPMAP
C
      DIMENSION AVEC(3),BVEC(3),CVEC(3),RVEC(3,NMAX),V(3),um(3,3),
     &AXLEN(3),CLIM(2,2),MUL(2)
      DATA CLIM /0,1.,0.,1./
C
      CALL GMEQ(AVEC,BVEC,3,1)
      DO 1 I=1,2
      T=SCALPR(AVEC,UM(1,I))/AXLEN(I)
      FRAC=CLIM(1,I)-T
      AMUL=AINT(FRAC)
      IF (FRAC.LT.0) AMUL=AMUL-1.
      CALL GMSCA(UM(1,I),V,AMUL,3,1)
      CALL GMADD(BVEC,V,BVEC,3,1)
      T1=T+AMUL
      MUL(I)=INT(CLIM(2,I)-T1)
    1 CONTINUE
C
      NP=0
       DO 2 NX=1,MUL(1)
      CALL GMADD(BVEC,UM(1,1),BVEC,3,1)
      CALL GMEQ(BVEC,CVEC,3,1)
      DO 3 NY=1,MUL(2)
      CALL GMADD(CVEC,UM(1,2),CVEC,3,1)
      CALL ERRCHK(2,NP,NMAX,'Points within unit cell',0)
      CALL GMEQ(CVEC,RVEC(1,NP),3,1)
    3 CONTINUE
    2 CONTINUE
      RETURN
      END
C
C
C
C
C LEVEL 2      SUBROUTINE PRIPLN(A,IR)
      SUBROUTINE PRIPLN(A,IR)
C
C *** PRIPLN updated by JCM 12 Nov 89 ***
C
CX
CC 13C
CH Given the normal to a plane face in A, prints the equation of the plane.
CA On entry A is a 1x3 array containing 3 elements of the normal.
CA          IR=1 indicates that the normal is in terms of h,k,l, and
CA          IR=2 in terms of x,y,z (for later use).
CO Writes on unit LPT the equation of the plane.
CN At present every plane is assumed to go through the origin.
C
      CHARACTER *12 NEQN
      DIMENSION A(3)
/CHARS/
/IOUNIT/
C
      IPT=0
      NEQN=' '
      DO 2 I=1,3
      IF (A(I)) 3,2,4
C
C NEGATIVE TERM:
   3  IPT=IPT+1
      NEQN(IPT:IPT)='-'
      GO TO 5
C
C POSITIVE TERM - OMIT EXPLICIT PLUS IF AT START:
   4  IF (IPT .EQ. 0) GO TO 5
      IPT=IPT+1
      NEQN(IPT:IPT)='+'
   5  K=IABS(JFIX(A(I)))
      IF (K .NE. 1) THEN
C COEFFICIENT OTHER THAN 1:
        IPT=IPT+1
        NEQN(IPT:IPT)=IDIGIT(K)
      ENDIF
      IPT=IPT+1
C PICK LETTER:
      IF (IR .NE. 2) THEN
        L=I+9
        IF (I .EQ. 1) L=8
      ELSE
C WANT X,Y,Z:
        L=I+22
      ENDIF
      NEQN(IPT:IPT)=LETLOW(L)
   2  CONTINUE
C
C TIDY:
      IF (IPT .EQ. 0) GO TO 100
      IF ((IPT .EQ. 3) .AND. (NEQN(2:2) .EQ. '-')) THEN
        NEQN(4:4)=NEQN(3:3)
        NEQN(3:3)='='
        NEQN(2:2)='>'
      ELSE
        NEQN(IPT+1:IPT+1)='>'
        NEQN(IPT+2:IPT+2)='='
        NEQN(IPT+3:IPT+3)=IDIGIT(10)
      ENDIF
      WRITE (LPT,2000) NEQN
2000  FORMAT (13X,A12)
 100  RETURN
      END
C
C
C
C
C LEVEL 7      SUBROUTINE PRIVAR
      SUBROUTINE PRIVAR
C
C *** PRIVAR updated for MK4 by JCM Aug 89 ***
C
CX
CC 6C
CH Prints a list of basic variables, and constraint relations, for LSQ.
CP VARMAK must have been obeyed to create the lists
CO For most basic variables, lists their names.  For family 4, ("very long
CO      vectors") only prints ranges.
CO Then lists the strict constraints.
CO Any phases and sources are indicated by *P and *S
C
      CHARACTER *1 IJOIN(8)
      CHARACTER *4 IPR1(8),IPR2(8),NAM1,NAM2,NOLD
      LOGICAL F4,F5
      DIMENSION K1(8),K2(8)
/CONSTR/
/DERBAS/
/GLOBAL/
/IOUNIT/
/PHASE/
/POINTS/
/SOURCE/
C
      IF (LVARB .LE. 0) THEN
        CALL MESS(LPT,1,'No variables')
        GO TO 100
      ENDIF
C
      WRITE (LPT,2001) LVARB
2001  FORMAT (/'    ',I5,' basic variable(s) :'/)
C NUMBER OF ITEMS PER LINE OF OUTPUT:
      LINE=7
      F4=.FALSE.
      IGENF4=0
      ISP1F4=0
      ISPNF4=0
      IC=0
      JPH=0
      JSO=0
C
      DO  4 IB=1,LVARB
      K=LVRPR(LBSVR(IB))
C
C SAVE PREVIOUS PHASE AND SOURCE:
      KPHASE=JPH
      KSOURC=JSO
      CALL KUNPAK(K,IFAM,IGEN,ISPC,JPH,JSO)
      IF (MULFAS .AND. KPHASE .NE. JPH) THEN
        WRITE (LPT,2002) (IPR1(J),IJOIN(J),IPR2(J),J=1,IC)
        IC=0
        WRITE (LPT,2006) JPH
2006    FORMAT(/' Phase',I3)
      ENDIF
C
      IF (IFAM .NE. 4) GO TO 5
C
C FAMILY 4 - LONG VECTORS, INCONVENIENT TO PRINT:
C GET PRINTING NAME:
      NOLD=NAM2
      CALL PARNAM(NAM1,NAM2,3,K)
      IF (IGEN .EQ. IGENF4) GO TO 8
C NEW GENUS (INCLUDING START)
      IF (F4 .AND. ISP1F4 .NE. ISPNF4) THEN
C PART-ENTRY ALREADY IN BUFFERS (BUT IF ONLY 1 IN RANGE, IS ALREADY THERE):
C PUT END VALUE OF RANGE INTO BUFF2:
        IPR2(IC)=NOLD
        IJOIN(IC)='-'
      ENDIF
C SET "HAVE HAD SOME FAMILY 4"
      F4=.TRUE.
C PUT GENUS NAME FOR FAMILY 4 INTO BUFFER BY ITSELF:
      IGENF4=IGEN
      IF (IC .GE. LINE-1) THEN
        WRITE (LPT,2002) (IPR1(J),IJOIN(J),IPR2(J),J=1,IC)
        IC=0
      ENDIF
      IC=IC+1
      IPR1(IC)=' '
      IPR2(IC)=NAM1
      IJOIN(IC)=' '
C PUT LOWER END OF RANGE INTO BUFF:
  14  IF (IC .GE. LINE-1) THEN
        WRITE (LPT,2002) (IPR1(J),IJOIN(J),IPR2(J),J=1,IC)
        IC=0
      ENDIF
      IC=IC+1
      IPR1(IC)=NAM2
      IPR2(IC)=' '
      IJOIN(IC)=' '
      ISP1F4=ISPC
      ISPNF4=ISPC
      GO TO 4
C
C SAME GENUS - IS IT NEXT SPECIES?
   8  IF (ISPNF4+1 .EQ. ISPC) THEN
        ISPNF4=ISPC
        GO TO 4
      ENDIF
C
C PUT RANGE END INTO BUFFER:
      IF (ISP1F4 .NE. ISPNF4) THEN
        IPR2(IC)=NOLD
        IJOIN(IC)='-'
        IF (IC .GE. LINE) THEN
          WRITE (LPT,2002) (IPR1(J),IJOIN(J),IPR2(J),J=1,IC)
          IC=0
        ENDIF
      ENDIF
      GO TO 14
C
C NOT FAMILY 4:
   5  IF (ISP1F4 .NE. ISPNF4) THEN
        ISPNF4=ISP1F4
        IPR2(IC)=NAM2
        IJOIN(IC)='-'
      ENDIF
      IF (IC .GE. LINE) THEN
        WRITE (LPT,2002) (IPR1(J),IJOIN(J),IPR2(J),J=1,IC)
        IC=0
      ENDIF
      IC=IC+1
      CALL PARNAM(IPR1(IC),IPR2(IC),1,IB)
      IJOIN(IC)=' '
      IF (IC .GE. LINE) THEN
        WRITE (LPT,2002) (IPR1(J),IJOIN(J),IPR2(J),J=1,IC)
2002    FORMAT (' ',10(A4,A1,A4,2X))
        IC=0
      ENDIF
   4  CONTINUE
C
C MAY BE REMNANTS OF FAMILY 4 NOT IN BUFFER:
      IF (F4 .AND. (ISP1F4 .NE. ISPNF4)) THEN
        IPR2(IC)=NAM2
        IJOIN(IC)='-'
      ENDIF
      IF (IC .NE. 0)  WRITE (LPT,2002) (IPR1(J),IJOIN(J),
     & IPR2(J),J=1,IC)
C
C CONSTRAINT LIST:
      IF (JCONST .LE. 0) GO TO 100
      WRITE (LPT,2003) JCONST
2003  FORMAT (/' ',I5,' constraint(s) - relations between shifts',
     & ' in variables are :'/)
      DO 3 J=JCONST,1,-1
      JROW=JROWPT(J)
      JNEXT=JROWPT(J+1)-1
      JR=JNEXT-JROW+1
      CALL PARNAM(NAM1,NAM2,2,LRDVR(J))
C KPHASE IS SET BY PARNAM:
      KP=KPHASE
      KS=KSOURC
      IF (JR .GT. 8) THEN
        WRITE (LPT,3000) NAM1,NAM2
        WRITE (ITO,3000) NAM1,NAM2
3000    FORMAT (/' ERROR ** redundant variable',2(A4),
     &   'related to > 8 basics - cannot yet print')
        JNEXT=JROW+7
        JR=8
      ENDIF
C
      F4=.TRUE.
      F5=.TRUE.
      DO 7 M=1,JR
      CALL PARNAM(IPR1(M),IPR2(M),1,JCMAT(M+JROW-1))
      K1(M)=KPHASE
      K2(M)=KSOURC
      IF (KPHASE .NE. KP) F4=.FALSE.
      IF (KSOURC .NE. KS) F5=.FALSE.
   7  CONTINUE
      IF (JR .NE. 1 .OR. ABS(AMOUNT(JROW)-1.) .GT. 0.00001) THEN
      IF (.NOT. MULFAS) WRITE (LPT,2004) NAM1,NAM2,AMOUNT(JROW),
     &  IPR1(1),IPR2(1),('+',AMOUNT(I+JROW-1),IPR1(I),
     &  IPR2(I),I=2,JR)
2004    FORMAT (1X,A4,1X,A4,' = ',F10.3,' times ',A4,1X,A4,
     &  (1X,A1,1X,F10.3,' times ',A4,1X,A4))
      IF (MULFAS) WRITE (LPT,2008) NAM1,NAM2,KP,AMOUNT(JROW),
     &  IPR1(1),IPR2(1),K1(1),('+',AMOUNT(I+JROW-1),IPR1(I),
     &  IPR2(I),K1(I),I=2,JR)
2008    FORMAT (1X,A4,1X,A4,' *P',I1,' = ',F10.3,' times ',A4,1X,A4,
     &  ' *P',I1,(1X,A1,1X,F10.3,' times ',A4,1X,A4,' *P',I1))
      ELSE
        IF (MULFAS) WRITE (LPT,2007) NAM1,NAM2,KP,IPR1(1),
     &  IPR2(1),K1(1)
2007    FORMAT (1X,A4,1X,A4,' *P',I1,' = ',A4,1X,A4,' *P',I1)
        IF (.NOT. MULFAS) WRITE(LPT,2005) NAM1,NAM2,IPR1(1),IPR2(1)
2005    FORMAT (1X,A4,1X,A4,' = ',A4,1X,A4)
      ENDIF
   3  CONTINUE
 100  RETURN
      END
C
C
C
C
C LEVEL 5      SUBROUTINE PRIWRD(IFAM,IGEN,ISPC,NAME,MODE)
      SUBROUTINE PRIWRD(IFAM,IGEN,ISPC,NAME,MODE)
C
C *** PRIWRD updated for MK4 by JCM 8 May 90 ***
C
CX
CC 6C
CH Finds the name of the packed (possibly part) LSQ parameter from
CH the built-in table of parameter names.
CA On entry IFAM, IGEN, ISPC are family, genus and species of the parameter.
CA          MODE=0 requests left justify, =1 right justify.
CA On exit  NAME is the A4 name from the table in /WORDS/, or 'XXXX'
CP The table must have been set up by LSETUP
C
      CHARACTER *4 NAME
/GLOBAL/
/PHASE/
/SOURCE/
/WDSPC/
/WORDS/
C
      NAME='XXXX'
C
C THE PHASE IS IRRELEVANT - EVERY PHASE HAS THE SAME VOCABULARY HERE
C IF MULTISOURCE, AND FAMILY 3 THE SOURCE IS RELEVANT:
      IF (MULONE) THEN
        K=0
        IF (IFAM .EQ. 3) THEN
C C106 Only for genus 1,2 (zero,pkcn) but not pkfn
          IF (IGEN.NE.1 .AND. IGEN.NE.2) K=KSOURC
        ENDIF
      ENDIF
C
      IPACK=KPAK(IFAM,IGEN,ISPC,0,K)
      IPT=NFIND(IPACK,IWDSPC,IWDNUM)
      IF (IPT .GT. 0) THEN
C
        IF (MODE .EQ. 0) THEN
          NAME=LSQWD(IPT)
        ELSE
C
C RIGHT JUSTIFY:
          J=4
          NAME=' '
          DO 3 I=4,1,-1
          IF (LSQWD(IPT)(I:I) .NE. ' ') THEN
            NAME(J:J)=LSQWD(IPT)(I:I)
            J=J-1
          ENDIF
   3      CONTINUE
        ENDIF
      ENDIF
      RETURN
      END
C
C
C
C
C LEVEL 7      SUBROUTINE PRJECT(LVAR,TKMAT)
      SUBROUTINE PRJECT(LVAR,TKMAT)
C
C *** PRJECT new by PJB C4.17 July 2009  ***
C
CX
CC 17B
CH Projects QSQRD P.Q and derivatives from the tensor structure factor
CHfor powder or single crystal datadata
C
      DIMENSION POLD(3)
      COMPLEX QCAL,QDER
/IOUNIT/
/MCAL/
/POLDA/
/QCAL/
/QCALD/
/REFINE/
      IF (IREF.eq. 9 .OR. IREF .EQ. 10) THEN
C     DO THE POWDER AVERAGES
        FMCSQR=REAL(TCALC(1)*CONJG(TCALC(1)) +
     &  TCALC(2)*CONJG(TCALC(2)))/2
        FMCSQR= FMCSQR +REAL(TCALC(6)*CONJG(TCALC(6)))
C PDOTQ Is the mean of any one component in the plane perp to H
        QDOTP=(TCALC(1) + TCALC(2))/2
        FMCMOD=SQRT(FMCSQR)
C DIFFERENTIALS OF QSQRD AND PDOTQ
        DO 1 I=1,LVAR
        FMCDER(I)=REAL(TCALC(1)*CONJG(FTCDER(1,I))+
     &  TCALC(2)*CONJG(FTCDER(2,I)) + 2.*TCALC(6)*CONJG(FTCDER(6,I)))
        DQDOTP(I)=0.5*(FTCDER(1,I) + FTCDER(2,I))
    1   CONTINUE
C        write (lpt,1000) real(qdotp),(real(dqdotp(i)),i=1,lvar)
C 1000 format (f8.4,2x,6f8.4)
      ELSE
        CALL GMPRD(TKMAT,POLND,POLD,3,3,1)
        J=2
        K=3
        QDOTP=0
        FMCSQR=0
        CALL GMZER(FMCDER,LVAR,1)
        CALL CGMZER(DQDOTP,LVAR,1)
C ON K AXES Q ONLY HAS x AND Y COMPONENTS
        DO 3 I=1,2
        QCAL=POLD(I)*TCALC(I)+POLD(J)*TCALC(3+K)+POLD(K)*TCALC(3+J)
        DO 2 IP=1,LVAR
        QDER=POLD(I)*FTCDER(I,IP) + POLD(J)*FTCDER(3+K,IP) +
     &  POLD(K)*FTCDER(3+J,IP)
        FMCDER(IP)=FMCDER(IP)+2.*REAL(QCAL*CONJG(QDER))
        DQDOTP(IP)=DQDOTP(IP)+POLD(I)*QDER
    2   CONTINUE
        QDOTP=QDOTP+POLD(I)*QCAL
        FMCSQR=FMCSQR+REAL(QCAL*CONJG(QCAL))
        fmcmod=sqrt(fmcsqr)
        J=K
        K=I
    3   CONTINUE
      ENDIF
      RETURN
      END
     &
     &C
C
C
C
C LEVEL 7      SUBROUTINE PRMBLK
      SUBROUTINE PRMBLK
C
C *** PRMBLK updated by PJB 4-Apr-2001 ***
C
CX
CC 18B
CH Applies shifts to multipole parameters, in both program and user units.
CP APSHMP must have stored a vector of multipole shifts in POLAMP(,4)
CP        and ESDs in POLAMP(,6)
CP CONMAT holds the conversion matrices
CD Applies matrix transformation to set of shifts to convert them into
CD user's notation.
CO Prints the converted shifts in the usual format on unit LPT
C
      CHARACTER *4 LNAM1,LNAM2
      CHARACTER *32 VFORM
/IOUNIT/
/MPODA/
/NEWOLD/
/POINTS/
C
      CALL CONVMP(2)
C
C APPLY ALL USER SHIFTS TO USER VALUES:
      IFAM=5
      IGEN=1
      DO 51 ISPC=1,NMPOL
      IF (KPOLMP(ISPC) .EQ. 0) GO TO 51
      SHIFT=POLAMP(ISPC,3)
      ESD=POLAMP(ISPC,5)
      CALL ADJUST(POLAMP(ISPC,1))
      CALL FETSHF(2,SHIFT,ESD)
      CALL PARNAM(LNAM1,LNAM2,3,KPAK(5,1,ISPC,0,0))
      WRITE (VFORM,2000) NSIGFG(ESD)
      WRITE (LPT,VFORM) LNAM1,LNAM2,XNEW,ESD,SHIFT,XOLD,SHESD
2000  FORMAT ('(2X,A4,1X,A4,4F10.',I1,'F10.3)')
   51 CONTINUE
C
C CONVERT NEW USER VALUES TO NEW PROGRAM VALUES:
      CALL CONVMP(1)
      RETURN
      END
C
C
C
C
C LEVEL 3      SUBROUTINE PRMTIV
      SUBROUTINE PRMTIV
C
C *** PRMTIV by JCM 11 Oct 84 ***
C
CX
CC 3A
CH A specialist routine for use in generating h,k,l indices where the
CH natural stepping vectors do not define a primitive cell.
CP Called from SETGEN
CD Sets up coefficients NPRIM(2,2), MCOUNT(2), LFAC(2) in /HKLGEN/
CD to make primitive stepping vectors from the existing steps.
C
      LOGICAL BINDIG
      DIMENSION VEC(3,2)
/HKLGEN/
/IOUNIT/
C
C
C  CHECK WHETHER PRIMITIVE AND SET UP INTERVENING STEPS IF NOT:
C
      DO 6 I=1,2
      DO 7 J=1,2
   7  NPRIM(I,J)=0
      MCOUNT(I)=1
   6  LFAC(I)=1
      IF (NP.EQ.1) GO TO 100
C
C  CHECK WHETHER BASE PLANE IS PRIMITIVE
      CALL VECPRD(STEP(1,1),STEP(1,2),VEC(1,1))
      CALL FCTOR(VEC(1,1),M)
      IF (M.EQ.1) GO TO 1
      CALL GMEQ(STEP(1,2),VEC(1,1),1,3)
      DO 10 N1=2,M
      CALL GMADD(VEC(1,1),STEP(1,1),VEC(1,1),1,3)
      CALL FCTOR(VEC(1,1),J)
      IF (J.EQ.M) GO TO 11
   10 CONTINUE
      WRITE (LPT,3000)M,J,(VEC(I,1),I=1,3),STEP
      WRITE (ITO,3000)M,J,(VEC(I,1),I=1,3),STEP
3000  FORMAT (/' ERROR ** IN PRMTIV FINDING BASE PLANE VECTOR - ',
     & ' M,J=',2I4,' VEC1=',3F5.1,' STEP ARRAY IS'/1X,9F5.1)
      STOP
C
  11  NPRIM(1,1)=N1-1
      NPRIM(2,1)=1
      LFAC(1)=M
C
C  IS THIS ENOUGH?
      IF (M.EQ.NP) GO TO 101
C
C  INTERVENING LAYERS ON THIRD AXIS:
    1 L=NP/M
      CALL GMEQ(STEP(1,3),VEC(1,2),1,3)
      DO 3 N2=1,L
      CALL GMEQ(VEC(1,2),VEC(1,1),1,3)
      DO 4 N1=1,L
      CALL FCTOR(VEC(1,1),J)
      IF (J.EQ.L) GO TO 5
    4 CALL GMADD(VEC(1,1),STEP(1,1),VEC(1,1),1,3)
    3 CALL GMADD(VEC(1,2),STEP(1,2),VEC(1,2),1,3)
C
C  ERROR IF WE GET HERE
      WRITE (LPT,3001)L,M,J,((VEC(I,II),I=1,3),II=1,2),STEP
      WRITE (ITO,3001)L,M,J,((VEC(I,II),I=1,3),II=1,2),STEP
3001  FORMAT (/' ERROR ** in PRMTIV making second vector',
     & ' - L,M,J=',3I4/' Vectors so far are:',6F5.1/' Step array',
     & ' is',9F5.1)
      STOP
C
   5  NPRIM(1,2)=N1-1
      NPRIM(2,2)=N2-1
      LFAC(2)=L
  101 IF (BINDIG(IOUT,16)) THEN
        WRITE (LPT,4000) M,L,NP,NPRIM,STEP
        WRITE (ITO,4000) M,L,NP,NPRIM,STEP
 4000   FORMAT (' M,L,NP,NPRIM,STEP:'/1X,3I5,4X,I4,4I3/9(1X,3F8.2/)
     &  /3(1X,3F8.2/))
      ENDIF
  100 RETURN
      END
C
C
C
C
C LEVEL 1      LOGICAL FUNCTION PRNCYC(N)
      LOGICAL FUNCTION PRNCYC(N)
C
C *** PRNCYC by JCM 17 Nov 84 ***
C
CX
CC 6C
CH Decides whether printing (of various different quantities in LSQ)
CH is needed during the current LSQ cycle.
CA On entry N is an integer specifying which member of the array IPRNT
CA            in /REFINE/ is to be consulted.  Values of N already
CA            assigned in some standard LSQ applications are:
CA N=1: PRIN - routine IICD1 (called by most LSQ applications) scans any
CA             I cards for a "PRIN" item;  it it finds one, it reads the
CA             integer which follows to IPRNT(1), and uses it as an
CA             indicator of the frequency with which general "obs and
CA             calc" lists are printed during the refinement.  These are:
CA     0 = no printing
CA     1 = print during first cycle
CA     2 = print during last cycle
CA     3 = print during first and last cycles
CA     4 = print every cycle
CA N=2: PRFC - similar to N=1, but used in the Profile Refinement system
CA             to control the printing of reflection information.
CA N=3: PRFO - as N=2, for a file to be reinput to the Fourier routines.
CA N=4: PRPR - as N=2, for a file containing the profile, to be reinput,
CA             e.g., to GENIE.
CA N=5: PRCV - as N=2, but only obeyed on last cycle.  The integer
CA             following "PRCV" is an indication of how many covariances
CA             from the inverse LSQ matrix to print on the .HKL file.
CA             So PRNCYC would be irrelevant here.
CA N=6: PREE - as N=2, for a file containing the eigenvalues and
CA             eigenvectors of that part of the inverse LSQ matrix
CA             relevant to intensities.  PRNCYC is again irrelevant,
CA             the integer here indicating how much material is sent to
CA             the line-printer file.
CA N=7: PRDM - read by IICD1, called by most LSQ applications.  Requests
CA             printing during the last cycle of h,k,l Fo Fc to a a
CA             .DEP file for "deposited Material".  This file may be
CA             subsequently interpreted by the main program DEPOS.
CA N=8: PRSK - read by GEOMCO, called by structure LSQ applications.
CA             Requests the printing of an "obs and calc" list for any
CA             slack constraints, including both geometrical constraints
CA             and those in Profile Refinement of Pawley-type.
CA
CA The user would be free to use higher values of N, e.g. from 20 downwards,
CA for his own print control.  An example of such use occurs in the main
CA program GRLSQ, in which N=2 is used in a different context from the above.
C
CP IPRNT(N) in /REFINE/ must contain an integer with a value in the
CP range 0-4, as described above.  ICYC in /REFINE/ must be the current
CP cycle number.
C
CD The function PRNCYC is set TRUE if printing is required, taking
CD of both IPRNT(N) and ICYC.
C
      LOGICAL FIRST,LAST
/REFINE/
C
      IP=IPRNT(N)
C
C IP=0 MEANS NO PRINTING:
      PRNCYC=.FALSE.
      IF (IP .GT. 0) THEN
C
        FIRST=(ICYC .EQ. NCYC1)
C DONE IS SET IF REFINEMENT HAS CONVERGED ACCORDING TO I CONV CARD:
        LAST=(ICYC .EQ. LASTCY) .OR. DONE
        PRNCYC=(IP .EQ. 4) .OR.
     &  ((IP .EQ. 3) .AND. (LAST .OR. FIRST)) .OR.
     &  ((IP .EQ. 2) .AND. LAST) .OR.
     &  ((IP .EQ. 1) .AND. (FIRST))
      ENDIF
      RETURN
      END
C
C
C
C
C LEVEL 3      SUBROUTINE PRNTMP(L21)
      SUBROUTINE PRNTMP(L21)
C
C *** PRNTMP updated by PJB 29 Apr 88 ***
C
CX
CC 5B
CH Prints out a Fourier projection or one layer of a 3D Fourier.
C
CA On entry L21 is the number of I5 integers required on a line.
CP The values of points on the map must be in array dens in COMMON /MAPDA/,
CP They are usually put there by one of FOUR1Z, FOURGP, ERRMAP, or GETMAP
CP which of these is used is usually decided by FORIER in respons to requests
CP on the M "cards"
CO The array of values is rounded to I5 integers and printed in rows of L21
CO columns on unit LPT
C
C
      LOGICAL EXACT
      DIMENSION JDENS(100),IU(3,3)
/IOUNIT/
/MAPDA/
C
      IF (MODET .EQ. 1) THEN
      DO 4 I=1,3
   4  CALL INDFIX(U(1,I),IU(1,I))
      IF (NDIM .EQ. 2) WRITE (LPT,2001) (IU(I,3),I=1,3),((IU(I,J),
     & I=1,3),J=1,2)
2001  FORMAT (//' Fourier projection down',3I4,' axis'/' x-axis along',
     & 3I4,'  y-axis along',3I4)
      IF (NDIM .EQ. 3) WRITE (LPT,2002) (IU(I,3),I=1,3),OUTLIM(1,3),
     & ((IU(I,J),I=1,3),J=1,2)
2002  FORMAT (//' Fourier section through',3I4,' axis at height',
     & F8.4/' x-axis parallel to',3I4,'  y-axis parallel to',3I4)
      IF (NDIM .EQ. 4) WRITE (LPT,2007) (IU(I,3),I=1,3),OUTLIM(1,3),
     & SECEND,((IU(I,J),I=1,3),J=1,2)
2007  FORMAT (//' Bounded section on ',3I4,' axis from ',F7.4,' to'
     & ,F8.4/' x-axis parallel to',3I4,'  y-axis parallel to',3I4)
      ELSE
      WRITE (LPT,2009) (U(I,3),I=1,3),OUTLIM(1,3),((U(I,J),I=1,3),
     & J=1,2)
2009  FORMAT (//' Fourier section through',3F8.4,' axis at height',
     & F8.4/' x-axis parallel to',3F8.4,'  y-axis parallel to',3F8.4)
      ENDIF
      WRITE (LPT,2003) ((OUTLIM(I,J),I=1,3),J=1,2)
2003  FORMAT (/' Rows of constant x and columns of constant y'/' x',
     & ' varies down the page from',F6.3,' to',F6.3,' in steps of',F6.3/
     & ' y varies along a row from',F6.3,' to',F6.3,' in steps of',F6.3)
      NL = NY/L21
      NR = MOD(NY,L21)
      EXACT = (NR .EQ. 0)
      IF (.NOT. EXACT) NL=NL+1
      DO 1 IX = 1,NX
      CALL MESS(LPT,1,' ')
      M = IX
      DO 2 N = 1,NL
      NEND=L21
      IF (N .EQ. NL .AND. .NOT. EXACT) NEND=NR
      DO 3 I=1,NEND
      JDENS(I) = JFIX(DENS(M))
    3 M = M+NX
    2 WRITE (LPT,2004) (JDENS(I),I=1,NEND)
2004  FORMAT (1X,100(I6))
    1 CONTINUE
      RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE PROPAG(MODE,INOUT)
      SUBROUTINE PROPAG(MODE,INOUT)
C
CC 17B
C *** PROPAG new by PJB 28-Sept-93 ***
C
CH Multiple entry subroutine for propagation vector refinement
CA MODE indicates what function is required
CA MODE = 1 Read a Q PROP card if present and if so call PROPER
CA          on exit INOUT is 1 id found 0 if not
CA      = 2 Set the symmetry constraints on the magnetic propagation vector
CA          INOUT is set on input to the offset of the propagation vector in
CA          the family 1 genus 1 parameters
CA      = 3 Apply a shift to the INOUTth component
CA      = 4 Write new Q PROP card on unit INOUT
CA      = 0 all components fixed
CA      = negative integer set the variable number of the -MODEth component to
CA       be INOUT
C
      DIMENSION ITAB(24),JGEN(3),NFIX3(3),RMAT(3,3),FIX3(3),NCOUNT(3)
C
/NSYM/
/SATELL/
/SYMDA/
/SYMTAB/
/SCRACH/
C
      IF (MODE.LE.0) GO TO 60
      GO TO (10,20,30,40), MODE
C
C READ Q PROP CARD
   10 CALL FINDCD('Q','PROP',4,0,LCD)
      IF (LCD.GT.0) THEN
        CALL RDNUMS(FIX3,7,3,NUM,IER)
        IF (IER.NE.0 .OR. NUM.NE.3)
     &  CALL ERRMES(1,1,'reading propagation vector')
        CALL PROPER(FIX3)
        INOUT=1
      ELSE
        INOUT=-1
      ENDIF
      GO TO 100
C
C SET SYMMETRY CONSTRAINTS
   20 IPOFF=INOUT
C CLEAR OUT ALL FIX/RELA INFO
      DO 22 K=1,3
      NFIX3(K)=9999
  22  CONTINUE
C
      IF (IPROP.LE.0 .OR. IPROP.EQ.2) GO TO 23
      CALL JGMZER(ITAB,1,NOPC)
      ITAB(1)=1
      JGEN(1)=1
      DO 21 I=2,NOPC
      IF (KSTAB(I).NE.1) GO TO 21
      ITAB(I)=IABS(NORD(I))
      JGEN(1)=JGEN(1)+1
   21 CONTINUE
C
C Find generators of subgroup
      CALL GENELM(ITAB,JGEN)
C
C JUMP IF NOT SPECIAL:
      IF (JGEN(1) .EQ. 1) GO TO 26
C JUMP IF NOT ON A CENTRE OF SYMMETRY:
      IF (JGEN(1) .GT. 0) GO TO 24
C FIX ALL COMPONENTS:
  23   DO 25 I=1,3
  25  CALL FIXPAR(I,NFIX3)
      GO TO 26
C
C TAKE FIRST (OF POSSIBLE 2) SYMMETRY ELEMENTS MAKING THIS POSITION SPECIAL:
  24  DO 27 I=2,3
      K=IABS(JGEN(I))
      CALL GMEQ(SYM(1,1,K),RMAT,3,3)
      IF (JGEN(I) .LT. 0) CALL GMREV(RMAT,RMAT,3,3)
      CALL RELSM3(RMAT,NFIX3,FIX3)
C
C IS THERE A SECOND GENERATOR OF THE SUB-GROUP WHICH MAKES THIS ATOM SPECIAL?
      IF (JGEN(3) .EQ. 0) GO TO 26
  27  CONTINUE
C ALL COMPONENT RELATIONS COLLECTED IN TEMPORARY SPACE - USE:
  26  DO 28 I=1,3
  28  NCOUNT(I)=KPAK(1,1,IPOFF+I,JPHASE,1)
      CALL FIXREL(3,NFIX3,FIX3,NCOUNT,5)
      GO TO 100
C
C APPLY SHIFT
   30 IF (INOUT.GT.3) GO TO 100
      CALL ADJUST(PROP(INOUT))
      GO TO 100
C
C WRITE NEW Q PROP CARD
   40 IF (ICARD(3:6).NE.'PROP') THEN
        L=LENGT(ICARD)
        WRITE (INOUT,4001) (ICARD(I:I),I=1,L)
 4001 FORMAT (80A1)
      ELSE
        WRITE (INOUT,4000) PROP
 4000 FORMAT ('Q PROP',3F10.4)
      ENDIF
      GO TO 100
C
C TO SET ALL COMPONENTS FIXED, OR VARY ONE:
   60 N=IABS(MODE)
      IF (N .EQ. 0) THEN
        DO 1 I=1,3
   1    KPROP(I)=0
      ELSE
        IF (N.GT.3) GO TO 100
        KPROP(N)=INOUT
      ENDIF
C
 100  RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE PROPDR(H,IS,DER)
      SUBROUTINE PROPDR(H,IS,DER)
C
CC 17B
C *** PROPDR updated by PJB 1 Feb 1994 ***
C
CH Makes derivatives of d*sqrd with respect to the magnetic propagation
CH vector

CA On entry H contains the indices of the magnetic reflection
CA          IS is +/- 1 depending on whether the propagation vector
CA             has been added or subtracted.
CA On exit DER contains the derivatives with respect to the three components
CA             of the pv.
C
      DIMENSION DER(3),H(3)
/CELPAR/
C
      CALL GMZER(DER,3,1)
      IF (IS.EQ.0) GO TO 100
      AS=SIGN(2.,FLOAT(IS))
      J=2
      K=3
      DO 1 I=1,3
      DER(I)=AS*(CPARS(I,2)*H(I)+CPARS(J+3,2)*H(K)+CPARS(K+3,2)*H(J))
      J=K
      K=I
    1 CONTINUE
C
  100 RETURN
      END
C
C
C
C
C LEVEL 5      SUBROUTINE PROPER(APROP)
      SUBROUTINE PROPER(APROP)
C
C *** PROPER corrected by PJB C4.35 March 2017 removed entry KSTARS***
C
CX
CC 17A
CH Determines whether the satellites generated by the propagation vector
CH PROP have integer indices, and generates its "star".
C
CA APROP is the 1X3 propagation vector copied to PROP
CP SYMOP should have been obeyed to read the space group symmetry
CD On exit  IPROP in /SATELL/ is zero if PROP is 0 0 0
CD                negative for other integer indices
CD                and positive for non-integer values.
CD          IABS(IPROP) is set to 2 if twice PROP is a reciprocal
CD                lattice vector.
CD Vectors in the star AKVEC now included in common SATELL
CD PROP is equivalenced to the first entry in ASTAR
C
CD On exit the symmetry table of the star is in KSTAB.
CD NKSTAR holds the number of vectors in the star,
CD INCOM is .TRUE. if the propagation vector is fixed on a symmetry point
CD and FKSTAR is a scale for structure factors assuming a mono-k domain.
CO Writes its findings on unit LPT
C
%      DIMENSION APROP(3),RPROP(3),BKVEC(3,%SY+1%),KITAB(49)
/IOUNIT/
/NSYM/
/SATELL/
/SYMMAG/
/SYMTAB/
C
C
      CALL GMEQ(APROP,PROP,3,1)
      CALL GMEQ(PROP,AKSTAR(1,1),3,1)
      CALL GMEQ(PROP,BKVEC(1,1),3,1)
      IPROP=0
      ND180=2
      IF (ABS(PROP(1))+ABS(PROP(2))+ABS(PROP(3)) .LT. .00001) GO TO 3
      IPROP=1
      ND180=1
      DO 1 I=1,3
      IF (PROP(I)-AINT(PROP(I)) .GT. .00001) GO TO 3
    1 CONTINUE
      IPROP=-1
C
C THIS PART USED TO BE KSTAR:
   3  MN=1
      MMN=1
      KSTAB(1)=1
      KITAB(1)=1
      DO 9 I=2,NOPC
      IF (IPROP.EQ.0) THEN
        KSTAB(I)=1
      ELSE
        ISIG=1
        CALL ROTSYM(PROP,RPROP,I,2)
C4.26 Now differentiate exact equality from differing by a lattice vector
        CALL EQRLV(AKSTAR,RPROP,MN,M,NOPC)
        CALL EQVEC(BKVEC,RPROP,MMN,MM,NOPC)
        IF (M.GT.MN) THEN
          CALL GMREV(RPROP,RPROP,3,1)
          CALL EQRLV(AKSTAR,RPROP,MN,M,0)
          IF (M.GT.MN) THEN
            MN=M
          ELSE
            ISIG=-1
          ENDIF
        ENDIF
        KSTAB(I)=M*ISIG
        IF (MM.GT.MMN)  MMN=MM
C KITAB is for exact equality
        KITAB(I)=MM*ISIG
      ENDIF
    9 CONTINUE
C
C  CHECK CENTRE OF SYMMETRY
      KCENT=1
      KSTAB(NOPC+1)=0
      CALL GMREV(PROP,RPROP,3,1)
      CALL EQRLV(AKSTAR,RPROP,MN,M,0)
C DOES CENTRE OF SYMMETRY PRODUCE A NEW VECTOR
      IF (M.GT.MN) THEN
        KCENT=2
      ELSE
        KSTAB(NOPC+1)=-1
      ENDIF
C
      NKC=MN
      NREP=MMN/NKC
      if (KCENT .eq.1) then
        write (lpt,2002)NREP
 2002   format ('Representation has dimension',i4 )
        if (NREP.gt.2) call errmes(1,0,'In determination of symmetry'//
     &' representations from propagation vector')
      ENDIF
      WRITE (LPT,2000) (KSTAB(I),I=1,NOPC)
2000  FORMAT('     Group of K:',24I4)
      WRITE (LPT,2003) KSTAB(NOPC+1)
2003  FORMAT('        Centred:',I4)
      IF (CPVEC) THEN
C4.26 Determine the operators for INCM type
        CALL CPVSYM(KITAB)
      ENDIF
      WRITE (LPT,2001) ((AKSTAR(I,J),I=1,3),J=1,NKC)
2001  FORMAT (' Vectors in the star: ',3F10.4/(22X,3F10.4))
C CASE WHERE CENTRE OF SYMMETRY PRODUCES NEW VECTORS:
      NKSTAR=KCENT*NKC
      FKSTAR=1.
      IPROP=(3-KCENT)*IPROP
      FKSTAR=FKSTAR/FLOAT(KCENT)
      INCOM=(KCENT.EQ.2)
      RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE PSICON(MGAT,IFTAB)
      SUBROUTINE PSICON(MGAT,IFTAB)
C
C *** PSICON reorgsnised by PJB C141/144 March/Dec 2006 ***
C
CX
CC 17A
CH Determines which atoms need phase factors in modulated structures.
CA MGAT identifies the magnetic atom in question.
CA IFTAB contains the factor table for the atomic site symmetry group.
CP The factor table for the magnetic symmetry group must be already in MSTAB.
CD On entry LPHI in common MAGDAT holds the number of the operator
CD                which generates a sub-lattice, and
CD          PHIH the corresponding phase factor as read from the crystal data.
CD On exit  IPTAB(I,MGAT) in MAGDAT has an entry for each symmetry operator I
CD                        giving the number labelling the sublattice which is
CD                        generated by the operation of J on MGAT. The
CD                        fundamental sublattice is labelled 1.
CD Logical FCENT(MGAT)    is set TRUE when the centre of symmetry generates
CD                        magnetically independent sublattices which need
CD                        phase factors: in which case the index I in
CD                       IPTAB runs from 1 to NOP, rather than 1 to NOPC.
CN The phase offsets refer to atoms in the actual positions generated by the
CN symmetry elements, they need not necessarily be in the origin cell.
CO Diagnostic O/P to LPT if BINDIG(IOUT,256)
C
%      DIMENSION TPHI(%PSIS%),LTPHI(%PSIS%),ITTAB(%PSIS%),ISET(%SYMO%),
     &IFTAB(*)
      LOGICAL LERCHK,FOUND,BINDIG
C4.6 Diagnostic output given by 2**4 (256) set in OUTP
/ATNAM/
/CONSTA/
/IOUNIT/
/MAGDAT/
/NSYM/
/POSNS/
/SATELL/
/SYMDA/
/SYMMAG/
%      DATA NPSI /%PSIS%/
C
      IAT=JMAGAT(MGAT)
C
C  COPY DATA READ TO TEMPORARY STORAGE
      CALL JGMEQ(LPHI(1,MGAT),LTPHI,1,NPHI(MGAT))
      CALL GMEQ(PHIH(1,MGAT),TPHI,1,NPHI(MGAT))
C  AND CLEAR LPHI
      CALL JGMZER(LPHI(1,MGAT),NPSI,1)
C
C Find the elements in the factor group of MSTAB which generate
C independent sublattices
      N=0
      NEW=0
      NOPR=NOPC
      NIC=1
C WHEN CENTRE OF SYMMETRY PRODUCES NEW SUBLATTICES
      IF (FCENT(MGAT)) THEN
        NOPR=NOP
        NIC=-1
      ENDIF
      CALL GMZER(IPTAB(1,MGAT),NOPR,1)
      DO 2 NO=1,NOPC
      DO 2 IC=1,NIC,-2
      IPOS=0
      IF (IABS(MSTAB(NO)).NE.NO) GO TO 2
      NEL=IFTAB(NO)
      DO 4 NPP=1,NOPC
      NP=NPP
      IF (NPP .GT.NOPC) THEN
        NP=NOPC-NPP
        NEL=-NEL
      ENDIF
      IF (IABS(MSTAB(IABS(NP))).EQ.NO) THEN
C TO CHECK WHETHER THIS OPERATOR HAS OCCURED BEFORE
        CALL COSET(NP,ISET(IPOS+1),NC,IFTAB,NOPC)
        IF (IC.LT.0) CALL JGMREV(ISET(IPOS+1),ISET(IPOS+1),NC,1)
C        WRITE (LPT,1009) 'A ',IC,N,NPP,NP,(ISET(IPOS+II),II=1,NC)
       IPOS=IPOS+NC
      ENDIF
    4 CONTINUE
      IF (N.NE.0) THEN
        DO 25 IP=1,IPOS
        NEW=NFIND(ISET(IP),ITTAB,N)
        IF (NEW.NE.0) GO TO 26
   25   CONTINUE
      ENDIF
      IF (.NOT. LERCHK(2,N,NPSI,1,'non-equivalent sublattices for'
     &  //ATNAME(IAT))) THEN
       write (lpt,5000) ip,ISET(ip),(Ittab(ii),ii=1,npsi)
 5000 format ('ip,iset,ittab:',2i5,2x,4i4)
        GO TO 100
      endif
      ITTAB(N)=NO*IC
      if (BINDIG(IOUT,256)) WRITE (LPT,5001) N,(ITTAB(LL),LL=1,N)
 5001 FORMAT ('ITTAB: ',8I4)
      NEW=N
      IF (BINDIG(IOUT,256)) WRITE (LPT,1009)
     &'B ',IC,NEW,NPP,NP,(ISET(II),II=1,IPOS)
 1009 format (1x,A2,I3,' Phase',i3,' Operator',2i3,' Coset',12i3)
      FOUND=.FALSE.
      DO 3 II=1,IPOS
      IJ=ISET(II)
      IF (IJ.LT.0) IJ=NOPC-IJ
      IPTAB(IJ,MGAT)=NEW
      IF (.NOT. FOUND) THEN
        L = NFIND(ISET(II),LTPHI,NPHI(MGAT))
        IF (L .NE.0) THEN
          LPHI(NEW,MGAT)=ITTAB(N)
          PHIH(NEW,MGAT)=TPHI(L)
          FOUND=.TRUE.
        ENDIF
      ENDIF
    3 CONTINUE
      IF (.NOT. FOUND)  CALL ERRIN2(ITTAB(N),1,
     &  'Phase for sublattice of '//ATNAME(IAT)//
     &  ' generated by operator',' not found')
   26 CONTINUE
    2 CONTINUE
C
      IF (.NOT. BINDIG(IOUT,256))  GO TO 100
 1000 FORMAT (' Psi Ops : ',4i4)
      WRITE (LPT,1000) (ITTAB(I),I=1,N)
      WRITE (LPT,1007) (I,IPTAB(I,MGAT),I=1,NOPC),
     &(NOPC-I,IPTAB(I,MGAT),I=NOPC+1,NOPR)
 1007 FORMAT (' PSI table : ',24(I4,' =',I3,1X))
      WRITE (LPT,1006) ' read ',(LTPHI(I),TPHI(I),I=1,NPHI(MGAT))
      NPHI(MGAT)=N
      WRITE (LPT,1006) 'stored',(LPHI(I,MGAT),PHIH(I,MGAT),I=1,N)
 1006 FORMAT (' PSI''s ',A6,' ',4(I4,F8.2,2X))
      WRITE (LPT,1005)
 1005 FORMAT (A7,(12I4))
C
  100 RETURN
      END
C
C
C
C
C LEVEL 4      SUBROUTINE PSYMOP(IPAR,MAXP)
      SUBROUTINE PSYMOP(IPAR,MAXP)
C
C *** PSYMOP by PJB August 2016 ***
CX
CC 2B
CH  Report the relationships between polarisation matrix elements
CH defined by the Q PSYM card
C
CP Called after INPSYM to report the relationships defined
CA IPAR and MAXP are set up by INPSYM
CA IPAR(18)  which component is related to which
CA MAXP The numver of independent matrix elements
CO Writes its findings to the listing filet

      DIMENSION IPAR(18)
      CHARACTER * 2 LCOMP(9)
      CHARACTER * 60 BUFF
/IOUNIT/
      DATA LCOMP/'XX','XY','XZ','YX','YY','YZ','ZX','ZY','ZZ'/

      WRITE (LPT,1010)
 1010 fORMAT (11X,'Par    Matrix Elements')
      DO 1 IP=1,MAXP
        LBUF=1
        ICOMP=NFIND(IP,IPAR,18)
        WRITE (BUFF(LBUF:),1000)IP,LCOMP(ICOMP)
        LBUF=LBUF+24
      DO 2 IC=1,18
        NUM=0
        IF ((IPAR(IC).EQ.IP) .AND. (IC .NE.ICOMP)) THEN
          IF (IC.GT.9) THEN
            WRITE (BUFF(LBUF:),1001) LCOMP(IC-9)
          ELSE
            WRITE (BUFF(LBUF:),1002) LCOMP(IC)
          ENDIF
          LBUF=LBUF+9
          NUM=NUM+1
        ELSE IF(IPAR(IC).EQ.-IP) THEN
          IF (IC.GT.9) THEN
            WRITE (BUFF(LBUF:),1003) LCOMP(IC-9)
          ELSE
            WRITE (BUFF(LBUF:),1004) LCOMP(IC)
         ENDIF
         LBUF=LBUF+9
          NUM=NUM+1
        ENDIF
      IF (NUM.GT.0)  WRITE (BUFF(LBUF:),1001)
    2 CONTINUE
      IF (LBUF .GT.1) WRITE (LPT,1005) (BUFF(I:I),I=1,LBUF)
    1 CONTINUE
      LBUF=1
      DO 3 IC=1,18
      IF (IPAR(IC).NE.0) GO TO 3
      IF (IC.GT.9) THEN
        WRITE (BUFF(LBUF:),1006) LCOMP(IC-9)
        LBUF=LBUF+1
      ELSE
        WRITE (BUFF(LBUF:),1007) LCOMP(IC)
      ENDIF
      LBUF=LBUF+6
    3 CONTINUE
      IF (LBUF .GT.1) WRITE (LPT,1008)(BUFF(I:I),I=1,LBUF)
 1000 FORMAT (10X,I3,7X,A2)
 1001 FORMAT (' =  (-',A2,')',3X)
 1002 FORMAT (' =    ',A2,4X)
 1003 FORMAT (' = -(-',A2,')',3X)
 1004 FORMAT (' =   -',A2,4X)
 1005 FORMAT (60A1)
 1006 FORMAT (' (-',A2,') ')
 1007 FORMAT (2X,A2,2X)
 1008 FORMAT ('Zero matrix elements: ',60A1)
      WRITE (LPT,1000)
      RETURN
      END


C
C
C
C
C LEVEL 4      SUBROUTINE PUNPAK(KK,IFAM,IGEN,ISPC)
      SUBROUTINE PUNPAK(KK,IFAM,IGEN,ISPC)
C
C *** PUNPAK by JCM 8 Nov 90 ***
C
CX
CC 6C
CH Unpacks a parameter specification from single integer.
CA On entry KK holds packed parameter specification
CA On exit IFAM holds family number
CA         IGEN holds genus number
CA         ISPC holds species number
CP KK  must have been made via a call of KPAK set up by LSETUP
CD Unpacks KK according to bases previously set
CN There is an inverse routine KPAK
C
      DIMENSION LPAK(5)
/LSQPAK/
C
      CALL NPACK(KK,LPAK,3,2,KKPACK)
      IFAM=LPAK(1)
      IGEN=LPAK(2)
      ISPC=LPAK(3)
      RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE PUTPAR(A,I,NUM,PAR,BAD)
      SUBROUTINE PUTPAR(A,I,NUM,PAR,BAD)
C
C *** PUTPAR by PJB Aug 91 ***
C
CX
CC 13C
CH Distributes parameters read by RDNUMS amongst individually named
CH variables.
CA On entry A is a vector of length at least NUM
CA          NUM is the number of parameters read by RDNUMS
CA          I is the position of the required parameter in A
CA          BAD is the value to put into PAR if the parameter wasn't read
CA              ie if I > NUM.
CA On exit the value has been set into PAR.
C
      DIMENSION A(1)
      IF (I.LE.NUM) THEN
        PAR=A(I)
      ELSE
        PAR=BAD
      ENDIF
      RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE QARRIN(N,K,FBUF,LUNI,IEND)
      SUBROUTINE QARRIN(N,K,FBUF,LUNI,IEND)
C
C *** QARRIN DUMMY CHANGED SPEC by PJB 12-July-99 ***
C
CX
CC 2B
CH In the library, simply a dummy routine.  If the user wishes some special
CH new input format for "ARRNGE" type main programs, he provides a new
CH version of QARRIN.
CA A replacement routine should set:
CA N=serial number of next reflection
CA K= h,k,l for next reflection
CA FBUF data buffer to contain F, DF, angles etc as required
CA LUNI is the CCSL unit on which to read the data
CA IEND is a logical, set TRUE if there are no more reflections.
C
CD In ARRNGE and similar main programs, if in /ARRDAT/ IFOR(1)=0, it is
CD expected that the user has included his own version of QARRIN.
C
      DIMENSION FBUF(1),K(3)
      LOGICAL IEND
C TO KEEP COMPILER HAPPY
      IEND = .TRUE.
      FBUF(1)=FBUF(1)
      LUNI=LUNI
      N=N
      K(1)=K(1)
      RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE QFOUIN(K,F,ALPHA,ENDD)
      SUBROUTINE QFOUIN(K,F,ALPHA,ENDD)
C
C *** QFOUIN DUMMY by JCM 20 Mar 84 ***
C
CX
CC 5B
CH In the library, simply a dummy routine.  If the user wishes some special
CH new input format for Fourier routines, he provides a new version of
CH QFOUIN.
C
CD Called when type 0 Fourier coefficient input is specified.  The user-
CD supplied routine must set:
CD K(1:3) = h,k,l
CD F(1:2) and PHASE according to the value of DTYP on an "M" card,
CD LOGICAL ENDD to be TRUE if there are no more items of data.
C
      LOGICAL ENDD
      DIMENSION K(3),F(2)
C to keep compilers happy
      ENDD = .TRUE.
      K(1)=K(1)
      F(1)=F(1)
      ALPHA=ALPHA
      RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE QLSQIN(K,IEND)
      SUBROUTINE QLSQIN(K,IEND)
C
C *** QLSQIN DUMMY by JCM 17 Nov 84 ***
C
CX
CC 6B
CH In the library, simply a dummy routine.  If the user wishes some special
CH new input format for Least Squares routines, he provides a new version
CH QLSQIN.
C
CD Called if data input type 0 is specified.  The user's routine must set:
CD   K(1:3) = h,k,l
CD   LOGICAL IEND = TRUE if there are no more data,
CD  and in /OBSCAL/, OBS=the observation, DOBS=its esd.
C
      LOGICAL IEND
      DIMENSION K(3)
/IOUNIT/
/OBSCAL/
C
C to keep compilers happy
      IEND = .TRUE.
      K(1)=K(1)
      RETURN
      END
C
C
C
C
      SUBROUTINE RANMOV(NA,RANDEL)
C
C *** RANMOV by JCM 28 Nov 91 ***
C
CX
CC 4B
CH Makes a change in atomic coordinates, according to the constraints
CA On entry NA=which atom
CA          RANDEL is an array of required shifts, holding 0,1,2 or 3 numbers
CA                 as appropriate.
CP Routine XYZREL must have set up the constraints in /POSREL/.
CD If the atomic position is unconstrained, applies RANDEL(1) to x, RANDEL(2)
CD to y and RANDEL(3) to z.  If there are constraints in /POSREL/, uses these
CD to shift some or all of x,y and z according to these constraints.
CD
CD Takes its shifts in sequence from the array RANDEL.
C
      DIMENSION RANDEL(3)
/POSNS/
/POSREL/
C
      J=0
      NFIR=0
      DO 1 I=1,3
      IF (NXYZ(I,NA) .LE. 0) GO TO 1
      IF (NXYZ(I,NA) .EQ. 9999 .OR. NFIR .EQ. 0) THEN
        J=J+1
        X(I,NA)=X(I,NA)+RANDEL(J)
C FIRST OF A RELATED SET IS MARKED SPECIALLY:
        IF (NXYZ(I,NA) .NE. 9999) THEN
          NFIR=I
          NRAN=J
        ENDIF
      ELSE
        X(I,NA)=X(I,NA)+(XYZ(NFIR,NA)/XYZ(I,NA))*RANDEL(NRAN)
      ENDIF
   1  CONTINUE
      RETURN
      END
C
C
C
C
C LEVEL 4      SUBROUTINE RADFUN(JAT,IEND)
      SUBROUTINE RADFUN(JAT,IEND)
C
C *** RADFUN updated by C139 July-4-2005 ***
C
CX
CC 4A
CH Reads coefficients for the expansion of an atomic wave function.
C
CA On entry JAT indicates which atom (but is irrelevant if IEND=0)
CA          IEND points to the first character position on the card to read,
CA               unless IEND is -ve, when it is a request for initialisation.
CA               or IEND=0, which requests checking and printing.
C
CD The card has already been read as far as "W atom-name RADF".
CD Entry IEND +ve reads the coefficients in atomic units of IMAX Slater
CD type functions, for the expansion of an atomic wave function as a sun
CD of tems of the form:    F(1,I)*R**N(I)*exp(-F(2,I)*R)
CD In mode 1 the F(1,I) are not normalised (Clementi) and in mode 2 they are
CD (Watson).
CD The numbers given are MODE, N(I,IAT), F(1,I,IAT) AND F(2,I,IAT)
CD
CD Entry IEND=0 converts the coefficients to Angstrom units, and checks for
CD normalisation, for atom JAT.
C
CO Entry IEND=0 writes its findings to unit LPT.
C
/IOUNIT/
/RADINT/
/SCRACH/
%      COMMON /SCRAT/MODE(%MPAT%),IROT(%MPAT%),TEMP(3,3),MFUN(10,%MPAT%),LENG(3)
      DATA S/1.8896/
C
      IF (IEND) 30,20,1
C
C  INITIALISE
  30  NRADF=0
%      CALL JGMZER(NTERMS,1,%RADF%)
      GO TO 100
C
C  READ REST OF CARD STARTING W <ATOM> RADF:
   1  IF (NRADF .EQ. 0 .OR. IRADF(NRADF) .NE. -JAT) THEN
%        CALL ERRCHK(2,NRADF,%RADF%,0,
     &   'radial functions')
        IRADF(NRADF)=-JAT
      ENDIF
      IPT1=IEND
      DO 4 I=1,2
      IPT=IPT1
      MODE(NRADF)=NN
      CALL RDINTG(NN,IPT,IPT1,80,IER)
      IF (IER.NE.0) GO TO 99
    4 CONTINUE
C
      IT=NTERMS(NRADF)
      IT=IT+1
      NTERMS(NRADF)=IT
      N(IT,NRADF)=NN
C
      DO 5 I=1,2
      IPT=IPT1
      CALL RDREAL(FF(I,IT,NRADF),IPT,IPT1,80,IER)
      IF (IER.NE.0) GO TO 99
    5 CONTINUE
      GO TO 100
C
C ERRORS IN READING:
  99  CALL ERRCH2(ICARD(IPT:IPT1-1),2,'cannot interpret','on W card')
      GO TO 100
C
C  ENTRY TO CHECK ONE ATOM AND OUTPUT PARAMETERS
C139  HAS IT BEEN DONE ALREADY
  20  IF (NFIND(JAT,IRADF,NRADF) .NE.0) GO TO 100
      IAT=NFIND(-JAT,IRADF,NRADF)
      IF (IAT .GT. 0) IMAX=NTERMS(IAT)
      IF (IAT .EQ. 0 .OR. IMAX .EQ. 0) THEN
        CALL ERRMES(1,1,'No radial wave-function given')
        GO TO 100
      ENDIF
      IRADF(IAT)=JAT
      CALL MESS(LPT,1,'Radial wave function :  Exponent      '//
     & 'Amplitude     Screening')
      CALL MESS(LPT,0,'                           of r'//
     & '                      Constant')
      DO 21 I=1,IMAX
      XI=FF(2,I,IAT)
      A=FF(1,I,IAT)
      FF(2,I,IAT) = S*XI
      XX = FLOAT(N(I,IAT)) + 1.5
      IF (MODE(IAT) .EQ. 1) GO TO 22
      FF(1,I,IAT) = A*(S**XX)
      GO TO 23
   22 XX = 2.0*XX
      Y = (2.*FF(2,I,IAT))**XX
      Y = 1./Y
      Y = Y*FACT(IFIX(XX)-1)
      Y = SQRT(1./Y)
      FF(1,I,IAT) = A*Y
   23 WRITE (LPT,2001) N(I,IAT),A,XI
2001  FORMAT (25X,I5,7X,F10.5,4X,F10.5,3X,E12.5)
   21 CONTINUE
C
C     CHECK NORMALISATION
      SUM = 0.
      DO 24 I = 1,IMAX
      DO 25 J = 1,IMAX
      IX = (N(I,IAT)+N(J,IAT)+3)
      Y = FF(1,I,IAT)*FF(1,J,IAT)*FACT(IX-1)
      Y = Y/((FF(2,I,IAT)+FF(2,J,IAT))**IX)
   25 SUM = SUM + Y
   24 CONTINUE
      Y = ABS(SUM-1.0)
      IF (Y .GT. 0.0005) CALL ERRRE2(SUM,1,
     & 'Function is not normalised','needed as normalisation integral')
  100 RETURN
      END
C
C
C
C
C LEVEL 1      FUNCTION RADIAN(X)
      FUNCTION RADIAN(X)
C
C *** RADIAN by JCM ***
C
CX
CC 10C
CH Converts from degrees to radians.
CA On entry X is the value of an angle in degrees
CD On exit  X has been converted to radians.
CN The function DEGREE(X) does the radians to degrees conversion
CN In routines where time matters, it is quicker to declare the COMMON
CN /CONSTA/ and multiply X by RAD.
C
/CONSTA/
C
      RADIAN = RAD*X
      RETURN
      END
C
C
C
C
C LEVEL 2      FUNCTION RANGER(X,A,B)
      FUNCTION RANGER(X,A,B)
C
C *** RANGER renamed from RANGE by PJB Nov 2010 C4.21 ***
C
CX
CC 11C
CH Puts a number into a given range.
CA On entry X is the current value of a real variable.
CA          A and B are the limits between which RANGE is to be set.
CD X must be periodic in (A-B).  A is included in the range, but B excluded.
CN A is not necessarily > or < B.
C
C4.2 test to avoid cycling with nan
      IF (X.NE.X) CALL ERRMES(1,0,'nan input to range subroutine')
      P=ABS(A-B)
      IF (A .GT. B) THEN
        ALOW=B
        AUP=A
      ELSE
        ALOW=A
        AUP=B
      ENDIF
      R=X
   1  IF (R .LE. AUP) GO TO 2
      R=R-P
      GO TO 1
C
   2  IF (R .GE. ALOW) GO TO 101
      R=R+P
      GO TO 2
C
 101  IF (R .EQ. B) R=A
      RANGER=R
      RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE RATFRC(F,I,J)
      SUBROUTINE RATFRC(F,I,J)
C
C ***  RATFRC  NEW BY by PJB April 03 ***
C
CH To make a rational fraction of the form F**2=I/J out of F
CC 9C
C
CD Trys to make a rational fraction of the form F**2=I/J out of F
CD if it doesn't succeed returns I=J=0


      DIMENSION VEC(2,3)
      LOGICAL INV
      DATA FPREC/10E-6/
C
      IF (ABS(F).LT.FPREC) GO TO 99
      F2 = F*F
      INV = (F2.LT.1)
      IF (INV) F2=1./F2
      INTPT = IFIX(F2)
      F1=AMOD(F2,1.)
      PREC = 2.*FPREC*F2
C Integer already
      IF (F1.LT.PREC) THEN
        I=INTPT
        J=1
        GO TO 2
      ENDIF
      ICYC=1
      FF=1./F1
C Two lines to include required point
      VEC(1,1)=1.
      VEC(2,1)=AINT(FF)
      VEC(1,2)=1.
      VEC(2,2)=VEC(2,1)+1.0
C Check whether either is close enough
      DO 3 II=1,2
      IF (ABS((1./VEC(2,II))-F1) .LT. PREC) GO TO 4
    3 CONTINUE
C
      II=3
    1 VEC(1,3)=VEC(1,1)+VEC(1,2)
      VEC(2,3)=VEC(2,1)+VEC(2,2)
      AM = VEC(1,3)/VEC(2,3)
      DEL= F1-am
      IF (ABS(DEL).LT.PREC) GO TO 4
      IF (DEL.GT.0) THEN
C SLOPE NOT YET BIG ENOUGH
        N=2
      ELSE
        N=1
      ENDIF
    5 VEC(1,N)=VEC(1,3)
      VEC(2,N)=VEC(2,3)
      ICYC=ICYC+1
      IF (ICYC.LT. 999)  GO TO 1
      GO TO 99
    4 I = NINT(VEC(1,ii))
      J = NINT(VEC(2,ii))
      I = I+INTPT*J
    2 IF (.NOT. INV) GO TO 5
      II=I
      I=J
      J=II
      GO TO 100
   99 I=0
      J=0
  100 RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE RCMPRD(A,B,C,I,J,K)
      SUBROUTINE RCMPRD(A,B,C,I,J,K)
C
C *** RCMPRD by PJB Jun 87 ***
C
CX
CC 12C
CH Performs the multiplication of a COMPLEX by a REAL matrix.
CA On entry A is a real IxJ matrix,
CA          B is a complex JxK matrix,
CA On exit  C is returned as the complex IxK matrix A*B
C
      DIMENSION A(1)
      COMPLEX B(1),C(1)
C
      DO 2 II = 1,I
      IK = II
      JK = 1
      DO 2 KK = 1,K
      IJ = II
      C(IK) = 0.
      DO 1 JJ = 1,J
      C(IK) = C(IK) + A(IJ)*B(JK)
      IJ = IJ + I
    1 JK = JK + 1
    2 IK = IK + I
      RETURN
      END
C
C
C
C
C LEVEL 5      SUBROUTINE RDANGL(IPT,N1,N2,N3,NCOM,IE)
      SUBROUTINE RDANGL(IPT,N1,N2,N3,NCOM,IE)
C
C *** RDANGL by JCM 15 Oct 90 ***
C
CX
CC 8A
CH Reads a specification of a bond angle, by reading the names of 2 intersecting
CH bonds;  makes the third bond involved.
CA On entry IPT is the position at which to start reading, and it is updated.
CA On exit N1, N2 and N3 specify the 3 bonds making up the triangle containing
CA         the angle.  The angle is opposite N1, enclosed by N2 and N3,
CA         with N2 < N3.
CA         NCOM points to the common atom.
CA         IE is an error indicator - IE=0 if OK, not 0 if error.
C
CD Reads and identifies 2 bond names;  finds their common atom; makes the
CD third bond of the triangle and adds it to the bond list.
C
CO Reports an error if bonds are not in list, or if bonds have no atom in
CO common.
C
      CHARACTER *4 BNAME
/SLKGEC/
/SLKGEO/
C
      IE=0
C READ FIRST BOND NAME:
      CALL RDWORD(BNAME,LEN,IPT,IPT,80,0,IER)
      N2=NCFIND(BNAME,BONNAM,NUMBON)
      IF (N2 .LE. 0) GO TO 11
C READ SECOND BOND NAME:
      CALL RDWORD(BNAME,LEN,IPT,IPT,80,0,IER)
      N3=NCFIND(BNAME,BONNAM,NUMBON)
      IF (N3 .GT. 0) GO TO 12
C
  11  CALL ERRCH2(BNAME,2,' ','is not a bond name')
      IE=1
      GO TO 100
C
C FIND THIRD SIDE:
  12  CALL BONTRI(N2,N3,N1,NCOM,IE)
 100  RETURN
      END
C
C
C
C
C LEVEL 4        SUBROUTINE RDATOM(IPT,IA,XACT,ISYMM,ILATT,CS)
       SUBROUTINE RDATOM(IPT,IA,XACT,ISYMM,ILATT,CS)
C
C *** RDATOM updated by JCM 7 Sep 90 ***
C
CX
CC 8A
CH Reads the specification of an atom for slack constraint purposes
CA On entry IPT points to the first character to read
CA On exit IA holds which base atom the new one is related to
CA         XACT holds the actual x,y,z coordinates
CA         ISYMM, ILATT and CS hold the transformation which takes the
CA                   base atom into the actual coordinates
CP On entry ICARD in /SCRACH holds the card read
CD Reads an atom name, which must be the same as one on an A card.
CD This may be followed either by 3 coordinates, x,y,z or by a
CD symmetry operator number, a lattice translation number, and 3
CD cell shifts.
CD
CD In either case, the actual destination atom, related to that on the
CD A card, is identified.
C
      DIMENSION XACT(3),CS(3)
      CHARACTER *4 NAME
/ATNAM/
/CARDRC/
/IOUNIT/
/NSYM/
C
C READ NAME OF BASE ATOM:
      CALL RDWORD(NAME,LEN,IPT,IPT,80,0,IER)
      IA=IATOM(NAME)
      IF (IA .LE. 0) THEN
        CALL ERRATM(NAME,1,'on L ATOM card')
        GO TO 100
      ENDIF
C
C READ SYMMETRY NUMBER (POSSIBLY -), LATTICE NUMBER AND 3 CELL TRANSLATIONS:
      IPKEEP=IPT
      ILATT=1
      DO 1 I=1,3
   1  CS(I)=0.
      CALL RDINTG(ISYMM,IPT,IPT,80,IER)
C MAY HAVE READ INTEGER, NOTHING OR DECIMAL NUMBER FOR X COORD:
      IF (IER .NE. -1) GO TO 10
C INSTEAD OF AN INTEGER WE HAVE TRIED TO READ A REAL.  X Y AND Z GIVEN.
      IPT=IPKEEP
      DO 19 I=1,3
  19  CALL RDREAL(XACT(I),IPT,IPT,80,IER)
      CALL XROOT(IA,XACT,ISYMM,ILATT,CS)
      IF (ISYMM .NE. 0) GO TO 2
      WRITE (LPT,3009) ATNAME(IA),XACT
      WRITE (ITO,3009) ATNAME(IA),XACT
3009  FORMAT (/' ERROR ** ',A4,' WILL NOT TRANSFORM INTO ',3F10.4)
      GO TO 99
C
C MAY BE SIMPLE LABEL FOR ATOM AS ON A CARD, OR PART SPEC:
C IF INTEGER READ IT IS SPECIFICATION FOR SYMMETRY OPERATOR:
  10  IF (IER .EQ. 100 .OR. ISYMM .EQ. 0) THEN
        ISYMM=1
        GO TO 2
      ENDIF
C
C CHECK SYMMETRY OPERATOR NUMBER:
      IF (IABS(ISYMM) .GT. NOPC) THEN
        WRITE (LPT,3003) ISYMM,NOPC
        WRITE (ITO,3003) ISYMM,NOPC
3003    FORMAT (/' ERROR ** symmetry operator number',I4,
     &   ' requested but only',I4,' present')
      GO TO 99
      ENDIF
C
      IF (ISYMM .LT. 0 .AND. .NOT. CENTRC) THEN
      CALL ERRMES(1,-1,'-ve symmetry operator in non-centric group')
      GO TO 99
      ENDIF
C
C READ AND CHECK LATTICE NUMBER (ALLOWED TO BE MISSING):
      CALL RDINTG(ILATT,IPT,IPT,80,IER)
      IF (IER .EQ. 100 .OR. ILATT .EQ. 0) GO TO 2
C
      IF (ILATT .GT. NLAT .OR. ILATT .LE. 0) THEN
        WRITE (LPT,3005) ILATT,NLAT
        WRITE (ITO,3005) ILATT,NLAT
3005    FORMAT (/' ERROR ** lattice translation number',I4,
     & ' requested but only',I4,' present')
        GO TO 99
      ENDIF
C
C READ AND CHECK CELL TRANSLATIONS:
      DO 3 K=1,3
      CALL RDREAL(CS(K),IPT,IPT,80,IER)
      IF (IER .NE. 0) GO TO 2
   3  CONTINUE
C
C MAKE ACTUAL COORDS FOR BOTH POSITIONS:
   2  CALL XTRANS(IA,XACT,ISYMM,ILATT,CS)
      GO TO 100
C
  99  IERR=IERR+1
 100  RETURN
      END
C
C
C
C
C LEVEL 4      SUBROUTINE RDBOND(IPT,NEND,IE)
      SUBROUTINE RDBOND(IPT,NEND,IE)
C
C *** corrected by KS Sept-1995 ***
C
CX
CC 8A
CH Reads a specification of a bond, by reading the names of the atoms at each
CH end.
CA On entry IPT is a starting position on the card.
CA On exit  NEND is an integer array of 2 elements which holds the numbers
CA             of the ends so identified in the list of L ATOM cards.
CA          IE is an error indicator - on exit IE=0 if OK, not 0 if error.
C
CD Given an L BOND card in /SCRACH/, reads the next 2 atom names.  An atom
CD may belong to the list already given on L ATOM cards, or it may be the
CD name of an atom in the asymmetric unit, on an A card.  In the latter case
CD it is added to the L ATOM list.
C
CO Reports an error if the atom names occur in neither list.
C
      CHARACTER *4 NAME
      REAL*4 CZ(3)
      DIMENSION NEND(2)
/ATNAM/
/POSNS/
/SLKGEC/
/SLKGEO/
C
      IE=0
C READ 2 ATOM NAMES:
      DO 1 J=1,2
      CALL RDWORD(NAME,LEN,IPT,IPT,80,0,IER)
      NEND(J)=0
      IF (NTARNM .GT. 0) NEND(J)=NCFIND(NAME,ATTNAM,NTARNM)
      IF (NEND(J) .GT. 0) GO TO 1
      N=IATOM(NAME)
      IF (N .EQ. 0) THEN
        CALL ERRATM(NAME,2,'L BOND card')
        IE=1
        GO TO 100
      ENDIF
C NAME OFF A CARD USED - ADD IT TO TARGET TABLE:
      CALL GMZER(CZ,1,3)
      CALL ADDATM(ATNAME(N),N,X(1,N),1,1,CZ,NEND(J))
C
   1  CONTINUE
 100  RETURN
      END
C
C
C
C
C LEVEL 5      SUBROUTINE RDDATA(NUNIT,K,H,F,IN,IOU)
      SUBROUTINE RDDATA(NUNIT,K,H,F,IN,IOU)
C
C *** RDDATA by JCM 5 Apr 89 updated by PJB Aug 2017 4.38 to skip header lines ***
C
CX
CC 13C
CH Reads in free format h,k,l (possibly floating) and a list of values,
CH allowing for a possible title.
CA On entry NUNIT is the unit from which to read
CA          IN indicates other incoming information:
CA          IN +ve means allow one line of text (recognised by containing
CA             any letter other than E)
CA          IN -ve means expect only numbers - this entry would be used for
CA             reading lines of a files other than the first.
CA          IN absolute value gives maximum number of numbers to read to F
CA On exit H(1:3) contains the first 3 numbers read, real
CA         K(1:3) contains the same numbers, fixed to integers.
CA         F() contains all the subsequent numbers on the line, reals.
CA             (maximum abs(IN) of them)
CA         IOU, absolute value, holds (as its units digit) the number of
CA               numbers read to the array F.  No array bound check is done
CA               on F at present.
CA         IOU is -9999 if end of file reached, so nothing new read
CA         IOU, sign, is +ve if no errors detected
CA                         -ve if some reading error occurred, or title
CA                            out of context.
CA         IOU, absolute value, has 100 added if title read.  In this case
CA                         the routine reads in the next line also.
C
CD Ignores empty lines.  If IN > 0 and finds text line, adopts it as a title
C
      DIMENSION H(3),K(3),F(1)
/SCRACH/
C
      IOU=-9999
      IREADT=0
   4  READ (NUNIT,1000,END=100) ICARD
1000  FORMAT (A80)
C Skip header lines starting #
      if (ICARD(1:1).eq.'#') go to 4
      IPT=1
      IOU=1
      L=LENGT(ICARD)
      IF (L .EQ. 0) GO TO 4
      DO 3 I=L,1,-1
      M=LETTER(ICARD(I:I))
      IF (M .EQ. 5) GO TO 3
      IF (M .GT. 0) THEN
C ASSUME TITLE GIVEN:
      IF (IN .LT. 0 .OR. IREADT .EQ. 1) CALL ERRMES(1,0,
     &  'letters on data file')
      CALL INPUTN(-1)
      IREADT=1
      GO TO 4
      ENDIF
   3  CONTINUE
C
      DO 2 I=1,3
   2  CALL RDREAL(H(I),IPT,IPT,80,IER)
      CALL INDFIX(H,K)
C READ AS MANY NUMBERS AS REMAIN:
      I=0
   1  I=I+1
      IF (I .GT. IABS(IN)) GO TO 5
C READ FIRST IN CASE EMPTY:
      CALL RDREAL(A,IPT,IPT,80,IER)
      IF (IER .EQ. 0) THEN
        F(I)=A
        GO TO 1
      ENDIF
      IF (IER .NE. 100) IOU=-1
C
   5  IOU=IOU*(I-1+100*IREADT)
 100  RETURN
      END
C
C
C
C
C LEVEL 8      SUBROUTINE RDFV(DOTHER)
      SUBROUTINE RDFV(DOTHER)
C
C *** RDFV updated by PJB C4.26 March 2013 ***
C allow fix vary of blanket spec for parameters separated in store
CX
CC 6A
CH Reads all the user's L FIX and L VARY cards in sequence.
C
CA DOTHER is a logical function which with be called to try to interpret
CA blanket type words such as MPAR (all magnetic parameters) which are not
CA already catered for in RDFV.
CD The cards read here start either L FIX or L VARY.  Next come as many
CD parameter specifications as the user wishes.  A parameter specification
CD in this context is one of:
C
CD   ONLY
CD   ALL <F>                       where <F> is a family name
CD   ALL <G>                       where <G> is genus name
CD   ALL <S>                       where <S> is species name.
CD   ALL <W>                       where <W> is a word for a
CD                                  number of species as set up by the
CD                                  main program, e.g. "XYZ".
CD Examples:
CD L FIX ONLY SCAL 1  TFAC
CD L VARY ALL SITE
CD L VARY NA1 X  NA2 XYZ  O1 ITF
CD L FIX ALL BIJ
CD L VARY ONLY C1 B11   C1 B22   C1 B33   C2 XYZT  ALL C3
CD L VARY ALL FAM1
CD
CD In identifying a parameter, RDFV then stores the instruction to fix
CD or vary it accordingly.  Such instructions are not actually certain
CD to be used until the routine VARMAK is called, which surveys them all
CD and may discard some in favour of others.
C
CN It should be noted that even in this "general" routine used by all
CN LSQ programs, family 1 genus 1 is special, in having no genus name
CN (so that it includes items with single names, e.g. "TFAC").  Also
CN family 2 is special, being the crystal structure parameters.
CN When an atom name is found, it is taken to be a genus name in family 2.
C
CI Reads in L FIX and L VARY cards.
C
      EXTERNAL DOTHER
      CHARACTER *4 NFV(2)
      LOGICAL FX,DOTHER
      DIMENSION IPARS(4)
/CELFIX/
/IOUNIT/
/LINKAG/
/NEWOLD/
/PHASE/
/REFINE/
/SOURCE/
      DATA NFV/'FIX','VARY'/
C
C COUNT CARDS - MAY BE NONE:
      IN=0
C LOOK FOR EITHER L FIX OR L VARY:
   8  CALL CDSCAN('L',NFV,2,IN,L,NW)
      IF (L .LE. 0) GO TO 100
      FX=(NW .EQ. 1)
      IN=L
      IPT=7
C
C READ NEXT PARAMETER SPECIFICATION ON CARD:
   7  CALL PARRD(IPT,IPT,KK,IFAM,IGEN,ISPC)
C KK ZERO MEANS NO MORE ON THIS CARD:
      IF (KK .EQ. 0) GO TO 8
C
C KK POSITIVE IS A PARAMETER SPEC.  ALL OF IFAM,IGEN AND ISPC SHOULD BE
C NON-ZERO.  ANY MORE COMPLICATED SPECS (LIKE 'ALL X' OR 'ALL FAM1') HAVE COME
C OUT WITH KK NEGATIVE.
C
      IF (KK .LT. 0) GO TO 1
C WE HAVE WHOLE SPEC - FIX OR VARY THE PARAMETER AS REQUIRED:
      CALL FVKPAK(KK,4,FX)
C IF VARY, NOW DO AND ALL WHO SAIL IN HER:
      IF (FX) GO TO 7
      DO 4 I=1,NUMCON
      IF (KPTCON(I+1)-KPTCON(I) .NE. 2) GO TO 4
      KK1=KKCON(KPTCON(I))
      KK2=KKCON(KPTCON(I)+1)
      IF (KK2 .EQ. KK) GO TO 15
      KK2=KKCON(KPTCON(I))
      KK1=KKCON(KPTCON(I)+1)
      IF (KK2 .NE. KK) GO TO 4
C VARIED PAR IS SIMPLY RELATED TO ANOTHER: VARY THAT TOO
  15  CALL FVKPAK(KK1,4,FX)
   4  CONTINUE
      GO TO 7
C
C KK LARGE & -VE MEANS WORDS  LIKE ONLY, ALL, XYZ BIJ - BRANCH:
   1  I100=-KK-98
C 1=ONLY  2=ALL  3=XYZ IN SFLSQ ETC, 4=BIJ DITTO, 5=XYZT DITTO
      GO TO (11,12,13,14) , I100
      GO TO 13
C
C 'ONLY'
  11  IF (IONLY(JPHASE) .NE. 0) GO TO 7
      IONLY(JPHASE)=1
      IF (.NOT. FX) IONLY(JPHASE)=2
      GO TO 7
C
C 'ALL'
  12  IF (IFAM .EQ. 0) THEN
        WRITE (LPT,3000) KK,IFAM,IGEN,ISPC
        WRITE (ITO,3000) KK,IFAM,IGEN,ISPC
3000    FORMAT (/' *** PROGRAM ERROR in RDFV ** ''ALL'' read, but',
     &   ' KK,IFAM,IGEN,ISPC=',4I5)
        STOP
      ENDIF
C
C -VE IFAM MEANS "ALL <W>" READ, LIKE ALL BIJ:
      IF (IFAM .GT. 0) GO TO 29
      I1=IABS(IFAM)
      GO TO (21,22,21,24,25,21) , I1
      IDOTH =7
      GO TO 36
      CALL ERRMES(1,0,'unforseen word after ALL in RDFV')
C
C ALL XYZB:
  25  L1=1
      GO TO 19
C
C ALL XYZ OR ALL XYZT OR ALL XYZS:
  21  DO 30 J=1,3
  30  CALL FIXVAR(FX,2,0,J,KPHASE,KSOURC,4)
      IF (I1 .EQ. 3) CALL FIXVAR(FX,2,0,12,KPHASE,KSOURC,4)
      IF (I1 .EQ. 6) CALL FIXVAR(FX,2,0,11,KPHASE,KSOURC,4)
      GO TO 7
C
C ALL BIJ:
  22  L1=4
  19  DO 32 J=L1,9
  32  CALL FIXVAR(FX,2,0,J,KPHASE,KSOURC,4)
      GO TO 7
C
C ALL CELL:
  24  DO 34 J=1,6
  34  CALL FIXVAR(FX,NCELF,NCELG,NCELS+J-1,KPHASE,KSOURC,4)
      GO TO 7
C
  29  IF (ISPC .NE. 0) GO TO 3
      IF (IGEN .NE. 0) GO TO 10
C FIX ALL OF FAMILY:
      CALL FIXVAR(FX,IFAM,0,0,KPHASE,KSOURC,4)
      GO TO 7
C
C OPERATE ON ALL SPECIES OF GIVEN GENUS:
  10  CALL FIXVAR(FX,IFAM,IGEN,0,KPHASE,KSOURC,4)
      GO TO 7
C
C KNOWN FAMILY, UNKNOWN GENUS:
   3  CALL FIXVAR(FX,IFAM,0,ISPC,KPHASE,KSOURC,4)
      GO TO 7
C
  13  IF (I100 .GT. 9) THEN
        I1 = I100 -2
        IDOTH=6
      ENDIF
   36 IF (DOTHER(I1,IDOTH,IPARS)) then
C       DO 35 J=IPARS(3),IPARS(4)
C       CALL FIXVAR(FX,IPARS(1),IPARS(2),J,KPHASE,KSOURC,4)
C   35  CONTINUE
C Need to do again if required parameters are separated in store
       IF (I1 .LT. 0) GO TO 36
       GO TO 7
      ENDIF
      CALL ERRMES(1,0,'unforseen word in RDFV')
C <G> XYZ OR <G> XYZT :
      L1=3
      IF (I100 .EQ. 6) L1=9
      DO 5 I=1,L1
   5  CALL FIXVAR(FX,IFAM,IGEN,I,KPHASE,KSOURC,4)
      IF (I100 .EQ. 5) CALL FIXVAR(FX,IFAM,IGEN,12,KPHASE,KSOURC,4)
      IF (I100 .EQ. 7) CALL FIXVAR(FX,IFAM,IGEN,11,KPHASE,KSOURC,4)
      GO TO 7
C
C <G> BIJ:
  14  DO 6 I=4,9
   6  CALL FIXVAR(FX,IFAM,IGEN,I,KPHASE,KSOURC,4)
      GO TO 7
C
      GO TO 7
C
 100  RETURN
      END
C
C
C
C
C LEVEL 2      SUBROUTINE RDINTG(N,IPT1,IPT2,IPTEND,IER)
      SUBROUTINE RDINTG(N,IPT1,IPT2,IPTEND,IER)
C
C *** RDINTG by JCM 10 Oct 83 ***
C
CX
CC 13C
CH Reads an integer in free format from a character string.
CA On entry IPT1 points to the first character in the string to consider
CA          IPTEND points to the last to be considered
CA On exit  N is the integer which was read
CA          IPT2 points to the first character after the terminating
CA               character, unless there was an erroneous character,
CA               in which case IPT2 points to it.
CD          IER = 0 if no errors were found
CD              = 100 if N=0 was derived from all spaces (so note IER
CD                   non-zero is not always indicative of a fatal error)
CD              = number in range 1-52 if a letter was found (the value of
CD               IER indicates which letter)
CD              = small -ve number (being an address in table ISMBOL in
CD               COMMON /CHARS/) if a symbol was found out of context.
CD              =-100 if the character found did not occur in any table
CP Before entry the character string from which the integer is to be read
CP is read into /SCRACH/
CD The string is expected to contain only digits, a possible sign,
CD and a space or a comma to terminate.(The number is also terminated
CD after the character pointed to by IPTEND.)
C
      CHARACTER *1 IC
/SCRACH/
C
      IPT=IPT1
      IER=0
      N=0
      ISIG=0
C ISIG SAYS WHETHER ANYTHING SIGNIFICANT YET READ, THEN HOLDS SIGN
   1  IF (IPT .GT. IPTEND) GO TO 101
      IC=ICARD(IPT:IPT)
C IGNORE INITIAL SPACES;  TERMINATE ON FINAL SPACE:
      IF ((IC .EQ. ' ') .AND. (ISIG .EQ. 0)) GO TO 3
      IF ((IC .EQ. ' ') .AND. (ISIG .NE. 0)) GO TO 102
C TEST FOR DIGIT FIRST, AS MOST LIKELY CHARACTER TO OCCUR:
      N1=NDIGIT(IC)
      IF (N1 .LT. 0) GO TO 2
C
C DIGIT:
      IF (ISIG .EQ. 0) ISIG=1
      N=N*10+N1
C THIS OVERFLOWS IF TOO BIG A NUMBER IS GIVEN
      GO TO 3
C
C NEITHER DIGIT NOR SPACE:
   2  N2=NSYMBL(IC)
C JUMP IF SYMBOL (NOT LETTER):
      IF (N2 .GT. 0) GO TO 6
C IF HERE, ERROR, PROBABLY LETTER:
      L=LETTER(IC)
      IF (L .GT. 0) IER=L
      IF (L .EQ. 0) IER=-100
      GO TO 101
C
C SYMBOL: + AND - EXPECTED AT START;  COMMA COULD TERMINATE
   6  IF (N2 .EQ. 2) GO TO 102
      IF ((N2 .EQ.14) .AND. (ISIG .EQ.0)) GO TO 8
      IF ((N2 .EQ. 15) .AND. (ISIG .EQ.0)) GO TO 3
      IER=-N2
      GO TO 101
C
C MINUS:
   8  ISIG=-1
C
C NEXT CHARACTER:
   3  IPT=IPT+1
      GO TO 1
C
 102  IPT=IPT+1
 101  N=N*ISIG
      IPT2=IPT
      IF ((ISIG .EQ. 0) .AND. (IER .EQ. 0)) IER=100
      RETURN
      END
C
C
C
C
C LEVEL 4      SUBROUTINE RDNUMS(A,IPT1,NBOUND,NUM,IER)
      SUBROUTINE RDNUMS(A,IPT1,NBOUND,NUM,IER)
C
C *** RDNUMS corrected by JCM 23 Apr 92 ***
C
CX
CC 13C
CH Reads all the numbers on a line in free format.
CA On entry IPT1 points to the first character in the string to be considered
CA On exit NUM is the number of numbers read
CA         A(1:NBOUND) is an array into which NUM numbers have been read.
CA         IER = 1 if any non-reals read, except "STEP", (and stops reading)
CA         IER = 2 if more than NBOUND numbers were read
CA         IER = 3 if a zero STEP length is requested
CA         IER = 4 if a negative number of STEPS is requested
C
CP Before entry the character string (maximum 80 characters) from which
CP the numbers are to be read must be in the character array in /SCRACH/.
C
CD The character string may contain just a simple string of numbers or
CD may have anywhere the word STEP followed by 3 numbers.  This is treated
CD like a FORTRAN "DO" loop:   the first number is an initial value
CD                             the second number is a final value
CD                             the third number is a step length
CD All the values implied by the "STEP" function are put into array A
CD The "STEP" length may be negative so long as the final value is less than
CD the initial one.
C
CD Stops when it has only blank card left, so it reads any non-blank
CD numbers no matter where they are on the card.  It cannot be used for
CD the (little used) facility which allows fixed format in which blanks
CD mean zeros.
C
CN Beware rounding error in the use of "STEP".
C
C STOPS WHEN IT HAS ONLY BLANK CARD LEFT, SO IT READS ANY NON-BLANK NUMBERS NO
C MATTER WHERE THEY ARE ON THE CARD, & IS NO USE FOR "C" CARDS.
C
C
      CHARACTER *4 IWORD
      LOGICAL TESTOV
      DIMENSION A(NBOUND)
/IOUNIT/
C
      IPT=IPT1
      IER=0
      NUM=0
   1  CALL RDREAL(X,IPT,IPT,80,IE)
      IF ((IE .EQ. 100) .OR. IPT .GT . 80) GO TO 100
      IF (IE .EQ. 0) GO TO 2
C
C IF HERE, IT IS EITHER "STEP" OR AN ERROR:
      IF (IE .NE. 19) GO TO 4
      IP=IPT
      CALL RDWORD(IWORD,IWDLEN,IP,IPT,IP+3,0,IE)
      IF (IWORD .NE. 'STEP') GO TO 4
      CALL RDREAL(X,IPT,IPT,80,IE)
      IF (IE .NE. 0) GO TO 4
      CALL RDREAL(Y,IPT,IPT,80,IE)
      IF (IE .NE. 0) GO TO 4
      CALL RDREAL(Z,IPT,IPT,80,IE)
      IF (IE .NE. 0) GO TO 4
C
      IF (Z .GT. 0.) GO TO 7
      Z=-Z
      X1=X
      X=Y
      Y=X1
C
   7  IF (.NOT. TESTOV(Y,Z)) GO TO 6
      WRITE (LPT,3002) X,Y,Z
      WRITE (ITO,3002) X,Y,Z
3002  FORMAT (' ERROR ** zero step length from',3F10.4)
      IER=3
      GO TO 100
C
   6  NPT=JFIX((Y-X+10.E-5)/Z)+1
      IF (NPT .GE. 1) GO TO 8
      WRITE (LPT,3003) X,Y,Z
      WRITE (ITO,3003) X,Y,Z
3003  FORMAT (' ERROR ** step',3F10.4,' gives -ve number of points')
      IER=4
      GO TO 100
C
   8  N1=NUM+NPT
      IF (N1 .GT. NBOUND) GO TO 5
      DO 9 I=1,NPT
   9  A(NUM+I)=X+FLOAT(I-1)*Z
      NUM=N1
      GO TO 1
C
C CANNOT MAKE SENSE OF CARD:
   4  IER=1
      CALL ERRIN2(IPT,2,'cannot interpret card at point',
     &  'expecting real number or "STEP"')
      GO TO 100
C
   2  NUM=NUM+1
      IF (NUM .LE. NBOUND) GO TO 3
   5  CALL ERRIN2(NBOUND,2,'more than','numbers read by RDNUMS')
      IER=2
      GO TO 100
C
   3  A(NUM)=X
      GO TO 1
C
 100  RETURN
      END
C
C
C
C
C LEVEL 2      SUBROUTINE RDREAL(X,IPT1,IPT2,IPTEND,IER)
      SUBROUTINE RDREAL(X,IPT1,IPT2,IPTEND,IER)
C
C *** RDREAL updated by JPW to read E format 3-May 2001
C
CX
CC 13C
CH Reads a real number in free format from a character string.
CA On entry IPT1 points to the first character in the string to consider
CA          IPTEND points to the last to be considered
CA On exit  X is the real number read,
CA          IPT2 points to the first character after the terminating character
CA               unless there was an erroneous character, in which case
CA               IPT2 points to it.
CA          IER =   0 if no errors were found
CA              = 100 if X=0 was derived from all spaces (so note IER
CA                    non-zero is not always indicative of a fatal error)
CA              = number in range 1-52 if a letter was found (the value of
CA                IER indicates which letter)
CA              = small -ve number (being an address in table ISMBOL in
CA                COMMON /CHARS/) if a symbol was found out of context.
CA              =-100 if the character found did not occur in any table
CA              =-101 if number of form N/M but M=0
CA              =-102 if more than 8 digits after decimal point
CP Before entry the character string (maximum 80 characters) from which
CP the number is to be read must be in the character array ICARD in /SCRACH/.
CD The string is expected to contain only digits, a possible sign,
CD a possible decimal point and a space or a comma to terminate.(The
CD number is also terminated after the character pointed to by IPTEND.)
CD A comma by itself will be read as 0. (So, e.g., on C cards, tetragonal
CD may come as 4.3,,4.5)
CD The routine will also read numbers in the form M/N (e.g. "2/3"),
CD and integers without the decimal point.
CD It will now also read E format (number with exponent) eg 2.001E-5
C
      CHARACTER *1 IC
      DOUBLE PRECISION TENTBL,XX,YY
      DIMENSION TENTBL(8)
/SCRACH/
      DATA TENTBL/0.1D0,0.01D0,0.001D0,0.0001D0,0.00001D0,
     & 0.000001D0,0.0000001D0,0.00000001D0/
C
      IPT=IPT1
      IER=0
      XX=0.
      YY=0.
      IT=0
      ISIG=0
      SIG=1.
C ISIG SAYS WHETHER ANYTHING SIGNIFICANT YET READ, SIG HOLDS SIGN
      IPSH=0
C IPSH SAYS WHETHER POINT OR SLASH READ
   1  IF (IPT .GT. IPTEND) GO TO 5
      IC=ICARD(IPT:IPT)
C IGNORE INITIAL SPACES;  TERMINATE ON FINAL SPACE:
      IF ((IC .EQ. ' ') .AND. (ISIG .EQ. 0)) GO TO 3
      IF ((IC .EQ. ' ') .AND. (ISIG .NE. 0)) GO TO 15
C TEST FOR DIGIT FIRST, AS MOST LIKELY CHARACTER TO OCCUR:
      N=NDIGIT(IC)
      IF (N .LT. 0) GO TO 2
C
C DIGIT:
      XX=10.*XX+FLOAT(N)
      GO TO 17
C
C NEITHER DIGIT NOR SPACE:
   2  N=NSYMBL(IC)
C JUMP IF SYMBOL (NOT LETTER):
      IF (N .GT. 0) GO TO 6
C IF HERE, ERROR, PROBABLY LETTER:
      L=LETTER(IC)
C If we find an 'E' we want to read the exponent
      IF(L.EQ.5) THEN
       IPT=IPT+1
       IF (IPSH .EQ. 1) XX=XX+YY
       IF (IPSH .EQ. -1) XX=XX/(YY*10.**IT)
C Have saved the part before the E, now read what comes after (must be int)
       CALL RDINTG(N,IPT,IPT,IPTEND,IER)
       IF(IER.EQ.0)XX=XX*10.**N
       GOTO 101
      ENDIF
      IF (L .GT. 0) IER=L
      IF (L .EQ. 0) IER=-100
      GO TO 5
C
C SYMBOL: + AND - EXPECTED AT START;  COMMA COULD TERMINATE
C COULD ALSO BE DECIMAL POINT OR SLASH:
   6  IF (N .EQ. 2) GO TO 15
      IF ((N .EQ.14) .AND. (ISIG .EQ.0)) GO TO 8
      IF ((N .EQ. 15) .AND. (ISIG .EQ.0)) GO TO 17
      IF ((N .EQ. 1) .AND. (IPSH .EQ. 0)) GO TO 7
      IF ((N .EQ. 10) .AND. (IPSH .EQ. 0)) GO TO 9
      IER=-N
      GO TO 5
C
C DECIMAL POINT:
   7  IPSH=1
C NOW READ FRACTION:
      GO TO 10
C
C SLASH:
   9  IPSH=-1
C NOW READ DENOMINATOR:
      GO TO 10
C
C MINUS:
   8  SIG=-1.
C
C SET "SOMETHING OTHER THAN SPACE READ"
  17  ISIG=1
C
C NEXT CHARACTER:
   3  IPT=IPT+1
      GO TO 1
C
C READ EITHER FRACTIONAL PART OR DENOMINATOR:
  10  ISIG=1
  11  IPT=IPT+1
      IF (IPT .GT. IPTEND) GO TO 5
      IC=ICARD(IPT:IPT)
C FIRST LOOK FOR DIGITS:
      N=NDIGIT(IC)
      IF (N .LT. 0) GO TO 12
C DIGIT:
      IT=IT+1
      IF (IT .LE. 8) GO TO 13
      IER=-102
      GO TO 5
  13  YY=FLOAT(N)*TENTBL(IT) + YY
      GO TO 11
C SPACE TERMINATES:
  12  IF (IC .EQ. ' ') GO TO 15
C OTHERWISE, COMMA TERMINATES AND EVERYTHING ELSE ERROR:
      NS=NSYMBL(IC)
      IF (NS .EQ. 2) GO TO 15
      L=LETTER(IC)
C If we find an 'E' we want to read the exponent
      IF(L.EQ.5) THEN
       IPT=IPT+1
       IF (IPSH .EQ. 1) XX=XX+YY
       IF (IPSH .EQ. -1) XX=XX/(YY*10.**IT)
C Have saved the part before the E, now read what comes after (must be int)
       CALL RDINTG(N,IPT,IPT,IPTEND,IER)
       IF(IER.EQ.0)XX=XX*10.**N
       GOTO 101
      ENDIF
      IF (NS .GT. 0) IER=-NS
      IF (L .GT. 0) IER=L
      IF (IER .EQ. 0) IER=-100
      GO TO 5
C
C END - XX HAS LEFT HAND PART,  POSSIBLY YY HAS RIGHT HAND PART:
  15  IPT=IPT+1
   5  IF (IPSH .EQ. 1) XX=XX+YY
      IF (IPSH .NE. -1) GO TO 101
C DEAL WITH N/M:
      IF (YY .GT. 0.) GO TO 16
      IF (IER .EQ. 0) IER=-101
      GO TO 101
  16  XX=XX/(YY*10.**IT)
 101  X = SNGL(XX)*SIG
      IPT2=IPT
      IF ((ISIG.EQ.0) .AND. (IER .EQ. 0) .AND. (IC .NE. ',')) IER=100
      RETURN
      END
C
C
C
C
C LEVEL 8      SUBROUTINE RDRELA
      SUBROUTINE RDRELA
C
C *** RDRELA updated JCM 13 Jan 88 ***
C
CX
CC 6A
CH Reads and interprets all user-supplied L RELA cards for constraints.
C
CD Deals with L RELA cards of type:
CD   L RELA 1  : followed by <a1> <p1>  <a2> <p2> where a1, a2 are
CD               constants and p1, p2 are parameter specifications.
CD               This is to be interpreted as:
CD               a1 x shift in p1 = a2 x shift in p2
CD
CD   L RELA 2  : followed by a string of <a1> <p1>  <a2> <p2>  ,a3> <p3> . .
CD               for as many as are needed.  This is to be interpreted as:
CD    a1 x shift in p1 + a2 x shift in p2 + a3 x shift in p3 + etc = 0.
CD
CD For each card the relation is read and stored.  It is not actually
CD absorbed until routine VARMAK is obeyed, when it may be modified in
CD the light of other FIX, VARY or RELA instructions.
C
CN Note that types 1 and 2 are not identical for a relation involving just
CN two parameters.
C
      DIMENSION AM(10),KK1(10)
C
C SET NO TYPE 2 CONSTRAINTS:
C
C READ ALL 'L RELA' CARDS:
      IN=0
   1  CALL FINDCD('L','RELA',4,IN,L)
      IF (L .LE. 0) GO TO 100
C INTERPRET NEXT CARD:
      IN=L
      CALL RDINTG(IRTYP,7,IPT,80,IER)
      IF (IRTYP .LE. 0 .OR. IRTYP .GE. 3) THEN
      CALL ERRIN2(IRTYP,2,'Relation type','not implemented')
      GO TO 1
      ENDIF
C
      GO TO (11,12) , IRTYP
C
C TYPE 1 CONSTRAINT - A1 TIMES P1 = A2 TIMES P2
  11  CALL RDREAL(AM(1),IPT,IPT,80,IER)
      CALL PARRD(IPT,IPT,KK1(1),IFAM1,IGEN1,ISPC1)
C PARAMETER SPEC INTO KK1(1) - MUST BE A GENUS NAME+SPECIES NAME SO KK1(1) +VE:
      IF (KK1(1) .LE. 0) GO TO 99
C
      CALL RDREAL(AM(2),IPT,IPT,80,IER)
      CALL PARRD(IPT,IPT,KK1(2),IFAM2,IGEN2,ISPC2)
      IF (KK1(2) .LE. 0) GO TO 99
      AM(2)=-AM(2)
      CALL ADDCON(2,KK1,AM,1)
      GO TO 1
C
C TYPE 2 - A LINEAR COMBINATION OF PARAMETERS, WITH CONSTANT COEFFICIENTS,
C          MUST BE CONSTANT.  ALL PARAMETERS ON ONE CARD - CONSTANTS FIRST
C READ AS MANY PAIRS OF CONSTANT, PARAMETER SPEC AS GIVEN:
  12  IPARS=0
   5  IPARS=IPARS+1
      CALL RDREAL(AM(IPARS),IPT,IPT,80,IER)
      IF (IER .EQ. 100) GO TO 21
      CALL PARRD(IPT,IPT,KK1(IPARS),IFAM,IGEN,ISPC)
      IF (KK1(IPARS) .LE. 0) GO TO 99
      GO TO 5
C
C NOW ABSORB TYPE 2 CONSTRAINT:
  21  CALL ADDCON(IPARS-1,KK1,AM,4)
      GO TO 1
C
C ERRORS:
  99  CALL ERRIN2(IPT,2,'cannot interpret L RELA card at point',' ')
      GO TO 1
C
 100  RETURN
      END
C
C
C
C
C LEVEL 3      SUBROUTINE RDWORD(WORD,IWDLEN,IPT1,IPT2,IPTEND,IANY,IER)
      SUBROUTINE RDWORD(WORD,IWDLEN,IPT1,IPT2,IPTEND,IANY,IER)
C
C *** RDWORD updated by JCM 28 Apr 90 ***
C
CX
CC 13C
CH Reads the next word from a character string.
C
CA WORD    is *(*), and set on exit to contain the next readable word
CA IWDLEN  integer, is set to the total number of characters read
CA On entry IPT1 points to the first character position to consider in ICARD
CA          IPTEND points to the last character position to consider.
CA          IANY indicates whether or not the "word" may start with a
CA               a non-letter.  If IANY is negative, any character may
CA               start the word, but if IANY = 0 it must start with a letter.
CA               If IANY is positive, a special entry used by multi-source
CA               multiphase Profile Refinement is invoked.  If *Sn or *Pn
CA               (n an integer) is read where a word is expected, n is
CA               transferred to KSOURC or KPHASE as appropriate, and the
CA               NEXT word is read as normal.
CA
CA On exit WORD contains the next readable word in ICARD terminated by
CA              a space.
CA         IWDLEN is set to the total number of characters read
CA         IPT2 points to the character position in ICARD after
CA              the one which terminated the word.
CA          IER is an error indicator:
CA IER =   0  no errors found
CA IER =   100 word contained all spaces (ie nothing left in field to consider)
CA IER =   number in range 1-10: initial character of word is a digit (IANY>=0)
CA IER =   small negative number: initial symbol out of context (the
CA         number is an address in the table ISMBOL in /CHARS/)
CA IER =  -100: initial symbol out of context, not found in any table
C
CP Expects ICARD in /SCRACH/ to contain enough characters.
CD Ignores spaces till a non-space;  then absorbs word until it finds
CD      either a space, or
CD      the end of the permitted field as given in IPTEND, or
CD      WORD is full (in which case it reads characters and counts them
CD      in IWDLEN, but does not store them
C
      CHARACTER *(*) WORD
      CHARACTER *1 IC
      LOGICAL SAID
/PHASE/
/SCRACH/
/SOURCE/
C
      MAX=LEN(WORD)
      IPT=IPT1
   4  WORD=' '
      IER=0
      IWDLEN=0
   1  IF (IPT .GT. IPTEND) GO TO 101
      IC=ICARD(IPT:IPT)
C IGNORE INITIAL SPACES;  TERMINATE ON FINAL SPACE:
      IF ((IC .EQ. ' ') .AND. (IWDLEN .EQ. 0)) GO TO 3
      IF ((IC .EQ. ' ') .AND. (IWDLEN .NE. 0)) GO TO 102
C TEST FOR LETTER FIRST, AS MOST LIKELY CHARACTER TO OCCUR:
      N1=LETTER(IC)
      IF (N1 .LE. 0) GO TO 2
C
C LETTER, OR SUBSEQUENT NON-SPACE:
   5  IWDLEN=IWDLEN+1
      IF (IWDLEN .LE. MAX) WORD(IWDLEN:IWDLEN)=IC
      GO TO 3
C
C NEITHER LETTER NOR SPACE:
C IF INITIAL LETTER READ, OR IF IER IS -VE ON ENTRY,  ANY SYMBOL IS  ACCEPTABLE:
   2  IF (IWDLEN .GT. 0 .OR. IANY .LT. 0) GO TO 5
      N1=NSYMBL(IC)
C JUMP IF SYMBOL (NOT LETTER):
      IF (N1 .GT. 0) GO TO 6
      N1=NDIGIT(IC)
      IF (N1 .GT. 0) IER=N1
C BY NOW IT IS AN UNRECOGNISABLE SYMBOL:
      IF (N1 .EQ. 0) IER=-100
      GO TO 101
C
C SYMBOL AT START OF WORD:
C
   6  IF (IANY .GT. 0) THEN
        IF (N1 .EQ. 17) THEN
          IF (SAID(ICARD(IPT+1:IPT+1),'P')) THEN
            CALL RDINTG(KPHASE,IPT+2,IPT,80,IER)
            GO TO 4
          ELSE IF (SAID(ICARD(IPT+1:IPT+1),'S')) THEN
            CALL RDINTG(KSOURC,IPT+2,IPT,80,IER)
            GO TO 4
          ENDIF
        ENDIF
      ENDIF
      IER=-N1
      GO TO 101
C
C NEXT CHARACTER:
   3  IPT=IPT+1
      GO TO 1
C
 102  IPT=IPT+1
 101  IF ((IWDLEN .EQ. 0) .AND. (IER .EQ. 0)) IER=100
      IPT2=IPT
      RETURN
      END
C
C
C
C
C LEVEL 4      SUBROUTINE RDWRDS(WD,IPT1,NBOUND,NUM,IER)
      SUBROUTINE RDWRDS(WD,IPT1,NBOUND,NUM,IER)
C
C *** RDWRDS by JCM 1 Oct 86 ***
C
CX
CC 13C
CH Reads all the words on a line from column 3 onwards.
C
CA On entry IPT1 points to the first character in ICARD to read
CA          NBOUND is the dimension of the array WD
CA On exit WD is an A4 array which holds all the words read.
CA         NUM is the number of words read (it stops at a non-word)
CA IER = 1 on exit if a non-word read (starting with a non-letter)
CA IER = 2 on exit if the array is overfilled
C
CP The card must have already been read into ICARD in /SCRACH/, usually
CP by CARDIN
C
      CHARACTER *4 WD(NBOUND)
C
      IPT=IPT1
      IER=0
      NUM=0
   1  CALL RDWORD(WD(NUM+1),LEN,IPT,IPT,80,-1,IE)
      IF (IE .EQ. 100 .OR. IPT .GE. 80) GO TO 100
      IF (IE .EQ. 0) GO TO 2
      IER=1
      GO TO 100
C
   2  NUM=NUM+1
      IF (NUM .LE. NBOUND) GO TO 1
      CALL ERRIN2(NBOUND,2,'array full - ','items, in RDWRDS')
      IER=2
 100  RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE READMP
      SUBROUTINE READMP
C
C *** READMP updated by JCM 22 Aug 86 ***
C
CX
CC 5B
CH Reads into the array DENS a map previously written to file, unformatted.
C
CP Assumes simply that NX by NY numbers have been written to unit IDUMPR
C
/MAPDA/
/MAPRD/
C
      I=0
      DO 1 IY=1,NY
      READ (IDUMPR) (DENS(I+J),J=1,NX)
   1  I=I+NX
      RETURN
      END
C
C
C
C
C LEVEL 4      SUBROUTINE READRT(IAT,IEND,NAME)
      SUBROUTINE READRT(IAT,IEND,NAME)
C
C *** READRT updated by PJB C118 Sept 2002 ***
C
CX
CC 17A
CH Reads whatever follows on a "W atom-name ROTN" card.
C
CA On entry IAT indicates which is the atom (or the total number,  if IEND
CA              is -ve.
CA          IEND points in ICARD to the next character to read
CA               unless IEND is -ve, when it requests initialisation
CA          IEND=-1 initialises the first IAT rotations
CA          IEND=-2 initialises the IATth rotation to be a unit matrix
CA          IEND=0 prints what has been read.
CA          NAME is the name of the atom to which this rotation applies
C
CO If IAT=0 writes its finding on unit LPT.
CN Now (C118) assumes a unit rotation matrix if none is given and one is
CN required
C
      CHARACTER*4 WORD,NAME,JAX(3)*1,RCAX(3)*2
/ATNAM/
/CELPAR/
/CARDRC/
/IOUNIT/
/QROT/
/SCRACH/
%      COMMON/SCRAT/MODE(%MPAT%),IROT(%MPAT%),TEMP(3,3),MFUN(10,%MPAT%),LENG(3)
      DATA JAX,RCAX/'X','Y','Z','a*','b*','c*'/
C
      IF (IEND) 30,20,2
C
C   INITIALISE COUNT OVER AXES
   30 IF (IEND .EQ. -1) THEN
        CALL ERRCHK(1,IAT,10,0,' rotations in READRT')
        CALL JGMZER(IROT,1,IAT)
      ELSE
        CALL GMUNI(ROT(1,1,IAT),3,3)
        IROT(IAT)=7
      ENDIF
      GO TO 100
C
   2  IPT=IEND
      CALL RDWORD(WORD,LWORD,IPT,IPT1,80,0,IER)
      IF (IER.NE.0) GO TO 50
C
C  WHICH AXIS IS IT?
      IF (LWORD.GT.1) GO TO 51
      I=NCFIND(WORD(1:1),JAX,3)
      DO 6 J=1,3
      IPT=IPT1
      CALL RDREAL(ROT(J,I,IAT),IPT,IPT1,80,IER)
      IF (IER.NE.0) GO TO 50
    6 CONTINUE
      IROT(IAT)=IROT(IAT)+2**(I-1)
      GO TO 100
C
   20 IF (IROT(IAT).EQ.0) GO TO 53
      DO 21 J=1,3
      IF (MOD(IROT(IAT),2).NE.1) GO TO 52
      CALL GMEQ(ROT(1,J,IAT),TEMP(1,J),1,3)
   21 IROT(IAT)=IROT(IAT)/2
   22 CALL GMPRD(ORTH(1,1,2),TEMP,ROT(1,1,IAT),3,3,3)
C  *** PJB CHANGED TO TRANSPOSE 4 Aug 88
      CALL TRANSQ(ROT(1,1,IAT),3)
      WRITE (LPT,2000) (JAX(J),(TEMP(K,J),K=1,3),J=1,3)
2000  FORMAT (' Direction cosines of quantum axes relative to ',
     & 'orthogonal crystallographic axes are:'/3(3X,A1,1X,3F10.5/))
      WRITE (LPT,2001) (JAX(J),J=1,3),(RCAX(J),(ROT(K,J,IAT),K=1,3)
     & ,J=1,3)
2001  FORMAT (' Components of reciprocal lattice vectors on ',
     & 'quantum axes are:'/5X,3(8X,A1,1X)/3(2X,A2,1X,3F10.5/))
      GO TO 100
C
C  REPORT ERRORS
   50 CALL ERRMES(1,1,'Reading rotation matrix')
      GO TO 100
C
   51 CALL ERRMES(1,1,'Axial direction'//WORD//' for '//
     &NAME//' atom not recognised')
      GO TO 100
C
   52 CALL ERRMES(1,1,'Direction of quantum axis '//JAX(J)//
     &' for atom '//NAME//' not given')
      GO TO 100
   53 CALL  ERRMES(4,-1,'Direction of quantum axes for atom '
     &//NAME//' not given.  Assuming unit matrix.')
      CALL GMUNI(TEMP,3,3)
      GO TO 22
C
  100 RETURN
      END
C
C
C
C
C LEVEL 2      SUBROUTINE REAORB(CORB,ORB,KMAX)
      SUBROUTINE REAORB(CORB,ORB,KMAX)
C
C *** REAORB updated by PJB Apr 2003 ***
C
CX
CC 18A
CH To change the orbital basis from Ylm and Yl-m to (Ylm +- Yl-m).
CN The basis functions Ylm+ and Ylm- are defined by 1/sqrt(2){Ylm +/- Y*lm]
CN  Thus Ylm+ = 1/sqrt(2)[Ylm + (-1)**m(Yl-m)]
CN The matrices are stored with the lowest index corresponding to positive
CN maximum m
C
      COMPLEX CORB(KMAX,KMAX)
      DIMENSION ORB(KMAX,KMAX)
/IOUNIT/
      COMPLEX FAC1,FAC2,D(169),D2(169),D3(169)
C
      K=KMAX/2
      RTHF=SQRT(0.5)
      FAC2=CMPLX(RTHF,0.)
      FAC1=FAC2*(-1)**K
      CALL CGMZER(D,KMAX,KMAX)
C
      I=K+1
      DO 1 M=-K,K
      IM=IABS(M)
      IF (M.EQ.0) THEN
        FAC1=CMPLX(0.,RTHF)
        FAC2=FAC1
        D(I)=CMPLX(1.,0.)
      ELSE
      D(I-IM)=FAC2
      D(I+IM)=FAC1
      FAC1=-FAC1
      ENDIF
      I=I+KMAX
    1 CONTINUE
      IF (IOUT.EQ.220) THEN
        L=0
        CALL MESS(LPT,1,'Transformation Matrix:')
        DO 25 I=1,KMAX
        WRITE (LPT,2001) (D(J),J=L+1,L+KMAX)
2001    FORMAT (12(1X,7(2F8.4,2X)/))
        L=L+KMAX
   25   CONTINUE
      ENDIF
      CALL CGMPRD(CORB,D,D2,KMAX,KMAX,KMAX)
      CALL TRANSC(D2,KMAX)
      CALL CGMPRD(D2,D,D3,KMAX,KMAX,KMAX)
      L=0
      II=1
      DO 5 I=1,KMAX
      DO 5 J=1,KMAX
      ORB(I,J)=REAL(D3(II))
      IF (ABS(AIMAG(D3(II))).GT..0001) THEN
        WRITE (LPT,3000) I,J,AIMAG(D3(II))
        WRITE (ITO,3000) I,J,AIMAG(D3(II))
3000    FORMAT (/' ERROR ** in REAORB - imaginary part of element',
     &  2I3,' is non-zero; value is ',F8.4)
      ENDIF
      II=II+1
    5 CONTINUE
      RETURN
      END
C
C
C
C
C LEVEL 2      LOGICAL FUNCTION REAPOL(H,POL,DPOL,MTYP,TEMP,TITLE,LUNI)
      LOGICAL FUNCTION REAPOL(H,POL,DPOL,MTYP,TEMP,TITLE,LUNI)
C
C *** REAPOL put into LIB by PJB  18-Mar-1997 ***
CC 2C
CH Reads polarisations from the .pol file written by CRYPAD
C
CD Returns TRUE if data were read, FALSE if end of file encountered.
CA On Entry LUNI is the logical unit to read from
CA On exit the components of input and output polarisation vectors are in POL
CA         the esd's of the measured vector are in DPOL
CA         MTYP = 1 fpr API: analyse input polarisation
CA         MTYP = 2 fpr APO: analyse ioutput polarisation
CA         TEMP is an ASCI string containing the measurement temperature
CA         TITLE is an descriptive ASCI string
C
      CHARACTER*(*) TITLE,TEMP
      DIMENSION POL(6),DPOL(3),H(3)
/SCRACH/
C
      REAPOL=.FALSE.
      READ (LUNI,1000,END=101) ICARD
 1000 FORMAT (A80)
      L=LENGT(ICARD)
      READ (ICARD,10) H,MTYP
   10 FORMAT (3F8.3,I5)
      TEMP=ICARD(30:38)
      TITLE=ICARD(40:L)
      READ (LUNI,11,END=101) POL,DPOL
   11 FORMAT (9F8.4)
      GO TO 100
C
  101 REAPOL=.TRUE.
  100 RETURN
      END
C
C
C
C
C LEVEL 3      SUBROUTINE RECELL(N,M)
      SUBROUTINE RECELL(N,M)
C
C *** RECELL updated by PJB  26-Aug-1998 ***
C
CX
CC 1B
CH Makes real or reciprocal space cell parameters from the others.
CA On entry:
CA   N=1 means make real space parameters; N=2 reciprocal
CA   M=1 means start from the 6 quadratic products in CPARS, A,B,C,D,E,F
CA       if real or A*,B*,C*,D*,E*,F* if reciprocal.
CA       ( A=a squared, B=b squared, D=b c cos alpha, etc.,
CA       and A*=a* squared, B*=b* squared, D*=b* c* cos alpha*, etc.,
CA       where a,b,c, etc are the cell parameters in real space,
CA       a*,b*,c* etc are in reciprocal.
CA
CA   M=2 means start from cell parameters.
C
CD The remaining annotation assumes, for the sake of clarity,
CD that N=1 and M=1.
CD
CD Accepts in /CELPAR/ the 6 quadratic products A* B* C* D* E* F*;
CD Makes first the usual cell parameters a* b* c* alpa* beta* gamma*,
CD then cos alpha*, cos beta*, cos gamma*.
CD (join here if on entry M=2)
CD Makes sin alpha*, sin beta*, sin gamma*:
CD Then makes the 9 corresponding quantities in real space, a,b,c,
CD cos alpha, cos beta, cos gamma, sin alpha, sin beta, sin gamma.
CD
CD Makes the volumes of both real & reciprocal cells in V(1) and V(2).
CD Now for entry M=1, we already have one set of quadratic products;
CD make the other set, and for entry M=2, make both sets.
CD
CD Finally forms the orthogonal matrices used in transformation of axes,
CD by a call of ORTHG.
CD
CD Called at end of RECIP (N=2,M=2), and at the end of a LSQ cycle which
CD refines cell parameters (N=1,M=1)
C
CO Writes its findings on unit LPT.
C
      DOUBLE PRECISION C
      DIMENSION ANGLE(3,2)
      CHARACTER *8 ESDBUF(6)
/CELFIX/
/CELPAR/
/IOUNIT/
C
      NOUT=N
      MM=M
      IF ((NOUT .NE. 1) .AND. (NOUT .NE. 2)) CALL ERRMES(
     & -1,0,'RECELL entry neither 1 nor 2')
      IN=3-NOUT
      IF (MM .EQ. 2) GO TO 5
C
C IF WE HAVE A,B, OR A* B* ETC. WE MUST FIRST MAKE FROM THEM THE
C CELL SIDES AND ANGLES TO CORRESPOND WITH ENTRY M=2
      DO 6 I=1,3
      IF (CPARS(I,IN) .GT. 0.) GO TO 7
      CALL ERRIN2(I,-1,'Cell side','has negative square - set to 0')
      CELL(I,1,IN)=0.
      GO TO 6
   7  CELL(I,1,IN)=SQRT(CPARS(I,IN))
   6  CONTINUE
      J=2
      K=3
C
C FORM COSINES:
      DO 18 I=1,3
      CELL(I,2,IN)=CPARS(I+3,IN)/(CELL(J,1,IN)*CELL(K,1,IN))
      IF (ABS(CELL(I,2,IN)) .LE. 1.) GO TO 8
      CALL ERRIN2(I,-1,'Cell angle',
     & 'has cosine of modulus > 1 - set to 1')
      CELL(I,2,IN)=SIGN(1.0,CELL(I,2,IN))
   8  J=K
      K=I
  18  CONTINUE
C
C FORM SINES - JOIN HERE IF M=2 - THEN START ON OTHER SPACE:
   5  DO 2 I=1,3
      CALL SINCOS(CELL(I,2,IN),CELL(I,3,IN),'RECELL')
      ANGLE(I,IN)=DEGREE(ATAN2(CELL(I,3,IN),CELL(I,2,IN)))
   2  CONTINUE
      J=2
      K=3
      DO 3 I=1,3
      C=DBLE((CELL(J,2,IN))*CELL(K,2,IN)-CELL(I,2,IN))/(CELL(
     & J,3,IN)*CELL(K,3,IN))
      CELL(I,2,NOUT)=SNGL(C)
      CALL SINCOS(CELL(I,2,NOUT),CELL(I,3,NOUT),'RECELL')
      ANGLE(I,NOUT)=DEGREE(ATAN2(CELL(I,3,NOUT),CELL(I,2,NOUT)))
      J=K
      K=I
   3  CONTINUE
C UNIT CELL VOLUME:
      V(IN)=CELL(1,1,IN)*CELL(2,1,IN)*CELL(3,1,IN)*CELL(1,3,NOUT)*
     & CELL(2,3,IN)*CELL(3,3,IN)
      V(NOUT)=1/V(IN)
C
C CELL SIDES IN OTHER SPACE:
      DO 4 I=1,3
      CELL(I,1,NOUT)=CELL(J,1,IN)*CELL(K,1,IN)*CELL(I,3,IN)/V(IN)
      J=K
      K=I
   4  CONTINUE
C
      IF (MM .EQ. 1) GO TO 10
C IF M=1 SET UP QUADRATIC PRODUCTS IN OTHER SPACE -
C IF M=2 SET UP QUADRATIC PRODUCTS IN BOTH SPACES:
      DO 9 I=1,3
      CPARS(I,IN)=CELL(I,1,IN)*CELL(I,1,IN)
      CPARS(I+3,IN)=CELL(J,1,IN)*CELL(K,1,IN)*CELL(I,2,IN)
      J=K
      K=I
   9  CONTINUE
  10  DO 11 I=1,3
      CPARS(I,NOUT)=CELL(I,1,NOUT)*CELL(I,1,NOUT)
      CPARS(I+3,NOUT)=CELL(J,1,NOUT)*CELL(K,1,NOUT)*CELL(I,2,NOUT)
      J=K
      K=I
  11  CONTINUE
      WRITE (LPT,2001) (CELL(I,1,1),I=1,3),(ANGLE(I,1),I=1,3)
** MAKE ESDS if required
      IF (SDCELL) THEN
      CALL RECISD(1)
        DO 12 I=1,6
        J=IPTCEL(I)
        IF (CELLSD(I,I).LE.0 .OR. J.LT. I) THEN
          ESDBUF(I)=' '
        ELSE
          IF (I.LE.3) THEN
            WRITE (ESDBUF(I),2020) SQRT(CELLSD(I,I))
          ELSE
            WRITE (ESDBUF(I),2021) SQRT(CELLSD(I,I))
          ENDIF
        ENDIF
   12   CONTINUE
        WRITE (LPT,2004) (ESDBUF(I),I=1,6)
        IF (PRODSD .AND. .NOT. LSQCEL) WRITE (LPT,2006)
      ENDIF
 2020 FORMAT (F8.4)
 2021 FORMAT (F8.2)
 2004 FORMAT (' esd''s          ',3(2X,A8),3A8)
 2006 FORMAT (' esd''s obtained from those in the quadratic products')
 2007 FORMAT ('quadratic prouct esd''s obtained from those of',
     &' the cell parameters')
      WRITE (LPT,2010) V(1)
      WRITE (LPT,2003) (CELL(I,1,2),I=1,3),(ANGLE(I,2),I=1,3)
      WRITE (LPT,2011) V(2)
2001  FORMAT (/' Real cell      ',3F10.4,3F8.2)
2010  FORMAT (' Volume = ',F10.4/)
2003  FORMAT (' Reciprocal cell',3F10.4,3F8.2)
2011  FORMAT (' Volume = ',E12.4/)
      IF ((NOUT .EQ. 2) .OR. (MM .EQ. 1)) WRITE (LPT,2002)
     & (CPARS(I,1),I=1,6)
      IF (SDCELL) THEN
        DO 13 I=1,6
        J=IPTCEL(I)
        IF (CELESD(I,I,1).LE.0 .OR. J.LT.I ) THEN
          ESDBUF(I)=' '
          WRITE (ESDBUF(I),2022) SQRT(CELESD(I,I,1))
        ENDIF
   13   CONTINUE
        WRITE (LPT,2005) (ESDBUF(I),I=1,6)
        IF (.NOT. PRODSD .AND. .NOT. LSQCEL) WRITE (LPT,2007)
      ENDIF
 2022 FORMAT (F8.4)
 2005 FORMAT (' esd''s:  '/2X,6(2X,A8,2X))
2002  FORMAT (/' Real cell quadratic products:'/
     & ' A (=a  sqrd)     B            C   D (=b c cos alpha)  E ',
     & '         F '/1X,6F12.5)
      IF ((NOUT .EQ. 2) .OR. (MM .EQ. 2)) WRITE (LPT,2000) (
     & CPARS(I,2),I=1,6)
2000  FORMAT (/' Reciprocal cell quadratic products:'/
     & ' A*(=a* sqrd)     B*          C*  D*(=b*c*cos alpha*)  E*',
     & '         F*'/1X,6F12.5)
      CALL ORTHG(M)
      RETURN
      END
C
C
C
C
C LEVEL 10      SUBROUTINE RECIP
      SUBROUTINE RECIP
C
C *** RECIP updated by PJB  26-Aug-1998 ***
C
CX
CC 1A
CH Reads the lattice parameters and forms the reciprocal cell.
CD The real cell parameters are read from the "C" card in the order
CD a, b, c (in Angstroms) alpha, beta, gamma (in degrees).
CD The reciprocal cell parameters,cell volume and othogonal transformations
CD are calculated.
CD Cell edges and angles which are fixed by symmetry need not be given
CD on the "C" card.  Redundant parameters at the right hand end of a card
CD may be omitted.  Those not at the end may be omitted, but a comma
CD should be present to show that something was there.
CD     E.g for a cubic cell:       C   3.456
CD         for a tetragonal cell:  C  1.234  ,  2.345
CD         for a monoclinic cell:  C  1.234 2.345 3.456 , 88.43
CD Redundant values may of course be present in the ordinary way,
CD e.g. C 3.456 3.456 3.456  90  90  90
C
CD On exit, CELL() in COMMON /CELPAR/ contains a,b,c,cos(alpha,beta,gamma),
CD sin(same),a*,b*,c*,cos(alpha*,beta*,gamma*), sin(same)
CD RECELL has been called to set up symmetry relations and  orthogonal
CD matrices and fill in CPARS
C
CO Write to unit LPT any constraints which the symmetry places on the
CO real space cell parameters.
C
      CHARACTER *42 HEADNG
      CHARACTER *5 LABEL(6)
      DIMENSION CIN(6)
      LOGICAL HEAD
/CARDRC/
/CELFIX/
/CELPAR/
/IOUNIT/
      DATA HEADNG/'Symmetry constraints on lattice parameters'/
      DATA LABEL/'  a','  b','  c','alpha',' beta','gamma'/
C
      HEAD=.FALSE.
      SDCELL=.FALSE.
      IF (INREAD(19) .GT. 0) CALL SYMOP
C
C READ C CARDS:
      NCELL=ICDNO(3)
      IF (NCELL .EQ. 0) CALL ERRMES(3,0,
     & 'starting "C" with cell parameters')
C
      ID=IABS(INREAD(3))
      DO 4 IC=1,NCELL
      CALL INPUTC(ID,CIN)
      ID=ID+NYZ
      IF (SDREAD) THEN
        CALL RECISD(0)
      ELSE
        I=0
        DO 5 J=1,2
        DO 5 K=1,3
        I=I+1
   5    CELL(K,J,1)=CIN(I)
      ENDIF
   4  CONTINUE
      INREAD(3)=-IABS(INREAD(3))
C
C DEAL WITH a:
      IP=1
C COMPLAIN IF EITHER a FIXED OR a NOT GIVEN ON CARD
      IF (IPTCEL(1) .NE. 0) GO TO 30
  10  CALL ERRCH2(LABEL(IP),0,'in symmetry in RECIP -',
     & 'would be fixed')
C
  30  IF (CELL(1,1,1) .NE. 0.) GO TO 31
C
C ERROR IF ANY ESSENTIAL ITEM MISSING FROM C CARD:
  21  CALL ERRCH2(LABEL(IP),0,'in symmetry in RECIP - ','found zero')
C
C NOW b and c:
  31  DO 9 IP=2,3
      IF (IPTCEL(IP) .NE. 9999) GO TO 8
C JUMP IF RELATION FOUND INVOLVING EITHER b OR c
  11  IF (CELL(IP,1,1) .EQ. 0.) GO TO 21
C COMPLAIN ON b OR c NOT GIVEN ON CARD WHEN NEEDED
      GO TO 9
C CELL SIDES MAY NOT BE FIXED:
   8  IF (IPTCEL(IP) .EQ. 0) GO TO 10
C
C UNCHAIN TO FIND PREVIOUS PARAMETER USED IN RELATION
      IP1=IP
  12  IP1=IPTCEL(IP1)
      IF (IP1-IP) 13,11,12
C
C CELL SIDE RELATION MUST BE SIMPLE EQUALITY:
  13  A=SQRT((AMCELL(IP1)/AMCELL(IP)))
      IF (ABS(A-1.) .GT. 0.0001) CALL ERRMES(-1,0,
     & 'cell side relation found other than equality')
C
      IF (.NOT. HEAD) CALL MESS(LPT,1,HEADNG)
      HEAD=.TRUE.
      WRITE (LPT,2002) LABEL(IP),LABEL(IP1)
2002  FORMAT (45X,A5,' =',A5)
      CELL(IP,1,1)=CELL(IP1,1,1)
   9  CONTINUE
C
C NOW CROSS TERMS - MAY BE FREE, FIXED (90 OR 120), OR RELATED TO ANOTHER TERM.
C 120 IS DETECTED BY RELATION OF A CROSS TERM TO A CELL SIDE TERM.
      J=2
      K=3
      DO 14 IP=4,6
      IF (IPTCEL(IP) .EQ. 9999 .AND. CELL(IP-3,2,1) .EQ. 0.) GO TO 21
C TURN ANGLES INTO COSINES;  THIS WILL TURN 0 INTO 1 FOR THOSE OMITTED
      CELL(IP-3,2,1)=COS(RADIAN(CELL(IP-3,2,1)))
C JUMP IF ANGLE FREE:
      IF (IPTCEL(IP).EQ.9999) GO TO 22
C JUMP IF ANGLE RELATED :
      IF (IPTCEL(IP) .NE. 0) GO TO 16
C CROSS TERM FIXED IMPLIES ANGLE IS 90:
      CELL(IP-3,2,1)=0.
      IF (.NOT. HEAD) CALL MESS(LPT,1,HEADNG)
      HEAD=.TRUE.
      WRITE (LPT,2003) LABEL(IP)
2003  FORMAT (45X,A5,' = 90')
      GO TO 22
C CROSS TERM IS INVOLVED IN A RELATION - FIND PREVIOUS CHAIN MEMBER:
  16  IP1=IP
  17  IP1=IPTCEL(IP1)
      IF (IP1-IP) 19,22,17
C RELATED TO PREVIOUS CELL PARAMETER - JUMP IF THAT ALSO A CROSS TERM:
  19  IF (IP1 .GE. 4) GO TO 18
C IF RELATED TO A*, B* OR C*, IMPLIES ANGLE IS 120.  THIS MAY BE ALTERED
C TO USE REAL SPACE CELL PARAMETERS - AT PRESENT THE MINUS SIGN IS
C NECESSARY BECAUSE THE RELATIONS HAVE BEEN OBTAINED IN RECIPROCAL SPACE
C NOT REAL, AND THE IMPLIED ANGLE IS 60 NOT 120.
      CELL(IP-3,2,1)=-(AMCELL(IP1)/(AMCELL(IP))*CELL(IP1,1,1)*
     & CELL(IP1,1,1)/(CELL(J,1,1)*CELL(K,1,1)))
      IF (.NOT. HEAD) CALL MESS(LPT,1,HEADNG)
      HEAD = .TRUE.
      WRITE (LPT,2004) LABEL(IP)
2004  FORMAT (45X,A5,'= 120')
      GO TO 22
C
C CROSS TERM RELATED TO A PREVIOUS ONE -
C PREVIOUS MUST HAVE BEEN GIVEN ON C CARD:
  18  IF (ABS(CELL(IP1-3,2,1)-1.).LT. 0.0001) GO TO 21
      CELL(IP-3,2,1)=(AMCELL(IP1)/AMCELL(IP))*CELL(IP-3,1,1)*CELL(
     & IP1-3,2,1)/CELL(IP1-3,1,1)
      IF (.NOT. HEAD) CALL MESS(LPT,1,HEADNG)
      HEAD = .TRUE.
      WRITE (LPT,2005) LABEL(IP),LABEL(IP1)
2005  FORMAT (45X,A5,'=',A5)
C
  22  J=K
      K=IP-3
  14  CONTINUE
C
C SET UP REMAINING QUANTITIES CONNECTED WITH CELL PARAMETERS:
      CALL RECELL(2,2)
      RETURN
      END
C
C
C
C
C LEVEL 5      SUBROUTINE RECISD(MODE)
      SUBROUTINE RECISD(MODE)
C
C *** RECISD new by PJB  26-Aug-1998 ***
C
CC 1A
CH Interprets a "C SD" card and calculates ESD's in both the cell
CH parameters and their quadratic products
C
CA On entry if MODE is 0 interprets a "C SD" card already read into
CA                  ICARD
CA          if MODE is 1 expects RECIP to have finished stting up the
CA             cell parameters, which are used to calculate the  ESD's
CA            in both the cell parameters and their quadratic products.
CD The cell ESDs are placed in the diagonal elements of the matrices, CELLSD
CD for the sides and angles, and CELESD(I,I,1) for the real space quadratic
CD products
CD The locical SDCELL is set to true to indicate that cell esd's are available
CD             PRODSD is true if the ESD's were given in the quadratic procucts
CD                      ie on a "C SD PROD ....." card
CD             LSQCEL is true if the ESDs's have been inserted directly from a
CD                     least squares refinement.
C
CP SYMOP and RECIP before the call with MODE 1
C
      DIMENSION CIN(6),SMTOBG(6,6),BGTOSM(6,6)
      CHARACTER *4 WORD
      CHARACTER *5 LABEL(6),PLABEL(6)*1
/CELFIX/
/CELPAR/
      DATA LABEL/'  a','  b','  c','alpha',' beta','gamma'/
      DATA PLABEL/'A','B','C','D','E','F'/
C
      IF (MODE.NE.0) GO TO 20
C Initial entry to read C SD card
      WORD=' '
      CALL RDWORD(WORD,LEN,5,IPT,9,0,IER)
      IF (IER.NE.0) THEN
        IPT=5
      ELSE IF  (WORD.NE.'PROD') THEN
        CALL ERRMES(1,1,'WORD '//WORD//
     &  ' following "SD"  on "C" card not recognised')
        GO TO 100
      ENDIF
      CALL RDNUMS(CIN,IPT,6,NUM,IER)
      IF (IER.EQ.100) THEN
C Allow a card saying just C SD or C SD PROD for filling in
C by LSQ programs
        SDCELL=.FALSE.
        GO TO 100
      ENDIF
      IF (IER.NE.0) CALL ERRMES(1,1,'reading numbers from "C SD" card')
      CALL GMZER(CELLSD,6,6)
      CALL GMZER(CELESD,6,12)
      SDCELL=.TRUE.
      LSQCEL=.FALSE.
      PRODSD=(WORD.EQ.'PROD')
      IF (PRODSD) THEN
        DO 1 I=1,NUM
        CELESD(I,I,1)=CIN(I)
    1   CONTINUE
      ELSE
        DO 2 I=1,NUM
        CELLSD(I,I)=CIN(I)
    2   CONTINUE
      ENDIF
      GO TO 100
C
C Entry to make one kind of SD from the other including constraints
C and relationships. Deferred because we must be sure that the lattice
C constants are available
  20  CALL CELLMA(BGTOSM)
      IF (PRODSD) GO TO 30
      DO 21 I=1,6
      J=IPTCEL(I)
      IF (J.EQ.0) THEN
        CELLSD(I,I)=0
        GO TO 21
      ENDIF
      IF (J .GT.I) THEN
        IF (CELLSD(I,I).LT.10E-6) THEN
          CALL ERRMES(1,1,
     &    'ESD FOR '//LABEL(I)//' REQUIRED BUT NOT GIVEN')
          GO TO 21
        ENDIF
      ENDIF
      IF (J.GT.999) GO TO 21
      IF (J.GT.I) THEN
        IF (I.LE. 3) THEN
          IF (J.LE.3) THEN
            CELLSD(J,J)=CELL(I,1,1)*CELLSD(I,I)*AMCELL(I)/
     &      (CELL(J,1,1)*AMCELL(J))
          ELSE
C must be fixed
            CELLSD(J,J)=0
          ENDIF
        ELSE
          CELLSD(J,J)=CELLSD(I,I)*CELL(J,1,1)*CELL(I,3,1)*AMCELL(I)/
     &    (CELL(I,1,1)*CELL(J,3,1)*AMCELL(J))
        ENDIF
      ENDIF
   21 CONTINUE
C square cellsd to get variance
      DO 24 I=1,6
      CELLSD(I,I)=CELLSD(I,I)**2
   24 CONTINUE
C
C Make quad product esd's from cell ones
C CELESD(I,J,1)=BGTOSM(I,K)*CELLSD(K,L)*BGTOSMTR(L,J)
C this is not quite right because we only have the diagonal elements
C so must impose the constraints again
      DO 25 I=1,6
      J=IPTCEL(I)
      IF (J.EQ.0 .OR. J.LT.I) GO TO 25
      CELESD(I,I,1)=CELLSD(I,I)*(BGTOSM(I,I)**2)
      IF (J.GT.999) GO TO 25
      CELESD(J,J,1)=CELESD(I,I,1)*(AMCELL(I)/AMCELL(J))**2
   25 CONTINUE
      GO TO 100
C
C CHECK RELATIONS FOR ESD'S IN PRODUCTS
  30  DO 31 I=1,6
      J=IPTCEL(I)
      IF (J.EQ.0 .OR. J.LT.I) GO TO 31
      IF (J .GT.I) THEN
        IF (CELESD(I,I,1).EQ.0) THEN
          CALL ERRMES(1,1,'ESD FOR QUADRATIC PRODUCT '//PLABEL(I)//
     &    ' REQUIRED BUT NOT GIVEN')
          GO TO 31
        ENDIF
      ENDIF
      IF (J.GT.999) GO TO 31
      CELESD(J,J,1)=CELESD(I,I,1)*AMCELL(I)/AMCELL(J)
   31 CONTINUE
C SQUARE TO GET VARIANCE
      DO 34 I=1,6
      CELESD(I,I,1)=CELESD(I,I,1)**2
   34 CONTINUE
C Make cell esd's from quad prod ones
C CELLSD(I,J)=SMTOBG(I,K)*CELESD(K,L,1)*SMBGTR(L,J)C
      CALL GMINV(BGTOSM,SMTOBG,6)
      DO 35 I=1,6
      J=IPTCEL(I)
      IF (J.EQ.0 .OR. J.LT.I) GO TO 35
      CELLSD(I,I)=CELESD(I,I,1)*(SMTOBG(I,I)**2)
      IF (J.GT.999) GO TO 35
C no relationships between sides and angles
      IF (I.LE.3 .AND. J.GT.3) GO TO 35
      CELESD(J,J,1)=CELESD(I,I,1)*(AMCELL(I)/AMCELL(J))
   35 CONTINUE
  100 RETURN
      END
C
C
C
C
C LEVEL 5      SUBROUTINE REFHDR
      SUBROUTINE REFHDR
C
C *** REFHDR updated for half wavelength by PJB C4.19 March 2010 *** ***
C
CX
CC 6B
CH Reads the header lines from reflection data files
C
      DIMENSION A(10)
      CHARACTER *12 word,key(4)
/DSOURC/
/IOUNIT/
/SCRACH/
      COMMON /SFHEDC/FRMATS(6),HEDWDS(6)
      CHARACTER * 50 FRMATS,HEDWDS*4
/SFHEDP/

      IERR=0
    3 READ (LUNI,1111,END=8) MESSAG
 1111 FORMAT (A100)
C CHECK FOR comment line Starting with #
      IF (MESSAG(1:1) .NE. '#') GO TO 20
C CHECK for word introducing header info
      CALL RDWORD(word,LEN,2,IPT,20,-1,IER)
      IF (IER.EQ.100) GO TO 3
      IF (IER .NE.0) GO TO 3
C Convert to all uppercase
      CALL UPONE(WORD,1)
      LDAT=NCFIND(WORD(1:4),HEDWDS,NHEAD)
      IF (LDAT.EQ.0) GO TO 3
      L = LENGT(MESSAG)
      IF (L.GE.79) THEN
        IPT=IPT-1
        L=L-IPT
        DO 6 I=1,L
    6   ICARD(I:I)=MESSAG(IPT+I:IPT+I)
        ICARD(L+1:)=' '
      IPT=1
      ENDIF
      IPOS=0
      INUM=0
      NUMA=(LHEAD(LDAT+1)-LHEAD(LDAT))
C4.19 this could be generalised for key value data
      IF (LDAT .EQ.2) THEN
C Wavelength
        CALL GMZER(SRCPAR(LHEAD(LDAT),JSRC),NUMA,1)
   31   CALL RDREAL(SRCPAR(LHEAD(LDAT)+INUM,JSRC),IPT,IPT,IPT+12,IER)
        IF (IER.NE. 0)  GO TO 5
        IF (INUM .GT. NUMA) GO TO 30
          INUM=INUM+1
          IPOS=IPOS+1
          CALL RDWORD(KEY(INUM),IWLEN,IPT,IPT,IPT+12,0,IER)
          IF (IER.EQ. 100)  THEN
            INUM=INUM-1
            GO TO 30
          ENDIF
        IF (IER.NE.0)  GO TO 5
        GO TO 31
      ENDIF
C
      CALL RDNUMS(A,IPT,NUMA,NUM,IER)
      IF (IER.NE.0 .OR. NUM .NE. NUMA)  GO TO 5
      if (ldat.eq.1) then
C Polarisation
        IF (NUMA .EQ. 5) THEN
          CALL GMEQ(A,SRCPAR(LHEAD(LDAT)+2,JSRC),3,1)
          CALL GMEQ(A(4),SRCPAR(LHEAD(LDAT),JSRC),2,1)
        ELSE
          IPOS=-3
          CALL GMEQ(A,SRCPAR(LHEAD(LDAT)-3,JSRC),2,1)
          WRITE (ITO,3000) JSRC,LHEAD(LDAT)+IPOS,
     &   (SRCPAR(LHEAD(LDAT)+I,JSRC),I=IPOS,IPOS+NUMA-1)
 3000 format ('Writing for source',I3,' at posn',I3,' Pol ',2F8.3)
        ENDIF
      ELSE
        CALL GMEQ(A,SRCPAR(LHEAD(LDAT),JSRC),NUMA,1)
      ENDIF
      WRITE (LPT,FRMATS(LDAT)) (SRCPAR(LHEAD(LDAT)+I,JSRC),
     &I=IPOS,IPOS+NUMA-1)
      HMASK(LDAT)=.TRUE.
      GO TO 3
   30 WRITE (LPT,FRMATS(LDAT)) SRCPAR(LHEAD(LDAT),JSRC),
     &(KEY(I),SRCPAR(LHEAD(LDAT)+I,JSRC),I=1,INUM)
      HMASK(LDAT)=.TRUE.
      go to 3
    5 WRITE (ITO,1112) NUM,IER,(ICARD(I:I),I=1,LENGT(ICARD))
      WRITE (ITO,1002) (a(i),i=1,num)
 1112 FORMAT (2I5,/100A1)
 1002 FORMAT ('Nums ',10f8.4)
      CALL ERRMES(1,0,'Reading data header')
   20 IERR=0
      DO 21 I=1,NHEAD
      IF (HMASK(I)) GO TO 21
      WRITE (ITO,1113) FRMATS(I)(3:16)
      WRITE (LPT,1113) FRMATS(I)(3:16)
 1113 FORMAT('Missing values for ',A14,' in data header')
      IERR=IERR+1
   21 CONTINUE
      IF (IERR.NE.0) CALL ERRMES(1,0,'Missing data in header')
      GO TO 100
    8 CALL ERRMES(1,0,'Unexpected end of data file')
  100 RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE REINDX(DPROP)
      SUBROUTINE REINDX(DPROP)
C
C *** REINDX updated by PJB 1 Feb 1994 ***
C
CC 6B
CH To reindex a set of reflections after a least squares cycle in which
CH the propagation vector changes
C
CA On entry DPROP(3) is the change in propagation vector
C
      DIMENSION DPROP(3)
/REFLNS/
C
      DO 1 KNOW=1,MAXK
      IF (ISMAG(KNOW).EQ.0) GO TO 1
      IF (ISMAG(KNOW) .GT.0) THEN
        CALL GMADD(REFH(1,KNOW),DPROP,REFH(1,KNOW),3,1)
      ELSE
        CALL GMSUB(REFH(1,KNOW),DPROP,REFH(1,KNOW),3,1)
      ENDIF
    1 CONTINUE
      RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE REJECT(N,NEXT,LREJ,USE)
      SUBROUTINE REJECT(N,NEXT,LREJ,USE)
C
C *** REJECT corrected by PJB 22-June-95 ***
C
CX
CC 11C
CH Decides for ARRNGE-type main programs whether the record number of
CH a reflection occurs in a list of those to be rejected.
CA On entry N is normally the number of the reflection to be tested.
CA            but if negative indicates the setting up entry which
CA            opens the rejection list and reads the first entry.
CA          NEXT should initially be set to zero;  it should then be
CA               preserved between entries.
CA          LREJ is the number of the unit from which to read rejection
CA               numbers.
C
CA On exit LOGICAL USE is TRUE if reflection number N is to be used.
C
CD Reads one integer at a time from unit LREJ.  Takes a -ve integer
CD to imply "all the numbers between the previous number and this one".
C
CN N must be monotonic increasing.
C
      LOGICAL USE
/ARRDAT/
/IOUNIT/
/SCRACH/
      EQUIVALENCE (ICARD(1:1),MESSAG)
C
      IF (N.GE.0) GO TO 1
C
      MESSAG='File containing rejection list?'
      NAMFIL='.REJ'
      LREJ=NOPFIL(111)
   31 READ (LREJ,1000,END=30) ICARD
1000  FORMAT (A80)
      CALL RDINTG(NEXT,1,IPT,80,IER)
      IF (IER.NE.0) GO TO 31
      IF (NEXT .GE. 0) GO TO 100
      WRITE (LPT,2000) NEXT
2000  FORMAT (/' No rejections - ',I6,' read')
  30  NEXT=99999999
      GO TO 100
C
   1  IF (N .LT. NEXT) GO TO 101
C
      USE=.FALSE.
      IF (N .LE. -NEXT) GO TO 100
C
C NEED NEXT NUMBER FROM LIST
      LAST=NEXT
      READ (LREJ,1000,END=2) ICARD
      CALL RDINTG(NEXT,1,IPT,80,IER)
      IF (IER.NE.0) GO TO 31
C
C CHECK CORRECT SEQUENCE
      IF ((LAST .LT. 0 .AND. NEXT+LAST .GT. 0)
     &  .OR. IABS(NEXT) .GT. LAST) GO TO 100
      WRITE (LPT,3000) LAST,NEXT
3000  FORMAT (/' ERROR ** in sequence of rejection list',2I10)
      STOP
C
C AT END, SET NO MORE REJECTIONS
   2  NEXT=99999999
      GO TO 100
 101  USE = .TRUE.
 100  RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE RELATE
      SUBROUTINE RELATE
C
C *** RELATE updated by JCM 11 Aug 88 ***
C
CX
CC 6C
CH In LSQ programs, converts a vector of derivatives wrt variables into the
CH vector of derivatives wrt basic variables.
CP /DERVAR/ must hold NVARV derivatives of some calculated function wrt
CP all variables, in DERIVV.
CP The constraint information must be set up in /CONSTR/ by a call of
CP VARMAK.
C
CD Applies the (strict) constraints to the vector DERIVV to convert it into
CD a vector DERIVB in /DERBAS/, of LVARB derivatives of the same calculated
CD function wrt basic variables.
C
/CONSTR/
/DERBAS/
/DERVAR/
/POINTS/
/REFINE/
C
      IF (SIMUL) GO TO 100
      IF (LVARV .LE. 0) GO TO 100
      DO 1 I=1,LVARB
      DERIVB(I)=DERIVV(LBSVR(I))
   1  CONTINUE
C
C ADD DERIVATIVES FOR RELATED VARIABLES:
      DO 2 J=1,JCONST
      JROW=JROWPT(J)
      JNEXT=JROWPT(J+1)-1
      DO 3 K=JROW,JNEXT
      I=JCMAT(K)
      DERIVB(I)=DERIVB(I)+AMOUNT(K)*DERIVV(LRDVR(J))
   3  CONTINUE
   2  CONTINUE
 100  RETURN
      END
C
C
C
C
C LEVEL 3      SUBROUTINE RELCL6
      SUBROUTINE RELCL6
C
C *** RELCL6 new by PJB  26-Aug-1998 ***
C
CC 8a
CH Determines the constraint matrix for the cell quadratic products
CH needed for determining esd's of bond lengths and angles
C
CD  On exit  RCLMAT(I,J) in common CELFIX is a 6x6 matrix giving the
CD  projection of the parameters (I) on the basic variables (J). The
CD  rows of the matrix corresponding to redundant parameters should be
CD  zero
CP  RECIP to read the cell cards
C
      DIMENSION IP(6)
/CELFIX/
C
      CALL GMZER(RCLMAT,6,6)
      CALL JGMZER(IP,6,1)
      DO 1 I=1,6
      IF (IP(I).GT.0) GO TO 1
      J=IPTCEL(I)
      IF (J.LT.I) GO TO 1
      RCLMAT(I,I)=1
      IF (J.GT.999) GO TO 1
C mark this chain done
      IP(J)=1
      II=I
    2 RCLMAT(J,I)=AMCELL(I)/AMCELL(J)
      II=J
      J=IPTCEL(II)
      IF (J.GT.II) GO TO 2
    1 CONTINUE
C
      RETURN
      END
C
C
C
C
C LEVEL 3      SUBROUTINE RELMT3(IPFIX,APFIX,IOP,RLMAT)
      SUBROUTINE RELMT3(IPFIX,APFIX,IOP,RLMAT)
C
C *** RELMT3 new by PJB  26-Aug-1998 ***
C
CC 8B
CH Determines symmetry constraints in the calculation of the esd's
CH of bond lengths and angles
C
CA On entry IPFIX and APFIX are the relation and amount vectors for
CA               an atomic position as used in LSQ.
CA          IOP is the number of the symmetry operator which has been
CA               applied to the atomic coordinates
CA On exit  RLMAT(I,J) is a 3x3 matrix giving the projection of the coordinates
CD (I) on the parameters (J).
CP SYMOP to set up the symmetry operators
CN The rows of the matrix corresponding to redundant parameters should be zero
C
      DIMENSION IPFIX(3),APFIX(3),RLMAT(3,3),TLMAT(3,3),IP(3)
/SYMDA/
C
      CALL GMZER(TLMAT,3,3)
      CALL JGMZER(IP,3,1)
      DO 1 I=1,3
      IF (IP(I).GT.0) GO TO 1
      J=IPFIX(I)
      IF (J.LT.I) GO TO 1
      TLMAT(I,I)=1
      IF (J.GT.999) GO TO 1
C mark this chain done
      IP(J)=1
      II=I
    2 TLMAT(J,I)=APFIX(I)/APFIX(J)
      II=J
      J=IPFIX(II)
      IF (J.GT.II) GO TO 2
    1 CONTINUE
C
C Now use the symmetry operator
      CALL TRANSQ(TLMAT,3)
C IOP MAY BE NEGATIVE IF INVERSION IS INVOLVED
      CALL GMPRD(TLMAT,SYM(1,1,IABS(IOP)),RLMAT,3,3,3)
      IF (IOP.LT.0) CALL GMREV(RLMAT,RLMAT,3,3)
      CALL TRANSQ(RLMAT,3)
      RETURN
      END
C
C
C
C
C LEVEL 2      SUBROUTINE RELMTX(RELMT1,RELMT2,IATS,NA)
      SUBROUTINE RELMTX(RELMT1,RELMT2,IATS,NA)
C
C *** RELMTX new by PJB 26-Aug-1998 ***
C
CC 8B
CH Makes the matrix relating the coordinates of NA atoms, which may or
CH may not be equivalent to one-another, to a set of basic variables
C
CA On Entry RELMT1 contains the 3x3 matrices relating the coordinates
CA             of each atom amongst themselves
CA          IATS(NA) contins the numbers labelling the NA atoms
CA On exit  RELMT2 is a 3NA x 3NA matrix relating the coordinates to the
CA             variables
CN There will be zero rows in RELMT2 corresponding to the redundant
CN variables
C
      DIMENSION RELMT1(3,3,NA),IATS(NA),RELMT2(*)
C
      M=3*NA
      CALL GMZER(RELMT2,M,M)
      DO 1 I=1,NA
      KS=I-1
      DO 3 J=1,I-1
      IF (IATS(J).EQ.IATS(I)) THEN
        KS=J-1
        GO TO 4
      ENDIF
    3 CONTINUE
    4 JS=(I-1)*3
      KPTR=KS*3*M+JS+1
      DO 2 K=1,3
      CALL GMEQ(RELMT1(1,K,I),RELMT2(KPTR),3,1)
      KPTR=KPTR+M
    2 CONTINUE
    1 CONTINUE
      RETURN
      END
C
C
C
C
C LEVEL 2      SUBROUTINE RELPAR(N1,A1,N2,A2,NFIX,FIX)
      SUBROUTINE RELPAR(N1,A1,N2,A2,NFIX,FIX)
C
C *** RELPAR by JCM 13 Jul 83 ***
C
CX
CC 6A
CH In the setting up of LSQ  applications, relates two parameters by
CH a simple linear relationship.
CA On entry N1 = the serial number of parameter 1 in the array NFIX
CA          N2 = the serial number of parameter 2 in the array NFIX
CA          A1 = a constant multiplier for parameter 1
CA          A2 = a constant multiplier for parameter 2
CA          the arrays NFIX and AFIX hold a (temporary) structure for
CA          chained parameters including the two given here.  They could
CA          refer, e.g., to 3 atom position coordinates, or to 6 cell
CA          quadratic products.
C
CD RELPAR absorbs into NFIX and FIX the relation:
CD     A1 x shift in parameter N1 = A2 x shift in parameter N2
CD dealing, if necessary, with any other similar relationships already
CD present, by setting up chains.
C
      DIMENSION NFIX(1),FIX(1)
C
      I1=N1
      I2=N2
      IOLD1=NFIX(I1)
      IOLD2=NFIX(I2)
C IOLD1 AND IOLD2 ARE WHAT IS ALREADY THERE.  THESE WILL BE ONE OF
C     0=FIXED
C      9999=FREE - NO REFERENCE HAS BEEN MADE TO THIS PARAMETER SO FAR
C     N, A FORWARD REFERENCE IN A CHAIN
      IF ((IOLD1 .NE. 9999) .OR. (IOLD2 .NE. 9999)) GO TO 1
C IF HERE, BOTH WERE FREE; SET UP 2-ELEMENT CHAIN AND EXIT
      NFIX(I1)=I2
      NFIX(I2)=I1
      FIX(I1)=A1
      FIX(I2)=A2
      GO TO 100
C
C IF HERE, ONE/BOTH PARS WERE FIXED/RELATED:
   1  IF (IOLD1 .NE. 0) GO TO 2
C
C P1 WAS ALREADY FIXED;  FIX (POSSIBLE CHAIN CONTAINING) P2
      CALL FIXPAR(I2,NFIX)
      GO TO 100
C
   2  IF (IOLD2 .NE. 0) GO TO 3
C SIMILARLY IF P2 FIXED, FIX (POSSIBLE CHAIN CONTAINING) P1
      CALL FIXPAR(I1,NFIX)
      GO TO 100
C
   3  IF (IOLD1 .NE. 9999) GO TO 4
C IF HERE, P2 IS CHAINED BUT P1 FREE; ADD P1 TO CHAIN
      NFIX(I1)=NFIX(I2)
      NFIX(I2)=I1
      FIX(I1)=A1*FIX(I2)/A2
      GO TO 100
C
   4  IF (IOLD2 .NE. 9999) GO TO 5
C SIMILARLY, P1 CHAINED BUT P2 FREE
      NFIX(I2)=NFIX(I1)
      NFIX(I1)=I2
      FIX(I2)=A2*FIX(I1)/A1
      GO TO 100
C
C IF HERE, BOTH P1 AND P2 ALREADY BELONGED TO CHAINS.  DISCOVER
C WHETHER SAME OR DIFFERENT CHAINS.
   5  L=IOLD2
   6  IF (L .EQ. I1) GO TO 8
C TO 8 IF SAME CHAIN
      IF (L .EQ. I2) GO TO 7
C TO 7 IF DIFFERENT CHAINS
      L=NFIX(L)
C UNCHAIN
      GO TO 6
C
C HERE ON 2 SEPARATE CHAINS TO BE MERGED.  FIRST SCALE CHAIN 1 BY
C CHAIN 2
   7  A=A1*FIX(I2)/(A2*FIX(I1))
      CALL SCLCHN(I1,A,NFIX,FIX)
C CROSS LINKS
      IT=NFIX(I1)
      NFIX(I1)=NFIX(I2)
      NFIX(I2)=IT
      GO TO 100
C
C HERE ON SAME CHAIN - SHOULD HAVE SAME SCALE RATIOS
   8  IF (ABS(A1*FIX(I2)-A2*FIX(I1)).GE.0.0001) CALL FIXPAR(I1,NFIX)
 100  RETURN
      END
C
C
C
C
C LEVEL 9      SUBROUTINE RELPOS(IAT,NFIX3,FIX3)
      SUBROUTINE RELPOS(IAT,NFIX3,FIX3)
C
C *** RELPOS by PJB  26-Aug-1998 ***
C
CX
CC 8B
CH Gets the constraints imposed by the symmetry on a set of atomic positions.
C
CD Space group symmetry generated constraints are each between 2 parameters
CD only, and refer to x, y, z coordinates
CD
      DIMENSION RMAT(3,3),NFIX3(3),FIX3(3)
/CARDRC/
/POSNS/
/SYMDA/
C
      IR=IAT
C CLEAR OUT ALL FIX/RELA INFO FOR THIS ATOM:
      DO 2 K=1,3
      NFIX3(K)=9999
   2  CONTINUE
C
C JUMP IF NOT SPECIAL:
      IF (ISGEN(1,IR) .EQ. 1) GO TO 100
C JUMP IF NOT SPECIAL BECAUSE OF A CENTRE OF SYMMETRY AT THE ORIGIN:
      IF (ISGEN(1,IR) .GT. 0) GO TO 4
C FIX ALL POSITION:
      DO 5 I=1,3
   5  CALL FIXPAR(I,NFIX3)
C
C TAKE FIRST (OF POSSIBLE 2) SYMMETRY ELEMENTS MAKING THIS POSITION SPECIAL:
   4  DO 1 I=2,3
      K=IABS(ISGEN(I,IR))
      CALL GMEQ(SYM(1,1,K),RMAT,3,3)
      IF (ISGEN(I,IR) .LT. 0) CALL GMREV(RMAT,RMAT,3,3)
      CALL RELSM3(RMAT,NFIX3,FIX3)
C
C IS THERE A SECOND GENERATOR OF THE SUB-GROUP WHICH MAKES THIS ATOM SPECIAL?
      IF (ISGEN(3,IR) .EQ. 0) GO TO 100
   1  CONTINUE
C
 100  RETURN
      END
C
C
C
C
C LEVEL 3      SUBROUTINE RELSM3(R,NFIX,FIX)
      SUBROUTINE RELSM3(R,NFIX,FIX)
C
C *** RELSM3 updated by JCM 13 Feb 90 ***
C
CX
CC 6A
CH Forms a complete set of relations imposed by symmetry on the given
CH 3 parameters of a LSQ application.
CA On entry R holds a generalised symmetry rotation operator.
CA On exit arrays NFIX and FIX hold the relationships found.
C
CD Adds any found relationships to the general collection which will
CD eventually be used by routine VARMAK.
C
      DIMENSION R(3,3),NFIX(3),FIX(3)
/IOUNIT/
C
      DO 1 K=1,3
C COUNTS 3 EQUATIONS
      IZ=0
C COUNTS NON-ZERO COEFFICIENTS FOUND IN EACH EQUATION
      DO 2 I=1,3
C COUNTS COEFFICIENTS WITHIN AN EQUATION
      A=R(K,I)
      IF (I .EQ. K) A=A-1.
      IF (ABS(A) .LT. 1.E-5) GO TO 2
      IZ=IZ+1
      IF (IZ .NE. 1) GO TO 3
      N1=I
      A1=A
C N1 AND A1 RECORD POSITION AND VALUE OF 1ST NON-ZERO
      GO TO 2
   3  IF (IZ .EQ. 2) GO TO 4
      WRITE (LPT,3000) A1,A2,A
      WRITE (ITO,3000) A1,A2,A
3000  FORMAT (/' ERROR ** in RELSM3 finding symmetry relations ',
     & 'between parameters',/' row of matrix ',
     &'minus unit matrix is',3F8.2)
      STOP
   4  N2=I
      A2=-A
C RECORD 2ND NON-ZERO IN N2,A2
   2  CONTINUE
      IF (IZ .EQ. 1) CALL FIXPAR(N1,NFIX)
      IF (IZ .EQ. 2) CALL RELPAR(N1,A1,N2,A2,NFIX,FIX)
   1  CONTINUE
      RETURN
      END
C
C
C
C
C LEVEL 3      SUBROUTINE RELSM6(R,NFIX,FIX)
      SUBROUTINE RELSM6(R,NFIX,FIX)
C
C *** RELSM6 updated by JCM 13 Feb 90 ***
C
CX
CC 6A
CH Forms a complete set of relations imposed by symmetry on the given
CH 6 parameters of a LSQ application.
CA On entry R holds a generalised symmetry rotation operator.
CA On exit arrays NFIX and FIX hold the relationships found.
C
CD Adds any found relationships to the general collection which will
CD eventually be used by routine VARMAK.
C
      DIMENSION R(3,3),NFIX(6),FIX(6)
      DIMENSION LKUP(3,3)
/IOUNIT/
      DATA LKUP/1,6,5,6,2,4,5,4,3/
C
      DO 1 K=1,3
      DO 1 L=K,3
C COUNTS 6 EQUATIONS
      IZ=0
C COUNTS NON-ZERO COEFFICIENTS FOUND IN EACH EQUATION
      DO 2 I=1,3
      DO 2 J=I,3
C COUNTS COEFFICIENTS WITHIN AN EQUATION
      A=R(K,I)*R(L,J)
      IF (I .NE. J) A=A+R(L,I)*R(K,J)
      IF ((I .EQ. K) .AND. (J .EQ. L)) A=A-1.
      A=FLOAT(JFIX(A))
      IF (A .EQ. 0.) GO TO 2
      IZ=IZ+1
      IF (IZ .NE. 1) GO TO 3
      N1=LKUP(I,J)
      A1=A
C N1 AND A1 RECORD POSITION AND VALUE OF 1ST NON-ZERO
      GO TO 2
   3  IF (IZ .EQ. 2) GO TO 4
      WRITE (LPT,3000) A1,A2,A
      WRITE (ITO,3000) A1,A2,A
3000  FORMAT (/' ERROR ** in RELSM6 finding symmetry relations ',
     & 'between parameters',/' row of matrix ',
     & 'minus unit matrix is',3F8.2)
      STOP
   4  N2=LKUP(I,J)
      A2=-A
C RECORD 2ND NON-ZERO IN N2,A2
   2  CONTINUE
C
      IF (IZ .EQ. 1) CALL FIXPAR(N1,NFIX)
      IF (IZ .EQ. 2) CALL RELPAR(N1,A1,N2,A2,NFIX,FIX)
   1  CONTINUE
      RETURN
      END
C
C
C
C
C LEVEL 3      SUBROUTINE RELSMO(R,NR,LFIX,NFIX,NUMCON,NPARS,KKCON,AMCON)
      SUBROUTINE RELSMO(R,NR,LFIX,NFIX,NUMCON,NPARS,KKCON,AMCON)
C
C *** RELSMO Corrected by PJB C4.27 April 2013 ***
C
CX
CC 6A
CH DETERMINES THE RELATIONSHIP IMPOSED BY A SYMMETRY OPERATOR
CH ON THE COMPONENTS OF A SYMMETRIC TENSOR IN ORTHOGONAL COORDINATES
CA ON ENTRY R HOLDS THE EIGEN VECTOR equations
CA          NR is the number of rows in R
CA ON EXIT LFIX IS THE NUMBER OF FIXED COMPONENTS  AND NFIX
CA     AND FIX THE ARRAY WITH FIXING INFO
CA     NUMCON IS THE NUMBER OF MULTIPARAMETER CONSTRAINTS FOUND
CA     NPARS,KKCON AND AMCON HOLD THE CONSTRAINT PARAMETERS
C
CD ADDS ANY FOUND RELATIONSHIPS TO THE GENERAL COLLECTION WHICH WILL
CD EVENTUALLY BE USED BY ROUTINE VARMAK.
C
      DIMENSION R(6,12),NFIX(6),NPARS(12),KKCON(6,12),
     &AMCON(6,12),A(6,12),KKCOL(6),KFIX(6)
/IOUNIT/
      DATA SMALL/0.00001/
C
C DERIVE CONSTRAINTS FROM THE R MATRIX
      LFIX=0
      DO 3 K=1,6
    3 KKCOL(K)=K
      N=0
      DO 1 J=1,NR
      NCOUNT=0
      DO 2 I=1,6
      IF (ABS(R(I,J)).GT.SMALL) THEN
        NCOUNT=NCOUNT+1
        KFX=I
      ENDIF
    2 CONTINUE
      IF (NCOUNT .EQ.0) GO TO 1
      IF (NCOUNT.EQ.1) THEN
        IF (NFIND(KFX,KFIX,LFIX).EQ.0) THEN
          LFIX=LFIX+1
          KFIX(LFIX)=KFX
          NFIX(KFX)=0

        ENDIF
      ELSE
        N=N+1
        CALL GMEQ(R(1,J),R(1,N),6,1)
      ENDIF
    1 CONTINUE

      NPAR=6-LFIX
      NCON=N
C
C MAKE THE CONSTRAINT MATRIX A FIRST SUBSCRIPT = PARAMETER, SECOND=CONSTRAINT
      DO 4 I=1,NCON
      KP=0
      DO 5 K=1,6
C NOT IF ALREADY FIXED:
      IF (LFIX .EQ. 0) GO TO 6
      IF (NFIND(K,KFIX,LFIX) .GT. 0) GO TO 5
   6  KP=KP+1
      A(KP,I)=R(K,I)
      KKCOL(KP)=K
   5  CONTINUE
   4  CONTINUE
C THIS MATRIX MAY CONTAIN REDUNDANT OR INCONSISTENT CONSTRAINTS,
C PERFORM GAUSSIAN ELIMINATION ON IT:
      DO 61 NP=1,NCON
      DO 62 J=NP,NPAR
      DO 62 I=NP,NCON
      IF (ABS(A(J,I)) .GT. SMALL) GO TO 63
  62  CONTINUE
C
C NO MORE NON-ZERO COEFFICIENTS LEFT - OUT
      GO TO 64
C
C PIVOT FOUND:
C SWAP COLUMNS J AND NP (EVEN IF THEY ARE THE SAME), AND SCALE:
  63  KTEMP=KKCOL(J)
      KKCOL(J)=KKCOL(NP)
      KKCOL(NP)=KTEMP
      PIVOT=A(J,I)
      DO 65 K=1,NCON
      TEMP=A(J,K)
      A(J,K)=A(NP,K)
      A(NP,K)=TEMP
  65  CONTINUE
C
C NOW SWAP ROWS I AND NP:
      DO 66 K=1,NPAR
      TEMP=A(K,I)
      A(K,I)=A(K,NP)
      A(K,NP)=TEMP/PIVOT
  66  CONTINUE
C
C NOW SCAN ALL CONSTRAINTS, OMITTING THE SECTION BETWEEN NP AND I
C WHICH WE ALREADY KNOW TO HAVE ZEROS, AND ELIMINATE:
      DO 71 L=1,NCON
      IF (L .GE. NP .AND. L .LE. I) GO TO 71
      IF (ABS(A(NP,L)) .LT. SMALL) GO TO 71
C4.27 Corrected to count backwards here so not to overwrite A(NP,L)
      DO 72 M=NPAR,NP,-1
  72  A(M,L)=A(M,L)-A(NP,L)*A(M,NP)
  71  CONTINUE
C
  61  CONTINUE
C
  64  NCON=NP-1
      NUMCON=0
      write (lpt,1007) (kkcol(jj),jj=1,npar)
 1007 format (6(3x,i2,3x))
      do ii=1,ncon
      write (lpt,1006) (a(jj,ii),jj=1,npar)
      enddo
 1006 format (6f8.4)
C Do the fixing first
      DO 68 I=1,NCON
      DO 69 J=NCON+1,NPAR
      IF (ABS(A(J,I)) .GT. SMALL) GO TO 68
  69  CONTINUE
C NO NON-ZEROS IN THE PANEL SO THE PARAMETER IS ACTUALLY FIXED:
      if (nfix(kkcol(i)).ne.0) then
        LFIX=LFIX+1
        KFIX(LFIX)=KKCOL(I)
        NFIX(KKCOL(I))=0
      endif
   68 CONTINUE
C
      DO 78 I=1,NCON
      DO 79 J=NCON+1,NPAR
C A NON-ZERO IN THIS PANEL MEANS A CONSTRAINT, NOT A FIXING:
      IF (ABS(A(J,I)) .GT. SMALL) GO TO 60
  79  CONTINUE
C PARAMETER IS  INVOLVED IN A MULTIPARAMETER CONSTRAINT
  60  K=KKCOL(I)
      NUMCON=NUMCON+1
      NP=0
      DO 80 J=I,NPAR
      IF (ABS(A(J,I)).LT.SMALL) GO TO 80
      KP=KKCOL(J)

      IF (LFIX .NE.0) THEN
        IF (NFIX(KP).EQ.0) GO TO 80
      ENDIF
      NP=NP+1
      KKCON(NP,NUMCON)=KP
      AMCON(NP,NUMCON)=A(J,I)
  80  CONTINUE
C IF ONLY ONE PARAMETER LEFT THIS IS A FIXING
      IF (NP.LT.1) THEN
        NUMCON=NUMCON-1
        LFIX=LFIX+1
        NFIX(K)=0
      ELSE
        NPARS(NUMCON)=NP
      ENDIF

  78  CONTINUE
      RETURN
      END




C
C
C
C
C LEVEL 1      SUBROUTINE REPMOD(MODER,LDATA)
      SUBROUTINE REPMOD(MODER,LDATA)
C
C *** REPMOD rewritten for CCSL free format input C4.22 March 2011 ***
C
CX
CC 7A
CH Does reporting of data modes for SF least squares
CD Reports the type of data expected for different values of MODER (MODE)
CA On INPUT MODER is the chosen data format type.
CA On EXIT LDATA hold the blueprint which RREFSF will use to read SF data
CD IREF may be on L REFI or L SORC REFI cards
C4.27 LDATA dimension  increased to 12
C
      DIMENSION MDATA(10,12),LDATA(11)
/IOUNIT/

CD THE EXISTING OPTIONS FOR MOD(MODER,100) ARE:
CD     MODER = 1    h,k,l,OBS,(SCALE GROUP), (CODE)
CD     MODER = 2.   h,k,l,OBS,WEIGHT, (SCALE GROUP), (CODE)
CD     MODER = 3.   h,k,l,OBS,STANDARD DEVIATION OF OBS, (SCALE GROUP),(CODE)
CD     MODER = 4    h,k,l,GCAL,OBS,STANDARD DEVN.
CD     MODER = 5    h,k,l,OBS,STD DEVN,C1 C2 C3 C4, where C1-C4 are the
CD                  constants involved in extinction corrections)
CD     MODER = 6   h,k,l,ACALC,BCALC,OBS,STANDARD DEVN., (SCALE GROUP) (CODE)
CD     MODER = 7    h,k,l (FLOATING) OBS,STD DEVN,(SCALE GROUP), (CODE)
CD     MODER = 8   h,k,l(FLOATING),OBS,STD DEVN,C1 C2 C3 C4,(SCALE GROUP) where
CD                 C1-C4 are the constants involved in the extinction correction
CD     MODER = 9   h,k,l(FLOATING),OBS,STD DEVN,P1 P2,ICODE where P1 P2  define
CD                 the incident ad scattered poln directions (+\- 1,2,3=x,y,z)
CD                 ICODE=0 if hkl are the same as previous observation, else 1.
CD     MODER =10   h,k,l(FIXED),OBS,STD DEVN,P1 P2,ICODE where P1 P2  define
CD                 the incident and scattered poln directions (+\- 1,2,3=x,y,z)
CD                 ICODE=0 if hkl are the same as previous observation, else 1.
CD     MODER =11   h,k,l(ANY),2theta,INT(up) ESD(up) INT(dw) ESD(dw)  for
CD                 magnetised powder data
CD     MODER =12   h,k,l(ANY),OBS,DOBS,WLGTH,PATH,(SCALE GROUP),(CODE) for
CD                 SXD or vivaldi data
CD
CD  Both the scale group and code are optional.  if the scale group is
CD  read as zero, it will be set = 1.
CD  The code is only used for MODER 9 and 10
CD If MODER > 100 and IREF< 5 or MODER = 11 then OBS and DOBS read are Intensities (Fsqr)
CD otherwise they are structure amplitudes, flipping ratios or polarisations.
CD For MODER =11 they are raw intensities.
C
C MDATA codes the data format for different MODER`:
C MDATA(1) Number of values required
C MDATA(2) Number of values allowed
C MDATA(3) Position of GOBS
C MDATA(4) Position of esd(GOBS) 0  means not there
C MDATA(5) Position of wt(GOBS) 0  means not there
C MDATA(6) Start of CPARS
C MDATA(7) Number of CPARS
C MDATA(8) Position of ISCALE (scale zone)
C MDATA(9) Position of ICODE
C MDATA(10) Special indicator which other parameters to be read or calculated
C       =1 Magnetized powder data need to calculate 2theta and multiplicity
C       =2 SXD or Vivaldi types Wavelength and Path are in CPARS(1..2)
C       =3 SNP data, must record ICODE from value at MDATA(9)

      DATA MDATA/4, 6, 4, 0, 0, 0, 0, 5, 6, 0,
     &           5, 7, 4, 0, 5, 0, 0, 6, 7, 0,
     &           5, 7, 4, 5, 0, 0, 0, 6, 7, 0,
     &           5, 8, 5, 6, 0, 0, 0, 7, 8, 0,
     &          10,11, 4, 5, 0, 6, 4,10,11, 0,
     &           8, 9, 6, 7, 0, 0, 0, 8, 9, 0,
     &           5, 7, 4, 5, 0, 0, 0, 6, 7, 0,
     &          10,10, 4, 5, 0, 6, 4, 7, 8, 0,
     &           8, 8, 4, 5, 0, 6, 2, 0, 8, 3,
     &           8, 8, 4, 5, 0, 6, 2, 0, 8, 3,
     &           8, 8, 5, 6, 0, 4, 1, 0, 0, 1,
     &           7, 9, 4, 5 ,0 ,6, 2, 0, 0, 2/

      GO TO (31,32,33,34,35,36,33,35,37,37,38,39) , MODER
      CALL ERRIN2(MODER,0,'Reflection input format of type',
     & 'not allowed')
      GO TO 100
C
  31  CALL MESS(LPT,0,'Data input as h,k,l, Gobs, (Scale), (Code)')
      GO TO 90
C
  32  CALL MESS(LPT,0,'Data input as h,k,l Gobs, Weight, '//
     & '(Scale), (Code)')
      GO TO 90
C
  33  CALL MESS(LPT,0,'Data input as h,k,l Gobs, Sigma, '//
     & '(Scale), (Code)')
      IF (MODER .EQ. 7) CALL MESS(LPT,0,'h,k,l floating')
      GO TO 90
C
  34  CALL MESS(LPT,0,'Data input as h,k,l Gcalc, Gobs, Sigma '//
     & '- output from MEANGM')
      GO TO 90
C
  35  CALL MESS(LPT,0,'Data input as h,k,l,Gobs,Sigma,4 coeffs,(Scale)')
      IF (MODER .EQ. 8) CALL MESS(LPT,0,'h,k,l floating')
      GO TO 90
C
  36  CALL MESS(LPT,0,'Data input as h,k,l A, B, Gobs, '//
     & 'Sigma (Scale), (Code) - ignoring A,B')
      GO TO 90
C
C4.3 SNP data from .pal files
  37  CALL MESS(LPT,0,'Data input as h,k,l,Gobs,Sigma,2 PolDirs,ICODE')
      IF (MODER .EQ. 9) CALL MESS(LPT,0,'h,k,l floating')
      GO TO 90
C
C Magnetised powder data
  38  CALL MESS(LPT,0,'Data input as  h,k,l,2theta,INT(up),ESD(up),'//
     &'INT(dw),ESD(dw)')
      GO TO 90
C
C SXD type data with wavelength and path with each reflection
  39  CALL MESS(LPT,0,'Data input as  h,k,l,Gobs Esd,Lambda,Path')
      CALL MESS(LPT,0,' (Free format, hkl fixed or floating)')
      GO TO 90

  90  CALL JGMEQ(MDATA(1,MODER),LDATA,10,1)
 100  RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE REPREF(IREF)
      SUBROUTINE REPREF(IREF)
C
C *** REPREF updated for QXQ and pol pow difference by PJB C4.26/7 April 2013 ***
C
CX
CC 7A
CH Does reporting of refinement types for SF least squares
CD Reports the type of refinement implied by different values of IREF (REFI)
CD IREF may be on L REFI or L SORC REFI cards
CD IREF = 1 Refine using modulus of structure factor
CD IREF = 2 Refine using structure factor squared
CD IREF = 3 Not allowed
CD IREF = 4 Refine using signed structure factor
CD IREF = 5 Refine using polarised neutron Flipping Ratios
CD IREF = 6 Refine using  ratio of magnetic to nuclear structure factors
CD          Antiferromagnetic only (obsolete)
CD IREF = 7 Refine using polarized neutron intensity asymmetry '
CD IREF = 8 Refine using SNP data: Polarisation matrix components
CD IREF = 9 Refine using polarized neutron intensities from powder data
CD IREF = 10 Refine using polarized neutron up-down difference intensity from powder data
CD IREF = 11 Refine  polarized neutron qxq term with CPV (complex chiral) data
C
/IOUNIT/

      GO TO (21,22,6,24,25,26,27,28,29,30,31) ,IREF
C Modes 3  or > 11
   6  CALL ERRIN2(IREF,2,'Refining mode','not allowed')
      GO TO 1
  21  CALL MESS(LPT,0,'Refine using modulus of structure factor')
      GO TO 1
  22  CALL MESS(LPT,0,'Refine using structure factor squared')
      GO TO 1
  24  CALL MESS(LPT,0,'Refine using signed structure factor')
      GO TO 1
  25  CALL MESS(LPT,0,'Refine using polarised neutron Flipping Ratios')
      GO TO 1
  26  CALL MESS(LPT,0,'Refine using  ratio of magnetic to nuclear '//
     &'structure factors')
      GO TO 1
  27  CALL MESS(LPT,0,'Refine using polarized neutron intensity '//
     &'asymmetry ')
      GO TO 1
  28  CALL MESS(LPT,0,'')
      GO TO 1
  29  CALL MESS(LPT,0,'Refine using polarized neutron intensities '//
     &'from powder data')
      go to 1
  30  CALL MESS(LPT,0,'Refine using polarized neutron up-down '//
     &'difference intensity from powder data')
      go to 1
  31  CALL MESS(LPT,0,'Refine  polarized neutron Q x Q* term '//
     &'with CPV (complex chiral) data')
      GO TO 1
    1 RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE RESHUF(A,IPT,N)
      SUBROUTINE RESHUF(A,IPT,N)
C
C *** RESHUF by JCM 22 Aug 86 ***
C
CX
CC 16C
CH Reorders a real array, given a parallel pointer array out of SORTX.
C
CA On entry A is a real array, of dimension at least N, of numbers
CA            whose pointers have been sorted using SORTX.
CA          IPT is an integer array, of dimension at least N, of pointers
CA            within A, probably just produced by sorting with SORTX.
CA          N is the number of entries in each of A and IPT.
CA On exit  A contains the same numbers reordered according to the
CA            pointers in IPT.
C
      DIMENSION A(N),IPT(N)
      COMMON /SCRAT/TEMP(3000)
C
      DO 1 I=1,N
   1  TEMP(I)=A(IPT(I))
C
      DO 2 I=1,N
   2  A(I)=TEMP(I)
      RETURN
      END
C
C
C
C
C LEVEL 3      FUNCTION RESOL(H,D)
      FUNCTION RESOL(H,D)
C
C *** RESOL by JCM 17 Apr 84 ***
C
CX
CC 5B
CH Calculates a resolution function for use with Fourier inversion.
CA On entry H(1:3) contains the indices h,k,l of a reflection.
CA          D is the resolution length in Angstroms.
CD The function value returned in RESOL multiplies the amplitude of the
CD term corresponding to H in the Fourier sum. The result corresponds
CD to averaging the density over a cube of edge 2D.
C
CP RECIP to set up the metric
C
      DIMENSION H(3),OH(3)
/CONSTA/
C
      RESOL=1.
      IF (ABS(D) .LT. 0.00001) GO TO 100
      CALL ORTHO(H,OH,2)
      DO 1 I = 1,3
      A = TWOPI*OH(I)*D
      IF (ABS(A) .LT. .001) GO TO 1
      RESOL = RESOL*SIN(A)/A
    1 CONTINUE
 100  RETURN
      END
C
C
C
C
C LEVEL 3      SUBROUTINE RFACS(IN)
      SUBROUTINE RFACS(IN)
C
C *** RFACS updated to do Chisqr for multi-source correctly C4.26 March 2013 ***
C Now deals correctly with refinement on Fsqr
C Calculates proper R-factor on squares
C
CX
CC 6B
CH A multiple entry routine to deal with all aspects of R Factor
CH calculations and statistics for single crystal observations, and
Ch for slack constraints.
CA On entry, IN indicates the calculation required:
CA   IN=1  Set up all quantities, clearing to zero
CA   IN=2  Add in contributions for conventional Obs R Factors
CA   IN=3  Print out for conventional Obs R Factors
CA   IN=4  Add in contributions for slack constraint type ISLKTP in /SLAKDA/
CA   IN=5  Print out for slack constraint, type ISLKTP
CA   IN=6  Print out for both obs and slack constraints
CA   IN=11  Set up all quantities, clearing to zero including NOBS
CA   IN=12  Add in contributions for conventional Obs R Factors, increment NOBS
CA   IN=13  Add into totals over all data sets
C
CD If IWGHT=1 we expect that the weights are unity: we try to avoid
CD unnecessary R factors in this case.
CD The R Factors are:
CD       R1=simple R factor, 100*sum[ABS(diffs)]/sum[obs]
CD       R2=squared R factor, 100*sum[ABS(obs sqrd - calc sqrd)]/sum[sqrd obs]
CD       R3=simple weighted R factor,
CD                      1OO*sum[ABS(weighted(diffs))]/sum[weighted(obs)]
CD       R4=Squared weighted R factor
C
CO For entries 3,5 and 6 prints R factors on unit LPT.
C
      LOGICAL TESTOV
/DERBAS/
/IOUNIT/
/OBSCAL/
/REFINE/
/RSTATS/
/SLAKDA/
/SLKGEO/
C
Clear totals for multisource
      IF (IN.EQ.21) THEN
        NBSTOT=0
        SWDTOT=0.
      ELSE
        IF (IN.GT.10) GO TO (7,2,8), (IN-10)
        GO TO (1,2,3,4,5,6) , IN
        CALL ERRIN2(IN,0,'in RFACS call - type','not written')
      ENDIF
C
    7 NOBS=0
C INITIAL ENTRY
   1  RNUM=0.0
      RDEN=0.0
      RSNUM=0.0
      RSDEN=0.0
      RWNUM=0.0
      RWDEN=0.0
      SUMWD=0.0
      RWSNUM=0.0
      RWSDEN=0.0
C TYPES OF SLACK CONSTRAINT:
%      CALL GMZER(SLKSWD,1,%SKTP%)
      GO TO 100
C
C ADDING IN ENTRY
    2 SUMWD = SUMWD+DIFF*DIFF*WT
      IF (IREF .EQ.2) THEN
C Obs is Fsqr
        DIF1 = ABS(SQRT(OBS) - SQRT(GCALC))
        G1 = SQRT(OBS)
        WG1 = G1*WT
        WDIF1 =DIF1*WT
        DIF2 = ABS(DIFF)
        WDIF2 = DIF2*WT
        G2 = OBS
        WG2 = OBS*WT
      ELSE
C Obs is F
        DIF1 =ABS(DIFF)
C C101 This was WDIF1 = ABS(WDIFF)
        WDIF1 =DIF1*WT
        G1 = ABS(OBS)
        WG1 = ABS(OBS)*WT
        DIF2 = ABS(OBS*OBS - GCALC*GCALC)
        WDIF2 = DIF2*WT
        G2 = OBS*OBS
        WG2 = G2*WT
      ENDIF
      IF (IN.EQ.12) NOBS=NOBS+1
      RNUM=RNUM+DIF1
      RDEN=RDEN+G1
      RSNUM=RSNUM+DIF2
      RSDEN=RSDEN+G2
      RWNUM=RWNUM+WDIF1
      RWDEN=RWDEN+WG1
      RWSNUM=RWSNUM+WDIF2
      RWSDEN=RWSDEN+WG2
C        write (ito,10) wdif1,wg1,rwnum,rwden,wdif2,wg2,rwsnum,rwsden
C   10 format (10e10.3)
      GO TO 100
C
C PRINT
   3  IF (TESTOV(RNUM,RDEN)) THEN
        CALL MESS(LPT,1,'R Factors not available as denominators zero')
        GO TO 100
      ENDIF
C
      R1=100.0*RNUM/RDEN
      R2=100.0*RSNUM/RSDEN
      WRITE (LPT,2001) R1,R2
2001  FORMAT (/' R1=Sum diffs/Sum obs =',G12.4/
     & ' R2=Sum of diffs of squares/Sum obs squared = ',G12.4)
      CHISQ=SUMWD/FLOAT(NOBS-LVARB)
      WRITE (LPT,2003) CHISQ,SUMWD
      WRITE (ITO,2003) CHISQ,SUMWD
2003  FORMAT (' Chi squared =',G12.3,' Sum weighted diffs sqrd =',
     & G12.3)
      WRITE (LPT,2033) NOBS,LVARB
2033  FORMAT (' For',I6,' observations and',I4,' basic variables')
      IF (IWGHT .EQ. 1) GO TO 100
      R3=100.0*RWNUM/RWDEN
      R4=100.0*RWSNUM/RWSDEN
      WRITE (LPT,2002) R3,R4
2002  FORMAT (' R3=Sum weighted diffs/Sum weighted obs = ',G12.4/
     &' R4=Sum weighted diffs of squares/Sum weighted squares obs =',
     &G12.4)
C Collect totals for multisource refinemments
      NBSTOT = NBSTOT+NOBS
      SWDTOT = SWDTOT + SUMWD
      GO TO 100
C
C SPECIAL ENTRY FROM SLACK CONSTRAINT CALCULATION - ADD IN:
   4  SLKSWD(ISLKTP)=SLKSWD(ISLKTP)+WT*DIFF*DIFF
      GO TO 100
C
C4.26 Entry at end of each data set
C Collect totals for multisource refinemments
   8  NBSTOT = NBSTOT+NOBS
      SWDTOT = SWDTOT + SUMWD
      GO TO 100
C
C PRINTING FOR SLACK CONSTRAINTS:
   5  WRITE (LPT,2010) ISLKTP
      WRITE (ITO,2010) ISLKTP
2010  FORMAT (/' For slack constraints type',I4)
** NEED DATA STATEMENT WITH DIFFERENT TYPES
      CSQTOT=SLKSWD(ISLKTP)/FLOAT(NSLAK(ISLKTP))
      WRITE (LPT,2011) CSQTOT,NSLAK(ISLKTP)
      WRITE (ITO,2011) CSQTOT,NSLAK(ISLKTP)
2011  FORMAT (/' Chi squared=',G12.3,' for',I4,' constraints')
      GO TO 100
C
C PRINTING FOR SLACK CONSTRAINTS AND CONVENTIONAL OBS TOGETHER:
   6  IF (NSKTOT .EQ. 0 .OR. SLONLY) GO TO 100
      CNUM=SUMWD
      CDEN=FLOAT(NOBS-LVARB)
%      DO 36 ISK=1,%SKTP%
      IF (NSLAK(ISK) .EQ. 0) GO TO 36
C WE ONLY WANT THIS FIGURE IF WE HAVE BOTH CONVENTIONAL OBS AND SLACK
C CONSTRAINTS:
      CNUM=CNUM+SLAKWT(ISK)*SLKSWD(ISK)
      CDEN=CDEN+SLAKWT(ISK)*FLOAT(NSLAK(ISK))
  36  CONTINUE
      CSQTOT=CNUM/CDEN
      WRITE (LPT,2005) CSQTOT
      WRITE (ITO,2005) CSQTOT
2005  FORMAT (' Chi squared for conventional obs',
     &   ' and all slack constraints = ',G12.3)
 100  RETURN
      END
C
C
C
C
C LEVEL 2      FUNCTION RGAUSS(SIGMA)
      FUNCTION RGAUSS(SIGMA)
C
C *** RGAUSS by PJB 27-Sept-93 ***
C
CX
CC 9C
CH Returns a value random number with a gaussian distribution.
CA On entry SIGMA gives the width if the dsitribution such that
CA          p(x)=exp-(x/SIGMA)**2
CA          if SIGMA=0 sets the seed for random number generation
CN  Uses the subprogram NB01A from the Harwell library.
C
/LENINT/
      COMMON /SEEDIT/LSEED
C
      IF (SIGMA.EQ.0) THEN
        SEED=SECNDS(0.)
        ISEED=2**(NBITS-1) -INT(SEED)
        ISEED=2*ISEED-1
        GO TO 100
      ENDIF
      AR=RAN(ISEED)
      R=ABS(2*AR-1.)
      K=0
      NUM=0
      A=0.
      XLIM=100.
      B=XLIM
      ERR=.0001
      MAXIT=100
    5 CALL NB01A(K,A,B,ERR,X,Y,MAXIT)
      GO TO (1,2,3,4) K
C
    1 IF (X.GT.XLIM) THEN
        Y=1.-R
      ELSE
        Y=1.-ERFNC(X)-R
      ENDIF
      GO TO 5
C
    2 RGAUSS=X
      IF (AR.LT.0.5) RGAUSS=-X
      RGAUSS=RGAUSS*SIGMA
      GO TO 100
C
    3 CALL ERRMES(1,0,'Too many iterations in RGAUSS')
      GO TO 100
    4 CALL ERRMES(1,0,'from RGAUSS')
      GO TO 100
C
C
  100 RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE RMCSCA(A,B,SCALE,NI,NJ)
      SUBROUTINE RMCSCA(A,B,SCALE,NI,NJ)
C
C *** RMCSCA from CMRSCA by PJB C4.26 April 2012 ***
C
CX
CC 12C
CH Multiplies every element of a REAL matrix by a COMPLEX scale.
CA On entry, A holds a REAL NI by NJ matrix
CA           SCALE holds a COMPLEX scalar
CA On exit,  B holds a COMPLEX NI by NJ matrix being A times SCALE
CN A cannot be the same as B
CN Note also the existence of CGMSCA which works entirely in COMPLEX.
C
      REAL A(1)
      COMPLEX B(1),SCALE
      NIJ=NI*NJ
      DO 1 I=1,NIJ
    1 B(I)=SCALE*A(I)
      RETURN
      END
C
C
C
C
C LEVEL 2      SUBROUTINE ROTOSM(H,RH,IOP,ISS)
      SUBROUTINE ROTOSM(H,RH,IOP,ISS)
C
C *** ROTOSM CROTO entry vector not reversed for neg iop MARCH 2013 ***
C
CX
CC 1B
CH Calculates the effect of the rotation matrix of a symmetry operator,
CH on a vector given on orthogonal axes.
CA On entry  H(1:3)is a real vector in standard orthogonal coordinates
CA           IOP  is the number of a symmetry operator, negative for one
CA                related by a centre of symmetry to the stored one
CA           ISS  defines the mode of operation:
CA ISS = 0  Set-up by calculating the whole set of symmetry operations in
CA          orthogonal co-ordinates
CA ISS > 0  Calculate the effect of the symmetry operator IOP.
CA ISS < 0  Calculate the effect of the inverse of the symmetry operator IOP.
CA On exit   RH(1:3) is the vector obtained by operating with the
CA                rotation matrix of the element IOP on H.
CP SYMOP and RECIP must have set up the symmetry and cell parameters.
CP ROTOSM must be called with ISS=0 before any other use is made of it
CD The call with ISS=0 sets the orthogonal symmetry elements into
CD COMMON /ORTSYM/
C
CN ENTRY CROTO(CH,CRH,IOP,ISS) does the rotation for the complex
CN vectors CH and CRH.
CN
CN Note that in orthogonal coordinates there is no distinction between
CN real and reciprocal space
C
      DIMENSION H(3),RH(3),TEMP(3,3)
      COMPLEX CH(3),CRH(3)
/CELPAR/
/ORTSYM/
/NSYM/
/SYMDA/
/SYMTAB/
C
      I=IABS(IOP)
      IF (ISS.NE.0 .AND. NFLAG .EQ. 42) GO TO 1
C
C PUT SYMMETRY ROTATIONS ONTO ORTHOGONAL AXES
C USE SYMORT(,,1) TEMPORARILY FOR TRANSPOSE:
      CALL GMEQ(ORTH(1,1,1),SYMORT(1,1,1),3,3)
      CALL TRANSQ(SYMORT(1,1,1),3)
      DO 27 NO=2,NOPC
      CALL GMPRD(SYM(1,1,NO),ORTH(1,1,2),TEMP,3,3,3)
      CALL GMPRD(SYMORT(1,1,1),TEMP,SYMORT(1,1,NO),3,3,3)
   27 CONTINUE
      CALL GMUNI(SYMORT(1,1,1),3)
      NFLAG=42
      IF (ISS .EQ. 0) GO TO 100
C
   1  IF (ISS.LT.0) I=INVERS(I)
      CALL GMPRD(SYMORT(1,1,I),H,RH,3,3,1)
      IF (IOP.LT.0) CALL GMREV(RH,RH,3,1)
      GO TO 100
C
C  ENTRY FOR COMPLEX VECTORS
      ENTRY CROTO(CH,CRH,IOQ,IST)
      I=IABS(IOQ)
      IF (IST.LT.0) I=INVERS(I)
      CALL RCMPRD(SYMORT(1,1,I),CH,CRH,3,3,1)
C4.26      IF (IOQ.LT.0) CALL CGMREV(CRH,CRH,2,3)
      GO TO 100

C
  100 RETURN
      END
C
C
C
C
C LEVEL 2      SUBROUTINE ROTSYM(H,RH,IOP,ISS)
      SUBROUTINE ROTSYM(H,RH,IOP,ISS)
C
C *** ROTSYM by JCM 11 Apr 83 ***
C
CX
CC 1B
CH Rotates the vector H into RH by the given symmetry operator.
CA On entry  H(1:3) is a 1x3 vector (in either space)
CA          IOP is the serial number of a symmetry rotation matrix
CA          ISS is positive for pre-multiplication by rotation matrix,
CA              negative for post-multiplication
CA              the absolute value of ISS is 1 for real and 2 for
CA              reciprocal space
CA On exit  RH(1:3) is the 1x3 vector resulting from multiplying H by
CA              the rotation matrix as specified by ISS
CP SYMOP to set the symmetry matrices
C
      DIMENSION H(3),RH(3)
/SYMDA/
/SYMTAB/
C
      I=IOP
      IS=ISS
C
C IF RECIPROCAL SPACE REQUESTED, MATRIX USED MUST BE INVERSE TRANSPOSED OF
C THAT REFERRING TO REAL SPACE.  THE INVERSE IS OBTAINED BY INDIRECT ADDRESSING
C VIA ARRAY INVERS, AND THE TRANSPOSE BY REVERSING THE SEQUENCE OF THE
C MULTIPLICATION:
      IF (IABS(IS).EQ.2) I=INVERS(I)
      IF (IS .LT. 0) IS=IS+5
      GO TO (1,2,1,2) , IS
C
C PRE-MULTIPLICATION
   1  CALL GMPRD(SYM(1,1,I),H,RH,3,3,1)
      GO TO 100
C
C POST-MULTPLICATION
   2  CALL GMPRD(H,SYM(1,1,I),RH,1,3,3)
 100  RETURN
      END
C
C
C
C
C LEVEL 2      SUBROUTINE RREFSF
      SUBROUTINE RREFSF
C
C *** C4.27 RREFSF Updated for Up -Down powder data April 2013 ***
C
CX
CC 6B
CH A common interface for reading and storing reflection data
CA READS FROM LUNI
CA Puts all the data into COMMON SFDATA
CD The GOBS stored is  F if the refinement is on structure
CD factors (IREF = 1) and  Fsqr if it is on their squares (IREF = 2).
CD  Both the scale group and code are optional.  if the scale group is
CD  read as zero, it will be set = 1.
CD  The code is only used for MODER 9 and 10
CD If MODER > 100 then OBS and DOBS read are Intensities (Fsqr) otherwise
CD they are structure amplitudes (F). The exception is when IREF is 5
CD in which case OBS and DOBS are flipping ratios.
C
      DIMENSION A(11),LDATA(10)
      LOGICAL LERCHK,TESTOV
/ABSDAT/
/DGEOM/
/DSOURC/
/EXTN/
/IOUNIT/
/OBSCAL/
/POLDA/
/REFINE/
/SFDATA/
/SCLDAT/
/SCRACH/
C
      NSREG=1
      IPS=0
      IF (IEXTYP.NE.0) THEN
        PATH=-1.
        WLGTH=SRCPAR(6,JSRC)
        IF (PATHS) THEN
          AMU=SRCPAR(7,JSRC)
          CALL GMEQ(SRCPAR(8,JSRC),UM,3,3)
        ENDIF
      ENDIF

      CALL REPMOD(MODER,LDATA)
C      write (lpt,4000) jsrc,moder,ldata
C 4000 format ('JSRC',i3,'  MODER',I3,' LDAtA',10i3)
      IF (JSRC.GT.1) IPS=IPSCAL(JSRC-1)
C THE FIRST LINE SHOULD ALREADY BE IN ICARD
      GO TO 4
    3 READ (LUNI,1111,END=8) MESSAG
 1111 FORMAT (A80)
C
%    4 IF (.NOT. LERCHK(2,NOBS,%NLSQ%,-1,'DATA ENTRIES')) GO TO 100
C
      NNOBS=NOBS
      CALL RDNUMS (A,1,LDATA(2),NUMA,IER)
      IF (NUMA .LT. LDATA(1))  CALL ERRMES(0,0,'Error rading data')
      call gmeq(a,hs(1,nobs),3,1)
      GOBS(NOBS)=A(LDATA(3))
      IF (LDATA(3).EQ.0) THEN
        IF (LDATA(4) .EQ.0) THEN
          WGTS(NOBS)=1.
        ELSE
          WGTS(NOBS)=A(LDATA(4))
        ENDIF
      ELSE
C IGNORE DATA WITH ZERO ESD
        DOBS=A(LDATA(4))
        IF (TESTOV(1.,DOBS)) THEN
          NOBS=NOBS-1
          GO TO 3
        ELSE
          WGTS(NOBS)=1./(DOBS*DOBS)
        ENDIF
      ENDIF
C SQUARE INPUT OBS IF REFINEMENT TYPE 2:
C4.22 Correction for case where GOBS=0
      IF ((IREF .EQ. 2 ) .AND. MODOBS .EQ.0) THEN
        GOBS(NOBS)=GOBS(NOBS)*GOBS(NOBS)
        IF (LDATA(3)+LDATA(4).GT.0) THEN
          IF (TESTOV(1.,GOBS(NOBS))) THEN
            WGTS(NOBS) = WGTs(NOBS)**2
          ELSE
            WGTS(NOBS) = WGTS(NOBS)/(4.*GOBS(NOBS))
          ENDIF
        ENDIF
      ELSE IF (IREF .EQ. 1 .AND. MODOBS .EQ.1) THEN
        IF (LDATA(3)+LDATA(4) .GT.0) THEN
          IF (TESTOV(1.,GOBS(NOBS))) THEN
            WGTS(NOBS)=SQRT(WGTs(NOBS))
          ELSE
            WGTS(NOBS)=WGTS(NOBS)*4.*GOBS(NOBS)
          ENDIF
        ENDIF
        GOBS(NOBS)=SQRT(GOBS(NOBS))
      ENDIF
C EXTRA PARAMETERS READ FROM DATA
      IF (LDATA(6).NE.0)
     &CALL GMEQ(A(LDATA(6)),CPARS(1,NOBS),LDATA(7),1)
      IPOS=LDATA(7)+1
C PUT ISCALE WITHIN PERMITTED RANGE: IT IS USUALLY OPTIONAL
      IF (NUMA .GE. LDATA(8)) THEN
        ISCALE=NINT(A(LDATA(8)))
      ELSE
        ISCALE=0
      ENDIF
      IF (ISCALE .EQ. 0) ISCALE=1
      IF (ISCALE .GT. NSREG) NSREG=ISCALE
      JSCALE(NOBS)=ISCALE + IPS
C ICODES to be stored
      ICODES(NOBS)=0
C SNP Data ICODE indicates change of reflection
      IF (NUMA .GE. LDATA(9))ICODES(NOBS)=NINT(A(LDATA(9)))
C SPECIALS
C MAGNETISED Powder data
      IF (LDATA(10) .EQ.1) THEN
        TWOTH=RADIAN(CPARS(1,NOBS))
        ICODES(NOBS)=0
C MULTIPLICITY AND ANGLE FACTOR FOR POWDER
        MUL=MULPCY(HS(1,NOBS))
        afac=SIN(TWOTH)*SIN(TWOTH/2.)
        FAC=FLOAT(MUL)/afac
         CPARS(1,NOBS)=FAC
         IPOS=2
C4.27 Mod to allow difference refinement
        IF (IREF.EQ. 10) THEN
          GOBS(NOBS)=GOBS(NOBS)-A(LDATA(3)+2)
          DOBS=SQRT(DOBS**2 + A(LDATA(4)+2)**2)
          WGTS(NOBS)=(DOBS**2)
          ICODES(NOBS)=2
        ELSE
%      IF (.NOT. LERCHK(2,NOBS,%NLSQ%,-1,'DATA ENTRIES')) GO TO 100
C Data for other polarisation
          CALL GMEQ(A(1),HS(1,NOBS),3,1)
          GOBS(NOBS)=A(LDATA(3)+2)
          DOBS=A(LDATA(4)+2)
          WGTS(NOBS)=1./(DOBS**2)
          JSCALE(NOBS)=ISCALE + IPS
          ICODES(NOBS)=1
          CPARS(1,NOBS)=FAC
          IPOS=2
        ENDIF
      ELSE IF (LDATA(10) .EQ.2 ) THEN
C SXD type data with wavelength and path with each reflection
        WLGTH=CPARS(1,NOBS)
        PATH=CPARS(2,NOBS)
      ENDIF
C
C CALCULATE OTHER PARAMETERS WHICH MAY BE NEEDED FOR THE REFINENENT
      IF (IEXTYP .NE.0 .AND. IPOS .NE.5) THEN
        CALL EXTPAR(HS(1,NOBS),WLGTH,PATH)
        CALL GMEQ(CEXT,CPARS(1,NOBS),4,1)
        IPOS=5
      ENDIF
      GO TO 3
C
C END OF DATA
    8 NDATA=NOBS
      MSRC(1,JSRC)=MODER
      MSRC(2,JSRC)=IREF
      NOBSRC(JSRC)=NOBS
      IPSCAL(JSRC)=IPS
C Scales are not used if iref=8
      if (iref.ne.8) IPSCAL(JSRC)=IPSCAL(JSRC)+NSREG
C
  100  RETURN
       END
C
C
C
C
C LEVEL 1      FUNCTION RSCALP(A,B)
      FUNCTION RSCALP(A,B)
C
C *** RSCALP by PJB Jun 87 ***
C
CX
CC 12C
CH Forms the scalar product of two COMPLEX vectors.
CA On entry A and B are complex vectors of dimension 3
CD The function value is the real product (A.Conjg(B) + Conjg(A).B)/2
C
      COMPLEX A(3),B(3),P
      P=CMPLX(0.,0.)
      DO 1 I=1,3
      P=P+A(I)*CONJG(B(I))
    1 CONTINUE
      RSCALP=REAL(P)
      RETURN
      END
C
C
C
C
C LEVEL 2      LOGICAL FUNCTION SAID(INCHAR,WANT)
      LOGICAL FUNCTION SAID(INCHAR,WANT)
C
C *** SAID modified by PJB July 95 ***
C
CX
CC 11C
CH Decides whether the character variables INCHAR and WANT are the same,
CH ignoring any distinction between upper and lower case.
CA On entry INCHAR is an character variable to test
CA          WANT is the character variable to match
CD Sets SAID .TRUE. if INCHAR and WANT are equal, ignoring the case
CD if they are letters.
C
      CHARACTER *(*) INCHAR,WANT
C
      SAID = .FALSE.
      LN=LEN(INCHAR)
      IF (LEN(WANT).NE.LN) GO TO 100
      DO 1 I=1,LN
      IF (INCHAR(I:I) .EQ. WANT(I:I)) GO TO 1
      L=LETTER(INCHAR(I:I))
      M=LETTER(WANT(I:I))
      IF (L .EQ. M .AND. L .NE. 0) GO TO 1
      GO TO 100
    1 CONTINUE
      SAID=.TRUE.
 100  RETURN
      END
C
C
C
C
C LEVEL 5      SUBROUTINE SATFND(H,HS,NR)
      SUBROUTINE SATFND(H,HS,NR)
C
C *** SATFND updated by PJB 23 Nov 90 ***
C
CX
CC 17B
CH Finds the indices HS of the satellite equivalent to H, offset by the
CH propagation vector PROP from a reciprocal lattice point.
CA On entry H is a 1x3 vector in reciprocal space.
CA On exit NR is the number of the symmetry operator which takes H
CA            into HS
CA         NR is set to zero if an allowed satellite was not found.
CA         HS is a 1x3 vector holding the satellite equivalent vector.
C
CP SYMOP and DOMAG1 must have set up the symmetry.
C
      DIMENSION H(3),HS(3)
      LOGICAL MAGABS
/NSYM/
/SATELL/
C
      J=1
      DO 1 I=1,NOPC
C
C141 KSTAB(1) NOW DOES ACTUALLY CONTAIN 1:
      IF (KSTAB(I).NE.J) GO TO 1
      CALL ROTSYM(H,HS,I,-2)
      IF (.NOT.MAGABS(HS,IK)) GO TO 101
      J=J+1
      IF (J.GT.NKSTAR) GO TO 2
    1 CONTINUE
C
    2 I=0
C IF NOTHING FOUND PUT H INTO HS
      CALL GMEQ(H,HS,1,3)
  101 NR=I
      RETURN
      END
C
C
C
C
C LEVEL 4      SUBROUTINE SATGEN(HF,HS,MUL,NUM)
      SUBROUTINE SATGEN(HF,HS,MUL,NUM)
C
C *** SATGEN corrected by PJB 2-Jan-96 ***
C
CX
CC 17B
CH Generates a set of magnetic satellite reflections.
CA On entry  HF contains the indices of the fundamental reflection
CA On exit   HS is an array of satellites of the fundamental which are
CA              inside the asymmetric unit
CA           MUL is an array containing the multiplicity of each satellite
CA           NUM is the number of distinct satellites found
CP SYMOP, SYMUNI and DOMAG1 must have set up the symmetry.
C
      DIMENSION HF(3),HS(3,1),MUL(1),H(3),HT(3),AK(3)
/NSYM/
/SATELL/
C
      NUM=0
      DO 1 J=1,NOPC
      IF (J.EQ.1) THEN
        CALL GMEQ(PROP,AK,3,1)
      ELSE
        NOP=IABS(KSTAB(J))
        IF (NOP.EQ.1) GO TO 1
        CALL ROTSYM(PROP,AK,NOP,2)
        IF (KSTAB(J).LT.0) CALL GMREV(AK,AK,3,1)
      ENDIF
      DO 2 KC=1,2
C  ADD STAR VECTOR TO FUNDAMENTAL
      CALL GMADD(HF,AK,H,3,1)
C  TAKE CARE OF SPECIAL CASES WHEN PROP IS HALF A RLV
      IF (KC.EQ.1 .AND. KCENT.EQ.1) THEN
        CALL GMADD(H,AK,HT,3,1)
        M=MULBOX(HT)
        IF (M.NE.0) GO TO 2
      ENDIF
      M=MULBOX(H)
      IF (M.EQ.0) GO TO 2
      NUM=NUM+1
      MUL(NUM)=M
      CALL GMEQ(H,HS(1,NUM),3,1)
   2  CALL GMREV(AK,AK,3,1)
   1  CONTINUE
C
      RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE SAVMAP
      SUBROUTINE SAVMAP
C
C *** SAVMAP updated by JCM 10 May 88 ***
C
CX
CC 5B
CH Writes 1 layer of map to given file, plus information for later retrieval.
C
CP One of FOUR1Z, FOURGP etc must have been obeyed first to produce map.
C
CO Writes on first entry a header block, plus one map;  on subsequent entries,
CO one map, and on the final entry one map and a trailer block.
C
CO The material written is the value of Z, NOBS and NUSED, and the array DENS.
C
CN The map can be later got back by GETMAP.
C
/CARDRC/
/IOUNIT/
/MAPDA/
/MAPSV/
/SCRACH/
C
C
C NSAV=HOW MANY MAPS ALREADY SENT - IF 0, SEND HEADER:
      IF (NSAV .GT. 0) GO TO 2
C
C * THERE IS A STRONG SUSPICION THAT THE USE OF NTOTAL WILL SIMPLIFY THIS
C COUNT AND CHECK NUMBER OF CARDS IN FILE IO10:
      NCDS=0
      DO 5 I=1,26
   5  NCDS=NCDS+ICDNO(I)
      WRITE (NDUMPS) INREAD,ICDNO,NCDS
      ICD=0
      ID=0
   9  ID=ID+1
      IF (ID .GT. NTOTAL(1)) GO TO 6
      READ (IO10,REC=ID,FMT=1000) ICARD
1000  FORMAT (A80)
      WRITE (NDUMPS) ICARD
      IF (ICARD(1:1) .NE. 'Y' .AND. ICARD(1:1) .NE. 'Z')ICD=ICD+1
      GO TO 9
C
   6  IF (ICD .EQ. NCDS) GO TO 2
      WRITE (LPT,3000) IO10,NCDS
      WRITE (ITO,3000) IO10,NCDS
3000  FORMAT (/' ERROR ** FILE',I3,' AND VECTOR ICDNO ARE',
     & ' OUT OF STEP - ICDNO EXPECTS',I4,' CARDS')
      STOP
C
C WRITE INFO FOR ONE MAP:
   2  WRITE (NDUMPS) OUTLIM(1,3),NOBSIN,NUSED,NX,NY
      I=0
      DO  4 IY=1,NY
      WRITE (NDUMPS) (DENS(I+J),J=1,NX)
   4  I=I+NX
      NSAV=NSAV+1
C
      IF (NSAV .EQ. 1) WRITE (LPT,2003) NCDS
2003  FORMAT (/' Header record with',I4,' cards written')
      IF (NDIM .EQ. 2) WRITE (LPT,2001) NSAV
2001  FORMAT (/' Map no.',I3,' saved')
      IF (NDIM .EQ. 3) WRITE (LPT,2002) NSAV,OUTLIM(1,3)
2002  FORMAT (/' Map no.',I3,' saved for Z=',F10.4)
      IF (ZCSV .LE. 99998.) GO TO 100
C
C WRITE TRAILER:
      WRITE (NDUMPS) 99999.,0,0,0,0
      CALL MESS(LPT,1,'Trailer record written')
 100  RETURN
      END
C
C
C
C
C LEVEL 2      LOGICAL FUNCTION SAYS(WANT)
      LOGICAL FUNCTION SAYS(WANT)
C
C *** SAYS by PJB 1-Oct-93 ***
C
CX
CC 11C
CH Decides whether the string WANT matches a string of the same length,just
CH read into /SCRACH/ ignoring any distinction between upper and lower case.
CA On entry WANT is the string to test
CD Sets SAYS .TRUE. if WANT matches the string at the start of ICARD,
CD ignoring the case of letters.
C
      CHARACTER *(*) WANT
/SCRACH/
C
      SAYS =.FALSE.
      L=LEN(WANT)
      DO 1 I=1,L
      N1=LETTER(WANT(I:I))
      IF (N1.EQ.0) THEN
C NOT A LETTER NEED AN EXACT MATCH
        IF (ICARD(I:I).EQ.WANT(I:I)) GO TO 1
        GO TO 100
      ELSE
C FOR LETTERS EITHER UPPER OR LOWER CASE WILL DO
        N2=LETTER(ICARD(I:I))
        IF (N1.EQ.N2) GO TO 1
        GO TO 100
      ENDIF
    1 CONTINUE
C ALL CHARACTERS MATCH
      SAYS=.TRUE.
  100 RETURN
      END
C
C
C
C
C LEVEL 2      FUNCTION SCALPR(A,B)
      FUNCTION SCALPR(A,B)
C
C *** SCALPR by JCM ***
C
CX
CC 12C
CH Forms the scalar product of two orthogonal vectors (or of one from
CH real space with one from reciprocal space).
CA On entry A and B are vectors of dimension 3
CD The function is set to the scalar product of A and B (not involving
CD  cell parameters) e.g. with one vector from real & one from reciprocal
CD  space
CN The function SCLPRD gives the scalar product using the cell parameters.
C
      DIMENSION A(3),B(3),C(1)
      CALL GMPRD(A,B,C,1,3,1)
      SCALPR = C(1)
      RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE SCLCHN(NP,A,NFIX,FIX)
      SUBROUTINE SCLCHN(NP,A,NFIX,FIX)
C
C *** SCLCHN by JCM 13 Jul 83 ***
C
CX
CC 6A
CH A specialist routine used during the setting up of constraints on LSQ
CH variables.  Scales a chain of connected variables by the given constant.
CA On entry NP points to the first element of the chain in the arrays
CA             NFIX, FIX.
CA          A is the real constant by which the chain is to be scaled,
CA          NFIX is an integer array holding pointers within itself to
CA             describe the existing chain,
CA          FIX is a real array of multipliers of the corresponding
CA             elements of NFIX.
CD Scales all the elements of FIX which correspond to NFIX(NP) and those
CD elements which are chained to it.
C
      DIMENSION NFIX(1),FIX(1)
C
      J1=NP
   1  FIX(J1)=A*FIX(J1)
      J1=IABS(NFIX(J1))
      IF (J1 .NE. NP) GO TO 1
      RETURN
      END
C
C
C
C
C LEVEL 1      FUNCTION SCLPRD(H1,H2,IR)
      FUNCTION SCLPRD(H1,H2,IR)
C
C *** SCLPRD by JCM 26 Apr 84 ***
C
CX
CC 1B
CH Forms the scalar product of two vectors referred to crystal axes.
CA On entry H1 and H2 are two 1x3 vectors referred to the crystal axes.
CA             They are in real space if IR=1, reciprocal if IR=2.
CD The function is set to be the scalar product of H1 and H2
CP RECIP must have been obeyed to set up the cell parameters.
C
      DOUBLE PRECISION SCL
      DIMENSION H1(3),H2(3)
/CELPAR/
C
      SCL=0.
      J=2
      K=3
      DO 1 I=1,3
      SCL=SCL+H1(I)*H2(I)*CPARS(I,IR) + (H1(J)*H2(K)+H1(K)*H2(J)
     & )*CPARS(I+3,IR)
      J=K
      K=I
   1  CONTINUE
      SCLPRD=SNGL(SCL)
      RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE SERROR(M,N,F,X,W,S,H,SD)
      SUBROUTINE SERROR(M,N,F,X,W,S,H,SD)
C
C *** SERROR from PJB by R M Richardson 22 Sep 80 ***
C
CX
CC 6C
CH Called after VA05A to give the standard deviations of the parameters.
C
CP  Minimisation procedure VA05A from the Harwell library
CA  Input arguments:-
CA     M,N,F,X,W as defined in VA05A description
CA  Output arguments:-
CA     S=Sum of squares
CA     H=Fractional variance covariance matrix
CA     SD=Fractional standard error of parameter (provided that the
CA     covariance is negligible)
C
      DIMENSION F(M),X(N),W(1),H(1),SD(N)
      NWI=M*N
      S=0.0
      DO 2 J=1,M
    2 S=S+F(J)*F(J)
      DO 10 I=1,N
      DO 6 J=1,N
      HH=0.0
      K=NWI+I
      KK=NWI+J
      DO 5 L=1,M
      HH=HH+W(K)*W(KK)
      K=K+N
      KK=KK+N
    5 CONTINUE
      IJ=(J-1)*N+I
      H(IJ)=HH/(X(I)*X(J))
    6 CONTINUE
      I2=(I-1)*N+I
      SD(I)=SQRT(H(I2)*S/(M-N))
   10 CONTINUE
      RETURN
      END
C
C
C
C
C LEVEL 12      SUBROUTINE SETABS
      SUBROUTINE SETABS
C
C *** SETABS by JCM 4 Oct 85 ***
C
CX
CC 2A
CH Sets up data for the calculation of absorption (or related) integrals.
CD Calls SETDC and SETG to set up the COMMON blocks /DGEOM/ and /GAUSS/
CD Checks that all necessary quantities have been given and are acceptable.
CD Checks that at least 3 plane faces have been given on G FACE cards.
CD Checks that D L/R card has been given.
CD If no G MODE card has been given, assumes mode 1, simple absorption
CD correction.
CD If no G PNTS card has been given assumes 5 x 5 x 5
CD  If no G MU card has been given assumes that mu will be set by a
CD main program
CP RECIP must have read in the cell parameters.
CI Causes D and "G" cards to be read from the copy of the Crystal Data
CI File on unit IO10.
CO Writes its findings to unit LPT.
C
/ABSDAT/
/CPLANE/
/DREAD/
/GAUSS/
/CARDRC/
/GREAD/
/IOUNIT/
C
      CALL MESS(LPT,2,
     & 'Absorption Corrections using Gaussian integration')
      IF (INREAD(4) .GT. 0) CALL SETDC
      IF (INREAD(7) .GT. 0 ) CALL INPUTG
C
C NOW CHECK SPECIFIC ITEMS NEEDED FOR ABSORPTION TYPE INTEGRALS:
      IF (NP .LE. 2) THEN
        CALL ERRMES(2,1,'equations of plane faces')
        GO TO 100
      ENDIF
C
      IF (IGREAD(2) .LE. 0) THEN
        NL=5
        NM=5
        NN=5
        CALL MESS(LPT,1,'No G PNTS card read - assuming 5 x 5 x 5')
      ENDIF
C
      IF (IGREAD(3) .LE. 0) CALL MESS(LPT,1,'No G MU card read - '//
     & 'assuming AMU put in place by MAIN program')
C
      IF (IGREAD(4) .LE. 0) THEN
        MODEA=1
        CALL MESS(LPT,1,'No G MODE card read - assuming 1')
      ENDIF
C
      IF (IDREAD(3) .LE. 0) THEN
        CALL ERRMES(2,1,'D L/R card for abs cor')
        GO TO 100
      ENDIF
C
      CALL SETGAU
 100  RETURN
      END
C
C
C
C
C LEVEL 11      SUBROUTINE SETANI
      SUBROUTINE SETANI
C
C *** SETANI by JCM 23 Sep 83 ***
C
CX
CC 4A
CH Reads "T" cards to set up for calculation of anisotropic temperature factors.
CD Reads cards starting "T"  giving the atom name, type of atf required
CD and 6 coefficients in order a11, a22, a33, a23, a13, a12.
CD SETANI converts the 6 coefficients to type 5 for internal use, stores
CD them in ATF in COMMON /ANISO/ and sets up vector IATYP which says which
CD type they started as.
C
CP RECIP and ATOPOS must have read the cell parameters and atomic positions.
CI Causes "T" cards to be read from the copy of the Crystal Data
CI File on unit IO10.
CO Writes its findings to unit LPT.
CN Types of atf at present allowed are:
CN  0: Convert given itf to an atf, then proceed as if type 2.
CN  2: exp-{1/4(a11 ha* ha* + . . +a12 ha* kb* + . . )}
CN  3: exp-{2*pi*pi(a11 ha* ha* + . .+2a12 ha* kb*  + . .)}
CN  4: exp-(a11 h h + . . +a12 h k + . .)
CN  5: exp-(a11 h h + . . +2a12 h k + . . )
C
CN Numbers 3 and 4 are out of Stout and Jensen pp449-450,
CN number 2 is used in Hewat profile refinement
CN and 5 is the form used internally in this program.
C
      CHARACTER *4 LABB
      DIMENSION ACOEFF(6)
/ANISO/
/CARDRC/
/CELPAR/
/CONSTA/
/IOUNIT/
/POSNS/
C
C
C IT IS NECESSARY THAT ATOPOS HAS SET UP THE ATOM LABELS:
      IF (INREAD(1) .GE. 0) CALL ATOPOS
C
C SET NO ATF ON ANY ATOM:
      CALL JGMZER(IAPT,1,NATOM)
C
C SET "T CARDS READ"
      INREAD(20)=-IABS(INREAD(20))
C
C READ NUMBER OF ANISOTROPIC TEMPERATURE FACTORS (NO. OF "T" CARDS):
      NCARD=ICDNO(20)
      IF (NCARD .EQ. 0) THEN
        CALL MESS(LPT,1,'No anisotropic temperature factors given')
        GO TO 100
      ENDIF
C
      IER=IERR
%      CALL ERRCHK(1,NCARD,%ATFS%,1,'anisotropic temperature factors')
      IF (IERR .GT. IER)GO TO 100
C
      CALL MESS(LPT,1,'Anisotropic temperature factors:')
      CALL MESS(LPT,0,'atom  type    11        22        33        '//
     & '23        13        12')
C
C READ T CARDS ONE BY ONE:
      ID=IABS(INREAD(20))
      DO 5 IP=1,NCARD
      CALL INPUTT(ID,LABB,LBBLEN,IATYP(IP),ATF(1,IP),IER)
      IF (IER .NE. 0) IERR=IERR+1
      ID=ID+NYZ
      J=IATOM(LABB)
      IF (J .LE. 0) THEN
        CALL ERRATM(LABB,2,'on T card')
        GO TO 100
      ENDIF
C
C NAME FOR ATF MATCHED WITH NAME IN ATOM LIST:
      IAPT(J)=IP
      IT=IATYP(IP)
      IF (IT .NE. 0) GO TO 11
C
C CONVERT ITF ALREADY READ TO BE AN ATF, AND SET ITF TO ZERO:
      DO 13 I=1,3
      ATF(I,IP)=TF(J)
      ATF(I+3,IP)=TF(J)*CELL(I,2,2)
  13  CONTINUE
      TF(J)=0.
      GO TO 12
C
C CHECK IF TYPE 1, AND FORCE THESE TO BE 2:
  11  IF (IT .NE. 1) GO TO 3
      CALL MESS(LPT,1,' *** WARNING ** ATF type 1 redefined to '//
     & 'exclude cosines - type 2 assumed')
  12  IATYP(IP)=2
      IT=2
C
C JOIN HERE ON ALL OTHER TYPES:
   3  WRITE (LPT,2002) LABB ,IATYP(IP),(ATF(I,IP), I=1,6)
2002  FORMAT(' ',A4,I5,6F10.4)
      GO TO (22,22,23,24,5) , IT
  22  FAC=0.25
      GO TO 30
C
  23  FAC=TWOPI*PI
  30  ACOEFF(1)=FAC*CPARS(1,2)
      ACOEFF(2)=FAC*CPARS(2,2)
      ACOEFF(3)=FAC*CPARS(3,2)
      ACOEFF(4) = FAC*CELL(3,1,2)*CELL(2,1,2)
      ACOEFF(5) = FAC*CELL(1,1,2)*CELL(3,1,2)
      ACOEFF(6) = FAC*CELL(2,1,2)*CELL(1,1,2)
      GO TO 25
C
  24  DO 9 I=1,3
      ACOEFF(3+I)=0.5
   9  ACOEFF(I)=1.
      GO TO 25
C
C CONVERT ATF() FOR INTERNAL USE;  CONATF WILL CONVERT BACK
  25  DO 6 I=1,6
   6  ATF(I,IP)=ATF(I,IP)*ACOEFF(I)
   5  CONTINUE
C
 100  RETURN
      END
C
C
C
C
C LEVEL 11      SUBROUTINE SETDC
      SUBROUTINE SETDC
C
C *** SETDC Updated for data headers by PJB Oct-2008 C4.12 ***
C
CX
CC 2A
CH Reads D cards to set up crystal orientation and diffraction geometry.
CP RECIP must have read in the cell parameters.
CD Sets the normalised orientation matrix into UM, the wavelength into
CD WLGTH, and the type of geometry into IGEOM all in COMMON /DGEOM/.
CD Also sets other useful quantities in /DGEOM/ for subsequent calculation
CD of the direction cosines of the incident and diffracted rays.
CD If IGEOM indicates 4-circle bisecting geometry, checks the determinant
CD of the UB matrix.  If it is a little different from 1., adjusts the
CD matrix elements until it is < 0.0001 away from 1.
CD If DOTWN! has been executed so that R TWIN cards have been read then
CD The UB matrix is expected to be related to the cell dimensions by the
CD matrix on the first R TMAT card.
CD The UB matrix refers to the hkl of the measurements, and the C card
CD to the structure of the twinned crystal.
C
      DIMENSION H(9)
/CARDRC/
/DGEOM/
/DREAD/
/IOUNIT/
/TWIN/
C4.9 Logical TMUNI is .TRUE.  if one ot the twin matrices is unit
C
       IF (INREAD(3) .GT. 0) CALL RECIP
       IF (INREAD(4) .GT. 0) CALL INPUTD
C
C CHECK D CARDS AND PREPARE FOR USE - AT THIS STAGE USE COULD BE ONE OF SEVERAL
C APPLICATIONS LIKE LP CORRECTIONS, ABSORTION INTEGRALS ETC:
C
      CALL ORTHO(UM(1),H(7),1)
      CALL UNIVEC(H(7),D)
      IF (DNEEDS(1) .AND. (IDREAD(1) .LE. 0)) THEN
      CALL ERRMES(2,1,'D GEOM card to define diffraction geometry')
      GO TO 100
      ENDIF
C
      GO TO (1,2,1,40,1,6,6,6,40,40,6) , IGEOM
C
   40 CALL ERRMES(1,0,
     & 'SETDC only for normal beam, equi-inclination, 4 circle and D3')
C
C NORMAL BEAM EQUATORIAL:
   2  IF (IDREAD(7) .LE. 0) GO TO 16
      IF (IDREAD(8) .LE. 0) THEN
      CALL ERRMES(2,1,'D CHIA card for type 2 geometry')
      GO TO 100
      ENDIF
C
      IF (ABS(SCALPR(UM(1),UM(4))) .LT. 1.E-5) GO TO 15
      WRITE (LPT,3006) (UM(I),I=1,3),(UM(I),I=4,6)
      WRITE (ITO,3006) (UM(I),I=1,3),(UM(I),I=4,6)
3006  FORMAT (/' ERROR ** in SETDC - scalar product of',3F5.0,
     & ' and',3F5.0,' non-zero')
      IERR=IERR+1
      GO TO 100
C
  15  CALL ORTHO(UM(4),H(1),2)
      CALL UNIVEC (H(1),D)
      CALL VECPRD(H(7),H(1),H(4))
      UM(4) = COS(ANGLIN(1))
      UM(5) = SIN(ANGLIN(1))
      UM(6) = 0.
      CALL GMPRD(H(1),UM(4),UM(1),3,3,1)
      GO TO 100
C
C     NORMAL BEAM AND EQUI-INCLINATION GEOMETRIES:
   1  IF (IDREAD(7) .GT. 0) GO TO 18
  16  CALL ERRIN2(IGEOM,1,'Type','geometry needs D ROTA card')
      GO TO 100
C
  18  DO 3 I = 1,3
   3  UM(I) = H(6+I)
      GO TO 100
C
C 4 CIRCLE BISECTING & D3 GEOMETRIES:
C4.12 Neither CCSL or BL UB matrix read
    6 IF (DNEEDS(5) .AND. DNEEDS(10)) THEN
        CALL ERRMES(2,1,
     &  'D UMAT or UMBL cards to define crystal orientation')
        GO TO 100
      ENDIF
      CALL GMEQ(UM,H,9,1)
      CALL TRANSQ(H,3)
C4.2 Check for twinning here
      IF (ICDN(18,1).GT.0) THEN
        IF (INREA(18,1).GT.0 ) CALL DOTWN1(0)
C 4.9 Don't need to convert the UBmatrix if TMUNIT
        if (TMUNIT) go to 5
        CALL DOTWN1(2)
        CALL GMPRD(H,TORTH(1,1,1),UM,3,3,3)
        go to 7
      endif
   5  DO 4 I=1,7,3
   4  CALL ORTHO(H(I),UM(I),1)
   7  CALL TRANSQ(UM,3)
      CALL TRINV3(UM,D)
      WRITE (LPT,2000) D
2000  FORMAT (/' Determinant of UB matrix is ',F12.6)
      IF (ABS(D-1.) .GE. 10.E-2) CALL ERRMES(1,0,
     & 'cell dimensions and UB matrix not compatible')
   11 IF (ABS(D-1.) .LT. 1.E-4) GO TO 12
C      write (lpt,2001) 'Direct',UM
C2001  format (1x,A6,' Matrix is ',/3(12X,3F10.5/))
      CALL GMEQ(UM,H,1,9)
      CALL TRINV3(UM,D)
C      write (lpt,2001) 'TrInv ',UM
      DO 14 I = 1,9
   14 UM(I) = 0.5*(H(I)+UM(I))
      GO TO 11
C
C UB MATRIX NOW OK:
   12 WRITE (LPT,2002) UM
2002  FORMAT (/' Matrix between diffractometer axes and ',
     & 'orthogonal crystallographic measurement axes is:'
     &/3(12X,3F10.5/))
 100  RETURN
C
      END
C
C
C
C
      BLOCK DATA INDGEO
/DREAD/
%      DATA (IDREAD(i),i=1,%DCRD%)/%DCRD% * 0/
%      DATA (DNEEDS(i),i=1,%DCRD%)/%DCRD%* .TRUE./
      END

      C
C
C
C
C LEVEL 12      SUBROUTINE SETFC
      SUBROUTINE SETFC
C
C *** SETFC updated by JCM 17 Feb 88 ***
C
CX
CC 1A
CH Calls all the setting up routines needed for nuclear structure
CH factor calculations.
CD Calls INPUTN, SYMOP, OPSYM(1), RECIP, ATOPOS, SETFOR and SETANI to set data
CD in the COMMON blocks /SYMDA/, /SYMTAB/, /NSYM/, /CELLDA/, /ATNAM/, /POSNS/,
CD /FORNAM/, /FORDA/, possibly /ANSCAT/ and /ANISO/.
C
CI Causes all the crystallographic and structure cards to be read from
CI the copy of the Crystal Data File on unit IO10.
CO If any of the constituent routines sets the error flag IERR in /CARDRC,
CO prints an error message and stops.
C
/CARDRC/
/IOUNIT/
C
      CALL INPUTN(LPT)
      CALL SYMOP
      CALL OPSYM(1)
      CALL RECIP
      CALL ATOPOS
      CALL SETFOR
      CALL SETANI
      IF (IERR .NE. 0) CALL ERRMES(1,0,'s in SETFC')
      RETURN
      END
C
C
C
C
C LEVEL 12      SUBROUTINE SETFCM(MAGSET)
      SUBROUTINE SETFCM(MAGSET)
C
C *** SETFCM by PJB 31-May-1994 ***
C
CX
CC 17A
CH Calls the routines needed to set up magnetic structure factor
CH calculations (or non-magnetic also).
CA On entry MAGSET is the name of a subroutine to do the specific magnetic
CA                setting up.  MAGSET is therefore DOMAG1 if actually a
CA magnetic structure, or DUMMY if non-magnetic.
CD Like SETFC it calls:
CD   INPUTN, SYMOP, OPSYM(1), RECIP, ATOPOS, SETFOR and SETANI to set
CD   data in the COMMON blocks /SYMDA/, /SYMTAB/, /NSYM/, /CELLDA/, /ATNAM/,
CD   /POSNS, /FORNAM/, /FORMDA/, possibly /ANSCAT/ and /ANISO/
CD If MAGSET=DOMAG1, calls DOMAG1(1) to read the magnetic data from "Q"  cards
CD and write the COMMON blocks /MAGDAT/, /SATELL/ and  /SYMMAG/.
CI Causes all the crystallographic and structure cards to be read from
CI the copy of the Crystal Data File on unit IO10.
CO If any of the constituent routines sets the error flag IERR in /CARDRC,
CO prints an error message and stops.
C
      EXTERNAL MAGSET
/CARDRC/
/IOUNIT/
/REFINE/
C
      CALL INPUTN(LPT)
      CALL SYMOP
      CALL OPSYM(1)
      CALL RECIP
      CALL ATOPOS
C TO BE RESET IF MULTIPOLE ROUTINES ARE USED:
      MPL=.FALSE.
C TO BE RESET IF MAGSET ACTUALLY=DOMAG1:
      MAG=.FALSE.
      CALL MAGSET(1)
      CALL SETFOR
      CALL SETANI
      IF (IERR .NE. 0) CALL ERRMES(1,0,'in SETFCM')
      RETURN
      END
C
C
C
C
C LEVEL 11      SUBROUTINE SETFOR
      SUBROUTINE SETFOR
C
C *** SETFOR updated by JCM 24 Nov 91 ***
C
CX
CC 4A
CH Sets up data for scattering or form factor calculations.
CD Reads "F" cards which all start  "F <name> ITYP"
CD Where <name> is a character string of maximum length 4 introduced
CD and terminated by spaces. <name> is the label of the scattering
CD factor and will often be a chemical symbol. The factor applies to
CD all atoms whose name starts with the scattering factor name. In the
CD atom name the character following <name> must be a non-letter.
CD For example - a set of A cards:
CD A Pb1
CD A FreD
CD A Pb2
CD A P4
CD A O14A
CD A O14B
CD would need 4 scattering factors, labelled:
CD F Pb      (applies to Pb1 and Pb2)
CD F P       (applies to P4)
CD F O       (applies to O14A and O14B)
CD F FreD    (applies to FreD)
CD
CD ITYP is an integer indicating the way in which the form-factor will be
CD           given
CD ITYP = 0  means "this is a multiplicative factor".  It is useful
CD           when the user wants to scale his structure factors up or down,
CD           without altering his other "F" cards.
CD For ITYP positive, at present 4 values are defined:
CD ITYP = 1  Neutron nuclear scattering.  In this case the scattering
CD           length is given on the same card after ITYP
CD ITYP = 2  Form factors given by series expansion of exponential terms,
CD           of the form:    sum[a(n)*exp{-a(n+1)*s*s}] + c
CD                           with  n=1,2,3 or 4  and  s=sin(theta)/lambda
CD           the coefficients a(n) and c are given on one, or possibly two
CD           "F" cards.  The cards each start "F <name> ITYP" and the 5, 7
CD           or 9 coefficients follow ITYP in flexible FORMAT. If it is
CD           necessary to use two cards they should be consecutive.
CD ITYP = 3  Form factors given tabulated against s=sin(theta)/lambda.
CD           the tabulated values, pairs of s and f in ascending s, follow.
CD           If multiple cards are needed each should start "F <name> 3" and
CD           they must be consecutive.
CD ITYP = 4  As 2, but the result is multiplied by sin(theta)/lambda squared
CD           This is the form of expansion used for the <jl> form factors
CD           with l not zero.
CD ITYP = 5  Obtain form factor from radial functions supplied on
CD           W RADF cards.
CD ITYP negative indicates an anomalous scattering factor.
CD       At present only type -1 is defined, which is the straightforward
CD       complex anomalous scattering factor.  Two numbers follow the -1
CD       on the "F" card; they are f' and f" the real and imaginary parts
CD       of the complex multiplicative factor to be applied to this atom
CD       (in addition to any other scattering factor).
C
CI Reads "F" cards from the copy of the Crystal Data File on unit IO10.
CO Writes its findings to unit LPT.
CN If "slack constraints only" is set, allows "no F cards".
C
      CHARACTER *4 LABF,LSAV
      LOGICAL ANOM
/ANSCAT/
/ATNAM/
/CARDRC/
/FONAM/
/FORGRP/
/FORMDA/
/IOUNIT/
/POSNS/
/SCRACH/
/SLKGEO/
C
C ATOPOS MUST BE OBEYED TO SET UP REQUIRED SCATTERING FACTOR NAMES IN THE TABLE
C FONAME
      IF (INREAD(1) .GT. 0) CALL ATOPOS
C
C SET "F" CARDS READ:
      INREAD(6)=-IABS(INREAD(6))
C
C CLEAR SCALE FACTORS, POINTERS FOR BOTH SORTS OF SCATTERING FACTORS
C AND COUNTS OF NUMBERS OF TERMS (IN CASE TYPES 2 OR 3):
%      DO 1 I=1,%FORM%
      CMULT(I)=1.0
      NT(I)=0
      MODE(I)=0
   1  NAMODE(I) = 0
C
C CLEAR FACTORS-ATOMS TABLES:
%      DO 50 I=1,%FORM%
      NAFPNT(I)=0
%      DO 50 J=1,%ATOM%
  50  NATFOR(I,J)=0
C
C SET "NO ANOMALOUS SCATTERING AT ALL" AND KEEP NUMBER OF FACTORS TO FIND:
      ANOM=.FALSE.
      NFKEEP=NUMFNM
C
C ID WORKS THROUGH "F" CARDS SEQUENTIALLY:
      NFREAD=0
      ID=IABS(INREAD(6))
C
C NCARD = NUMBER OF "F" CARDS ON CRYSTAL DATA FILE:
      NCARD=ICDNO(6)
      IF (NCARD .EQ. 0) THEN
        IF (.NOT. SLONLY) CALL ERRMES(1,1,'No cards labelled F read')
        GO TO 100
      ENDIF
C
   2  CALL INPUTF(ID,LABF,LBFLEN,NTYP,IPT,IER)
      NFREAD=NFREAD+1
      ID=ID+NYZ
   5  IF (IER .NE. 0) IERR=IERR+1
      IPKEEP=IPT
C INPUTF READS THE LABEL, THE TYPE AND THE WHOLE CARD TO ICARD AS A1, AND
C LEAVES IPT POINTING TO WHERE TO CONTINUE READING.
C
C FIND LABEL IN TABLE MADE UP BY ATOPOS - IF THE NEW LABEL IS NOT THERE, IT
C DOES NOT APPLY TO ANY GIVEN POSITIONS.  IF A NEW LABEL IS ADDED, AND OVER-
C FILLS THE TABLE (INDICATING TOO MANY FACTORS FOR THE SPACE ALLOWED IN
C COMMON /FORMDA/), LMATCH WILL COMPLAIN:
      LKEEP=NUMFNM
%      LFAC=LMATCH(LABF,FONAME,NUMFNM,%FORM%)
      IF (LKEEP .NE. NUMFNM) THEN
        CALL MESS(LPT,1,'WARNING ** no atom card asks for factor '//
     & 'labelled '//LABF)
      ENDIF
C
C NTYP IS -VE FOR ANOMALOUS, 0 FOR A SCALE AND +VE FOR A SCATTERING FACTOR:
      IF (NTYP) 11,12,13
C
C ANOMALOUS SCATTERING:
  11  ANOM = .TRUE.
      IF (NAMODE(LFAC) .NE. 0) THEN
        CALL ERRCH2(LABF,2,
     &   'reading 2nd anomalous scattering factor for',' ')
        GO TO 6
      ENDIF
C
      NAMODE(LFAC)=IABS(NTYP)
      IF (NAMODE(LFAC) .EQ. 1) GO TO 3
      WRITE (LPT,3003) NTYP,LABF
      WRITE (ITO,3003) NTYP,LABF
3003  FORMAT (/' ERROR ** type',I4,' anomalous scattering ',
     & 'factor not recognised for factor labelled ',A4)
      IERR=IERR+1
      GO TO 6
C
C RECORD MODE IN NAMODE, AND FOR NOW EXPECT ONLY 1 - THEN READ FDASH AND FDDASH
   3  I=NAMODE(LFAC)
      CALL RDREAL(XX,IPT,IPT,80,IER)
      IF (IER .NE. 0) THEN
        CALL ERRIN2(IPKEEP,2,'in number on "F" card at point',' ')
        GO TO 6
      ENDIF
C
      IPKEEP=IPT
      CALL RDREAL(Y,IPT,IPT,80,IER)
      IF (IER .NE. 0) THEN
        CALL ERRIN2(IPKEEP,2,'in number on "F" card at point',' ')
      ELSE
        FDASH(LFAC)=CMPLX(XX,Y)
      ENDIF
      GO TO 6
C
C SIMPLE SCALE FACTOR:
  12  CALL RDREAL(XX,IPT,IPT,80,IER)
      IF (IER .NE. 0) THEN
        CALL ERRIN2(IPKEEP,2,'in number on "F" card at point',' ')
        GO TO 6
      ENDIF
C
      CMULT(LFAC)=CMULT(LFAC)*XX
      GO TO 6
C
C SCATTERING FACTOR:
  13  IF (NTYP .LE. 5) GO TO 7
      WRITE(LPT,3002) NTYP,LABF
      WRITE(ITO,3002) NTYP,LABF
3002  FORMAT (/' ERROR ** type',I4,' scattering factor not',
     & ' recognised for factor labelled ',A4)
      IERR=IERR+1
      GO TO 6
C
   7  IF (MODE(LFAC) .EQ. 0) GO TO 20
      CALL ERRCH2(LABF,2,'reading second scattering factor for',
     & ' ')
      GO TO 6
C
  20  MODE(LFAC)=NTYP
      GO TO (21,22,23,22,6) , NTYP
C
C TYPE 1 - NEUTRON NUCLEAR SCATTERING - READ IN 1 MORE NUMBER:
  21  CALL RDREAL(XX,IPT,IPT,80,IER)
      IF (IER .NE. 0) THEN
        CALL ERRIN2(IPKEEP,2,'in number on "F" card at point',' ')
        GO TO 6
      ENDIF
C
      CMULT(LFAC)=CMULT(LFAC)*XX
      GO TO 6
C
C HERE ON TYPE 2 - EXPONENTIAL APPROXIMATION:
  22  IF (NT(LFAC) .LT. 9) GO TO 9
  15  CALL ERRCH2(LABF,2,
     & '>9 coefficients for exponential approx for factor',' ')
      GO TO 6
C
C READ HOWEVER MANY NUMBERS THERE ARE ON THE CARD:
   9  IPKEEP=IPT
      CALL RDREAL(XX,IPT,IPT,80,IER)
C IF IER IS RETURNED AS 100 WE HAVE READ ALL SPACES:
      IF (IER .EQ. 100) GO TO 10
      IF (IER .NE. 0) THEN
        CALL ERRIN2(IPKEEP,2,
     &   'cannot read number from "F" card at point',' ')
        GO TO 6
      ENDIF
C
      NT(LFAC)=NT(LFAC)+1
      IF (NT(LFAC) .GT. 9) GO TO 15
      F(NT(LFAC),LFAC)=XX
      IF (IPT .LT. 80) GO TO 9
C
C END OF NUMBERS ON CARD - CHECK THERE ARE MORE CARDS:
  10  IF (NFREAD .GE. NCARD) GO TO 16
      LSAV=LABF
      CALL INPUTF(ID,LABF,LBFLEN,NTYP,IPT,IER)
      NFREAD=NFREAD+1
      ID=ID+NYZ
      IF (NTYP .NE. 2) GO TO 5
      IF (LSAV .NE. LABF) GO TO 5
C
C WE HAVE ANOTHER CARD FOR THE SAME FACTOR:
      GO TO 9
C
C HERE ON TYPE 3 - READ POSSIBLY SEVERAL MORE F CARDS
%  23  IF (NT(LFAC) .LT. %FTAB%) GO TO 8
%  35  CALL ERRCH2(LABF,1,'more than %FTAB% entries in table for factor',
     & ' ')
      GO TO 6
C
C READ HOWEVER MANY NUMBERS THERE ARE ON THE CARD:
   8  IPKEEP=IPT
      CALL RDREAL(XX,IPT,IPT,80,IER)
C IF IER IS RETURNED AS 100 WE HAVE READ ALL SPACES:
      IF (IER .EQ. 100) GO TO 30
      IF (IER .NE. 0) THEN
        CALL ERRIN2(IPKEEP,2,
     &   'cannot read number from "F" card at point',' ')
        GO TO 6
      ENDIF
C
      IF (NT(LFAC) .EQ. 0) LL=1
      LL=-LL
      IF (LL .GT. 0) GO TO 33
      NT(LFAC)=NT(LFAC)+1
%      IF (NT(LFAC) .GT. %FTAB%) GO TO 35
      S(NT(LFAC),LFAC)=XX
      F(NT(LFAC),LFAC)=9999.
      IF (NT(LFAC) .EQ. 1) GO TO 36
      IF (S(NT(LFAC),LFAC) .GT. S(NT(LFAC)-1,LFAC)) GO TO 36
      WRITE (LPT,3011) NT(LFAC),S(NT(LFAC),LFAC),S(NT(LFAC)-1,
     & LFAC),LABF
      WRITE (ITO,3011) NT(LFAC),S(NT(LFAC),LFAC),S(NT(LFAC)-1,
     & LFAC),LABF
3011  FORMAT (/' ERROR ** TERM',I5,' OF TABLE IS',F10.4,
     & ' AND IS LESS THAN THE PREVIOUS TERM',F10.4,' FOR FACTOR ',A4)
      GO TO 6
  33  F(NT(LFAC),LFAC)=XX
  36  IF (IPT .LT. 80) GO TO 8
C
C END OF NUMBERS ON CARD - CHECK THERE ARE MORE:
  30  IF (NFREAD .GE. NCARD) GO TO 16
      LSAV=LABF
      CALL INPUTF(ID,LABF,LBFLEN,NTYP,IPT,IER)
      NFREAD=NFREAD+1
      ID=ID+NYZ
      IF (NTYP .NE. 3) GO TO 5
      IF (LSAV .NE. LABF) GO TO 5
C
C WE HAVE ANOTHER CARD FOR THE SAME FACTOR:
      GO TO 8
C
C HERE WHEN CARD HAS BEEN DEALT WITH - ARE THERE MORE?
   6  IF (NFREAD .LT. NCARD) GO TO 2
C
C NOW WRITE OUT ALL INFORMATION ASSIMILATED:
  16  CALL MESS(LPT,1,'Scattering factors read for given atomic '//
     & 'positions:')
      CALL MESS(LPT,0,'Name  Type          Description')
C
C SCAN ALL FACTORS AS DECODED BY ATOPOS:
      DO 41 LFAC=1,NFKEEP
      IF (MODE(LFAC) .LE. 0) THEN
        CALL ERRCH2(FONAME(LFAC),1,'factor','needed but not read')
        GO TO 41
      ENDIF
C
      M=MODE(LFAC)
      GO TO (43,44,45,46,47) , M
C
  43  WRITE (LPT,2001) FONAME(LFAC),M,CMULT(LFAC)
2001  FORMAT (/1X,A4,I5,'  Neutron nuclear scattering factor value',
     & F10.4)
      GO TO 40
C
  44  N1=NT(LFAC)
      WRITE (LPT,2002) FONAME(LFAC),M,N1,CMULT(LFAC),(F(I,LFAC),
     & I=1,N1)
2002  FORMAT (/1X,A4,I5,' Series expansion form factor with',I4,
     & ' terms multiplied by',F10.4/11X,'Coefficients are:'/11X,9F10.4)
      GO TO 40
C
  45  N1=NT(LFAC)
      WRITE (LPT,2003)FONAME(LFAC),M,N1,CMULT(LFAC),(S(I,LFAC),
     & F(I,LFAC),I=1,N1)
2003  FORMAT (/1X,A4,I5,'  Form factors given in table with',I5,
     & ' entries multiplied by',F10.4/11X,'Table is:'/
     & (1X,5(F10.2,F10.4)))
      IF (F(NT(LFAC),LFAC) .NE. 9999.) GO TO 40
      CALL MESS(LPT,1,'WARNING ** an odd number of numbers was read'//
     & ' as the table of S and F')
      CALL MESS(ITO,1,'WARNING ** an odd number of numbers was read'//
     & ' as the table of S and F')
      GO TO 40
C
  46  N1=NT(LFAC)
      WRITE (LPT,2002) FONAME(LFAC),M,N1,CMULT(LFAC),(F(I,LFAC),
     & I=1,N1)
      CALL MESS(LPT,0,
     & '          Factor is finally multiplied by s squared')
      GO TO 40
C
  47  WRITE (LPT,2030) FONAME(LFAC),M
2030  FORMAT (/1X,A4,I5,'  Form factor to be calculated from radial',
     & ' wave functions given on W RADF cards')
      GO TO 40
C
C WRITE ANOMALOUS SCATTERING FACTOR IF PRESENT:
  40  IF (NAMODE(LFAC).NE.0) WRITE (LPT,2004) FONAME(LFAC),FDASH(LFAC)
2004  FORMAT (' ',A4,' also has anomalous scattering factor - coeff',
     & 'icients:',2F10.4)
C
C FORM LIST OF ATOM LABELS TO WHICH THIS FACTOR APPLIES:
      IPT=0
      ICARD=' '
      DO 48 I=1,NATOM
      IF (NFORMF(I) .NE. LFAC) GO TO 48
C ALSO, FILL IN TABLES FOR GROUPS OF ATOMS:
      NAFPNT(LFAC)=NAFPNT(LFAC)+1
      NATFOR(LFAC,NAFPNT(LFAC))=I
C
C PUT ATOM NAME INTO BUFFER IF IT WILL FIT:
      IF (IPT .GT. 54) THEN
        WRITE (LPT,2005) (ICARD(IJ:IJ),IJ=1,LENGT(ICARD))
2005    FORMAT (12X,'applies to ',80A1)
        ICARD=' '
        IPT=0
      ENDIF
C
      LEN=LENGT(ATNAME(I))
      ICARD(IPT+1:IPT+LEN)=ATNAME(I)(1:LEN)
      IPT=IPT+LEN+1
  48  CONTINUE
      IF (IPT.NE.0) WRITE (LPT,2005) (ICARD(IJ:IJ),IJ=1,LENGT(ICARD))
C
  41  CONTINUE
 100  RETURN
C
      END
C
C
C
C
C LEVEL 11      SUBROUTINE SETFOU(MNEED)
      SUBROUTINE SETFOU(MNEED)
C
C *** SETFOU updated by PJB April 2006 C142  ***
C
CX
CC 5A
CH Sets up data for Fourier map calculations.
CD Reads in:  one "N" card with the title
CD            several "M" cards with map information (including that
CD            for contour plotting if required by user)
CD Sets up:   COMMON ready for calls of FORIER, which will then organise
CD            the actual calculation of (possibly several) maps, and their
CD            plotting, printing and saving as requested.
CD
CD Sets defaults of: 3 dimensions if no M NDIM card is given
CD            no resolution if no M DELT card is given
CD            a scale for Fourier coefficients of 1. if no M SCAL card is given
CD            a map scale of 2.5 cm/Angstrom if no M CM/A card is given.
CD Checks that M cards have been read for DTYP, SMAX, FTYP, MESH.
CI Causes "N" and "M" cards to be read from the copy of the Crystal
CI Data File on unit IO10.
CO Writes its findings to unit LPT.
CI42 MNEED is the mask of Mcards needed to allow multiple use of INPUTM
C14G Call to STPLT moved outside (into main FOURPL)
C
      EXTERNAL GFDEFS
      LOGICAL TESTOV,NOTOK
%      DIMENSION KLIM(3),UT(3,3),NPOINT(100),MNEED(%MCRD%)
      CHARACTER *6 FILLED
/ATNAM/
/CARDRC/
/CELPAR/
/CONTUR/
/FRIED/
/GFNUMS/
/GFWRDS/
/IOUNIT/
/MAPDA/
/MAPGT/
/MAPLAB/
/MAPPR/
/MAPRD/
/MAPSV/
/MREAD/
/PLOMAP/
/XENDA/
C
C Set no error
        IERR=0
C RECIP MUST BE OBEYED FIRST (AND THEREFORE SYMOP ALSO)
      IF (INREAD(3) .GT. 0) CALL RECIP
C
C COMMENT THAT FRIED CANNOT BE USED (IF FALSE) HERE:
      IF (.NOT. FRIEDL) CALL MESS(LPT,1,
     & 'Friedel''s law being assumed for Fourier')
C
C READ, STORE AND PRINT TITLE FROM AN "N" CARD:
      CALL INPUTN(LPT)
C
C If M LABL cards present call atopos
      CALL FINDCD('M','LABL',4,0,LCD)
      IF (LCD .GT.0) CALL ATOPOS
C NOW READ ALL "M" CARDS:
%      CALL JGMEQ(MNEED,IMREAD,%MCRD%,1)
      CALL INPUTM
C
C NOW CHECK ALL INFO GIVEN, AND WRITE OUT FOR THOSE CARDS NOT GIVEN
      IF (IMREAD(11) .EQ. 0) CALL ERRMES(2,1,
     & 'M DTYP card giving data input type')
C
      IF (IMREAD(12) .EQ. 0) THEN
        CALL MESS(LPT,1,'No resolution function')
        DELTA=0.
      ENDIF
C
      IF (IMREAD(15) .EQ. 0) CALL ERRMES(2,1,
     & 'sin theta/lambda maximum')
C
      IF (IMREAD(13) .EQ. 0) SCALF1=1.0
C
C Default NDIM now Later      IF (IMREAD(1) .NE. 0) THEN
C        NDIM=3
C        CALL MESS(LPT,1,'No M NDIM card - assuming 3D')
C      ENDIF
C
      IF (IMREAD(2) .EQ. 0) CALL ERRMES(2,1,
     & 'M FTYP card giving type of Fourier required')
C
      IF (IMREAD(3) .EQ. 0) CALL ERRMES(2,1,
     & 'M MESH card giving mesh for output')
C
      IF ((IMREAD(6) .GT. 0) .AND. (IMREAD(7) .EQ. 0)) THEN
        SCALMP=2.5
       CALL MESS(LPT,1,
     & 'Default scale of 2.5 cm/Angstrom for plotted map')
      ENDIF
C
C
C SET UP SCALE ACCORDING TO NUMBER OF DIMENSIONS:
      IF (IMREAD(4) .EQ. 0) THEN
        CALL GMUNI(U,3,3)
        MODET=0
      ENDIF
      IF (MODET.EQ.1) THEN
        M=1
      ELSE
        M=0
      ENDIF
      CALL USYM(M)
C
C WE ARE NOW DOWN TO DECIDING WHERE THE MAP IS TO COME FROM, AND WHAT IS
C TO BE DONE WITH IT ONCE WE HAVE IT.
C
C SAVE, GET, READ, PRIN AND PLOT CARDS HAVE ALL BEEN INTERPRETED IN INPUTM.
C HERE WE NEED ONLY MAKE SURE WE HAVE SOMETHING SENSIBLE TO DO.
C
C FIRST SORT ALL LISTS INTO ASCENDING ORDER:
      IF (NCONT .GT. 0) THEN
        CALL SORTX(CONT,NPOINT,NCONT)
        CALL RESHUF(CONT,NPOINT,NCONT)
      ENDIF
      IF (IZPR .GT. 0) THEN
        CALL SORTX(ZPRVAL,NPOINT,IZPR)
        CALL RESHUF(ZPRVAL,NPOINT,IZPR)
      ENDIF
      IF (IZPL .GT. 0) THEN
        CALL SORTX(ZPLVAL,NPOINT,IZPL)
        CALL RESHUF(ZPLVAL,NPOINT,IZPL)
      ENDIF
      IF (IZSV .GT. 0) THEN
        CALL SORTX(ZSVVAL,NPOINT,IZSV)
        CALL RESHUF(ZSVVAL,NPOINT,IZSV)
      ENDIF
      IF (IZRD .GT. 0) THEN
        CALL SORTX(ZRDVAL,NPOINT,IZRD)
        CALL RESHUF(ZRDVAL,NPOINT,IZRD)
      ENDIF
      IF (IZGT .GT. 0) THEN
        CALL SORTX(ZGTVAL,NPOINT,IZGT)
        CALL RESHUF(ZGTVAL,NPOINT,IZGT)
      ENDIF
C
      IF ((IMREAD(5) .EQ. 0).AND.(IMREAD(6) .EQ. 0).AND.(IMREAD
     & (9) .EQ. 0)) CALL ERRMES(1,1,
     & 'no M PRIN, M PLOT or M SAVE cards')
C
      SCALF2=V(2)
      IF (NDIM .EQ. 2) SCALF2=SCALF2*VCTMOD(1.,U(1,3),1)
C
      if (IMREAD(4) .gE.0) then
C AXES present: We are making some kind of map
        CALL GMUNI(UT,3,3)
        IF (MODET .EQ.1) CALL GMEQ(U,UT,3,3)
C CALCULATE AND CHECK MAXIMUM VALUES OF INDICES, LIMITS ETC:
        DO 1 I=1,2
        KLIM(I)=IFIX(VCTMOD(2.*SMAX,UT(1,I),1))
        IF (TESTOV(1.,OUTLIM(3,I))) THEN
          CALL ERRIN2(I,1,'zero step length for map in direction'
     &    ,' ')
          GO TO 1
        ENDIF
C
        IF (OUTLIM(3,I) .LE. 0.) THEN
          WRITE (LPT,3001) OUTLIM(3,I),I
          WRITE (ITO,3001) OUTLIM(3,I),I
3001      FORMAT (' ERROR ** Negative step in map',F10.4,
     & ' in direction',I2)
          IERR=IERR+1
          GO TO 1
        ENDIF
C
        NN=JFIX((OUTLIM(2,I)-OUTLIM(1,I)+10.E-5)/OUTLIM(3,I)) +1
        IF (I .EQ. 1) NX=NN
        IF (I .EQ. 2) NY=NN
        IF (NN .GT. 0) GO TO 1
        WRITE (LPT,3002) NN,I
        WRITE (ITO,3002) NN,I
3002    FORMAT (' ERROR ** Negative number',I3,' of points ',
     & 'required for map in direction',I2)
        IERR=IERR+1
   1    CONTINUE
C
C CHECK STORAGE LIMITS:
        if (IMREAD(4) .gE.0) then
          NH=2*KLIM(1)+1
          NK=KLIM(2)+1
          NHK=2*NH*NK
          IF (NHK .GT. 10201) THEN
            WRITE (LPT,3010) KLIM(1),KLIM(2),NHK
            WRITE (ITO,3010) KLIM(1),KLIM(2),NHK
3010        FORMAT (/' ERROR ** Too much data for Fourier store'/
     & ' h max=',I4,' k max=',I4, 'needing space',I7,' - only 10201',
     & ' available')
            STOP
          ENDIF
        ENDIF
C
        NXY=NX*NY
        IF (NXY .GT. 10201) THEN
          WRITE (LPT,3011) NX,NY,NXY
          WRITE (ITO,3011) NX,NY,NXY
3011    FORMAT (/' ERROR ** Too much data for Fourier store'/
     & ' No. of points in x direction =',I5/
     & ' no. of points in y direction =',I5/
     & ' requiring store',i7,' - only 10201 available')
          STOP
        endif
        IF (MODET.EQ.2) THEN
C  REDEFINE NH,NK,NHK TO BE MAX VALUES OF INDICES FOR GENERAL PLANE FOURIER
          NHK=IFIX(VCTMOD(2.*SMAX,UT(1,3),1))
          NH=KLIM(1)
        ELSE
          NKX=2*NK*NX
          IF (NKX .GT. 10201) THEN
            WRITE (LPT,3012) KLIM(1),NX,NKX
            WRITE (ITO,3012) KLIM(1),NX,NKX
3012      FORMAT (/' Error ** too much data for Fourier store'/
     &    ' k max =',I4,' no. of points in x direction =',I5/
     &    ' requiring store',i7,' - only 10201 available')
            STOP
          endif
C
          CALL ERRCHK(1,KLIM(1)+1,100,0,'h values in Fourier')
          CALL ERRCHK(1,NK,100,0,'k values in Fourier')
        ENDIF
      ENDIF
C
C Report atom labels
      IF (IMREAD(18) .EQ.0) THEN
        WRITE (LPT,3020)
 3020   FORMAT (/'No atom labels on the map')
      ELSE
      write (lpt,5010)NGFSYM,(i,GFsyms(i),i=1,11)
 5010 format (i3,2x,12(i4,1x,a6,2x))
         WRITE (LPT,3021)
 3021   FORMAT (/'Atom labels on the map are:')
        DO 2 N=1,NLABS
          IF (FILL(N)) THEN
            FILLED='Filled'
             LC=LSYMB(N)
          ELSE
            FILLED='Open  '
          ENDIF
3022       FORMAT (A4,1X,A7,2(1x,a6),1x,f6.2)
             WRITE (LPT,3022) ATNAME(LABAT(N)),GFCOLS(MCOLOR(N)),
     &      gfsyms(LSYMB(N)),FILLED,sysize(N)
   2    CONTINUE
      ENDIF
C
C M AXME
      IF (IMREAD(17).EQ.0) THEN
        CALL MESS(LPT,1,'No M AXME card given axes for ME calculation'//
     &'assumed parallel to crystallographic xyz')
        CALL GMUNI(UU,3,3)
      ENDIF
      IF (IMREAD(17) .GE.0) THEN
        WRITE (LPT,1001) 'Axes for Maxent calculation',
     &  ((UU(I,J,1),I=1,3),J=1,3)
 1001 FORMAT (A27,3F8.3,2(/27X,3F8.3))
        CALL GMINV(UU,UU(1,1,2),3)
      ENDIF
C
C M MAXE
C Indicate maxent options to be given interactively
      if (imread(19).eq.0) MSTOP=-999
C
C M GRID
      IF (IMREAD(16) .EQ. 0) CALL ERRMES(2,1,
     & 'M GRID  card giving grid for maxent calculation')
      if (IMREAD(16) .GE. 0) then
        nd=ndimen
        if (NDIMEN .eq.9) then
          NOTOK=(NDIM .EQ. 2)
          NDIMEN=3
        else if (NDIMEN .eq.6) then
          NOTOK = (NDIM .EQ.  3)
          NDIMEN=2
        else
          call errin2(NDIMEN,1,'Wrong number of entries (',
     &  ') on M GRID card, should be 6 or 9')
        endif
        if (NOTOK) then
          call errmes(1,1,
     &  'Data on M NDIM and M GRID cards are incompatible')
        else
          if (IMREAD(1) .EQ. 0)  NDIM=NDIMEN
        ENDIF
        CALL TRANSQ(XLIM,3)
      ELSE
        if (IMREAD(1) .EQ. 0) THEN
          NDIM=3
          CALL MESS(LPT,1,'No M NDIM card - assuming 3D')
        endif
      ENDIF
      IF (IERR .NE. 0) CALL ERRMES(1,0,'during SETFOU')
C
      RETURN
      END
C
C
C
C
C LEVEL 5      SUBROUTINE SETGAU
      SUBROUTINE SETGAU
C
C *** SETGAU BY JCM ***
C
CX
CC 2A
CH Sets up the COMMON /GAUSS/ for Gaussian integration (for use in
CH absorption correction type integrals).
CP NL,NM,NN in /GAUSS/ should be the required number of Gauss points
CP        to scan the given crystal in the 3 directions x,y,z.
CP INPUTG should have read all the "G" cards.
C
CD Sets up a 3D mesh of Gauss points and weights covering the given
CD crystal whose faces are described in /CPLANE/.  In /GAUSS/
CD the arrays XX, YY, ZZ hold the x,y and z coordinates of the points
CD referred to the standard crystallographic axes, and the array WW
CD holds the weights.
CO Writes the crystal volume so found to unit LPT.
C
CN SETGAU may be called several times in one job, to enable comparison
CN between integrations using different numbers of points.
C
      LOGICAL TESTOV
/CPLANE/
/GAUSS/
/CARDRC/
/IOUNIT/
      COMMON /SCRAT/GPT(150),GWT(150)
C
C
      IF (INREAD(7) .GT. 0) CALL INPUTG
      NQ = NL*NM*NN
%      CALL ERRCHK(1,NQ,%GPTS%,0,'Gauss points, product of all 3')
      U = 0.
      V = 0.
      DO 11 IR = 1,NP
      DO 11 IS = 1,NP
      D = BB(IR)*CC(IS) - CC(IR)*BB(IS)
      DO 11 IT = 1,NP
      E = BB(IS)*CC(IT) - CC(IS)*BB(IT)
      F = BB(IT)*CC(IR) - CC(IT)*BB(IR)
      A = DD(IR)*E + DD(IS)*F + DD(IT)*D
      B = AA(IR)*E + AA(IS)*F + AA(IT)*D
      IF (TESTOV(A,B)) GO TO 11
      X = A/B
      A = (DD(IS) - AA(IS)*X)*CC(IT) - (DD(IT) - AA(IT)*X)*CC(IS)
      IF (TESTOV(A,E)) GO TO 11
      Y = A/E
      A = DD(IT) - AA(IT)*X -BB(IT)*Y
      IF (TESTOV(A,CC(IT))) GO TO 11
      Z = A/CC(IT)
      DO 12 I = 1,NP
      IF (AA(I)*X + BB(I)*Y + CC(I)*Z - DD(I) .GT. 0.0001) GO TO 11
  12  CONTINUE
      IF (U .LT. X) U=X
      IF (X .LT. V) V=X
  11  CONTINUE
      U = U-V
      IO = 1
C
C SET UP ENTIRE RANGES OF GAUSS POINTS AND WEIGHTS IN /SCRAT/:
      ITEM1=1
      ITEM2=NL
      CALL GAUSPT(NL,GPT(ITEM1),GWT(ITEM1))
      DO 16 IR=ITEM1,ITEM2
      X = V + U*GPT(IR)
      E = 6000.
      D = -6000.
      DO 17 IS = 1,NP
      DO 17 IT = 1,NP
      A = (DD(IS) - AA(IS)*X)*CC(IT) - (DD(IT) - AA(IT)*X)*CC(IS)
      B = BB(IS)*CC(IT) - CC(IS)*BB(IT)
      IF (TESTOV(A,B)) GO TO 17
      Y = A/B
      A = DD(IT) - AA(IT)*X - BB(IT)*Y
      IF (TESTOV(A,CC(IT))) GO TO 17
      Z = A/CC(IT)
      DO 18 IQ = 1,NP
      IF (AA(IQ)*X + BB(IQ)*Y + CC(IQ)*Z - DD(IQ) .GT. 0.0001) GO TO 17
  18  CONTINUE
      IF (D .LT. Y) D=Y
      IF (Y .LT. E) E=Y
  17  CONTINUE
      D = D-E
C
C SET UP GAUSS POINTS AND WEIGHTS FOR SECOND INTEGRATION DIRECTION (UNLESS SAME
C AS FIRST):
      ITEM3=ITEM1
      ITEM4=ITEM2
      IF (NM .EQ. NL) GO TO 1
      ITEM3=ITEM2+1
      ITEM4=ITEM3+NM-1
      CALL GAUSPT(NM,GPT(ITEM3),GWT(ITEM3))
   1  DO 16 IS = ITEM3,ITEM4
      Y = E + D*GPT(IS)
      G = 6000.
      F = -6000.
      DO 23 IT = 1,NP
      A = DD(IT) - AA(IT)*X - BB(IT)*Y
      IF (TESTOV(A,CC(IT))) GO TO 23
      Z=A/CC(IT)
      DO 24 IQ = 1,NP
      IF (AA(IQ)*X + BB(IQ)*Y + CC(IQ)*Z - DD(IQ) .GE. 0.0001) GO TO 23
  24  CONTINUE
      IF (F .LT. Z) F=Z
      IF (Z .LT. G) G=Z
  23  CONTINUE
      F = F-G
      ITEM5=ITEM1
      ITEM6=ITEM2
      IF (NN .EQ. NL) GO TO 2
      ITEM5=ITEM3
      ITEM6=ITEM4
      IF (NN .EQ. NM) GO TO 2
      ITEM5=ITEM4+1
      ITEM6=ITEM5+NN-1
      CALL GAUSPT(NN,GPT(ITEM5),GWT(ITEM5))
   2  DO 16 IT = ITEM5,ITEM6
      Z = G + F*GPT(IT)
      XX(IO) = X
      YY(IO) = Y
      ZZ(IO) = Z
      WW(IO) = D*F*GWT(IR)*GWT(IS)*GWT(IT)
      IO = IO + 1
  16  CONTINUE
      V = 0.
      DO 22 IQ = 1,NQ
      V = V + WW(IQ)
  22  CONTINUE
      IF (TESTOV(1.,V)) CALL ERRMES(1,0,
     & '- is origin strictly inside crystal?')
C
      VSTAR = 1/V
      DO 29 IQ = 1,NQ
      WW(IQ) = VSTAR*WW(IQ)
  29  CONTINUE
      V=V*U
      WRITE (LPT,2000) V
2000  FORMAT (/' Crystal volume ',F12.5)
      RETURN
      END
C
C
C
C
C LEVEL 6      SUBROUTINE SETGEN(S)
      SUBROUTINE SETGEN(S)
C
C *** SETGEN corrected by JBF 15 Aug 94 ***
C
CX
CC 3A
CH Sets up the generation of a complete set of reflection indices.
CA On entry S is the maximum value of Sin(theta)/lambda required.
CP SYMUNI to define the asymmetric unit
CD Uses the defined asymmetric unit and given S to set up COMMON /HKLGEN/
CD ready for repeated entries to GETGEN.  GETGEN will generate all hkl's in
CD the given asymmetric unit with sin(theta)/lambda < S.
C
CD S is put into COMMON /BRAGG/ here.
C
      DIMENSION TEMP(3)
      LOGICAL ONCARD,BINDIG
/BRAGG/
/FUNIT/
/HKLGEN/
/IOUNIT/
C
      STHLMX=S
      IF (S .NE. 0.) GO TO 5
C IF S ZERO, TRY TO FIND "SMAX" ON AN I CARD:
      IF (.NOT. ONCARD('I','SMAX',STHLMX)) THEN
C NEED SMAX:
      CALL ERRMES(2,1,'max sin theta/lambda to generate hkl values')
      GO TO 100
      ENDIF
C
C     SET UP DEFAULT VALUES
   5  CALL GMZER(PT,3,3)
      CALL GMZER(STEP,3,3)
      CALL GMZER(PRPT,3,3)
C
C     SWITCH ACCORDING TO THE NUMBER OF SYMMETRY PLANES:
      N1=NASYM+1
      GO TO (1,2,3,4) , N1
C
C NO PLANES:
   1  CALL GMUNI(STEP,3)
      GO TO 10
C
C ONE PLANE:
   2  CALL GMEQ(ASYM(1,1),STEP(1,3),1,3)
      CALL INVENT(STEP(1,3),STEP(1,3),STEP(1,1))
C THAT MIDDLE VALUE OF STEP IS JUST SOME VECTOR NOT IN THE PLANE
      CALL  INVENT(STEP(1,3),STEP(1,1),STEP(1,2))
      GO TO 10
C
C TWO PLANES:
   3  CALL GMEQ(EDGE(1,3),STEP(1,3),1,3)
      CALL INVENT(ASYM(1,1),STEP(1,3),STEP(1,1))
      CALL INVENT(ASYM(1,2),STEP(1,3),STEP(1,2))
      GO TO 10
C
C THREE PLANES:
   4  CALL GMEQ(EDGE,STEP,3,3)
C
C JOIN - DETERMINE VOLUME OF CELL
   10 DO 12 I=1,3
   12 CALL FCTOR(STEP(1,I),N)
      NP=JFIX(DETER3(STEP))
      IF (NP.GT.0) GO TO 11
      NP=-NP
      CALL GMEQ(STEP(1,1),TEMP,1,3)
      CALL GMEQ(STEP(1,2),STEP(1,1),1,3)
      CALL GMEQ(TEMP,STEP(1,2),1,3)
C
C SET UP LIMITS AND STARTING VALUES:
  11  J=2
      K=3
      DO 16 I=1,3
      CALL VECPRD(STEP(1,J),STEP(1,K),VECEND(1,I))
      ALNGTH=2.*STHLMX*VCTMOD(1.,VECEND(1,I),1)
      LENGTH=IFIX(ALNGTH/N)+1
      DO 15 L=1,3
      VECEND(L,I)=VECEND(L,I)/ALNGTH
C DEPENDING ON THE NUMBER OF BOUNDING PLANES OF THE ASYMMETRIC
C UNIT, THE PREVIOUS POINT VECTOR STARTS AT 0 OR FAR END OF VECTOR:
      IF (NASYM .EQ. 3) GO TO 15
      IF ((NASYM .EQ. 2) .AND. (I .NE. 3)) GO TO 15
      IF ((NASYM .EQ. 1) .AND. (I .EQ. 3)) GO TO 15
      PRPT(L,3)=PRPT(L,3)-FLOAT(LENGTH)*STEP(L,I)
  15  CONTINUE
      J=K
  16  K=I
      CALL GMSUB(PRPT(1,3),STEP(1,1),PRPT(1,1),3,1)
      CALL GMEQ(PRPT(1,3),PRPT(1,2),1,3)
C START POINT IN PT ALSO:
      CALL GMEQ(PRPT,PT,3,3)
      IF (BINDIG(IOUT,16)) THEN
        WRITE (LPT,4000) STEP,PT,VECEND
        WRITE (ITO,4000) STEP,PT,VECEND
 4000   FORMAT (/' STEP,PT,VECEND :'/3(3(3F8.2/)/))
      ENDIF
      CALL PRMTIV
 100  RETURN
      END
C
C
C
C
C LEVEL 12      SUBROUTINE SETLP
      SUBROUTINE SETLP
C
C *** SETLP by JCM 8 Oct 85 ***
C
CX
CC 2A
CH Prepares to calculate (X-ray) Lorentz and polarisation corrections.
CP RECIP should have read the cell parameters.
CD Reads and checks the D cards necessary for LP corrections and puts
CD required data into COMMON /DGEOM/
CD Checks the presence of D WVLN and D TH2M (for type 10 IGEOM) cards.
CO Writes a title to unit LPT.
C
/DGEOM/
/DREAD/
/IOUNIT/
C
      CALL MESS(LPT,2,'Lp corrections')
      CALL SETDC
      IF (IDREAD(2) .LE. 0) THEN
        CALL ERRMES(2,1,'D WVLN card fto define measurement wavelength')
        GO TO 100
      ENDIF
C
      IF (IGEOM .NE. 10) THEN
        IF (IDREAD(4) .LE. 0) CALL ERRMES(2,1,
     &  'D TH2M card for monochrometer 2theta')
      ENDIF
C
 100  RETURN
      END
C
C
C
C
C LEVEL 12      SUBROUTINE SETPOL
      SUBROUTINE SETPOL
C
C *** SETPOL updated by PJB  C104 27-Apr-2001 ***
C
CX
CC 2A
CH Reads the up and down polarisations of a polarised neutron beam.
CD Reads the "P" card giving the polarisation and flipping efficiency
CD both with their standard deviations. Stores the data in COMMON /POLDA/.
CD A new card format (1997) allows the "UP" and "DOWN" polarisations to
CD be given with ther standatd deviations. If this format is chosen the
CD polarisations should be preceeded by the 'words' "UP", or "DOWN" as
CD appropriate. If MODE is to be given it should be preceeded by the 'word'
CD "DEPO".
CD If a negative efficiency is read it is assumed that the UP and DOWN
CD polarisations are given
CD SETPOL also sets the polarisation direction POLND on crystallographic axes
CD if the crystal geometry is specified on D cards.
CN As of the Mar 1997 revision the data stored and used are the up and down
CN polarisations and their standard deviations. If the old format with the
CN flipper efficiency is used the treatment of its standard deviation is not
CN quite correct.
C
CI Reads the "P" card from the copy of the Crystal Data File on unit IO10.
CO Writes its findings to unit LPT
C
      LOGICAL FOUND(3)
      CHARACTER*4 PWRDS(3),WORD
C
/CARDRC/
/DGEOM/
/IOUNIT/
/POLDA/
/SCRACH/
C
      DATA PWRDS/'UP','DOWN','DEPO'/
C
      IF (INREAD(16) .LT.0) RETURN
C RETURN IF P CARD HAS ALREADY BEEN READ
      INREAD(16)=-IABS(INREAD(16))
      IF (ICDNO(16) .LE. 0) CALL ERRMES(1,0,
     & 'no polarisation data have been given')
C
      DO 7 I=1,3
      FOUND(I)=.FALSE.
    7 CONTINUE
      MODE=0
      ICNT=0
      CALL CARDIN(IABS(INREAD(16)))
      CALL RDREAL(P,3,IPT,80,IER)
      IF (IER.GT.0) THEN
        IPT=3
        IF (IER.LT.53) GO TO 1
        GO TO 99
      ENDIF
      CALL RDREAL(DP,IPT,IPT,80,IER)
      CALL RDREAL(E,IPT,IPT,80,IER)
      CALL RDREAL(DE,IPT,IPT,80,IER)
      CALL RDINTG(MODE,IPT,IPT,80,IER)
      POLUP=P
      DPOLUP=DP
      IF (E .GE. 0) THEN
        WRITE (LPT,2000) P,DP,E,DE
2000  FORMAT (/' Polarisation of beam is',F10.5,' +or-',F10.5,
     & '.  Flipping efficiency is',F10.5,' +or-',F10.5)
        POLDW=-(P*E)
        DPOLDW=DE
      ELSE
        POLDW=E
        DPOLDW=DE
        WRITE (LPT,2001) POLUP,DPOLUP,POLDW,DPOLDW
      ENDIF
    5 IMODE = MODE+1
      IF (INREAD(4) .GT. 0) CALL SETDC
      DO 6 I=1,3
      POLND(I)=UM(3*I)
    6 CONTINUE
      IF (IMODE .EQ. 3) THEN
        CALL MESS(LPT,1,
     &   'Depolarisation to be calculated as a volume effect')
        IF (INREAD(7) .GT. 0) CALL INPUTG
        CALL SETABS
      ENDIF
      GO TO 100
C FOR NEW P CARD FORMAT
    1 iany=0
      CALL RDWORD(WORD,LWRD,IPT,IPT1,IPT+5,iany,IER)
      ipt=ipt1
      IF (IER.EQ.0) THEN
      I=NCFIND(WORD,PWRDS,3)
      IF (I.LE.0 .OR. FOUND(I)) GO TO 99
        FOUND(I)=.TRUE.
        GO TO (2,3,4) I
    2   CALL RDREAL(POLUP,IPT,IPT,80,IER)
        IF (IER.NE.0) GO TO 99
        CALL RDREAL(DPOLUP,IPT,IPT,80,IER)
        IF (IER.NE.0) GO TO 99
        ICNT=ICNT+1
        GO TO 1
    3   CALL RDREAL(POLDW,IPT,IPT,80,IER)
        IF (IER.NE.0) GO TO 99
        CALL RDREAL(DPOLDW,IPT,IPT,80,IER)
        IF (IER.NE.0) GO TO 99
C109 Two following lines removed
C        E=PD/P
C        DPD=DE
        ICNT=ICNT+1
      ELSE IF (IER.EQ.100 .AND. ICNT.GE. 2) THEN
C CHECK THAT THEY HAVE OPPOSITE SIGNS
        IF (POLUP*POLDW .GT.0)
     & CALL MESS(LPT,1,'*** POSSIBLE ERROR Up and Down polarisations'
     &//' have the same sign ')
        WRITE (LPT,2001) POLUP,DPOLUP,POLDW,DPOLDW
2001  FORMAT (/' Polarisation with spin up is',F10.5,' +or-',F10.5,
     & ' that with spin down is',F10.5,' +or-',F10.5)
        GO TO 5
      ELSE
        GO TO 99
      ENDIF
      GO TO 1
    4 CALL RDINTG(MODE,IPT,IPT,80,IER)
      IF (IER.NE.0) GO TO 99
      GO TO 1
  99  CALL ERRMES(1,1,'On P card saying: '//ICARD)
 100  RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE SHFESD(J)
      SUBROUTINE SHFESD(J)
C
C *** SHFESD by JCM 7 May 86 ***
C
CX
CC 6C
CH During the application of LSQ shifts, calculates the shift and ESD for
CH a "redundant" variable.
C
CA On entry J points to the constraint information in /CONSTR/
CA            for this redundant variable (which is related to a set
CA            of basic variables by the given constraint J)
C
CD On exit  SHIFT is set to the linear combination of relevant shifts
CD                in basic variables,
CD          ESD is set to the square root of the sum of squares of their esds.
C
/CONSTR/
/DERBAS/
/MATDAT/
/NEWOLD/
      JROW=JROWPT(J)
      JNEXT=JROWPT(J+1)-1
      SHIFT=0.
      ESD=0.
      DO 1 M=JROW,JNEXT
      SHIFT=SHIFT + AMOUNT(M)*BLSQ(JCMAT(M))
   1  ESD=ESD + (AMOUNT(M)*DERIVB(JCMAT(M)))**2
      ESD=SQRT(ESD)
      RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE SID(A,N,ND1,ND2,D)
      SUBROUTINE SID(A,N,ND1,ND2,D)
C
C *** SID from PJB by A. Bartelemy ***
C
CX
CC 12C
CH Solves a set of simultaneous linear equations.
CA  A   is an N by N+1 sized matrix written in a table of dimension ND1
CA      by ND2
CA  On entry A(1:N,1:N) contains the matrix of coefficients
CA           A(1:N,N+1) contains the column of right-hand sides
CA  On exit  D is the value of the determinant
CA           A(1:N,N+1) contains the solution if D is not zero
C
C  SUBROUTINE *** SID ***         A BARTHELEMY  19/2/75        *
C  INVERSION DE MATRICE AVEC CALCUL DE DETERMINANT             *
C  MATRICE A(N,N+1)    DANS TABLEAU (ND1,ND2)                  *
C   EN ENTREE POUR APPEL PAR RAFIN MAIN :                      *
C        A(I=1 A N,J=1 A N)=AMAT                               *
C        A(I=1 A N,J=N+1  )=VVEC                               *
C  N=NOMBRE DE COLONNES DE A                                   *
C
      DIMENSION II(16),IL(16),IG(16),A(ND1,ND2)
C
      M=N+1
      D=1.
      IS=N-1
      DO 10 K=1,N
      IL(K)=0
   10 IG(K)=K
C
C.....
      DO 150 K=1,N
      R=0.
      DO 40 I=1,N
      IF (IL(I) .NE. 0) GO TO 40
      W=A(I,K)
      X=ABS(W)
      IF (X .LT. R) GO TO 40
      R=X
      P=W
      KF=I
   40 CONTINUE
C
      II(K)=KF
      IL(KF)=KF
      D=D*P
C.....ERROR NUL DETERMINANT
      IF (D .EQ. 0.) GO TO 100
C
      DO 80 I=1,N
      IF (I .EQ. KF) THEN
        A(I,K)=1./P
      ELSE
        A(I,K)=-(A(I,K)/P)
      ENDIF
   80 CONTINUE
C
      DO 140 J=1,M
      IF (J .EQ. K) GO TO 140
      W=A(KF,J)
      IF (W .EQ. 0.) GO TO 140
      DO 130 I=1,N
      IF (I .EQ. KF) THEN
        A(I,J)=W/P
      ELSE
        A(I,J)=A(I,J)+W*A(I,K)
      ENDIF
  130 CONTINUE
  140 CONTINUE
C
  150 CONTINUE
C.....
C
      DO 190 K=1,IS
      KF=II(K)
      KL=IL(KF)
      KG=IG(K)
      IF (KF .EQ. KG) GO TO 190
C
      DO 170 I=1,N
      R=A(I,KF)
      A(I,KF)=A(I,KG)
  170 A(I,KG)=R
C
      DO 180 J=1,M
      R=A(K,J)
      A(K,J)=A(KL,J)
  180 A(KL,J)=R
C
      IL(KF)=K
      IL(KG)=KL
      IG(KL)=IG(K)
      IG(K)=KF
      D=-D
  190 CONTINUE
  100 RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE SINCOS(SN,CS,L1)
      SUBROUTINE SINCOS(SN,CS,L1)
C
C *** SINCOS updated by JCM 1 Jul 86 ***
C
CX
CC 10C
CH Calculates sin from cos or vice-versa.
CA On entry SN is a sine or cosine of an angle
CA On exit  CS is the cosine or sine respectively of the same angle
CA          L1 is a character variable which is used to identify the
CA             calling routine if the abssolute value of SN is greater
CA             than 1.
CN If ABS(SN)>1 the routine writes an error message and STOPS
C
      CHARACTER *(*) L1
/IOUNIT/
C
      IF (ABS(SN)-10.E-5 .GT. 1.) THEN
        WRITE (LPT,3000) SN,L1
        WRITE (ITO,3000) SN,L1
3000    FORMAT (/' Sin or Cos value',E12.4,' greater than unity',
     &  ' - called from ',A6)
        STOP
      ENDIF
C
C NOW DETECT CASE WHERE SN IS ONLY JUST MORE THAN 1:
      IF (ABS(SN) .GE. 1.0) THEN
        SN = SIGN(1.0,SN)
        CS = 0.
      ELSE
C
C USUAL CASE:
        CS = SQRT(1. - SN*SN)
      ENDIF
      RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE SORTN(IVAL,IP,N)
      SUBROUTINE SORTN(IVAL,IP,N)
C
C *** SORTN updated by JHM/JCM 22 Aug 86 ***
C
CX
CC 16C
CH Sorts pointers to an integer array using Heapsort.
C
CA On entry IVAL is an array of N integers.
CA On exit IP is an array of N pointers to IVAL in ascending order
C
CN Copyright John Matthewman 18 July 1983
CN  HEAPSORT
CN  (See Knuth 'Art of Computer Programming' Vol 3, Section 5.2.3)
C
      DIMENSION IVAL(N),IP(N)
C
C EXTRA PART (WHICH MAY BE REMOVED AGAIN) - SET UP POINTERS:
      DO 16 I=1,N
  16  IP(I)=I
      IF (N .LT. 2) GO TO 100
C  INITIALISE
      L=N/2+1
      IR=N
    1 L=L-1
      K=IP(L)
    3 J=L
      GO TO 4
C
C  SIFTING LOOP
    5 IF (IVAL(IP(J)).LT.IVAL(IP(J+1))) J=J+1
    7 IP(I)=IP(J)
    4 I=J
      J=J+J
      IF (J-IR) 5,7,8
C
C  FLOYDS MODIFICATION
   10 IP(J)=IP(I)
    8 J=I
      I=I/2
      IF (I) 6,6,9
    9 IF (J.GT.L .AND. IVAL(K).GT.IVAL(IP(I))) GO TO 10
   6  IP(J)=K
C
C  END OF A SIFT
      IF (L.GT.1) GO TO 1
      K=IP(IR)
      IP(IR)=IP(1)
      IR=IR-1
      IF (IR.GT.1) GO TO 3
      IP(1)=K
 100  RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE SORTX(VAL,IP,N)
      SUBROUTINE SORTX(VAL,IP,N)
C
C *** SORTX updated by JHM/JCM 22 Aug 86 ***
C
CX
CC 16C
CH Sorts pointers to a real array using Heapsort.
C
CA On entry VAL is an array of N real numbers.
CA On exit IP is an array of N pointers to VAL in ascending order
C
CN Copyright John Matthewman 18 July 1983
CN  HEAPSORT
CN  (See Knuth 'Art of Computer Programming' Vol 3, Section 5.2.3)
C
C
      DIMENSION VAL(N),IP(N)
C
C EXTRA PART (WHICH MAY BE REMOVED AGAIN) - SET UP POINTERS:
      DO 16 I=1,N
  16  IP(I)=I
      IF (N .LT. 2) GO TO 100
C  INITIALISE
      L=N/2+1
      IR=N
    1 L=L-1
      K=IP(L)
    3 J=L
      GO TO 4
C
C  SIFTING LOOP
    5 IF (VAL(IP(J)).LT.VAL(IP(J+1))) J=J+1
    7 IP(I)=IP(J)
    4 I=J
      J=J+J
      IF (J-IR) 5,7,8
C
C  FLOYDS MODIFICATION
   10 IP(J)=IP(I)
    8 J=I
      I=I/2
      IF (I) 6,6,9
    9 IF (J.GT.L .AND. VAL(K).GT.VAL(IP(I))) GO TO 10
   6  IP(J)=K
C
C  END OF A SIFT
      IF (L.GT.1) GO TO 1
      K=IP(IR)
      IP(IR)=IP(1)
      IR=IR-1
      IF (IR.GT.1) GO TO 3
      IP(1)=K
 100  RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE SPACE(NT,NSCR,NGENS)
      SUBROUTINE SPACE(NT,NSCR,NGENS)
C
C *** SPACE corrected by PJB  02-Nov-1994 ***
C
Cx
CC 1A
CH Interprets symbols from an S card which are the space group name.
CA On entry NT is a string of characters representing a space group short name.
CA There must be at least one space between elements, e.g. P21 21 21.
CA On exit NSCR is the unit on which S cards have been temporarily written.
CA         NGENS is the number of generators.
CD Generates S cards for subequent interpretation by SYMOP.
CN This is not the best or simplest way of doing this, but it came from a
CN working program.
CN *** SPACE adapted from an anonymous program by JCM 22 Aug 92 ***
C
      CHARACTER *1 LATLET(7),NDIGS(7),SPALET(6)
      CHARACTER *4 FIRST,MID,LAST
      CHARACTER *16 NT
      CHARACTER *12 IN
      CHARACTER *12 SYSTEM(6)
      CHARACTER *4 NTEX(21),AMTSA(3),AMGES(3,2)
      CHARACTER *4 TX(6,3),TEXB(9)
      LOGICAL TRI,MONO,ORTHO,TETRA,HEXA,CUBIC,CENTRE
      LOGICAL AFACE,BFACE,CFACE,BODY,RHOMB,FACE,PRIM,SLASH,MINUS
      LOGICAL EMPTY(3),LETT1(3),OUTSID
      LOGICAL FIRDIG(6),FIRA,FIRB,FIRC,FIRM,FIRN,FIRD,FIR21
      LOGICAL MIDA,MIDB,MIDC,MIDD,MIDM,MIDN,MID2,MID21
      LOGICAL LASTA,LASTB,LASTC,LASTD,LASTM,LASTN,LAST2
      DIMENSION MGES(3,3,21),NET(3),NES(3),MGET(3,13),
     & MSS(48,3,3),MTS(48,3),MSSS(3,3),MTSS(3),MTSA(3,3),NSV(3,18),
     & NSW(3)
      EQUIVALENCE (FIRST,IN(1:4))
      EQUIVALENCE (MID,IN(5:8))
      EQUIVALENCE (LAST,IN(9:12))
/IOUNIT/
      DATA NDIGS/'0','1','2','3','4','5','6'/
      DATA LATLET/'A','B','C','I','R','F','P'/
      DATA SPALET/'A','B','C','M','N','D'/
      DATA SYSTEM/'TRICLINIC','MONOCLINIC','ORTHORHOMBIC','TETRAGONAL',
     &  'HEXAGONAL','CUBIC'/
      DATA MGES/1,3*0,1,3*0,1,-1,3*0,-1,3*0,1,0,1,0,2*-1,3*0,1,0,1,
     & 0,-1,4*0,1,0,1,3*0,2*1,2*0,2*1,0,-1,4*0,1,-1,3*0,-1,3*0,-1,1,
     & 3*0,1,3*0,-1,0,-1,0,2*1,3*0,-1,0,-1,0,1,4*0,2*-1,3*0,1,3*0,3*-1,
     & 0,1,4*0,-1,1,3*0,-1,3*0,1,0,1,0,1,4*0,-1,0,-1,0,-1,4*0,2*1,2*0,
     & 2*-1,3*0,2*-1,2*0,2*1,3*0,1,-1,3*0,1,3*0,1,0,1,0,1,4*0,2*1,3*0,
     & -1,3*0,-1,0,-1,0,-1,4*0,-1/
C MGES HOLDS:
C   1:  1  0  0     2: -1  0  0    3:  0  1  1    4:  0  1  0    5:  0  1  0
C       0  1  0         0 -1  0       -1 -1  0       -1  0  0        0  0  1
C       0  0  1         0  0  1        0  0  1        0  0  1        1  0  0
C
C   6:  1  1  0     7: -1  0  0    8:  1  0  0    9:  0 -1  0   10:  0 -1  0
C      -1  0  0         0 -1  0        0  1  0        1  1  0        1  0  0
C       0  0  1         0  0 -1        0  0 -1        0  0 -1        0  0 -1
C
C  11: -1  0  0    12: -1 -1  0   13:  1  0  0   14:  0  1  0   15:  0 -1  0
C       0  1  0         1  0  0        0 -1  0        1  0  0       -1  0  0
C       0  0 -1         0  0 -1        0  0  1        0  0 -1        0  0  1
C
C  16:  1  0  0    17: -1  0  0   18: -1  0  0   19:  0  1  0   20:  1  0  0
C      -1 -1  0         1  1  0        0  1  0        1  0  0        0 -1  0
C       0  0 -1         0  0  1        0  0  1        0  0  1        0  0 -1
C
C  21:  0 -1  0
C      -1  0  0
C       0  0 -1
C
      DATA NTEX/3*'    ','+1/8','+1/6','    ','+1/4',
     & '    ','+1/3','+3/8',2*'    ','+1/2',3*'    ','+2/3',
     & '    ','+3/4','    ','+5/6'/
      DATA TEXB/'  -Z','  -Y',' X-Y','  -X','    ','   X',' Y-X','   Y',
     & '   Z'/
      DATA MGET/0,0,0,    12,0,0,  0,12,0,  0,0,12,  0,12,12,  12,0,12,
     &        12,12,0,  12,12,12,   0,6,6,   6,0,6,    6,6,0,    6,6,6,
     &         18,6,6/
C MGET HOLDS:
C           1:     0    0    0                8:    1/2  1/2  1/2
C           2:    1/2   0    0                9:     0   1/4  1/4
C           3:     0   1/2   0               10:    1/4   0   1/4
C           4:     0    0   1/2              11:    1/4  1/4   0
C           5:     0   1/2  1/2              12:    1/4  1/4  1/4
C           6:    1/2   0   1/2              13:    3/4  1/4  1/4
C           7:    1/2  1/2   0
C
      DATA NSV/6,0,0,    0,6,0,   0,0,6,   0,0,4,   0,0,8,    9,9,0,
     &         6,6,6,    6,6,0,  6,18,0,  6,18,3,  6,18,6,   6,18,9,
     &        12,6,9,   0,12,0,  0,18,0,   0,0,0,  0,12,0,  12,12,12/
C NSV HOLDS:
C           1:    1/4   0    0               10:    1/4  3/4  1/8
C           2:     0   1/4   0               11:    1/4  3/4  1/4
C           3:     0    0   1/4              12:    1/4  3/4  3/8
C           4:     0    0   1/6              13:    1/2  1/4  3/8
C           5:     0    0   1/3              14:     0   1/2   0
C           6:    3/8  3/8   0               15:     0   3/4   0
C           7:    1/4  1/4  1/4              16:     0    0    0
C           8:    1/4  1/4   0               17:     0   1/2   0
C           9:    1/4  3/4   0               18:    1/2  1/2  1/2
C
C     READ THE SYMBOL, DETERMINE BRAVAIS LATTICE AND CRYSTAL FAMILY.
      JS=1
      JR=0
C DEFAULT MONOCLINIC:
      MSYS=2
      IN='000000000000'
      MINUS=.FALSE.
      SLASH=.FALSE.
C PUT THE SYMBOL INTO UPPER CASE:
      CALL UPPER(NT)
      DO 9 IS=1,16
      IF (NT(IS:IS) .NE. ' ') GO TO 10
   9  CONTINUE
      CALL ERRMES (1,0,'No space group symbol')
  10  NBR=NCFIND(NT(IS:IS),LATLET,7)
      IF (NBR .EQ. 0) CALL ERRCH2(NT(IS:IS),0,'lattice letter',
     & 'not recognised')
      AFACE=(NBR .EQ. 1)
      BFACE=(NBR .EQ. 2)
      CFACE=(NBR .EQ. 3)
      BODY =(NBR .EQ. 4)
      RHOMB=(NBR .EQ. 5)
      FACE =(NBR .EQ. 6)
      PRIM =(NBR .EQ. 7)
C
      OUTSID=.TRUE.
      DO 1 I=IS+1,16
      IF (OUTSID .AND. NT(I:I) .EQ. ' ') GO TO 1
      IF (JS .LE. 12) IN(JS:JS)=NT(I:I)
      IF (IN(JS:JS) .EQ. '-') THEN
        IF (JS .NE. 1) THEN
          CALL ERRMES(1,0,'Minus other than at start of first symbol')
        ELSE
          MINUS=.TRUE.
          JS=JS-1
        ENDIF
      ENDIF
      IF (IN(JS:JS) .EQ. '/') THEN
        IF (JS .NE. 2 .AND. JS .NE. 3) THEN
          CALL ERRMES(1,0,'Slash other than within first symbol')
        ELSE
          SLASH=.TRUE.
        ENDIF
      ENDIF
      IF (NT(I:I) .EQ. ' ') THEN
        OUTSID=.TRUE.
        IF (JS .LE. 12) IN(JS:JS)='0'
        JR=JR+1
        JS=4*JR
      ELSE
        OUTSID=.FALSE.
      ENDIF
      JS=JS+1
      IF (NT(I:I) .EQ. '3' .OR. NT(I:I) .EQ. '6') MSYS=5
   1  CONTINUE
C
      DO 3 J=1,3
      I=4*J-3
      EMPTY(J)=IN(I:I) .EQ. '0'
      LETT1(J)=(NCFIND(IN(I:I),SPALET,6) .GT. 0)
*      DIGIT1(J) =(NCFIND(IN(I:I),NDIGS(2),6) .GT. 0)
   3  CONTINUE
      IF (EMPTY(1)) CALL ERRMES(1,0,'No space group symbols')
      DO 7 I=1,6
   7  FIRDIG(I)=(FIRST(1:1) .EQ. NDIGS(I+1))
      FIRA=(FIRST(1:1) .EQ. 'A')
      FIRB=(FIRST(1:1) .EQ. 'B')
      FIRC=(FIRST(1:1) .EQ. 'C')
      FIRM=(FIRST(1:1) .EQ. 'M')
      FIRN=(FIRST(1:1) .EQ. 'N')
      FIRD=(FIRST(1:1) .EQ. 'D')
      FIR21=(FIRST(1:2) .EQ. '21')
      MIDA=(MID(1:1) .EQ. 'A')
      MIDB=(MID(1:1) .EQ. 'B')
      MIDC=(MID(1:1) .EQ. 'C')
      MIDD=(MID(1:1) .EQ. 'D')
      MIDM=(MID(1:1) .EQ. 'M')
      MIDN=(MID(1:1) .EQ. 'N')
      MID2=(MID(1:1) .EQ. '2')
      MID21=(MID(1:2) .EQ. '21')
      LAST2=(LAST(1:1) .EQ. '2')
      LASTA=(LAST(1:1) .EQ. 'A')
      LASTB=(LAST(1:1) .EQ. 'B')
      LASTC=(LAST(1:1) .EQ. 'C')
      LASTD=(LAST(1:1) .EQ. 'D')
      LASTM=(LAST(1:1) .EQ. 'M')
      LASTN=(LAST(1:1) .EQ. 'N')
C
      IF (FIRDIG(4)) MSYS=4
      IF (MID(1:1).EQ.'3') MSYS=6
      IF (MSYS.EQ.2.AND.FIRST(1:1).GE.'2'.AND.MID(1:1).GE.'2') MSYS=3
      IF (FIRDIG(1) .AND. EMPTY(2)) MSYS=1
      TRI=  (MSYS .EQ. 1)
      MONO= (MSYS .EQ. 2)
      ORTHO=(MSYS .EQ. 3)
      TETRA=(MSYS .EQ. 4)
      HEXA= (MSYS .EQ. 5)
      CUBIC=(MSYS .EQ. 6)
C
C       FOR MONOCLINIC SETTING WITH ONLY 1 FIELD, FORCE B AXIS UNIQUE:
      IF (MONO .AND. EMPTY(2)) THEN
        MID=FIRST
        FIRST='    '
        EMPTY(2)=.FALSE.
      ENDIF
C
C       SELECTION OF GENERATORS:
C
      NG=0
      KL=0
      DO 6 I=1,3
      NES(I)=1
      NET(I)=0
      DO 6 J=1,3
   6  MTSA(I,J)=0
C
C FORM FIRST 2 (DECMAL) DIGITS OF FIRST SYMBOL IN NDIG1 AND NSCRW1.  IF THEY
C WERE NOT DIGITS, THIS IS MEANINGLESS.  IF THERE IS NO SCREW NSCRW1 WILL BE
C EITHER -1 (IF / PRESENT) OR 0 (IF FIRST SYMBOL IS IN FACT A SINGLE DIGIT).
      NDIG1=ICHAR(FIRST(1:1))-ICHAR('0')
      NSCRW1=ICHAR(FIRST(2:2))-ICHAR('0')
      IF (TRI .OR. TETRA .OR. HEXA .OR. CUBIC) THEN
C
C        POINT GROUPS 1,-1,3,-3,4,-4,6,-6,4/M,6/M.
C
        NET(1)=NDIG1
        KL=24*NSCRW1/NDIG1
        IF (MINUS) NET(1)=NDIG1+6
        IF (NDIG1.EQ.3) NG=1
        IF (NDIG1.GE.3 .AND. NDIG1.LE.6 .AND. NSCRW1.GT.0) MTSA(1,3)=KL
        IF (EMPTY(2)) THEN
          NG=1
          IF (SLASH) THEN
            NET(2)=8
            IF (FIRST(4:4).EQ.'A' .OR. FIRST(3:3).EQ.'A') NES(2)=2
            IF (FIRST(4:4).EQ.'N' .OR. FIRST(3:3).EQ.'N') NES(2)=7
            NG=2
          ENDIF
          GO TO 400
        ENDIF
      ENDIF
C
C       MONOCLINIC-ORTHORHOMBIC. ((OR MORE THAN ONE AXIS))
C
      DO 105 I=1,3
      DO 105 J=1,4
      L=4*(I-1)+J
      M=L+4
      IF (M.GT.12) M=M-12
C
C      MONOCLINIC - ORTHORHOMBIC ACTUALLY STARTS HERE
C
      IF (MONO .OR. ORTHO) THEN
C
C   DETECT 2-FOLD AXIS NOT FOLLOWED BY A LETTER:
C
*        IF (IN(L:L).EQ. '2' .AND. IN(M:M) .LT. 'A')THEN
        IF (IN(L:L).EQ.'2' .AND. (NCFIND(IN(M:M),SPALET,6).EQ.0)) THEN
          NG=NG+1
          NET(NG)=29-9*I
          IF (IN(L+1:L+1) .EQ. '1') NES(NG)=I+1
          IF (NG.EQ.2 .AND. LAST(2:2) .EQ. '1') MTSA(2,3)=12
          IF (NG.EQ.2) GO TO 400
        ENDIF
C
C   WE HAVE A LETTER:
C
*        IF (IN(L:L) .GT. '6') THEN
        LETL=NCFIND(IN(L:L),SPALET,6)
        IF (LETL .GT. 0) THEN
          NG=NG+1
          NET(NG)=23-5*I
** TURNS A, B OR C INTO 2, 3 OR 4:
          IF (LETL .GE. 1 .AND. LETL .LE. 3) NES(NG)=LETL+1
          IF (IN(L:L) .EQ. 'N') NES(NG)=I+4
          IF (IN(L:L) .EQ. 'D') NES(NG)=I+8
        ENDIF
C
C       3. TETRAGONAL-HEXAGONAL-CUBIC
C
      ELSE IF (IN(M:M) .GT. '1') THEN
C
        IF (I.NE.3 .OR. SLASH .OR.
     &   (CUBIC .AND.(LETT1(1) .OR. EMPTY(3)))) THEN
          NG=NG+1
          IF (NG.EQ.4)NG=3
C  FIRST CYCLE  :
          IF (I.EQ.1) THEN
            IF (CUBIC) THEN
               NET(1)=5
            ELSE IF (MID2) THEN
              NET(NG)=36-4*MSYS
              IF (MID21) NES(1)=2
            ELSE IF (LETT1(2)) THEN
              NET(NG)=22-MSYS
            ENDIF
C
C   SECOND CYCLE :
C
          ELSE IF (I.EQ.2) THEN
            IF (LAST2) NET(NG)=21
            IF (LETT1(3)) NET(NG)=19
            IF (CUBIC) THEN
              IF (LAST2) NET(2)=14
              IF (MINUS) NET(2)=15
            ENDIF
          ELSEIF (I.EQ.3) THEN
            IF (NCFIND(IN(M:M),SPALET,6) .GT. 0) NET(NG)=8
            IF (IN(M:M) .EQ. '2') NET(NG)=2
          ENDIF
          IF (FIR21) NES(2)=6
*          IF (MID2 .AND. LAST2 .AND. I.EQ.1 .AND. FIRST(2:2).GT.'0')
          IF (MID2 .AND. LAST2 .AND. I.EQ.1 .AND. NSCRW1.GT.0)
     &     MTSA(2,3)=24-MTSA(1,3)
          IF (.NOT. FIRDIG(3)) MTSA(1,3)=0
*          IF (NET(2) .EQ. 14 .AND. FIRST(2:2) .GT. '0') THEN
          IF (NET(2) .EQ. 14 .AND. NSCRW1 .GT. 0) THEN
            MTSA(2,1)=24-KL
            MTSA(2,2)=KL
            MTSA(2,3)=KL
          ENDIF
          N=NCFIND(IN(M:M),LATLET,3)
          IF (N .GT. 0) NES(NG)=N+1
          IF (IN(M:M) .EQ. 'N') THEN
            NES(NG)=4+I
            IF ( I.EQ.2) NES(NG)=8
          ELSE IF (IN(M:M) .EQ. 'D')THEN
            NES(NG)=14-I
          ENDIF
          IF (LASTD .AND. CUBIC) THEN
            IF (FIRA) THEN
C GROUP 230 - I A 3 D:
              NES(2)=12
            ELSE
C GROUP 220 - I -4 3 D:
              NES(2)=13
            ENDIF
          ENDIF
        ENDIF
      ENDIF
 105  CONTINUE
C
C       COMPLETE SYMMETRY OPERATIONS
C
 400  NGENS=NG
      DO 415 K=1,NG
      DO 415 I=1,3
      MTS(K,I)=MGET(I,NES(K))+MTSA(K,I)
      DO 415 J=1,3
 415  MSS(K,I,J)=MGES(I,J,NET(K))
C
      NSS=-1
      K=0
 610  K=K+1
      IF (K.GT.NG) GO TO 617
      L=1
      IF (MSS(K,1,1)+MSS(K,2,2)+MSS(K,3,3).EQ.-3)NSS=K
      IF (MSS(K,1,1)+MSS(K,2,2)+MSS(K,3,3).EQ.3)NU=K
  616 IF (L.GT.NGENS) GO TO 610
      DO 620 I=1,3
      ITN=MTS(K,I)
      DO 620 J=1,3
      N=0
      ITN=ITN+MSS(K,I,J)*MTS(L,J)
      DO 625 M=1,3
  625 N=N+MSS(K,I,M)*MSS(L,M,J)
      ITN=MOD(ITN+24,24)
      MSSS(I,J)=N
 620  MTSS(I)=ITN
      DO 640 KK=1,NG
      N=0
      DO 645 I=1,3
      DO 645 J=1,3
  645 IF (MSSS(I,J).NE.MSS(KK,I,J)) N=1
      IF (N.EQ.0) GO TO 618
  640 CONTINUE
      NG=NG+1
      DO 646 I=1,3
      MTS(NG,I)=MTSS(I)
      DO 646 J=1,3
  646 MSS(NG,I,J)=MSSS(I,J)
  618 L=L+1
      IF (K.EQ.NSS) THEN
        DO 720 I=1,3
        J=I+1
        IK=I+2
        IF (J.GT.3)J=J-3
        IF (IK.GT.3)IK=IK-3
C
C  REMOVE LATTICE TRANSLATIONS -  FIRST I THEN F,A,B,C:
C
        IF (BODY .AND. I.EQ.1) THEN
          IF (MTS(NSS,1) .GE. 12 .AND. MTS(NSS,2) .GE. 12
     &     .AND. MTS(NSS,3) .GE. 12) THEN
            DO 700 IJ=1,3
 700        MTS(NSS,IJ)=MTS(NSS,IJ)-12
          ENDIF
        ELSE IF (FACE .OR. NBR.EQ.I) THEN
          IF (MTS(NSS,J).GE.12.AND.MTS(NSS,IK).GE.12)THEN
            DO 718 II=1,3
 718        MTS(NSS,II)=MTS(NSS,II)-MGET(II,I+4)
          ENDIF
        ENDIF
 720    CONTINUE
      ENDIF
      GO TO 616
C
C       DETERMINE CENTROSYMMETRY AND SHIFT VECTOR TO A CENTRE OF SYMM..
C
 617  CENTRE = (NSS.GT.0)
      DO 619 I=1,3
C RE-USE OF ARRAY MTSA, WHICH WAS THE SCREW AXIS TRANSLATION:
 619  MTSA(1,I)=0
      IF (CENTRE) THEN
        DO 615 K=1,3
          MTSA(1,K)=MOD((MTS(NSS,K)/2)+24,24)
 615    CONTINUE
      ENDIF
C
C   DETERMINE THE REF. NUMBER SHIFT VECTOR TO AN ORIGIN OF I.T..
      IIS=1
      DO 5 I=1,3
   5  NSW(I)=0
C NOW SET MS TO PICK SPECIAL INDIVIDUAL VECTORS TO GET THE ORIGIN RIGHT:
      MS=16
      IF (IIS.EQ.1) THEN
        IF (ORTHO) THEN
C
C          ORTHORHOMBIC         ********
C
          IF (FIRST(2:2) .EQ. '1' .AND. MID(2:2) .EQ. '1') THEN
C GROUP P21 21 2 (7 MORE ORTHO GROUPS & P42 N M ALSO HAVE MS=8):
            IF (LAST(2:2) .EQ. '0') MS=8
C GROUPS P (& I)21 21 21 (P N C 2 & A B M 2 ALSO HAVE MS=2):
            IF (LAST(2:2) .EQ. '1') MS=2
          ENDIF
C
C GROUPS P (& A & I)B A 2, PN A 21, PN N 2 (THE NEXT 5 ORTHO WITH MS=8):
C    (BUT NB THIS DOES TOO MANY WITH MIDA):
          IF ((MIDA .OR. (FIRN .AND. MIDN)) .AND. LAST2) THEN
            MS=8
C GROUPS PC A 21 AND P (& A & I) M A 2 (THE ONLY 4 GROUPS WITH MS=1):
            IF (FIRM .OR. FIRC) MS=1
          ENDIF
C
C GROUPS CM M A & CM C A (THE LAST 2 OF THE 8 ORTHOS WITH MS=8):
          IF (CFACE .AND. FIRM .AND. LASTA) MS=8
C
C GROUPS A B M 2 & P N C 2 (P&I 21 21 21 HAVE BEEN SET ALREADY):
          IF ((FIRN .OR. FIRB).AND.(MIDC .OR. MIDM)
     &     .AND. LAST2) MS=2
C
C GROUPS I B C A AND I M M A (IA 3, F41 3 2 & I A 3 D ALSO HAVE MS=7):
          IF (BODY .AND. LASTA) MS=7
C
C GROUP F D D 2 (THE ONLY GROUP WITH MS=6):
          IF (MIDD .AND. LAST2) MS=6
        ELSE IF (TETRA)THEN
C
C                 TETRAGONAL         *********
C
          IF (.NOT. SLASH)THEN
C GROUP 80 : I41 (AND OTHERS WHICH GET RESET LATER)
            IF (BODY .AND. NSCRW1.EQ.1) MS=9
            IF ((MID2.AND.LAST2) .AND. (NSCRW1.EQ.1.OR.NSCRW1.EQ.3))THEN
C GROUPS 91,92 : P41 2 2, P43 2 2 (AND OTHERS WHICH GET RESET LATER):
              MS=3
C GROUP 98 : I41 2 2 (96, P43 21 2 NEEDS MS=12 BUT IT IS NOT SET HERE):
              IF (BODY) MS=12
            ENDIF
C THE FOLLOWING LOOP LOOKS FOR 1,2 AND 3 - AND, NB, 0, MEANING "NO DIGIT":
C THESE SET:
C MS=9 FOR GROUPS 90,113 : P 4 21 2, P-4 21 M (AND OTHERS RESET LATER)
C MS=10 JUST FOR GROUP 90 : P41 21 2 (THE ONLY GROUP WITH MS=10)
C MS=11 JUST FOR GROUP 94 : P42 21 2 (114, P-4 21 C NEEDS MS=11 BUT NOT HERE)
C MS=12 JUST FOR GROUP 96 : P43 21 2 (98, I41 2 2 NEEDS MS=12 BUT ALREADY HAS)
            IF (MID21) THEN
              DO 815 I=1,4
              IF (NSCRW1 .EQ. I-1) MS=8+I
 815        CONTINUE
            ENDIF
C
            IF (LASTC) THEN
C GROUP 112 : P-4 2 C (AND 114 : P-4 21 C WHICH IS IMMEDIATELY RESET)
              IF (MID2) MS=3
C GROUP 114 : P -4 21 C
              IF (MID21) MS=11
            ENDIF
C
C GROUP I-4 2 D (THE ONLY GROUP WITH MS=13) (& OTHERS WHICH ARE LATER RESET):
            IF (LASTD) MS=13
C GROUP 116 : P-4 C 2 (AND 120 : I -4 C 2 WHICH IS LATER RESET)
            IF (MIDC .AND. MINUS) MS=3
            IF (MIDN) THEN
C GROUP P 42 N M (THE OTHER 8 FOR MS=8 ARE ORTHRHOMBIC):
              IF (NSCRW1 .EQ. 2) MS=8
C GROUPS P 4 N C & P -4 N 2 (THERE ARE 3 MORE WITH MS=9):
              IF (NSCRW1 .EQ. 0) MS=9
            ENDIF
C GROUP I 41 M D (THE ONLY GROUP WITH MS=15):
            IF (MIDM .AND. LASTD) MS=15
          ENDIF
C GROUPS P 4 B M, P42 B C, I4 C M, I41 C D, P -4 B 2, I -4 C 2, P4/N B M,
C        P4/M B M, P42/N B C, P42/M B C & I 4/M C M (& I41/A C D WHICH IS RESET
C        LATER):
          IF (MIDB .OR. BODY.AND.MIDC) MS=14
C GROUPS P42/N & P42/N N M:
          IF (FIRST(4:4).EQ.'N' .AND. (EMPTY(2) .OR. MIDN)) MS=14
C GROUPS P4/M N C & P4/N N C:
          IF (MIDN.AND.(FIRST(3:3).EQ.'M'.OR.FIRST(3:3).EQ.'N')) MS=14
          IF (FIRST(4:4).EQ.'A') THEN
C GROUP 141 : I 41/A M D (THE ONLY GROUP WITH MS=17)
            IF (MIDM) MS=17
C GROUP 142 : I 41/A C D (THE ONLY GROUP WITH MS=18)
            IF (MIDC) MS=18
          ENDIF
        ELSE
C
C ALL TYPES EXCEPT ORTHO AND TETRA:
C GROUPS P31 1 2, P31 2 1, P32 1 2, P32 1 2 (THE ONLY GROUPS GIVING MS=4 OR 5):
          IF (FIRDIG(3) .AND. .NOT. EMPTY(2)) THEN
            IF (NSCRW1 .EQ. 1) MS=4
            IF (NSCRW1 .EQ. 2) MS=5
          ENDIF
C CUBIC GROUPS F41 3 2 & IA 3 & IA 3 D (2 ORTHO GROUPS ALSO HAVE MS=7):
          IF (FACE .AND. NSCRW1.EQ.1 .OR. BODY .AND. FIRA) MS=7
        ENDIF
      ENDIF
C
*      IF (ONCARD('S','ORIG',A) THEN
*      CALL RDNUMS( for 3 values off card)
*      IIS=2
*      ENDIF
*** THIS WAS:
C       SHIFT TO ANOTHER ORIGIN
C
**        WRITE(ITO,2026)
**2026    FORMAT (' Type the shift vector:')
**        READ (ITI,1014) NV
**1014    FORMAT (A12)
**        JN=2
**        JM=0
**        DO 840 I=1,12
**        IF (JN.LT.14) IN(JN:JN)=NV(I:I)
**        IF (NV(I:I) .EQ. ' ') THEN
**          JM=JM+1
**          JN=4*JM+1
**        ENDIF
** 840    JN=JN+1
**        JP=0
**        DO 845 I=1,9,4
**        JP=JP+1
**        IO=I+1
**        LO=I+3
**        IF (IN(LO:LO).NE.'0') NSW(JP)=
**     1   (ICHAR(IN(IO:IO))-ICHAR('0'))*24/(ICHAR(IN(LO:LO))-ICHAR('0'))
** 845    CONTINUE
**      ENDIF
C
C
C       APPLY THE SHIFT OF ORIGIN TO ALL OPERATIONS.
C
** IIS IS ALWAYS 1 OR 2 NOW
      IF (CENTRE.OR.IIS.GT.0) THEN
        DO 823 K=1,3
          IF (IIS.NE.1)NSV(K,MS)=0
C MTSA HAS THE HALF ORIGIN SHIFT IN IT BY NOW:
          NSW(K)=NSV(K,MS)+MTSA(1,K)+NSW(K)
          NSW(K)=MOD(NSW(K)+24,24)
 823    CONTINUE
        DO 825 I=1,NG
        DO 825 J=1,3
          L=MTS(I,J)
          DO 822 K=1,3
 822      L=L-(MSS(NU,J,K)-MSS(I,J,K))*NSW(K)
 825      MTS(I,J)=MOD(L+144,24)
      ENDIF
C
C       NORMALIZATION OF CENTRING TYPE.
C
      DO 755 I=1,NG
      DO 755 J=1,3
C
      K=MOD(J,3)+1
      KI=MOD(K,3)+1
      IF (BODY .AND. J.EQ.1)THEN
        IF(MTS(I,1).GE.12.AND.MTS(I,2).GE.12.AND.MTS(I,3).GE.12)THEN
          DO 765 IJ=1,3
 765      MTS(I,IJ)=MTS(I,IJ)-12
        ENDIF
      ELSEIF (FACE .OR. NBR.EQ.J)THEN
        IF (MTS(I,K).GE.12 .AND. MTS(I,KI).GE.12)THEN
          DO 775 II=1,3
 775      MTS(I,II)=MTS(I,II)-MGET(II,J+4)
        ENDIF
      ENDIF
 755  CONTINUE
C
C OUTPUT:
C
C DIAGNOSTIC CCSL OUTPUT :
      IF (IOUT .EQ. 16) THEN
        WRITE (LPT,4000) SYSTEM(MSYS)
4000    FORMAT (/' Crystal family',29X,': ',A12)
        IF (CENTRE) THEN
          WRITE (LPT,4001) NT
4001      FORMAT (' Space group (centrosymmetric)',14X,':   ',A16)
        ELSE
          WRITE (LPT,4002) NT
4002      FORMAT (' Space group (noncentrosymmetric)',11X,': ',A16)
        ENDIF
        IF (IIS.EQ.1) THEN
          DO 422 I=1,3
          AMTSA(I)=NTEX(NSW(I)+1)
          IF (NSW(I).NE.0) AMTSA(I)(1:1)=' '
          IF (NSW(I).EQ.0) AMTSA(I)='   0'
 422      CONTINUE
          WRITE (LPT,4003) (AMTSA(I),I=1,3)
4003      FORMAT (' Shift vector (leads to the orig. of symb.):',3A4)
        ENDIF
C
        WRITE (LPT,4004) NT,MS,NGENS,NES,NET
4004    FORMAT (1X,A16,'MS=',I4,' NGENS=',I2,' NES=',3I4,' NET=',3I4)
        IR=-1
        WRITE (LPT,4005)
4005    FORMAT (/' Symmetry-operations'/)
 420    IR=IR+2
        IE=IR+1
        DO 425 I=IR,IE
        IU=I
        IO=MOD(IU,2)
        IF (IO.EQ.0)IO=2
        DO 425 J=1,3
        MO=MSS(I,J,1)+MSS(I,J,2)*3+MSS(I,J,3)*4+5
        TX(J,IO)=TEXB(MO)
 425    AMGES(J,IO)=NTEX(MTS(I,J)+1)
        IF (IE.LE.NG) WRITE (LPT,4006) IR,(TX(J,1),
     &  AMGES(J,1),J=1,3),IE,(TX(J,2),AMGES(J,2),J=1,3)
4006    FORMAT(2X,I2,'.',1X,2(A4,A4,' ,'),A4,A4,4X,I2,'.',1X,
     &  2(A4,A4,' ,'),A4,A4)
        IF (IE.GT.NG) WRITE (LPT,4006) IR,(TX(J,1),AMGES(J,1),J=1,3)
        IF (IE.LT.NG) GO TO 420
      ENDIF
C
C OUTPUT S CARD GENERATORS TO SCRATCH FILE:
      DO 8 I=1,NGENS
      WRITE (NSCR,5000) (TEXB(MSS(I,J,1)+MSS(I,J,2)*3+MSS(I,J,3)*4+5),
     & NTEX(MTS(I,J)+1),J=1,3)
5000  FORMAT ('S ',2(2A4,','),2A4)
   8  CONTINUE
C
C ADJUST NGENS IF FURTHER S CARDS ARE TO BE WRITTEN
C CENTROSYMMETRIC OPERATOR:
      IF (CENTRE) THEN
        NGENS=NGENS+1
        WRITE (NSCR,5001)
5001  FORMAT ('S -X, -Y, -Z')
      ENDIF
C
C NON-PRIMITIVE LATTICES:
      IF (NBR.LT.7) NGENS=NGENS+1
      IF (NBR.EQ.6) NGENS=NGENS+2
      IF (AFACE .OR. FACE) WRITE (NSCR,5002)
5002  FORMAT ('S X, 1/2+Y, 1/2+Z')
      IF (BFACE .OR. FACE) WRITE (NSCR,5003)
5003  FORMAT ('S 1/2+X, Y, 1/2+Z')
      IF (CFACE .OR. FACE) WRITE (NSCR,5004)
5004  FORMAT ('S 1/2+X, 1/2+Y, Z')
      IF (BODY) WRITE (NSCR,5005)
5005  FORMAT ('S 1/2+X, 1/2+Y, 1/2+Z')
      IF (RHOMB) WRITE (NSCR,5006)
5006  FORMAT ('S 2/3+X, 2/3+Y, 1/3+Z'/'S 1/3+X, 2/3+Y, 2/3+Z')
      REWIND (NSCR)
      RETURN
      END
C
C
C
C
C LEVEL 3      SUBROUTINE SPCSET(N)
      SUBROUTINE SPCSET(N)
C
C *** SPCSET updated by JCM 14 Nov 89 ***
C
CX
CC 14B
CH Defines the "space" in which coordinates will be given for plotting.
CA On entry N is the number of the space in which subsequent "plot"
CA            coordinates will be given.
C
CD The current space is held in NSPCE in COMMON /PLTRAN/.
CD  Coordinate systems useful in most plotting applications:
CD        1=Plotter (actual coordinates on a particular graphical output device)
CD        2=CCSL (the coordinates in which the programs are written)
CD Coordinate sytems 3 to 7 are for user applications; for example in plotting
CD Fourier maps they are used as follows:
CD        3=Picture (one "picture" which contains one section of the map)
CD        4=Map (The crystallographically related axes of the Fourier
CD               calculation).
CD        5=Character type 1 (in contouring, the text under the map)
CD        6=Character type 2 ( the title over the map)
CD        7=Character type 3 (the contour list panel)
C
CD A new conversion matrix is set up into PTRAN(,,1).
CD It should take a point expressed in current coordinates (space N) into
CD plotter coordinates (space 1).
C
CP PLTRIN  must have been used to set up matrices defining the
CP transformation from space N to "plotter" space.
C
CP For plotting FOURIERS:
CP Matrix 1 takes CCSL into plotter
CP Matrix 2 takes picture into CCSL
CP Matrix 3 takes map into picture
CP Matrix 4 takes char 1 into picture
CP Matrix 5 takes char 2 into picture (if required)
CP Matrix 6 takes char 3 into picture (if required)
CP
CP These must have been set up initially.  They are mostly unchanging,
CP but to move from one picture to the next we alter column 3 of matrix 2.
C
      DIMENSION PTEMP(2,3)
/PLTRAN/
C
C CHECK PLAUSIBLE N:
      IF (N .LE. 0 .OR. N .GT. MAXSP) CALL ERRIN2(N,0,
     & 'cannot set space','in SPCSET')
C
      IF (N .GT. 1) GO TO 2
      CALL GMZER(PTRAN(1,1,1),2,3)
      CALL GMUNI(PTRAN(1,1,1),2)
      GO TO 101
C
C ANY SPACE OTHER THAN 1:
   2  M=N-1
      CALL GMEQ(PMTRIX(1,1,M),PTRAN(1,1,1),2,3)
C
C HAVE WE REACHED PLOTTER SPACE YET?
   3  M=NTRAN(M)-1
      IF (M .LT. 0) CALL ERRIN2(N,0,'Space',
     & 'in plotting not available - check setting up')
      IF (M .EQ. 0) GO TO 101
      CALL PMTMUL(PMTRIX(1,1,M),PTRAN(1,1,1),PTEMP)
      CALL GMEQ(PTEMP,PTRAN(1,1,1),2,3)
      GO TO 3
C
 101  NSPCE=N
      RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE SPGNAM(N,NAME)
      SUBROUTINE SPGNAM(N,NAME)
C
C *** SPGNAM by JCM 30 Aug 92 ***
C
CX
CC 1A
CH Decodes space group symbol or integer from S GRUP card
CA On entry N is the space group number,
CA            or, if 0, means that the group symbol is given.
CA On exit NAME is 16 characters of short space group symbol.
CP On entry the card is in /SCRACH/
C
      CHARACTER *16 NAME
/SCRACH/
      CHARACTER *16 SGSYMB(230),TRIMON(15),ORTHO(59),TETRA(68)
      CHARACTER *16 TRIHEX(52),CUBIC(36)
      EQUIVALENCE (SGSYMB(1),TRIMON(1)),(SGSYMB(16),ORTHO(1))
      EQUIVALENCE (SGSYMB(75),TETRA(1)),(SGSYMB(143),TRIHEX(1))
      EQUIVALENCE (SGSYMB(195),CUBIC(1))
      DATA TRIMON/'P1','P-1','P2','P21','C2','PM','PC','CM','CC','P2/M',
     & 'P21/M','C2/M','P2/C','P21/C','C2/C'/
      DATA ORTHO/'P2 2 2','P2 2 21','P21 21 2','P21 21 21','C2 2 21',
     & 'C2 2 2','F2 2 2','I2 2 2','I21 21 21','PM M 2',
     & 'PM C 21','PC C 2','PM A 2','PC A 21','PN C 2',
     & 'PM N 21','PB A 2','PN A 21','PN N 2','CM M 2',
     & 'CM C 21','CC C 2','AM M 2','AB M 2','AM A 2',
     & 'AB A 2','FM M 2','FD D 2','IM M 2','IB A 2',
     & 'IM A 2','PM M M','PN N N','PC C M','PB A N',
     & 'PM M A','PN N A','PM N A','PC C A','PB A M',
     & 'PC C N','PB C M','PN N M','PM M N','PB C N',
     & 'PB C A','PN M A','CM C M','CM C A','CM M M',
     & 'CC C M','CM M A','CC C A','FM M M','FD D D',
     & 'IM M M','IB A M','IB C A','IM M A'/
      DATA TETRA/'P4','P41','P42','P43','I4',
     & 'I41','P-4','I-4','P4/M','P42/M',
     & 'P4/N','P42/N','I4/M','I41/A','P4 2 2',
     & 'P4 21 2','P41 2 2','P41 21 2','P42 2 2','P42 21 2',
     & 'P43 2 2','P43 21 2','I4 2 2','I41 2 2','P4 M M',
     & 'P4 B M','P42 C M','P42 N M','P4 C C','P4 N C',
     & 'P42 M C','P42 B C','I4 M M','I4 C M','I41 M D',
     & 'I41 C D','P-4 2 M','P-4 2 C','P-4 21 M','P-4 21 C',
     & 'P-4 M 2','P-4 C 2','P-4 B 2','P-4 N 2','I-4 M 2',
     & 'I-4 C 2','I-4 2 M','I-4 2 D','P4/M M M','P4/M C C',
     & 'P4/N B M','P4/N N C','P4/M B M','P4/M N C','P4/N M M',
     & 'P4/N C C','P42/M M C','P42/M C M','P42/N B C','P42/N N M',
     & 'P42/M B C','P42/M N M','P42/N M C','P42/N C M','I4/M M M',
     & 'I4/M C M','I41/A M D','I41/A C D'/
      DATA TRIHEX/'P3','P31','P32','R3','P-3',
     & 'R-3','P3 1 2','P3 2 1','P31 1 2','P31 2 1',
     & 'P32 1 2','P32 2 1','R3 2','P3 M 1','P3 1 M',
     & 'P3 C 1','P3 1 C','R3 M','R3 C','P-3 1 M',
     & 'P-3 1 C','P-3 M 1','P-3 C 1','R-3 M','R-3 C',
     & 'P6','P61','P65','P62','P64',
     & 'P63','P-6','P6/M','P63/M','P6 2 2',
     & 'P61 2 2','P65 2 2','P62 2 2','P64 2 2','P63 2 2',
     & 'P6 M M','P6 C C','P63 C M','P63 M C','P-6 M 2',
     & 'P-6 C 2','P-6 2 M','P-6 2 C','P6/M M M','P6/M C C',
     & 'P63/M C M','P63/M M C'/
      DATA CUBIC/'P2 3','F2 3','I2 3','P21 3','I21 3',
     & 'PM 3','PN 3','FM 3','FD 3','IM 3',
     & 'PA 3','IA 3','P4 3 2','P42 3 2','F4 3 2',
     & 'F41 3 2','I4 3 2','P43 3 2','P41 3 2','I41 3 2',
     & 'P-4 3 M','F-4 3 M','I-4 3 M','P-4 3 N','F-4 3 C',
     & 'I-4 3 D','PM 3 M','PN 3 N','PM 3 N','PN 3 M',
     & 'FM 3 M','FM 3 C','FD 3 M','FD 3 C','IM 3 M','IA 3 D'/
C
      IF (N .GT. 0) THEN
        NAME=SGSYMB(N)
      ELSE
        I=7
   1    IF (ICARD(I:I) .EQ. ' ') THEN
          I=I+1
          IF (I .LE. 80) GO TO 1
          NAME=' '
        ELSE
          NAME=ICARD(I:I+15)
        ENDIF
      ENDIF
      RETURN
      END
C
C
C
C
C LEVEL 2      SUBROUTINE SPHARM(Y,T,P,LMAX,NUM)
      SUBROUTINE SPHARM(Y,T,P,LMAX,NUM)
C
C *** SPHARM by PJB Apr 84 ***
C
CX
CC 9C
CH Calculates spherical harmonics.
CA  On entry T and P are the spherical polar angles theta and phi
CA             defining the orientation of the spherical harmonic function
CA             (in radians).
CA           LMAX is the number of different l values to calculate
CA             (LMAX=maximum l +1)
CA           NUM is the total number of spherical harmonic functions
CA              which will be calculated (NUM=LMAX(LMAX+1)/2)
CA On exit  Y(N) is complex and is set to the value of the Nth
CA              spherical harmonic, these being in sets of constant l
CA              arranged in order of increasing l with m running from
CA              0 to l within each l value.
CN Only values for positive m are stored
C
      COMPLEX Y(NUM),EXPHI(20)
/CONSTA/
C
      D = 1./SQRT(TWOPI)
      C = COS(T)
      S = SIN(T)
      Y(1) = CMPLX(SQRT(0.5),0.)
      IF (LMAX .EQ. 1) GO TO 6
      Y(2) = CMPLX(SQRT(1.5),0.)*C
      Y(3) = CMPLX(-SQRT(.75),0.)*S
      IF (LMAX .LT. 3) GO TO 6
      LL = LMAX-2
      N = 2
      DO 1 L = 1,LL
      A = SQRT(FLOAT((2*L+1)*(2*L+3)))
      B = SQRT(FLOAT((2*L+1)*(2*L-1)))
      MAX = L+1
      DO 2 MM = 1,MAX
      M = MM-1
      Y(N+L+1) = C*Y(N)
      IF (L .NE. M) Y(N+L+1) = Y(N+L+1)-SQRT(FLOAT((L-M)*(L+M)))*Y(N-L)
     & /B
      Y(N+L+1) = Y(N+L+1)*A/SQRT(FLOAT((L+1-M)*(L+1+M)))
      N = N+1
    2 CONTINUE
C
      Y(N+L+1) = CMPLX(0.,0.)
      IF (S .LT. .0001) GO TO 1
      Y(N+L+1) = -(FLOAT(2*L)*C*Y(N+L)/S) - SQRT(FLOAT(4*L+2))*Y(N+L-1)
      Y(N+L+1) = Y(N+L+1)/SQRT(FLOAT(2*L+2))
    1 CONTINUE
C
    6 CALL TRIG(EXPHI,P,LMAX)
      N = 1
C
      DO 4 L = 1,LMAX
C134 Take care of phase convention (-1)**M
      SIGND=D
      DO 5 M = 1,L
      Y(N) = Y(N)*EXPHI(M)*SIGND
      SIGND=-SIGND
    5 N = N+1
    4 CONTINUE
      RETURN
      END
C
C
C
C
C LEVEL 8      SUBROUTINE SPHELI(IM,MODE)
      SUBROUTINE SPHELI(IM,MODE)
C
C *** SPHELI updated by PJB 30-May-95 ***
C
CX
CC 17B
CH Imposes perpendicularity on the two components of a helix.
CA On entry IM labels the magnetic atom in question
CA MODE = 0  For the setting up entry
CA MODE = 1  First least squares entry
CA MODE = 2  On entries after least squares cycles
C
      DIMENSION C(4),KK(4),PERP(3)
      LOGICAL TESTOV
/ATNAM/
/MAGDAT/
/PHASE/
/SOURCE/
%      DATA NPSI/%PSIS%/
C
      IF (MODE.LT.2) THEN
C CHECK PERPENDICULARITY
        TEST=SCALPR(SPIND(1,1,1,IM),SPIND(1,1,2,IM))
        IF (ABS(TEST).GT..0005) THEN
          CALL ERRRE2(TEST,-1,
     & 'Axes of '//ATNAME(JMAGAT(IM))//' helix not perpendicular:'//
     &  ' scalar product =',' ')
C FORCE SECOND AXIS TO BE PERPENDICULAR TO FIRST
          CALL VECPRD(SPIND(1,1,1,IM),SPIND(1,1,2,IM),PERP)
          CALL UNIVEC(PERP,D)
          CALL VECPRD(PERP,SPIND(1,1,1,IM),SPIND(1,1,2,IM))
          ANGM(3,IM)=DEGREE(ACOS(SPIND(3,1,2,IM)))
          ANGM(4,IM)=DEGREE(ATAN2(SPIND(2,1,2,IM),SPIND(1,1,2,IM)))
        ENDIF
      ENDIF
      IF (MODE.GT.0) THEN
C CALCULATE THE COEFFICIENTS C(N) OF THE PERPENDICULARITY CONSTRAINT
        N=0
        M=0
        DO 1 II=1,2
        JJ=II+1
        IF (JJ.GT.2) JJ=1
        DO 1 J=2,3
        N=N+1
        CC=0
C  GET THE PARAMETER SPECS
        DO 2 I=1,3
        CC=CC+SPIND(I,1,JJ,IM)*SPIND(I,J,II,IM)
    2   CONTINUE
        IF (TESTOV(1.,CC)) GO TO 1
        M=M+1
        C(M)=CC
C 106 Added JPHASE,JSOURC instead of 1,1 in KPAK
        KK(M)=KPAK(2,IM,12+NPSI+N,JPHASE,JSOURC)
    1   CONTINUE
C
        IF (M.LE.1) GO TO 100
C SCALED SHIFTS MUST ADD TO ZERO
C Removed 3rd August 1999
C        C(1)=-C(1)
C  ADD NEW OR REPLACE THE EXISTING CONSTRAINT
        IF (MODE.EQ.1) THEN
          CALL ADDCON(M,KK,C,4)
        ELSE
          CALL RELCON(M,KK,C,4)
        ENDIF
      ENDIF
  100 RETURN
      END
C
C
C
C
C LEVEL 2      SUBROUTINE SPHPOL(ANG1,ANG2,SD,MODE)
      SUBROUTINE SPHPOL(ANG1,ANG2,SD,MODE)
C
C *** SPHPOL by PJB 24 Jan 89 ***
C
CX
CC 17A
CH Sets up spherical polar spin directions for magnetic structures.
CA On entry ANG1 holds the first spherical polar angle (with Z) in degrees
CA          ANG2 holds the second spherical polar angle (with X) in degrees
CA          MODE is 1 if the 3 directions alone are wanted,
CA                  3 if the derivative directions are also wanted.
C
CA On exit  SD always holds in its first 3 elements the components of the
CA             spin direction on the X, Y, Z (standard orthogonal) axes.
CA             If MODE=3 it also holds elements for the LSQ derivatives in
CA             columns 2 and 3.
C
      DIMENSION SD(3,MODE)
C
      SA1=SIN(RADIAN(ANG1))
      SA2=SIN(RADIAN(ANG2))
      CA1=COS(RADIAN(ANG1))
      CA2=COS(RADIAN(ANG2))
      SD(1,1)=SA1*CA2
      SD(2,1)=SA1*SA2
      SD(3,1)=CA1
C  AND THE DIFFERENTIALS
      IF (MODE .EQ.3)THEN
        SD(1,2)=RADIAN(CA1*CA2)
        SD(2,2)=RADIAN(CA1*SA2)
        SD(3,2)=RADIAN(-SA1)
        SD(1,3)=-RADIAN(SA1*SA2)
        SD(2,3)=RADIAN(SA1*CA2)
        SD(3,3)=0.
      ENDIF
C
      RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE SPLINE(N,X,F,D)
      SUBROUTINE SPLINE(N,X,F,D)
C
C *** SPLINE from HARWELL TB04A 21 May 85 ***
C
CX
CC 9A
CH Sets up a cubic spline to fit a curve.
CA On entry N is the number of points on a curve
CA          F(I) are the N function values at the N points X(I)
CA          D(I) is set to the derivative if the spline at the point I
CA              for all N points.
CN Uses working space in COMMON /SCRAT/
CN For further details see the description of the Harwell Library
C
      DIMENSION X(N),F(N),D(N)
/IOUNIT/
      COMMON /SCRAT/A(2000)
C
C F(I) ARE THE FUNCTION VALUES AT THE POINTS X(I) FOR I=1,N AND
C THE SPLINE DERIVATIVES D(I) ARE FOUND.  THE DIMENSION OF A MUST
C NOT BE LESS THAN 3*N.
C
      DO 5 I=2,N
      IF (X(I)-X(I-1)) 1,1,5
   1  WRITE(LPT,3000) I
3000  FORMAT(/'  ERROR ** in SPLINE - X',I3,' out of order')
      A(1)=1.
      GO TO 100
C
   5  CONTINUE
C
      DO 2 I=1,N
      J=2
      IF (I-1) 6,10,6
   6  J=N-1
      IF (I.EQ.N) GO TO 10
      H1=1./(X(I)-X(I-1))
      H2=1./(X(I+1)-X(I))
      A(3*I-2)=H1
      A(3*I-1)=2.*(H1+H2)
      A(3*I)=H2
      D(I)=3.0*(F(I+1)*H2*H2+F(I)*(H1*H1-H2*H2)-F(I-1)*H1*H1)
      GO TO 2
C
  10  H1=1./(X(J)-X(J-1))
      H2=1./(X(J+1)-X(J))
      A(3*I-2)=H1*H1
      A(3*I-1)=H1*H1-H2*H2
      A(3*I)=-(H2*H2)
      D(I)=2.*(F(J)*(H2*H2*H2+H1*H1*H1)-F(J+1)*H2*H2*H2-F(J-1)*H1*H1*H1)
   2  CONTINUE
      P=A(4)/A(1)
      A(5)=A(5)-P*A(2)
      A(6)=A(6)-P*A(3)
      D(2)=D(2)-P*D(1)
      DO 4 I=3,N
      K=3*I-4
      P=A(K+2)/A(K)
      A(K+3)=A(K+3)-P*A(K+1)
      D(I)=D(I)-P*D(I-1)
      IF (I.NE.N-1) GO TO 4
      P=A(K+5)/A(K)
      A(K+5)=A(K+6)-P*A(K+1)
      A(K+6)=A(K+7)
      D(N)=D(N)-P*D(N-2)
   4  CONTINUE
C
      D(N)=D(N)/A(3*N-1)
      DO 7 I=3,N
      J=N+2-I
   7  D(J)=(D(J)-A(3*J)*D(J+1))/A(3*J-1)
      D(1)=(D(1)-D(2)*A(2)-D(3)*A(3))/A(1)
      A(1)=0.
 100   RETURN
      END
C
C
C
C
C LEVEL 1      FUNCTION SPLINT(IX,N,U,S,D,X)
      FUNCTION SPLINT(IX,N,U,S,D,X)
C
C *** SPLINT from HARWELL TG01B 21 May 85 ***
C
CX
CC 9C
CH Evaluates a cubic spline given spline values and first derivative
CH values at the given knots.
C
C
CA On entry IX allows the caller to take advantage of spline parameters
CA            set on a previous call in cases when an X point follows
CA            the previous X point.
CA      If IX < 0 the whole range is searched for knot interval;
CA      If IX > 0 it is assumed that X is greater than the X of the
CA      previous call and search started from there.
CA           N=The number of knots.
CA           U holds the knots.
CA           S holds the spline values.
CA           D holds the first derivative values of the spline at the
CA             knots.
CA           X=the point at which the spline value is required.
C
CP A call of SPLINE must have set up the knots in D.
C
CN The spline value is defined as zero outside the knot range, which
CN is extended by a rounding error for the purpose.
C
C     ALLOWABLE ROUNDING ERROR ON POINTS AT EXTREMES OF KNOT RANGE
C     IS 2**IEPS*MAX(\U(1)\,\U(N)\).
      DIMENSION U(N),S(N),D(N)
      DATA IFLG,IEPS/0,-19/
      SAVE J
C
C       TEST WHETHER POINT IN RANGE.
      IF(X.LT.U(1)) GO TO 3
      IF(X.GT.U(N)) GO TO 4
C
C       JUMP IF KNOT INTERVAL REQUIRES RANDOM SEARCH.
      IF(IX.LT.0.OR.IFLG.EQ.0) GO TO 12
C       JUMP IF KNOT INTERVAL SAME AS LAST TIME.
      IF(X.LE.U(J+1)) GO TO 8
C       LOOP TILL INTERVAL FOUND.
    1 J=J+1
   11 IF(X.GT.U(J+1)) GO TO 1
      GO TO 7
C
C       ESTIMATE KNOT INTERVAL BY ASSUMING EQUALLY SPACED KNOTS.
   12 J=NINT(ABS(X-U(1))/(U(N)-U(1))*(N-1)+1)
C       ENSURE CASE X=U(N) GIVES J=N-1.
      J=MIN0(J,N-1)
C       INDICATE THAT KNOT INTERVAL INSIDE RANGE HAS BEEN USED.
      IFLG=1
C       SEARCH FOR KNOT INTERVAL CONTAINING X.
      IF(X.GE.U(J)) GO TO 11
    2 J=J-1
      IF(X.LT.U(J)) GO TO 2
C
C       CALCULATE SPLINE PARAMETERS FOR JTH INTERVAL.
    7 H=U(J+1)-U(J)
      Q1=H*D(J)
      Q2=H*D(J+1)
      SS=S(J+1)-S(J)
      B=3.0*SS-2.0*Q1-Q2
      A=Q1+Q2-2.0*SS
C
C       CALCULATE SPLINE VALUE.
    8 Z=(X-U(J))/H
      SPLINT=((A*Z+B)*Z+Q1)*Z+S(J)
      GO TO 100
C
C       TEST IF X WITHIN ROUNDING ERROR OF U(1).
   3  IF(X.LE.U(1)-2.0**IEPS*AMAX1(ABS(U(1)),ABS(U(N)))) GO TO 101
      J=1
      GO TO 7
C       TEST IF X WITHIN ROUNDING ERROR OF U(N).
   4  IF(X.GE.U(N)+2.0**IEPS*AMAX1(ABS(U(1)),ABS(U(N)))) GO TO 101
      J=N-1
      GO TO 7
C
C POINTS OUTSIDE RANGE:
 101  IFLG=0
      SPLINT=0.0
 100  RETURN
      END
C
C
C
C
C LEVEL 3      SUBROUTINE STATIS(MODE)
      SUBROUTINE STATIS(MODE)
C
C *** STATIS updated by PJB 13 Feb 2001 ***
C
CX
CC 2B
CH Calculates means and other statistics for a set of measurements of a
CH single quantity.
CA MODE is an integer indicating which of the two sets of data held in
CA /REFS/ is to be used
CA  MODE=Negative number initialise by clearing SUMS to zero
CA  MODE=0 read and average both sets
CA  MODE=1 read and average the first block of data in REFS
CA  MODE=2 read and average the second block
CP INPUAR to fill in the data in /REFS/
CP The vector SUMS in COMMON /STATS/ is used to accumulate quantities
CA needed for statistical output. It should be cleared by calling
CP  STATIS(-1) before reading the data
CP   SUMS(1) holds the sum of the observations
CP   SUMS(2)       the sum of the standard deviations
CP   SUMS(3)       the sum of the means of repeated measurements
CP   SUMS(4)       the sum of the standard deviations of repeated measurements
CP   SUMS(5)       the sum for repeated observations of their weighted squares
CP                 minus the weighted square of the mean
CP   SUMS(6)       the number of repeated observations
CP   SUMS(7)       the sum of the means of equivalent observations
CP   SUMS(8)       the sum of the standard deviations of equivalent observations
CP   SUMS(9) as SUM(5) for equivalent observations
CP   SUMS(10) holds the number of equivalent observations
CP   SUMS(11)       the sum of all weighted observations
CP   SUMS(12)       the sum of the means for all observations
C
/REFS/
/STATS/
C
C TO INITIALISE
      IF (MODE.LT.0) THEN
        CALL GMZER(SUMS,12,1)
        GO TO 100
      ELSE IF (MODE.NE.0) THEN
        MS=MODE
        ME=MS
      ELSE
        MS=1
        ME=2
      ENDIF
C
      DO 4 IS=MS,ME
      CALL WTMEAN(X,DX,0,WRK3)
      CALL WTMEAN(X,DX,0,WRK1)
      IR=1
      II=0
    2 L=LL(IR,IS)
      IF (L.EQ.3) GO TO 3
      IE=II+L
      IB=II+4
      CALL WTMEAN(X,DX,0,WRK2)
      DO 1 I=IB,IE,ITEMS
C WRK1 IS THE WORKING SPACE FOR STATISTICS OF ALL MEASUREMENTS TAKEN
C INDIVIDUALLY
      CALL WTMEAN(R(I,IS),R(I+1,IS),2,WRK1)
C WRK2 IS THE WORKING SPACE FOR STATISTICS OF REPEATED MEASUREMENTS
      CALL WTMEAN(R(I,IS),R(I+1,IS),2,WRK2)
      SUMS(1)=SUMS(1)+R(I,IS)
      SUMS(2)=SUMS(2)+R(I+1,IS)
    1 CONTINUE
      II=II+L
      CALL WTMEAN(R(II+1,IS),R(II+2,IS),-1,WRK2)
C WRK3 IS THE WORKING SPACE FOR STATISTICS OF EQUIVALENTS AFTER AVERAGING
C REPEATED MEASUREMENTS
      CALL WTMEAN(R(II+1,IS),R(II+2,IS),2,WRK3)
      IF (WRK2(4).GT.1.01) THEN
        SUMS(3)=SUMS(3)+R(II+1,IS)
        SUMS(4)=SUMS(4)+R(II+2,IS)
        SUMS(5)=SUMS(5)+WRK2(2)-R(II+1,IS)*WRK2(1)
C        SUMS(6)=SUMS(6)+WRK2(4)
        SUMS(6)=SUMS(6)+1.
      ENDIF
        SUMS(11)=SUMS(11)+1.
        SUMS(12)=SUMS(12)+R(II+1,IS)
C  LEAVE SPACE FOR MEANS
      II=II+2
      IR=IR+1
      GO TO 2
C
C  FINISH ONE INDEPENDENT MEASUREMENT
    3 CALL WTMEAN(AMEAN(IS),DEV(IS),-1,WRK1)
      CALL WTMEAN(AMN,DEVN,-1,WRK3)
      IF (WRK1(4).GT.1.01) THEN
        SUMS(7)=SUMS(7)+AMEAN(IS)
        SUMS(8)=SUMS(8)+DEV(IS)
        SUMS(9)=SUMS(9)+WRK3(2)-AMN*WRK3(1)
        SUMS(10)=SUMS(10)+1.
c        SUMS(10)=SUMS(10)+WRK3(4)
      ENDIF
    4 CONTINUE
C
      IF (MODE .EQ. 0) THEN
        RAT=AMEAN(2)/AMEAN(1)
        DRAT=SQRT((DEV(1)/AMEAN(1))**2+(DEV(2)/AMEAN(2))**2)
        CALL WTMEAN(RAT,DRAT,2,WRK1)
        CALL WTMEAN(X,DX,0,WRK2)
        DO 5 I=1,2
        CALL WTMEAN(AMEAN(I),DEV(I),2,WRK2)
    5   CONTINUE
        CALL WTMEAN(X,DX,-1,WRK2)
      ENDIF
  100 RETURN
      END
C
C
C
C
C LEVEL 3      SUBROUTINE STATPA(IENTRY,ILEAVE)
      SUBROUTINE STATPA(IENTRY,ILEAVE)
C
C *** STATPA  rewritten by PJB August 2016 ***
CX
CC 2B
CH Calculates means and other statistics for polarisation matrix element
CH measurements
C
CA START is a logical set to TRUE 1initially
CA       STATPA returned as FALSE unless the next call to INPUAR will return
CA       an independent reflection
CP INPSYM to read  a Q PSYM card and set up the averaging mode
CP INPUAR is called between each call to STATPA to fill in the data in /REFS/
CP The vector SUMS in COMMON /STATS/ is used to accumulate quantities
CA needed for statistical output.
C
CD   For each independent component ICOMP of the polarisation matrix
CD   SUMS(1,ICOMP) accumulates the sum of squared deviations from the means
CD                 forindependent reflections
CD   SUMS(2,ICOMP) accumulates the number of observations
CD   SUMS(3,ICOMP) accumulates the number of independent reflections
C
      LOGICAL FIRST,REV
/IOUNIT/
/REFS/
/SCRACH/
/STATP/
/SYMMAG/
C
      NSLOTS=NDOM*MAXP
      IF (IENTRY.EQ.1) THEN
C Initialize averages: There is one slot for each independent component and domain
        DO 20 I=1,NSLOTS
        CALL WTMEAN(Ax,Bx,0,WRK(1,I))
   20   CONTINUE
      ENDIF
C SECTION TO MAKE THE AVERAGES from data in refs
      IS=1
      IR=1
      II=0
   11 L=LL(IR,IS)
      IF (L.EQ.3) GO TO 13
      IE=II+L
      IF (.NOT. FIRST) THEN
Check whether index belongs to a different domain
         CALL EQVEC(HLABEL,R(II+1,1),1,J,0)
         IF (J.GT.1)  then
           CALL GMEQ(R(II+1,1),HLABEL,3,1)
         ELSE
           CALL GMEQ(R(II+1,1),HLABEL,3,1)
         ENDIF
        ELSE
         CALL GMEQ(R(II+1,1),HLABEL,3,1)
         FIRST=.FALSE.
      ENDIF
      IDOM=INDOM(HLABEL)
      IB=II+4
      DO 12 I=IB,IE,ITEMS
      ICOMP=NINT(R(I+2,IS))
      IF (ICOMP.LT.0) ICOMP=9-ICOMP
      IP=IPAR(ICOMP)
      REV = (IP.LT.0)
      ROBS=R(I,IS)
      IF (IP.NE.0) THEN
        IF (REV) IP=-IP
C Fix the averaging slot from component and domain number
        ISLOT=(IDOM-1)*MAXP + IP
        IF (REV) ROBS=-ROBS
C WRK(I,ISLOT) IS THE WORKING SPACE FOR STATISTICS OF THIS COMPONENT and domain
        CALL WTMEAN(Robs,R(I+1,IS),2,WRK(1,ISLOT))
      ELSE
C STATISTICS FOR ZERO ELEMENTS
        IF (ICOMP.GT.9) ROBS=-ROBS
        CALL WTMEAN(Robs,R(I+1,IS),2,ZSUMS)
      ENDIF
   12 CONTINUE
      II=II+L
C  LEAVE SPACE FOR MEANS
      II=II+2
      IR=IR+1
C go to read next block
      GO TO 11
C
C  Here when the indices or component number change
C  do the average over repeated measurements
C  CHECK WHETHER THE REFLECTION ALSO CHANGES
   13 IF (MOD(JJ(IR,IS),100).LT.4+INC) THEN
C THE REFLECTION CHANGES
        CALL GMEQ(R(II+1,1),HLABEL,3,1)
        NPOLN=0
C Make the averages for components and domains
        DO 14 ISLOT=1,NSLOTS
          NOBS=NINT(WRK(4,ISLOT))
          IF (NOBS.EQ. 0) GO TO 14
          NPOLN=NPOLN+1
C Save slot number for this result
          IPOLN(NPOLN)=ISLOT
          CALL WTMEAN(AMEAN(NPOLN),DEV(NPOLN),-1,WRK(1,ISLOT))
   14   CONTINUE
        CALL JGMEQ(K(1,1),KSAVE,3,1)
        ILEAVE=1
      else
        ILEAVE=0
      ENDIF
      RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE STERMS(G,R,H,S)
      SUBROUTINE STERMS(G,R,H,S)
C
C *** STERMS by PJB 17 Jan 85 ***
C
CX
CC 9C
CH Calculates a term in the spherically symmetric form factor summation,
CH for a 3D averaged form-factor involving Sk and r only.
C
/CONSTA/
C
      FOURPI = 4.*PI
C  TEST FOR SPECIAL CASES:
      IF (H .LT .001) GO TO 1
      IF (S .LT. .001) GO TO 2
      IF (ABS(H-S) .LT. .001) GO TO 3
      G = H*COS(H*R)*SIN(S*R) - S*COS(S*R)*SIN(H*R)
      G = FOURPI*G/(H*S*(S*S-H*H))
      GO TO 100
    1 IF (S .LT. .001) GO TO 4
      G = SIN(S*R) - S*R*COS(S*R)
      G = FOURPI*G/S**3
      GO TO 100
    2 G = SIN(H*R) - H*R*COS(H*R)
      G = FOURPI*G/H**3
      GO TO 100
    3 G = -(SIN((H+S)*R)) + (H+S)*R
      G = TWOPI*G/(H+S)*H*S
      GO TO 100
    4 G = (FOURPI*R**3)/3.
 100  RETURN
      END
C
C
C
C
C LEVEL 7      SUBROUTINE STGPLT
      SUBROUTINE STGPLT
C
C *** STGPLT NEW by PJB c4.38 July 2017 for FOUGPL ***
C
CX
CC 14A
CH Sets up quntities needed when plotting maps using GNUPLOT;
C
CP Plotting of a Fourier map must be set up by SETFOU.  In particular:
CP NX=number of x values wanted for plotted points
CP NY=number of y values wanted for plotted points
CP The map axis lengths AXLEN and the angle PHI between them
CP are set by USYM.
CP There is a title in ITITLE, of length NTITLE, read by INPUTN
CN On exit COMMON GPLMAP holds the geometry needed to plot the map
CD
C
/CONTUR/
/GPLMAP/
/IOUNIT/
/MAPDA/
/NTITL/
/TITLE/
C
C SIZE OF THE MAP IN ANGSTROMS
      spanx=(OUTLIM(2,1)-OUTLIM(1,1))
      spany=(OUTLIM(2,2)-OUTLIM(1,2))
C lengths of cryst axes of map
      XLEN=AXMAP(1)*SPANX
      YLEN=AXMAP(2)*spanY
      PROJ=XLEN*COSPHI
C SIZE OF MAP  GRAPH 0 TO 1
      WIDMAP=YLEN+ABS(PROJ)
      HGTMAP=XLEN*SINPHI
      XPROJ=PROJ/WIDMAP
      WIDBOX=1.-ABS(XPROJ)
      FRACXY=HGTMAP*COSPHI/(SINPHI*WIDMAP)
      FRACW=1.-ABS(FRACXY)
C XORIGIN dependS ON sign of cosphi
      XORIG=0.
      IF (COSPHI .LT. 0) XORIG=-XPROJ
C scale the U matrix
C      CALL GMSCA(U(1,1),UU(1,1),1./SPANX,3,1)
C      CALL GMSCA(U(1,2),UU(1,2),1./SPANY,3,1)
C Transform for cryst map to gnuplot  graph X,Y
      TMAP(1,1)=FRACXY/spanx
      TMAP(1,2)=FRACW/spany
      TMAP(1,3)= XORIG - (OUTLIM(1,1)*FRACXY/spanx) -
     &(OUTLIM(1,2)*FRACW/spany)
      TMAP(2,1)=-1./spanx
      TMAP(2,2)=0.
      TMAP(2,3) = OUTLIM(2,1)/spanx
      write (lpt,1000) ((tmap(i,j),j=1,3),i=1,2)
 1000 format ('Map to graoh transform',3f8.4/21x,3f8.4)
C
      RETURN
      END
C
C
C
C
C LEVEL 7      SUBROUTINE STLSFW
      SUBROUTINE STLSFW
C
C *** STLSFW by JCM 17 Nov 84 ***
C
CX
CC 7A
CH Sets up the main program FWLSQ to perform LSQ on Forsyth & Wells
CH scattering factor coefficients.
C
CI Reads in and interprets an I card and an L VALS card giving
CI the 5, 7 or 9 initial values.
CO Writes its findings to unit LPT.
C
/FWVALS/
/CARDRC/
/IOUNIT/
/REFINE/
C
C SET 'FORSYTH & WELLS SCATTERING FACTOR TYPE LSQ':
      IREF=-1
C WRITE TITLE IN CASE USER HAS INVOKED WRONG SUB-LIBRARY:
      CALL CENTRE(LPT,3,'Least Squares Refinement',80)
      CALL CENTRE(LPT,0,'Forsyth and Wells Scattering Factors',80)
      IF (INREAD(9) .GT. 0) CALL INPUTI
      CALL IICD1
C
C READ L CARDS:   L VALS HAS 5, 7 OR 9 STARTING VALUES
      ILCD=ICDNO(12)
      IF (ILCD .LE. 0) CALL ERRMES(1,0,'No L cards')
C
      K=0
      NVLS=0
  1   CALL FINDCD('L','VALS',4,K,LCD)
      IF (LCD .GT. 0) THEN
        K=LCD
        NV=NVLS+1
        CALL RDNUMS(COEFFS(NV),7,9,NVLS,IER)
        NVLS=NVLS+NV-1
        GO TO 1
      ENDIF
C
      NVALS=NVLS
      WRITE (LPT,2010) NVALS,(COEFFS(I),I=1,NVALS)
2010  FORMAT (/1X,I4,' coefficients in approximation'/' Initial values',
     & 9F12.5)
      RETURN
      END
C
C
C
C
C LEVEL 9      SUBROUTINE STLSSF
      SUBROUTINE STLSSF
C
C *** STLSSF updated by PJB  March 2008 ***
C
CX
CC 7A
CH Sets up any main program which does single crystal structure factor LSQ.
C
CI Reads and interprets:
CI An I card giving general instructions (including NCYC, CYC1, MCOR,
CI             and PRIN items, if required).
CI All L cards except FIX, VARY and RELA.
C
CD Reads in I and L cards.  If the refinement is actually a simple
CD application of geometric slack constraints, with no other observations,
CD sets this up (by recording "no. of scale factors=0" in LF1SP(2)),
CD deals with a possible absence of fudge factors, and exits.
CD
CD Sets MODOBS = MODER/100 and MODER = MOD(MODER,100).
CD  MODOBS = 1 indicates that the reflection file contains
CD intensities rather than structure amplitudes
CD Otherwise deals with defaults for:
CD L TFAC: set TFAC=0 and fixed
CD L SCAL: set SCAL(1)=0, variable, and NSCALE=1
CD L REFI: assumes refinement type 1, "on mod Fc"
CD L MODE: assumes mode 3, data input as h,k,l, obs, sigma(obs), possible
CD         scale zone, possible code.
CD L WGHT: assumes weighting type 2, "use 1/sigma sqrd".
CD L FUDG: assumes no fudge factors.
C
CO Writes its findings to unit LPT.
C
/CARDRC/
/IOUNIT/
/LREAD/
/OBSCAL/
/PRBLEM/
/REFINE/
/SCLDAT/
/SLAKDA/
/SLKGEO/
C
      IF (INREAD(9) .GT. 0) CALL INPUTI
      CALL IICD1
C NOW ALL L CARDS EXCEPT FIX,RELA, VARY:
      CALL INPLSF
C AND INTERPRET THEM HAVING READ ALL:
C
C IF ONLY SLAK CONSTRAINTS & NO OBS, ONLY DEFAULT TO CONSIDER
C IS FUDG, AND WE NEED TO SET NO SCALES:
      IF (NSLAK(1) .LE. 0 .OR. .NOT. SLONLY) THEN
C DEFAULT IF NO L TFAC:
        IF (ILREAD(1) .EQ. 0) CALL LLTFAC(5)
C DEFAULT IF NO L SCAL:
C4.7 Allow for L SORC SCAL
        IF (ILREAD(2) .EQ. 0 .AND. ILREAD(6) .EQ. 0) CALL LLSCAL(0)
C SET ACTUAL NUMBER OF SCALE ZONES AS NUMBER OF PARAMETERS OF FAMILY 1, GENUS 2:
        LF1SP(2)=-NSCALE
C
C DEFAULT IF NO REFI - ASSUME REFINING ON MOD FC TO BE MOST USUAL:
        IF (ILREAD(3) .EQ. 0) THEN
          IREF=1
          CALL MESS(LPT,1,
     &    'No L REFI card - assuming refining on mod(Fc), type 1')
        ENDIF
C
C DEFAULT IF NO MODE CARD - TYPE 3:
        IF (ILREAD(4) .EQ. 0) THEN
          MODER=3
          CALL MESS(LPT,1,
     &    'No L MODE card - assuming mode 3, data input as h,k,l'//
     &    ' Gobs, sigma, (Scale), (Code)')
        ENDIF
C
C REPORT WHETHER F OR FSQR TO BE READ
        IF (IREF.NE.5) THEN
          IF (MODOBS .NE.0 ) THEN
            CALL MESS(LPT,1,
     &      'GOBS IS EXPECTED TO BE F SQUARED (MODER >= 100)')
          ELSE
            CALL MESS(LPT,1,'Gobs is expected to be F (MODER < 100)')
          ENDIF
        ENDIF
C
C DEFAULT WEIGHTING IS TYPE 2 - ALSO SORT OUT INTERACTION BETWEEN IWGHT & MODER:
        IF (ILREAD(5) .EQ. 0) THEN
          IWGHT=2
          CALL MESS(LPT,1,'No L WGHT card given - assuming type 2')
        ENDIF
C
C IF WEIGHTING SCHEME 2, EXACT FORM OF INPUT FOR WEIGHTS DEPENDS ON MODER:
        IF (IWGHT .EQ. 2) THEN
C
C CANNOT HAVE MODER=1:
          IF (MODER .EQ. 1) THEN
            WRITE (LPT,3000) IWGHT,MODER
            WRITE (ITO,3000) IWGHT,MODER
3000        FORMAT (/' ERROR ** Weighting scheme=',I4,
     &      ' and input mode =',I4,' incompatible')
            IERR=IERR+1
          ELSE IF (MODER .EQ. 2) THEN
C
C WEIGHT TO BE USED AS READ:
            CALL MESS(LPT,1,
     &      'Weights to be used as read from reflection data')
          ELSE
C
C SIGMA READ, WEIGHT IS 1/SIGMA SQUARED:
            CALL MESS(LPT,1,
     &      'Sigma read from reflection data - weight is '//
     &      '1/sigma squared')
          ENDIF
        ENDIF
      ELSE
        LF1SP(2)=0
      ENDIF
C
      CALL ERRMES(0,0,'for structure factor LSQ')
C
      CALL GEOMIN(1)
      RETURN
      END
C
C
C
C
C LEVEL 7      SUBROUTINE STPLOT
      SUBROUTINE STPLOT
C
C *** STPLOT updated by PJB Aug 2017 C4.38 ***
C
CX
CC 14A
CH Sets up the plotting of maps;  fits elements of a picture together.
C
CP Plotting of a Fourier map must be set up by SETFOU.  In particular:
CP NX=number of x values wanted for plotted points
CP NY=number of y values wanted for plotted points
CP PMAP(2,2) in /CONTUR/ holds the matrix which converts map coords
CP       to cms, set by USYM.
CP There is a title in ITITLE, of length NTITLE, read by INPUTN
C
CD Calls the special plotting routine PIGLET to do whatever is necessary
CD locally to start using graphical output.
CD
CD Decides the scales of various sizes of characters which will be
CD written on a picture.  Sets up all conversion matrices needed in
CD subsequent map plotting, by calculating the layout of the various
CD elements of a picture (map, title, expanatory text, etc) within its
CD frame.
CD
CD Finally calls PIGLET to do whatever is required locally to start the
CD whole plot, now we know how big it will be.
C
      DIMENSION PTEMP(2,3),PMAP(2,2)
/BITMAP/
/CONTUR/
/IOUNIT/
/LENINT/
/MAPDA/
/NTITL/
/PLODAT/
/PLOMAP/
/TITLE/
C
      write (lpt,5001) 'Entry to STPLOT'
 5001 format (a)
C4.38 Code section moved from USYM since PMAP is specific for PIGLET plotting
      TLEN=AXMAP(1)*OUTLIM(3,1)*SCALMP
      PMAP(1,1)=TLEN*COSPHI
      PMAP(2,1)=-(TLEN*SINPHI)
      PMAP(1,2)=AXMAP(2)*OUTLIM(3,2)*SCALMP
      PMAP(2,2)=0.0
C
      FX=FLOAT(NX-1)
      FY=FLOAT(NY-1)

      HGTMAP=-(PMAP(2,1)*FX)
C WIDTH OF PROJECTING PIECE OF MAP:
      WIDPRO=ABS(PMAP(1,1)*FX)
      WIDMAP=WIDPRO+PMAP(1,2)*FY
C
C INITIALISE ANY SPECIAL HARDWARE QUANTITIES FOR PLOTTER:
      CALL PIGLET(0.,0.,0)
C
C SET UP NWORDS=NUMBER OF CONSECUTIVE INTEGERS OF LENGTH NBITS NEEDED TO
C TAKE 108 BITS (OR WHATEVER IS SET UP):
%      NWORDS=IFIX(%CBIT%./FLOAT(NBITS))+1
C
C WE MUST CHECK THAT THERE IS ROOM FOR NX ROWS + 2 EDGES IN THE LONG
C DIMENSION OF IBIT, AND THAT BOTH THE NUMBER OF ROWS AND THE NUMBER OF COLUMNS
C WILL FIT IN THE "BITS ALLOWED PER ROW", WHICH IS THE SHORTER DIMENSION
C OF IBIT TIMES THE WORD LENGTH IN NBITS.
C
C NBITS IS ACTUALLY THE WORD LENGTH MINUS ONE, TO AVOID THE SIGN BIT.
C
%      M1DIM=%CBIT%
      M2=NX+2
      MSIZE=NBITS*NWORDS
      M1DIM2=M1DIM-2
      IF (M1DIM2 .LT. NX) THEN
        WRITE (LPT,3000) M1DIM2,NX
        WRITE (ITO,3000) M1DIM2,NX
3000    FORMAT (' ERROR ** Too many x values to plot -',I5,
     &  ' allowed by parameter CM1-2,',I5,' given')
        STOP
      ENDIF
C
      IF (NX .GT. MSIZE) THEN
        WRITE (LPT,3001) NX,NBITS,NWORDS
        WRITE (ITO,3001) NX,NBITS,NWORDS
3001    FORMAT (' ERROR ** Too many x values to plot -',I5,
     &  ' requested - NBITS,NWORDS in STPLOT=',2I5)
        STOP
      ENDIF
C
      IF (NY .GT. MSIZE) THEN
        CALL ERRIN2(NY,-1,'too many y values to plot -','requested')
        WRITE (LPT,3003) MSIZE,NWORDS,NBITS
        WRITE (ITO,3003) MSIZE,NWORDS,NBITS
3003    FORMAT (' but only space for',I5,' arising from',I5,' words',
     &  ' using',I5,' bits in each')
        STOP
      ENDIF
C
      FX=FLOAT(NX-1)
      FY=FLOAT(NY-1)
C
C
C DECIDE CHARACTER SCALES - FIRST TYPE 1, THE TEXT BLOCK:
C FIRST TRY TO MAKE THE TEXT BLOCK THE SAME WIDTH AS THE MAP:
      CMSCAL=WIDMAP*CHMAP
      CHSCAL(1,1)=WIDMAP/1050.
C 1050 IS A GUESS, BEING  AN ARBITRARY AMOUNT TO BE THE WIDTH OF A LINE
C OF TEXT, THE WHOLE THING BEING IN CHARACTER COORDINATES.  THE BEST SIZE FOR
C THE FRAME IS CALCULATED IN PLTTXT.
      CHSCAL(2,1)=ASPECT*CHSCAL(1,1)
C IF CHARS TYPE 1 ARE MORE THAN 1 CM OR LESS THAN 0.2 CMS, ADJUST SO THAT THEY
C HIT THE LIMIT:
      CLIM1=CMSCAL/(CHUNIT)
      CLIM2=0.2*CMSCAL/(CHUNIT)
      IF (CHSCAL(2,1) .GT. CLIM1) CHSCAL(2,1)=CLIM1
      IF (CHSCAL(2,1) .LT. CLIM2) CHSCAL(2,1)=CLIM2
      CHSCAL(1,1)=CHSCAL(2,1)/ASPECT
C ALL WIDTHS OF ITEMS IN PICTURE ARE WANTED IN CMS:
      WIDTXT=CHSCAL(1,1)*1050.
      HGTTXT=10.*CHSCAL(2,1)*CHUNIT
C      write (lpt,5002) aspect,widmap,widtxt,chscal(1,1),chscal(2,1),
C     &cmscal
C 5002 format ('STPLOT choosing chunit',6f10.4)
C THE 10 COVERS 5 LINES OF TEXT AND 5 BLANKS IN BETWEEN
C
C CHAR TYPE 1 IS DEFINITIVE FOR ALL THE WHITE SPACE AND INTERNAL BORDERS:
      XWHITE=CHSCAL(1,1)*CHUNIT
      YWHITE=CHSCAL(2,1)*CHUNIT
      XMARG=4.*XWHITE
      YMARG=4.*YWHITE
C
C NOW CHARACTER TYPE 2, THE TITLE.  WE MAKE THIS MATCH THE TEXT BLOCK BY
C TRYING TO MAKE THEIR WIDTHS THE SAME, BUT IF THIS GIVES CHAR TYPE 2 OF
C MORE THAN 1.5 CMS HIGH, WE ALLOW IT TO BE SMALLER:
C
C FIRST MEASURE LENGTH OF TITLE IN CHARACTER UNITS:
      CALL KANGA2(0.,0.,TLEN,ITITLE,-NTITLE)
      TLEN=TLEN+2.*CHUNIT
      CHSCAL(1,2)=WIDTXT/TLEN
      CLIM1=1.5/CHUNIT
      IF (CHSCAL(1,2) .GT. CLIM1) CHSCAL(1,2)=CLIM1
      CHSCAL(2,2)=CHSCAL(1,2)*ASPECT
      WIDTTL=TLEN*CHSCAL(1,2)
      HGTTTL=2.*CHSCAL(2,2)*CHUNIT
C
C DO NOTHING ABOUT CHARACTER TYPE 3 - CONTOUR LIST PANEL YET:
C A DIGIT IS 20 PLOTTER UNITS WIDE - PRETEND USING TYPE 1 FOR NOW:
      WIDCON=220.*CHSCAL(1,1)
      WIDMAX=WIDMAP
      IF (WIDTXT .GT. WIDMAP) WIDMAX=WIDTXT
      WIDPIC=3.*XMARG+WIDMAX+WIDCON
      HGTPIC=4.*YMARG+HGTMAP+HGTTXT+HGTTTL+2.*YWHITE
C
C NOW SET UP THE VARIOUS MATRICES WHICH MOVE FROM ONE SPACE TO ANOTHER:
C
C A TRANSFORMATION TAKES THE FORM:
C        A B C    OLD X = NEW X
C        D E F    OLD Y   NEW Y
C                  1
C SO A,B,D,E ROTATES OLD X,OLD Y AND C,F GIVES A TRANSLATION.  THUS C AND
C F ARE IN THE SAME UNITS AS NEW X, NEW Y.
C
C PMTRIX 1 MOVES FROM CCSL TO PLOTTER - IT HAS BEEN SET UP IN PINTIL
C
C PMTRIX 2 MOVES FROM PICTURE TO CCSL - WE HAVE NO REASON TO ALTER THE SCALE OR
C ORIENTATION OF A PICTURE IN CCSL SPACE.  (IF, LATER, WE WANT TO DO THIS, HERE
C IS THE PLACE TO DO IT.)
C
C THIS MATRIX IS THE ONLY ONE WHICH CHANGES ONCE SET UP - ITS THIRD COLUMN IS
C THE ONE WHICH MOVES FROM PICTURE TO PICTURE, POSSIBLY PUTTING SEVERAL
C SIDE BY SIDE ON WIDE PAPER.
C
C FIRST CALCULATE HOW SEVERAL PICTURES CAN FIT ON THE PLOTTER:\=
      IF (FROMCM .LE.0) THEN
        N1=1
        N2=1
        GO TO 1
      ENDIF
      IF (HGTPIC .GE. PAPERW)  THEN
        WRITE (LPT,3004) HGTPIC,PAPERW
        WRITE (ITO,3004) HGTPIC,PAPERW
3004    FORMAT (' ERROR ** picture of height',F10.2,'cms requested',
     &  ' but plotter paper given as only',F10.2,'cms')
        STOP
      ENDIF
C
      NYPIC=IFIX(PAPERW/(HGTPIC+BORDER))
      IF (NYPIC.EQ.0) NYPIC=1
      N1=(IZPL-1)/NYPIC + 1
      N2=NYPIC
      IF (N1 .EQ. 1) N2=IZPL
C
C TOTAL SIZE OF PLOT IN CMS:
    1 WIDTOT=(WIDPIC+BORDER)*FLOAT(N1)
      HGTTOT=(HGTPIC+BORDER)*FLOAT(N2)
C
C INITIALISE COUNT ACROSS PAGE:
      IYPIC=0
C
C USE PLTRIN TO PUT MATRICES 3 4 5 AND 6 IN PLACE:
C
C PMTRIX 3 TAKES MAP COORDINATES INTO PICTURE COORDINATES.  THE ROTATION
C PART HAS BEEN SET UP BY USYM AND IS IN PMAP IN /CONTUR/
C
      CALL GMEQ(PMAP,PTEMP,2,2)
C MAP ORIGIN IN PICTURE COORDS:
      XO=XMARG
      DIFF=(WIDTXT-WIDMAP)/2.
      IF (DIFF .GT. 0.) XO=XO+DIFF
      IF (COSPHI .LT. 0.) XO=XO+WIDPRO
      PTEMP(1,3)=XO
C
      PTEMP(2,3)=2.*YMARG+HGTTXT+3.*YWHITE+HGTMAP
      CALL PLTRIN(PTEMP,4,3)
C
C NOW THE CHARACTERS INTO PICTURE MATRICES.  ALL THE ROTATIONS ARE AT
C PRESENT SIMPLE SCALES, NOT ACTUAL ROTATIONS.
C
      CALL GMZER(PTEMP,2,2)
      PTEMP(1,1)=CHSCAL(1,1)
      PTEMP(2,2)=CHSCAL(2,1)
C
C PMTRIX 4 TAKES CHARACTERS OF TYPE 1 INTO PICTURE COORDS.  THE ORIGIN HERE
C IS THE BOTTOM LEFT HAND CORNER OF THE TEXT BLOCK:
      XO=XMARG
      IF (DIFF .LT. 0.) XO=XO-DIFF
      PTEMP(1,3)=XO
      PTEMP(2,3)=YMARG
      CALL PLTRIN(PTEMP,5,3)
C
C PMTRIX 5 IS FOR CHARACTER TYPE 2, THE TITLE CHARACTERS.  THE ORIGIN IS THE
C BOTTOM LEFT HAND CORNER OF THE TITLE BLOCK:
C
      CALL GMZER(PTEMP,2,2)
      PTEMP(1,1)=CHSCAL(1,2)
      PTEMP(2,2)=CHSCAL(2,2)
      DIFF1=(WIDMAP-WIDTTL)/2.
      IF (DIFF .GT. 0.) DIFF1=DIFF1+DIFF
      IF (DIFF1 .LT. 0.) DIFF1=0.
      PTEMP(1,3)=DIFF1+XMARG
      PTEMP(2,3)=HGTPIC-YMARG-HGTTTL
      CALL PLTRIN(PTEMP,6,3)
C
C PMTRIX 6 IS FOR CHARACTER TYPE 3, THE CONTOUR LIST.  THE ORIGIN IS NOT
C YET DETERMINED AS WE DO NOT KNOW HOW MANY CONTOURS WILL BE FOUND
C
C
C WE ARE NOW IN A POSITION TO CALL WHATEVER SPECIAL ROUTINE IS NEEDED TO START
C A PLOT, REQUESTING A PIECE OF PAPER HGTTOT WIDE (ACROSS PLOTTER) AND WIDTOT
C LONG (ALONG LENGTH OF PLOTTER, OFTEN APPROACHING INFINITY IF REALLY A PLOTTER)
C
C WHEN WE START TO APPLY THIS TO VDUS, OUR REQUIRED SCREEN (IN CMS) IS
C WIDTOT WIDE AND HGTTOT HIGH.  BUT WE WOULD IN PRACTICE ASK FOR WIDPIC TIMES
C HGTPIC BECAUSE OF DRAWING ONE AT A TIME.  LEAVE THIS FOR NOW.
C
      IF (FROMCM .GT. 0)   CALL PIGLET(WIDTOT,HGTTOT,999)
      IF (FROMCM .LE. 0)   CALL PIGLET(WIDPIC,HGTPIC,999)
      RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE SUBSYM(ITAB)
      SUBROUTINE SUBSYM(ITAB)
C
C *** SUBSYM updated for NOPC+1 December 2006 ***
C
CX
CC 1B
CH Replaces all the symmetry parameters by those of a subgroup.
C
CA On entry ITAB is a table of dimension NOPC in which ITAB(I)=+-1
CA               if element I (or the -ve element) is in the subgroup
CA          IABS(ITAB(I)) is not 1 otherwise
CA          ITAB(NOPC+1)=-1 if the sub-group is non-centrosymmetric.
CP SYMOP
CD Replaces the full symmetry by the configurational symmetry of a
CD magnetic structure.
CD Stores all necessary quantities in the COMMON /OLDSYM/.
CN The routine SYMBAK may be used to restore the stored symmetry.
C
      DIMENSION ITAB(24),IGTAB(3),KTAB(24),MTAB(24),NTAB(24)
/IOUNIT/
/NSYM/
/OLDSYM/
/SYMDA/
/SYMTAB/
C
      CALL MESS(LPT,1,
     & 'Full symmetry replaced by configurational symmetry')
C STORE NUMBERS
      NOPO=NOP
      NCENTO=NCENT
      NOPCO=NOPC
C COPY ALL SYMMETRY ELEMENTS:
      CALL GMEQ(SYM,OSYM,9,NOPC)
      CALL GMEQ(TRANS,OTRANS,3,NOPC)
      CALL JGMEQ(INVERS,JNVERS,1,NOPC)
      CALL JGMEQ(NORD,JNORD,1,NOPC)
%      CALL JGMEQ(MULTAB,MOLTAB,%SYMO%,NOPC)
      CALL JGMEQ(IGENER,IOGEN,1,3)
C
      CALL JGMEQ(ITAB,NTAB,1,NOPC)
C
C  IS THERE A CENTRE OF SYMMETRY
      NCENT=1
C4.1 ITAB(NOPC+1) now used for centre
      IF (ITAB(NOPC+1).EQ.-1) NCENT=2
      CENTRC=(NCENT .EQ. 2)
C COUNT ELEMENTS OF THE EXTRACTED SUBGROUP IN IS:
      IS=1
C NOPONT(NEW ELEMENT)=OLD ELEMENT ADDRESS:
      NOPONT(1)=1
C KTAB(OLD ELEMENT)=NEW ELEMENT ADDRESS:
      CALL JGMZER(KTAB,NOPC,1)
      KTAB(1)=1
C COUNT DOWN ORDERS OF SYMMETRY ELEMENTS:
      DO 8 M=6,2,-1
      IF (M .EQ. 5) GO TO 8
      CALL JGMZER(MTAB,NOPC,1)
C COUNT ELEMENTS OF THE ORIGINAL GROUP:
      DO 1 I=2,NOPC
C PICK OUT ONLY ELEMENTS OF THE SUBGROUP:
      IF (IABS(NTAB(I)).NE.1) GO TO 1
C THEN PICK ONLY THOSE OF ORDER M:
      IF (MOD(IABS(JNORD(I)),100) .NE. M) GO TO 1
      II=I
C COUNT ALL POWERS OF THIS ELEMENT UP TO M:
      DO 9 K=1,M-1
      IF (NTAB(II) .EQ. 0) GO TO 9
      IS=IS+1
      MORD=MOD(JNORD(II),100)
      IF(K.NE.1) THEN
        NORD(IS)=ISIGN(IABS(MORD)+100,MORD)
      ELSE
        NORD(IS)=MORD
      ENDIF
      IF (NTAB(II) .EQ. -1) THEN
        NOPONT(IS)=-INVERS(II)
        KTAB(INVERS(II))=IS
        NORD(IS)=-NORD(IS)
      ELSE
        NOPONT(IS)=II
        KTAB(II)=IS
      ENDIF
      NTAB(II)=0
      MTAB(II)=NORD(IS)
   9  II=MOLTAB(II,I)
   1  CONTINUE
   8  CONTINUE
C
C RECONSTITUTE SYMMETRY, NOW ONLY FOR SUBGROUP:
      NOPC=IS
      DO 2 I=2,NOPC
      IC=IABS(NOPONT(I))
      CALL GMEQ(OSYM(1,1,IC),SYM(1,1,I),3,3)
      CALL GMEQ(OTRANS(1,IC),TRANS(1,I),3,1)
C  WAS THERE AN INVERSION?
      IF (NOPONT(I).LT.0) THEN
        CALL GMREV(SYM(1,1,I),SYM(1,1,I),3,3)
        INVERS(I)=KTAB(IC)
      ENDIF
      INVERS(I)=KTAB(JNVERS(IC))
C
      DO 2 J=2,NOPC
      ISS=IABS(NOPONT(J))
      M=MOLTAB(IC,ISS)
      MULTAB(I,J)=KTAB(M)
    2 CONTINUE
C
      NOP=NOPC*NCENT
      CALL JGMEQ(NORD,KTAB,NOPC,1)
      IGTAB(1)=ITAB(1)*NOPC
      CALL GENELM(MTAB,IGTAB)
      CALL JGMEQ(IGTAB(2),IGENER,2,1)
      NGEN=1
      IF (IGENER(2).NE.0) NGEN=2
      IF (IOUT .GT. 100) THEN
        WRITE(LPT,4000) ((MULTAB(I,J),I=1,NOPC),J=1,NOPC)
4000    FORMAT (' Multiplication table for subgroup:'/8(1X,8I5/))
        WRITE (LPT,4001) (NORD(I),I=1,NOPC)
4001    FORMAT ('   NORD: ',8I4)
        WRITE (LPT,4002) (INVERS(I),I=1,NOPC)
4002    FORMAT (' INVERS: ',8I4)
      ENDIF
      RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE SUMVEC(A,I,J,K,SUM)
      SUBROUTINE SUMVEC(A,I,J,K,SUM)
C
C *** SUMVEC by JCM 26 Sep 85 ***
C
CX
CC 12C
CH Calculates the sum of elements of a real array
CA On entry A is a real vector of length at least J
CA          I is the position in the array of the first element in the sum
CA          J is the position beyond which elements are not included
CA          K is the "step" between included elements
CA On exit  SUM is the sum of the chosen elements
C
CD Sets SUM=the sum of elements of array A by a DO LOOP 'I,J,K', dealing
CD correctly with J < I, and therefore usable in both FORTRAN 66 & 77.
C
      DIMENSION A(1)
C
      SUM=0.
      IF (J .LT. I) GO TO 100
C
      DO 1 N=I,J,K
   1  SUM=SUM+A(N)
 100  RETURN
      END
C
C
C
C
C LEVEL 2      SUBROUTINE SYMBAK
      SUBROUTINE SYMBAK
C
C *** SYMBAK by PJB 1 May 92 ***
C
CX
CC 1B
CH Restores the original symmetry operators after a call to SUBSYM.
C
/IOUNIT/
/NSYM/
/OLDSYM/
/SYMDA/
/SYMTAB/
C
      CALL MESS(LPT,1,'Restoring full symmetry')
C RESTORE NUMBERS
      NOP=NOPO
      NOPC=NOPCO
      NCENT=NCENTO
      CENTRC=(NCENT .EQ. 2)
C COPY ALL SYMMETRY ELEMENTS:
      CALL GMEQ(OSYM,SYM,9,NOPC)
      CALL GMEQ(OTRANS,TRANS,3,NOPC)
      CALL JGMEQ(JNVERS,INVERS,1,NOPC)
      CALL JGMEQ(JNORD,NORD,1,NOPC)
      CALL JGMEQ(MOLTAB,MULTAB,24,NOPC)
      CALL JGMEQ(IOGEN,IGENER,1,3)
      RETURN
      END
C
C
C
C
C LEVEL 3      SUBROUTINE SYMCEN(NC)
      SUBROUTINE SYMCEN(NC)
C
C *** SYMCEN by JCM 11 Jul 83 ***
C
CX
CC 1A
CH A specialist routine used during the input of space group symmetry
CH to discover whether there is a centre of symmetry.
C
CP Called at the start of routine SYMGEN.
C
CD Takes the temporary copy of the space group as generated in the
CD scratch COMMON /SCRAT/ and scans it for a centre of symmetry at the
CD origin.
CD
CD Sets NCENT=1 for non-centrosymmetric, 2 for centrosymmetric.
CD      CENTRC=.TRUE. if centrosymmetric, .FALSE. otherwise
CD      NC=0 if non-centrosymmetric, or the number of the (-x,-y,-z)
CD           operator.
CD      NOPC=NOP/NCENT.
C
CO Writes its findings on unit LPT.
C
      CHARACTER *5 WORD(2)
/IOUNIT/
/NSYM/
%      COMMON /SCRAT/TSYM(3,3,%SY*2%),TTRANS(3,%SY*2%),
%     & MLTAB(%SY*2%,%SY*2%),ITAB(%SYMO%),JTAB(%SY*2%),
%     & NNORD(%SY*2%),D(3,3)
/SYMDA/
      DATA WORD/'Non-c','    C'/
C
      NCENT=1
      NC=0
      CALL GMZER(ORIGIN,1,3)
      DO 1 NO=1,NOP
      DO 2 I=1,3
      DO 2 J=1,3
      IF (ABS(TSYM(I,J,1)+TSYM(I,J,NO)).GT..0001) GO TO 1
    2 CONTINUE
      IF (ABS(TTRANS(1,NO))+ABS(TTRANS(2,NO))+ABS(TTRANS(3,NO))
     &  .EQ. 0.) GO TO 4
C
C CENTRE OF SYMMETRY FOUND NOT AT ORIGIN:
      CALL GMEQ(TTRANS(1,NO),ORIGIN,1,3)
      CALL GMSCA(ORIGIN,ORIGIN,0.5,1,3)
C FOR NOW, JUST KEEP TRANSLATION VECTOR ASSOCIATED WITH -X,-Y,-Z
      WRITE (LPT,2001) ORIGIN
2001  FORMAT (/' Centre at:',3F10.4,' Fcs complex')
      GO TO 3
C
C  CENTRE OF SYMMETRY FOUND AT ORIGIN:
   4  NCENT=2
      NC=NO
      GO TO 3
   1  CONTINUE
   3  WRITE (LPT,2000) WORD(NCENT),NOP
2000  FORMAT (/' ',A5,'entrosymmetric space group with',I3,
     & ' operator(s)')
      NOPC=NOP/NCENT
      CENTRC=NCENT.EQ.2
%      CALL ERRCHK(1,NOPC,%SYMO%,0,'symmetry operators')
      RETURN
      END
C
C
C
C
C LEVEL 4      SUBROUTINE SYMDOM(IOPD,MULDOM)
      SUBROUTINE SYMDOM(IOPD,MULDOM)
C
C *** added to library by PJB C4.30  August 2016 ***
C
CC 17C
C
CH Finds the operators generating domains and makes the domain multiplication table
CA IOPD is returned containing the symmetry operator generating each domain
CA MULDOM is the multiplication table for the numbered domains

%      DIMENSION IOPD(%DOMS%),MULDOM(%DOMS%,%DOMS%)
/IOUNIT/
/NSYM/
/SYMMAG/
/SYMTAB/
C
C MAKE THE DOMAIN MULTIPLICATION TABLE
 1000 FORMAT ('Domain multiplication Table:',10I5)
 1001 FORMAT (28X,10I5)
      ND=1
      DO 1 N=1,NOP
        IF (MSTAB(N) .EQ.N) THEN
          IOPD(ND)=N
          IF (ND .EQ.NDOM) GO TO 3
          ND=ND+1
        ENDIF
    1 CONTINUE
    3 NM=1
      DO 2 N=1,ND
        I=IOPD(N)
        DO 4 M=1,ND
          J=IOPD(M)
          MULDOM(M,N)=NFIND(MULTAB(J,I),IOPD,NDOM)
  4     CONTINUE
        IF (N.EQ.1) THEN
          WRITE (LPT,1000) (MULDOM(L,1),L=1,NDOM)
        ELSE
          WRITE (LPT,1001) ((MULDOM(L,J),L=1,NDOM),J=2,NDOM)
        ENDIF
  2   CONTINUE
      RETURN
      END
C
C
C
C
C LEVEL 3      SUBROUTINE SYMEQU(HI,H,K,N,MI,UU,BETA)
      SUBROUTINE SYMEQU(HI,H,K,N,MI,UU,BETA)
C
C *** SYMEQU updated by PJB C4.38 Aug 2017 ***
C
CX
CC 5B
CH Generates new indices and a phase, in Fourier calculations.
C
CA On entry HI is a 1x3 vector containg h,k,l
CA          N is the number of a symmetry operator
CA          H is an array of indices already found for this HI
CA          MI is the number of entries in H.
CA On exit  EH holds the new h,k,l
CA          UU=0. if these indices have occurred before in the array H
CA             or, if NDIM=2 or 3, =-1 if the (-h,-k,-l) operator was
CA                 necessary to put EH into the correct half of reciprocal
CA                  space with l >=0,
CA                                  +1 if (-h,-k,-l) was not used.
CA            or, if NDIM=2, the transformed l is non-zero;
CA            or, if NDIM=4 for a bounded section, UU= the coefficient
CA                needed for this EH in the sum.
CA          BETA is the phase for this h,k,l.
C
CP Fourier calculations should be set up by SETFOU.
CN C4.31 This updated version finds the symmetry operators transformed to
CN map coordinates the new common block /TSYMDA/
C
      DIMENSION HI(3),EH(3),K(3),H(3,*),q(3)
      COMPLEX BOUND
      LOGICAL TESTOV
C
/CONSTA/
/IOUNIT/
/MAPDA/
/MAPMAP/
/NSYM/
/SYMDA/
/SYMTAB/
C Contains the transformed symmetry operators
/TSYMDA/
C
      UU=1.
      IN=invers(n)
C4.31 Transform using TSYM
C4.38 Order of multiplication reversed
      CALL GMPRD(HI,TSYM(1,1,N),EH,1,3,3)
      CALL INDFIX(EH,K)
      IF (K(2)) 4,3,2
   3  IF (K(1)) 4,5,2
   5  IF (K(3)) 4,2,2
   4  DO 6 I=1,3
      K(I)=-K(I)
      EH(I)=-EH(I)
   6  CONTINUE
C TO ENSURE FRIEDEL EXACT HALF
      UU=-UU

   2  CALL EQVEC(H,EH,MI,M,NOP)
C DO NOT USE IF EXACTLY THIS HKL HAS ALREADY OCCURRED FROM THIS CYCLE:
      IF (M .LE. MI) GO TO 101
      MI = M
C ONLY TEST L IF 2D:
      IF ((NDIM .EQ. 2) .AND. (K(3) .NE. 0)) GO TO 101
      CALL GMZER(Q,3,1)
      CALL GMSUB(Q,SECZER,Q,3,1)
C4.31 Translation transformed from  TTRANS
      IF (MODEF .NE. 6) CALL GMADD(Q,TTRANS(1,N),Q,3,1)
C These are in transfomed cryst coords
      TRA=SCALPR(Q,EH)
      BETA = TWOPI*TRA
      IF (NDIM.NE.4) GO TO 100
      IF (TESTOV(1.,EH(3))) GO TO 100
      ARG=TWOPI*EH(3)
      BOUND=CEXP(CMPLX(0.,-(ARG*SECEND)))
     & -CEXP(CMPLX(0.,-(ARG*SECZER(3))))
      BOUND=BOUND*CMPLX(0.,1./ARG)
      ABOUND=CABS(BOUND)
      UU=UU*ABOUND/(SECEND-SECZER(3))
      IF (ABOUND.GT.10E-5)
     &  BETA=BETA+ATAN2(AIMAG(BOUND),REAL(BOUND))
      GO TO 100
C
 101  UU=0.
 100  RETURN
      END
C
C
C
C
C LEVEL 7      LOGICAL FUNCTION SYMFIX(KK)
      LOGICAL FUNCTION SYMFIX(KK)
C
C *** SYMFIX by JCM 7 Jun 88 ***
C
CX
CC 6C
CH Says whether a LSQ parameter is fixed by symmetry or not.
CA On entry KK holds packed parameter spec
CA On exit SYMFIX is TRUE if KK is fixed by symmetry (not just by user)
C
      LOGICAL KSAME
/LINKAG/
C
      SYMFIX=.TRUE.
C
C SCAN ALL FIXING AND VARYING:
      DO 1 I=1,NUMFV
C IF ENTRY IS NOT KK ITSELF, AND DOES NOT ENCOMPASS KK, JUMP:
      IF (.NOT. KSAME(KK,KKFV(I)))  GO TO 1
C OTHERWISE, IF STATUS IS + (="FIX") 5 (="BY PROGRAM"), TRUE:
      IF (KSTFV(I) .EQ. 5) GO TO 100
   1  CONTINUE
      SYMFIX=.FALSE.
 100  RETURN
      END
C
C
C
C
C LEVEL 6      SUBROUTINE SYMFRI
      SUBROUTINE SYMFRI
C
C *** SYMFRI updated  by JCM 14 Jul 86 ***
C
CX
CC 1A
CH Reads and interprets an item "FRIE" on an I card.
C
CP Called at the end of the specialist routine SYMTID, which is used to
CP tidy the symmetry operators towards the end of their input.
C
CD Finds the item "FRIE" if it is present, and reads a following integer.
CD Sets the LOGICAL FRIEDL to be TRUE if Friedel's law is to be assumed,
CD that h,k,l is equivalent to -h,-k-l.
Cd
CI The item "I FRIE n" has n=0 for "do NOT assume Friedel's law".  The
CI default  is to assume the law.
CO Reports its findings on unit LPT.
CN used for non-centrosymmetric structures only.
C
      LOGICAL ONCARD
/FRIED/
/IOUNIT/
/NSYM/
C
      FRIEDL=.TRUE.
      IF (CENTRC) GO TO 100
C
C IF NON-CENTROSYMMETRIC, LOOK FOR I FRIE CARD:
      IF (ONCARD('I','FRIE',A)) THEN
C
C AND IF I FRIE CARD GIVEN, TAKE INSTRUCTION FROM IT:
        FRIEDL=(A .NE. 0.)
        IF (FRIEDL) THEN
          CALL MESS(LPT,1,'Friedel''s law assumed - hkl equivalent '//
     &    'to -h-k-l')
          GO TO 100
        ENDIF
      ENDIF
C
      FRIEDL=.FALSE.
      CALL MESS(LPT,1,'Friedel''s law NOT assumed - hkl distinct '//
     & 'from -h-k-l')
 100  RETURN
      END
C
C
C
C
C LEVEL 8      SUBROUTINE SYMGEN
      SUBROUTINE SYMGEN
C
C *** SYMGEN by PJB/JCM 8 Jul 83 ***
C
CX
CC 1A
CH Produces the generators of a space group which has been read by SYMOP.
C
CP The entire group must be in the COMMON /SCRAT/, with TSYM holding
CP the rotation matrices and TRANS the corresponding translation vectors.
CP /SCRAT/ also holds the temporary multiplication table for operators,
CP MULTAB.
C
CD SYMGEN has 4 main sections.  The first has been separated off as routine
CD SYMCEN, and the last as SYMTID.
CD
CD SYMCEN identifies a centre of symmetry at the origin if there is one.
CD
CD Part 2 fills in the vector NNORD as a temporary list of the orders
CD of each of the operators.
CD Various elements of NNORD are set to zero:
CD       firstly, all those centrosymetrically related to others,
CD       next, for those of orders 3,4 or 6, zeros are inserted for
CD       the element cubed, to the power 4, etc.
CD Part 3 sets up the pointer vector ITAB, 1xNOPC sized, and JTAB
CD 1xNOP sized.  It makes a list of the generators of the group in IGENER,
CD counting them in NGEN.  A new numbering of operators in made in JTAB,
CD and used to index ITAB.  NUMOP counts up as elements of the group are
CD generated, stopping at NOPC.
C
CD SYMTID tidies the information out of the temporary arrays in /SCRAT/
CD into /SYMDA/ and /SYMTAB/, and sets up a table of pointers to
CD invers elements, INVERS.
C
      LOGICAL FIRST,BINDIG
/IOUNIT/
/NSYM/
%      COMMON /SCRAT/TSYM(3,3,%SY*2%),TTRANS(3,%SY*2%),
%     & MLTAB(%SY*2%,%SY*2%),ITAB(%SYMO%),JTAB(%SY*2%),
%     & NNORD(%SY*2%),D(3,3)
/SYMTAB/
C
C
C FIRST LOOK FOR CENTRE OF SYMMETRY:
      CALL SYMCEN(NC)
C
C CLEAR TABLE OF ORDERS OF ELEMENTS:
      DO 14 N=1,NOP
  14  NNORD(N)=1
C
C DISCOVER ORDERS & FILL IT TABLE, REJECTING CENTROSYMMETRICALLY
C RELATED OPERATORS, AND REJECTING HIGHER POWERS OF THOSE OF ORDER
C 3, 4 OR 6:
      NGEN=1
      IGENER(1)=1
      IF (NOP .EQ. 1) GO TO 18
C
      DO 1 NO=2,NOP
      IF (NNORD(NO).EQ.0.OR. NNORD(NO).GT.10) GO TO 1
C N WILL GIVE THE NUMBER OF THE LATEST GENERATED OPERATOR:
      N=1
C M WILL GIVE THE ORDER:
      M=1
   16 N=MLTAB(NO,N)
C  REJECT OPERATORS WHICH GENERATE A CENTRE:
      IF (N.EQ.NC) GO TO 1
C
C IF UNIT OPERATOR (NUMBER 1) HAS BEEN GENERATED, WE NOW HAVE THE
C ORDER OF OPERATOR NUMBER "NO":
      IF (N.EQ.1) GO TO 15
      M=M+1
      GO TO 16
C
C FILL IT ORDERS VECTOR;  CANCEL C-RELATED IF THERE IS ONE:
   15 NNORD(NO)=M
      IF (CENTRC) NNORD(MLTAB(NC,NO))=0
      IF (M.LE.2) GO TO 1
C HOLD ORDER FOR HIGHER POWERS OF THOSE OF ORDER GREATER THAN 2
C WITH 100 ADDED
      N=NO
      DO 17 J=3,M
      N=MLTAB(NO,N)
      IF (CENTRC) NNORD(MLTAB(NC,N))=0
      JJ=J-1
      IF (2*JJ .GT.M) JJ=M-JJ
      NNORD(N)=M
      IF (MOD(M,JJ).EQ.0) NNORD(N)=M/JJ
   17 NNORD(N)=NNORD(N)+100
    1 CONTINUE
C
C PART 3:
C NOW FILL IN VECTORS ITAB AND JTAB TO GIVE THE CROSS-REFERENCES BETWEEN
C OLD AND NEW NUMBERINGS OF THE OPERATORS:
      NGEN=0
      IGENER(1)=0
  18  NUMOP=1
      ITAB(1)=1
      JTAB(1)=1
C HERE MAY BE TRICLINIC: IF NOP=1 WE HAVE P1, AND WANT 1 GENERATOR BEING
C THE IDENTITY OPERATOR.  IF NOP=2 WE HAVE P-1, AND (BECAUSE OF THE
C WAY WE ARE STORING OPERATORS) WANT 0 GENERATORS.
      IF (NOPC .EQ. 1) GO TO 101
C
C HERE AT LEAST MONOCLINIC; CLEAR REMAINING ITEMS IN VECTORS:
      IF (NOP .GT. 1) CALL JGMZER(JTAB(2),1,NOP-1)
      IF (NOPC .GT. 1) CALL JGMZER(ITAB(2),1,NOPC-1)
C
C NOW COUNT DOWN THROUGH ORDERS OF POSSIBLE SYMMETRY ELEMENTS:
      DO 2 NN=1,5
      IORD=7-NN
C  OPERATORS OF ORDER 5 NOT ALLOWED
      IF (IORD.EQ.5) GO TO 2
      FIRST =.TRUE.
      DO 3 NNN=1,NOP
      IF (NNORD(NNN).NE.IORD) GO TO 3
C  WE HAVE FOUND AN OPERATOR OF ORDER IORD
C  HAS THIS OPERATOR BEEN USED ALREADY?
      IF (JTAB(NNN).NE.0) GO TO 3
C AND IS IT THE FIRST?
      IF (.NOT. FIRST) GO TO 4
C  THE FIRST OPERATOR OF THIS ORDER
      FIRST=.FALSE.
      M=NNN
      GO TO 9
C
C  HERE IF NOT FIRST:
    4 DO 30 M=1,NOP
      IF (MLTAB(ITAB(IGENER(NGEN)),M).EQ.NNN) GO TO 31
   30 CONTINUE
      WRITE (LPT,3000)NNN,NGEN
      WRITE (ITO,3000)NNN,NGEN
3000  FORMAT (' ERROR ** in SYMGEN - operator',I4,' not found',
     & ' in table MLTAB;  no. of generators so far -',I4)
      STOP
C
   31 IF (NNORD(M).EQ.0 .OR. NNORD(M).GT.10) GO TO 3
      IF (JTAB(M).NE.0) GO TO 3
C  MAKE IT A GENERATOR
    9 NGEN=NGEN+1
      NUMOP=NUMOP+1
      IGENER(NGEN)=NUMOP
      ITAB(NUMOP)=M
      JTAB(M)=NUMOP
      IF (NUMOP.GE.NOPC) GO TO 101
      NUM=NUMOP-1
C  REMAKE MULTIPLICATION TABLE SAVING NEW ORDER
    7 NUM=NUM+1
      J=ITAB(NUM)
      DO 6 N=1,NUM
      I=ITAB(N)
      MUL=MLTAB(I,J)
C IPERM ENSURES OPERATORS ARE COMBINED BOTH WAYS ROUND:
      DO 8 IPERM=1,2
      IF (JTAB(MUL).NE.0) GO TO 8
      NUMOP=NUMOP+1
      ITAB(NUMOP)=MUL
      JTAB(MUL)=NUMOP
      IF (NUMOP.GE.NOPC) GO TO 101
    8 MUL=MLTAB(J,I)
    6 CONTINUE
      IF (NUMOP.GT.NUM) GO TO 7
C
    3 CONTINUE
C
    2 CONTINUE
C
C SOME DIAGNOSTIC OUTPUT IN CASE OF TROUBLE:
      IF (BINDIG(IOUT,16)) THEN
        WRITE (LPT,4000) (NNORD(I),I=1,NOP)
        WRITE (ITO,4000) (NNORD(I),I=1,NOP)
4000    FORMAT (/' NNORD:',(16I5))
        WRITE (LPT,4001) (JTAB(I),I=1,NOP)
        WRITE (ITO,4001) (JTAB(I),I=1,NOP)
4001    FORMAT (/' JTAB:',(16I5))
        WRITE (LPT,4002) (ITAB(I),I=1,NOPC)
        WRITE (ITO,4002) (ITAB(I),I=1,NOPC)
4002    FORMAT (/'ITAB:',(16I5))
      ENDIF
C
C PART 4 - TIDY UP INFORMATION INTO PERMANENT SPACE:
 101  CALL SYMTID(NC)
      RETURN
      END
C
C
C
C
C LEVEL 9      SUBROUTINE SYMOP
      SUBROUTINE SYMOP
C
C *** SYMOP updated by JCM 30 Aug 92 ***
C
CX
CC 1A
CH Reads all the symmetry operators or a space group specification from
CH "S" cards, and generates the space group.
C
CD Reads all "S" cards and stores (ultimately):
CD      the space group rotation matrices in SYM in /SYMDA
CD      the translation vectors associated with them in TRANS in /SYMDA
CD      the lattice translation in ALAT in /SYMDA
CD      NOP=total number of operators, in /NSYM
CD      NOPC= the number of operators actually stored (half NOP if
CD            centrosymmetric with origin at centre), in /NSYM
CD      NLAT= the number of lattice vectors, in /NSYM
CD      NCENT=1 if non-centrosymmetric, 2 if centrosymmetric, in /NSYM
CD      NGEN= the number of generators of the space group, in /NSYM
C
CD Only the generating elements of the space group need be given.
CD The position X,Y,Z is assumed, and non-primitive lattice translations
CD are taken care of.
CD
CD Operators related by a centre are eliminated.
C
CI Reads all the "S" cards from the copy of the Crystal Data File held
CI on unit IO10.
C
CN The complete group of operators formed may be printed out using OPSYM.
C
      LOGICAL ONCARD,SGIVEN
      CHARACTER *16 SNAME
/CARDRC/
/IOUNIT/
/NSYM/
%      COMMON /SCRAT/TSYM(3,3,%SY*2%),TTRANS(3,%SY*2%),
%     & MLTAB(%SY*2%,%SY*2%),R(3,3),T(3)
/SYMDA/
C
C INPUT NUMBER OF S CARDS:
      NNSYM=ICDNO(19)
C
C SET "S CARDS READ":
      INREAD(19)=-IABS(INREAD(19))
C
C INITIALISE AS THOUGH P1:
      NLAT = 1
      NOP = 1
      CALL GMZER(ALAT(1,1),1,3)
      CALL GMZER(TTRANS(1,1),1,3)
      CALL GMUNI(TSYM(1,1,1),3)
C ALAT HOLDS (UP TO 4) LATTICE TRANSLATION VECTORS
C TTRANS HOLDS (IN THIS FIRST STAGE) THE TRANSLATION VECTORS OF EACH OPERATOR
C TSYM HOLDS (IN THIS FIRST STAGE) THE ROTATION MATRICES OF EACH OPERATOR
C
      IF (NNSYM .EQ. 0) CALL MESS(LPT,1,
     & 'No cards starting S have been read - assuming space group P1')
      ID=IABS(INREAD(19))
C
C FIRST, IS THERE AN S GRUP CARD
      SGIVEN=(ONCARD('S','GRUP',A))
      IF (SGIVEN) THEN
        CALL SPGNAM(JFIX(A),SNAME)
        NSPC=NOPFIL(5)
        CALL SPACE(SNAME,NSPC,NGENS)
        NNSYM=NGENS
        ID=-NSPC
      ENDIF
C
C READ AND INTERPRET S CARDS ONE BY ONE:
      DO 4 NCARD = 1,NNSYM
      CALL INPUTS(ID,R,T)
      IF (.NOT. SGIVEN) ID=ID+NYZ
      NO=NOP
C DISCOVER WHETHER R,T IS A NEW OPERATOR:
      CALL EQOP(R,T,NO,NLAT)
      IF (NO .LE. NOP) GO TO 4
C
C IF HERE, NEW OPERATOR:
   5  NOP=NOP+1
      DO 6 N=2,NOP
      N1 =NOP
      N2 = N
C USE IPERM TO TRY MULTIPLICATION BOTH WAYS ROUND:
      DO 8 IPERM=1,2
      CALL GMPRD (TSYM(1,1,N1),TTRANS(1,N2),T,3,3,1)
      CALL GMPRD (TSYM(1,1,N1),TSYM(1,1,N2),R,3,3,3)
      CALL GMADD(T,TTRANS(1,N1),T,1,3)
      CALL FRAC3(T)
      NP=NO
      CALL EQOP(R,T,NP,NLAT)
C FILL IN MULTIPLICATION TABLE - THIS IS WHY WE NEED TO KNOW WHICH OPERATOR
C IT WAS IF THERE IS A MATCH IN EQOP:
      MLTAB(N1,N2)=NP
      IF (NP.GT.NO) NO=NP
      IF (N1 .EQ. N2) GO TO 6
      N1 = N
      N2 = NOP
   8  CONTINUE
   6  CONTINUE
C THE NEXT TEST REPEATS THE PROCESS ON ANY NEWLY CREATED
C OPERATORS - WE CANNOT ALTER NOP AT THE END OF A DO LOOP:
      IF (NO-NOP) 4,4,5
    4 CONTINUE
C
C HERE WHEN ALL CARDS READ:
      DO 7 N=1,NOP
      MLTAB(1,N)=N
   7  MLTAB(N,1)=N
      IF (NLAT .LT. 2) GO TO  102
C
C     FORM COMPLETE TRANSLATION GROUP
      DO 12 N=2,NOP
      M1=NLAT
      CALL GMPRD(TSYM(1,1,N),ALAT(1,2),T,3,3,1)
      CALL FRAC3(T)
      CALL EQPOS(ALAT,T,M1,M2,4)
      IF (M2 .GT. NLAT) NLAT=M2
  12  CONTINUE
      J = 2
      I = 2
   1  M1=NLAT
      CALL GMADD(ALAT(1,I),ALAT(1,J),T,1,3)
      CALL FRAC3(T)
      CALL EQPOS(ALAT,T,M1,M2,4)
      IF (M2 .GT. NLAT) NLAT=M2
      J=J+1
      IF (J .LE. NLAT) GO TO 1
      I=I+1
      J=I
      IF (I .LE. NLAT) GO TO 1
C
C  COMPLETE GROUP FORMED - NOW FIND GENERATORS
 102  IF (IERR .NE. 0) CALL ERRMES(1,0,'on S cards')
C
      CALL SYMGEN
      RETURN
      END
C
C
C
C
C LEVEL 3      SUBROUTINE SYMREF(HIN,HOUT,NREFS,PHASE)
      SUBROUTINE SYMREF(HIN,HOUT,NREFS,PHASE)
C
C *** SYMREF corrected by PJB (davinda) 22-Apr-1994 ***
C
CX
CC 1B
CH Generates a set of equivalent reflections and related phases.
C
CP The space group symmetry must be set up by a call of SYMOP
C
CA On entry HIN holds an array of 3 reals, h,k,l
CA On exit  HOUT is a 2-D real array of sets of related h,k,l values.
CA          NREFS is set to the number of generated sets (including h,k,l)
CA          PHASE holds an array of scalar products, hx+ky+lz, with h,k,l
CA                corresponding to the array HIN, and x,y,z being the
CA                translation vector corresponding to the symmetry operator
CA                which produced it (in fact, the negated vector for the
CA                inverse operator).
C
%      DIMENSION HIN(3),HOUT(3,%SY*2%),EH(3),PHASE(*),TR(3)
/NSYM/
/SYMDA/
/SYMTAB/
C
      NREFS=0
      DO 2 J=1,NCENT
      DO 1 I=1,NOPC
      CALL ROTSYM(HIN,EH,I,2)
      IF (J .EQ. 2) CALL GMREV(EH,EH,3,1)
      CALL EQVEC(HOUT,EH,NREFS,M,NOP)
      IF (M .GT. NREFS) THEN
        NREFS=M
        CALL GMREV(TRANS(1,INVERS(I)),TR,3,1)
* I suppose this is right?
        IF (J .EQ. 2) CALL GMREV(TR,TR,3,1)
        PHASE(M)=SCALPR(EH,TR)
      ENDIF
   1  CONTINUE
   2  CONTINUE
      RETURN
      END
C
C
C
C
C LEVEL 7      SUBROUTINE SYMTID(NC)
      SUBROUTINE SYMTID(NC)
C
C *** SYMTID by JCM 11 Jul 83 ***
C
CX
CC 1A
CH Tidies all the arrays connected with the space group symmetry.
CP A specialist routine called at the end of routine SYMGEN.
C
CD Copies out of the scratch COMMON /SCRAT/:
CD     rotation matrices TSYM to SYM in /SYMDA/
CD     translation vectors TTRANS to TRANS in /SYMDA/
CD     orders of elements NNORD into NORD in /SYMTAB/
CD     multiplication table from MLTAB to MULTAB in /SYMTAB/
CD
CD An inverting element is indicated by a -ve entry in NORD.
CD
CD Also sets up the constraints imposed on the cell parameters In
CD both spaces) by the symmetry.  This is done here in case the user
CD is about to use routines SCLPRD and VCTMOD, which refer to the
CD cell parameter quadratic products.  If RECIP has not yet been obeyed,
CD the actual cell parameters are not available, so sensible guesses
CD (consistent with the symmetry) are inserted.
C
CO Writes to unit LPT a brief report of the generators.
C
      LOGICAL BINDIG
/CELFIX/
/CELPAR/
/CARDRC/
/IOUNIT/
/NSYM/
%      COMMON /SCRAT/TSYM(3,3,%SY*2%),TTRANS(3,%SY*2%),
%     & MLTAB(%SY*2%,%SY*2%),ITAB(%SYMO%),JTAB(%SY*2%),
%     & NNORD(%SY*2%),D(3,3)
/SYMDA/
/SYMTAB/
C
      CALL MESS(LPT,1,'The group is generated by the')
      IF (NGEN .GT. 0) WRITE (LPT,2001) NGEN,(IGENER(I),I=1,NGEN)
 2001 FORMAT ('+',31X,I3,' element(s) numbered:',3I3)
      IF (CENTRC .AND.  NOP .GT. 2) CALL MESS(LPT,0,'and the')
      IF (CENTRC) CALL MESS (LPT,0,'centre of symmetry.')
C
C  STORE DEFINITIVE SYMMETRY OPERATORS  IN NEW SEQUENCE;  ALSO ORDERS OF
C  ELEMENTS :
      DO 3 N1=1,NOPC
      CALL GMEQ(TSYM(1,1,ITAB(N1)),SYM(1,1,N1),3,3)
      CALL GMEQ(TTRANS(1,ITAB(N1)),TRANS(1,N1),1,3)
      NORD(N1)=NNORD(ITAB(N1))
      IF ((NORD(N1).EQ.0) .AND. (NC .GT. 0)) NORD(N1)=NNORD(MLTAB
     & (ITAB(N1),NC))
C  MAKE THE ORDERS OF INVERTING ELEMENTS NEGATIVE:
      IF (DETER3(SYM(1,1,N1)) .LT.0.) NORD(N1)=-NORD(N1)
C
C STORE MULTIPLICATION TABLE AND INVERSES:
      DO 2 N2=1,NOPC
      MULTAB(N2,N1)=JTAB(MLTAB(ITAB(N2),ITAB(N1)))
      IF (MULTAB(N2,N1) .EQ. 1) INVERS(N1)=N2
   2  CONTINUE
   3  CONTINUE
C
C DIAGNOSTIC OUTPUT IN CASE OF TROUBLE:
      IF (BINDIG(IOUT,16)) THEN
        DO 88 N1=1,NOPC
        WRITE (LPT,4000) (MULTAB(N2,N1),N2=1,NOPC)
        WRITE (ITO,4000) (MULTAB(N2,N1),N2=1,NOPC)
4000    FORMAT (/' MULTAB:',(16I5))
  88    CONTINUE
        WRITE (LPT,4001) (INVERS(I),I=1,NOPC)
        WRITE (ITO,4001) (INVERS(I),I=1,NOPC)
4001    FORMAT (/' INVERS:',(16I5))
        WRITE (LPT,4002) (NORD(I),I=1,NOPC)
        WRITE (ITO,4002) (NORD(I),I=1,NOPC)
4002    FORMAT (/' NORD:',(16I5))
      ENDIF
C
C
C SET UP CONSTRAINTS ON CELL PARAMETERS:
C CLEAR CHAIN INFORMATION FOR ALL CELL PARAMETERS
      IF (INREAD(3) .LT. 0) GO TO 101
      DO 6 I=1,6
   6  IPTCEL(I)=9999
C
C CYCLE OVER ALL SYMMETRY LOOKING FOR RELATIONS
      IF (NOPC .EQ. 1) GO TO 7
      DO 8 NO=1,NGEN
      CALL RELSM6(SYM(1,1,IGENER(NO)),IPTCEL,AMCELL)
   8  CONTINUE
C
C PUT SUITABLE NUMBERS IN CPARS TO KEEP SCLPRD AND VCTMOD HAPPY EVEN IF RECIP
C NOT OBEYED BEFORE SYMUNI:
   7  DO 4 I=1,2
      DO 5 J=1,3
      CPARS(J,I)=1.
      CPARS(J+3,I)=0.
      IF (IPTCEL(J+3) .NE. 0 .AND. IPTCEL(J+3) .LT.4)CPARS(J+3,I)=
     & 0.5*FLOAT(2*I-3)
   5  CONTINUE
   4  CONTINUE
C
C READ I FRIE CARD IF RELEVANT, SETTING LOGICAL FRIEDL FOR "FRIEDEL TO HOLD":
 101  CALL SYMFRI
      RETURN
      END
C
C
C
C
C LEVEL 7      SUBROUTINE SYMUNI
      SUBROUTINE SYMUNI
C
C *** SYMUNI updated by PJB 14 Jun 88 ***
C
CX
CC 1A
CH Selects a reciprocal space asymmetric unit fitting the symmetry.
CP SYMOP should have been obeyed, leaving NORD holding the orders of the
CP       symmetry operators, INVERS pointing at their inverse elements,
CP       FRIEDL set and the operators in SYM and TRANS.
CD Sets up in /FUNIT:
CD         NASYM planes bounding an asymmetric unit in ASYM
CD         EDGE to hold edges
CD         ANG to hold angles
CD         NMUL to hold fraction of reciprocal space used
CD By a call of UNITID makes the found unit hold the required typical h,k,l
CD whose default is 13,11,10 (i.e. all positive, h > k > l)
CD
CD By a call of POLUNI fills in /GUNIT with indicators used in finding the
CD multiplicity of a reflection.
CD
CD Builds up tentative unit in COMMON /SCRAT in ASY, communicating with other
CD routines like FIXUNI via /SCRAT.
CD
CD Works from a list of mirror planes in /SCRAT;  a unit may not contain A
CD mirror.  Notes also if point group is cubic, and takes those separately.
CD
CD Uses a list of axes of symmetry elements in AXI in /SCRAT.
CD If not cubic, and mirror planes are not enough to form a unit of the correct
CD size, uses such axes to form the remaining planes.  If there is only 1 axis,
CD takes an arbitrary plane containing it, and symmetry related planes.
CD
CD If there are more than one, the first is "principal" and must either be
CD perpendicular to a unit plane, or contained in it (all planes).  Planes
CD are taken through this axis and those of other elements in turn.
CD
CD Point group are dealt with as follows:
CD
CD Triclinic: 1 and -1 are singled out; -1 is given an arbitrary plane.
CD Cubic: 3 planes are needed, each containing two axes.  If no 4 axis,we have:
CD    either  23 for which we need three 3 axes (distinguished by NMUL=12)
CD    or      m3 for which we need one 3 and two 2's
CD
CD    If a 4 is present, then 4 3 3 will do for 432 and -43m,
CD           but m3m needs 4 3 2 (and is detected by having NMUL=48).
CD
CD Mirrors: use of mirrors as planes will finish:
CD       monoclinic: m
CD       orthorhombic: mm2 and mmm
CD       tetragonal: 4mm and 4/mmm
CD       trigonal 3m
CD       hexagonal: 6mm, -6m2 and 6/mmm
CD
CD Single axis: a number of planes through a single axis will finish:
CD       monoclinic: 2 and 2/m
CD       orthorhombic: no more
CD       tetragonal: 4, -4 and 4/m (which has also 1 mirror)
CD       trigonal: 3 and -3
CD       hexagonal:  6, -6, 6/m (the last two having 1 mirror also)
CD
CD Principal axis: planes through principal axis and a "2" axis finish:
CD       orthorhombic: 222
CD       tetragonal: 422 and -42m (which has 1 mirror also)
CD       trigonal: 32
CD       hexagonal: 622
CD
CD This leaves -3m, which belongs to the "principal axis" category above, but
CD because we have removed the centrosymmetrically related operators has no
CD explicit "2" axes left.  There are two ways of dealing with this - a plane
CD perpendicular to the principal axis, or a halving of the angle between
CD existing planes.  For the moment the former is taken.
CD
CO If the procedure outlined above does not produce a sensible outcome, writes
CO error mesages and stops.
C
CN This highlights a general point.  For most point groups it is evident how
CN many planes must be used to slice space into suitable units, but for a
CN subset of them (422, -42m, -3, 32, -3m, 622 : for laymen, those which:
CN          are non-cubic
CN          have at least 6 spots
CN          have both black and white spots
CN          but not superimposed
CN the space may be carved into two different sets of units, one with 3 faces
CN and one with 2.  The above methods will generally give preference to 2,
CN except in the case of -3m as described.
CN
CN The user may not get exactly the unit he wants for this reason.  He is
CN allowed to specify typical indices of a reflection to be inside the finished
CN unit, but this will not influence the carving in the cases mentioned.  I
CN have in mind to allow him also to offer a plane, so that, e.g., in
CN 422 if he offers the equator plane, he will get the broader wedge of space
CN cut off by that plane, instead of the narrower wedge "infinite" in both
CN directions.
C
      DIMENSION XAX(3),ZAX(3)
/FRIED/
/FUNIT/
/IOUNIT/
/NSYM/
%      COMMON /SCRAT/AXI(3,%SYMO%,2),MIRROR(%SYMO%),D(3,3),PL1(3),PL2(3),PL3(3),
     & HT(3),ASY(3,4),NSTAT(4),NOPL,NICE,VOL,MOP1,MOP2
/SYMDA/
/SYMTAB/
      DATA XAX,ZAX/1.0,0.,0.,0.,0.,1./
C
C READ IN POSSIBLE U CARD GIVING 3 TYPICAL INDICES REQUIRED BY USER TO
C BE WITHIN THE FINISHED ASYMMETRIC UNIT.  IF NO U CARD USE 13,11,10:
      CALL INPUTU(HT)
C
C CLEAR SPACE FOR FIXUNI TO BUILD UP NOPL PLANES IN ASY WITH STATUS NSTAT:
      NOPL=0
      CALL GMZER(ASY(1,1),3,4)
      CALL JGMZER(NSTAT,1,4)
C
C NMUL=FRACTION OF UNIT INVOLVED AND MUST TAKE ACCOUNT OF FRIEDEL:
      NMUL=NOP
      IF (FRIEDL) NMUL=NOPC*2
C
C JUMP IF POINT GROUP 1, NO PLANES AT ALL REQUIRED:
      IF (NMUL.EQ.1) GO TO 102
C JUMP IF NOT POINT GROUP -1:
      IF (NOPC .GT. 1) GO TO 2
C SPECIAL FOR P-1 OR P1 WITH FRIEDEL - PUT IN 0 0 1 AND ACCEPT:
      CALL FIXUNI(ZAX,1)
      GO TO 102
C
C HERE FOR MONOCLINIC ONWARDS:
C SET UP AXES OF SYMMETRY ELEMENTS, AND MARK MIRROR PLANES IF THEY EXIST:
C NOTE LASTAX=NO. OF LAST ELEMENT OF LIST (IRRELEVANT ELEMENTS ARE ALREADY 0)
C NP2 = FIRST "2", NP3 = FIRST "3" (THERE ARE NO -3) AND NP4 = FIRST "4"
C AND COUNT "3" AXES IN N3, BEAUSE CUBIC HAS 4 OF THESE AND NOTHING ELSE HAS >1
C ALSO, NPP2 IS SET TO POINT TO THE FIRST +2 (NOT -2) FOR THE SPECIAL CASE -3M.
C
   2  LASTAX=0
      N3=0
      NP2=0
      NPP2=0
      NP3=0
      NP4=0
      DO 3 N=2,NOPC
      MIRROR(N)=0
      IF (IABS(NORD(N)).GT.100) THEN
        CALL GMZER(AXI(1,N,1),3,1)
        CALL GMZER(AXI(1,N,2),3,1)
        GO TO 3
      ENDIF
C  GET THE AXIS IN REAL SPACE
      CALL AXIS(SYM(1,1,N),AXI(1,N,1))
C  GET THE AXIS IN RECIPROCAL COORDINATES
      CALL GMEQ(SYM(1,1,INVERS(N)),D,3,3)
      CALL TRANSQ(D,3)
      CALL AXIS(D,AXI(1,N,2))
C
C PICK OUT USEFUL AXES:
      LASTAX=N
      IF (NORD(N) .EQ. 2) NPP2=N
      I=IABS(NORD(N))
      IF (I .EQ. 3) N3=N3+1
      IF (I .EQ. 2 .AND. NP2 .EQ. 0) NP2=N
      IF (I .EQ. 3 .AND. NP3 .EQ. 0) NP3=N
      IF (I .EQ. 4 .AND. NP4 .EQ. 0) NP4=N
C
C MARK MIRRORS:
      IF (NORD(N).EQ.-6 .OR. NORD(N).EQ.-2) GO TO 4
      IF (.NOT.FRIEDL) GO TO 3
      IF (NORD(N).EQ.3) GO TO 3
   4  MIRROR(N)=1
   3  CONTINUE
C
C IF PRINCIPAL AXIS IS A "2" MOVE NP2 PAST IT:
      IF (NP2 .EQ. 2) NP2=3
C
C JUMP IF NOT CUBIC:
      IF (N3 .NE. 4) GO TO 5
C JUMP IF NO "4" AXIS:
      IF (NP4 .EQ. 0) GO TO 6
C
C PICK PLANE THROUGH 4 AND ANY 3:
      CALL VECPRD(AXI(1,NP4,2),AXI(1,NP3,2),PL1)
C AND INSIST ON KEEPING IT:
      CALL FIXUNI(PL1,2)
C NOW DISTINGUISH BETWEEN M3M AND THE REST;  4 3 3 FOR M3M IS NOT SMALL ENOUGH:
      NSTART=NP3+1
      NS=3
      IF (NMUL .LT. 48) GO TO 19
      NSTART=NP2
      NS=2
C SCAN REMAINING OPERATORS LOOKING ONLY AT SUITABLE AXES:
  19  DO 7 J=NSTART,LASTAX
      IF (IABS(NORD(J)) .NE. NS) GO TO 7
C MAKE 2 MORE PLANES, EACH THROUGH NEW AXIS AND ONE OF ORIGINAL:
      CALL VECPRD(AXI(1,J,2),AXI(1,NP4,2),PL1)
      CALL VECPRD(AXI(1,NP3,2),AXI(1,J,2),PL2)
      CALL FIXUNI(PL1,1)
      CALL FIXUNI(PL2,1)
      IF (NICE) 8,102,8
C IF NICE IS EVER 0 WE ARE HOME - OTHERWISE TAKE NEXT 3RD AXIS:
   8  CALL FIXUNI(PL1,-2)
      CALL FIXUNI(PL2,-3)
   7  CONTINUE
C
C  SHOULD NOT GET HERE:
      GO TO 11
C
C CUBIC WITH NO 4 AXIS - IS IT 23 OR 3M?:
   6  IF (NMUL .NE. 12) GO TO 20
C 23 - UNIT MUST HAVE THREE 3 AXES AS EDGES, ANY ANY 3 SHOULD DO:
      I=NP3
      J=I
  21  J=J+1
      IF (J .GT. LASTAX) GO TO 11
      IF (NORD(J) .NE. 3) GO TO 21
      K=J
  22  K=K+1
      IF (K .GT. LASTAX) GO TO 11
      IF (NORD(K) .NE. 3) GO TO 22
      CALL PLN3AD(I,J,K)
      IF (NICE) 11,102,11
C
C M3 - WANT ONE 3 AXIS AND TWO 2S:
  20  DO 9 J=NP2,LASTAX
C PICK OUT PAIRS OF 2 AXES TO PUT WITH 3:
      IF (NORD(J) .NE. 2) GO TO 9
      IF (J .EQ. LASTAX) GO TO 11
      J1=J+1
      DO 39 K=J1,LASTAX
      IF (NORD(K) .NE. 2) GO TO 39
      CALL PLN3AD(NP3,J,K)
      IF (NICE) 10,102,10
C
C IF DO NOT MAKE GOOD CELL, TAKE ALL 3 OUT AGAIN:
  10  CALL FIXUNI(PL1,-1)
      CALL FIXUNI(PL2,-2)
      CALL FIXUNI(PL3,-3)
  39  CONTINUE
   9  CONTINUE
C
C SHOULD HAVE MADE GOOD UNIT BY NOW:
  11  WRITE (LPT,3000)NP2,NP3,NP4
      WRITE (ITO,3000)NP2,NP3,NP4
3000  FORMAT (/' *** PROGRAM ERROR in SYMUNI - all cubic axes scanned',
     & ' - NP2, NP3, NP4=',3I3)
      STOP
C
C NEITHER TRICLINIC NOR CUBIC - TRY ALL MIRRORS:
   5  DO 12 N=2,LASTAX
      IF (MIRROR(N).EQ.0) GO TO 12
      CALL FIXUNI(AXI(1,N,1),1)
      IF (NICE) 12,102,12
   12 CONTINUE
C
C MIRRORS INADEQUATE - PICK OUT THOSE WITH ONLY 1 SYMMETRY ELEMENT (OTHER THAN
C THE UNIT, A CENTRE, OR THOSE GENERATED FROM THE ONE):
      IF (LASTAX .NE. 2) GO TO 13
C THIS ASSUMES THAT SUCH AN AXIS IS ELEMENT 2 - SO LONG AS WE HAVE COME IN VIA
C SYMOP, SYMGEN IT WILL BE:
C
C TAKE PLANE THROUGH AXIS AND X AXIS (OR Z AXIS):
  18  CALL VECPRD(AXI(1,2,2),XAX,PL1)
      IF (VCTMOD(1.0,PL1,1).LT.0.0001) CALL VECPRD(AXI(1,2,2),ZAX,PL1)
C MAKE THIS FIRST PLANE MANDATORY:
      CALL FIXUNI(PL1,2)
      IF (NICE) 15,102,15
C NEED ANOTHER PLANE - SWING IT:
  15  DO 14 I=2,NOPC
      CALL ROTSYM(PL1,PL2,I,1)
      CALL FIXUNI(PL2,1)
      IF (NICE) 14,102,14
  14  CONTINUE
C
C SHOULD BE ENOUGH:
      CALL ERRMES(-1,0,'in SYMUNI - single axis not enough')
C
C HAVE PRINCIPAL AXES PLUS OTHERS - ARE THERE ANY 2'S?
  13  IF (NPP2 .EQ. 0) GO TO 16
C MAKE PLANES THROUGH PRINCIPAL AND A 2 AND OFFER IN TURN:
      DO 17 J=NP2,LASTAX
      IF (NORD(J) .NE. 2) GO TO 17
      CALL VECPRD(AXI(1,2,2),AXI(1,J,2),PL1)
      CALL FIXUNI(PL1,1)
      IF (NICE) 17,102,17
  17  CONTINUE
C
C THIS CONTINUAL OFFERING DOES NOT REMOVE THE PLANES IT DOES NOT LIKE, AND
C MAY CAUSE TROUBLE.
C
C SHOULD HAVE BEEN ENOUGH - IF NOT ONLY CASE  SHOULD BE CENTRE NOT AT ORIGIN:
      IF (.NOT. CENTRC) GO TO 18
      CALL ERRMES(-1,0,
     & 'in SYMUNI - principal axis plus 2 axes not enough')
C
C WE SHOULD BE AT -3M HERE, WITH 2 MIRRORS, BUT UNIT TOO BIG.  HALVE IT:
  16  CALL FIXUNI(AXI(1,2,1),1)
      IF (NICE .NE. 0) CALL ERRMES(-1,0,'reached end of SYMUNI')
C
C SUCCESSFUL UNIT - TIDY IT AND TRANSFORM TO HOLD TYPICAL REFLECTION:
 102  CALL UNITID
C
C FINAL UNIT - MARK EDGES FOR MULTIPLICITY:
      CALL POLUNI
C
      RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE TB02A(A,F,X,Y,N)
      SUBROUTINE TB02A(A,F,X,Y,N)
C
C *** TB02A updated by JCM from HARWELL ***
C
CX
CC 9C
CH Interpolates in non-equal interval table.
CA On entry real arrays A and F hold the arguments and function values
CA          X holds the required argument
CA          N is the dimension of A and F, and so is the number of items
CA On exit  Y holds the interpolated function value
C
      DIMENSION A(N),F(N)
      Y=0.0
      DO 1 L=1,N
      PL=1.0
      DO 3 J=1,N
      IF(L .EQ. J) GO TO 3
      PL=(X-A(J))*PL/(A(L)-A(J))
   3  CONTINUE
   1  Y=Y+PL*F(L)
      RETURN
      END
C
C
C
C
C LEVEL 5      SUBROUTINE TBLFND(NAME,IANS,IFAM,IGEN,ISPC,KP,KS)
      SUBROUTINE TBLFND(NAME,IANS,IFAM,IGEN,ISPC,KP,KS)
C
C *** TBLFND updated by JCM 8 May 90 ***
C
CX
CC 6C
CH Looks for an A4 NAME in every table it can find, trying to identify it as
CH part of a LSQ parameter name.
CA On entry NAME is the target name to find
CA On exit IANS gives the answer:
CA  IANS=0 means cannot find NAME anywhere
CA  IANS=large -ve means that NAME is not part of a parameter specification,
CA        but some other word recognised on a FIX/VARY card, like:
CA        'ONLY' (-99) or 'ALL' (-100)
CA  IANS=small -ve means that NAME is a word recognised from the user's
CA        table, and IANS has been picked up from the user's parallel table
CA        table of small -ve integers or parameter specs
CA  IANS=+ve means that NAME was part of a parameter specification;  it may
CA        be a family, genus or species name, and from it may have been
CA        deduced other things (like family name from genus name)
CA
CA        In this case, as many of IFAM, IGEN and ISPC as can be set on exit
CA        are set.
C
CP Expects LSQ to have been set up by LSETUP;  if structure parameters are to
CP be LSQ parameters, expects tables of atom names in /ATNAM and form factor
CP names in /FONAM
CP
CP If Multiphase, expects KPHASE to hold phase required for this one word.
C
      CHARACTER *4 NAME,ITB(2)
      DIMENSION ITBSPC(2)
/ATNAM/
/CHARS/
/FONAM/
/FORMDA/
/FORMD2/
/GLOBAL/
/PHASE/
/POSNS2/
/PRBLEM/
/SOURCE/
/WDSPC/
/WORDS/
      DATA ITB/'ALL','ONLY'/
      DATA ITBSPC/-100,-99/
C
C CLEAR ANSWERS:
      IFAM=0
      IGEN=0
      ISPC=0
      KP=0
      KS=0
C
C FIRST TRY TO FIND IN MAIN WORD TABLE WHICH WAS SET UP IN THE MAIN PROGRAM TO
C SPECIFY THE PROBLEM:
      L=NCFIND(NAME,LSQWD,IWDNUM)
      IF (L .GT. 0) THEN
C FOUND IN WORD TABLE - PARALLEL ARRAY IWDSPC SHOULD BE PACKED INFO
C AS TO WHAT THIS WORD ACTUALLY IS:
        IANS=IWDSPC(L)
        IF (IANS .GT. 0) CALL KUNPAK(IANS,IFAM,IGEN,ISPC,KP,KS)
        GO TO 100
      ENDIF
C
C NEXT TRY TBLFND'S OWN TABLE OF USEFUL WORDS APPLICABLE TO MOST LSQ:
      L=NCFIND(NAME,ITB,2)
      IF (L .GT. 0) THEN
        IANS=ITBSPC(L)
        GO TO 100
      ENDIF
C
C TRY DIGITS (SPECIES NAMES INVOLVED IN FAMILY 1, OR 3 ETC. ):
      N=0
      DO 4 J=1,4
C A DIGIT WILL BE LEFT-JUSTIFIED:
      IF (NAME(J:J) .NE. ' ') THEN
        DO 2 I=1,10
        IF (NAME(J:J) .EQ. IDIGIT(I)) GO TO 3
   2    CONTINUE
      ENDIF
      IF (N .EQ. 0) GO TO 5
      GO TO 9
   3  IF (I .EQ. 10) I=0
      N=10*N+I
   4  CONTINUE
   9  ISPC=N
C GO TO PACK INTO IANS
      GO TO 102
C
C OTHER WORDS REFER TO FAMILY 2 OR MORE - CHECK THERE MAY BE SOME:
   5  IF (NFAM .LT. 2) GO TO 101
      IF (MULFAS) THEN
        L=NCFIND(NAME,ATNA(1,KPHASE),NATO(KPHASE))
      ELSE
        L=IATOM(NAME)
      ENDIF
      IF (L .GT. 0) THEN
        IGEN=L
        IFAM=2
        GO TO 102
      ENDIF
C
C MAY BE SCATTERING FACTOR NAME:
      IF (MULFAS) THEN
        ISC=NCFIND(NAME,FONA(1,KPHASE),NMFNM(KPHASE))
      ELSE
       ISC=ISCAT(NAME)
      ENDIF
      IF (ISC .GT. 0) IGEN=NBKF(ISC,KPHASE)
      IF (IGEN .EQ. 0) GO TO 101
      ISPC=10
      IFAM=2
C IFAM, IGEN, ISPC OK - PACK INTO IANS:
 102  IANS=KPAK(IFAM,IGEN,ISPC,KPHASE,0)
      KP=KPHASE
      GO TO 100
C
C WORD CANNOT BE FOUND:
 101  IANS=0
 100  RETURN
      END
C
C
C
C
C LEVEL 2      SUBROUTINE TBOUND(IFOUND)
      SUBROUTINE TBOUND(IFOUND)
C
C *** TBOUND by PJB Aug 86 ***
C
CX
CC 5B
CH A specialist routine used duing the plotting of atomic positions
CH in main program ATMPLO.
C
      DIMENSION Y(3)
%      COMMON/SCRAT/AA(3,3),TRXX(3,%SY*2%),TLAT(3,4),BOUNDS(2,6),XX(3,3),
     & TMPV1(3),TMPV2(3),TMPV3(3),TTXX(3,50),NT
      EQUIVALENCE(Y,TMPV1)
C
C  FIRST GET JUST INSIDE THE LOWER BOUND
      IFOUND=0
      CALL GMEQ(Y,XX(1,NT),1,3)
      DO 3 I=1,NT
    1 DIFF=XX(I,NT)-BOUNDS(1,I)
      IF (DIFF.GT. -.001) GO TO 2
      XX(I,NT)=XX(I,NT)+1.
      GO TO 1
C
C  HERE IF INSIDE LOWER BOUND, SEE IF LOWEST POSSIBLE
    2 IF (DIFF.LT.1.) GO TO 3
      XX(I,NT)=XX(I,NT)-1.
      DIFF=DIFF-1.
      GO TO 2
    3 CONTINUE
C
C  NOW TEST UPPER BOUND
      J=NT
   12 IF (BOUNDS(2,J)-XX(J,J).LT.-.001) GO TO 10
      IF (J.EQ.1) THEN
C  TEST IF STRICLY INSIDE BOX
      CALL GMPRD(XX(1,1),AA,TMPV2,1,3,3)
      DO 21 I=1,3
      IF (TMPV2(I).LT.BOUNDS(1,3+I) .OR. TMPV2(I).GT.BOUNDS(2,3+I))
     &  GO TO 10
   21 CONTINUE
      IFOUND=IFOUND+1
      CALL GMEQ(TMPV2,TTXX(1,IFOUND),1,3)
      XX(1,1)=XX(1,1)+1.
      ELSE
      CALL GMEQ(XX(1,J),XX(1,J-1),1,3)
      J=J-1
      ENDIF
      GO TO 12
C
C  HERE IF TESTED POINT OUTSIDE
   10 IF(J.EQ.NT) GO TO 100
      J=J+1
      XX(J,J)=XX(J,J)+1.
      GO TO 12
C
C  HERE WHEN NO MORE POSSIBILITIES
 100  RETURN
C
      END
C
C
C
C
C LEVEL 6      SUBROUTINE TCHALC(H)
      SUBROUTINE TCHALC(H)
C
C *** TCHALC new by PJB  from LCHALC C4.17 July 2009  ***
C
CX
CC 17B
CHCalculates magnetic structure factor tensors and derivatives on K-based axes
CA On entry H is the 1x3 vector containing h,k,l
CA On exit   FMCPOL = is the mean of the projection of the interaction vector
CA                    on any direction perpendicular to H
CD           FMCSQR = is the mean squared modulus of the magnetic interaction vector
CP RECIP, SYMOP, SETANI, SETFOR and DOMAG1 must have been obeyed to set up
CP the structure factor calculation. (They are all called by SETFCM)
CP The LSQ environment must have been set up by a suitable MAIN program (like
CP SFLSQ) which has called LSETUP and VARMAK.
CP The calculation uses transformed susceptibility compinents X(1,IR) which must
CP be set up for each data source (field direction)  before calls to FCHCAL.
CP
CD On exit, in /MCAL/:
CD    FMCDER is an array containin g the derivatives of the mean square interaction
CD           vector wrt the family 2 (structure) parameters (Not multiplied by anything)
CD On exit,  /QCAL/ contains just the complex projcetion of Mperp:
CD On exit, in /QCALD/:
CD    FQCDER is an array containing the derivatived of the Q above with respect to
CD           all the family 2 parameters.
CD
CD All the above will be zero if h,k,l is a magnetic absence
CN Note the existence also of LFCALC (nuclear structure factors for LSQ)
CN                            FMCALC (magnetic structure factors)
CN                            FCALC  (nuclear structure factors)
C
CN  The arrays of dimension 6 are for the symmetric tensors, used here instead of
CN  magnetic moment vectors
%      COMPLEX DERIVM(6,%F2VA%),SUM1(6),TERM,TVEC(6),FORM,HR,FORMFA
     &,FMC(6)
      LOGICAL MAGABS,BINDIG
      DIMENSION RH(3),H(3),RS(6),TRAN(6,6),CHISYT(6,6)
/ANISO/
/BRAGG/
/CONSTA/
/DSOURC/
/IOUNIT/
/MAGCHI/
/MAGDAT/
      DIMENSION CHIIJ(6,20),KCHIJ(6,20)
      EQUIVALENCE (ANGM,CHIIJ),(KSMOD,KCHIJ)
/MCAL/
/NSYM/
/PHASE/
/POINTS/
/POSNS/
/PRBLEM/
/QCAL/
/QCALD/
/SATELL/
/SYMDA/
/SYMTAB/
C      DATA IPTR/1,6,4,6,2,5,4,5,3/

C
C Set single phase
      JPHASE=1
C
C CLEAR ALL ANSWERS IN CASE ABSENT:
C CLEAR MODULUS AND SQUARE:
      FMCMOD=0.
      FMCSQR=0.
      SSQRD=STHL*STHL
C CLEAR DERIVATIVES:
      L2=NVARF(2,JPHASE,1)
      IF (L2 .GT. 0) CALL GMZER(FMCDER,1,L2)
C
C OUT IF ABSENT:
      IF (MAGABS(H,IK)) GO TO 100
C
C  No DOMAINS with paramagnetic structures
      ND=0
C FMC COLLECTS THE MAGNETIC STRUCTURE TENSOR, A COMPLEX SYMMetric TENSOR,
C initialised here
      CALL CGMZER(FMC,1,6)
C
C FIRST SCATTERING FACTOR:
      IFF=0
C
C OFFSET TO REACH THE FAMILY 2 VARIABLES:
      LO=LVFST1(2,JPHASE,1)
C CLEAR DERIVATIVE VECTOR FOR ALL FAMILY 2:
      DO 82 I=1,L2
      DO 82 J=1,6
  82  DERIVM(J,I)=0.
C
C CYCLE OVER MAGNETIC ATOMS:
      DO 1 IM=1,NMAG
      IR=JMAGAT(IM)
C
C GET NEW FORM FACTOR IF DIFFERENT FROM THE PREVIOUS ONE
      IF (NMFORM(IM) .NE. IFF) THEN
        IFF=NMFORM(IM)
        FORM=FORMFA(STHL,IFF)
      ENDIF
C
      CALL CGMZER(SUM1,6,1)
C
C SYMMETRY CYCLE
      DO 3 IS=1,NOPC
      CALL ROTSYM(H,RH,IS,-1)
C ANISOTROPIC T F (=1. IF NOT THERE) NEEDED SEPARATELY FOR LSQ:
      F1=TWOPI*(SCALPR(X(1,IR),RH)+SCALPR(TRANS(1,IS),H))
      ERS=ANITF(RH,IR)
      ARS=COS(F1)*ERS
      BRS=SIN(F1)*ERS
      TERM=CMPLX(ARS,BRS)
      CALL GMTRAN(CHISYM(1,1,IS),CHISYT,6,6)
C CHISYM no longer depends on the data source (here for a powder)
      CALL GMPRD(CHISYT,CHIIJ(1,IM),RS,6,6,1)
      if (BINDIG(iout,1024)) write (lpt,3000) is,real(term),RS
 3000 format ( i3,f8.2,2x,6f8.4)
      CALL C1MSCA(RS,TVEC,TERM,6,1)
C IF CENTROSYMMETRIC, COMPENSATE FOR USING ONLY HALF NUMBER OF OPERATORS:
      IF(CENTRC) CALL CMRSCA(TVEC,TVEC,2.0,6,1)
      CALL CGMADD(SUM1,TVEC,SUM1,1,6)
C      if (BINDIG(iout,1024))
C     &WRITE (LPT,1000) is,real(term),!(real(tvec(i)),i=1,6)
C     &(real(SUM1(i)),i=1,6)
C 1000 FORMAT (i3,2x,f8.3,2x,2(6f8.3,2x))
C
C NOW WE DO THE INNERMOST SUMS FOR THE DERIVATIVES OF FMCMOD WRT
C VARIABLES XYZ AND ALL BIJ.  WE USE THE
C COMPLEX VECTOR DERIVM TO ACCUMULATE THE DERIVATIVES OF THE REAL &
C IMAGINARY PARTS OF THE COMPLEX FC WRT EACH VARIABLE IN TURN.
C
      DO 7 I=1,3
      L = KX(I,IR)
      IF (L .GT. 0) THEN
        CALL C1MSCA(RS,TVEC,RH(I)*CMPLX(-BRS,ARS),6,1)
        IF(CENTRC) CALL CMRSCA(TVEC,TVEC,2.0,3,1)
        CALL CGMADD(DERIVM(1,L-LO),TVEC,DERIVM(1,L-LO),1,6)
      ENDIF
   7  CONTINUE
C
C JUMP IF NOT ATF AT ALL:
      IA=IAPT(IR)
      IF (IA .EQ. 0) GO TO 6
      I2=2
      I3=3
      DO 4 I=1,3
      L = KATF(I,IA)
      IF (L .GT. 0) THEN
C114 I1 replaced by I in next line
        CALL C1MSCA(RS,TVEC,RH(I)*RH(I)*TERM,6,1)
        IF(CENTRC) CALL CMRSCA(TVEC,TVEC,2.0,6,1)
        CALL CGMADD(DERIVM(1,L-LO),TVEC,DERIVM(1,L-LO),1,6)
      ENDIF
      L = KATF(3+I,IA)
      IF (L .GT. 0) THEN
        CALL C1MSCA(RS,TVEC,RH(I2)*RH(I3)*TERM,6,1)
        IF(CENTRC) CALL CMRSCA(TVEC,TVEC,2.0,6,1)
        CALL CGMADD(DERIVM(1,L-LO),TVEC,DERIVM(1,L-LO),1,6)
      ENDIF
      I2=I3
      I3=I
    4 CONTINUE
C NOW DERIVATIVES FOR SUSCEPTIBILITIES
    6 DO 14 I=1,6
      L=KCHIJ(I,IM)
      IF (L .GT. 0) THEN
C4.11 CHISYM no longer depends on the data source
        CALL C1MSCA(CHISYT(1,I),TVEC,TERM,1,6)
        IF(CENTRC) CALL CMRSCA(TVEC,TVEC,2.0,6,1)
        CALL CGMADD(DERIVM(1,L-LO),TVEC,DERIVM(1,L-LO),1,6)
      ENDIF
   14 CONTINUE
C
   3  CONTINUE
C END OF INNERMOST CYCLE OVER SYMMETRY
C
C SCALE MOMENT TO CMS-12 AND WITH FIELD, CORRECT FOR MULTIPLICITY
      AM=AMULT(IR)
      HR=FORM*SITE(IR)*VALMUB*AMULT(IR)*FIELD
C HR IS PRODUCT OF ATOM DEPENDENT BUT SYMMETRY INDEPENDENT FACTORS
      CALL CGMSCA(SUM1,TVEC,HR,6,1)
      CALL CGMADD(FMC,TVEC,FMC,1,6)
C
C  NOW WE TIDY UP THE XYZ AND BIJ DERIVATIVES, AND MAKE ITF, SITE
C  AND MU
      DO 8 I=1,3
      L = KX(I,IR)
      IF (L .GT. 0)
     & CALL CGMSCA(DERIVM(1,L-LO),DERIVM(1,L-LO),TWOPI*HR,6,1)
      IF (IA .GT. 0) THEN
        L = KATF(I,IA)
        IF (L .GT. 0)
     &  CALL CGMSCA(DERIVM(1,L-LO),DERIVM(1,L-LO),HR,6,1)
      L = KATF(I+3,IA)
        IF (L .GT. 0)
     &  CALL CGMSCA(DERIVM(1,L-LO),DERIVM(1,L-LO),HR*2.,6,1)
      ENDIF
   8  CONTINUE
C
      L = KSITE(IR)
      IF (L .GT. 0)
     & CALL CGMSCA(SUM1,DERIVM(1,L-LO),HR/SITE(IR),3,1)
      L = KTF(IR)
      IF (L .GT. 0)
     & CALL CGMSCA(SUM1,DERIVM(1,L-LO),-(SSQRD*HR),3,1)
C RESCALE CHI DERIVATIVES
      DO 19 I=1,3
      L=KCHIJ(I,IM)
      IF (L .GT. 0) CALL CGMSCA(DERIVM(1,L-LO),DERIVM(1,L-LO),HR,6,1)
      L=KCHIJ(I+3,IM)
      IF (L .GT. 0) CALL CGMSCA(DERIVM(1,L-LO),DERIVM(1,L-LO),HR,6,1)
   19 CONTINUE
C
   1  CONTINUE
C END OF CYCLE OVER ATOMIC POSITIONS
C
C  FMC Is now a COMPLEX tensor on ORTHOGONAL CRYST COORDINATES
C      write (lpt,3002) H,(real(FMC(i)),i=1,6)
C TRANSFORM TO K-BASED AXES
      CALL TRAN2K(H,TRAN,TKMAT)
      CALL RCMPRD(TRAN,FMC,TCALC,6,6,1)
C      write (lpt,3001) (real(tcalc(i)),i=1,6)
      DO 20 I = 1,L2
C      write (lpt,3001) (real(DERIVM(j,i)),j=1,6)
      CALL RCMPRD(TRAN,DERIVM(1,i),FTCDER(1,I),6,6,1)
C       WRITE (LPT,3001) (FTCDER(j,I),j=1,6)
   20 CONTINUE
C 3002 FORMAT (3F4.0,6F8.3)
C 3001 FORMAT (12x,6(2F8.3,1X))
C PROJECT OUT MAGNETIC SCATTERING ACCORDING TO DATA-TYPE
      CALL PRJECT(l2,TKMAT)

 100  RETURN
      END
C
C
C
C
C LEVEL 1      LOGICAL FUNCTION TESTOV(A,B)
      LOGICAL FUNCTION TESTOV(A,B)
C
C *** TESTOV by JCM 22 Nov 83 ***
C
CX
CC 11C
CH Tests a floating division for potential overflow.
CA On entry A is the real numerator
CA          B is the real denominator
CA on exit  TESTOV is set .TRUE. if A/B would overflow, .FALSE. if not.
C
      TESTOV = ((A+B) .EQ. A)
      RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE TESTP(LUN,LINO,I,HEADNG,NL)
      SUBROUTINE TESTP(LUN,LINO,I,HEADNG,NL)
C
C *** TESTP by JCM 16 Oct 85 ***
C
CX
CC 13C
CH Puts a given heading at top of every printer page, counting lines.
CA On entry LUN is the required output unit number
CA          LINO is the number of lines already output on the current page
CA          I is the number of lines required to be output on this call
CA          HEADNG is the character variable holding the heading
CA          NL is the number of lines in HEADNG
CA On exit  LINO has been updated.
CD Tests the potential output against a page size of NLINES
CO If necessary, throws a page and puts out the heading on unit LUN
C
      CHARACTER*(*) HEADNG
%      DATA NLINES/%LNPP%/
C
      LINO=LINO+1
      IF (LINO+I .LT. NLINES) GO TO 100
      IF (LINO .LT. NLINES-4) GO TO 100
      CALL NEWPAG(LUN)
      WRITE (LUN,FMT=HEADNG)
      LINO=NL+1
 100  RETURN
      END
C
C
C
C
C LEVEL 5      FUNCTION THREEJ(AJ)
      FUNCTION THREEJ(AJ)
C
C ***  THREEJ  NEW BY by PJB April 03 ***
C
CH RETURNS A 3J COEFFICIENT
C
CC 9C
C
CA AJ(6) holds the angular momentum quantum numbers
CA They are floating point numbers, only because they may be half
CA integral.
C
      DIMENSION AJ(6)
      VEC=VECOUP(AJ(1),AJ(4),AJ(2),AJ(5),AJ(3),-AJ(6))
      IJ=NINT(AJ(1)-AJ(2)-AJ(6))
      THREEJ=VEC*SQRT(1/(2.*AJ(3)+1.))
      IF (MOD(IJ,2) .NE.0) THREEJ=-THREEJ
      RETURN
      END
C
C
C
C
C LEVEL 3      SUBROUTINE TQLI(D,E,N,NP,Z,BOTH)
      SUBROUTINE TQLI(D,E,N,NP,Z,BOTH)
C
C *** TQLI by JCM from "NUMERICAL RECIPES"  Dec 89 ***
C
CX
CC 9C
CH Performs the QL algorithm for eigenvalues and vectors of a real
CH symmetric matrix previously reduced to tridiagonal form.
CA On entry D is a real vector of length NP whose first N elements are the
CA            diagonal elements of the required tridiagonal matrix;
CA          E similarly holds the sub-diagonal matrix;  E(1) is arbitrary.
CA          N is the size of all required matrices and vectors;
CA          NP is their DIMENSION in the routine, and may be larger.
CA          Z is an NPxNP array holding an NxN matrix.  If the routine
CA            TRED2 has been used to reduce the matrix to tridiagonal, Z should
CA            on entry to TQLI contain the matrix on exit from TRED2.
CA            Otherwise it should contain a unit matrix.
CA          BOTH is a logical, set TRUE if both eigenvalues and eigenvectors
CA             are wanted.
CA On exit  D holds the eigenvalues, and the Kth column of Z holds the
CA            normalised eigenvector corresponding to D(K).
C
CN Adapted from Press, Flannery, Teukolsky & Vetterling, Numerical Recipes.
C
      LOGICAL BOTH
      DIMENSION D(NP),E(NP),Z(NP,NP)
C
      IF (N .LE. 1) GO TO 100
      DO 11 I=2,N
      E(I-1)=E(I)
  11  CONTINUE
C
      E(N)=0.
      DO 15 L=1,N
      ITER=0
   1  DO 12 M=L,N-1
      DD=ABS(D(M))+ABS(D(M+1))
      IF (ABS(E(M))+DD.EQ.DD) GO TO 2
  12  CONTINUE
C
      M=N
   2  IF (M .NE. L) THEN
        IF (ITER.EQ.30)
     &   CALL ERRMES(1,0,'too many iterations IN TQLI')
        ITER=ITER+1
        G=(D(L+1)-D(L))/(2.*E(L))
        R=SQRT(G**2+1.)
        G=D(M)-D(L)+E(L)/(G+SIGN(R,G))
        S=1.
        C=1.
        P=0.
        DO 14 I=M-1,L,-1
        F=S*E(I)
        B=C*E(I)
        IF(ABS(F).GE.ABS(G))THEN
          C=G/F
          R=SQRT(C**2+1.)
          E(I+1)=F*R
          S=1./R
          C=C*S
        ELSE
          S=F/G
          R=SQRT(S**2+1.)
          E(I+1)=G*R
          C=1./R
          S=S*C
        ENDIF
        G=D(I+1)-P
        R=(D(I)-G)*S+2.*C*B
        P=S*R
        D(I+1)=G+P
        G=C*R-B
        IF (BOTH) THEN
          DO 13 K=1,N
          F=Z(K,I+1)
          Z(K,I+1)=S*Z(K,I)+C*F
          Z(K,I)=C*Z(K,I)-S*F
  13      CONTINUE
        ENDIF
C
  14    CONTINUE
        D(L)=D(L)-P
        E(L)=G
        E(M)=0.
        GO TO 1
      ENDIF
  15  CONTINUE
 100  RETURN
      END
C
C
C
C
C LEVEL7      SUBROUTINE TRAN2K(H,TRAN,U)
      SUBROUTINE TRAN2K(H,TRAN,U)
C
C *** TRAN2K new by PJB  C4.17 July 2009  ***
C
CH  Form the Transformation matrix of A Symmetric Tensor between Cryst and K-Based Axes
CA On Entry H Are The Reflections Indices
CA On Exit T Is The Required 6X6 Transformation Matrix
C
CX
CC 17B
      DIMENSION H(3),OH(3),TRAN(6,6),IPTR(3,3),U(3,3)
/IOUNIT/
C
      DATA IPTR/1,6,5,6,2,4,5,4,3/
C GET THE UNIT VECTOR PARALLEL TO  H
      CALL ORTHO(H,OH,2)
      CALL UNIVEC(OH,SCATV)
C CONSTRUCT THE ROTATION MATRIX FROM IT
      STH=(1.-OH(3)**2)
      if (sth .lt. .001) then
        call gmuni(u,3,3)
      else
      sth=sqrt(sth)
        U(1,1)=OH(2)/STH
        U(1,2)=-OH(1)/STH
        U(1,3)=0
        U(2,1)=-OH(3)*U(1,2)
        U(2,2)=OH(3)*U(1,1)
        U(2,3)=-STH
        U(3,1)=OH(1)
        U(3,2)= OH(2)
        U(3,3)=OH(3)
      endif
C
C NOW THE TRANSFORM FOR A SYMMETRIC TENSOR
      CALL GMZER(TRAN(1,1),6,6)
      DO 1 I=1,3
      DO 1 J=I,3
      IP=IPTR(I,J)
      DO 2 II=1,3
      DO 2 JJ=1,3
      TRAN(IP,IPTR(II,JJ))=TRAN(IP,IPTR(II,JJ))+U(I,II)*U(J,JJ)
    2 CONTINUE
    1 CONTINUE
      IF (.FALSE.) THEN
      DO 4 I=1,6
      IF (I.LT.4) THEN
        WRITE (LPT,1000) (U(I,J),J=1,3),(TRAN(I,J),J=1,6)
 1000   FORMAT (3F8.4,2X,6F8.4)
        ELSE
        WRITE (LPT,1001) (TRAN(I,J),J=1,6)
      ENDIF
 1001 FORMAT (26X,6F8.4)
    4 CONTINUE
C      WRITE (LPT,1001)
      ENDIF
      RETURN
      END


C
C
C
C
C LEVEL 1      SUBROUTINE TRANSC(A,ND)
      SUBROUTINE TRANSC(A,ND)
C
C *** TRANSC by JCM 12 Jul 83 ***
C
CX
CC 12C
CH Replaces a COMPLEX square matrix by its transposed conjugate.
CA On entry A is a COMPLEX NDxND matrix
CA On exit  the elements of A have been replaced by their conjugates, and A
CA          has been transposed.
C
      COMPLEX A(ND,ND),B
C
      DO 2 I=1,ND
   2  A(I,I)=CONJG(A(I,I))
C
      DO 1 I=1,ND-1
      DO 1 J=I+1,ND
      B=CONJG(A(I,J))
      A(I,J)=CONJG(A(J,I))
   1  A(J,I)=B
      RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE TRANSQ(A,ND)
      SUBROUTINE TRANSQ(A,ND)
C
C *** TRANSQ by JCM 12 Jul 83 ***
C
CX
CC 12C
CH Replaces a real square matrix by its transpose.
CA On entry A is an NDxND real square matrix
CA On exit  A has been replaced by its transpose
C
      DIMENSION A(ND,ND)
C
      DO 1 I=1,ND-1
      DO 1 J=I+1,ND
      B=A(I,J)
      A(I,J)=A(J,I)
   1  A(J,I)=B
      RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE TRED2(A,N,NP,D,E,BOTH)
      SUBROUTINE TRED2(A,N,NP,D,E,BOTH)
C
C *** TRED2 by JCM from "NUMERICAL RECIPES" 4 Dec 89 ***
C
CX
CC 9C
CH Performs the Householder reduction of a real symmetric matrix to
CH tridiagonal form.
CA On entry A is a real, symmetric NxN matrix held in an NPxNP array
CA          BOTH is a LOGICAL which is TRUE if both eigenvalues and eigen-
CA          vectors will subsequently be wanted.
CA On exit  D is a vector of length NP whose first N elements hold the
CA            diagonal of the tridiagonal matrix,
CA          E similarly holds the sub-diagonal elements, and E(1)=0.
CA          If BOTH, then A is replaced by the orthogonal matrix Q which
CA          effects the transformation;  if .NOT. BOTH, A holds rubbish.
C
CN For eigenvalues and eigenvectors, should be followed by a call to TQLI.
CN Adapted from Press, Flannery, Teukolsky & Vetterling, Numerical Recipes.
C
      LOGICAL BOTH
      DIMENSION A(NP,NP),D(NP),E(NP)
C
      IF (N .LE. 1) GO TO 1
      DO 18 I=N,2,-1
      L=I-1
      H=0.
      SCALE=0.
      IF(L.GT.1)THEN
        DO 11 K=1,L
        SCALE=SCALE+ABS(A(I,K))
  11    CONTINUE
        IF(SCALE.EQ.0.)THEN
          E(I)=A(I,L)
        ELSE
          DO 12 K=1,L
          A(I,K)=A(I,K)/SCALE
          H=H+A(I,K)**2
  12      CONTINUE
          F=A(I,L)
          G=-SIGN(SQRT(H),F)
          E(I)=SCALE*G
          H=H-F*G
          A(I,L)=F-G
          F=0.
          DO 15 J=1,L
          IF (BOTH) A(J,I)=A(I,J)/H
          G=0.
          DO 13 K=1,J
          G=G+A(J,K)*A(I,K)
  13      CONTINUE
C
          IF (L .GT. J) THEN
            DO 14 K=J+1,L
            G=G+A(K,J)*A(I,K)
  14        CONTINUE
          ENDIF
          E(J)=G/H
          F=F+E(J)*A(I,J)
  15      CONTINUE
          HH=F/(H+H)
          DO 17 J=1,L
          F=A(I,J)
          G=E(J)-HH*F
          E(J)=G
          DO 16 K=1,J
          A(J,K)=A(J,K)-F*E(K)-G*A(I,K)
  16      CONTINUE
  17      CONTINUE
        ENDIF
      ELSE
        E(I)=A(I,L)
      ENDIF
      D(I)=H
  18  CONTINUE
C
   1  IF (BOTH) D(1)=0.
        E(1)=0.
        DO 23 I=1,N
      IF (BOTH) THEN
        L=I-1
        IF(D(I).NE.0.)THEN
          DO 21 J=1,L
          G=0.
          DO 19 K=1,L
          G=G+A(I,K)*A(K,J)
  19      CONTINUE
          DO 20 K=1,L
          A(K,J)=A(K,J)-G*A(K,I)
  20      CONTINUE
  21      CONTINUE
        ENDIF
      ENDIF
      D(I)=A(I,I)
C
      IF (BOTH) THEN
        A(I,I)=1.
        IF(L.GE.1)THEN
          DO 22 J=1,L
          A(I,J)=0.
          A(J,I)=0.
  22      CONTINUE
        ENDIF
      ENDIF
  23  CONTINUE
      RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE TRIAN1(A,B,C,D,I)
      SUBROUTINE TRIAN1(A,B,C,D,I)
C
C *** TRIAN1 by JCM 25 Jan 85 ***
C
CX
CC 10C
CH Applies the cosine formula for the solution of spherical triangles.
CA The entry and exit conditions vary according to the entry value of I:
CA     I=1: sets D=angle A given sides A,B,C
CA     I=2: sets A=side A given sides B,C and D=angle A.
CA     I=3: sets D=side A given angles A,B,C
CA     I=4: sets A=angle A given angles B,C and D=side A.
CD The angles are given and returned as their cosines.
CO Writes an error message is a cosine found >1
C
/IOUNIT/
C
      CS = B*C
      S = SQRT((1.-B*B)*(1.-C*C))
      GO TO (1,2,2,1),I
    1 CS = -CS
    2 GO TO (3,4,3,4),I
   3  IF(ABS(S) .GT. 1.E-3) GO TO 9
      IF (ABS(A+CS) .GT. 1.E-3) GO TO 10
      D=0.
      GO TO 100
    9 X = (A + CS)/S
      GO TO 5
    4 X = D*S + CS
    5 IF (ABS(X) - 1. .LT. 10.E-3) GO TO 8
  10  WRITE (LPT,3000) A,B,C,D,I,S,CS,X
      WRITE (ITO,3000) A,B,C,D,I,S,CS,X
3000  FORMAT (/' ERROR ** in spherical triangle - cosine greater',
     & ' than 1.0'/' A,B,C,D=',4F10.4,'I=',I2,'S,CS,X=',3F10.4)
      STOP
C
    8 IF (ABS(X) .GT. 1.) X = SIGN(1.,X)
      GO TO (6,7,6,7),I
    6 D = X
      GO TO 100
    7 A = X
 100  RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE TRIG(A,B,K)
      SUBROUTINE TRIG(A,B,K)
C
C *** TRIG by JCM 18 Apr 84 ***
C
CX
CC 10C
CH Sets up cos(nx) and sin(nx) for a range of n by recursion.
CA On entry B is the reqired argument x
CA          K is the required number of terms
CA On exit  A is the COMPLEX array holding the answers
CD Calculates the COMPLEX trigonometric functions A(i) = CEXP(0,m*B)
CD for i = m+1, m = 0,K-1.
C
      COMPLEX A(K),MULT
      A(1) = CMPLX(1.,0.)
      IF (K .LT. 2) GO TO 100
      MULT = CEXP(CMPLX(0.,B))
      DO 1 I = 2,K
      A(I) = A(I-1)*MULT
    1 CONTINUE
 100  RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE TRINV3(A,D)
      SUBROUTINE TRINV3(A,D)
C
C *** TRINV3 by JCM ***
C
CX
CC 12C
CH Replaces a 3x3 matrix by the transpose of its inverse.
CA On entry A holds a 3x3 real matrix
CA On exit  D is the value of the determinant of the matrix.
CA          A has been replaced by its inverse
CD If D is less than 10E-5 no replacement takes place.
C
      DIMENSION A(9),P(9)
      D = 0.
      II = 0
      IO = 0
      JO = 3
      KO = 6
      DO 1 IC = 1,3
      J = 2
      K = 3
      DO 2 I = 1,3
      II = II+1
      P(II) = A(JO+J)*A(KO+K) - A(JO+K)*A(KO+J)
      J = K
    2 K = I
      D = D + P(II)*A(II)
      JO = KO
      KO = IO
    1 IO = IO + 3
      IF (ABS(D) .LT. 10.E-5) GO TO 100
      DO 3 I = 1,9
    3 A(I) = P(I)/D
 100  RETURN
      END
C
C
C
C
C LEVEL 4      SUBROUTINE TRYUNI(NCHK)
      SUBROUTINE TRYUNI(NCHK)
C
C *** TRYUNI by JCM 25 Sep 84 ***
C
CX
CC 1A
CH A specialist routine used in the setting up of the asymmetric unit, to
CH try out a given set of planes as faces of the unit.
CA On entry NCHK non-zero indicates that a check on the given representative
CA indices HT (see below) is to be performed whatever the given unit
CA is like.
C
CP The scratch COMMON /SCRAT/ is set up as follows:
CP A tentative asymmetric unit is held as NOPL planes in the array ASY,
CP the dimension of 4 allowing for "dead" planes in case we need to
CP revive them.
C
CP The status of each plane is in NSTAT:
CP       0=not there
CP       1=possible
CP       25=mandatory
C
CP HT is a 1x3 array holding the indices of a typical reflection which
CP must occur within (that is, not on the faces or the edges of) the
CP finished asymmetric unit.
C
C
CD TRYUNI does not necessarily produce the correct unit, but it checks
CD that any unit it sends out has 1 and only 1 relative of HT in it.
C
CD A unit which is too small, or which fails the above test, is
CD flagged on exit by NICE=-1.
CD An acceptable unit is falgged by NICE=1.
C
CD NOPL is expected to be 1, 2 or 3.  Copies NOPL planes out of the
CD temporary array ASY to the (eventually) permanent array ASYM in
CD /FUNIT/.
C
CD If there is more than 1 plane, the edge(s) and angle(s) involved are
CD set up, together with AMUL = the proportion of reciprocal space
CD occupied by the given unit.
CD
CD We then have VOL=AMUL*NMUL, and aim at VOL=1.
CD
CD If there are 3 planes forming a hinge, sets VOL=0., and NICE=1, and
CD leaves the configuration for the calling routine (FIXUNI) to deal with.
CD
CD If VOL=1., checks that the unit contains 1 and only 1 relative of
CD the representative indices in HT.
CD
CD If NCHK is non-zero does this check in any case, counting the number
CD of relatives both inside and outside.  This caould be useful if the
CD user is ever allowe to specify his own unit.
C
      DIMENSION NNSTAT(3)
/CONSTA/
/FRIED/
/FUNIT/
/IOUNIT/
/NSYM/
%      COMMON /SCRAT/AXI(3,%SYMO%,2),MIRROR(%SYMO%),D(3,3),PL1(3),PL2(3),PL3(3),
     & HT(3),ASY(3,4),NSTAT(4),NOPL,NICE,VOL,MOP1,MOP2
C
      NASYM=NOPL
      IF (NASYM .LE. 0 .OR. NASYM .GE. 4)
     &  CALL ERRIN2(NASYM,0,'in PROGRAM using TRYUNI with NOPL=',' ')
C
      I=1
      DO 2 J=1,NASYM
   3  IF (NSTAT(I) .NE. 0) GO TO 4
      I=I+1
      IF (I .LT. 5) GO TO 3
      CALL ERRMES(-1,0,'TRYUNI not given enough planes')
C
   4  CALL GMEQ(ASY(1,I),ASYM(1,J),1,3)
      NNSTAT(I)=NSTAT(J)
      I=I+1
   2  CONTINUE
C
C SET UP PI/3 FOR DETECTION OF ANGLE, NICE INITIALISED TO 'TOO BIG', AND
C CLEAR INDICATOR THAT WE HAVE PI/3 OR 2PI/3 ANGLE:
      PIBY3=PI/3.
      NICE=1
      N3AX=0
C BRANCH ON 1, 2 OR 3 PLANES:
   25  GO TO (7,8,9) , NASYM
C
C SINGLE PLANE - HALF SPACE:
   7  AMUL=0.5
      GO TO 10
C
C TWO PLANES - MAY FIRST NEED TO REVERSE ONE FOR SMALLER ANGLE:
   8  ANG(3)=ANGRAD(ASYM(1,1),ASYM(1,2),1)
      IF (ABS(ANG(3)-PIBY3) .LT. 0.0001) N3AX=3
      IF (ABS(ANG(3)-2.*PIBY3) .LT. 0.0001) N3AX=3
C DO NOT TRY TO REVERSE IF STATUS 3:
      IF (NNSTAT(1) .EQ. 3 .AND. NNSTAT(2) .EQ. 3) GO TO 11
      IF ((NICE .NE. -1) .AND. (ANG(3) .LE. PIBY2)) GO TO 11
      IF ((NICE .EQ. -1) .AND. (ANG(3) .GE. PIBY2)) GO TO 11
C ANGLE MUST BE ACUTE BETWEEN PLANES EXCEPT FOR CERTAIN CASES WHERE
C 2PI/3 NOT PI/3 IS WANTED
      NREV=2
      IF (NNSTAT(2) .EQ. 3) NREV=1
      CALL GMREV(ASYM(1,NREV),ASYM(1,NREV),1,3)
      ANG(3)=PI-ANG(3)
  11  AMUL=ANG(3)/TWOPI
      CALL VECPRD(ASYM(1,1),ASYM(1,2),EDGE(1,3))
C TAKE OUT ANY COMMON FACTOR:
      CALL FCTOR(EDGE(1,3),N)
      GO TO 10
C
C THREE PLANES - MAKE ANGLES SMALLER AS ABOVE, MAKE EDGES AND ANGLES:
   9  SUM=-PI
      NFLIP=0
      J2=2
      J3=3
      DO 12 J=1,3
      ANG(J)=ANGRAD(ASYM(1,J2),ASYM(1,J3),1)
      IF (ABS(ANG(J)-PIBY3) .LT. 0.0001) N3AX=J
      IF (ABS(ANG(J)-2.*PIBY3) .LT. 0.0001) N3AX=J
C DO NOT TEST 3RD ANGLE AS WE CANNOT COPE IF IT IS TOO BIG:
      IF (NFLIP .GT. 1) GO TO 13
      IF (NNSTAT(J2) .EQ. 3 .AND. NNSTAT(J3) .EQ. 3) GO TO 13
      IF ((NICE .NE. -1) .AND. (ANG(J) .LE. PIBY2)) GO TO 13
      IF ((NICE .EQ. -1) .AND. (ANG(J) .GE. PIBY2)) GO TO 13
      NREV=J3
      IF (NNSTAT(J3) .EQ.3 ) NREV=J2
      CALL GMREV(ASYM(1,NREV),ASYM(1,NREV),1,3)
C CHOOSE PLANE TO REVERSE IF NECESSARY
      ANG(J)=PI-ANG(J)
      NFLIP=NFLIP+1
  13  SUM=SUM+ANG(J)
C
C MAKE EDGE, POINTING SAME WAY AS OPPOSITE PLANE:
      CALL VECPRD(ASYM(1,J2),ASYM(1,J3),EDGE(1,J))
      IF (SCALPR(EDGE(1,J),ASYM(1,J)) .LT.0.) CALL GMREV(EDGE(1,J),
     & EDGE(1,J),1,3)
      CALL FCTOR(EDGE(1,J),N)
      J2=J3
      J3=J
  12  CONTINUE
      AMUL=SUM/FOURPI
C
C DETECT HINGE - 3 PLANES, BUT WITH A COMMON EDGE:
      CALL EQVEC(EDGE(1,1),EDGE(1,3),2,M,0)
      IF (M .GE.3) GO TO 10
C MARK HINGE TO BE DEALT WITH OUTSIDE:
      VOL=0.
      GO TO 100
C
C JOIN - WE HAVE A UNIT WITH 1, 2 OR 3 PLANES (NOT HINGE), AND WHERE RELEVANT
C EDGES AND ANGLES HAVE BEEN STORED;  MUL=FRACTION OCCUPIED:
  10  VOL=AMUL*FLOAT(NMUL)
C IF VOL IS 1 WE HAVE A UNIT OF THE RIGHT SIZE:
      IF (ABS(VOL-1.) .LT. 0.00001) NICE=0
C IF VOL IS TOO SMALL WE MAY HAVE TO REMOVE A PLANE, OR WE MAY HAVE TO STOP
C REDUCING THE ANGLE BETWEEN TWO PLANES TO PI/3 AND LEAVE IT AT 2PI/3:
      IF (VOL .LT. 0.9998) NICE=-1
      IF (NICE .EQ. -1 .AND. N3AX .NE. 0) GO TO 25
C THIS MAY LOOP, BUT THE SECOND TIME WE LOOK AT SUCH A UNIT IT SHOULD BE OK.
      IF (NCHK .EQ. 0 .AND. NICE .NE. 0) GO TO 100
C
C IF VOLUME OK, OR IF ASKED TO CHECK ANYWAY, COUNT RELATIVES OF TYPICAL REFLN:
      MOP1=0
      IC=1
      IF (FRIEDL) IC=2
C IF FRIEDEL, SCAN -HT AS WELL AS HT:
      CALL GMREV(HT,PL2,3,1)
      DO 18 NC=1,IC
      CALL GMREV(PL2,PL2,3,1)
C SCAN ALL SYMMETRY OPERATORS STORED:
      DO 18 N1=1,NOPC
      CALL ROTSYM(PL2,PL1,N1,2)
      CALL INBOX(PL1,IN)
C TEST RELATIVE FOR BEING IN GIVEN BOX - "ON" AS AN ANSWER IS AN ERROR:
      IF (IN .GT. 0) THEN
        WRITE (LPT,3002) HT
        WRITE (ITO,3002) HT
3002    FORMAT (/' *** ERROR - typical reflection',3F5.0,' not general')
        STOP
      ENDIF
C
      IF (IN .GE. 0) THEN
C MOP1=NUMBER OF RELATIVES INSIDE BOX:
C MOP2 WILL HOLD "WHICH OPERATOR PUTS HT INTO BOX", -VELY IF BY A CENTRE ALSO:
        MOP1=MOP1+1
        MOP2=N1*(3-2*NC)
      ENDIF
  18  CONTINUE
C
C MOP1=0 MEANS WRONG BOX:
      IF (MOP1 .EQ. 0) NICE=-1
 100  RETURN
      END
C
C
C
C
C LEVEL 3      SUBROUTINE UNITID
      SUBROUTINE UNITID
C
C *** UNITID by JCM 26 Sep 84 ***
C
CX
CC 1A
CH A specialist routine called when an asymmetric unit has been found,
CH to tidy the unit, its faces and edges.
C
CP Must be called from SYMUNI, after calls of TRYUNI have found a
CP satisfactory unit, with NASYM faces in the array ASYM, edges in the array
CP EDGE and angles in the array ANG, all in /FUNIT/.
C
CP TRYUNI has also set MOP2 to point to the symmetry operator which
CP transforms the typical reflection HT into their relative in the
CP asymmetric unit.
C
CD Transforms the asymmetric unit as found back so that it contains
CD HT, writes out the equations of the final planes, and sets up the
CD edges again.
C
CO Write the equations of the planes bounding the asymmetric unit
CO to unit LPT.
C
/FUNIT/
/IOUNIT/
%      COMMON /SCRAT/AXI(3,%SYMO%,2),MIRROR(%SYMO%),D(3,3),PL1(3),PL2(3),PL3(3),
     & HT(3),ASY(3,4),NSTAT(4),NOPL,NICE,VOL,MOP1,MOP2
C
      MO=IABS(MOP2)
      IF (NASYM .LE. 0) THEN
C SPECIAL FOR P1, NO FRIEDEL:
        CALL MESS(LPT,1,'No symmetrical equivalents')
        GO TO 100
      ENDIF
C
      WRITE (LPT,2001) NASYM
2001  FORMAT (/' Asymmetric unit has',I3,' plane(s):')
      DO 2 I=1,NASYM
      CALL ROTSYM(ASYM(1,I),PL1,MO,-2)
      IF (MOP2 .LT. 0) CALL GMREV(PL1,PL1,1,3)
      CALL GMEQ(PL1,ASYM(1,I),1,3)
      CALL PRIPLN(ASYM(1,I),1)
C
   2  CONTINUE
C
C REMAKE EDGES:
      IF (NASYM .LT.2) GO TO 100
      J2=2
      J3=3
      DO 3 J=1,3
      IF (NASYM .NE. 3 .AND. J .NE.3) GO TO 4
      CALL VECPRD(ASYM(1,J2),ASYM(1,J3),EDGE(1,J))
      IF (SCALPR(EDGE(1,J),ASYM(1,J)) .LT.0.) CALL GMREV(EDGE(1,J),
     & EDGE(1,J),1,3)
      CALL FCTOR(EDGE(1,J),N)
   4  J2=J3
      J3=J
   3  CONTINUE
 100  RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE UNIVEC(X,U)
      SUBROUTINE UNIVEC(X,U)
C
C *** UNIVEC 1 May 84 by JCM ***
C
CX
CC 12C
CH Replaces a vector by a parallel unit vector, and gives its length.
CA On entry X is a real 1x3 vector referred to the CCSL orthogonal axes
CA On exit  X is replaced by a parallel unit vector
CA          U is set to the original length of X
CD If the length would be very small, X is not changed.
CN Works in double precision
C
      DOUBLE PRECISION DU
      DIMENSION X(3)
C
      U = 0.
      DU = 0.D0
      DO 1 I = 1,3
    1 DU = DU + X(I)*X(I)
      IF (DU .LT. 10.D-8) GO TO 100
      U = SNGL(DSQRT(DU))
      DO 2 I = 1,3
    2 X(I) = X(I)/U
 100  RETURN
      END
C
C
C
C
C LEVEL 3      SUBROUTINE UNUSYM
      SUBROUTINE UNUSYM
C
C *** UNUSYM new by PJB June 2006 ***
C
CX
CC 5A
CH Undoes the transformsation of symmetry operators by pre- and post-multiplying
CH them by the inverse of the orientation matrix for a Fourier map.
C
CA On entry N=0 if no matrix U has in fact been read.
C
CD Each symmetry matrix R except the first is replaced by:
CD         U * R * (U)**-1
CD and each translation operator T by (U) * T
C
CD The routine also fills in the matrix PMAP(2,2), using the matrix
CD U expressed on the standard orthogonal axes.  This matrix is
CD then used in a "map to picture" conversion during plotting.
C
CN If the original symmetry matrices are ever needed we can recover the
CN transformations from the first element.
C
      DIMENSION TT(3),B(3,3),a(3,3)
/MAPDA/
/NSYM/
/SYMDA/
C
C
      CALL GMINV(U,A,3)
C
      DO 1 N=2,NOPC
      CALL GMPRD(SYM(1,1,N),A,B,3,3,3)
      CALL GMPRD(U,B,SYM(1,1,N),3,3,3)
      CALL GMPRD(U,TRANS(1,N),TT,3,3,1)
      CALL GMEQ(TT,TRANS(1,N),1,3)
   1  CONTINUE
      RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE UPLOW(C)
      SUBROUTINE  UPLOW(C)
C
C *** UPLOW by JCM 3 Aug 92 ***
C
CX
CC 13C
CH Makes first letter of C upper case, and any subsequent letters lower case.
C
      CHARACTER *(*) C
      LOGICAL FIRST
/CHARS/
C
      FIRST=.TRUE.
      L=LENGT(C)
      DO 1 I=1,L
      M=LETTER(C(I:I))
      IF (M .GT. 0) THEN
        IF (FIRST) C(I:I)=LETUP(M)
        IF (.NOT. FIRST) C(I:I)=LETLOW(M)
        FIRST=.FALSE.
      ENDIF
   1  CONTINUE
      RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE UPONE(CH,IS)
      SUBROUTINE UPONE(CH,IS)
C
CC 13C
C *** UPONE modified by PJB 7-July-95 ***
C
CH Puts character strings into all uppercase or all lower case depending on ISYS
CA CH contains the string for conversion
CA If IS=1 converts to upper case
CA    IS=2 converts to lower case
CA    IS=3 converts to upper or lower case depending on NSYSTM
CA All other values of IS convert CH to upper case
C
C TO LOWER CASE FOR UNIX UPPER FOR VMS
      CHARACTER *(*) CH
/CHARS/
/GLOBAL/
C
      ISYS=IS
      IF (IS.EQ.3) THEN
        ISYS=1
C UNIX NEEDS LOWER CASE
        IF (NSYSTM.EQ.2) ISYS=2
      ENDIF
      N=LENGT(CH)
      DO 1 I=1,N
      DO 2 J=1,26
      IF (ISYS.EQ.2) THEN
        IF (CH(I:I) .NE. LETUP(J)) GO TO 2
        CH(I:I)=LETLOW(J)
      ELSE
        IF (CH(I:I) .NE. LETLOW(J)) GO TO 2
        CH(I:I)=LETUP(J)
      ENDIF
      GO TO 1
   2  CONTINUE
   1  CONTINUE
      RETURN
      END

C LEVEL 1      SUBROUTINE UPPER(C)
      SUBROUTINE UPPER(C)
C
C *** UPPER by JCM 3 Aug 92 ***
C
CX
CC 13C
CH Replaces any lower case letters in C by upper case
C
      CHARACTER *(*) C
/CHARS/
C
      L=LENGT(C)
      DO 1 I=1,L
      M=LETTER(C(I:I))
      IF (M .GT. 0) C(I:I)=LETUP(M)
   1  CONTINUE
      RETURN
      END
C
C
C
C
C LEVEL 3      SUBROUTINE USYM(NONE)
      SUBROUTINE USYM(NONE)
C
C *** USYM UPDATED TO REMOVE USE OF TRANSFORMED SYMMETRY C4.31 NOV 2016  ***
C
CX
CC 5A
CH Transforms all the symmetry operators TO MAP AXES and stores them in /TSYM.
C
CA On entry NONE=0 if no matrix U has in fact been read.
C4.2 TNONE used to be N
C
CP Fourier calculations should be set up by SETFOU;  in particular the
CP number of dimensions, NDIM, is needed.
C
CD Each symmetry matrix TR in TSYMDA (except the first) is relted to
CD one R in SYMDA : by     TR =  (U)**-1 * R * U
CD and each translation operator TT  to T by TT = (U)**-1 * T
C
CD The routine also fills in the matrix PMAP(2,2), using the matrix
CD U expressed on the standard orthogonal axes.  This matrix is
CD then used in a "map to picture" conversion during plotting.
C
      dimension temp(3,3),A(3,3),C(3,3),TT(3)
/CONTUR/
/IOUNIT/
/MAPDA/
/MAPMAP/
/NSYM/
/PLOMAP/
/SYMDA/
/TSYMDA/
C
C IF UNIT MATRIX, SKIP INVERSION:
      IF (NONE .EQ. 0) then
      	call gmuni(u,3,3)
        call gmeq(sym,tsym,3,3,NOPC)
        call gmeq(trans,ttrans,3,3,NOPC)
      endif
C Check that U has a positive determinant etc.
      DET=deter3(u)
      IF (ABS(DET) .LT. 0.0001) CALL ERRMES(1,1,
     &' the 3 axes of the transformed map are coplanar')
      if (det.lt.0) then
C4.31 Ensure right handed axes for map
        call gmrev(u(1,3),u(1,3),3,1)
        write (lpt,2001)
 2001  format (
     &'Z axis of map reversed to obtain Right-handed orientation')
      det=-det
      endif
      WRITE(LPT,2000) Det
2000  FORMAT (/' Unit cell transformed for Fourier is ',F6.2,' times',
     & ' original cell')
C GET INVERSE OF U (NOT TRANSPOSED)
      CALL GMINV(u,uinv,3)
      if (none.eq.0) go to 10
C transform symmetry elementds
      call gmuni(tsym,3,3)
      call gmzer(ttran,3,1)
      DO 1 N=2,NOPC
C4.31 Don't overwrite the symmetry elements but store transformed ones in /TSYM/
      CALL GMPRD(SYM(1,1,N),U,temp,3,3,3)
      CALL GMPRD(uinv,temp,tsym(1,1,n),3,3,3)
      call gmprd(uinv,trans(1,n),ttrans(1,n),3,3,1)
   1  CONTINUE
C
  10  DO 4 I=1,3
   4  CALL ORTHO(U(1,I),A(1,I),1)
      GO TO (100,5,6), NDIM
C 2-D PROJECTION:
    5 CALL UNIVEC(A(1,3),TT(3))
      DO 7 I=1,2
      CALL VECPRD(A(1,I),A(1,3),C(1,I))
      CALL UNIVEC(C(1,I),AXMAP(i))
   7  CONTINUE
      COSPHI=SCALPR(C(1,1),C(1,2))
      GO TO 8
C
C 3-D:
   6  DO 9 I=1,2
   9  CALL UNIVEC(A(1,I),AXMAP(I))
      COSPHI=SCALPR(A(1,1),A(1,2))
C
   8  CALL SINCOS(COSPHI,SINPHI,'USYM')
 100  RETURN
      END
C
C
C
C
C LEVEL 4      SUBROUTINE VA05A(M,N,F,X,DSTEP,DMAX,ACC,MAXFUN,IPRINT,W)
      SUBROUTINE VA05A (M,N,F,X,DSTEP,DMAX,ACC,MAXFUN,IPRINT,W)
C
C *** VA05A updated by JCM from HARWELL ***
C
CX
CC 6C
CH Minimises the sum of squares of given functions without requiring
CH the explicit calculation of derivatives.
CA On entry M,N,X,DSTEP,DMAX,ACC,MAXFUN,IPRINT,W should be set according to the
CA          specification of VA05A
CA On exit  X is set to contain the refined values of the parameters
CA          F is set to the corresponding function values
CP A routine called CALFUN(M,N,F,X) must be provided to set the array F
C
CN IPRINT must be the name of an integer, NOT an explicit integer
C
      DIMENSION F(1),X(1),W(1)
/IOUNIT/
C
C MAXC COUNTS CALLS OF CALFUN:
      MAXC=0
      MPN=M+N
C     'NT' AND 'NTEST' CAUSE AN ERROR RETURN IF F(X) DOES NOT DECREASE
      NT=N+2
      NTEST=0
C     'DTEST' IS USED IN A TEST TO MAINTAIN LINEAR INDEPENDENCE
      DTEST=FLOAT(N+N)-0.5
C     PARTITION THE WORKING SPACE ARRAY W
C     THE FIRST PARTITION HOLDS THE JACOBIAN APPROXIMATION
      NWI=M*N
C     THE NEXT PARTITION HOLDS THE GENERALIZED INVERSE
      NWX=NWI+MPN*N
C     THE NEXT PARTITION HOLDS THE BEST VECTOR X
      NWF=NWX+N
C     THE NEXT PARTITION HOLDS THE BEST VECTOR F
      NWC=NWF+M
C     THE NEXT PARTITION HOLDS THE COUNTS OF THE INDEPENDENT DIRECTIONS
      NWD=NWC+N
C     THE NEXT PARTITION HOLDS THE INDEPENDENT DIRECTIONS
      NWW=NWD+N*N
C     THE REMAINDER OF W IS USED FOR SCRATCH VECTORS
      NWV=NWW+N
      NWT=NWV+M
      NWU=NWT+N
C     USUALLY 'FMIN' IS THE LEAST CALCULATED VALUE OF F(X)
      FMIN=-1.
C     USUALLY 'DD' IS THE SQUARE OF THE CURRENT STEP LENGTH
      DD=0.
      DSS=DSTEP*DSTEP
      DM=DMAX*DMAX
C     'PARM' IS THE LEAST VALUE OF THE MARQUARDT PARAMETER
      PARM=SQRT(ACC)/DMAX
C     'DPAR' AND 'NTPAR' ARE USED TO REGULATE THE MARQUARDT PARAMETER
      DPAR=10.*DM
C     'IS' CONTROLS A GO TO STATEMENT FOLLOWING A CALL OF CALFUN
      IS=4
      IC=0
C     'TINC' IS USED IN THE CRITERION TO INCREASE THE STEP LENGTH
      TINC=1.
C
C     START A NEW PAGE FOR PRINTING
      IF (IPRINT .NE. 0) THEN
        CALL NEWPAG(LPT)
        CALL MESS(LPT,0,'   THE FOLLOWING OUTPUT IS PROVIDED BY '//
     &  'SUBROUTINE VA05A')
        CALL NEWLIN(LPT)
        CALL NEWLIN(LPT)
        IPC=0
      ENDIF
      GO TO 3
C
C     TEST WHETHER THERE HAVE BEEN MAXFUN CALLS OF CALFUN
    4 IF (MAXFUN .GT. MAXC) GO TO 3
      IF (IPRINT .EQ. 0) THEN
        IPRINT=2
        GO TO 19
      ELSE
        WRITE(LPT,3000) MAXC
        WRITE(ITO,3000) MAXC
3000    FORMAT (///5X,'ERROR RETURN FROM VA05A BECAUSE THERE HAVE BEEN',
     &   I5,' CALLS OF CALFUN')
        GO TO 7
      ENDIF
C
C     CALL THE SUBROUTINE CALFUN
    3 MAXC=MAXC+1
      CALL CALFUN (M,N,F,X)
C     CALCULATE THE SUM OF SQUARES
      FSQ=0.
      DO 8 I=1,M
      FSQ=FSQ+F(I)*F(I)
    8 CONTINUE
C     TEST FOR ERROR RETURN BECAUSE F(X) DOES NOT DECREASE
      GO TO (9,10,9,10),IS
    9 IF (FSQ .LT. FMIN) GO TO 11
      IF (DD .GT. DSS) GO TO 10
      NTEST=NTEST-1
      IF (NTEST .GT. 0) GO TO 10
      IF (IPRINT .NE. 0) GO TO 15
      IPRINT=1
      GO TO 19
   15 WRITE (LPT,3001)
      WRITE (ITO,3001)
3001  FORMAT (///5X,'ERROR RETURN FROM VA05A BECAUSE F(X) NO LONGER',
     & ' DECREASES'//5X,'THIS MAY BE DUE TO THE VALUES OF DSTEP',
     & ' AND ACC, OR TO LOSS OF RANK IN THE JACOBIAN MATRIX')
C     PROVIDE PRINTING OF FINAL SOLUTION IF REQUESTED
    7 IF (IPRINT .EQ. 0) GO TO 19
      WRITE (LPT,2001) MAXC
2001  FORMAT (///5X,'THE FINAL SOLUTION CALCULATED BY VA05A REQUIRED',
     & I5,' CALLS OF CALFUN, AND IS')
      WRITE (LPT,2002) (I,W(NWX+I),I=1,N)
2002  FORMAT (//4X,'I',7X,'X(I)',10X,'I',7X,'X(I)',10X,'I',7X,'X(I)',
     & 10X,'I',7X,'X(I)',10X,'I',7X,'X(I)'//5(I5,E17.8))
      WRITE (LPT,2003) (I,W(NWF+I),I=1,M)
2003  FORMAT (//4X,'I',7X,'F(I)',10X,'I',7X,'F(I)',10X,'I',7X,'F(I)',
     & 10X,'I',7X,'F(I)',10X,'I',7X,'F(I)'//5(I5,E17.8))
      WRITE (LPT,2004) FMIN
2004  FORMAT (/5X,'THE SUM OF SQUARES IS',E17.8)
C     RESTORE THE BEST VALUES OF X AND F
   19 DO 135 I=1,N
      X(I)=W(NWX+I)
  135 CONTINUE
      DO 136 I=1,M
      F(I)=W(NWF+I)
  136 CONTINUE
      GO TO 100
C
   11 NTEST=NT
C     PROVIDE ORDINARY PRINTING IF REQUESTED
   10 IF(IABS(IPRINT)-1) 39,38,40
   38 WRITE (LPT,2005) MAXC
2005  FORMAT (///5X,'AT THE',I5,' TH CALL OF CALFUN WE HAVE')
   42 WRITE (LPT,2002) (I,X(I),I=1,N)
      WRITE (LPT,2004) FSQ
      IF (IPRINT .GT. 0) WRITE (LPT,2003) (I,F(I),I=1,M)
      GO TO 39
C
   40 IPC=IPC-1
      IF (IPC .GT. 0) GO TO 39
      WRITE (LPT,2006) MAXC
2006  FORMAT (///5X,'THE BEST ESTIMATE AFTER',I5,' CALLS OF CALFUN IS')
      IPC=IABS(IPRINT)
      IF (FSQ .LT. FMIN) GO TO 42
      IF (FMIN .LT. 0) GO TO 42
      WRITE (LPT,2002) (I,W(NWX+I),I=1,N)
      WRITE (LPT,2004) FMIN
      IF (IPRINT .GT. 0) WRITE (LPT,2003) (I,W(NWF+I),I=1,M)
C
   39 GO TO (49,47,47,48),IS
C     STORE THE INITIAL VECTORS X AND F
   48 IF (IC .GT. 0) GO TO 51
      DO 52 I=1,N
      W(NWX+I)=X(I)
   52 CONTINUE
      GO TO 54
C
C     CALCULATE THE INITIAL JACOBIAN APPROXIMATION
   51 K=IC
      DO 55 I=1,M
      W(K)=(F(I)-W(NWF+I))/DSTEP
      K=K+N
   55 CONTINUE
C     TEST WHETHER THE MOST RECENT X IS BEST
      IF (FMIN .GT. FSQ) GO TO 57
      X(IC)=W(NWX+IC)
      GO TO 58
C
   57 W(NWX+IC)=X(IC)
   54 DO 53 I=1,M
      W(NWF+I)=F(I)
   53 CONTINUE
      FMIN=FSQ
C
C     SET X FOR THE NEXT CALL OF CALFUN
   58 IC=IC+1
      IF (IC .GT. N) GO TO 60
      X(IC)=W(NWX+IC)+DSTEP
      GO TO 3
C     SET THE DIRECTION MATRIX
   60 K=NWD
      DO 61 I=1,N
      DO 62 J=1,N
      K=K+1
      W(K)=0.
   62 CONTINUE
      W(K+I-N)=1.
      W(NWC+I)=1.+FLOAT(N-I)
   61 CONTINUE
C     SET THE MARQUARDT PARAMETER TO ITS LEAST VALUE
   24 PAR=PARM
C     COPY THE JACOBIAN AND APPEND THE MARQUARDT MATRIX
   25 PPAR=PAR*PAR
      NTPAR=0
   63 KK=0
      K=NWI+NWI
      DO 26 I=1,N
      DO 141 J=1,M
      KK=KK+1
      W(KK+NWI)=W(KK)
  141 CONTINUE
      DO 27 J=1,N
      K=K+1
      W(K)=0.
   27 CONTINUE
      W(K+I-N)=PAR
   26 CONTINUE
C     CALCULATE THE GENERALIZED INVERSE OF J
      CALL MB11A (N,MPN,W(NWI+1),N,W(NWW+1))
C     NOTE THAT THE THIRD AND FIFTH ENTRIES OF THIS ARGUMENT LIST
C     STAND FOR ONE-DIMENSIONAL ARRAYS.
C     START THE ITERATION BY TESTING FMIN
   64 IF (FMIN .LE. ACC) GO TO 7
C     NEXT PREDICT THE DESCENT AND MARQUARDT MINIMA
      DS=0.
      DN=0.
      SP=0.
      DO 66 I=1,N
      X(I)=0.
      F(I)=0.
      K=I
      DO 67 J=1,M
      X(I)=X(I)-W(K)*W(NWF+J)
      F(I)=F(I)-W(NWI+K)*W(NWF+J)
      K=K+N
   67 CONTINUE
      DS=DS+X(I)*X(I)
      DN=DN+F(I)*F(I)
      SP=SP+X(I)*F(I)
   66 CONTINUE
C     PREDICT THE REDUCTION IN F(X) DUE TO THE MARQUARDT STEP
C     AND ALSO PREDICT THE LENGTH OF THE STEEPEST DESCENT STEP
      PRED=SP+SP
      DMULT=0.
      K=0
      DO 68 I=1,M
      AP=0.
      AD=0.
      DO 69 J=1,N
      K=K+1
      AP=AP+W(K)*F(J)
      AD=AD+W(K)*X(J)
   69 CONTINUE
      PRED=PRED-AP*AP
      DMULT=DMULT+AD*AD
   68 CONTINUE
C     TEST FOR CONVERGENCE
      IF (DN .GT.DM) GO TO 29
      AP=SQRT(DN)
      IF (PRED+2.*PPAR*AP*(DMAX-AP)-ACC) 7,7,70
   29 IF (PRED+PPAR*(DM-DN)-ACC) 7,7,70
C     TEST WHETHER TO APPLY THE FULL MARQUARDT CORRECTION
   70 DMULT=DS/DMULT
      DS=DS*DMULT*DMULT
   71 IS=2
      IF (DN .GT. DD) GO TO 73
C     TEST THAT THE MARQUARDT PARAMETER HAS ITS LEAST VALUE
      IF (PAR .GT. PARM) GO TO 24
      DD=AMAX1(DN,DSS)
      DS=0.25*DN
      TINC=1.
      IF (DN .GE. DSS) GO TO 132
      IS=3
      GO TO 103
C
C     TEST WHETHER TO INCREASE THE MARQUARDT PARAMETER
   73 IF (DN .GT. DPAR) GO TO 32
      NTPAR=0
      GO TO 33
   32 IF (NTPAR .GT. 0) GO TO 35
      NTPAR=1
      PTM=DN
      GO TO 33
   35 NTPAR=NTPAR+1
      PTM=AMIN1 (PTM,DN)
      IF (NTPAR .LT. NT) GO TO 33
C     SET THE LARGER VALUE OF THE MARQUARDT PARAMETER
      PAR=PAR*(PTM/DM)**0.25
      IF (6.*DD .GE. DM) GO TO 25
      AP=SQRT(PRED/DN)
      IF (AP .LE. PAR) GO TO 25
      PAR=AMIN1(AP,PAR*(DM/(6.*DD))**0.25)
      GO TO 25
C
C     TEST WHETHER TO USE THE STEEPEST DESCENT DIRECTION
   33 IF (DS .LT. DD) GO TO 75
C     TEST WHETHER THE INITIAL VALUE OF DD HAS BEEN SET
      IF (DD .GT. 0.) GO TO 78
      DD=AMIN1(DM,DS)
      IF (DD .GE. DSS) GO TO 78
      DD=DSS
      GO TO 71
C
C     SET THE MULTIPLIER OF THE STEEPEST DESCENT DIRECTION
   78 ANMULT=0.
      DMULT=DMULT*SQRT(DD/DS)
      GO TO 80
C     INTERPOLATE BETWEEN THE STEEPEST DESCENT AND MARQUARDT DIRECTIONS
   75 SP=SP*DMULT
      ANMULT=(DD-DS)/((SP-DS)+SQRT((SP-DD)**2+(DN-DD)*(DD-DS)))
      DMULT=DMULT*(1.-ANMULT)
C     CALCULATE THE CORRECTION TO X, AND ITS ANGLE WITH THE FIRST
C     DIRECTION
   80 DN=0.
      SP=0.
      DO 81 I=1,N
      F(I)=DMULT*X(I)+ANMULT*F(I)
      DN=DN+F(I)*F(I)
      SP=SP+F(I)*W(NWD+I)
   81 CONTINUE
      DS=0.25*DN
C     TEST WHETHER AN EXTRA STEP IS NEEDED FOR INDEPENDENCE
      IF (W(NWC+1) .LE. DTEST) GO TO 132
      IF (SP*SP .GE. DS) GO TO 132
C
C     TAKE THE EXTRA STEP AND UPDATE THE DIRECTION MATRIX
   83 DO 84 I=1,N
      X(I)=W(NWX+I)+DSTEP*W(NWD+I)
      W(NWC+I)=W(NWC+I+1)+1.
   84 CONTINUE
      W(NWD)=1.
      IF(N.LE.1)GO TO 4
      DO 85 I=1,N
      K=NWD+I
      SP=W(K)
      DO 86 J=2,N
      W(K)=W(K+N)
      K=K+N
   86 CONTINUE
      W(K)=SP
   85 CONTINUE
      GO TO 4
C     EXPRESS THE NEW DIRECTION IN TERMS OF THOSE OF THE DIRECTION
C     MATRIX, AND UPDATE THE COUNTS IN W(NWC+1) ETC.
  132 IF(N.GE.2)GO TO 153
      IS=1
      GO TO 152
  153 SP=0.
      K=NWD
      DO 87 I=1,N
      X(I)=DW
      DW=0.
      DO 88 J=1,N
      K=K+1
      DW=DW+F(J)*W(K)
   88 CONTINUE
      GO TO (89,90),IS
   90 W(NWC+I)=W(NWC+I)+1.
      SP=SP+DW*DW
      IF (SP .LE. DS) GO TO 87
      IS=1
      KK=I
      X(1)=DW
      GO TO 92
   89 X(I)=DW
   92 W(NWC+I)=W(NWC+I+1)+1.
   87 CONTINUE
      W(NWD)=1.
C     REORDER THE DIRECTIONS SO THAT KK IS FIRST
      IF (KK .LE. 1) GO TO 93
      KS=NWC+KK*N
      DO 95 I=1,N
      K=KS+I
      SP=W(K)
      DO 96 J=2,KK
      W(K)=W(K-N)
      K=K-N
   96 CONTINUE
      W(K)=SP
   95 CONTINUE
C     GENERATE THE NEW ORTHOGONAL DIRECTION MATRIX
   93 DO 97 I=1,N
      W(NWW+I)=0.
   97 CONTINUE
      SP=X(1)*X(1)
      K=NWD
      DO 98 I=2,N
      DS=SQRT(SP*(SP+X(I)*X(I)))
      DW=SP/DS
      DS=X(I)/DS
      SP=SP+X(I)*X(I)
      DO 99 J=1,N
      K=K+1
      W(NWW+J)=W(NWW+J)+X(I-1)*W(K)
      W(K)=DW*W(K+N)-DS*W(NWW+J)
   99 CONTINUE
   98 CONTINUE
      SP=1./SQRT(DN)
      DO 199 I=1,N
      K=K+1
  199 W(K)=SP*F(I)
C     PREDICT THE NEW RIGHT HAND SIDES
  152 FNP=0.
      K=0
      DO 101 I=1,M
      W(NWW+I)=W(NWF+I)
      DO 102 J=1,N
      K=K+1
      W(NWW+I)=W(NWW+I)+W(K)*F(J)
  102 CONTINUE
      FNP=FNP+W(NWW+I)**2
  101 CONTINUE
C     CALCULATE THE NEXT VECTOR X, AND THEN CALL CALFUN
  103 DO 104 I=1,N
      X(I)=W(NWX+I)+F(I)
  104 CONTINUE
      GO TO 4
C     UPDATE THE STEP SIZE
   49 DMULT=0.9*FMIN+0.1*FNP-FSQ
      IF (DMULT .GE. 0.) GO TO 108
      DD=AMAX1(DSS,0.25*DD)
      TINC=1.
      IF (FSQ-FMIN) 106,107,107
C     TRY THE TEST TO DECIDE WHETHER TO INCREASE THE STEP LENGTH
  108 SP=0.
      SS=0.
      DO 109 I=1,M
      SP=SP+ABS(F(I)*(F(I)-W(NWW+I)))
      SS=SS+(F(I)-W(NWW+I))**2
  109 CONTINUE
      PJ=1.+DMULT/(SP+SQRT(SP*SP+DMULT*SS))
      SP=AMIN1(4.,TINC,PJ)
      TINC=PJ/SP
      DD=AMIN1(DM,SP*DD)
      GO TO 106
C     IF F(X) IMPROVES STORE THE NEW VALUE OF X
   47 IF (FSQ .GE. FMIN) GO TO 110
  106 FMIN=FSQ
      DO 111 I=1,N
      SP=X(I)
      X(I)=W(NWX+I)
      W(NWX+I)=SP
  111 CONTINUE
      DO 112 I=1,M
      SP=F(I)
      F(I)=W(NWF+I)
      W(NWF+I)=SP
  112 CONTINUE
  110 GO TO (107,107,113),IS
  113 IS=2
      IF (FMIN-ACC) 7,7,83
C     CALCULATE THE CHANGES IN X AND IN F
  107 DS=0.
      DO 114 I=1,N
      X(I)=X(I)-W(NWX+I)
      DS=DS+X(I)*X(I)
  114 CONTINUE
      DO 115 I=1,M
      F(I)=F(I)-W(NWF+I)
  115 CONTINUE
C     CALCULATE THE GENERALIZED INVERSE TIMES THE CHANGE IN X
      K=NWI
      SS=0.
      DO 116 I=1,MPN
      SP=0.
      DO 117 J=1,N
      K=K+1
      SP=SP+W(K)*X(J)
  117 CONTINUE
      W(NWV+I)=SP
      SS=SS+SP*SP
  116 CONTINUE
C     CALCULATE J TIMES THE CHANGE IN F
C     ALSO APPLY PROJECTION TO THE GENERALIZED INVERSE
      DO 118 I=1,N
      ST=0.
      K=NWI+I
      DO 119 J=1,MPN
      ST=ST+W(K)*W(J+NWV)
      K=K+N
  119 CONTINUE
      ST=ST/SS
      K=NWI+I
      DO 120 J=1,MPN
      W(K)=W(K)-ST*W(J+NWV)
      K=K+N
  120 CONTINUE
      ST=PPAR*X(I)
      K=I
      DO 121 J=1,M
      ST=ST+W(K)*F(J)
      K=K+N
  121 CONTINUE
      W(NWW+I)=ST
  118 CONTINUE
C     REVISE J AND CALCULATE ROW VECTOR FOR CORRECTION TO INVERSE
      IC=0
      K=0
      KK=NWI
      SP=0.
      SPP=0.
      DO 122 I=1,M
      SS=F(I)
      ST=F(I)
      DO 123 J=1,N
      IC=IC+1
      KK=KK+1
      SS=SS-W(IC)*X(J)
      ST=ST-W(KK)*W(NWW+J)
  123 CONTINUE
      SS=SS/DS
      W(NWV+I)=ST
      SP=SP+F(I)*ST
      SPP=SPP+ST*ST
      DO 124 J=1,N
      K=K+1
      W(K)=W(K)+SS*X(J)
  124 CONTINUE
  122 CONTINUE
      DO 125 I=1,N
      ST=PAR*X(I)
      DO 126 J=1,N
      KK=KK+1
      ST=ST-W(KK)*W(NWW+J)
  126 CONTINUE
      W(NWT+I)=ST
      SP=SP+PAR*X(I)*ST
      SPP=SPP+ST*ST
  125 CONTINUE
C     TEST THAT THE SCALAR PRODUCT IS SUFFICIENTLY ACCURATE
      IF (0.01*SPP-ABS(SP-SPP)) 63,63,127
C     CALCULATE THE NEW GENERALIZED INVERSE
  127 DO 128 I=1,N
      K=NWI+I
      ST=X(I)
      DO 129 J=1,M
      ST=ST-W(K)*F(J)
      K=K+N
  129 CONTINUE
      SS=0.
      DO 130 J=1,N
      SS=SS+W(K)*X(J)
      K=K+N
  130 CONTINUE
      ST=(ST-PAR*SS)/SP
      K=NWI+I
      DO 131 J=1,MPN
      W(K)=W(K)+ST*W(NWV+J)
      K=K+N
  131 CONTINUE
  128 CONTINUE
      GO TO 64
C
 100  RETURN
      END
C
C
C
C
C LEVEL 8       SUBROUTINE VARMAK(DEFALT,GETPAR,VARSXX,DOTHER)
      SUBROUTINE VARMAK(DEFALT,GETPAR,VARSXX,DOTHER)
C
C *** VARMAK updated by PJB C4.26 March 2013 ***
C to recoerd the number of fam1 parameters on which the structure factor depends
C
CX
CC 6A
CH Makes variables for a LSQ cycle from given FIX/VARY and CONSTRAINT lists.
CA DEFALT is a dummy name for a subroutine to be obeyed if no other
CA        information is available about a parameter, and which gives
CA        out the values .TRUE./.FALSE. for fixed/varied by default.
CA GETPAR is a dummy name for a subroutine to be obeyed to get the next
CA        parameter.  It should be replaced by PARRUN in the single-
CA        crystal applications, RUNPAR for Profile Refinement.
CA VARSXX is the dummy name for a subroutine to be obeyed when all the
CA        variables have been designated, to record "which variable" is this
CA        parameter" against all possible parameters for this application.
CA        This method of recording the information is new to MK4.
CA DOTHER name of the dummy subroutine passed tp VARSXX to allow it to
CA        deal with extra parameters.
C
CP Parameter naming must have been set up by LSETUP
CP All fixing, varying and constraining information must have been set up
CP into the COMMON /LINKAG/ using routines ADDFIX, ADDCON, SUBCON
CP ADDVAR
C
CD Scans all available information about all parameters.  Sets up tables
CD of: LVRPR "which parameter is this variable" (holds a packed KK value)
CD     LBSVR "which variable is this basic variable" (all +ve)
CD     LVRBS "which basic is this variable" (+=basic, -=redundant)
CD     LRDVR "which variable is this redundant variable"
CD
CD Stores all the constraints relevant to this cycle in /CONSTR/
CD
CD Sets up various useful quantities:
CD     LVARB=number of basic variables
CD     LVARV=number of variables
CD     NVARF()=numbers of variables in each phase in each family
CD     NBARF()=numbers of basics in each phase in each family
CD     LVFST1()=1 BEFORE starting place in a derivative vector for a
CD              particular family of a particular phase, i.e. which is the last
CD              variable before the first variable of that family.
CD     LBFST()=1 BEFORE starting place in a basic variable vector for a
CD              particular family of a particular phase, i.e. which is the last
CD              variable before the first basic variable of that family.
CD Calls VARSXX (application dependent) to store what used to be held in the
CD big array LPRVR, i.e. "which variable is this parameter?"
C
CO Calls PRIVAR to print out its findings.
C
      LOGICAL DEFALT,DOTHER
      EXTERNAL DEFALT,GETPAR,VARSXX,DOTHER
      LOGICAL FOUND,KSAME,FX
%      DIMENSION KKCOL(%CPAR%),KBVCOL(%CPAR%),A(%CPAR%,%ALLC%),KPRVR(%PVAR%)
%      DIMENSION KREDUN(%ALLC%)
/CONSTR/
/DERBAS/
/DERVAR/
/IOUNIT/
/LINKAG/
/PHASE/
/POINTS/
/PRBLEM/
/REFINE/
/SOURCE/
C
C START COUNTS OF VARIABLES AND BASIC VARIABLES:
      LVARV=0
      LVARB=0
C NOT IF ONLY SIMULATION:
      IF (SIMUL) GO TO 100
C
C COUNT FIXED PARAMETERS:
      LFIX=0
C
      DO 88 I=1,NPHASE
      DO 88 J=1,NFAM
      DO 88 K=1,NSOURC
C CLEAR COUNT OF VARIABLES & BASICS/FAMILY/PHASE/SOURCE
      NBARF(J,I,K)=0
      NVARF(J,I,K)=0
C CLEAR POINTERS TO STARTS-1 OF FAMILY VARIABLES  & BASICS PER PHASE/SOURCE:
      LVFST1(J,I,K)=-1
  88  LBFST1(J,I,K)=-1
C
C FIRST SCAN FIX & VARY LISTS AND FIX WHERE POSSIBLE:
C START A SCAN OF PARAMETERS:
      IFAM=0
C
C NEXT PARAMETER:
   2  CALL GETPAR(IFAM,IGEN,ISPC)
      IF (IFAM .EQ. -1) GO TO 3
      FOUND=.FALSE.
      KTIM=0
      KSTAT=0
C GET AND KK FOR THIS PARAMETER:
      KK=KPAK(IFAM,IGEN,ISPC,JPHASE,JSOURC)
C SCAN FIXES & VARIES, BOTH SPECIFIC & BLANKET, FOR MATCHES:
      DO 1 I=1,NUMFV
      IF (.NOT. KSAME(KK,KKFV(I))) GO TO 1
      IF (KTIME(I) .GT. KTIM .AND. IABS(KSTFV(I)) .GE. KSTAT)THEN
        KTIM=KTIME(I)
        KSTAT=IABS(KSTFV(I))
        FX=(KSTFV(I) .GT. 0)
      ENDIF
      FOUND=.TRUE.
   1  CONTINUE
C
C NO MENTION SO FAR IF FOUND STILL FALSE:
      IF (.NOT. FOUND) THEN
C FIRST SEE IF 'ONLY' OCCURRED ON 'FIX' CARD:
        IF (IONLY(JPHASE) .EQ. 1) THEN
          FX  =.FALSE.
C OR ON 'VARY' CARD:
        ELSE IF (IONLY(JPHASE) .EQ. 2) THEN
          FX  =.TRUE.
        ELSE
C OTHERWISE DEFAULT:
          FX  =.NOT. (DEFALT(IFAM,IGEN,ISPC))
        ENDIF
      ENDIF
C
C RECORD KK FOR "CERTAINLY FIXED" (OF WHICH THE OPPOSITE IS "PROBABLY VARIED")
      IF (FX) THEN
%      CALL ERRCHK(2,LFIX,%PVAR%,0,'LSQ parameters in VARMAK')
        KPRVR(LFIX)=KK
      ENDIF
C NEXT PARAMETER
      GO TO 2
C
C SECOND LIST ALL PARAMETERS OCCURRING IN CONSTRAINTS:
   3  NPAR=0
      DO 41 I=1,NUMCON
C NOT IF CONSTRAINT DELETED:
      IF (KSTCON(I) .EQ. 0) GO TO 41
C
C SCAN EVERY PARAMETER SPEC IN THIS CONSTRAINT:
      DO 42 K=KPTCON(I),KPTCON(I+1)-1
C NOT IF FIXED:
      IF (LFIX .EQ. 0) GO TO 46
      IF (NFIND(KKCON(K),KPRVR,LFIX) .GT. 0) GO TO 42
  46  IF (NPAR .EQ. 0) GO TO 43
C IS IT THERE ALREADY?
      IF (NFIND(KKCON(K),KKCOL,NPAR) .GT. 0) GO TO 42
C ADD TO LIST:
%  43  CALL ERRCHK(2,NPAR,%CPAR%,0,'parameters in strict constraints')
C
C IN DESCENDING SEQUENCE (SO THAT REDUNDANTS WILL BE LATER PARAMETERS)
      DO 44 J=1,NPAR-1
      IF (KKCOL(J) .GT. KKCON(K)) GO TO 44
      DO 45 L=NPAR,J+1,-1
  45  KKCOL(L)=KKCOL(L-1)
      KKCOL(J)=KKCON(K)
      GO TO 42
  44  CONTINUE
      KKCOL(NPAR)=KKCON(K)
C      DO 44 L=NPAR-1,1,-1
C      IF (KKCOL(L) .GT. KKCON(K)) GO TO 45
C  44  KKCOL(L)=KKCOL(L-1)
C      L=1
C  45  KKCOL(L)=KKCON(K)
  42  CONTINUE
  41  CONTINUE
C
C
C FILL IN MATRIX OF COEFFICIENTS IN CONSTRAINTS:
C IN MATRIX A, FIRST SUBSCRIPT = PARAMETER, SECOND=CONSTRAINT
%      CALL GMZER(A,%CPAR%,%ALLC%)
      NCON=0
      DO 51 I=1,NUMCON
      IF (KSTCON(I) .EQ. 0) GO TO 51
%      CALL ERRCHK(2,NCON,%ALLC%,0,'strict constraints')
      DO 52 K=KPTCON(I),KPTCON(I+1)-1
C NOT IF ALREADY FIXED:
      IF (LFIX .EQ. 0) GO TO 53
      IF (NFIND(KKCON(K),KPRVR,LFIX) .GT. 0) GO TO 52
  53  A(NFIND(KKCON(K),KKCOL,NPAR),NCON)=AMCON(K)
  52  CONTINUE
  51  CONTINUE
C
C THIS MATRIX MAY CONTAIN REDUNDANT OR INCONSISTENT CONSTRAINTS, OR
C SIMPLY CONSTRAINTS NOT IN THE BEST FORM FOR DESIGNATING REDUNDANT
C VARIABLES.  PERFORM GAUSSIAN ELIMINATION ON IT:
C
      SMALL=0.000001
      DO 61 NP=1,NCON
      DO 62 J=NP,NPAR
      DO 62 I=NP,NCON
      IF (ABS(A(J,I)) .GT. SMALL) GO TO 63
  62  CONTINUE
C
C NO MORE NON-ZERO COEFFICIENTS LEFT - OUT
      GO TO 64
C
C PIVOT FOUND:
C SWOP COLUMNS J AND NP (EVEN IF THEY ARE THE SAME), AND SCALE:
  63  KTEMP=KKCOL(J)
      KKCOL(J)=KKCOL(NP)
      KKCOL(NP)=KTEMP
      PIVOT=A(J,I)
      DO 65 K=1,NCON
      TEMP=A(J,K)
      A(J,K)=A(NP,K)
      A(NP,K)=TEMP
  65  CONTINUE
C
C NOW SWOP ROWS I AND NP:
      DO 66 K=1,NPAR
      TEMP=A(K,I)
      A(K,I)=A(K,NP)
      A(K,NP)=TEMP/PIVOT
  66  CONTINUE
C
C NOW SCAN ALL CONSTRAINTS, OMITTING THE SECTION BETWEEN NP AND I
C WHICH WE ALREADY KNOW TO HAVE ZEROS, AND ELIMINATE:
      DO 71 L=1,NCON
      IF (L .GE. NP .AND. L .LE. I) GO TO 71
      IF (ABS(A(NP,L)) .LT. SMALL) GO TO 71
      DO 72 M=NP+1,NPAR
  72  A(M,L)=A(M,L)-A(NP,L)*A(M,NP)
  71  CONTINUE
C
  61  CONTINUE
C
  64  NCON=NP-1
      IF (NPAR .LT. NCON) THEN
        WRITE (LPT,3010) NPAR,NCON
        WRITE (ITO,3010) NPAR,NCON
3010    FORMAT (' ERROR ** ',I4,' parameters in ',I4,' constraints')
        STOP
      ENDIF
C
C THIRD MARK THE FIRST NCON PARAMETERS FROM THE ELIMINATED
C MATRIX AS "NOT BASIC" (MAY BE FIXED OR REDUNDANT)
      DO 68 I=1,NCON
      M=-I
      DO 69 J=NCON+1,NPAR
C A NON-ZERO IN THIS PANEL MEANS A CONSTRAINT, NOT A FIXING:
      IF (ABS(A(J,I)) .GT. SMALL) GO TO 60
  69  CONTINUE
C
C HERE WE HAVE DISCOVERED THAT THE PARAMETER IS ACTUALLY FIXED:
%      CALL ERRCHK(2,LFIX,%PVAR%,0,'LSQ parameters in VARMAK')
      KPRVR(LFIX)=KKCOL(I)
      KREDUN(I)=0
      GO TO 68
C
C HERE WE HAVE DISCOVERED THAT THE PARAMETER IS REDUNDANT:
  60  KREDUN(I)=KKCOL(I)
  68  CONTINUE
C
C FOURTH SCAN PARAMETERS AGAIN, DESIGNATING BASICS AND REDUNDANTS:
C
      IFAM=0
C
C NEXT PARAMETER:
  21  CALL GETPAR(IFAM,IGEN,ISPC)
C GETPAR RETURNS IFAM -1 IF ALL FINISHED:
      IF (IFAM .EQ. -1) GO TO 22
      KK=KPAK(IFAM,IGEN,ISPC,JPHASE,JSOURC)
C
C IF PARAMETER IS FIXED, LEAVE IT SO:
      IF (LFIX .EQ. 0) GO TO 23
      IF (NFIND(KK,KPRVR,LFIX) .GT. 0) GO TO 21
C IF NOT DESIGNATED "FIX" IT MUST BE A VARIABLE:
%  23  CALL ERRCHK(2,LVARV,%VVAR%,0,'variables in LSQ')
C
C COUNT VARIABLES/FAMILY/PHASE:
      NVARF(IFAM,JPHASE,JSOURC)=NVARF(IFAM,JPHASE,JSOURC)+1
C RECORD STARTS OF FAMILIES IN ANY VARIABLES VECTOR, -1:
      IF (LVFST1(IFAM,JPHASE,JSOURC) .EQ. -1) THEN
        LVFST1(IFAM,JPHASE,JSOURC)= LVARV-1
      ENDIF
C
*** and check that F2VA has not been exceeded
C
C RECORD "WHICH PARAMETER IS THIS VARIABLE?"
      LVRPR(LVARV)=KK
C IF REDUNDANT, DEFER FURTHER DETAILS TILL WE HAVE LABELLED ALL BASICS:
      IF (NCON .NE. 0) THEN
        N=NFIND(KK,KREDUN,NCON)
        IF (N .GT. 0) THEN
          KREDUN(N)=LVARV
          GO TO 21
        ENDIF
      ENDIF
C
C MAKE IT BASIC:
%      CALL ERRCHK(2,LVARB,%BVAR%,0,'basic variables in LSQ')
C RECORD CROSS POINTERS FOR VARIABLES AND BASIC VARIABLES:
      LVRBS(LVARV)=LVARB
      LBSVR(LVARB)=LVARV
C RECORD STARTS OF FAMILIES IN ANY BASIC VARIABLES VECTOR, -1:
      IF (LBFST1(IFAM,JPHASE,JSOURC) .EQ. -1) THEN
        LBFST1(IFAM,JPHASE,JSOURC)= LVARB-1
      ENDIF
C
C ALL THE PARAMETERS INVOLVED IN THE RIGHT HAND SIDES OF CONSTRAINTS ARE
C BASIC - SEE IF THIS ONE IS THERE, AND RECORD WHICH VARIABLE IT IS IF SO:
      IF (NPAR .GT. 0) THEN
        N=NFIND(KK,KKCOL,NPAR)
        IF (N .GT. 0) KBVCOL(N)=LVARB
      ENDIF
C
C RECORD BASIC VARIABLES/FAMILY/PHASE:
      NBARF(IFAM,JPHASE,1)=NBARF(IFAM,JPHASE,1)+1
      GO TO 21
C
C A BIT OF OVERKILL UNTIL I DECIDE ON A PERMANENT STRUCTURE:
  22  IV=LVARV
      IB=LVARB
      DO 301 JJU=NPHASE,1,-1
      DO 301 IJU=NFAM,1,-1
      DO 301 KJU=NSOURC,1,-1
      IF (LBFST1(IJU,JJU,KJU) .EQ. -1) THEN
        LBFST1(IJU,JJU,KJU)=IB
      ELSE
        IB=LBFST1(IJU,JJU,KJU)
      ENDIF
      IF (LVFST1(IJU,JJU,KJU) .EQ. -1) THEN
        LVFST1(IJU,JJU,KJU)=IV
      ELSE
        IV=LVFST1(IJU,JJU,KJU)
      ENDIF
 301  CONTINUE
C
C FINALLY ABSORB ALL CONSTRAINTS FOR USE THIS CYCLE:
      JCONST=0
      NEXTJ=1
      JROWPT(1)=1
      DO 30 I=1,NCON
      LV=KREDUN(I)
      IF (LV .EQ. 0) GO TO 30
%      CALL ERRCHK(2,JCONST,%CSTR%,0,'strict constraints')
C RECORD CROSS POINTERS FOR VARIABLES AND REDUNDANT VARIABLES:
      LVRBS(LV)=-JCONST
      LRDVR(JCONST)=LV
      DO 31 J=NCON+1,NPAR
      IF (ABS(A(J,I)) .LT. SMALL) GO TO 31
C
C PUT CONSTRAINT INTO TABLE TO USE THIS CYCLE:
      JCMAT(NEXTJ)=KBVCOL(J)
      AMOUNT(NEXTJ)=-A(J,I)
      NEXTJ=NEXTJ+1
      JROWPT(JCONST+1)=NEXTJ
  31  CONTINUE
  30  CONTINUE
C
C FETTLE STARTS OF FAMILIES FOR THOSE WITH NO MEMBERS:
***???
C
C PRINT OUT WHAT WE HAVE DONE:
      CALL PRIVAR
C
C CALL APPLICATION-DEPENDENT ROUTINE TO FILL IN "WHICH VARIABLE IS THIS
C PARAMETER?" FOR ALL PARAMETERS:
      CALL VARSXX(DOTHER)
C4.26 RECORD THE NUMBER OF FAM 1 PARAMETERS ON WHICH THE STRUCTURE FACTOR DEPENDS
      IF (DOTHER(J,9,IDUM)) NVARF(1,JPHASE,1)=NVARF(1,JPHASE,1)+J
C
 100  RETURN
      END
C
C
C
C
C LEVEL 8      SUBROUTINE VARSDS
      SUBROUTINE VARSDS
C
C *** VARSDS updated by PJB 29-Sept-93  ***
C
CX
CC 7A
CH Makes variables for cell parameters and propagation vector for d-spacing LSQ.
CP Only useful if called from DSLSQ or similar.  Expects suitable type
CP of Least Squares to be set up.
C
CD First clears all possible parameters for this application to be fixed.
CD Then scans all variables as made by VARMAK, identifies each variable as a
CD type of parameter, and calls individual routines to record the information.
C
/DERVAR/
/IOUNIT/
/POINTS/
/REFINE/
C
C SET ALL VARIABLES FIXED:
      CALL CELVAR(0,0)
      CALL PROPAG(0,0)
C
C COUNT ALL VARIABLES:
      DO 1 I=1,LVARV
C J=WHICH BASIC VARIABLE:
      J=LVRBS(I)
C KPACK=WHICH PACKED PARAMETER SPEC:
      KPACK=LVRPR(I)
C
C AND ITS FAMILY, GENUS AND SPECIES:
      CALL PUNPAK(KPACK,IFAM,IGEN,ISPC)
C FAMILY 1, GENUS 1 - CELL PARAMETERS:
      IF (IFAM .EQ. 1 .AND. IGEN .EQ. 1) THEN
        IF (ISPC.LE.6) THEN
          CALL CELVAR(ISPC,I)
        ELSE
          CALL PROPAG(-ISPC+6,I)
        ENDIF
      ELSE
        CALL ERRMES(-1,0,' parameter in DSLSQ not of family 1 genus 1')
      ENDIF
C
   1  CONTINUE
      RETURN
      END
C
C
C
C
C LEVEL 13      SUBROUTINE VARSMG
      SUBROUTINE VARSMG
C
C *** VARSMG by JCM 16 Nov 90 ***
C
CX
CC 7A
CH Records variable pointers for all variables in magnetic structure-factor LSQ.
CP VARMAK has set up the variables
C
CD First clears all possible parameters for this application to be fixed.
CD Then scans variables as made by VARMAK.  Identifies each variable as a
CD type of parameter, and calls individual routines to record the information.
C
/DERVAR/
/IOUNIT/
/POINTS/
/REFINE/
C
      IF (SIMUL) GO TO 100
C SET ALL VARIABLES FIXED:
      CALL LTFAC9
      CALL CELVAR(0,0)
      CALL EXTIN9
      CALL LSCAL9
      CALL F2VAR9
      CALL MAGVAR(0,0,0)
C
C SCAN ALL VARIABLES:
      DO 1 I=1,LVARV
      KPACK=LVRPR(I)
      CALL PUNPAK(KPACK,IFAM,IGEN,ISPC)
C
C BRANCH ON FAMILY:
      GO TO (11,12), IFAM
C
  11  GO TO (21,22) , IGEN
C
C FAMILY 1, GENUS 1 - MISCELLANEOUS SPECIES (TFAC,A*,B* . . F*,DOMR,MOSC):
  21  GO TO (31,32,32,32,32,32,32,33,33) , ISPC
C
C TFAC:
  31  CALL LTFAC8(I)
      GO TO 1
C
C DOMR OR MOSC (EXTINCTION CORRECTION PARAMETERS)
  33  CALL EXTIN8(ISPC-7,I)
      GO TO 1
C
C CELL PARAMETERS:
  32  CALL CELVAR(ISPC-1,I)
      GO TO 1
C
C FAMILY 1, GENUS 2 - IN SF THIS IS 'SCAL':
  22  CALL LSCAL8(ISPC,I)
      GO TO 1
C
C FAMILY 2 - THESE ARE ALL TO DO WITH THE STRUCTURE FACTOR:
  12  IF (ISPC .LE. 12) CALL F2VAR8(IGEN,ISPC,I)
      IF (ISPC .GT. 12) CALL MAGVAR(IGEN,ISPC,I)
   1  CONTINUE
 100  RETURN
      END
C
C
C
C
C LEVEL 8      SUBROUTINE VARSSF(DOTHER)
      SUBROUTINE VARSSF(DOTHER)
C
C *** VARSSF Updated by PJB C4.26 For 3rd argument in DOTHER March 2013 ***
C
CX
CC 7A
CH Records variable pointers for all variables in structure-factor LSQ.
CP VARMAK has set up the variables
CA DOTHER is the name of a logical function to record the variable
CA pointers for parameters not in the basic structure factor set (F2PARS)
CA it is LDUMMY for simple structure factor LSQ.
C
CD First clears all possible parameters for this application to be fixed.
CD Then scans variables as made by VARMAK.  Identifies each variable as a
CD type of parameter, and calls individual routines to record the information.
C
      EXTERNAL DOTHER
      LOGICAL DOTHER,CLAIMD
      dimension IDUM(4)
      CHARACTER *12 BUFF
/DERVAR/
/IOUNIT/
/NEWOLD/
/POINTS/
/REFINE/
C
      IF (SIMUL) GO TO 100
C SET ALL VARIABLES FIXED:
      CALL LTFAC9
      CALL CELVAR(0,0)
      CALL EXTIN9
      CALL LSCAL9
      CALL F2VAR9
      CLAIMD = DOTHER(0,2,IDUM)
C
C SCAN ALL VARIABLES:
      DO 1 I=1,LVARV
      KPACK=LVRPR(I)
      CALL PUNPAK(KPACK,IFAM,IGEN,ISPC)
C
C BRANCH ON FAMILY:
      GO TO (11,12), IFAM
      GO TO 99
C
  11  GO TO (21,22) , IGEN
      GO TO 99
C
C FAMILY 1, GENUS 1 - MISCELLANEOUS SPECIES (TFAC,A*,B* . . F*,DOMR,MOSC):
  21  GO TO (31,32,32,32,32,32,32,33,33) , ISPC
      GO TO 99
C
C TFAC:
  31  CALL LTFAC8(I)
      GO TO 1
C
C DOMR OR MOSC (EXTINCTION CORRECTION PARAMETERS)
  33  CALL EXTIN8(ISPC-7,I)
      GO TO 1
C
C CELL PARAMETERS:
  32  CALL CELVAR(ISPC-1,I)
      GO TO 1
C
C FAMILY 1, GENUS 2 - IN SF THIS IS 'SCAL':
  22  CALL LSCAL8(ISPC,I)
      GO TO 1
C
C UNRECOGNISED FAMILY GENUS OR SPECIES TRY DOTHER
  99  IF (DOTHER(I,2,IDUM)) GO TO 1
      WRITE (BUFF,1000) IFAM,IGEN,ISPC
 1000 FORMAT (3I4)
      CALL ERRMES(-1,0,
     &'VARSSF Parameter with family, genus and species'//
     &BUFF//' not defined')
C
C FAMILY 2 - THESE ARE ALL TO DO WITH THE STRUCTURE FACTOR:
  12  IF (ISPC .GT. 12) GO TO 99
      CALL F2VAR8(IGEN,ISPC,I)
   1  CONTINUE
 100  RETURN
      END
C
C
C
C
C LEVEL 8      SUBROUTINE VARST2
      SUBROUTINE VARST2
C
C *** VARST2 by JCM 17 Aug 92 ***
C
CX
CC 7B
CH Makes variables for zero and cell for T2 type LSQ
CP Only useful if called from T2LSQ or similar.  Expects suitable type
CP of Least Squares to be set up.
C
CD First clears all possible parameters for this application to be fixed.
CD Then scans all variables as made by VARMAK, identifies each variable as a
CD type of parameter, and calls individual routines to record the information.
C
/DERVAR/
/IOUNIT/
/POINTS/
/REFINE/
/ZEROPT/
C
      IF (SIMUL) GO TO 100
C SET ALL VARIABLES FIXED:
      CALL CELVAR(0,0)
      KZERO=0
C
C COUNT ALL VARIABLES:
      DO 1 I=1,LVARV
C J=WHICH BASIC VARIABLE:
      J=LVRBS(I)
C KPACK=WHICH PACKED PARAMETER SPEC:
      KPACK=LVRPR(I)
C
C AND ITS FAMILY, GENUS AND SPECIES:
      CALL PUNPAK(KPACK,IFAM,IGEN,ISPC)
C FAMILY 1, GENUS 1 - CELL PARAMETERS:
      IF (IGEN .EQ. 1) THEN
        IF (ISPC .EQ. 7) THEN
          KZERO=I
        ELSE
          CALL CELVAR(ISPC,I)
        ENDIF
      ENDIF
C
   1  CONTINUE
 100  RETURN
      END
C
C
C
C
C LEVEL 1      FUNCTION VCTMOD(SCALE,H,IR)
      FUNCTION VCTMOD(SCALE,H,IR)
C
C *** VCTMOD by JCM 26 Apr 84 ***
C
CX
CC 1B
CH Calculates the modulus of the vector H, in either space.
CA On entry H is a 1x3 array holding the given vector
CA          SCALE is the number by which to multiply the answer
CA          IR indicates the required space.  The modulus is calculated
CA             in real space if IR=1, reciprocal if IR=2.
C
CN Multiplies by the input quantity SCALE - useful if SCALE is equal
CN to say, lambda/2
C
      DOUBLE PRECISION VEC
      DIMENSION H(3)
/CELPAR/
C
      VEC = 0.
      J = 2
      K = 3
      DO 1 I=1,3
      VEC=VEC+H(I)*H(I)*CPARS(I,IR) + H(J)*H(K)*2.*CPARS(I+3,IR)
      J = K
   1  K = I
      VEC = SCALE*DSQRT(VEC)
      VCTMOD = SNGL(VEC)
      RETURN
      END
C
C
C
C
C LEVEL 4      FUNCTION VECOUP(J1,M1,J2,M2,J,M)
      FUNCTION VECOUP(J1,M1,J2,M2,J,M)
C
C *** VECOUP updated by PJB 23-Jun-98 ***
C
CX
CC 9C
CH Calculates Clebsch-Gordon vector coupling coefficient
CH <j1,m1,j2,m2|j,m>
CA J1,M1,J2,M2,J,M are the angular momentun quanum numbers
CA They are floating point numbers, only because they may be half
CA integral.
CA On exit VECOUP holds the answer
C
      DIMENSION IFAC(7)
      REAL J1,J2,J,M1,M2,M
C
      VECOUP = 0.
      IF (J .GT. J1+J2) GO TO 100
      IF (ABS(J1-J2) .GT. J) GO TO 100
      IF (M .NE. M1+M2) GO TO 100
      IFAC(1) = NINT(J1+J2-J)
      IF (ABS(FLOAT(IFAC(1))-(J1+J2-J)).GT.10E-6) GO TO 99
      IFAC(2) = NINT(J1-M1)
      IF (ABS(FLOAT(IFAC(2))-(J1-M1)).GT.10E-6) GO TO 99
      IFAC(3) = NINT(J2+M2)
      IF (ABS(FLOAT(IFAC(3))-(J2+M2)).GT.10E-6) GO TO 99
      IFAC(4) = NINT(J-J2+M1)
      IFAC(5) = NINT(J-J1-M2)
      IFAC(6) = 0
      IFAC(7)=NINT(J+M)
      IF (ABS(FLOAT(IFAC(7))-(J+M)).GT.10E-6) GO TO 99
      N = 0
      DO 1 I = 4,6
      IF (IFAC(I) .LT. N) N = IFAC(I)
    1 CONTINUE
      ANUM = FACT(NINT(J1+J2-J))*FACT(NINT(J1-J2+J))*FACT(NINT(J2+J-J1))
      ANUM = ANUM*FACT(NINT(J1+M1))*FACT(NINT(J2+M2))*FACT(NINT(J+M))
      ANUM = ANUM*FACT(NINT(J1-M1))*FACT(NINT(J2-M2))*FACT(NINT(J-M))
      VECOUP = SQRT((2.*J+1)*ANUM/FACT(NINT(J1+J2+J+1)))
      VEC = VECOUP
C
      K = 0
      DO 7 I = 1,3
      IFAC(I) = IFAC(I) + N
      IF (IFAC(I) .EQ. 0) K = 1
    7 CONTINUE
C
      DO 8 I = 4,6
    8 IFAC(I) = IFAC(I) - N
C
      SUM = 1
      DO 2 I = 1,6
    2 SUM = SUM/FACT(IFAC(I))
C
      SUM = SUM*FLOAT(1-2*MOD(IABS(N),2))
      TERM = SUM
      IF (K .EQ. 1) GO TO 101
    5 TERM = -TERM
C
      DO 3 I = 4,6
      IFAC(I) = IFAC(I) + 1
    3 TERM = TERM/FLOAT(IFAC(I))
C
      DO 4 I = 1,3
      TERM = TERM*FLOAT(IFAC(I))
      IFAC(I) = IFAC(I) - 1
      IF (IFAC(I) .EQ. 0) K = 1
    4 CONTINUE
      SUM = SUM + TERM
      IF (K .NE. 1) GO TO 5
      GO TO 101
C
C  ERROR NON-INTEGRAL FACT
   99 CALL ERRMES(1,-1,
     &' Non-integral argument for factorial in VECOUP')
      GO TO 100
C
 101  VECOUP = VECOUP*SUM
 100  RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE VECPRD(VEC1,VEC2,PRD)
      SUBROUTINE VECPRD(VEC1,VEC2,PRD)
C
C *** VECPRD by JCM ***
C
CX
CC 12C
CH Calculates the vector product of two 1x3 vectors.
CA On entry VEC1 and VEC2 hold 1x3 real vectors
CA On exit PRD = the vector product of VEC1 cross VEC2
C
      DIMENSION VEC1(3),VEC2(3),PRD(3)
      J = 2
      K = 3
      DO 1 I = 1,3
      PRD(I) = VEC1(J)*VEC2(K) - VEC1(K)*VEC2(J)
      J = K
   1  K = I
      RETURN
      END
C
C
C
C
C LEVEL 5      SUBROUTINE VOCAB(WORD,MEAN,NW)
      SUBROUTINE VOCAB(WORD,MEAN,NW)
C
C *** VOCAB by JCM 4 Aug 90 ***
C
CX
CC 6A
CH Adds a given set of vocabulary and meanings to the Least Squares
CH total vocabulary.
CA On entry WORD is an array of NW A4 words
CA          MEAN is a corresponding (3,NW) array of integers, being the family,
CA               genus and species assigned to the word
CP In /WDSPC/ IWDNUM should hold the existing number of entries in LSQWD.
CP If used in a PR context:
CP In /PHASE/ KPHASE should hold the relevant phase (or zero if for all phases)
CP In /SOURCE/ KSOURC should hold the relevant source (or zero for all sources)
CD Copies the word array to LSQWD, starting at entry IWDNUM+1
CD If the first of a triplet in MEAN is negative, copies it to IWDSPC
CD Otherwise packs the triplet according to preset packing to IWDSPC
CD Updates IWDNUM, checking it.
C
      CHARACTER *4 WORD(NW)
      DIMENSION MEAN(3,NW)
/PHASE/
/SOURCE/
/WDSPC/
/WORDS/
C
C CHECK ARRAY SIZES:
%      CALL ERRCHK(1,IWDNUM+NW,%WORD%,0,
     & 'words specifying LSQ problem')
      DO 1 I=1,NW
      LSQWD(I+IWDNUM)=WORD(I)
      IF (MEAN(1,I) .LT. 0) THEN
        IWDSPC(I+IWDNUM)=MEAN(1,I)
      ELSE
        IWDSPC(I+IWDNUM)=KPAK(MEAN(1,I),MEAN(2,I),MEAN(3,I),
     &  KPHASE,KSOURC)
      ENDIF
   1  CONTINUE
      IWDNUM=IWDNUM+NW
      RETURN
      END
C
C
C
C
C LEVEL 2      SUBROUTINE VOIGT(X,SIGMA,GAMMA,YVAL,DERX,DERS,DERG)
      SUBROUTINE VOIGT(X,SIGMA,GAMMA,YVAL,DERX,DERS,DERG)
C
C *** VOIGT by WIFD Jun 84 ***
C
CC 9C
CH Calculates normalised Voigt function
C
CD...      VOIGT is the normalised VOIGT function; a convolution of a
CD      normalised Gaussian (half-width= sigma) and Lorentzian
CD      (Cauchy) function (full-width at half-height= width). The
CD      function is calculated by noting that the VOIGT function
CD      is, to within a scale factor, equal to the real part of the
CD      complex error function.
C            W.I.F.David            6-JUN-84
C            Neutron Division
C            RAL                  ext. 5179
C
      DOUBLE PRECISION WR,WI,XX,YY
C
      OVRTPI=0.564189584
      OVRT2=0.707106781
      BTEM=OVRT2/SIGMA
      ATEM=OVRTPI*BTEM
      XTEM=X*BTEM
      YTEM=0.5*GAMMA*BTEM
      XX= DBLE(XTEM)
      YY= DBLE(YTEM)
      CALL WERF(WR,WI,XX,YY)
      SWR=SNGL(WR)
      SWI=SNGL(WI)
      CTEM=ATEM*BTEM
      YVAL=ATEM*SWR
      DWRDX=-(2.*(XTEM*SWR-YTEM*SWI))
      DWRDY= 2.*(YTEM*SWR+XTEM*SWI-OVRTPI)
      DERX=CTEM*DWRDX
      DERS=-(ATEM*(SWR+DWRDX*XTEM+DWRDY*YTEM)/SIGMA)
      DERG=0.5*CTEM*DWRDY
C
      RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE WERF(RS1,RS2,XX,YY)
      SUBROUTINE WERF(RS1,RS2,XX,YY)
C
C *** WERF by WIFD 25 May 84 ***
C
CC 9C
CH Weighted error function ???
C
      IMPLICIT DOUBLE PRECISION            (A-H,O-Z)
      DOUBLE PRECISION                  LAMBDA
      LOGICAL                  B
C
      X=DABS(XX)
      Y=DABS(YY)
      IF (Y .LT. 4.29 .AND. X .LT. 5.33) GO TO 1
      H= 0.
      NC= 0
      NU= 8
      LAMBDA= 0.
      B= .TRUE.
      GO TO 2
 1      S=(1.0-Y/4.29)*DSQRT(1.0-X**2/28.41)
      H=1.6*S
      H2=2.0*H
      NC=6+IDINT(23.0*S)
      NU=9+IDINT(21.0*S)
      LAMBDA=H2**NC
      B=LAMBDA .EQ. 0.
 2      R1=0.
      R2=0.
      S1=0.
      S2=0.
      N=NU+1
 3      N=N-1
      FN=N+1
      T1=Y+H+FN*R1
      T2=X-FN*R2
      C=0.5/(T1**2+T2**2)
      R1=C*T1
      R2=C*T2
      IF (H .LE. 0.0 .OR. N .GT. NC) GO TO 4
      T1= LAMBDA+S1
      S1=R1*T1-R2*S2
      S2=R2*T1+R1*S2
      LAMBDA=LAMBDA/H2
 4      IF (N .GT. 0) GO TO 3
      IF (B) GO TO 6
      RS1=S1
      RS2=S2
      GO TO 7
 6      RS1=R1
      RS2=R2
 7      RS1= 1.12837916709551*RS1
      IF (Y .EQ. 0.0) RS1= DEXP(-(X**2))
      RS2= 1.12837916709551*RS2
      IF (XX .LT. 0) RS2= -RS2
      RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE WGHTLS(N,ARG)
      SUBROUTINE WGHTLS(N,ARG)
C
C *** WGHTLS updated by JCM 23 Mar 92 ***
C
CX
CC 6C
CH Performs various operations to do with weights for LSQ, either for PR
CH or simpler applications.
CH applications.
CA On entry N=1 means find an L WGHT card and read from it the type of
CA              weighting to be used, with default = 1.  ARG is irrelevant.
CA          N=2 means from ARG, IWGHT etc make a weight to go with this OBS
CA          N=3 means given WT, get WDIFF and SQRTWT.  ARG is included for
CA              diagnostic purposes only, and is sometimes used as the
CA              argument, or sometimes the observation.
C
      LOGICAL ONCARD
/IOUNIT/
/OBSCAL/
/SOURCE/
C
      GO TO (10,20,30) , N
C
C FIND AND INTERPRET AN L WGHT CARD, OR THE LACK OF IT:
  10  IF (.NOT. ONCARD('L','WGHT',W)) THEN
        CALL MESS(LPT,1,'No L WGHT card -')
        GO TO 101
      ELSE
        IWGH(KSOURC)=JFIX(W)
        IF (IWGH(KSOURC) .GT. 3 .OR. IWGH(KSOURC) .LE. 0) THEN
          CALL ERRIN2(IWGH(KSOURC),1,'weighting scheme',
     &  ' not allowed -')
          GO TO 101
        ENDIF
      ENDIF
C
      GO TO (41,42,43) , IWGH(KSOURC)
C
C UNIT WEIGHTS:
  41  CALL MESS(LPT,1,'Unit weights')
      GO TO 100
C
C WEIGHT TO BE USED AS READ:
  42  CALL MESS(LPT,1,
     & 'Weights to be used as read from reflection data')
      GO TO 100
C
C SIGMA READ, WEIGHT IS 1/SIGMA SQUARED:
  43  CALL MESS(LPT,1,'Sigma read from reflection data - weight '//
     & 'is 1/sigma squared')
      GO TO 100
C
C INITIAL VALUE FOR WT - USED TO BE SUBROUTINE WTINPR:
  20  GO TO (1,2,3) , IWGH(JSOURC)
C
C UNIT WEIGHTS:
   1  WT=1.
      GO TO 100
C
C DOBS READ AND TO BE USED AS WEIGHT:
   2  WT=DOBS
      GO TO 100
C
C SIGMA READ (INTO DOBS) - USE 1/SIGMA SQUARED:
   3  IF (DOBS.NE.0.) THEN
        WT=1./(DOBS*DOBS)
      ELSE
       WRITE(LPT,3000) ARG,OBS
3000    FORMAT(/' WARNING ** zero weight found for point ',
     &   2(F10.3,2X),' -- weight set to unity ')
        WT=1.0
      ENDIF
      GO TO 100
C
  30  SQRTWT=SQRT(WT)
      WDIFF=SQRTWT*DIFF
      GO TO 100
C
 101  IWGH(KSOURC) = 1
      CALL MESS(LPT,0,'assuming unit weights')
 100  RETURN
      END
C
C
C
C
C LEVEL 2      SUBROUTINE WGHTSF
      SUBROUTINE WGHTSF
C
C *** WGHTSF argument H removed by PJB 12-July 1999 ***
C
CX
CC 6C
CH Deals with weights of LSQ observations for single crystal.
CD Puts weight of current observation into WT, its square root into SQRTWT,
CD and WDIFF = SQRTWT times difference, all according to IWGHT.
C
/DSOURC/
/OBSCAL/
C
C Now the statistical weights are calculated when reading the data
       DOBS=SQRT(1./WT)
       GO TO (1,2) ,IWGHT
C
C  NO WEIGHTS, but arrange relative weights of different data sets
   1  WT=SRCWT(JSRC)
      GO TO 3
C
   2  WT=WT*SRCWT(JSRC)
C
   3  SQRTWT=SQRT(WT)
      WDIFF=DIFF*SQRTWT
      RETURN
      END
C
C
C
C
C LEVEL 1      FUNCTION WIYPOS(Y)
C
      FUNCTION WIYPOS(Y)
C
C *** WIYPOS by WIFD 6-JUNE-84 ***
C
CC 9C
CH      Returns  \$\exp(y^2){\textrm errf}(y)\$ for positive \$y\$ only
C
      IMPLICIT DOUBLE PRECISION            (A-H,O-V)
      DOUBLE PRECISION LAMBDA
      LOGICAL B
      VY=DBLE(Y)
      IF (VY .LT. 4.29 ) GO TO 1
      H= 0.
      NC= 0
      N= 9
      LAMBDA= 0.
      B= .TRUE.
      GO TO 2
 1      S=(1.0-VY/4.29)
      H=1.6*S
      H2=2.0*H
      NC=6+IDINT(23.0*S)
      N=10+IDINT(21.0*S)
      LAMBDA=H2**NC
      B= .FALSE.
      IF (LAMBDA .EQ. 0.) B= .TRUE.
 2      R1=0.
      S1=0.
 3      N=N-1
      FN=N+1
      T1=VY+H+FN*R1
      R1=0.5/T1
      IF (H .LE. 0.0 .OR. N .GT. NC) GO TO 4
      S1=R1*(LAMBDA+S1)
      LAMBDA=LAMBDA/H2
 4      IF (N .GT. 0) GO TO 3
      IF (B) GO TO 6
      VR= S1
      GO TO 7
 6      VR= R1
 7      VR= 1.12837916709551*VR
      IF (VY .EQ. 0.0) VR= 1.
      WIYPOS= SNGL(VR)
      RETURN
      END
C
C
C
C
C LEVEL 2      SUBROUTINE WTMEAN(X,DX,IFUN,SUMS)
      SUBROUTINE WTMEAN(X,DX,IFUN,SUMS)
C
C *** WTMEAN corrected by PJB 21-Oct-97 ***
C
CX
CC 9C
CH Multiple entry routine for the calculation of weighted averages.
CA On entry IFUN indicates which action is required:
CA          IFUN= 0 initialses an array SUMS for subsequent summing.
CA          IFUN= a positive integer adds an observation X with a  weight
CA                deduced from the value of IFUN:
CA                IFUN=1 gives unit weights
CA                IFUN=2 gives 1/DX squared
CA          IFUN= a negative integer returns the mean in X, the standard
CA                deviation in DX, and the number of observations in
CA                the 4th element of given array SUMS.
CA If an observation has zero DX, it is ignored.  -ve DX is treated as +ve.
C
CA SUMS is a 1x5 array holding values for an individual set of data, so that
CA      several sets may be collected simultaneously.
CA
CA SUMS HOLDS:
CA      Sum of weighted observations
CA      Sum of weighted squares of observations
CA      Sum of 1/DX squared
CA      Number of observations
CA      Denominator for mean
CA             If unit weights, this is the number of observations,
CA             If 1/DX sqrd weights this is the sum of the weights
C
C
      DIMENSION SUMS(5)
      IF (IFUN .LT.0) GO TO 1
      IF (IFUN .GT. 0) GO TO 3
C
C  INITIALISE:
      CALL GMZER(SUMS,1,5)
      GO TO 100
C
C  ADD AN OBSERVATION:
   3  SUMS(4)=SUMS(4)+1.
      W=1.
      IF (DX .EQ. 0.) GO TO 100
      D=1./(DX)**2
      IF (IFUN .EQ. 2) W=D
      SUMS(1) = SUMS(1)+X*W
      SUMS(2) = SUMS(2)+X*(X*W)
      SUMS(3) = SUMS(3) + D
      SUMS(5) = SUMS(5) + W
      GO TO 100
C
C  CALCULATE MEAN AND SDEV:
   1  X = 0.
      DX = 0.
      IF (SUMS(4) .LE. 0 ) GO TO 100
      X = SUMS(1)/SUMS(5)
      DEL = 1./SUMS(3)
      IF (SUMS(4) .EQ.1.) GO TO 5
      DDX=SUMS(2)-SUMS(1)*X
      IF (DDX.LT.0) DDX=0
      DX = DDX/(SUMS(5)*(SUMS(4)-1.))
      IF (DEL .LT. DX) DEL = DX
    5  DX=SQRT(DEL)
 100  RETURN
      END
C
C
C
C
C LEVEL 3      SUBROUTINE XROOT(IA,XX,IS,IL,C)
      SUBROUTINE XROOT(IA,XX,IS,IL,C)
C
C *** XROOT updated by JCM 18 Oct 87 ***
C
CX
CC 8B
CH Finds the symmetry operations which take the given source atom into
CH the given coordinates.
C
CA On entry IA is the number of the atom in the given list on A cards
CA          XX is a 1x3 real array holding the given x,y,z to be identified.
CA On exit IS the number of the necessary symmetry operator, set -ve if
CA            the (-x, -y, -z) operator is also required;  if no such operator
CA            is found, IS=0
CA         IL is the number of the necessary lattice translation.
CA         C is a 1x3 real array holding any necessary cell translations,
CA           which will be whole numbers.
C
CP The symmetry should have been read by SYMOP, and the atomic positions
CP by ATOPOS.
C
CN There is an inverse subroutine XTRANS
CN Does not now involve the putting of a transformed atom back into
CN a central cell, because this had awkward repercussions in slack
CN constraints.
C
      DIMENSION XX(3),X1(3),X2(3),X3(3),C(3)
      LOGICAL GMSAME
/NSYM/
/POSNS/
/SYMDA/
C
C CYCLE OVER CENTRE
      DO 1 IC=1,NCENT
C CYCLE OVER OPERATORS WITHOUT CENTRE:
      DO 2 IS=1,NOPC
      CALL ROTSYM(X(1,IA),X1,IS,1)
      CALL GMADD(X1,TRANS(1,IS),X1,1,3)
      IF (IC .EQ. 2) CALL GMREV(X1,X1,1,3)
C CYCLE OVER LATTICE TRANSLATIONS:
      DO 3 IL=1,NLAT
      CALL GMADD(X1,ALAT(1,IL),X2,1,3)
C DO NOT NOW PUT INTO CENTRAL CELL:
C      CALL FRAC3(X2)
C
C SCAN ALL 27 CELLS:
      DO 4 NCELZ=1,5
      C(3)=FLOAT(NCELZ-3)
      DO 5 NCELY=1,5
      C(2)=FLOAT(NCELY-3)
      DO 6 NCELX=1,5
      C(1)=FLOAT(NCELX-3)
      CALL GMADD(X2,C,X3,1,3)
C
C X3 SHOULD EVENTUALLY MATCH OUR TARGET:
      IF (GMSAME(XX,X3,3,0.0001)) GO TO 101
   6  CONTINUE
   5  CONTINUE
   4  CONTINUE
   3  CONTINUE
   2  CONTINUE
   1  CONTINUE
C IF HERE, WE HAVE NO MATCH:
      IS=0
 101  IF (IC .EQ. 2) IS=-IS
      RETURN
      END
C
C
C
C
C LEVEL 3      SUBROUTINE XTRANS(IAT,XX,IS,IL,C)
      SUBROUTINE XTRANS(IAT,XX,IS,IL,C)
C
C *** XTRANS corrected by JCM 18 Oct 87 ***
C
CX
CC 8B
CH Transforms a given atomic position by given symmetry operator and
CH lattice and cell translations.
C
CA On entry IAT = which atom
CA          IS = which symmetry operator, -ve if -x,-y,-z
CA          IL = which lattice translation
CA          C is a 1x3 real array holding cell translations in the x, y and
CA            z directions, which will usually be integers.
CA On exit  XX is a 1x3 real array holding the transformed coordinates
CP The symmetry should have been set up by SYMOP, and the atomic positions
CP by ATOPOS.
C
CN There is an inverse subroutine XROOT
CN Altered not to put atom into central cell after symmetry transformations
CN because this has awkward repercussions in slack constraints
C
      DIMENSION XX(3),C(3)
/POSNS/
/SYMDA/
C
C ROTATE BY SYMMETRY OPERATOR:
      CALL ROTSYM(X(1,IAT),XX(1),IABS(IS),1)
C TRANSLATION VECTOR ASSOCIATED WITH THIS SYMMETRY OPERATOR:
      CALL GMADD(XX(1),TRANS(1,IABS(IS)),XX(1),1,3)
C CENTRE OF SYMMETRY IF APPLICABLE:
      IF (IS .LT. 0) CALL GMREV(XX,XX,1,3)
C LATTICE TRANSLATION:
      CALL GMADD(XX(1),ALAT(1,IL),XX(1),1,3)
C DO NOT NOW PUT INTO CENTRAL CELL:
C      CALL FRAC3(XX)
C CELL TRANSLATIONS:
      CALL GMADD(XX(1),C(1),XX(1),1,3)
      RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE XYZREL
      SUBROUTINE XYZREL
C
C *** XYZREL by JCM 28 Nov 91 ***
C
CX
CC 6B
CH Collects all position parameter constraints implied by the symmetry.
CD Space group symmetry generated constraints are each between 2 parameters.
CD Some of the relations found may lead to fixings rather than constraints.
CD
CD On exit in /POSREL/ for each atom I the integer array NXYZ(I,1:3) and
CD real array XYZ(I,1:3) hold the constraints.
C
C
      DIMENSION RMAT(3,3)
/POSNS/
/POSREL/
/SYMDA/
C
C SCAN ALL ATOMS, PICKING UP RELATIONS BETWEEN POSITION PARAMETERS:
      DO 3 IR=1,NATOM
C CLEAR OUT ALL FIX/RELA INFO FOR THIS ATOM:
      DO 2 K=1,3
      NXYZ(K,IR)=9999
   2  CONTINUE
C
C JUMP IF NOT SPECIAL:
      IF (ISGEN(1,IR) .EQ. 1) GO TO 3
C JUMP IF NOT SPECIAL BECAUSE OF A CENTRE OF SYMMETRY AT THE ORIGIN:
      IF (ISGEN(1,IR) .LE. 0) THEN
C FIX ALL POSITION:
        CALL JGMZER(NXYZ(1,IR),1,3)
        GO TO 3
      ENDIF
C
C TAKE FIRST (OF POSSIBLE 2) SYMMETRY ELEMENTS MAKING THIS POSITION SPECIAL:
      DO 1 I=2,3
      K=IABS(ISGEN(I,IR))
      CALL GMEQ(SYM(1,1,K),RMAT,3,3)
      IF (ISGEN(I,IR) .LT. 0) CALL GMREV(RMAT,RMAT,3,3)
      CALL RELSM3(RMAT,NXYZ(1,IR),XYZ(1,IR))
C
C IS THERE A SECOND GENERATOR OF THE SUB-GROUP WHICH MAKES THIS ATOM SPECIAL?
      IF (ISGEN(3,IR) .EQ. 0) GO TO 3
   1  CONTINUE
   3  CONTINUE
      RETURN
      END
##ENDLIB
##MAI
C
C                       M A I N   P R O G R A M S
C
C
C LEVEL 50      PROGRAM ABSMSF
      PROGRAM ABSMSF
C
C *** ABSMSF updated by PJB March 2010 C4.19 headers ***
C
C *****************************************************************************
C
C                            A B S M S F
C
C TO TAKE MEANS OF INTENSITIES AND CALCULATE STRUCTURE FACTORS
C AND CALCULATE AND APPLY ABSORPTION CORRECTIONS IF G CARDS ARE GIVEN
C
C *****************************************************************************
C
CC 2D
CH To read  ARRNGE files, apply absorption corrections and calculate
CH mean structure factors
C
CD The program reads a file written by an "arrnge" type program.
CD Then,  if G cards are present, it calculates and applies absorption
CD corrections to the measured intensities. The program then calculates
CD the weighted mean of all measurements of reflections which should
CD be equivalent and deduces the mean structure factor.
CD A statistical analysis is made of the degree of reproducibility
CD of multiple measurements of the same reflection and on the degree
CD of equivalence of symmetrically equivalent reflections. The mean
CD overall reflection intensity is calculated in order to facilitate
CD the estimation of a scale factor.
C
CI The crystal data file must contain:
CI      S cards giving the symmetry.
CI      A C card with the cell dimensions.
CI      I cards (the same as were used with ARRNGE). These define
CI      the type of data, how many additional parameters such as
CI      angles were stored by ARRNGE, etc.
CI The following are optional
CI      D cards describing the diffraction geometry.
CI      G cards describing the crystal shape.
CI If either is absent no absorption corrections will be made.
CI
CI The data file is that written by ARRNGE. Default extension ".arr"
C
CO The usual listing file reporting data read from the CDF. It also
CO reports the results of the statistical analysis.
CO An optional second listing file giving the absorption corrections. It
CO is called ABSCOR.LIS and will only be produced if there is
CO an OUTP 100 entry on an I card.
CO The output file, which will have default extension ".sf", contains
CO a list of hkl, Fobs, esd(Fobs) in a format suitable for input to
CO least squares programs: MODE 3 for integer indices and MODE 6 for
CO floating indices.
C
CR On running the program the user is asked for the name of the
CR crystal data file, the reflection data file (.arr) and is then
CR asked to choose the name for the output file (.sf).
CR The results of the statistical analysis are reported on the
CR terminal.
C
CN If extinction corrections which are not path sensitive are to be
CN made the extinction coefficients required by least squares programs
CN can be obtained by running EXTCAL on the files written by ABSMSF.
CN Note however that if the paths for different reflections differ
CN significantly then equivalent reflections should be treated
CN independently and AVEXAR rather than ABSMSF should be used to
CN process the ARRNGE output files.
C
      DIMENSION LUN(2),LOUT(1)
      CHARACTER*56 HEDING,FILNAM*40,FILNOM*10
/ABSDAT/
/CARDRC/
/IOUNIT/
/DGEOM/
/REFS/
/SCRACH/
/STATS/
      DATA HEDING/'(5X,''h'',4X,''k'',4X,''l'',10X,''Fobs'',7X,''DFobs
     &''/)'/
C
      CALL PREFIN('ABSMSF')
      MODE=0
      CALL SYMOP
      CALL RECIP
      CALL INPUTI
      CALL ICDFMT(INC,ITEMS)
      IF (INC.NE.0) THEN
        HEDING(2:2)='6'
        HEDING(9:9)='7'
        HEDING(16:16)='7'
        HEDING(23:24)='12'
      ENDIF
      SCALE(1)=1.
      SCALE(2)=1.
      LH=2
      NAMFIL='.ARR'
      LUNI=NOPFIL(101)
      LUN(1)=LUNI
      CALL ARRHED
      IF (ICDNO(7).NE.0) THEN
        CALL SETABS
C FORCE ABSORPTION INTEGRAL
        MODEA=1
        CALL ABSCOR(0)
        MODE=1
      ELSE
        CALL SETDC
      ENDIF
      CALL ERRMES(0,0,'to ABSMSF')
C
C OPEN output file
      FILNAM=FILNOM(LUN(1))
      L=LENG(FILNAM,10)
      MESSAG=FILNAM(1:L-4)
      NAMFIL='.SF '
      LOUT(1)=NOPFIL(122)
C4.19 Call common module to write header on structure factor output
C4.19a corrected order of parameters
      CALL HDROUT(LOUT,1,MODE)
C
      CALL NEWPAG(LPT)
      WRITE (LPT,HEDING)
      CALL STATIS(-1)
      LINO=3
C
    1 IEND= INPUAR(1,LUN)
      IF (IEND.NE.0) GO TO 100
C Skip line for domain average if no entries.
      if (ii.eq.0) go to 1
      IF (ICDNO(7).NE.0) CALL ABSCOR(1)
      CALL STATIS(1)
C
C  CALCULATE F FROM F**2
      IF (AMEAN(1).LT.0) GO TO 1
      F=SQRT(AMEAN(1))
      DF=SQRT(AMEAN(1)+DEV(1))-F
      CALL TESTP(LPT,LINO,1,HEDING,LH)
      IF (INC .NE. 0) THEN
        WRITE (LOUT(1),2006) (R(II+I,1),I=1,3),F,DF
2006    FORMAT (3F8.3,2F10.4)
        WRITE (LPT,2005) (R(II+I,1),I=1,3),F,DF
2005    FORMAT (1X,3F8.3,2X,2F12.3)
      ELSE
        WRITE (LPT,2001)(K(I,1),I=1,3),F,DF
2001    FORMAT (1X,3I5,2X,2F12.3)
        WRITE (LOUT(1),2002) (K(I,1),I=1,3),F,DF
2002    FORMAT (3I5,2F10.4)
      ENDIF
      GO TO 1
C
C  END OF DATA GIVE STATITSICS
  100 R1=100.*SUMS(2)/SUMS(1)
      AMNF2=SUMS(12)/SUMS(11)
      WRITE (LPT,2000) R1
      WRITE (ITO,2000) R1
      IF (SUMS(6).GT.1) THEN
        R2=100.*SUMS(4)/SUMS(3)
        CHI1=SUMS(5)/(SUMS(6)-1.)
        WRITE (LPT,2021) NINT(SUMS(6)),CHI1,R2
        WRITE (ITO,2021) NINT(SUMS(6)),CHI1,R2
      ELSE
        WRITE (LPT,2011)
        WRITE (ITO,2011)
      ENDIF
      IF (SUMS(10).GT.1) THEN
        R3=100.*SUMS(8)/SUMS(7)
        CHI2=SUMS(9)/(SUMS(10)-1.)
        WRITE (LPT,2022) NINT(SUMS(10)),CHI2,R3
        WRITE (ITO,2022) NINT(SUMS(10)),CHI2,R3
      ELSE
        WRITE (LPT,2012)
        WRITE (ITO,2012)
      ENDIF
      WRITE (LPT,2023) AMNF2
      WRITE (ITO,2023) AMNF2
 2000 FORMAT (/' The R on Fsqrd based on counting statistics is',
     & 2X,F8.2,'%')
 2021 FORMAT ( /' The chisquared for',I4,' repeated measurements is ',
     & F8.2/' and the associated R on Fsqrd is',15X,F8.2,'%')
 2022 FORMAT (/' The chisquared  for',I4,' equivalent reflections is',
     &F 8.2/' with an associated R on Fsqrd of',16X,F8.2,'%')
 2023 FORMAT (/' The average F squared over all measured reflections',
     & ' is',F10.2)
      STOP
 2011 FORMAT (/' There were no repeated measurements ')
 2012 FORMAT (/' No equivalent reflections were measured')
      END
C
C
C
C
C LEVEL 50      PROGRAM ABSSXD
      PROGRAM ABSSXD
C
C *** ABSSXD new by PJB  C4.21 November 2010 ******
C
C *****************************************************************************
C
C                            A B S S X D
C
C
C *****************************************************************************
C
CC 2D
CH To read  ARRNGE files with SXD format and prepare for LSQ with extinction
C
CD The program will read a file in SXD (DTYP 5) format written by ARRNGE or ARRINC
CD and prepare a file for LSQ in which each reflection may be measured with a
CD different wavelength and so must be treated independntly when an extinction
CD is to be refined.  It will average reflections which have been measured more
CD than once. If  "G" cards are present on the crystal data file, absorption
CD factors will be calculated and applied.  The data are written in a form
CD suitable for input to the CCSL least squares programs (SFLSQ, MAGLSQ etc.)
CD MODE for LSQ = 12.
C
CI The crystal data file must contain:
CI     S cards giving the symmetry
CI     A  C card with the cell dimensions
CI     An I DTYP card describing the type of data (the same as used for
CI           ARRNGE) it is only used to determine whether the measurement
CI           wavelengths were stored by ARRNGE  so that the data are
CI           appropriate for ABSSXD
CI    D cards describing the diffraction geometry, the  UB matrix
CI          may be on the arranged data file.
CI    G cards describing the crystal shape. These are optional and if absent no
CI          absorption corrections will be made and a constant path
CI          length of 2mm will be assumed.
CI    If the data are for a magnetic structure with non-integer indices
CI    a Q PROP card giving the propagation vector is required.
CI Basically the same crystal data as that used with ARRNGE to produce the
CI input file should be used but with the addition of D and G cards.  The
CI data input is a file written by one of the ARRNGE type programs.
C
CO The usual listing file reporting data read from the CDF.  A file of
CO averaged and (possibly absorption corrected) data suitable for input to
CO one of the least squares programs L MODE 12. This file has default extension
CO .sf.
CR On running the program the user is asked for the name of the crystal data,
CR that of the arranged data. T
C
      DIMENSION LUN(2),WRK2(5),H(3)
      LOGICAL ONCARD,DOABS,MULP,FIRST
      CHARACTER*120 HEDING
      CHARACTER*40 FILNAM,FILNOM*10,EXTN*4
/ABSDAT/
/DGEOM/
/CARDRC/
/IOUNIT/
/REFS/
/SCRACH/
      DATA HEDING/'(4X,''h'',4X,''k'',4X,''l'',5X,''Fobs'',5X,''DFobs'',
     &4X,''Lambda      Path  Transmission'')'/
      DATA FIRST/.TRUE./
      INC = 0
      DUMMY=0.
      SCALE(1)=1.
      EXTN='.SF'
C SET A DUMMY WAVELENGTH
      WLGTH=1.0
C
      CALL PREFIN('ABSSXD')
      CALL SYMOP
      CALL RECIP
      CALL INPUTI
      CALL ICDFMT(INC,ITEMS)
      CALL MULIND(MULP)
      IF (MULP) INC=1
      IF (INC.NE.0) THEN
        HEDING(2:2)='6'
        HEDING(9:9)='7'
        HEDING(16:16)='7'
        HEDING(23:23)='7'
      ELSE
        IBUFF=35
      ENDIF
      IF (.NOT. ONCARD('I','DTYP',DTYP)) CALL ERRMES(3,1,
     & 'I DTYP giving data type for ARRNGE')
C CHECK CORRECT DATA TYPE   SXD
       IF (NINT(DTYP).NE.5) CALL ERRIN2(NINT(DTYP),0,
     &'Data arrangrd with DTYP ',
     &'is not appropriate for ABSSXD must be DTYP 5')
      LH=2
  109 CALL ASK(' Give input file name ')
      CALL RDWORD(FILNAM,LEN,1,IE,41,-1,IER)
      IF (IER.EQ.0) GO TO 11
      IF (IER.EQ.100) GO TO 100
      CALL ERRMES(1,-1,' Illegal file name')
      GO TO 109
   11 MESSAG=FILNAM
      NAMFIL='.ARR'
      L = LENGT(NAMFIL)
      LUN(1)=NOPFIL(131)
      IF (LUN(1).LE.0) GO TO 109
      LUNI=LUN(1)
C Call to ARRHED to read header
      CALL ARRHED
      IF (FIRST) THEN
        DOABS= (ICDNO(7).NE.0)
        IF (DOABS) THEN
          CALL SETABS
C FORCE ABSORPTION + PATH LENGTH INTEGRALS
          MODEA=5
        ELSE
          CALL SETDC
        ENDIF
        CALL ERRMES(0,0,'to ABSSXD')
        FIRST=.FALSE.
      ENDIF
C
C OPEN output file
      FILNAM=FILNOM(LUN(1))
      L=LENG(FILNAM,10)
      MESSAG=FILNAM(1:L-4)
      NAMFIL=EXTN
      LOUT=NOPFIL(122)
C4.12 Write header on structure factor output
      CALL HDROUT(LOUT,1,MODEH)
C
      WRITE (LPT,117) (FILNAM(I:I),I=1,L)
  117 FORMAT ('Data  read from ',80A1)
      IF (.NOT. DOABS) HEDING(64:)=''')'
C      WRITE (ITO,2030)HEDING
C 2030 format(A120)
      WRITE (LPT,HEDING)
      LINO=3
C
    1 IEND= INPUAR(1,LUN)
      IF (IEND.NE.0) GO TO 6
      IS=1
      IR=1
      II=0
    2 L=LL(IR,IS)
      CALL GMEQ(R(II+1,IS),H,3,1)
      IF (L.EQ.3) GO TO 1
      IE=II+L
      IB=II+4
      WLGTH=0.
      DO 4 I=IB,IE,ITEMS
C      write (ito,111) (r(jt,1),jt=I,i+items-1)
C  111 format (12f10.4)
      IF ((WRK2(4).NE.0) .AND. (ABS(WLGTH-R(I+2,IS)).GT.0.01))
     &CALL DATOUT(H,WRK2,DOABS,INC,LOUT)
      WLGTH=R(I+2,IS)
      CALL WTMEAN(R(I,IS),R(I+1,IS),2,WRK2)
    4 CONTINUE
      IJ=II
      II=II+L
      IFUN=-1
      IF (WRK2(4).NE.0) CALL DATOUT(H,WRK2,DOABS,INC,LOUT)
C  SKIP SPACE FOR MEANS
      II=II+2
      IR=IR+1
      GO TO 2

    6 CALL CLOFIL(LUN(1))
      CALL CLOFIL(LOUT)
C
  100 STOP
      END
C
C
C
C
      SUBROUTINE DATOUT(H,WRK,DOABS,INC,LOUT)
C
CC 2D
CH Data output for  ABSSXD to prepare for LSQ with extinction

      DIMENSION H(3),WRK(5),ABSC(3),K(3)
      LOGICAL DOABS
      CHARACTER *10 TFAC
/DGEOM/
/IOUNIT/
C
      T=2.0
      TFAC='      '
      CALL WTMEAN(F,DF,-1,WRK)
      IF (DOABS) THEN
        CALL ABMULT(H,ABSC)
        F=F/ABSC(1)
        DF=DF/ABSC(1)
        T=ABSC(3)
        WRITE (TFAC,152) 1./ABSC(1)
  152   FORMAT(F10.4)
      ENDIF
      IF (F.GT.0.) THEN
        SF=SQRT(F)
        DF=SQRT(F+ABS(DF)) -SF
      ELSE
        DF = SQRT(ABS(DF))
        F = 0.
      ENDIF
      CALL WTMEAN(F,DF,0,WRK)
      IF (ISNAN(SF)) GO TO 100
      IF (INC .EQ. 0) THEN
        CALL INDFIX(H,K)
        WRITE (LPT,150) K,SF,DF,WLGTH,T,TFAC
        WRITE (LOUT,150) K,SF,DF,WLGTH,T
  150   FORMAT (3I5,2F10.3,2F10.4,A10)
      ELSE
        WRITE (LPT,151) H,SF,DF,WLGTH,T,TFAC
        WRITE (LOUT,151) H,SF,DF,WLGTH,T
  151   FORMAT (3F8.3,2F10.3,2F10.4,A10)
      ENDIF
  100 RETURN
      END

C
C
C
C
C LEVEL 50      PROGRAM ADDFC
      PROGRAM ADDFC
C
C *** ADDFC documented by PJB 18-Nov-1997 ***
C
C *****************************************************************************
C
C                          A D D F C
C
C
C  Program to read observed  hkl and structure factors and to add in
C  calculated structure factors so that o/p file can be used for Fouriers.
C
C *****************************************************************************
C
CC 4D
CH Adds calculated structure factors to a list of hkl and observed F's
C
CD Calculates the structure factors of reflections whose indices are
CD contained in a list. The list is also supposed to contain the observed
CD structure factor and its standard deviation. The calculated structure
CD factor will be multiplied by a scale factor read from an L SCAL card
CD if one is present. The results are recorded on a file suitable for
CD input to other programs such as the Fourier plotting plogram FOURPL.
C
CI The crystal data file must contain all cards required for structure
CI factor calculations viz:
CI       S cards giving the symmetry
CI       A C card with the cell dimensions
CI       A cards defining the atoms, their positions and isotropic
CI       temperature factors
CI       F cards giving the scattering factors
CI optionally:
CI      T cards giving anisotropic temperature factors
CI      An L SCAL card giving a scale factor by whuich Fcalc will be
CI      multiplied.
CI
CI A data file, default extension ".sf", containing a list of h,k,l, Fobs,
CI esd(Fobs) in format (3I5,2F10.4)
C
CO The usual listing file reporting data read from the CDF.
CO An output file containing the same list of reflections as the input
CO file but with an extra column (columns of A and B if
CO non-centrosymmetric) containing the (scaled) calculated
CO structure factor between the hkl, and the Fobs value. The file has
CO format (3I5,5F10.4) and is suitable for input to least squares
CO programs MODE 4 (centrosymmetric only), or fourier calculations DTYP 1 if
CO centrosymmetric DTYP 3 if non-centrosymmetric.
C
CR On running the program the user is asked for the name of the
CR crystal data file, the reflection data file (.sf) and is then
CR asked to choose the name for the output file (.sf).
C
      DIMENSION K(3),H(3)
      COMPLEX FCALC,FC
      LOGICAL ONCARD,SCALIT
/NSYM/
/SCRACH/
C
      CALL PREFIN('ADDFC')
      CALL SETFC
      NAMFIL='.SF'
      LUN=NOPFIL(101)
      NAMFIL='.SF'
      LUNO=NOPFIL(102)
      SCALIT=ONCARD('L','SCAL',SCALE)
    1 READ (LUN,10,END=100) K,FO,SIGFO
   10 FORMAT (3I5,2F10.4)
      CALL INDFLO(H,K)
      FC=FCALC(H)
      IF (SCALIT) FC=FC*SCALE
      A=REAL(FC)
      B=AIMAG(FC)
      IF (CENTRC) THEN
        WRITE(LUNO,11) K,A,FO,SIGFO
      ELSE
        WRITE(LUNO,11) K,A,B,FO,SIGFO
      ENDIF
   11 FORMAT(3I5,4F10.3)
      GO TO 1
  100 STOP
      END
C
C
C
C
C LEVEL 50      PROGRAM ARANTI
      PROGRAM ARANTI
C
C *** ARANTI updated by PJB Aug 92 ***
C
C*********************************************************************
C
C                             A R A N T I
C
C  MAIN PROGRAM TO ARRANGE DATA ITEMS ACCORDING TO THEIR INDICES H,K,L
C  AND OTHER CONSIDERATIONS.
C
C MADE INITIALLY VERSION, AND USING IN-STORE SORT.
C
C**************************************************************************
C
      LOGICAL USE,IEND
      DIMENSION H(3),K(3),FBUF(6),KR(4),HR(3),W1(5),W2(5),LIST(24)
/ARRDAT/
/IOUNIT/
/NSYM/
/SCRACH/
/WHEN/
C
      CALL PREFIN('ARANTI')
      CALL SYMOP
      CALL OPSYM(2)
      CALL SYMUNI
      CALL TROPS(LIST,NTRAN)
C
C INPUT I CARD AND SET UP:
      CALL INPUTI
      CALL IICD3
      INC=.FALSE.
      CALL ARPRIN(H,FBUF,0)
      CALL ERRMES(0,0,'for ARRNGE')
C
C SET UP FUTURE USE OF NPACK TO HAVE H,K,L IN RANGE -150 TO +150 AND
C THE OPERATOR NUMBER TO BE BETWEEN -NOPC AND +NOPC.  4 ITEMS TO BE PACKED.
      KR(1)=-150
      KR(2)=-150
      KR(3)=-150
      KR(4)=NTRAN
      KR(5)=-NOPC
      KEYS=5
      CALL AINOUT(KR,FBUF,KEYS,NUMVAL,0)
C
C  SET UP WEIGHTING SCHEME
      IFUN1=2
      IFUN2=1
      IF (IFOR(4).EQ.1) IFUN2=2
      IF (IFOR(4).EQ.2) IFUN1=1
C
      IEND=.TRUE.
C
C IF REJECTIONS TO BE READ SET THINGS UP
      USE=.TRUE.
      IF (IFOR(5).EQ.1) CALL REJECT(N,NEXT,LREJ,USE)
C
C START READING REFLECTIONS
   1  CALL ARREAD(H,FBUF,IEND)
      IF (IEND) GO TO 3
      N=NINT(FBUF(1))
C
C TEST FOR REJECTIONS IF REQUESTED IN I CARD:
      IF (IFOR(5).EQ.1) CALL REJECT(N,NEXT,LREJ,USE)
      IF (USE) GO TO 2
      CALL ARPRIN(H,FBUF,1)
      GO TO 1
C
C ACCEPTED:
    2  CALL INDFIX(H,K)
      CALL ASUNIT(H,HR,IN,M)
C SETS IN=WHICH SYMMETRY OPERATOR PUTS THIS HKL INTO ASYMMETRIC UNIT
C "IN" MAY BE NEGATIVE FOR A FRIEDEL RELATED HKL
C
C THE INDICES OF THE REFLECTION IN THE ASYMMETRIC UNIT INTO WHICH THIS ONE
C TRANSFORMS ARE PUT INTO HR, THEN AS INTEGERS TO KR
C - IN THIS WAY THE ARRAY KR BUILDS UP A
C SORT ITEM IN WHICH THE SYMMETRY OPERATOR NUMBER WILL CHANGE MOST FREQUENTLY,
C H WILL CHANGE NEXT MOST FREQUENTLY, K NEXT, AND L LEAST.
C
      IF (IN .EQ. 0) THEN
        WRITE (ICARD,3000) K
3000    FORMAT (3I4)
        CALL ERRMES(1,0,
     &  ICARD(1:12)//' will not transform into asymmetric unit')
      ENDIF
C
C KEEP FRIEDEL RELATED PAIRS SEPARATE:
      KR(5)=IN
      KR(4)=LIST(IABS(IN))
C SWAP INDICES TO SORT SO THAT L CHANGES LEAST FREQUENTLY
      KR(1)=JFIX(HR(3))
      KR(2)=JFIX(HR(2))
      KR(3)=JFIX(HR(1))
C
C SEND WHOLE ITEM TO BE INCLUDED IN A SORT PROCESS:
      CALL AINOUT(KR,FBUF,KEYS,ITEMS,1)
      GO TO 1
C
    3 CALL AINOUT(K,FBUF,NREFS,N1,2)
      IF (NREFS.EQ.0) CALL ERRMES(1,0,'No data after ARRNGE sort')
C
      MESSAG='file for sorted reflections'
      NAMFIL='.ARR'
      LUNI=NOPFIL(112)
      CALL MESS(LPT,1,'Sorted reflections recorded to '//NAMFIL)
C
      CALL CENTRE(LPT,100,
     & '***** Sorted and averaged observations *****',120)
      CALL NEWLIN(LPT)
C WRITE STANDARD PAGE HEADING, AND SET UP TESTP:
      CALL ARPRIN(H,FBUF,2)
C
C HERE FOR NEW GROUP (ALL REFLNS RELATED BY SYMMETRY TO THIS ONE)
      CALL WTMEAN(X,DX,0,W1)
C
C HERE FOR NEW SUBGROUP (ALL ATTEMPTS TO MEASURE EXACTLY SAME REFLN)
C INITIALISE STATISTICS COUNTS
    5 CALL WTMEAN(X,DX,0,W2)
      IBUF=0
      JPOS=1
      CALL AINOUT(KR,FBUF,NR,ICHNGE,3)
      HR(1)=FLOAT(KR(3))
      HR(2)=FLOAT(KR(2))
      HR(3)=FLOAT(KR(1))
      IOP=IABS(KR(5))
      CALL ROTSYM(HR,H,IOP,-1)
      NREF=NR
C
C  PRINT OUT DATA FOR INDIVIDUAL REFLECTIONS
      CALL ARPRIN(H,FBUF,3)
    6 CALL WTMEAN(FBUF(2),FBUF(3),IFUN2,W2)
C  FILL IN BUFFER FOR WRITING ONE LINE TO FILE
      CALL ARPRIN(H,FBUF,4)
      IF (NR.GT.1) THEN
        CALL AINOUT(KR,FBUF,NR,JJ,4)
        CALL ARPRIN(H,FBUF,5)
        GO TO 6
      ENDIF
C
C END OF SUBGROUP
      CALL WTMEAN(FBUF(2),FBUF(3),-1,W2)
      CALL ARPRIN(H,FBUF,6)
      CALL WTMEAN(FBUF(2),FBUF(3),IFUN1,W1)
      IF (ICHNGE.EQ.4) GO TO 5
C
C END OF GROUP
      CALL WTMEAN(FBUF(2),FBUF(3),-1,W1)
      CALL ARPRIN(HR,FBUF,7)
      IF (ICHNGE.NE.0) GO TO 4
      STOP
      END
C
C
C
C
      SUBROUTINE TROPS(LIST,MMAX)
C
C *** TROPS for ARANTI by PJB Aug 86 ***
C
      DIMENSION LIST(24),TVEC(3,24),NOPS(24)
/NSYM/
/SYMDA/
C
C INITIALISE
      CALL JGMZER(NOPS(2),1,23)
      CALL GMZER(TVEC,3,24)
      N=1
      DO 1 I=2,NOPC
      CALL EQPOS(TVEC,TRANS(1,I),N,M,24)
      IF (M.GT.N) N=M
      LIST(I)=M
    1 CONTINUE
      MMAX=N
C
      RETURN
      END
C
C
C
C
C LEVEL 50      PROGRAM ARISNP
      PROGRAM ARISNP
C
C    *** ARISNP corrected by PJB C4.9 May 2008 ***
C
C*********************************************************************
C
C                             A R I S N P
C
C  MAIN PROGRAM TO ARRANGE DATA ITEMS ACCORDING TO THEIR INDICES H,K,L
C  AND OTHER CONSIDERATIONS. THIS VERSION IS FOR MODULATED STRUCTURES
C  AND SNP DATA.
C
C**************************************************************************
C
CC 2D
CH To group together equivalent elements of polarisation matrices for structures
CH with non-zero propagation vectors.
C
CD Arranges elements of polarisation matrices according to their matrix indices,
CD their reflection indices and the symmetry given by the crystal data. Averages
CD of repeated measurements of the same matrix element for the same reflection,
CD and of groups of equivalent such items are made.
CD Equivalent reflections belonging to different configuration domains
CD are grouped adjacently but not averaged together.
C
CI The crystal data file must contain:
CI     Symmetry information on S cards
CI     A Q PROP card giving the propagation vector
CI     I cards which select the different options. The words on I cards
CI     which are recognised are: DTYP,MULP,PRIN,REJ,RNUM,WGHT
CI     DTYP is mandatory and the number which follows indicates the format
CI          of the data to be arranged only 11 or 12 for SNP data
CI          DTYP = 11 IGOR type data (rhistory crpd) ext .pol
CI          DTYP = 12 MAD data from logfiles (rlogfile crpd) ext .pol
CI     REJ  if given and followed by the value 1 a list of reflections to
CI          be rejected is expected.
CI     RNUM if given and followed by the value 1 the record numbers will
CI          be stored with the reflections in the output file as well as
CI          in the listing file.
CI     WGHT The number which follows selects the weighting scheme
CI           = 0 (default) Unit weights for individual measurements, and
CI               the mean of equivalents weighted according to their esd's.
CI           = 1 Statisitical weights used for individual measurements, and
CI               esd's used for weighting for mean of equivalents.
CI           = 2 Unit weights used throughout.
CI
CI A data file of the type indicated by DTYP above.
CI
CI If REJ=1 a file containing the record numbers of reflections
CI to be rejected. The numbers must be in increasing order except that a
CI negative number means reject all reflections with record numbers between the
CI previous positive number given and that whose record number is the absolute
CI value just read (inclusive). The default extension for this file-name
CI is .rej
CO A listing file: arisnp.lis which reports how the crystal data file was
CO interpreted and lists the data which have been arranged. In this output all
CO reflections equivalent to one another are grouped together and
CO averaged. Within the groups, multiple measurements of the same reflection
CO are placed together. The overall ordering of reflections with non-integer
CO indices is with respect to the fundamental from which they are derived
CO and these are arranged with h changing most rapidly, k next and \$\ell\$
CO most slowly. Reflections derived from the same fundamental are ordered
CO according to the label given to their propagation vector in the "star".
CO
CO A file with extension .arr destined to be read by further processing
CO programs contains all the data arranged as above but with no
CO averaging. These data can subsequently be read by subroutine INPUAR or
CO equivalent code. One call to INPUAR fills in the COMMON /REFS/ with all
CO the data for one group of equivalent reflections as below
CO    COMMON /REFS/K(3,2),JJ(48,2),LL(48,2),R(500,2),SCALE(2),INC,II,
CO   &FF(3,2),ITEMS
CO The final index IS in the vectors in REFS is to enable data to be read
CO from more than one  source, for merging etc. LL(I,IS) contains the number
CO of entries in R for the Ith reflection in the group. The entries in R for
CO each reflection are:
CO      II+1 to II+3 :   its indices hkl
CO      II+4 to II+LL :  groups of "value" "esd"
CO                    or groups of "record number" "value" "esd" if RNUM 1
CO                    was given. The groups also contain a number in the
CD                    range -9 to 9 indicating which component in the
CD                    polarisation matrix it is.
CO      ITEMS will be set to the number of items stored per reflection.
CO II starts at 1 for the first reflection in the group and should be
CO incremented by LL(I,IS)+2 after obtaining each subgroup I of data (the
CO extra two slots provide space in which to store the means of repeated
CO measurements). If LL(J+1,IS)=3 the Jth reflection is the last in the
CO group and the next three entries in R are the indices hkl with which to
CO label the group of equivalents. See subroutine STATIS for an example of
CO using the data stored in REFS.
CO
CR On running the program the user is asked for the name of the crystal data
CR file, then if REJ=1; for the file containing the rejection list.
CR The names of one or more data files of the type specified by DTYP
CR are then given interactively. After the last file has been read the
CR program reports the number of records sorted,
CR and asks for a name to give to the output file of sorted data.
C
CN A key with which to sort reflections with non-integral indices is obtained
CN in the following steps:
CN  1. The domain ID to which the reflection belongs is determined by adding
CN     and subtracting the vectors of the star to find the fundamental.
CN  2. The operator N which takes the original set of indices into the
CN     asymmetric unit of the full group is found.
CN  3. The domain S to which this transformed reflection belongs is determined
CN     together with the indices h k l of the coresponding fundamental.
CN The reflections are then sorted on the integer keys IS,l,k,h,S,N,ID in that
CN order. IS is 0 for fundamental reflections and 1 for satellite reflections so
CN that these groups are sorted separately. An integer is included in the output
CN file with each recorded set of indices  indicating to which domain the
CN reflection belongs, and the most significant sort key that changed from
CN the previous reflection.
CN or superstructure reflections measured in several configuration domains.
CN AVERPA reads and processes .arr files containing SNP data
C
      PARAMETER (KEYS=8)
      LOGICAL USE,IEND,FIRST,IMPROP
      DIMENSION H(3),HF(3),K(3),KR(KEYS),HR(3),W1(5),W2(5),W3(5),W4(5),
     &HI(3), HJ(3),FBUF(10),KSOP(24),KOLD(KEYS)
/ARRDAT/
/FRIED/
/IOUNIT/
/NSYM/
/SATELL/
/SCRACH/
/SYMTAB/
C
      CALL PREFIN('ARISNP')
      CALL SYMOP
      CALL OPSYM(2)
      FRIEDL=.TRUE.
      CALL SYMUNI
C
      CALL INPUTI
      CALL IICD3
      CALL ICDINC
C SET UP A TABLE GIVING ONE OPERATOR WHICH GENERATES EACH DOMAIN
      KSOP(1)=1
      I=2
      DO 71 J=2,NOPC
      IF (KSTAB(J).NE.I) GO TO 71
      KSOP(I)=J
      I=I+1
      IF (I.GT.NKC) GO TO 70
   71 CONTINUE
C
   70 CALL ARPRIN(H,FBUF,0)
      ITEMS=NUMVAL
      CALL ERRMES(0,0,'for ARISNP')
C
C SET UP AINOUT FOR H,K,L IN RANGE -20 TO +20 AND OPERATORS -NOPC TO +NOPC.
C ITEMS PACKED SO FUNDAMENTALS COME OUT FIRST
C IFOR(7) ITEMS TO BE STORED
      KR(1)=1
      KR(2)=-20
      KR(3)=-20
      KR(4)=-20
      KR(5)=-9
      KR(6)=-NKC
      KR(8)=-NOPC
      KR(7)=NKC
C Extra key for matrix element labels
C      KEYS=8
      CALL AINOUT(KR,KOLD,FBUF,KEYS,NUMVAL,0)
C
C  SET UP WEIGHTING SCHEME
      IFUN1=2
      IFUN2=1
      IF (IFOR(4).EQ.1) IFUN2=2
      IF (IFOR(4).EQ.2) IFUN1=1
C
C SET NREF1 TO KEEP THE FIRST REFLECTION NUMBER OF THE INPUT FILE:
      IEND=.TRUE.
C
C IF REJECTIONS TO BE READ SET THINGS UP
      USE=.TRUE.
      IF (IFOR(5) .NE. 0) CALL REJECT(-1,NEXT,LREJ,USE)
C
C START READING REFLECTIONS
   35 CALL PLREAD(H,FBUF,IEND)
      N=NINT(FBUF(1))
      IF (IEND) GO TO 32
C
C TEST FOR REJECTIONS IF REQUESTED IN I CARD:
      IF (IFOR(5).NE.0) CALL REJECT(N,NEXT,LREJ,USE)
      IF (USE) GO TO 10
      CALL ARPRIN(H,FBUF,1)
      GO TO 35
C
C ACCEPTED:
  10  CALL INCMUL(HF,H,HI,IT)
      IF (IS.EQ.999) THEN
        WRITE (LPT,2040) N,H
 2040   FORMAT (' Therefore record',I6,' with indices',3F8.3,
     &   ' is rejected')
        GO TO 35
      ENDIF
      CALL ASUNIT(HI,HR,IN,M)
C SETS IN=WHICH SYMMETRY OPERATOR PUTS THE HKL INTO ASYMMETRIC UNIT
C "IN" MAY BE NEGATIVE FOR A FRIEDEL RELATED HKL
C
C THE INDICES OF THE REFLECTION IN THE ASYMMETRIC UNIT INTO WHICH THIS ONE
C TRANSFORMS ARE PUT INTO HR, THEN AS INTEGERS TO KR
C - IN THIS WAY THE ARRAY KR BUILDS UP A
C SORT ITEM IN WHICH THE SYMMETRY OPERATOR NUMBER WILL CHANGE MOST FREQUENTLY,
C H WILL CHANGE NEXT MOST FREQUENTLY, K NEXT, AND L LEAST.
C
      IF (IN .EQ. 0) THEN
        WRITE (LPT,3000) HI
        WRITE (ITO,3000) HI
3000    FORMAT (/' ERROR ***',3F5.3,' Will not transform into given',
     &   ' asymmetric unit')
        STOP
      ENDIF
C
C FIND THE CORRESPONDING FUNDAMENTAL
      CALL INCFUN(H,K,HR,IJ)
C
C4.9 The sense of the Y axis changes for improper rotations
      IMPROP=(IN*NORD(IABS(IN)).LT.0)
      IF (IMPROP) THEN
        IP=NINT(ABS(FBUF(4)))
        IF (IP.GE.4 .AND. IP.LE.6) FBUF(4)=-FBUF(4)
        IF ( IP.EQ.2 .OR. IP.EQ.5. OR. IP.EQ.8) FBUF(2)=-FBUF(2)
      ENDIF
C SET KR(1) TO INDICATE WHETHER FUNDAMENTAL OR NOT
      KR(1)=IT
      IF (IT.NE.0) KR(1)=1
C SWAP INDICES TO SORT SO L CHANGES LEAST FREQUENTLY
      KR(2)=K(3)
      KR(3)=K(2)
      KR(4)=K(1)
      KR(5)=NINT(FBUF(4))
      KR(6)=IJ
      KR(8)=IN
      KR(7)=IABS(IT)
C SEND WHOLE ITEM TO BE INCLUDED IN A SORT PROCESS:
      CALL AINOUT(KR,KOLD,FBUF,KEYS,ITEMS,1)
C      write (lpt,3300) KR,(fbuf(i),i=1,4)
      GO TO 35
C
   32 CALL AINOUT(K,KOLD,FBUF,NREFS,N1,2)
      IF (NREFS.EQ.0) CALL ERRMES(1,0,'No data after ARISNP sort')
C
      MESSAG='file for sorted reflections'
      NAMFIL='.ARR'
      LUNI=NOPFIL(142)
      CALL MESS(LPT,1,'Sorted reflections recorded to '//NAMFIL)
C
      FIRST=.TRUE.
      ISOLD=0
C
C TO CALCULATE THE AVERAGE OVER DIFFERENT ELEMENTS OF THE POLN MATRIX
    5 CALL WTMEAN(X,DX,0,W4)
C TO CALCULATE THE AVERAGE OVER CONFIGURATION DOMAINS
    4 CALL WTMEAN(X,DX,0,W3)
C HERE FOR NEW GROUP (ALL REFLNS RELATED BY SYMMETRY TO THIS ONE)
    1 CALL WTMEAN(X,DX,0,W1)
C HERE FOR NEW SUBGROUP (ALL ATTEMPTS TO MEASURE EXACTLY SAME REFLN)
    2 CALL WTMEAN(X,DX,0,W2)
      IBUF=0
      JPOS=1
      CALL AINOUT(KR,KOLD,FBUF,NR,ICHNGE,3)
      H(1)=FLOAT(KR(4))
      H(2)=FLOAT(KR(3))
      H(3)=FLOAT(KR(2))
      IT=KR(6)
      ID=KR(7)
      IS=KR(1)
      NREF=NR
      IF (FIRST) THEN
        IF (IS.EQ.0) THEN
          CALL CENTRE(LPT,100,
     & '***** Sorted and averaged observations of fundamental '//
     & 'reflections *****',120)
       ELSE
         CALL CENTRE(LPT,100,
     &  '***** Sorted and averaged observations of satellite '//
     &  'reflections *****',120)
        ENDIF
        CALL NEWLIN(LPT)
C WRITE STANDARD PAGE HEADING, AND SET UP TESTP (H AND FBUF NOT USED)
        CALL ARPRIN(H,FBUF,2)
        FIRST=.FALSE.
      ENDIF
C
C  GET INCOMMENSURATE INDEX
      CALL INCIND(H,K,HR,IT)
C AND TRANSFORM IT BACK TO WHERE IT CAME FROM
      INVOP=INVERS(IABS(KR(8)))
      improp=(kr(8)*nord(IABS(KR(8))).lt.0)
      CALL ROTSYM(HR,HI,INVOP,2)
      IF (KR(8).LT.0) CALL GMREV(HI,HI,3,1)
C Procedure for imroper rotations
C yx,yz -> -yx,-yz  yy -> -(-yy)
C
C      write (lpt,3300) Hi,ICHNGE,(fbuf(i),i=1,4)
C
C PRINTOUT DATA FOR INDIVIDUAL MEASUREMENTS
      CALL ARPRIN(HI,FBUF,3)
C
    3 CALL WTMEAN(FBUF(2),FBUF(3),IFUN2,W2)
C FILL IN A BUFFER FOR WRITING ONE LINE TO FILE
      CALL ARPRIN(HI,FBUF,4)
      IF (NR.GT.1) THEN
        CALL AINOUT(KR,KOLD,FBUF,NR,JJ,4)
        CALL ARPRIN(HI,FBUF,5)
        GO TO 3
      ENDIF
C
C END OF SUBGROUP
      CALL WTMEAN(FBUF(2),FBUF(3),-1,W2)
      CALL ARPRIN(HR,FBUF,6)
      CALL WTMEAN(FBUF(2),FBUF(3),IFUN1,W1)
      IF (ICHNGE.EQ.8) GO TO 2
C
C END OF GROUP
C GET LABELLING INDEX
      IF (IS.NE.0) THEN
      if (id.eq.0) then
        write (lpt,3300) Hi,ICHNGE,(fbuf(i),i=1,4),kr
        write (ito,3300) Hi,ICHNGE,(fbuf(i),i=1,4),kr
 3300 format ('ID=0 ',3f8.3,i4,3f8.3,f8.0,3i4)
        stop
      endif
        IOP=MULTAB(KSOP(ID),INVERS(KSOP(IABS(IT))))
        CALL ROTSYM(HR,HI,IOP,2)
C         IOP=INVERS(KSOP(IABS(IT)))
C         CALL ROTSYM(HR,HI,IOP,2)
      ELSE
        CALL GMEQ(H,HI,3,1)
      ENDIF
      IS=ID
      CALL WTMEAN(FBUF(2),FBUF(3),-1,W1)
      IF (IS.NE.0) CALL WTMEAN(FBUF(2),FBUF(3),2,W3)
      CALL ARPRIN(HI,FBUF,7)
      IF (ICHNGE.GT.6) GO TO 1
      IF (IS.NE.0 .AND. NKC .gt.1) THEN
        CALL WTMEAN(FBUF(2),FBUF(3),-1,W3)
        CALL ROTSYM(HR,HJ,INVERS(KSOP(IABS(IT))),2)
        CALL ARPRIN(HJ,FBUF,8)
      ENDIF
      IF (ICHNGE.EQ.1) THEN
        CALL CENTRE(LPT,100,
     &  '***** Sorted and averaged observations of satellite '//
     &  'reflections *****',120)
        CALL NEWLIN(LPT)
C NEW PAGE NEW HEADING, AND RESET TESTP (H AND FBUF NOT USED)
        CALL ARPRIN(H,FBUF,2)
      ENDIF
      IF (ICHNGE.EQ.5) GO TO 4
      IF (ICHNGE.GT.0) GO TO 5
      STOP
      END
C
C
C
C
C LEVEL 50      PROGRAM ARRINC
      PROGRAM ARRINC
C
C    *** ARRINC updated by PJB C4.3 October 2007 ***
C
C Number of sort keys is now PARAMETER KEYS.
C
C*********************************************************************
C
C                             A R R I N C
C
C  MAIN PROGRAM TO ARRANGE DATA ITEMS ACCORDING TO THEIR INDICES H,K,L
C  AND OTHER CONSIDERATIONS. THIS VERSION IS FOR MODULATED STRUCTURES.
C
C**************************************************************************
C
CC 2D
CH To group together equivalent reflections for structures with non-zero
CH propagation vectors
C
CD Arranges data items according to their indices and the symmetry given
CD by the crystal data. Averages of repeated measurements of the same
CD reflection, and of groups of equivalent reflections are made.
CD Equivalent reflections belonging to different configuration domains
CD are grouped adjacently but not averaged together.
C
CI The crystal data file must contain:
CI     Symmetry information on S cards
CI     A Q PROP card giving the propagation vector
CI     I cards which select the different options. The words on I cards
CI     which are recognised are: DTYP,MULP,PRIN,REJ,RNUM,WGHT
CI     DTYP is mandatory and the number which follows indicates the format
CI     of the data to be arranged
CI         = 0 user supplied subroutine QARRIN to read the data
CI         = 1 D3 polarised neutron ratios  (default extn .fli)
CI         = 2 COLL5  1 card output
CI         = 3 COLL5  2 card output
CI         = 4 ADVANCE floating format output (default extn .col)
CI         = 5 SXD output from SXDABS store lambda and pathlength
CI         = 6 LLB format, floating indices (default extn .psi)
CI         = 7 D3 integrated intensities 2 card output (default extn .roc)
CI         = 8 COLL5 floating format (ext .fsq)
CI         = 9 D3 floating format (ext .fli)
CI     ANGL if given and >= 1 read and store three diffractometer angles
CI     MULP is followed by the number by which all indices have been
CI          multiplied in COLL5. MULP should not be given unless the
CI          multiplication option in COLL5 has been used.
CI     PRIN if given and followed by a negative number unique reflections
CI          are not listed on the printed output. Otherwise all reflections
CI          are printed.
CI     REJ  if given and followed by the value 1 a list of reflections to
CI          be rejected is expected.
CI     RNUM if given and followed by the value 1 the record numbers will
CI          be stored with the reflections in the output file as well as
CI          in the listing file.
CI     WGHT The number which follows selects the weighting scheme
CI           = 0 (default) Unit weights for individual measurements, and
CI               the mean of equivalents weighted according to their esd's.
CI           = 1 Statisitical weights used for individual measurements, and
CI               esd's used for weighting for mean of equivalents.
CI           = 2 Unit weights used throughout.
CI
CI A data file of the type indicated by DTYP above. Its default extension
CI is .fli for DTYP 1, .col for DTYP 4, .sxd for DTYP 5, .psi for DTYP 6
CI .roc for DTYP 7, .fsq for DTYP 8 otherwise .dat.
CI
CI If REJ=1 a file containing the record numbers of reflections
CI to be rejected. The numbers must be in increasing order except that a
CI negative number means reject all reflections with record numbers between the
CI previous positive number given and that whose record number is the absolute
CI value just read (inclusive). The default extension for this file-name
CI is .rej
CO A listing file: arrinc.lis which reports how the crystal data file was
CO interpreted and lists the data which have been arranged. In this output all
CO reflections equivalent to one another are grouped together and
CO averaged. Within the groups, multiple measurements of the same reflection
CO are placed together. The overall ordering of reflections with non-integer
CO indices is with respect to the fundamental from which they are derived
CO and these are arranged with h changing most rapidly, k next and \$\ell\$
CO most slowly. Reflections derived from the same fundamental are ordered
CO according to the label given to their propagation vector in the "star".
CO
CO A file with extension .arr destined to be read by further processing
CO programs contains all the data arranged as above but with no
CO averaging. These data can subsequently be read by subroutine INPUAR or
CO equivalent code. One call to INPUAR fills in the COMMON /REFS/ with all
CO the data for one group of equivalent reflections as below
CO    COMMON /REFS/K(3,2),JJ(48,2),LL(48,2),R(500,2),SCALE(2),INC,II,
CO   &FF(3,2),ITEMS
CO The final index IS in the vectors in REFS is to enable data to be read
CO from more than one  source, for merging etc. LL(I,IS) contains the number
CO of entries in R for the Ith reflection in the group. The entries in R for
CO each reflection are:
CO      II+1 to II+3 :   its indices hkl
CO      II+4 to II+LL :  groups of "value" "esd"
CO                    or groups of "record number" "value" "esd" if RNUM 1
CO                    was given. The groups also contain the wavelength
CO                    and pathlength if DTYP=5 and the values of psi
CO                    if DTYP 6.
CO      ITEMS will be set to the number of items stored per reflection.
CO II starts at 1 for the first reflection in the group and should be
CO incremented by LL(I,IS)+2 after obtaining each subgroup I of data (the
CO extra two slots provide space in which to store the means of repeated
CO measurements). If LL(J+1,IS)=3 the Jth reflection is the last in the
CO group and the next three entries in R are the indices hkl with which to
CO label the group of equivalents. See subroutine STATIS for an example of
CO using the data stored in REFS.
CO
CR On running the program the user is asked for the name of the crystal data
CR file, then if REJ=1; for the file containing the rejection list.
CR The names of one or more data files of the type specified by DTYP
CR are then given interactively. After the last file has been read the
CR program reports the number of records sorted,
CR and asks for a name to give to the output file of sorted data.
C
CN A key with which to sort reflections with non-integral indices is obtained
CN in the following steps:
CN  1. The domain ID to which the reflection belongs is determined by adding
CN     and subtracting the vectors of the star to find the fundamental.
CN  2. The operator N which takes the original set of indices into the
CN     asymmetric unit of the full group is found.
CN  3. The domain S to which this transformed reflection belongs is determined
CN     together with the indices h k l of the coresponding fundamental.
CN The reflections are then sorted on the integer keys IS,l,k,h,S,N,ID in that
CN order. IS is 0 for fundamental reflections and 1 for satellite reflections so
CN that these groups are sorted separately. An integer is included in the output
CN file with each recorded set of indices  indicating to which domain the
CN reflection belongs, and the most significant sort key that changed from
CN the previous reflection.
CN SORGAM reads and processes .ARR files containing polarised neutron data
CN ABSMSF reads and processes .ARR files containing  integrated intensities
CN INCMSF reads and processes .ARR files containing intensities of magnetic
CN or superstructure reflections measured in several configuration domains.
CN AVEXAR can process all types of .ARR file, treating equivalent relections
CN as independent
C
C4.3
      PARAMETER (KEYS=7)
      LOGICAL USE,IEND
      DIMENSION H(3),HF(3),K(3),KR(KEYS),HR(3),W1(5),W2(5),W3(5),HI(3),
     & HJ(3),FBUF(10),KSOP(24),KROLD(KEYS)
/ARRDAT/
/FRIED/
/IOUNIT/
/NSYM/
/SATELL/
/SCRACH/
/SYMTAB/
C
      CALL PREFIN('ARRINC')
      CALL SYMOP
      CALL OPSYM(2)
      FRIEDL=.TRUE.
      CALL SYMUNI
C
      CALL INPUTI
      CALL IICD3
      CALL ICDINC
C SET UP A TABLE GIVING ONE OPERATOR WHICH GENERATES EACH DOMAIN
      KSOP(1)=1
      I=2
      DO 71 J=2,NOPC
      IF (KSTAB(J).NE.I) GO TO 71
      KSOP(I)=J
      I=I+1
      IF (I.GT.NKC) GO TO 70
   71 CONTINUE
C
   70 CALL ARPRIN(H,FBUF,0)
      CALL ERRMES(0,0,'for ARRINC')
C
C SET UP AINOUT FOR H,K,L IN RANGE -20 TO +20 AND OPERATORS -NOPC TO +NOPC.
C ITEMS PACKED SO FUNDAMENTALS COME OUT FIRST
C IFOR(7) ITEMS TO BE STORED
      KR(1)=1
      KR(2)=-20
      KR(3)=-20
      KR(4)=-20
      KR(5)=-NKC
      KR(7)=-NOPC
      KR(6)=NKC
C4.3 KROLD added to call to AINOUT
      CALL AINOUT(KR,KROLD,FBUF,KEYS,NUMVAL,0)
C
C  SET UP WEIGHTING SCHEME
      IFUN1=2
      IFUN2=1
      IF (IFOR(4).EQ.1) IFUN2=2
      IF (IFOR(4).EQ.2) IFUN1=1
C
C SET NREF1 TO KEEP THE FIRST REFLECTION NUMBER OF THE INPUT FILE:
      IEND=.TRUE.
C
C IF REJECTIONS TO BE READ SET THINGS UP
      USE=.TRUE.
      IF (IFOR(5) .NE. 0) CALL REJECT(-1,NEXT,LREJ,USE)
C
C START READING REFLECTIONS
   35 CALL ARREAD(H,FBUF,IEND)
      N=NINT(FBUF(1))
      IF (IEND) GO TO 32
C
C TEST FOR REJECTIONS IF REQUESTED IN I CARD:
      IF (IFOR(5).NE.0) CALL REJECT(N,NEXT,LREJ,USE)
      IF (USE) GO TO 10
      CALL ARPRIN(H,FBUF,1)
      GO TO 35
C
C ACCEPTED:
  10  CALL INCMUL(HF,H,HI,IT)
      IF (IS.EQ.999) THEN
        WRITE (LPT,2040) N,H
 2040   FORMAT (' Therefore record',I6,' with indices',3F8.3,
     &   ' is rejected')
        GO TO 35
      ENDIF
      CALL ASUNIT(HI,HR,IN,M)
C SETS IN=WHICH SYMMETRY OPERATOR PUTS THE HKL INTO ASYMMETRIC UNIT
C "IN" MAY BE NEGATIVE FOR A FRIEDEL RELATED HKL
C
C THE INDICES OF THE REFLECTION IN THE ASYMMETRIC UNIT INTO WHICH THIS ONE
C TRANSFORMS ARE PUT INTO HR, THEN AS INTEGERS TO KR
C - IN THIS WAY THE ARRAY KR BUILDS UP A
C SORT ITEM IN WHICH THE SYMMETRY OPERATOR NUMBER WILL CHANGE MOST FREQUENTLY,
C H WILL CHANGE NEXT MOST FREQUENTLY, K NEXT, AND L LEAST.
C
      IF (IN .EQ. 0) THEN
        WRITE (LPT,3000) HI
        WRITE (ITO,3000) HI
3000    FORMAT (/' ERROR ***',3F5.3,' Will not transform into given',
     &   ' asymmetric unit')
        STOP
      ENDIF
C
C FIND THE CORRESPONDING FUNDAMENTAL
      CALL INCFUN(H,K,HR,IJ)
C
C SET KR(1) TO INDICATE WHETHER FUNDAMENTAL OR NOT
      KR(1)=IT
      IF (IT.NE.0) KR(1)=1
C SWAP INDICES TO SORT SO L CHANGES LEAST FREQUENTLY
      KR(2)=K(3)
      KR(3)=K(2)
      KR(4)=K(1)
      KR(5)=IJ
      KR(7)=IN
      KR(6)=IABS(IT)
C SEND WHOLE ITEM TO BE INCLUDED IN A SORT PROCESS:
      CALL AINOUT(KR,KROLD,FBUF,KEYS,ITEMS,1)
      GO TO 35
C
   32 CALL AINOUT(K,KROLD,FBUF,NREFS,N1,2)
      IF (NREFS.EQ.0) CALL ERRMES(1,0,'No data after ARRINC sort')
C
      MESSAG='file for sorted reflections'
      NAMFIL='.ARR'
      LUNI=NOPFIL(142)
      CALL MESS(LPT,1,'Sorted reflections recorded to '//NAMFIL)
C
      CALL CENTRE(LPT,100,
     & '***** Sorted and averaged observations of fundamental '//
     & 'reflections *****',120)
      CALL NEWLIN(LPT)
C WRITE STANDARD PAGE HEADING, AND SET UP TESTP (H AND FBUF NOT USED)
      CALL ARPRIN(H,FBUF,2)
      ISOLD=0
C
C TO CALCULATE THE AVERAGE OVER CONFIGURATION DOMAINS
    4 CALL WTMEAN(X,DX,0,W3)
C HERE FOR NEW GROUP (ALL REFLNS RELATED BY SYMMETRY TO THIS ONE)
    1 CALL WTMEAN(X,DX,0,W1)
C HERE FOR NEW SUBGROUP (ALL ATTEMPTS TO MEASURE EXACTLY SAME REFLN)
    2 CALL WTMEAN(X,DX,0,W2)
      IBUF=0
      JPOS=1
      CALL AINOUT(KR,KROLD,FBUF,NR,ICHNGE,3)
      H(1)=FLOAT(KR(4))
      H(2)=FLOAT(KR(3))
      H(3)=FLOAT(KR(2))
      IT=KR(5)
      ID=KR(6)
      IS=KR(1)
      NREF=NR
C
C  GET INCOMMENSURATE INDEX
      CALL INCIND(H,K,HR,IT)
C AND TRANSFORM IT BACK TO WHERE IT CAME FROM
      INVOP=INVERS(IABS(KR(7)))
      CALL ROTSYM(HR,HI,INVOP,2)
      IF (KR(7).LT.0) CALL GMREV(HI,HI,3,1)
C
C PRINTOUT DATA FOR INDIVIDUAL MEASUREMENTS
      CALL ARPRIN(HI,FBUF,3)
C
    3 CALL WTMEAN(FBUF(2),FBUF(3),IFUN2,W2)
C FILL IN A BUFFER FOR WRITING ONE LINE TO FILE
      CALL ARPRIN(HI,FBUF,4)
      IF (NR.GT.1) THEN
        CALL AINOUT(KR,KROLD,FBUF,NR,JJ,4)
        CALL ARPRIN(HI,FBUF,5)
        GO TO 3
      ENDIF
C
C END OF SUBGROUP
      CALL WTMEAN(FBUF(2),FBUF(3),-1,W2)
      CALL ARPRIN(HR,FBUF,6)
      CALL WTMEAN(FBUF(2),FBUF(3),IFUN1,W1)
      IF (ICHNGE.EQ.7) GO TO 2
C
C END OF GROUP
C GET LABELLING INDEX
      IF (IS.NE.0) THEN
        IOP=MULTAB(KSOP(ID),INVERS(KSOP(IABS(IT))))
        CALL ROTSYM(HR,HI,IOP,2)
C         IOP=INVERS(KSOP(IABS(IT)))
C         CALL ROTSYM(HR,HI,IOP,2)
      ELSE
        CALL GMEQ(H,HI,3,1)
      ENDIF
      IS=ID
      CALL WTMEAN(FBUF(2),FBUF(3),-1,W1)
      IF (IS.NE.0) CALL WTMEAN(FBUF(2),FBUF(3),2,W3)
      CALL ARPRIN(HI,FBUF,7)
      IF (ICHNGE.GT.5) GO TO 1
      IF (IS.NE.0) THEN
        CALL WTMEAN(FBUF(2),FBUF(3),-1,W3)
        CALL ROTSYM(HR,HJ,INVERS(KSOP(IABS(IT))),2)
        CALL ARPRIN(HJ,FBUF,8)
      ENDIF
      IF (ICHNGE.EQ.1) THEN
        CALL CENTRE(LPT,100,
     &  '***** Sorted and averaged observations of satellite '//
     &  'reflections *****',120)
        CALL NEWLIN(LPT)
C NEW PAGE NEW HEADING, AND RESET TESTP (H AND FBUF NOT USED)
        CALL ARPRIN(H,FBUF,2)
      ENDIF
      IF (ICHNGE.GT.0) GO TO 4
      STOP
      END
C
C
C
C
C LEVEL 50      PROGRAM ARRNGE
      PROGRAM ARRNGE
C
C *** ARRNGE updated by PJB C4.3 October 2007 ***
C
C Number of sort keys is now PARAMETER KEYS.
C*********************************************************************
C
C                          A R R N G E
C
C  MAIN PROGRAM TO ARRANGE DATA ITEMS ACCORDING TO THE CRYSTAL SYMMETRY
C  THIS VERSION WILL DEAL WITH INDICES WHICH ARE SUBMULTIPLES OF INTEGERS.
C
C**************************************************************************
CC 2D
CH To group together equivalent reflections and give some statistics on
CH their degree of equivalence, indices may be submultiples of integers.
C
CD Arranges data items according to their indices and the symmetry given
CD by the crystal data. Averages of repeated measurements of the same
CD reflection, and of groups of equivalent reflections are made.
C
CI The crystal data file must contain:
CI     Symmetry information on S cards
CI     I cards which select the different options. The words on I cards
CI     which are recognised are: DTYP,MULH,MULK,MULL,MULP,PRIN,REJ,RNUM,WGHT
CI     DTYP is mandatory and the number which follows indicates the format
CI     of the data to be arranged
CD    DTYP = 0 user supplied subroutine QARRIN to read the data
CD    DTYP = 1 D3 polarised neutron ratios as given by D3OP99
CD             Data read: NUMOR,K,(ANG(I),I=1,3),R,DR
CD             FORMAT (4I5,3F8.2,2F10.6)4I5,24X,2F1.6
CD    DTYP = 2 COLL5  1 card output
CD    DTYP = 3 COLL5  2 card output
CD             Data read for 2 and 3:NUMOR,K,Fsqr,Dfsqr,(ANG(I),I=1,4)
CD             FORMAT (I6,3I4,2F10.2,4F8.2)
CD    DTYP = 4 RACER floating format output
CD             Data read: NUMOR,H,INT,dINT,(ANG(I),I=1,4)
CD             FORMAT (I6,3F6.2,I8,I4,4F8.2)
CD    DTYP = 5 SXD format output including wave-length and path length
CD             Data read: NUMOR,H,Fsqr,DFsqr,Lambda,path
CD             FORMAT (I8,3F8.2,4F10.4)
CD    DTYP = 6 LLB format (floating indices)
CD             Data read: NUMOR,H,Fsqr,Dfsqr,(ANG(I),I=1,4)
CD             FORMAT (I4,3F6.2,2F10.4,4F8.3)
CD    DTYP = 7 D3 Integrated intensities (ext .ROC)
CD             Data read: NUMOR,H,Fsqr,Dfsqr,(ANG(I),I=1,4)
CD             FORMAT (I6,3F6.2,2F10.2,4F8.2)
CD    DTYP = 8 COLL5 floating format (1 card ext .COL)
CD             Data read: NUMOR,H,Fsqr,Dfsqr,(ANG(I),I=1,4)
CD             FORMAT (I6,3F7.3,2F10.4,4F8.2)
CI     All the other words are optional:
CI     ANGL if given and >= 1 read and store three diffractometer angles
CI     Any or all of MULH, MULK and MULL each followed by the number by which
CI         the corresponding index h,k,or \$\ell\$ should be multiplied to
CI         obtain an integer.
CI     MULP is followed by the number by which all indices have been
CI          multiplied in COLL5. If MULP is absent it is assumed that there
CI          was no multiplication.
CI     PRIN if given and followed by a negative number unique reflections
CI          are not listed on the printed output. Otherwise all reflections
CI          are printed.
CI     REJ  if given and followed by the value 1 a list of reflections to
CI          be rejected is expected.
CI     RNUM if given and followed by the value 1 the record numbers will
CI          be stored with the reflections in the output file as well as
CI          in the listing file.
CI     WGHT The number which follows selects the weighting scheme
CI           = 0 (default) Unit weights for individual measurements, and
CI               the mean of equivalents weighted according to their esd's.
CI           = 1 Statisitical weights used for individual measurements, and
CI               esd's used for weighting for mean of equivalents.
CI           = 2 Unit weights used throughout.
CI
CI A data file of the type indicated by DTYP above. Its default extension
CI is .fli for DTYP 1, .col for DTYP 4, .sxd for DTYP 5, .psi for DTYP 6
CI .roc for DTYP 7, .fsq for DTYP 8 otherwise .dat.
CI
CI If REJ=1 a file containing the record numbers of reflections
CI to be rejected. The numbers must be in increasing order except that a
CI negative number means reject all reflections with record numbers between the
CI previous positive number given and that whose record number is the absolute
CI value just read (inclusive). The default extension for this file-name is .rej
CI
CO A listing file: arrnge.lis which reports how the crystal data file was
CO interpreted and lists the data which have been arranged. In this output all
CO reflections equivalent to one another are grouped together and averaged.
CO Within the groups multiple measurements of the same reflection are placed
CO together. These are arranged with h changing most rapidly, k next and l
CO most slowly.
CO The esd's of the means are calculated both from the esd's of the
CO values being averaged, and from the weighted deviations of these
CO values from the mean. The larger of the two values is printed and
CO used for further calculation.
CO Some statistics on the degree of equivalence between supposedly
CO equivalent measurements are also given in the listing file and on the
CO terminal.
CO A file with extension .arr destined to be read by further processing
CO programs contains all the data arranged as above but with no
CO averaging. These data can subsequently be read by function INPUAR or
CO equivalent code. One call to INPUAR fills in the COMMON /REFS/ with all
CO the data for one group of equivalent reflections.
CO (COMMON /REFS/K(3,2),LL(48,2),R(500,2),SCALE(2),INC,II,FF(3,2) )
CO The final index IS in REFS is to enable data to be read from more than one
CO source, for merging etc. LL(I,IS) contains the number of entries in R
CO for the Ith reflection in the group. The entries in R for each
CO reflection are:
CO      II+1 to II+3 :    its indices hkl
CO      II+4 to II+LL:    groups of "value" "esd" ("other data")
CO                     or groups of "record number" "value" "esd" ("other
CO                     data") if RNUM 1 was given.
CO II starts at 1 for the first reflection in the group and should be
CO incremented by LL(I,IS)+2 after obtaining each subgroup I of data (the
CO extra two slots provide space in which to store the means of repeated
CO measurements). If LL(J+1,IS)=3 the Jth reflection is the last in the group
CO and the next three entries in R are the indices hkl with which to label the
CO group of equivalents. See subroutine STATIS for an example of using the
CO data stored in REFS.
C
CR On running the program the user is asked for the name of the crystal data
CR file, then if REJ=1, for the file containing the rejection list.
CR The names of one or more data files of the type specified by DTYP
CR are then given interactively. After the last file has been read the
CR program reports the number of records sorted,
CR and asks for a name for the output file of sorted data.
C
CN SORGAM reads and processes .arr files containing polarised neutron data
CN ABSMSF reads and processes .arr files containing  integrated intensity
CN         measurements, applying absorption corrections if required.
CN AVEXAR reads .arr files calculates extinction parameters and possibly
CN         path-lengths treating equivalent relections independently. It
CN         also applies absorption corrections if required.
C
C4.3
      PARAMETER (KEYS=4)
      LOGICAL USE,IEND,MULP
      DIMENSION H(3),K(3),FBUF(10),KR(KEYS),HR(3),W1(5),W2(5),W3(5),
     &SUMS(12),KROLD(KEYS)
/ARRDAT/
/IOUNIT/
/NSYM/
/SCRACH/
C
      CALL PREFIN('ARRNGE')
      CALL SYMOP
      CALL OPSYM(2)
      CALL SYMUNI
C
C INPUT I CARD AND SET UP:
      CALL INPUTI
      CALL IICD3
      CALL MULIND(MULP)
      INC=MULP
      CALL ARPRIN(H,FBUF,0)
      CALL ERRMES(0,0,'for ARRNGE')
C
C SET UP FUTURE USE OF NPACK TO HAVE H,K,L IN RANGE -150 TO +150 AND
C THE OPERATOR NUMBER TO BE BETWEEN -NOPC AND +NOPC.  4 ITEMS TO BE PACKED.
      KR(1)=-150
      KR(2)=-150
      KR(3)=-150
      KR(4)=-NOPC
C4.3  KROLD added to calls to AINOUT
      CALL AINOUT(KR,KROLD,FBUF,KEYS,NUMVAL,0)
C
C  SET UP WEIGHTING SCHEME
      IFUN1=2
      IFUN2=1
      IF (IFOR(4).EQ.1) IFUN2=2
      IF (IFOR(4).EQ.2) IFUN1=1
C
      IEND=.TRUE.
C
C IF REJECTIONS TO BE READ SET THINGS UP
      USE=.TRUE.
      IF (IFOR(5).EQ.1) CALL REJECT(-1,NEXT,LREJ,USE)
C
C START READING REFLECTIONS
   1  CALL ARREAD(H,FBUF,IEND)
      IF (MULP) CALL INDMUL(H,H)
      IF (IEND) GO TO 3
      N=NINT(FBUF(1))
C
C TEST FOR REJECTIONS IF REQUESTED IN I CARD:
      IF (IFOR(5).EQ.1) CALL REJECT(N,NEXT,LREJ,USE)
      IF (.NOT. USE) THEN
        CALL ARPRIN(H,FBUF,1)
        GO TO 1
      ENDIF
C
C ACCEPTED:
      CALL INDFIX(H,K)
      CALL ASUNIT(H,HR,IN,M)
C SETS IN=WHICH SYMMETRY OPERATOR PUTS THIS HKL INTO ASYMMETRIC UNIT
C "IN" MAY BE NEGATIVE FOR A FRIEDEL RELATED HKL
C
C THE INDICES OF THE REFLECTION IN THE ASYMMETRIC UNIT INTO WHICH THIS ONE
C TRANSFORMS ARE PUT INTO HR, THEN AS INTEGERS TO KR
C - IN THIS WAY THE ARRAY KR BUILDS UP A
C SORT ITEM IN WHICH THE SYMMETRY OPERATOR NUMBER WILL CHANGE MOST FREQUENTLY,
C H WILL CHANGE NEXT MOST FREQUENTLY, K NEXT, AND L LEAST.
C
      IF (IN .EQ. 0) THEN
        WRITE (ICARD,3000) K
3000    FORMAT (3I4)
        CALL ERRMES(1,0,
     &  ICARD(1:12)//' will not transform into asymmetric unit')
      ENDIF
C
C KEEP FRIEDEL RELATED PAIRS SEPARATE:
      KR(4)=IN
C SWAP INDICES TO SORT SO THAT L CHANGES LEAST FREQUENTLY
      KR(1)=JFIX(HR(3))
      KR(2)=JFIX(HR(2))
      KR(3)=JFIX(HR(1))
C
C SEND WHOLE ITEM TO BE INCLUDED IN A SORT PROCESS:
      CALL AINOUT(KR,KROLD,FBUF,KEYS,NUMVAL,1)
      GO TO 1
C
    3 CALL AINOUT(K,KROLD,FBUF,NREFS,N1,2)
      IF (NREFS.EQ.0) CALL ERRMES(1,0,'No data after ARRNGE sort')
C
      MESSAG='file for sorted reflections'
      NAMFIL='.ARR'
      LUNI=NOPFIL(112)
      CALL MESS(LPT,1,'Sorted reflections recorded to '//NAMFIL)
C
      CALL CENTRE(LPT,100,'***** Sorted and averaged '//
     & 'observations *****',120)
      CALL NEWLIN(LPT)
C WRITE STANDARD PAGE HEADING, AND SET UP TESTP:
      CALL ARPRIN(H,FBUF,2)
C
C INITIALISE R-FACTOR SUMS
      CALL GMZER(SUMS,12,1)
C
C HERE FOR NEW GROUP (ALL REFLNS RELATED BY SYMMETRY TO THIS ONE)
C W1 IS THE WORKING SPACE FOR STATISTICS OF EQUIVALENTS AFTER AVERAGING
C REPEATED MEASUREMENTS
    4 CALL WTMEAN(X,DX,0,W1)
C W3 IS THE WORKING SPACE FOR STATISTICS OF EQUIVALENTS weighted with esds's
      CALL WTMEAN(X,DX,0,W3)
C
C HERE FOR NEW SUBGROUP (ALL ATTEMPTS TO MEASURE EXACTLY SAME REFLN)
C INITIALISE STATISTICS COUNTS
C W2 IS THE WORKING SPACE FOR STATISTICS OF REPEATED MEASUREMENTS
    5 CALL WTMEAN(X,DX,0,W2)
      IBUF=0
      JPOS=1
      CALL AINOUT(KR,KROLD,FBUF,NR,ICHNGE,3)
      HR(1)=FLOAT(KR(3))
      HR(2)=FLOAT(KR(2))
      HR(3)=FLOAT(KR(1))
      CALL INDDIV(HR,HR)
      IOP=IABS(KR(4))
      CALL ROTSYM(HR,H,IOP,-1)
      IF (KR(4) .LT. 0) CALL GMREV(H,H,1,3)
      NREF=NR
C
C  PRINT OUT DATA FOR INDIVIDUAL REFLECTIONS
      CALL ARPRIN(H,FBUF,3)
C Repeated measurements should be weighted according to their esd'd
   6  CALL WTMEAN(FBUF(2),FBUF(3),2,W2)
      SUMS(1) = SUMS(1) + FBUF(2)
      SUMS(2) = SUMS(2) + FBUF(3)
C Sums 11 counts the measurments
      SUMS(11) = SUMS(11) + 1.
C  FILL IN BUFFER FOR WRITING ONE LINE TO FILE
      CALL ARPRIN(H,FBUF,4)
      IF (NR.GT.1) THEN
        CALL AINOUT(KR,KROLD,FBUF,NR,JJ,4)
        CALL ARPRIN(H,FBUF,5)
        GO TO 6
      ENDIF
C
C END OF SUBGROUP
C Get the mean of repeated measurements
      CALL WTMEAN(FBUF(2),FBUF(3),-1,W2)
      IF (W2(4).GT.1.01) THEN
        SUMS(3) = SUMS(3) + FBUF(2)
        SUMS(4) = SUMS(4) + FBUF(3)
C Sums 5 accumulates individual chisqrs
        SUMS(5) = SUMS(5) + (W2(2) - W2(1)*FBUF(2))/(W2(4)-1.)
C Sums 6 counts the reflections which have been measured more than once
        SUMS(6) = SUMS(6) + 1.
      ENDIF
      CALL ARPRIN(H,FBUF,6)
      CALL WTMEAN(FBUF(2),FBUF(3),IFUN1,W1)
C Make sure we get statistics for statisitical weights
      CALL WTMEAN(FBUF(2),FBUF(3),2,W3)
      IF (ICHNGE.EQ.4) GO TO 5
C
C END OF GROUP
      CALL WTMEAN(FBUF(2),FBUF(3),-1,W1)
      CALL WTMEAN(X,DX,-1,W3)
      IF (W3(4).GT.1.01) THEN
        SUMS(7) = SUMS(7) + FBUF(2)
        SUMS(8) = SUMS(8) + FBUF(3)
        SUMS(9) = SUMS(9) + (W3(2) - W3(1)*FBUF(2))/(W3(4)-1.)
C Sums 10 counts the reflections for which equivalents have been measured
        SUMS(10) = SUMS(10) + 1.
      ENDIF
      CALL ARPRIN(HR,FBUF,7)
      IF (ICHNGE.NE.0) GO TO 4

C  END OF DATA GIVE STATISTICS
      R1=100.*SUMS(2)/SUMS(1)
      WRITE (LPT,2000) R1
      WRITE (ITO,2000) R1
 2000 FORMAT (/' The R factor based on counting statistics is',
     & 2X,F8.2,'%')
      AMNF2 = SUMS(1)/SUMS(11)
      IF (SUMS(6).GT..5) THEN
        R2=100.*SUMS(4)/SUMS(3)
        CHI1=SUMS(5)/SUMS(6)
        WRITE (LPT,2021) NINT(SUMS(6)),CHI1,R2
        WRITE (ITO,2021) NINT(SUMS(6)),CHI1,R2
 2021 FORMAT ( /' The chisquared for',I4,' repeated measurements is ',
     & F8.2/' and the associated R factor is',15X,F8.2,'%')
      ELSE
        WRITE (LPT,2011)
        WRITE (ITO,2011)
 2011 FORMAT (/' There were no repeated measurements ')
      ENDIF
      IF (SUMS(10).GT..5) THEN
        R3=100.*SUMS(8)/SUMS(7)
        CHI2=SUMS(9)/SUMS(10)
        WRITE (LPT,2022) NINT(SUMS(10)),CHI2,R3
        WRITE (ITO,2022) NINT(SUMS(10)),CHI2,R3
 2022 FORMAT (/' The chisquared  for',I4,' equivalent reflections is',
     &F 8.2/' with an associated R factor of',16X,F8.2,'%')
      ELSE
        WRITE (LPT,2012)
        WRITE (ITO,2012)
 2012 FORMAT (/' No equivalent reflections were measured')
      ENDIF
        WRITE (LPT,2023) AMNF2
        WRITE (ITO,2023) AMNF2
 2023 FORMAT (/' The average value measured, taken over all ',
     & 'reflections, is',F10.2)
      STOP
      END
C
C
C
C
C LEVEL 50      PROGRAM ARRSNP
      PROGRAM ARRSNP
C
C *** ARRSNP new by PJB  C4.2 October 2007 ***
C
C*********************************************************************
C
C                          A R R S N P
C
C  MAIN PROGRAM TO ARRANGE THE MATRIX ELEMENT OF SNP DATA TOGETHER
C  ACCORDING TO THE CRYSTAL SYMMETRY. WILL DEAL WITH INDICES WHICH
C  ARE SUBMULTIPLES OF INTEGERS.
C
C**************************************************************************
CC 2D
CH To group together equivalent measurements and give some statistics on
CH their degree of equivalence, indices may be submultiples of integers.
C
CD Arranges observations of elements of polarisation matrices according to the
CD matrix indices, the reflectionindices, and the symmetry given by the crystal
CD data. Averages of  repeated measurements of the same item, and of groups of
CD equivalent items are made.
C
CI The crystal data file must contain:
CI     Symmetry information on S cards
CI     I cards which select the different options. The words on I cards
CI     which are recognised are: DTYP,MULH,MULK,MULL,PRIN,REJ,RNUM,WGHT
CI     DTYP is mandatory and the number which follows indicates the format
CI     of the data only 11 and 12 for SNP data
CI          DTYP = 11 IGOR type data (rhistory crpd outout) ext .pol
CI          DTYP = 12 MAD data from logfiles (rlogfile crpd) ext .pol
CI     All the other words are optional:
CI     Any or all of MULH, MULK and MULL each followed by the number by which
CI         the corresponding index h,k,or \$\ell\$ should be multiplied to
CI         obtain an integer.
CI     REJ  if given and followed by the value 1 a list of reflections to
CI          be rejected is expected.
CI     RNUM if given and followed by the value 1 the record numbers will
CI          be stored with the reflections in the output file as well as
CI          in the listing file.
CI     WGHT The number which follows selects the weighting scheme
CI           = 0 (default) Unit weights for individual measurements, and
CI               the mean of equivalents weighted according to their esd's.
CI           = 1 Statisitical weights used for individual measurements, and
CI               esd's used for weighting for mean of equivalents.
CI           = 2 Unit weights used throughout.
CI
CI A data file of the type indicated by DTYP above. Its default extension
CI is .pol
CI
CI If REJ=1 a file containing the record numbers of reflections
CI to be rejected. The numbers must be in increasing order except that a
CI negative number means reject all reflections with record numbers between the
CI previous positive number given and that whose record number is the absolute
CI value just read (inclusive). The default extension for this file-name is .rej
CI
CO A listing file: ARRSNP.lis which reports how the crystal data file was
CO interpreted and lists the data which have been arranged. In this output all
CO reflections equivalent to one another are grouped together and averaged.
CO Within the groups multiple measurements of the same reflection are placed
CO together. These are arranged with h changing most rapidly, k next and l
CO most slowly.
CO The esd's of the means are calculated both from the esd's of the
CO values being averaged, and from the weighted deviations of these
CO values from the mean. The larger of the two values is printed and
CO used for further calculation.
CO Some statistics on the degree of equivalence between supposedly
CO equivalent measurements are also given in the listing file and on the
CO terminal.
CO A file with extension .arr destined to be read by further processing
CO programs contains all the data arranged as above but with no
CO averaging. These data can subsequently be read by function INPUAR or
CO equivalent code. One call to INPUAR fills in the COMMON /REFS/ with all
CO the data for one group of equivalent reflections.
CO (COMMON /REFS/K(3,2),LL(48,2),R(500,2),SCALE(2),INC,II,FF(3,2) )
CO The final index IS in REFS is to enable data to be read from more than one
CO source, for merging etc. LL(I,IS) contains the number of entries in R
CO for the Ith reflection in the group. The entries in R for each
CO reflection are:
CO      II+1 to II+3 :    its indices hkl
CO      II+4 to II+LL:    groups of "value" "esd" ("other data")
CO                     or groups of "record number" "value" "esd" ("other
CO                     data") if RNUM 1 was given.
CO II starts at 1 for the first reflection in the group and should be
CO incremented by LL(I,IS)+2 after obtaining each subgroup I of data (the
CO extra two slots provide space in which to store the means of repeated
CO measurements). If LL(J+1,IS)=3 the Jth reflection is the last in the group
CO and the next three entries in R are the indices hkl with which to label the
CO group of equivalents. See subroutine STATIS for an example of using the
CO data stored in REFS.
C
CR On running the program the user is asked for the name of the crystal data
CR file, then if REJ=1, for the file containing the rejection list.
CR The names of one or more data files of the type specified by DTYP
CR are then given interactively. After the last file has been read the
CR program reports the number of records sorted,
CR and asks for a name for the output file of sorted data.
C
CN AVERPA reads and processes .arr files containing SNP data

      PARAMETER (KEYS=5)
      LOGICAL USE,IEND,MULP
      DIMENSION H(3),K(3),FBUF(10),KR(KEYS),HR(3),W1(5),W2(5),W3(5),
     &SUMS(6),KROLD(KEYS)
/ARRDAT/
/IOUNIT/
/NSYM/
/SCRACH/
C
      CALL PREFIN('ARRSNP')
      CALL SYMOP
      CALL OPSYM(2)
      CALL SYMUNI
C
C INPUT I CARD AND SET UP:
      CALL INPUTI
      CALL IICD3
      CALL MULIND(MULP)
      INC=MULP
      CALL ARPRIN(H,FBUF,0)
      CALL ERRMES(0,0,'for ARRSNP')
C
C SET UP FUTURE USE OF NPACK TO HAVE H,K,L IN RANGE -150 TO +150 AND
C THE OPERATOR NUMBER TO BE BETWEEN -NOPC AND +NOPC.  4 ITEMS TO BE PACKED.
      KR(1)=-100
      KR(2)=-100
      KR(3)=-100
C Extra key for matrix element labels
      KR(4)=-9
      KR(5)=-NOPC
      CALL AINOUT(KR,KROLD,FBUF,KEYS,NUMVAL,0)

C
C  SET UP WEIGHTING SCHEME
      IFUN1=2
      IFUN2=1
      IF (IFOR(4).EQ.1) IFUN2=2
      IF (IFOR(4).EQ.2) IFUN1=1
C
      IEND=.TRUE.
C
C IF REJECTIONS TO BE READ SET THINGS UP
      USE=.TRUE.
      IF (IFOR(5).EQ.1) CALL REJECT(-1,NEXT,LREJ,USE)
C
C START READING REFLECTIONS
   1  CALL PLREAD(H,FBUF,IEND)
      IF (MULP) CALL INDMUL(H,H)
      IF (IEND) GO TO 3
      N=NINT(FBUF(1))
C
C TEST FOR REJECTIONS IF REQUESTED IN I CARD:
      IF (IFOR(5).EQ.1) CALL REJECT(N,NEXT,LREJ,USE)
      IF (.NOT. USE) THEN
        CALL ARPRIN(H,FBUF,1)
        GO TO 1
      ENDIF
C
C ACCEPTED:
      CALL INDFIX(H,K)
      CALL ASUNIT(H,HR,IN,M)
C SETS IN=WHICH SYMMETRY OPERATOR PUTS THIS HKL INTO ASYMMETRIC UNIT
C "IN" MAY BE NEGATIVE FOR A FRIEDEL RELATED HKL
C
C THE INDICES OF THE REFLECTION IN THE ASYMMETRIC UNIT INTO WHICH THIS ONE
C TRANSFORMS ARE PUT INTO HR, THEN AS INTEGERS TO KR
C - IN THIS WAY THE ARRAY KR BUILDS UP A
C SORT ITEM IN WHICH THE SYMMETRY OPERATOR NUMBER WILL CHANGE MOST FREQUENTLY,
C H WILL CHANGE NEXT MOST FREQUENTLY, K NEXT, AND L LEAST.
C
      IF (IN .EQ. 0) THEN
        WRITE (ICARD,3000) K
3000    FORMAT (3I4)
        CALL ERRMES(1,0,
     &  ICARD(1:12)//' will not transform into asymmetric unit')
      ENDIF
C
C KEEP FRIEDEL RELATED PAIRS SEPARATE:
      KR(5)=IN
C SWAP INDICES TO SORT SO THAT L CHANGES LEAST FREQUENTLY
      KR(1)=JFIX(HR(3))
      KR(2)=JFIX(HR(2))
      KR(3)=JFIX(HR(1))
      KR(4)=NINT(FBUF(4))
C
C SEND WHOLE ITEM TO BE INCLUDED IN A SORT PROCESS:
C      write (ito,7000) KR,(Fbuf(i),i=1,4)
C 7000 format (5i4,4f10.3)
      CALL AINOUT(KR,KROLD,FBUF,KEYS,NUMVAL,1)
      GO TO 1
C
    3 CALL AINOUT(K,KROLD,FBUF,NREFS,N1,2)
      IF (NREFS.EQ.0) CALL ERRMES(1,0,'No data after ARRSNP sort')
C
      MESSAG='file for sorted reflections'
      NAMFIL='.ARR'
      LUNI=NOPFIL(112)
      CALL MESS(LPT,1,'Sorted reflections recorded to '//NAMFIL)
C
      CALL CENTRE(LPT,100,'***** Sorted and averaged '//
     & 'observations *****',120)
      CALL NEWLIN(LPT)
C WRITE STANDARD PAGE HEADING, AND SET UP TESTP:
      CALL ARPRIN(H,FBUF,2)
C
C INITIALISE SUMS
      CALL GMZER(SUMS,6,1)
C HERE FOR NEW GROUP (ALL REFLNS RELATED BY SYMMETRY TO THIS ONE)
C TO CALCULATE THE AVERAGE OVER DIFFERENT ELEMENTS OF THE POLN MATRIX
      CALL WTMEAN(X,DX,0,W1)
C W1 IS THE WORKING SPACE FOR STATISTICS OF EQUIVALENTS weighted with esds's
C
C HERE FOR NEW SUBGROUP (ALL ATTEMPTS TO MEASURE EXACTLY SAME REFLN)
C INITIALISE STATISTICS COUNTS
    7 CALL WTMEAN(X,DX,0,W1)
      CALL WTMEAN(X,DX,0,W3)
C W2 IS THE WORKING SPACE FOR STATISTICS OF REPEATED MEASUREMENTS
    5 CALL WTMEAN(X,DX,0,W2)
      IBUF=0
      JPOS=1
      CALL AINOUT(KR,KROLD,FBUF,NR,ICHNGE,3)
      HR(1)=FLOAT(KR(3))
      HR(2)=FLOAT(KR(2))
      HR(3)=FLOAT(KR(1))
      IPOL=KR(4)
      CALL INDDIV(HR,HR)
      IOP=IABS(KR(5))
      CALL ROTSYM(HR,H,IOP,-1)
      IF (KR(5) .LT. 0) CALL GMREV(H,H,1,3)
      NREF=NR
C      write (ito,7000) KR,(Fbuf(i),i=1,4)
C
C  PRINT OUT DATA FOR INDIVIDUAL REFLECTIONS
      CALL ARPRIN(H,FBUF,3)
C Repeated measurements should be weighted according to their esd'd
   6  CALL WTMEAN(FBUF(2),FBUF(3),2,W2)
C  FILL IN BUFFER FOR WRITING ONE LINE TO FILE
      CALL ARPRIN(H,FBUF,4)
      IF (NR.GT.1) THEN
        CALL AINOUT(KR,KROLD,FBUF,NR,JJ,4)
        CALL ARPRIN(H,FBUF,5)
        GO TO 6
      ENDIF
C
C END OF SUBGROUP
C Get the mean of repeated measurements
      CALL WTMEAN(FBUF(2),FBUF(3),-1,W2)
C Sums(1) accumulates the weighted square deviations of repeated measurements
      IF (W2(4).GT.1.01) THEN
        SUMS(1) = SUMS(1) + W2(2) - W2(1)*FBUF(2)
C Sums(2) accumulates the number of repeated measurements
        SUMS(2) = SUMS(2) + W2(4)
C Sums(3) accumulates the number of sets of repeated measurements
        SUMS(3)=SUMS(3)+1.
      ENDIF
      CALL ARPRIN(H,FBUF,6)
      CALL WTMEAN(FBUF(2),FBUF(3),IFUN1,W1)
C Make sure we get statistics with statisitical weights
      CALL WTMEAN(FBUF(2),FBUF(3),2,W3)
C Next equivalent
      IF (ICHNGE.EQ.5) GO TO 5
C
C END OF GROUP
      CALL WTMEAN(FBUF(2),FBUF(3),-1,W1)
      CALL WTMEAN(X,DX,-1,W3)
      IF (W3(4).GT.1.01) THEN
C Sums(4) accumulates the weighted square deviations of equivalent measurementd
        SUMS(4) = SUMS(4) + W3(2) - W3(1)*FBUF(2)
C Sums(5) accumulates the number of equivalrnt measurements
        SUMS(5) = SUMS(5) + W3(4)
C Sums(6) accumulates the number of sets of equivalent measurements
        SUMS(6) = SUMS(6) + 1.
C        write (ito,3010) sums
C 3010 format (6f10.3)
      ENDIF
      CALL ARPRIN(HR,FBUF,7)
      IF (ICHNGE.NE.0) GO TO 7
C
C  END OF DATA GIVE STATISTICS
      IF (SUMS(2)-SUMS(3) .GT.0) THEN
        CHI1=SUMS(1)/(SUMS(2)-SUMS(3))
        WRITE (LPT,2021) NINT(SUMS(2)),CHI1
        WRITE (ITO,2021) NINT(SUMS(2)),CHI1
 2021 FORMAT ( /' The chisquared for',I4,' repeated measurements is ',
     & F8.2)
      ELSE
        WRITE (LPT,2011)
        WRITE (ITO,2011)
 2011 FORMAT (/' There were no repeated measurements ')
      ENDIF
      IF (SUMS(5)-SUMS(6).GT.0) THEN
        CHI2=SUMS(4)/(SUMS(5)-SUMS(6))
        WRITE (LPT,2022) NINT(SUMS(6)),NINT(SUMS(5)),CHI2
        WRITE (ITO,2022) NINT(SUMS(6)),NINT(SUMS(5)),CHI2

 2022 FORMAT (/' The chisquared  for',I4,' equivalent sets containing',
     &I4,' reflections is',F 8.2)
      ELSE
        WRITE (LPT,2012)
        WRITE (ITO,2012)
 2012 FORMAT (/' No equivalent reflections were measured')
      ENDIF
      STOP
      END
C
C
C
C
C LEVEL 50      PROGRAM AVERPA
      PROGRAM AVERPA
C
C *** AVERPA  updated  by PJB August 2016 To allow for s-domains C4.30 ***
C
C *****************************************************************************
C
C                            A V E R P A
C
C TO TAKE MEANS OF POLARISATION MATRIX COMPONENTS ACCORDING TO DIFFERENT
C STUCTURAL ASSUMPTIONS
C
C *****************************************************************************
C
CC 2D
CH Reads ARRNGEd SNP data and calculates  mean values of polarisation matrix
CH components.
C
CD The program reads a file written by ARRSNP or ARISNP then calculates
CD mean values of components of the polarisation matrix which are equal under
CD chosen structural assumptions.
CI The crystal data file must contain:
CI      S cards giving the symmetry.
CI      A C card with the cell dimensions.
CI      I cards (the same as were used with ARRNGE). These define
CI      the type of data, and how many additional parameters were stored.
CI      A Q PSYM parameter is needed to define the averaging mode required:
CI        PSYM = 0  All elements treated independently
CI             = 1  Simple magnetic only
CI             = 2  Simple chiral only
CI             = 3  Nuclear and magnetic in quadrature
CI             = 4  Nuclear and magnetic, phase 0 or 180
CI       Alternatively PSYM can be followed by 18 which give a user defined
CI       averaging scheme. The numbers IP(I) should be such that for all
CI       components J related to I. IP(J)=+/-IP(I)=+/-I where
CI      I and J =3*(In-1)+Out (In/Out=1,2,3 for X,Y,Z)
CI PSYM=1 Simple magnetic only XX=-XX=-1,
CI                                YY=-(-YY)=-(ZZ)=-ZZ
CI                                YZ=ZY=-(-YZ)=-(-ZY)
CI                                XY=YX=XZ=ZX=-(-XY)=-(-YX)=-(-XZ)=-(-ZX)=0
CI
CI PSYM=2 Chiral magnetic only XX=-XX=-1;
CI                                XY=XZ=-XY=-XZ=0;
CI                                YX=-YX;  ZX=-ZX;
CI                                YY=-(-YY)=-(ZZ)=-ZZ;
CI                                YZ=ZY=-(-YZ)=-(-ZY)
CI
CI PSYM=3 Magnetic in quadrature XX=-XX;
CI         with nuclear           XY=-YX=-(-XY)=(-YX);
CI                                XZ=-ZX=-(-XZ)=(-ZX);
CI                                YY=-(-YY); -(ZZ)=-ZZ;
CI                                YZ=ZY=-(-YZ)=-(-ZY)
CI
CI PSYM=4 Magnetic in phase with  XX=-XX;
CI              nuclear           YX=-ZX=-YX=-YX=0;
CI                                XY=-XY;
CI                                XZ=-XZ;
CI                                YY,YZ,ZY,ZZ,-YY,-YZ,-ZY,-ZZ independent
CI                                YZ=ZY=-(-YZ)=-(-ZY)
CI
C
CI The data file is that written by ARRSNP or ARISNP. Default extension ".arr"
C
CO The usual listing file reporting data read from the CDF. It also
CO reports the results of a statistical analysis which attempts to
CO validate the chosen averaging scheme.
CO An output file extn .pal intended for further processing, such as
CO least squares refinement using SNPLSQ.
C
CR On running the program the user is asked for the name of the
CR crystal data file, the reflection data file (.arr) and is then
CR asked to choose the name for the output file (.pal).
C
      DIMENSION LUN(2),LOUTS(2),SUMS(5,18)
      LOGICAL OK,TESTOV
      CHARACTER*70 HEDING,FILNOM*10,FILNAM*10
      CHARACTER *5 LABEL(18)
      CHARACTER*2 LCOMP(9)
/CARDRC/
/DGEOM/
/IOUNIT/
/REFS/
/SCRACH/
/STATP/
C
      DATA HEDING/'(5X,''h'',4X,''k'',4X,''l'',3X,''Ndom  In-Out    Pobs
     &'',6X,''DPobs    Nobs''/)'/
      DATA LCOMP/'XX','XY','XZ','YX','YY','YZ','ZX','ZY','ZZ'/
C
      CALL PREFIN('AVERPA')
      CALL INPUTI
      CALL ICDFMT(INC,ITEMS)
      IF (INC.NE.0) THEN
        HEDING(2:2)='6'
        HEDING(9:9)='7'
        HEDING(16:16)='7'
        HEDING(23:23)='5'
      ENDIF
      NAMFIL='.ARR'
      LUN(1)=NOPFIL(101)
      LUNI=LUN(1)
C4.12 READ THE DATA HEADER
      CALL ARRHED(1)
      CALL SETDC
      call domag1(3)
      CALL INPSYM(IPAR,MAXP,OK)
      IF (OK) CALL PSYMOP(IPAR,MAXP)
      CALL ERRMES(0,0,'to AVERPA')
C   OPEN OUTPUT FILES
      FILNAM=FILNOM(LUN(1))
      L=LENG(FILNAM,10)
      MESSAG=FILNAM(1:L-4)
      NAMFIL='.PAL'
      LOUT=NOPFIL(122)
      LOUTS(1)=LOUT
      NUNITS=1
C4.19 Write header on asymmetry outputs
      MODE=0
      CALL HDROUT(LOUTS,NUNITS,MODE)
C
      CALL NEWPAG(LPT)
      WRITE (LPT,HEDING)
      LINO=5
      SCALE(1)=1.0
C4.9 Labels made here so that all are done
      DO 22 J=1,MAXP
      IJ=NFIND(J,IPAR,18)
      IF (IJ.GT.9) THEN
        LABEL(J)='(-'//LCOMP(IJ-9)//')'
      ELSE
        LABEL(J)='  '//LCOMP(IJ)//' '
      ENDIF
   22 CONTINUE
C
C CLEAR SUMS TO HOLD STATISTICS ON COMPONENT SYMMETRY
      CALL WTMEAN(Ax,Bx,0,ZSUMS)
      DO 3 IP=1,MAXP
        CALL WTMEAN(A,B,0,SUMS(1,IP))
    3 CONTINUE
C
C START LOOP TO READ DATA
      MIN=1
      MOUT=0
    1 IEND= INPUAR(1,LUN)
      IF (IEND.NE.0) GO TO 7
      CALL STATPA(MIN,MOUT)
      MIN=MOUT
      IF (MOUT.EQ.0) GO TO 1
C      DO 50 J=1,NPOLN
C      write (lpt,5000) j,hlabel,AMEAN(J),DEV(J),inc
C 5000 format (I4,3f8.3,2f10.3,i4)
C   50 continue
C
C  WRITE MEAN PA DATA
      CALL TESTP(LPT,LINO,1,HEDING,2)
      NEW=1
      DO 2 J=1,NPOLN
        ISLOT=IPOLN(J)
        IP=MOD(ISLOT-1,MAXP) +1
        L=NFIND(IP,IPAR,18)
        ND=((ISLOT-1)/MAXP)+1
        IK=MOD(L-1,3)+1
        IJ=((L-1)/3)+1
        NOBS =  NINT(WRK(4,ISLOT))
        IF (J.EQ.1) THEN
          IF (INC .EQ. 0) THEN
            WRITE (LPT,2001) (K(I,1),I=1,3),ND,LABEL(IP),AMEAN(J),
     &      DEV(J),NOBS
          ELSE
            WRITE (LPT,2004) HLABEL,ND,LABEL(IP),AMEAN(J),DEV(J),NOBS
          ENDIF
        ELSE
          IF (INC .EQ. 0) THEN
            WRITE (LPT,2002) ND,LABEL(IP),AMEAN(J),
     &      DEV(J), NOBS
          ELSE
            WRITE (LPT,2005)  ND,LABEL(IP),AMEAN(J),DEV(J),NOBS
          ENDIF
        ENDIF
        IF (INC .EQ. 0) THEN
          WRITE (LOUT,2003) (K(I,1),I=1,3),AMEAN(J),DEV(J),
     &    FLOAT(IJ),FLOAT(IK),NEW
        ELSE
          WRITE (LOUT,2006)  HLABEL,AMEAN(J),DEV(J),FLOAT(IJ),
     &    FLOAT(IK),NEW
        ENDIF
        NEW=0
 2001   FORMAT (1X,3I5,2X,I4,3X,A5,2F10.3,2X,I4)
 2002   FORMAT (16X,2X,I4,3X,A5,2F10.3,2X,I4)
 2003   FORMAT (3I5,2F8.3,2F4.0,I5)
 2004   FORMAT (1X,3F8.3,1X,I4,4X,A5,2F10.3,2X,I4)
 2005   FORMAT (23X,3X,I4,4X,A5,2F10.3,2X,I4)
 2006   FORMAT (3F8.3,2F8.3,2F4.0,I5)
C Save some statistics for symmetry check
        IF (NOBS.LE.1) GO TO 2
        DATVAR = WRK(3,ISLOT)
        ANUM=WRK(2,ISLOT)-(WRK(1,ISLOT)*AMEAN(J))
        IF ((ANUM .LT.0) .OR.TESTOV(ANUM,WRK(5,ISLOT))) GO TO 2
        AMNVAR=ANUM/WRK(5,ISLOT)
C USE THE RATIO OF CALCULATED:EXPERIMENTAL ESD TO ASSESS QUALITY
        RATIO=SQRT(AMNVAR*DATVAR)
        CALL WTMEAN(RATIO,FLOAT(NOBS**2),2,SUMS(1,IP))
    2   CONTINUE
        WRITE (LPT,2003)
      GO TO 1
C
C  END OF DATA GIVE STATITSICS
C   tests for quality of averages
    7 WRITE (LPT,2020)
      DO 6 IP=1,MAXP
      IC=NFIND(IP,IPAR,18)
      NOBS=NINT(SUMS(4,IP))
      IF (NOBS .EQ.0) GO TO 6
      CALL WTMEAN(QMEAN,QDEV,-1,SUMS(1,IP))
      WRITE (LPT,2021) IP,LABEL(IP),QMEAN,NOBS
 2020 FORMAT (//'Chisqr test on average for:  Par   Element   ',
     &'Chisqr  Nobs')
 2021 FORMAT (26x,I5,5X,A5,F8.1,I7)
    6 CONTINUE
      NOBS=NINT(ZSUMS(4))
      IF (NOBS .NE.0) THEN
        CALL WTMEAN(ZMEAN,ZDEV,-1,ZSUMS)
        WRITE (LPT,2022) ZMEAN/ZDEV,ZMEAN,ZDEV
 2022   FORMAT ('Chisqr test for zero elements ',
     &   F5.1,' ('F5.3,'+/-',F5.3,')')
      ENDIF
      STOP
      END
C
C
C
C
C LEVEL 50      PROGRAM AVEXAR
      PROGRAM AVEXAR
C
C *** AVEXAR updated by PJB October 2008 C4.12 Read and write headers ******
C
C *****************************************************************************
C
C                            A V E X A R
C
C
C *****************************************************************************
C
CC 2D
CH To read  ARRNGE files and prepare for LSQ with extinction
C
CD The program will read one or more of the files written by ARRNGE or ARRINC
CD and prepare a file for LSQ in which equivalent reflections are treated
CD independently so that a path-length dependent extinction correction can be
CD refined.  It will average reflections which have been measured more
CD than once. If the data are intensity measurements, and "G" cards are
CD present on the crystal data file, absorption factors will be calculated and
CD applied. The 4 constants needed for Becker Coppens extinction
CD corrections are no longer calculated, since this is now done when the data
CD are read by RREFSA. The data are written in a form suitable for input
CD to the CCSL least squares programs (SFLSQ, MAGLSQ etc.).
C
CI The crystal data file must contain:
CI     S cards giving the symmetry
CI     A  C card with the cell dimensions
CI     An I DTYP card describing the type of data (the same as used for
CI           ARRNGE) it is only used to determine whether the data are flipping
CI           ratios or  intensities and how many additional parameters such as
CI           angles were stored by ARRNGE
CI    D cards describing the diffraction geometry, the wavelength and UB matrix
CI          may be on the arranged data file.
CI    G cards describing the crystal shape. These are optional and if absent no
CI          absorption corrections will be made and a constant path
CI          length of 2mm will be assumed.
CI    If the data are for a magnetic structure with non-integer indices
CI    a Q PROP card giving the propagation vector is required.
CI Basically the same crystal data as that used with ARRNGE to produce the
CI input file should be used but with the addition of E, D and G cards.  The
CI data input is a file written by one of the ARRNGE type programs.
C
CO The usual listing file reporting data read from the CDF.  A file of
CO averaged and (possibly absorption corrected) data suitable for input to
CO one of the least squares programs L MODE 5 for integer indices and  L MODE 8
CO for floating indices. This file has default extension .sf for
CO structure factors and .fr for flipping ratios.
CR On running the program the user is asked for the name of the crystal data,
CR that of the arranged data file and a possible scale factor. This latter is to
CR allow data on very different scales to be scaled to approximately the same
CR level,if no scale is gicen  a scale of unity is assumed. Several data sets
CR may be processed in the same run.
CN This program replaces the three similar programs ABSEXF, ARREXF and AVEXTR
C
      DIMENSION LUN(2)
      LOGICAL ONCARD,ISFLIP,DOABS,MULP,SAYS,ASYM,FIRST
      CHARACTER*80 HEDING
      CHARACTER*40 FILNAM,FILNOM*10,EXTN*4
/ABSDAT/
/DGEOM/
/CARDRC/
/IOUNIT/
/REFS/
/SCRACH/
      DATA HEDING/'(4X,''h'',4X,''k'',4X,''l'',5X,''Fobs'',6X,''DFobs'',
     &2X,''Transmission'')'/
      DATA FIRST/.TRUE./
      INC = 0
      DUMMY=0.
C
      CALL PREFIN('AVEXAR')
      CALL SYMOP
      CALL RECIP
      CALL INPUTI
      CALL ICDFMT(INC,ITEMS)
      CALL MULIND(MULP)
      IF (MULP) INC=1
      IF (INC.NE.0) THEN
        HEDING(2:2)='6'
        HEDING(9:9)='7'
        HEDING(16:16)='7'
        HEDING(23:23)='7'
      ELSE
        IBUFF=35
      ENDIF
      IF (.NOT. ONCARD('I','DTYP',DTYP)) CALL ERRMES(3,1,
     & 'I DTYP giving data type for ARRNGE')
       ISFLIP=(NINT(DTYP).EQ.1)
      LH=2
      SCALE(1)=1.
      IF (ISFLIP) THEN
        EXTN='.FR '
        CALL ASK('Output flipping ratios or asymmetries F,A (def F)')
        ASYM=(SAYS('A'))
       if (ASYM) EXTN='.ASY'
      ELSE
        EXTN='.SF '
      ENDIF
  109 IF (ISFLIP) THEN
        WRITE (ITO,113)
      ELSE
        WRITE (ITO,111)
      ENDIF
  111 FORMAT (' Give input file name, and scale (def 1.0) RETURN ')
  113 FORMAT (' Give input file name  RETURN ' )
      CALL ASK('if no more ): ')
      CALL RDWORD(FILNAM,LEN,1,IE,41,-1,IER)
      IF (IER.EQ.0) GO TO 11
      IF (IER.EQ.100) GO TO 100
      CALL ERRMES(1,-1,' Illegal file name')
      GO TO 109
   11 IF (.NOT. ISFLIP) THEN
        CALL RDREAL(SCALE(1),IE,IE,80,IER)
        IF (IER .NE. 0) SCALE(1)=1.0
      ENDIF
      MESSAG=FILNAM
      NAMFIL='.ARR'
      L = LENGT(NAMFIL)
      LUN(1)=NOPFIL(131)
      IF (LUN(1).LE.0) GO TO 109
      LUNI=LUN(1)
C4,12 Call to ARRHED to read header
      CALL ARRHED
      IF (FIRST) THEN
        DOABS= (ICDNO(7).NE.0)
        IF (DOABS) THEN
          CALL SETABS
C FORCE ABSORPTION INTEGRAL
          MODEA=1
        ELSE
          CALL SETDC
        ENDIF
        CALL ERRMES(0,0,'to AVEXAR')
        FIRST=.FALSE.
      ENDIF
C
C OPEN output file
      FILNAM=FILNOM(LUN(1))
      L=LENG(FILNAM,10)
      MESSAG=FILNAM(1:L-4)
      NAMFIL=EXTN
      LOUT=NOPFIL(122)
C4.12 Write header on structure factor output
    3 IF (IPLO.NE.0) THEN
        READ (IPLO,2030,END=2) MESSAG
 2030   FORMAT (A100)
        WRITE (LOUT,2030) MESSAG
        GO TO 3
    2   CALL CLOFIL(IPLO)
        IPLO=0
      ENDIF
      WRITE (LOUT,2033) WLGTH
       IF (ICDNO(7).NE.0) WRITE (LOUT,2032) AMU
 2033 FORMAT ('#Wavelength',F10.4)
 2032 FORMAT ('#Absorption',F10.4)
      WRITE (LOUT,2034) UM
 2034 FORMAT ('#Orientation',9F8.4)
C
      WRITE (LPT,117) WLGTH,(FILNAM(I:I),I=1,L)
  117 FORMAT ('Data measured with lambda =',F7.3,' read from ',80A1)
      IF (.NOT. ISFLIP) WRITE (LPT,118) SCALE(1)
  118 FORMAT (' and  multiplied by',F8.3/)
      IF (.NOT. DOABS) HEDING(43:)=')'
C      WRITE (ITO,2030)HEDING
      WRITE (LPT,HEDING)
      LINO=3
C
    1 IEND= INPUAR(1,LUN)
      IF (IEND.NE.0) GO TO 6
      CALL ABSOUT(LOUT,DOABS,ISFLIP,ASYM)
      GO TO 1
    6 CALL CLOFIL(LUN(1))
      CALL CLOFIL(LOUT)
      GO TO 109
C
  100 STOP
      END
C
C
C
C
      SUBROUTINE ABSOUT(LOUT,DOABS,ISFLIP,ASYM)
C
C *** ABSOUT by PJB 10 Apr 87 ***
CC 2B
CH Output routine for AVEXAR (probably obsolete)
C
      DIMENSION KK(3),H(3)
      CHARACTER *120 BUFF, VFMT*60
      LOGICAL DOABS,ISFLIP,ASYM
      COMMON /DIRCOS/DIREC(3,2)
/DGEOM/
/EXTN/
/IOUNIT/
/REFS/
/STATS/
      DATA VFMT/'(2f10.2,2F8.4,2x,2(3f8.4,2x))'/
C
      IS=1
      IR=1
      II=0
      IF (ISFLIP) VFMT(7:7)='5'
    2 L=LL(IR,IS)
      CALL GMEQ(R(II+1,IS),H,3,1)
      IF (INC .EQ. 0) THEN
        CALL INDFIX(H,KK)
        WRITE (BUFF,150) KK
  150   FORMAT (3I5)
        IBUFF=16
      ELSE
        WRITE (BUFF,151) H
  151   FORMAT (3F8.3)
        IBUFF=25
      ENDIF
      IF (L.EQ.3) GO TO 100
      IE=II+L
      IB=II+4
      IFUN=0
      CALL WTMEAN(R(IB,IS),R(IB+1,IS),IFUN,WRK2)
      DO 1 I=IB,IE,2
      IFUN=2
      CALL WTMEAN(R(I,IS),R(I+1,IS),IFUN,WRK2)
    1 CONTINUE
      IJ=II
      II=II+L
      IFUN=-1
      CALL WTMEAN(R(II+1,IS),R(II+2,IS),IFUN,WRK2)
C NO ABSORPTION FOR FLIPPING RATIOS
      IF (.NOT. ISFLIP) THEN
        IF (DOABS) THEN
          TRFAC=ABSOR(R(IJ+1,IS))
          ABSC=1/TRFAC
          R(II+1,IS)=R(II+1,IS)*ABSC
          R(II+2,IS)=R(II+2,IS)*ABSC
        ENDIF
        IF (R(II+1,IS).GT.0.) THEN
          FOBS=SQRT(R(II+1,IS)*SCALE(1))
          DF=SQRT(SCALE(1)*(R(II+1,IS)+ABS(R(II+2,IS)))) -FOBS
        ELSE
          DF = SQRT(ABS(R(II+2,IS)*SCALE(1)))
          FOBS = 0.
        ENDIF
      ELSE
        FOBS=R(II+1,IS)
        DF=R(II+2,IS)
        IF (ASYM) THEN
          DF=2.*FOBS*DF/((FOBS+1)**2)
          FOBS=(FOBS-1.)/(FOBS+1)
        ENDIF
      ENDIF
      WRITE (BUFF(IBUFF:),VFMT) FOBS,DF
      IBUFF=IBUFF+20
      WRITE (LOUT,18) (BUFF(I:I),I=1,IBUFF)
   18 FORMAT (100A1)
      IF (DOABS) THEN
        WRITE(BUFF(IBUFF:),15) TRFAC,TM
        IBUFF=IBUFF+20
      ENDIF
   15 FORMAT (2F10.4)
      WRITE (LPT,18)  (BUFF(I:I),I=1,IBUFF)
C  LEAVE SPACE FOR MEANS
      II=II+2
      IR=IR+1
      GO TO 2
C
 100  RETURN
      END
C
C
C
C
C LEVEL 50      PROGRAM BESTPL
      PROGRAM BESTPL
C
C *** BESTPL by WIFD Sep 92 ***
C
C *****************************************************************************
C
C                            B E S T P L
C
C      Calculates the best plane associated with a set of atoms
C
C *****************************************************************************
C
%      DIMENSION OX(3,%ATOM%),OXAV(3),XX(3,3)
      DIMENSION DIAG0(3),DIAG1(3),YY(3,3),XAV(3)
/ATNAM/
/IOUNIT/
/POSNS/
C
C.. Initialise
      CALL PREFIN('BESTPL')
C.. Read the lattice parameters and form the reciprocal cell
      CALL RECIP
C.. Read symmetry operators from S cards and form the space group
      CALL SYMOP
C.. Print out all the symmetry operators in real space
      CALL OPSYM(1)
C.. Get atoms
      CALL ATOPOS
C..
      DO 10 I=1,3
        OXAV(I)=0.
 10   CONTINUE
C
      IF (NATOM .LT. 3) CALL ERRIN2(NATOM,0,'Only',
     & 'atoms given - at least 3 required ')
C
C
      DO 20 N=1,NATOM
        CALL ORTHO(X(1,N),OX(1,N),1)
        DO 22 I=1,3
          OXAV(I)=OXAV(I)+OX(I,N)
 22     CONTINUE
 20   CONTINUE
C
      DO 24 I=1,3
        OXAV(I)=OXAV(I)/FLOAT(NATOM)
 24   CONTINUE
C
      CALL ORTHO(OXAV,XAV,-1)
C
      WRITE (LPT,2002) (XAV(I),I=1,3)
      WRITE (ITO,2002) (XAV(I),I=1,3)
 2002 FORMAT(' Centre of gravity at fractional coordinates ',3F10.5)
C
      DO 30 N=1,NATOM
        DO 32 I=1,3
          OX(I,N)=OX(I,N)-OXAV(I)
 32     CONTINUE
 30   CONTINUE
C
      DO 40 J=1,3
        DO 42 I=J,3
          XXIJ=0.
          DO 44 N=1,NATOM
            XXIJ=XXIJ+OX(I,N)*OX(J,N)
 44       CONTINUE
          XX(I,J)=XXIJ
          XX(J,I)=XXIJ
 42     CONTINUE
 40   CONTINUE
C
      CALL TRED2(XX,3,3,DIAG0,DIAG1,.TRUE.)
      CALL TQLI(DIAG0,DIAG1,3,3,XX,.TRUE.)
C.. Eigenvalues held in DIAG0
C.. Kth column of YY holds the normalised eigenvectors corresponding
C.. to DIAG0(K)
C
      DIAMIN=DIAG0(1)
      IDIAG=1
      DO 50 I=2,3
        IF (DIAG0(I).LT.DIAMIN) THEN
          IDIAG=I
          DIAMIN=DIAG0(I)
        END IF
 50   CONTINUE
C
      WRITE(LPT,2001) IDIAG
      WRITE(ITO,2001) IDIAG
2001  FORMAT (/' Smallest eigenvalue number',I3)
C
      WRITE(LPT,2005) (XX(I,IDIAG),I=1,3)
      WRITE(ITO,2005) (XX(I,IDIAG),I=1,3)
2005  FORMAT(/' Directions cosines of best plane:'/1X,3F10.5)
C
C
      XP=XX(1,IDIAG)
      YP=XX(2,IDIAG)
      ZP=XX(3,IDIAG)
C
      XT=ATAND(YP/XP)
      IF (XP.LT.0.) THEN
        PHI=XT+180.
      ELSE
        IF (YP.LT.0.) THEN
          PHI=XT+360.
        ELSE
          PHI=XT
        END IF
      END IF
      THETA=ACOSD(ZP)
C
      WRITE (LPT,2004) THETA,PHI
      WRITE (ITO,2004) THETA,PHI
2004  FORMAT(' (Theta,Phi) = (',2F9.3,')'//' Distances:')
C
      DO 60 N=1,NATOM
      WRITE (LPT,2003) ATNAME(N),SCALPR(OX(1,N),XX(1,IDIAG))
      WRITE (ITO,2003) ATNAME(N),SCALPR(OX(1,N),XX(1,IDIAG))
2003  FORMAT (1X,A4,F10.5)
 60   CONTINUE
C
      STOP
      END
C
C
C
C
C LEVEL 50      PROGRAM BONDS
      PROGRAM BONDS
C
C *** BONDS updated by PJB C123 Apr 2003 ***
C
C *****************************************************************************
C
C                              B O N D S
C
C  MAIN PROGRAM TO CONTROL THE CALCULATION AND PRINTING OF BOND LENGTHS
C  AND ANGLES.  CAN ALSO PUT OUT CARDS FOR GEOMETRIC SLACK CONSTRAINTS.
C
C SEEKS FIRST A "B SLAK" CARD (WITH, AT PRESENT, NOTHING ELSE ON IT).
C
C IF THERE IS NO SUCH CARD, BEHAVES AS A CONVENTIONAL BOND LENGTH PROGRAM, I.E.
C READS (IF THERE) "I BMAX" OR "B BMAX" AS MAXIMUM BOND TO CONSIDER (DEFAULT 2)
C READS (IF THERE) "I BMIN" OR "B BMIN" AS MINIMUM BOND TO CONSIDER (DEFAULT 0)
C FIRST SCANS ALL "B BOND" CARDS AND PRINTS REQUESTED BONDS
C NEXT SCANS ALL "B ANGL" CARDS AND PRINTS REQUESTED ANGLES
C LAST SCANS ALL "B BOTH" CARDS AND PRINTS REQUESTED BONDS AND ANGLES.
C
C ALL ATOMS ARE REFERRED TO BY THEIR LABELS, IN (1X,A4) GROUPS,
C "B BOND" AND "B BOTH" CARDS HAVE SIMILAR FORMATS:
C      A LIST OF MORE THAN 2 LABELS REQUESTS ALL COMBINATIONS OF PAIRS
C                            OF ATOMS TO BE CONSIDERED FOR BONDS.
C      TWO LABELS REQUEST THAT SINGLE BOND ONLY.
C      ONE LABEL REQUESTS THE SEARCHING FOR ALL BONDS ORIGINATING FROM
C                            THAT ONE ATOM.
C
C
C "B ANGL" CARDS ARE DIFFERENT.  LABELS SHOULD OCCUR ONLY IN THREES, AND THE
C REQUESTED ANGLE IS CALCULATED WITHOUT ANY OF THE ABOVE CHECKS OR MOVES.
C
C IF THERE IS A "B SLAK" CARD, READS SETS OF B BOND AND/OR B ANGL CARDS, BUT
C INTERPRETS THESE SLIGHTLY DIFFERENTLY.
C     B BOND IS FOLLOWED BY A SOURCE ATOM NAME, A DESTINATION ATOM NAME,
C             LENGTH1, SD1, LENGTH2, SD2
C BOTH THE ATOM NAMES MAAY BE GENERAL.  FOR THESE BMAX IS SET TO LENGTH1+SD1,
C BMIN TO LENGTH1-SD1.  THE SOURCE ATOM NAME, IF GENERAL, IS DECODED IN THE MAIN
C PROGRAM.  THE DESTINATION ATOM NAME IS DECODED WITHIN ROUTINE BNDLST.  BONDS
C ARE FOUND IN THE USUAL WAY, BUT IN THIS OPTION THEY ARE ALSO CONSIDERED FOR
C OUTPUT TO UNIT LSK, A .SLK FILE WHICH IS A PIECE OF A .CCL FILE, TO BE USED
C TO GIVE SUCH BONDS AS SLACK CONSTRAINTS TO ANOTHER PROGRAM.
C
C THIS MAY WELL GENERATE BOTH "L ATOM" CARDS AND "L BOND" CARDS, AS THE
C DESTINATION ATOMS ONLY POSSESS LABELS IF THEY ARE WITHIN THE ORIGINAL,
C CENTRAL UNIT CELL.
C
C THE PROGRAM NEEDS TO GENERATE ITS OWN NAMES FOR THESE CARDS.  IT USES Ato<n>
C FOR A NEW ATOM, WHERE n IS THE SERIAL NUMBER OF THE ATOM IN ITS LIST, AND
C Bon<n> FOR A NEW BOND.  OTHER IDEAS WELCOMED.
C
C A "B ANGL" CARD REQUESTS THE OUTPUT ON UNIT LSK OF "L ANGL"  CARDS FOR LATER
C USE IN SLACK CONSTRAINTS.  IT HAS THE FORMAT:
C NAME1  NAME2  NAME3  ANGLE1  SD1  ANGLE2  SD2  OPTIONAL (BMAX, SDMAX)
C ALL NAMES ARE GENERAL;  THE ANGLES ARE TO BE CENTRED AT NAME2, BETWEEN BONDS
C GOING TO NAME1 AND NAME3, OR ANY OF THEIR RELATED EQUIVALENTS.  (IF BAMX AND
C SDMAX ARE GIVEN, SUCH BONDS MUST BE OF LENGTH BMAX+-SDMAX.)
C
C TO BE CONSIDERED, AN ANGLE MUST BE OF MAGNITUDE ANGLE1+-SD1.
C
C THE OUTPUT L ANGL CARD CONTAINS ANGLE2 AND SD2.
C
C AN L ANGL CARD ALSO NEEDS A NAME, GENERATED AS Ang<n>
C
C *****************************************************************************
C
CC 8D
CH Calculation of bond lengths and angles. Can also write cards for geometric
CH slack constraints
C
CD The program will calculate bond lengths, with optional standard
CD deviations, and requested bond angles. The results of its calculations
CD can be written in a form suitable for imposing slack constraints in least
CD squares refinements.
CD To determine whether slack constraints are wanted the program looks
CD first for a B SLAK card (with, at present, nothing else on it).
CD
CD If there is no such card, it behaves as a conventional bond length program,
CD i.e. it reads B  cards which define what bonds and angles are required
CD     An I BMAX or B BMAX card to define the maximum bond to consider
CD    (default 2)
CD     An I BMIN or B BMIN card defines the minimum bond to consider (default 0)
CD     B BOND cards define the atoms whose bonds are required
CD     B ANGL cards define which angles are required
CD     B BOTH cards say that both bonds and angles are required.
CD     A B BESD card must be inluded if the standard deviations of the bond
CD     lengths are required
CD     A B AESD card must be inluded if the standard deviations of the bond
CD     angles are required
CD
CD All atoms are referred to by their labels, in (1X,A4) groups, B BOND
CD and B BOTH cards have similar formats:
CD      a list of more than 2 labels indicates that all combinations of pairs
CD      of atoms are to be considered for bonds (and angles).
CD      two labels request the bonds between these two atoms only.
CD      A single label indicates that all bonds originating from
CD      that one atom are required.
CD B ANGL cards are different.  Labels should occur only in threes, and the
CD        angle is calculated at the second atom in the list.
CD
CD If there is a B SLAK card, the program reads sets of B BOND and/or B ANGL
CD cards, but interprets these slightly differently.
CD     B BOND is followed by a source atom name, a destination atom name,
CD     length1, sd1, length2, sd2. Both the atom names may be general.
CD     For these BMAX is set to length1+sd1, BMIN to length1-sd1.
CD     The source atom name, if general, is decoded in the main program.  The
CD     destination atom name is decoded within routine bndlst.  Bonds are found
CD     in the usual way, but in this option they are also considered for
CD     output to a file (default extension .slk which can be concatenated
CD     with a CDF, to be used to give such bonds as slack constraints
CD     in a least squares program.
CD     This use of the program may generate both L ATOM cards and L BOND
CD     cards,  as the destination atoms only possess labels if they are
CD     within the original, central unit cell. The program must generate
CD     its own names for atoms on such cards.  It uses ato<n> for a
CD     new atom, where n is the serial number  of the atom in its list,
CD     and bon<n> for a new bond.
CD
CD     A B ANGL card causes L ANGL  cards to be written for later
CD     use in slack constraints.
CD     It has the format:
CD            name1,  name2,  name3,  angle1,  sd1,  angle2,  sd2,
CD            optional (bmax, sdmax)
CD     All names are general;  the angles are at name2,
CD     between bonds going to name1 and name3, or any of their
CD     related equivalents.  If bmax and sdmax are given,
CD     such bonds must be of length bmax+-sdmax.
CD     In order to be considered, an angle must be of magnitude
CD     angle1+-sd1.  The L ANGL card which is written contains
CD     angle2 and sd2.  An L ANGL card also needs a name, which
CD     is generated as ang<n>.
C
CI The crystal data file (CDF) must contain:
CI     S cards giving the symmetry
CI     a  C card with the cell dimensions
CI      and if bond esd's are required
CI     a C SD card giving the esd's in the cell parameters
CI     A cards defining the atom names and positions
CI      and if bond esd's are required
CI     A SD cards giving the esd's in the atomic parameters
CI     B cards as described above and in the Users' manual
C
CO The usual listing file reporting data read from the CDF. It also
CO contains lists of the bond lengths and angles which were requested.
CO
CO If a B SLAK card is read a file, default extension .slk, which
CO can be concatenated with a CDF in order to impose the slack
CO constraints requested on B cards (see description above) in a least
CO squares refinement.
CO
CO If a B FILE card is read a machine readable list of bonds and angles is
CO generated. If the word following FILE on the card looks like a file name the
CO list is written to this file. If not the user is asked for a file name.
C
CR The only intervention needed on the part of the user is to give the
CR name of the CDF and, if a B SLAK card is present, to choose a name
CR for the file (default extension .slk) in which to write the L BOND,
CR L ATOM and L ANGL cards gnerated.
C
C
      LOGICAL BOTH
      LOGICAL ONCARD
      CHARACTER *4 BWD(6),NAMES(30),GENNAM
      DIMENSION K(6)
/ATNAM/
/ATNMPK/
/BANERR/
/BONDLA/
/CELPAR/
/IOUNIT/
/POSNS/
/SCRACH/
C
      DATA BWD/'BOND','BOTH','ANGL','SLAK','BMAX','BMIN'/
C
      CALL PREFIN('BONDS')
C
C DECIDE WHETHER JUST BOND PRINTING, OR MAKING CARDS TO DRIVE SLACK CONSTRAINTS:
      CALL FINDCD('B','SLAK',4,0,LCD)
      SLK=(LCD .NE. 0)
      IF (SLK) CALL CENTRE(LPT,2,'Card Generation for geometric '//
     & 'slack constraints',80)
      IF (.NOT. (SLK)) CALL CENTRE(LPT,2,'Bond lengths and '//
     & 'angles program',80)
C123 Is a machine readable output required?
      CALL FINDCD('B','FILE',4,0,LBOND)
      IF (LBOND.NE.0) THEN
        CALL RDWORD(NAMFIL,L,7,IPT,27,-1,IER)
        IF (IER.EQ.0) THEN
          MESSAG=NAMFIL
          IF(INDEX(MESSAG,".") .NE.0 .OR. L .GT.6) THEN
            IF (L.GT.10) L=10
            IOPN=222
          ELSE
            IOPN=22
          ENDIF
        ELSE
          MESSAG= 'Bonds and angles file'
          IOPN=12
        ENDIF
        LBOND=NOPFIL(IOPN)
      ENDIF
      CALL SYMOP
      CALL OPSYM(1)
      CALL RECIP
C NEED POSITIONS (AND THEREFORE CELL AND SYMMETRY)
      CALL ATOPOS
C
C SET UP PACKED ATOM SPECIFICATIONS:
      K(1)=NATOM
      K(2)=-48
      K(3)=4
      K(4)=-2
      K(5)=-2
      K(6)=-2
      CALL NPACK(ITEMP,K,6,0,ATPACK)
C
C IF FOR SLACK, OPEN UNIT ON TO WHICH TO WRITE EXTRA CARDS:
      IF (SLK) THEN
        MESSAG='Geometric constraint file'
        NAMFIL='.SLK'
        LSK=NOPFIL(112)
C AND START COUNTS FOR GENERATED ATOM, BOND AND  ANGLE NAMES:
        NTARNM=0
        NUMBON=0
        NUMANG=0
      ELSE
        BMAX=2.
        IF (ONCARD('I','BMAX',BMAX) .OR. ONCARD('B','BMAX',BMAX))
     &   WRITE (LPT,2001) BMAX
2001    FORMAT (/' Maximum bond to print =',F12.5)
        BMIN=0.
        IF (ONCARD('I','BMIN',BMIN) .OR. ONCARD('B','BMIN',BMIN)) THEN
          IF (BMIN .GT. 0.) WRITE (LPT,2002) BMIN
2002      FORMAT (/' Minimum bond to print =',F12.5)
        ENDIF
      ENDIF
      BONOUT=.FALSE.
C
C Are esd's required?
      CALL FINDCD('B','BESD',4,0,LCD)
      BNDESD=(LCD .GT. 0)
      CALL FINDCD('B','AESD',4,0,LCD)
      ANGESD=(LCD .GT. 0)
C CHECK HERE THAT esd's of parameters have been read
      IF (BNDESD .OR. ANGESD) THEN
        IF (BNDESD .AND. ANGESD) THEN
        WRITE (LPT,2008)
 2008 FORMAT(' Standard Deviations in bond lengths and angles ',
     &   'to be calulated')
        ELSE
          IF (BNDESD) WRITE (LPT,2006)
 2006 FORMAT(' Standard Deviations in bond lengths to be calulated')
          IF (ANGESD) WRITE (LPT,2007)
 2007 FORMAT(' Standard Deviations in angles to be calulated')
        ENDIF
        IF (.NOT. SDCELL) THEN
          IF (.NOT. ATESDS) THEN
            CALL ERRMES(1,1,
     &      'BOND Esd''s required but no cell or atom esd''s given')
          ELSE
            CALL ERRMES(1,-1,
     &      'BOND Esd''s required but no cell esd''s given')
          ENDIF
        ELSE
          IF (.NOT. ATESDS) THEN
            WRITE (LPT,2005)
            WRITE (ITO,2005)
          ENDIF
          CALL RELCL6
        ENDIF
      ENDIF
 2005 FORMAT('** WARNING ONLY: BOND Esd''s required but no ATOM ',
     &      'esd''s given')
C FIRST SCAN FOR 'BOND' CARDS:
      BOTH = .FALSE.
      CALL FINDCD('B','BONDS',4,0,LCD)
C OUT  IF NO DISTANCES CALLED FOR, TO TRY ANGLES
      IF (LCD .LE. 0) GO TO 2
C
C CHECK here for errors in input
      CALL ERRMES(0,0,'to BONDS')
      CALL MESS(LPT,2,'Interatomic distances')
C SET "LOOKING FOR WORD BOND"
      LIN=1
      CALL NEWLIN(LPT)
      CALL NEWLIN(LPT)
C JOIN HERE IF BOTH BONDS AND ANGLES REQUIRED
C I1LAST HOLDS SERIAL NUMBER OF LATEST SOURCE ATOM BEFORE THIS ONE
   3  I1LAST=9999
      IF (ICARD(3:6).NE.BWD(LIN)) GO TO 7
      GO TO 4
C
   7  CALL FINDCD('B',BWD(LIN),4,LCD,LCD)
C J IF NO MORE B BOND CARDS (OR B BOTH CARDS NEXT TIME ROUND)
      IF (LCD .LE. 0) GO TO 2
   4  CALL MESS(LPT,1,'Interpreting card saying:')
      CALL MESS(LPT,0,ICARD)
C IF SLAK, READ GENERAL ATOM NAMES:
      IF (SLK) THEN
        IPT=7
        DO 30 J=1,7
        CALL RDWORD(NAMES(J),LEN,IPT,IPT,80,0,IER)
        IF (IER .NE. 0) GO TO 33
  30    CONTINUE
C
        CALL ERRMES(1,-1,'too many labels')
        GO TO 7
C
C READ LENGTHS & ESDS:
  33    CALL RDREAL(BON1,IPT,IPT,80,IER)
        IF (BON1 .EQ. 0.) CALL ERRMES(1,0,'no max bond')
        CALL RDREAL(SD1,IPT,IPT,80,IER)
        CALL RDREAL(BON2,IPT,IPT,80,IER)
        CALL RDREAL(SD2,IPT,IPT,80,IER)
        NUM=J-1
        BMAX=BON1+SD1
        BMIN=BON1-SD1
      ELSE
        CALL RDWRDS(NAMES,7,30,NUM,IER)
      ENDIF
C J IF ALL BONDS REQUIRED
      IF (NUM .EQ. 0) GO TO 8
C IF ALL BONDS FROM ONE ATOM:
      IF (NUM .EQ. 1) GO TO 12
C HERE THERE IS MORE THAN ONE LABEL ON THE CARD - TREAT EACH AS SOURCE:
      DO 5 II=1,NUM
C INTERPRET SOURCE ATOMS AS GENERAL:
      DO 31 I1=1,NATOM
      IF (NAMES(II) .NE. ATNAME(I1) .AND. GENNAM(ATNAME(I1))
     &  .NE. NAMES(II)) GO TO 31
C
      IF (BOTH) II1=1
      IF (.NOT. BOTH) II1=II+1
      IF (II1 .GT. NUM) GO TO 5
      DO 6 JJ=II1,NUM
      IF (JJ .NE. II) CALL BNDLST(ATNAME(I1),NAMES(JJ))
   6  CONTINUE
C IF BOTH BONDS & ANGLES REQUIRED, USE STORED BONDS TO DO ANGLES
      IF (BOTH) CALL ANGLST(I1)
  31  CONTINUE
   5  CONTINUE
      GO TO 7
C
C
C HERE IF CARD SIMPLY SAYS "B BOND" AND WANTS ALL DISTANCES
C OR "B BOTH" FOR ALL ANGLES, ALL DISTANCES
   8  DO 35 I1=1,NATOM
C SECOND CYCLE NOT OVER ALL.  FIRST ATOM USED TO BE PUT INTO CENTRAL CELL,
C AFTER WHICH IT WAS USUALLY THE CASE THAT CONSIDERING ONLY THOSE ATOMS WHICH
C FOLLOWED IT WOULD GIVE ENOUGH EXAMPLES OF THE REQUIRED BONDS TO SATISFY.
C NOW THE CENTRAL ATOM IS LEFT ALONE (SO THAT IF IT CAME IN NEGATIVE, THE
C EXAMPLE OF IT WOULD STAY NEGATIVE.  IF THIS SCHEME DOES NOT GIVE ENOUGH
C BONDS WE CAN EXTEND THE SEARCH AREA.
      DO 36 I2=I1,NATOM
      CALL BNDLST(ATNAME(I1),ATNAME(I2))
  36  CONTINUE
      IF (BOTH) CALL ANGLST(I1)
  35  CONTINUE
      GO TO 7
C
C HERE IF ONLY 1 LABEL GIVEN - WANT ALL BONDS FROM THIS ONE SOURCE
C THE SOURCE MAY HAVE BEEN GIVEN AS A GENERAL ATOM - IF SO, CYCLE OVER ALL ITS
C RELATED ATOMS HERE, TO COLLECT TOGETHER IN A GROUP ALL THE BONDS FROM THE
C ONE ATOM:
  12  DO 27 I1=1,NATOM
      IF (NAMES(1) .NE. ATNAME(I1) .AND. GENNAM(ATNAME(I1))
     &  .NE. NAMES(1)) GO TO 27
      DO 26 I2=1,NATOM
      CALL BNDLST(ATNAME(I1),ATNAME(I2))
  26  CONTINUE
      IF (BOTH) CALL ANGLST(I1)
  27  CONTINUE
      GO TO 7
C
C NO MORE B BOND (OR B BOTH) CARDS:
   2  IF (BOTH) GO TO 100
      LCD=0
  17  CALL FINDCD('B','ANGL',4,LCD,LCD)
C J IF NO MORE B ANGL CARDS
      IF (LCD .LE. 0) GO TO 16
      CALL MESS(LPT,2,'Interpreting card saying:')
      CALL MESS(LPT,0,ICARD)
C
C IF WRITING CARDS FOR GEOMETRIC CONSTRAINTS:
      IF (.NOT. SLK) GO TO 43
C CONTROL AS FOR B BOTH - COLLECT A LIST OF USEFUL BONDS WITHOUT PRINTING THEM
      BONOUT=.TRUE.
      IPT=7
      DO 39 I=1,3
  39  CALL RDWORD(NAMES(I),L,IPT,IPT,80,0,IER)
      CALL RDREAL(ANG1,IPT,IPT,80,IER)
      CALL RDREAL(SD1,IPT,IPT,80,IER)
      CALL RDREAL(ANG2,IPT,IPT,80,IER)
      CALL RDREAL(SD2,IPT,IPT,80,IER)
C READ OPTIONAL MAX BOND AND SD FOR ANGLE CONSIDERATION:
      CALL RDREAL(BBMAX,IPT,IPT,80,IER)
      CALL RDREAL(SDMAX,IPT,IPT,80,IER)
C BBMAX AND SDMAX MAY BE ABSENT:
      IF (BBMAX .LE. 0.) THEN
        BMAX=CELL(1,1,1)/4.
        BMIN=0.
        IF (ONCARD('I','BMAX',B)) BMAX=B
        IF (ONCARD('I','BMIN',B)) BMIN=B
        IF (ONCARD('B','BMAX',B)) BMAX=B
        IF (ONCARD('B','BMIN',B)) BMIN=B
      ELSE
        BMAX=BBMAX+SDMAX
        BMIN=BBMAX-SDMAX
        IF (BMAX .EQ. BMIN) BMIN=0.
      ENDIF
C
C TREAT CENTRAL ATOM (**NB THE SECOND NAME, NOT THE FIRST) AS GENERAL:
      DO 37 I1=1,NATOM
      IF (NAMES(2) .NE. ATNAME(I1) .AND. GENNAM(ATNAME(I1))
     &  .NE. NAMES(2)) GO TO 37
      CALL BNDLST(ATNAME(I1),NAMES(1))
      IF (NAMES(3) .NE. NAMES(1)) CALL BNDLST(ATNAME(I1),NAMES(3))
      CALL ANGLST(I1)
  37  CONTINUE
      GO TO 17
C
C FIND LABELS FOR ANGLES IN SETS OF 3:
  43  CALL MESS(LPT,1,'Interatomic angles:')
      CALL MESS(LPT,0,' Atom1-Atom2-Atom3       Angle')
      CALL RDWRDS(NAMES,7,30,NUM,IER)
      DO 15 I=1,NUM,3
      I1=IATOM(NAMES(I))
      IF (I1 .GT. 0) GO TO 20
      CALL ERRATM(NAMES(I),-1,'atom for angle in BONDS')
      GO TO 15
  20  I2=IATOM(NAMES(I+1))
      IF (I2 .GT. 0) GO TO 19
      CALL ERRATM(NAMES(I+1),-1,'atom for angle in BONDS')
      GO TO 15
  19  I3=IATOM(NAMES(I+2))
      IF (I3 .GT. 0) GO TO 18
      CALL ERRATM(NAMES(I+2),-1,'atom for angle in BONDS')
      GO TO 15
  18  A=BONDA(I1,I2,I3)
      WRITE(LPT,2010) NAMES(I),NAMES(I+1),NAMES(I+2),A
2010  FORMAT (1X,A4,' - ',A4,' - ',A4,F12.2)
  15  CONTINUE
      GO TO 17
C
C NOW LOOK FOR ANY B BOTH CARDS
  16  BONOUT=.FALSE.
      CALL FINDCD('B','BOTH',4,0,LCD)
      IF (LCD .LE. 0) GO TO 100
      CALL MESS(LPT,1,'Distances to be used in angle calculations:')
      CALL NEWLIN(LPT)
      BOTH=.TRUE.
      LIN=2
C ARRANGE TO USE SAME CODE AS FOR B BOND
      GO TO 3
C
 100  STOP
      END
C
C
C
C
C LEVEL 50      PROGRAM CALMMP
      PROGRAM CALMMP
C
C *** CALMMP updated by PJB 4 Jun 92 ***
C
C ****************************************************************************
C
C                              C A L M M P
C
C      TO READ INDICES AND CALCULATE AND OUTPUT MAGNETIC STRUCTURE
C         FACTORS USING MULTIPOLE FORM FACTORS, AVERAGING OVER
C                    DIFFERENT DOMAINS IF PRESENT
C
C ****************************************************************************
CC 18D
CH To calculate multipole magnetic structure factors for a given list of indices.
C
CD CALMMP reads a list of indices of magnetic reflections and
CD calculates their magnetic structure factors using multipole form factors.
C
CI The crystal data file must contain all cards needed for magnetic
CI and nuclear structure factor calculations vis:
CI       S cards giving the symmetry.
CI       A C card with the cell dimensions.
CI       A cards defining the atoms, their positions and isotropic
CI       temperature factors.
CI       F cards giving the  magnetic and non-magnetic scattering
CI       factors
CI       P cards defining the multiopoles to use
CI       Q cards defining the magnetic structure
CI       W ROTN cards to describe the orientations of the multipole axes
CI optionally:
CI       T cards giving anisotropic temperature factors
C
CO A listing file which reports the structural data read from the CDF and
CO gives a list of the reflections, their \sinth\ values the real and
CO imaginary parts A and B of their structure factors and the real and
CO imaginary parts of the three components of the magnetic interaction
CO vector for the fundamental domain. These are followed by the squares of
CO the nuclear and magnetic scattering amplitudes, the total squared
CO scattering amplitude and the reflection multiplicity,
C
CO Optionally an output file containing hkl, A,B, and the the real
CO and imaginary parts of the three components of the magnetic interaction
CO vector for the fundamental domain can also be written. FORMAT (3I5,8F10.4)
CO if the magnetic reflections have integer indices, (3F8.3,8F10.4) if not.
C
CR On running the program the user is asked for the name of the crystal
CR data file and the name of the file containing the list of reflection
CR indices; also to choose whether to record the results to
CR file, and if the answer is yes to choose a file name.
C
      COMPLEX FCALC
      LOGICAL OUTPUT,ISPABS,SAYS,LATABS,MAGABS
      CHARACTER*132 VFMT
      DIMENSION H(3),K(3),A(6)
/BRAGG/
/CARDRC/
/CONSTA/
/DGEOM/
/IOUNIT/
/MAGDAT/
/MPODA/
/QCAL/
/SATELL/
/SCRACH/
      DATA VFMT/'(5X,''h'',3X,''k'',3X,''l'',1X,
     & '' SinTheta/l |Fnucl|   |Fmagn|    Fsqrd''/)'/
C
      CALL PREFIN('CALMMP')
      LUN=NOPFIL(1)
C
      CALL ASK('Store structure factors on file? Y or N')
      OUTPUT=(SAYS('Y'))
C
C  SET UP CRYSTALLOGRAPHY
C  ONLY SOME OF SETFC HERE, REST AFTER DOMAG1(1)
      CALL SYMOP
      CALL OPSYM(1)
      CALL RECIP
      CALL ATOPOS
      CALL SETANI
      CALL EXTINC(1,0.)
C READ Q CARDS
      CALL DOMAG1(1)
C DOMAG1 must be before PFSET so that magnetic atoms and form factors are
C recognised
      CALL PFSET
C
      CALL SETFOR
      CALL PFOUT
C
C FIND MAGNETIC CONSTRAINTS
      CALL MAGCNC
      CALL DOMAG1(2)
      CALL ERRMES(0,0,'in CALMMP')
C
C  HEADING
      LIN=3
      IF (IPROP.GT.0) VFMT(1:24)='(5X,''h'',7X,''k'',7X,''l'',4X'
      IF (OUTPUT) THEN
        LPT1=NOPFIL(2)
        CALL INPUTN(LPT1)
        LIN=LIN+1
        CALL MESS(LPT,0,'Nuclear and Magnetic structure factors '//
     & 'and Total cross-sections output to '//NAMFIL)
      ENDIF
      CALL CENTRE(LPT,100,'***** Calculation of Magnetic and Nuclear'//
     & ' Structure Factors ***** ',90)
      CALL MESS(LPT,1,' ')
      WRITE (LPT,VFMT)
C
C  READ REFLECTION INDICES
    1 READ (LUN,1001,END=101) ICARD
 1001 FORMAT (A80)
      CALL RDNUMS(A,1,6,NUM,IER)
      IF (NUM.LT.3 .OR. IER.NE.0) GO TO 1
      CALL GMEQ(A,H,3,1)
      STHL=VCTMOD(0.5,H,2)
C  CALCULATE MAGNETIC AND NUCLEAR STRUCTURE FACTORS
      FMCMOD=0.
      FMCSQR=0.
      IF (.NOT.MAGABS(H,IK)) CALL FMMPCA(H,FMCMOD,FMCSQR)
      FC=0.
      IF (.NOT.LATABS(H)) FC=CABS(FCALC(H))
      FSQR=FC*FC+FMCSQR
C
      IF (IPROP.LE.0) THEN
        CALL INDFIX(H,K)
C fudge for cr2o3
        call cmrsca(fmc,fmc,1./valmub,3,1)
        WRITE (LPT,2200) K,STHL,FC,FMCMOD,FSQR
 2200   FORMAT (1X,3I4,2X,F8.4,3F10.4)
        IF (OUTPUT) WRITE (LPT1,2008) K,FC,FMCMOD,FSQR,fmc(3)
2008    FORMAT (3I5,6F10.4)
      ELSE
        WRITE (LPT,2201) H,STHL,FC,FMCMOD,FSQR
2201    FORMAT (1X,3F8.3,2X,F8.4,3F10.4)
        IF (OUTPUT) WRITE (LPT1,2008) H,FC,FMCMOD,FSQR,fmc(3)
2009    FORMAT (3F6.3,6F10.4)
      ENDIF
   21 CONTINUE
      GO TO 1
C
  101 STOP
      END
C
C
C
C
C LEVEL 50      PROGRAM  CALMPL
      PROGRAM  CALMPL
C
C ***  CALMPL  made from GETMPL by PJB April 2003 ***
C
C ****************************************************************************
C
C                              C A L M P L
C
C         TO READ INDICES AND CALCULATE AND OUTPUT STRUCTURE
C         FACTORS USING MULTIPOLE FORM FACTORS, AVERAGING OVER
C                    DIFFERENT DOMAINS IF PRESENT
C
C ****************************************************************************
CC 18D
CH To calculate multipole structure factors for a given list of indices.
C
CD  CALMPL  reads a list of  of  reflection indices and
CD calculates their structure factors using multipole form factors.
C
CI The crystal data file must contain all cards needed for magnetic
CI and nuclear structure factor calculations vis:
CI       S cards giving the symmetry.
CI       A C card with the cell dimensions.
CI       A cards defining the atoms, their positions and isotropic
CI       temperature factors.
CI       F cards giving the  magnetic and non-magnetic scattering
CI       factors
CI       P cards defining the multiopoles to use
CI       W ROTN cards to describe the orientations of the multipole axes
CI optionally:
CI       T cards giving anisotropic temperature factors
C
CO A listing file which reports the structural data read from the CDF and
CO gives a list of the reflections, their \sinth\ values the real and
CO imaginary parts A and B of their structure factors
CD These are followed by the smodulus of the scattering amplitude
CO  and the reflection multiplicity,
C
CO Optionally an output file containing hkl, A,B, can also be written.
CO FORMAT (3I5,2F10.4)
C
CR On running the program the user is asked for the name of the crystal
CR data file and the name of the file containing the list of reflection
CR indices; also to choose whether to record the results to
CR file, and if the answer is yes to choose a file name.
C
      COMPLEX FMPCAL,FC
      LOGICAL OUTPUT,SAYS
      DIMENSION H(3),K(3),A(6)
/BRAGG/
/CARDRC/
/CONSTA/
/FORMDA/
/IOUNIT/
/MPODA/
/POLFOR/
/SCRACH/
      DATA VFMT/'(5X,''h'',3X,''k'',3X,''l'',1X,
     & '' SinTheta/l    A        B|     Fmod''/)'/
C
      CALL PREFIN('CALMPL')
      LUN=NOPFIL(1)
C
      CALL ASK('Store structure factors on file? Y or N')
      OUTPUT=(SAYS('Y'))
C
C  SET UP CRYSTALLOGRAPHY
      CALL SYMOP
      CALL OPSYM(1)
      CALL RECIP
      CALL ATOPOS
      CALL SETANI
C
      CALL PFSET
      CALL SETFOR
      CALL PFOUT
      CALL ERRMES(0,0,'to CALMPL')
C
C  HEADING
      CALL CENTRE(LPT,100,
     & '***** CALCULATION OF STRUCTURE FACTORS ***** ',74)
      LIN=3
      IF (OUTPUT) THEN
        LPT1=NOPFIL(2)
        LIN=LIN+1
        CALL MESS(LPT,0,
     & '                   Structure factors output to '//NAMFIL)
      ENDIF
C
C  READ REFLECTION INDICES
    1 READ (LUN,1001,END=101) ICARD
 1001 FORMAT (A80)
      CALL RDNUMS(A,1,6,NUM,IER)
      IF (NUM.LT.3 .OR. IER.NE.0) GO TO 1
      CALL GMEQ(A,H,3,1)
      STHL=VCTMOD(0.5,H,2)
C  CALCULATE MAGNETIC AND NUCLEAR STRUCTURE FACTORS
      FC=FMPCAL(H)
      FCMOD=CABS(FC)
C
      CALL INDFIX(H,K)
      WRITE (LPT,2200) K,STHL,FC,FCMOD
 2200 FORMAT (1X,3I4,2X,F8.4,3F10.4)
      IF (OUTPUT) WRITE (LPT1,2008) K,FC
2008  FORMAT (3I5,2F10.4)
      GO TO 1
C
  101 STOP
      END
C
C
C
C
C LEVEL 50      PROGRAM CALMSF
      PROGRAM CALMSF
C
C *** CALMSF updated by PJB 4 Jun 92 ***
C
C ****************************************************************************
C
C                              C A L M S F
C
C      TO READ INDICES AND CALCULATE AND OUTPUT MAGNETIC STRUCTURE
C          FACTORS AVERAGING OVER  DIFFERENT DOMAINS IF PRESENT
C
C ****************************************************************************
CC 17D
CH To calculate the magnetic structure factors for a given list of indices.
C
CD CALMSF reads a list of indices of magnetic reflections and
CD calculates their magnetic structure factors.
C
CI The crystal data file must contain all cards needed for magnetic
CI and nuclear structure factor calculations vis:
CI       S cards giving the symmetry.
CI       A C card with the cell dimensions.
CI       A cards defining the atoms, their positions and isotropic
CI       temperature factors.
CI       F cards giving the  magnetic and non-magnetic scattering
CI       factors
CI       Q cards defining the magnetic structure
CI optionally:
CI       T cards giving anisotropic temperature factors
C
CO A listing file which reports the structural data read from the CDF and
CO gives a list of the reflections, their \sinth\ values the real and
CO imaginary parts A and B of their structure factors and the real and
CO imaginary parts of the three components of the magnetic interaction
CO vector for the fundamental domain. These are followed by the squares of
CO the nuclear and magnetic scattering amplitudes, the total squared
CO scattering amplitude and the reflection multiplicity,
C
CO Optionally an output file containing hkl, A,B, and the the real
CO and imaginary parts of the three components of the magnetic interaction
CO vector for the fundamental domain can also be written. FORMAT (3I5,8F10.4)
CO if the magnetic reflections have integer indices, (3F8.3,8F10.4) if not.
C
CR On running the program the user is asked for the name of the crystal
CR data file and the name of the file containing the list of reflection
CR indices; also to choose whether to record the results to
CR file, and if the answer is yes to choose a file name.
C
      EXTERNAL DOMAG1
      COMPLEX FCALC
      LOGICAL OUTPUT,SAYS,LATABS,MAGABS
      CHARACTER*132 VFMT
      DIMENSION H(3),K(3)
/BRAGG/
/CARDRC/
/DGEOM/
/IOUNIT/
/SATELL/
/SCRACH/
      DATA VFMT/'(5X,''h'',3X,''k'',3X,''l'',1X,
     & '' SinTheta/l |Fnucl|   |Fmagn|    Fsqrd''/)'/
C
      CALL PREFIN('CALMSF')
      LUN=NOPFIL(1)
C
      CALL ASK('Store structure factors on file? Y or N')
      OUTPUT=(SAYS('Y'))
C
C  SET UP CRYSTALLOGRAPHY
      CALL SETFCM(DOMAG1)
C FIND MAGNETIC CONSTRAINTS
      CALL MAGCNC
      CALL DOMAG1(2)
      CALL ERRMES(0,0,'in CALMSF')
C
C  HEADING
      LIN=3
      IF (IPROP.GT.0) VFMT(1:24)='(5X,''h'',7X,''k'',7X,''l'',4X'
      IF (OUTPUT) THEN
        LPT1=NOPFIL(2)
        CALL INPUTN(LPT1)
        LIN=LIN+1
        CALL MESS(LPT,0,'Nuclear and Magnetic structure factors '//
     & 'and Total cross-sections output to '//NAMFIL)
      ENDIF
      CALL CENTRE(LPT,100,'***** Calculation of Magnetic and Nuclear'//
     & ' Structure Factors ***** ',90)
      CALL MESS(LPT,1,' ')
      WRITE (LPT,VFMT)
C
C  READ REFLECTION INDICES
    1 READ (LUN,1001,END=101) ICARD
 1001 FORMAT (A80)
      CALL RDNUMS(H,1,3,NUM,IER)
      IF (NUM.NE.3 .OR. IER.NE.0) GO TO 1
      STHL=VCTMOD(0.5,H,2)
C  CALCULATE MAGNETIC AND NUCLEAR STRUCTURE FACTORS
      FMCMOD=0.
      FMCSQR=0.
      IF (.NOT.MAGABS(H,IK)) CALL FMCALC(H,FMCMOD,FMCSQR)
      FC=0.
      IF (.NOT.LATABS(H)) FC=CABS(FCALC(H))
      FSQR=FC*FC+FMCSQR
C
      IF (IPROP.LE.0) THEN
        CALL INDFIX(H,K)
        WRITE (LPT,2200) K,STHL,FC,FMCMOD,FSQR
 2200   FORMAT (1X,3I4,2X,F8.4,3F10.4)
        IF (OUTPUT) WRITE (LPT1,2008) K,FC,FMCMOD,FSQR
2008    FORMAT (3I5,3F10.4)
      ELSE
        WRITE (LPT,2201) H,STHL,FC,FMCMOD,FSQR
2201    FORMAT (1X,3F8.3,2X,F8.4,3F10.4)
        IF (OUTPUT) WRITE (LPT1,2008) H,FC,FMCMOD,FSQR
      ENDIF
      GO TO 1
C
  101 STOP
      END
C
C
C
C
C LEVEL 50      PROGRAM CALQSF
      PROGRAM CALQSF
C
C *** CALQSF updated by PJB/JBF 2 Jun 92 ***
C
C ****************************************************************************
C
C                              C A L Q S F
C
C      TO READ INDICES AND CALCULATE AND OUTPUT MAGNETIC INTERACTION
C                  VECTORS FOR DIFFERENT DOMAINS IF PRESENT
C
C ****************************************************************************
CC 17D
CH To calculate the magnetic interaction vectors for each domain for
CH a given list of indices. The results are given on polarisation axes.
C
CD CALMSF reads a list of indices of magnetic reflections and
CD calculates their magnetic interaction vectors. The interaction vectors
CD corresponding to each of the possible antiferromagnetic domains are listed
CD separately. The results are given on polarisation axes: x parallel to the
CD scattering vector, z perpendicular to the scattering plane and y completing
CD the right-handed Cartesian set).
C
CI The crystal data file must contain all cards needed for magnetic
CI and nuclear structure factor calculations vis:
CI       S cards giving the symmetry.
CI       A C card with the cell dimensions.
CI       A cards defining the atoms, their positions and isotropic.
CI       temperature factors.
CI       F cards giving the  magnetic and non-magnetic scattering
CI       factors
CI       Q cards defining the magnetic structure
CI optionally:
CI       T cards giving anisotropic temperature factors
CI and in addition:
CI       D cards giving the wavelength and crystal orientation
CI       are required.
C
CO A listing file which reports the structural data read from the CDF and
CO gives a list of the reflections, their \$\theta\$ values, the domain
CO number, the real and imaaginary parts of the three components of the
CO magnetic interaction vector for this domain and finally
CO the square of the magnetic scattering amplitude.
CO
CO Optionally an output file containing the same information as above can
CO also be written. FORMAT (3I5,F8.2,I5,6F10.4) if the magnetic
CO reflections have integer indices, (3F8.3,8.2,I5,6F10.4) if not.
C
CR On running the program the user is asked for the name of the crystal
CR data file and the name of the file containing the list of reflection
CR indices; also to choose whether to record the results to
CR file, and if the answer is yes to choose a file name.
C
      EXTERNAL DOMAG1
      COMPLEX FCALC,FC,QR(3)
      LOGICAL OUTPUT,SAYS,LATABS
      CHARACTER*132 VFMT
      DIMENSION H(3),POLI(3,3),K(3)
/BRAGG/
/CARDRC/
/DGEOM/
/IOUNIT/
/QCAL/
/SATELL/
/SYMMAG/
/SCRACH/
      DATA VFMT/'(4X,''h'',3X,''k'',3X,''l'',1X, ''    Theta  Ndom    AQ
     &y     BQy       AQz     BQz'',10X''Fnuclear      Fsqr(mag)''/)'/
C
      CALL PREFIN('CALQSF')
      LUN=NOPFIL(1)
C
      CALL ASK('Store structure factors on file? Y or N')
      OUTPUT=(SAYS('Y'))
C
C  SET UP CRYSTALLOGRAPHY
      CALL SETFCM(DOMAG1)
      CALL OPSYM(2)
      CALL SETDC
C SET 3RD POLARISATION AXIS PARALLEL TO OMEGA AXIS
      POLI(1,3)=UM(3)
      POLI(2,3)=UM(6)
      POLI(3,3)=UM(9)
C  ORTHOGONAL SYMMETRY ROTATION
      CALL ROTOSM(H,H,0,0)
C FIND MAGNETIC CONSTRAINTS
      CALL MAGCNC
      CALL DOMAG1(2)
      CALL ERRMES(0,0,'for CALQSF')
      NDTOT=NDOM*KCENT
C
C  HEADING
      LIN=3
      IF (IPROP.GT.0)VFMT(1:24)='(5X,''h'',7X,''k'',7X,''l'',4X'
      IF (OUTPUT) THEN
        LPT1=NOPFIL(2)
        CALL INPUTN(LPT1)
        LIN=LIN+1
        CALL MESS(LPT,0,'Components of Q in the plane of the '//
     & 'reflection and nuclear sfs output to '//NAMFIL)
      ENDIF
      CALL CENTRE(LPT,100,'***** Calculation of Magnetic Interaction'//
     & ' Vectors and Nuclear Structure Factors *****',95)
      CALL MESS(LPT,0,'             (y and z are in the plane hkl '//
     & 'with z parallel to the omega axis)')
C
      CALL MESS(LPT,1,' ')
      WRITE (LPT,VFMT)
C  READ REFLECTION INDICES
    1 READ (LUN,1001,END=101) ICARD
1001  FORMAT (A80)
      CALL RDNUMS(H,1,3,NUM,IER)
      IF (NUM.NE.3 .OR. IER.NE.0) GO TO 1
C
C  GET OTHER TWO POLARISATION AXES
      CALL ORTHO(H,POLI(1,1),2)
      CALL UNIVEC(POLI(1,1),STHL)
      STHL=STHL/2.
      CALL VECPRD(POLI(1,3),POLI(1,1),POLI(1,2))
      CALL UNIVEC(POLI(1,2),D)
C IF Z NOT PERPENDICULAR MAKE IT SO
      IF (ABS(D-1).GT..0001) CALL VECPRD(POLI(1,1),POLI(1,2),POLI(1,3))
      THETA=DEGREE(ASIN(STHL*WLGTH))
C  CALCULATE Q AND NUCLEAR STRUCTURE FACTORS
      CALL FMCALC(H,FMMOD,FMSQR)
      FC=0.
      IF (.NOT.LATABS(H)) FC=FCALC(H)
C
      DO 21 ND=1,NDTOT
      CALL CRMPRD(Q(1,ND),POLI,QR,1,3,3)
      IF (IPROP.LE.0) THEN
        CALL INDFIX(H,K)
        WRITE (LPT,2200) K,THETA,ND,(QR(I),I=2,3),FC,FMSQR
 2200   FORMAT (1X,3I4,2X,F8.2,I4,2X,2(2F8.4,2X),2X,2F8.4,F10.4)
        IF (OUTPUT) WRITE (LPT1,2008) K,THETA,ND,(QR(I),I=2,3),FC
2008    FORMAT (3I5,F8.2,I5,6F10.4)
      ELSE
        WRITE (LPT,2210) H,THETA,ND,(QR(I),I=2,3),FC,FMSQR
 2210   FORMAT (1X,3F8.3,2X,F8.2,I4,2X,2(2F8.4,2X),2X,2F8.4,2X,F10.4)
        IF (OUTPUT) WRITE (LPT1,2009) H,THETA,ND,(QR(I),I=2,3),FC
 2009   FORMAT (3F8.4,F8.2,I5,8F10.4)
      ENDIF
   21 CONTINUE
      GO TO 1
C
 101  STOP
      END
C
C
C
C
C LEVEL 50      PROGRAM CHILSQ
      PROGRAM CHILSQ
C
C *** CHILSQ restructured to use LSQCYC C4.19 March 2010 ***
C
C ****************************************************************************
C
C                       C H I L S Q
C
C
C MAIN PROGRAM FOR STRUCTURE FACTOR LEAST SQUARES REFINEMENT, OF
C MIXED NUCLEAR AND MAGNETIC STRUCTURE FACTORS WITH EXTINCTION CORRECTIONS
C Paramagnetic calculation with anisotropic susceptibility
C
C ****************************************************************************
C
CC 6D
CH Least squares refinement from magnetic structure factor data
CH (paramagnetic version)
C
CD Main program for least squares refinement, of magnetic structure factor data
CD from (possibly) mixed nuclear and magnetic reflections
CD Paramagnetic structure factors with anisotropic susceptibility
C
CI The crystal data file must contain all cards needed for magnetic
CI and nuclear structure factor calculations vis:
CI       S cards giving the symmetry.
CI       A C card with the cell dimensions.
CI       A cards defining the atoms, their positions and isotropic.
CI       temperature factors.
CI       F cards giving the  magnetic and non-magnetic scattering
CI       factors
CI       Q cards defining the magnetic structure (Q STYP PARA)
CI optionally:
CI       T cards giving anisotropic temperature factors
CI Additionally:
CI       L cards indicating which parameters should be refined
CI       REFI = 3  paramagnetic intensities
CI       REFI = 5 flipping ratios
CI       REFI = 7  asymmetries
CI       REFI =11   magnetised powder intensities
CI        are useful (see the CCSL users' manual)
CI       I cards which may have the words words NCYC, CYCL1, PRIN,
CI           MCOR and CONV
CI           NCYC the number of least squares cycles (default 3)
CI           CYC1 the number to be assigned to the first cycle (default 1)
CI           PRIN frequency at which output lists are printed
CI               PRIN = 0 no printing
CI               PRIN = 1 first cycle
CI               PRIN = 2 last cycle
CI               PRIN = 3 first and last cycles
CI               PRIN = 4 every cycle
CI           MCOR controls the correlations printed at the end of the job
CI               (default +70)
CI               MCOR = 0 whole correlation matrix printed
CI               MCOR = -ve no printing
CI               MCOR = +ve correlations above MCOR printed
CI           CONV convergence criterion; LSQ cycling is terminated if the
CI               maximum shift/esd < CONV (default 0.01)
CI The data file which should be a list of hkl and structure factors or
CI flipping ratios in the format indicated by the L MODE and REFI cards.
C
CO The usual listing file reporting the data which have been read. This file
CO also contains the output listings requested by the I PRIN card  as well as
CO the R-factors and chisqrd at the end of each least squares cycle.
CO A new crystal data file corresponding to the structure at the end of the
CO least squares refinement.
C
CR On running the program the user is asked for the name of the crystal data
CR file and the name of the file containing the structure factor data.
CR The value of \$\chi^2\$  at the end of each cycle is reported on the
CR terminal.
CR Just before the last cycle the user is asked for a name for the new crystal
CR data file.
C
C
      CHARACTER *4 ISFWRD(10)
      LOGICAL DFLTCH,DOCHI2
      EXTERNAL DFLTCH,LFCALC,DOCHI1,DOCHI2,PARRUN,VARSSF,SFDHED,
     &TCHALC
      DIMENSION ALSQ(10000)
      DIMENSION ISWDSP(3,10),MODES(9)
/BRAGG/
/CARDRC/
/DERBAS/
/DGEOM/
/DSOURC/
/EXTN/
/FCAL/
/IOUNIT/
/MAGCHI/
/MCAL/
/NEWOLD/
/OBSCAL/
/POLDA/
/POSNS/
/PRBLEM/
/REFINE/
/SCLDAT/
/SCRACH/
/SFDATA/
      COMMON /SFHEDC/FRMATS(6),HEDWDS(6)
      CHARACTER * 50 FRMATS,HEDWDS*4
      COMMON /SFHEDP/NHEAD,LHEAD(7),HMASK(6)
      LOGICAL HMASK
      DATA ISFWRD/
     & 'SCAL','DOMR','MOSC',
     & 'CH11','CH22','CH33','CH23','CH31','CH12',
     & 'CHIJ'/
      DATA ISWDSP/
     & 1,2,0, 1,1,8, 1,1,9,
     & 2,0,13, 2,0,14, 2,0,15, 2,0,16, 2,0,17, 2,0,18,
     & -8,0,0/
C BLOCK DATA F2PARS USED FOR SF PARS
C  THE ALLOWED OPTIONS FOR MODER IN CHILSQ ARE JUST:
C   3.   H,K,L,OBS,STANDARD DEVIATION OF OBS, (SCALE GROUP),(CODE)
C   5.   H,K,L,OBS,STD DEVN,C1 C2 C3 C4, WHERE C1-C4 ARE THE
C        CONSTANTS INVOLVED IN EXTINCTION CORRECTIONS
C   7.   H,K,L (FLOATING) OBS,STD DEVN,(SCALE GROUP), (CODE)
C   8.   H,K,L(FLOATING),OBS,STD DEVN,C1 C2 C3 C4, WHERE C1-C4
C        ARE THE CONSTANTS INVOLVED IN THE EXTINCTION CORRECTION
C   11.  H,K,L(FIXED OR FLOATING),2theta,INT(up) ESD(up) INT(dw) ESD(dw)
C BOTH THE SCALE GROUP AND CODE ARE OPTIONAL.  IF THE SCALE GROUP IS
C READ AS ZERO, IT WILL BE SET = 1.
C   THE CODE IS NOT AT PRESENT USED; IT IS ENVISAGED THAT IT MAY BE USEFUL
C IN REJECTING SELECTED OBSERVATIONS LATER.
      DATA NMODES,MODES/9,1,2,3,4,5,6,7,8,11/
CC
C ALTER VALUE HERE IF NECESSARY, WITH DIMENSION OF ALSQ:
%      MATSZ=%MATS%
C
C SET UP STRUCTURE FACTOR CALCULATION:
      CALL PREFIN('CHILSQ')
C
C SET "MAGNETIC"
      MAG=.TRUE.
      CHI=.TRUE.
C
C SET UP CRYSTALLOGRAPHY
      CALL SETFCM(DOCHI1)
C
C SPECIFY PROBLEM:
      NFAM=2
      NGENS(1)=2
      NGENS(2)=NATOM
      NSPC(1)=22
      NSPC(2)=18
C
C SPECIES TYPES FOR EACH GENUS OF FAMILY 1:
      LF1SP(1)=9
      LF1SP(2)=-20
C
C WORDS RELEVANT TO THIS PROBLEM FROM DATA INTO COMMON:
C C4.26 LOGICAL CHI now used by LSETSF
      CALL LSETSF(10,ISWDSP,ISFWRD)
C
C NAMES SET UP SO THAT:
C FAMILY 1 GENUS 1 HAS SPECIES TFAC, DOMR, MOSC (WITH PROVISION FOR
C A* ETC FOR GEOMETRIC CONSTRAINTS)
C   '    1    '  2 HAS GENUS NAME SCAL, SPECIES INDICATED TO BE 1,2,3 ETC
C
C FAMILY 2 IS AS USUAL THE PARAMETERS WHICH DEPEND ON THE ATOM.  GENUS NAMES
C ARE THEREFORE THE SAME AS ATOM NAMES, AND SPECIES NAMES ARE:
C X Y Z B11 B22 B33 B23 B13 B12 SCAT SITE ITF,
C THE MAGNETIC SUSCEPTIBILITY TENSOR COMPONENTS CH11, CH22 ...ETC
      CALL CENTRE(LPT,3,'Least Squares Refinement',80)
      CALL CENTRE(LPT,0,'Paramagnetic structure factors '//
     & 'program',80)
C
C READ I AND (MOST) L CARDS:
      CALL STLSSF
C READ E CARD:
      CALL EXTINC(1,0.)
C find out whether PATHs should be calculated
      PATHS =(IEXTYP.NE.0 .AND. ICDNO(7).NE.0)
      IF (PATHS) CALL SETABS
C
C These data now read for each data set
C  GET POLARISATION DIRECTION ETC, ALWAYS NEEDED
C
C
C SET UP PARAMETERS AS VARIABLES:
      CALL DOCHI1(2)
      CALL CHITRN

      CALL PARSSF(DOCHI2)
      CALL VARMAK(DFLTCH,PARRUN,VARSSF,DOCHI2)
C
C DATA HEADER NEEDS MAGNETIC FIELD
      NHEAD=NHEAD+1
      LHEAD(NHEAD+1)=LHEAD(NHEAD)+1
      FRMATS(NHEAD)='(''Magnetic Field'',f8.2,'' T'')'
      HEDWDS(NHEAD)='MAGN'
      HMASK(NHEAD)=.FALSE.
C Save the index of the magnetic field in SRCPAR
      MAGP=LHEAD(NHEAD)
C
C READ ALL THE DATA
      CALL DATASF(NMODES,MODES)
C
      CALL ERRMES(0,0,'for CHILSQ')
C
C Least squares cycles
      DONE=.FALSE.
      DO 1 ICYC=NCYC1,LASTCY
      CALL LSQCYC(ALSQ,MATSZ,LFCALC,TCHALC)
      CALL APSHSF(DOCHI2)
      IF (DONE) GO TO 39
      DONE=(AMAXSH.LT.CONV .OR. ICYC.EQ.LASTCY-1 .OR. NCYC.EQ.1)
C ON PENULTIMATE CYCLE PRODUCE NEW CRYSTAL DATA FILE:
      IF (DONE) CALL NWINSF(DOCHI2)
   1  CONTINUE
C
C PRINT CORRELATION MATRIX:
  39  CALL MATCOR(ALSQ,MATSZ)
C Calculate Induced moments
      CALL MUCALC(MAGP)
      STOP
      END
C
C
C
C
C
      LOGICAL FUNCTION DFLTCH(IFAM,IGEN,ISPC)
C
C *** DFLTCH  new by PJB 27 Apr 2001 ***
C
CX
CC 7A
CH Called as a substitute for DEFALT via VARMAK, giving default fix/vary
CH for otherwise unspecified parameters for magnetic structures.
C
CA On entry IFAM, ISPC, IGEN give family, genus, species of parameter
CA On exit LOGICAL DFLTMG is TRUE if the parameter is to be varied, or
CA                           FALSE if to be fixed.
CD For magnetic structures, fix all conventional structure parameters,
CD and vary all possible magnetic parameters.
C
/MAGDAT/
C
      DFLTCH=.TRUE.
      GO TO (1,2) , IFAM
      GO TO 101
C
C FAMILY 1 - DEFAULT FIX ALL
   1  GO TO 101
C
C FAMILY 2 - DEFAULT FIX NUCLEAR PARAMETERS:
   2  IF (ISPC .LE. 12) GO TO 101
C
C  FIX MAGNETIC PARS OF NON-MAGNETIC ATOMS
      IF (MAGAT(IGEN).EQ.0) GO TO 101
C
C  Vary all chis
      GO TO 100
C
C FIX:
 101  DFLTCH=.FALSE.
 100  RETURN
      END
C
C
C
C
C LEVEL 50      PROGRAM COMMON
      PROGRAM COMMON
C
C *** COMMON added for use by CCSL.FOR by PJB Sep 86 ***
C
C *****************************************************************************
C
C                       C O M M O N
C
C ARTIFICIAL MAIN PROGRAM TO GIVE USER ACCESS TO ALL GENERATED COMMON
C
C *****************************************************************************
/ABSDAT/
/ADASH/
/ANISO/
/ANSCAT/
/ARRDAT/
/ATBLOC/
/ATBLOK/
/ATNAM/
/ATNMPK/
/BANERR/
/BITMAP/
/BONDLA/
/BRAGG/
/CARDRC/
/CELFIX/
/CELPAR/
/CHARS/
/CONSTA/
/CONSTR/
/CONTUR/
/CPLANE/
/DEPMAT/
/DERBAS/
/DERVAR/
/DGEOM/
/DREAD/
/EXCREG/
/EXTN/
/FCAL/
/FCCDAT/
/FINAME/
/FOCDAT/
/FONAM/
/FORGRP/
/FORMDA/
/FORMD2/
/FRIED/
/FUDG/
/FUNIT/
/FWVALS/
/F2NAMS/
/F2NUMS/
/F4PARS/
/GAUSS/
/GKSDAT/
/GLOBAL/
/GRDBCK/
/GREAD/
/GUNIT/
/HKLGEN/
/IINFO/
/IINFOW/
/IOUNIT/
/LENINT/
/LINKAG/
/LOONEY/
/LREAD/
/LSQPAK/
/MAGDAT/
/MAPDA/
/MAPGT/
/MAPPR/
/MAPRD/
/MAPSV/
/MATDAT/
/MCAL/
/MPODA/
/MPODAC/
/MREAD/
/NEWOLD/
/NSYM/
/NTITL/
/OBSCAL/
/OLDSYM/
/OMITPR/
/ORTSYM/
/OVER/
/PAWLPR/
/PHAS0/
/PHASE/
/PLODAT/
/PLOMAP/
/PLOTCH/
/PLTRAN/
/PLTS/
/POINTS/
/POLDA/
/POLDAT/
/POLFOR/
/POLKA/
/POSNS/
/POSNS2/
/POSREL/
/PRABSC/
/PRBLEM/
/PREORI/
/PREXTN/
/PRNAMS/
/PRNUMS/
/PRPKCN/
/PRPKFN/
/PRSAVE/
/PRSAVF/
/PRSTAT/
/PRZERO
/PWORDS/
/QCAL/
/QCALD/
/QROT/
/RADINT/
/REFINE/
/REFIPR/
/REFLNS/
/REFS/
/RSTATS/
/SATELL/
/SCLDAT/
/SCRACH/
/SLAKDA/
/SLKGEC/
/SLKGEO/
/SOURCE/
/SPLBCK/
/STATS/
/SYMDA/
/SYMMAG/
/SYMREP/
/SYMTAB/
/THET2/
/TITLE/
/TTHMNC/
/WAVCHR/
/WAVEFN/
/WHEN/
/WDSPC/
/WORDS/
/ZEROPT/
      STOP
      END
C
C
C
C
C LEVEL 50      PROGRAM COMPAR
      PROGRAM COMPAR
C
C *** COMPAR updated by JBF/PJB/JCM Jul 87 ***
C
C ******************************************************************************
C
C                      C O M P A R
C
C  TO COMPARE TWO DATA SETS OUTPUT FROM ARRNGE
C  AND PRODUCE SOME STATISTICS
C ******************************************************************************
C
      DIMENSION LUN(2)
      CHARACTER*2 STREAM
      CHARACTER*10 FILNOM,TITLE
/CARDRC/
      COMMON/HEADNG/HEDING
      CHARACTER*180 HEDING
/IOUNIT/
/REFS/
/SCRACH/
/STATS/
C
      CALL PREFIN('COMPAR')
      IF (INREAD(9) .GT. 0) CALL INPUTI
      CALL ICDFMT(INC,ITEMS)
C
      DO 1 IS=1,2
    8 WRITE (STREAM,10) IS
   10 FORMAT (I2)
      CALL ASK('file-name for stream'//STREAM)
      CALL RDWORD(TITLE,LEN,1,IE,11,0,IER)
      IF (IER.EQ.0) GO TO 5
      CALL MESS(ITO,0,'File-name unreadable')
      GO TO 8
   5  SCALE(IS)=1.
      MESSAG=TITLE(1:LEN)
      NAMFIL='.ARR'
      LUN(IS)=NOPFIL(121)
      IF (LUN(IS).LT.0) GO TO 8
    1 CONTINUE
      HEDING(7:16)=FILNOM(LUN(1))
      HEDING(24:33)=FILNOM(LUN(2))
      WRITE (LPT,13) (FILNOM(LUN(I)),I=1,2)
   13 FORMAT (//22X,'****** COMPARISON of ',A10,' with ',A10,' ******')
      WRITE (LPT,HEDING)
      LINO=8
C
      CALL STATIS(-1)
      MODE=0
      CALL WTMEAN(X,DX,0,WRK1)
    6 IF (INPUAR(MODE,LUN).NE.0) GO TO 4
      IF (MATCH(K) .NE. 0) GO TO 6
C
    2 CALL STATIS(0)
      CALL TESTP(LPT,LINO,1,HEDING,3)
      WRITE (LPT,15) (K(I,1),I=1,3),(AMEAN(I),DEV(I),I=1,2),X,DX,RAT,
     & DRAT
   15 FORMAT (1X,3I5,4(2X,2F10.4))
      GO TO 6
C
C  HERE TO END
    4 CALL WTMEAN(X,DX,-1,WRK1)
      CHI=(WRK1(2)-X*WRK1(1))/(WRK1(4)-1.)
      WRITE (LPT,12) X,DX,CHI
   12 FORMAT (/' Ratio 2:1 is',F8.4,' +/-',F7.4,' with Chi-squared ',
     & F8.4)
      STOP
      END
C
C
C
C
      BLOCK DATA BLKHED
      COMMON/HEADNG/HEDING
      CHARACTER*180 HEDING
      DATA HEDING/'(23X,''          '',12X,''          '',13X,''Combin
     &ed'',16X,''Ratio''/''     h    k    l     Mean       Esd
     &Mean       Esd        Value      Esd        Value      Esd''/)'/
      END
C
C
C
C
C LEVEL 50      PROGRAM CRYPAD
      PROGRAM CRYPAD
C
C *** CRYPAD updated by PJB  10-March-2000 ***
C
C ***********************************************************************
C
C                           C R Y P A D
C
C
C                   DATA PROCESSSING FOR CRYOPAD II
C                 PGPLOT plotting routines added Aug 96
C
C ***********************************************************************
C
CC 2D
CH Processes data collected by the zero field neutron polarimeter CRYOPAD
C
CD Reads the data files, written by the zero field neutron
CD polarimeter CRYOPAD II, from the ILL ASCII data base and processes
CD them according to the chosen options.
CD The processing procedure depends upon the orders being processed
CD and it is not useful to process different classes of order in the
CD same run. The (presently 2) different classes are:
CD    A. Polarisation scans (MPF, MPT, MPA)
CD    B. Polarisation analysis (APO, API)
CD
CD Both classes give graphical output and require the PGPLOT
CD graphical library. On UNIX systems at ILL this requires the
CD environment variable PGPLOT\_DIR to be set to /usr/ill/lib. Issue
CD the command "setenv PGPLOT\_DIR /usr/ill/lib" or put it
CD in your .login file. On VMS systems the logical names required can
CD be set up by executing @ILLCOM:PGPLOT51\_LOGICAL or including it in
CD your LOGIN.COM file.
CD
CD A. Polarisation scans
CD    The program reads the scan and tries to fit the data points to
CD    a sinusiodal curve.
CD    For \$\theta\$ scans the amplitude and origin of the scan are
CD    varied to obtain a best fit. For \$\chi\$ scans the frequency is
CD    also varied. The results are written on the listing file and a
CD    graph is drawn giving the final fit.
CD B. Polarisation analysis
CD    For polarisation analysis orders the program reads the
CD    line given at the end of each cycle of the analysis which gives
CD    the current best estimate of the polarisation being analysed.
CD    Successive cycles are checked to ensure whether they are
CD    consistent within statistics. At the end of the last cycle the
CD    initial and final polarisation components are written on the
CD    output and listing files together with the current hkl value,
CD    the temperature, date, time, and any commentary which may have
CD    been given. A stereogram is plotted giving the incident and
CD    scattered polarisation directions with an information panel
CD    giving the magnitudes of the scattered polarisations.
CD    The results of several analyses may be drawn on the same
CD    stereogram. A new one will be started when hkl changes or when
CD    the temperature difference between successive analyses is
CD    greater than a preset value.
CI
CI A sequence of the ASCII data files written by CRYOPAD. These are
CI normally taken from the ILL database, but will be taken from the
CI path given in the environment variable CRPDATA if that is defined. The
CI current (Sept 1998) path for the ILL data base is /usr/illdata,
CI if another path is needed it can be given in the environment
CI variable ILLDATA. The sequence of files is terminated by a
CI missing file in the sequence:
CI      fname(n+1)= fname(n) + 1
CI where 9+1=a, a+1=b ... and z+1=10
C
CO A listing file which reports the processing which was done. It contains
CO the results of any fits made to scans and the components of incident
CO and scattered polarisations for any polarisation analyses.
CO
CO A file "dcards.cry" to which the UB matrix and wavelength are written
CO each time they change.
CO If analysis orders are being processed the final components of incident
CO and scattered polarisation are written to an file with extension .pol
CO together with the current hkl, temperature and commentary. This
CO file is suitable for reading by PALSQ.
CO A binary file comdat.bin which records the parameters which were
CO defined during the processing, and which will be reused in future
CO runs of CRYPAD which are not initialised.
CO
CO Finally if any hard copies of graphical output were requested
CO these are written to a postscript file whose name is reported on
CO exit from the program,
C
CR When running the program the user is asked whether to "Initialise"
CR or "Not" or whether to "Continue". The reply is "Y"es to start a new
CR experiment or if the common data have been changed since the last
CR run, i.e. the sample, experimental conditions, or wavelength are
CR different. Reply "C"ontinue to proceed without asking questions. If
CR the reply is C processing will continue from the next file in
CR sequence after the last processed in the previous run. The reply
CR should be "N"o if there is a break in the sequence of output files.
CR
CR If the reply is Y or N futher questions are posed to allow the
CR source of data to be identified. The replies to most questions
CR should be self evident. The cycle number is 0 or "return"
CR for the current cycle, -1 for the previous cycle otherwise
CR the 3 digit cycle number eg 964 for the 4th cycle in 1994.
CR
CR The first and optionally last files to
CR process should be in lower case without an extension.
CR
CR The orders to be processed should be one or more
CR of *MPF, *MPT, *MPA *APO *API. But as mentioned above it is not
CR usually useful to process both scan and analysis orders in the same run.
CR
CR Both scan and analysis orders produce graphical output and the user
CR is asked whether this output should be displayed on
CR an X terminal or a Tektronix emulator.
CR After each plot is finished the user is asked whether he wants a
CR hard copy, if the answer is yes a page containing the plot is added
CR to a postscript file.
CR When processing analysis orders the user is given the option before
CR each  stereogram is plotted, to plot it, not to plot it, or to
CR continue without making further plots. In this latter case the .pol
CR output file for all analyses will still be written.
C
      INTEGER PGOPEN
      CHARACTER *10 DUMNAM,COMNAM,PGFIL*12,TERM*8
      DIMENSION IDUM(4),ADUM(9),ICOMDA(41)
      CHARACTER*200 ICOMCH
      EQUIVALENCE(ICOMDA,ALAM),(ICOMCH,ISNAME)
      DIMENSION ICOM(15)
      LOGICAL START,BEGIN,SAID,CONT,RDCOM,CHGPAR,SAYS,PSCAN,CHNG
      CHARACTER*100 FMT1
      CHARACTER*1 IREP
      COMMON /ALWORD/KEY(5),CWORD(11),DWORD(4),OWORD(6),LWORD(16)
     &,MORD(10)
      CHARACTER*5 KEY,CWORD,DWORD,OWORD,LWORD
      CHARACTER *4 MORD
      COMMON/NLWORD/NKEY,NCOM,NDAT,NORDE,NLWORD,NMORD,
     &JANAL,LANG,LANAL,LMISC,LEND
     &,KCOMOF(12),KDATOF(4),KORDOF(6),LOFF(16)
/CRPDN/
/CRPDC/
      COMMON /GRAPH/INPLOT
      LOGICAL INPLOT
/IOUNIT/
/POLKA/
/SCAN/
      LOGICAL PFIXED,INTACT
      COMMON /HEDING/ HEADNG
      CHARACTER*132 HEADNG
/SCRACH/
      DATA COMNAM/'COMDAT.BIN'/
C
      CALL INITIL('CRYPAD')
      START=.TRUE.
      BEGIN=.TRUE.
      INPLOT=.FALSE.
      PLTING=.TRUE.
      IEND=.TRUE.
      COMENT=' '
      CALL UPONE(COMNAM,3)
C SET IPOL 1 AT START
      IPOL=1
C  TO CHOOSE APPEND FOR WRITE FILES
      INIT=124
C
C  SET UP
      LCOUNT=6
      CALL INITIL('CRYPAD')
   56 WRITE (ITO,220)
  220 FORMAT (/' INITIALISE ? Answer Y(es), N(o), C(ontinue)',
     &' or H(elp) : ',$)
      READ (ITI,221) IREP
  221 FORMAT (A1)
      IF (.NOT.SAID(IREP,'H')) GO TO 55
      WRITE (ITO,222)
  222 FORMAT ('/ Reply Yes if you are starting a new experiment or if
     &the common data have been'/' changed since the last run, i.e.
     &the sample, experimental conditions, or'/' wavelength are
     &different. Reply "C"ontinue to proceed without asking questions')
      GO TO 56
   55 CONT=SAID(IREP,'C')
      IF (.NOT.SAID(IREP,'N') .AND. .NOT.CONT) GO TO 59
      MESSAG=COMNAM
      ICOMU=NOPFIL(1021)
      LCOUNT=LCOUNT+1
      READ (ICOMU) ICOMDA,ICOMCH
      START=.FALSE.
      CALL CLOFIL(ICOMU)
C OVERWRITE ANY OTHER DEF OF IPOL AND PLTING
      IPOL=1
      PLTING=.TRUE.
      IF (CONT) GO TO 57
      CALL ASK('User is: '//IUNAME//' Sample is: '//ISNAME//
     &' OK ? Y(es) or N(o)')
      IF (.NOT. SAYS('Y')) GO TO 59
      LDIR=LENGT(DATDIR)
      CALL MESS(ITO,0,'Data will be read from '//DATDIR(1:LDIR)//IP1)
      CALL ASK('OK ? Y(es) or N(o)')
      IF (.NOT. SAYS('Y')) CALL INFILE
C
   57 IF (CONT) GO TO 64
      L=LENGT(OP2)
      WRITE (MESSAG,226) L
      WRITE(ITO,MESSAG)OP2,NSEQ
  226 FORMAT ('('' Results will be appended to file '',A',I3,
     &','' starting at sequence number'',I5)')
      CALL ASK('OK ? Y(es) or N(o)')
      IF (SAYS('Y')) GO TO 64
      CALL ASK('Give new output file-name')
      OP2=MESSAG
      INIT=122
      GO TO 61
C
C  COMMON DATA FILE NOT FOUND
   60 WRITE(ITO,228)COMNAM
  228 FORMAT (' Common data file ',A10,' was not found. Continue ?
     &Y(e)s or N(o) : ',$)
      READ (ITI,221)IREP
      IF (.NOT.SAID(IREP,'Y')) STOP
C
C  HERE TO INITIALISE
C  SET STATUS NEW FOR WRITE FILES
   59 INIT=122
   58 CALL INFILE
      CALL ASK('Give output file name')
      OP2=MESSAG
   61 NSEQ=1
      IF (CONT) GO TO 64
      WRITE (ITO,231)NSEQ
  231 FORMAT (' Processing will start with scan',I5,
     &' OK Y(es) or N(o): ',$)
      READ (ITI,221) IREP
      IF (SAID(IREP,'N')) THEN
       CALL ASK(' Give number of first scan to be processed')
        CALL RDINTG(ISEQ,1,IPT,10,IER)
      ENDIF
      IF (.NOT. START) GO TO 64
C     PUT IN THOSE CRPD INSTRUCTIONS TO BE PROCESSED IN THIS RUN
   63 WRITE(ITO,212)
  212 FORMAT (' Give the orders to be processed in this run, A4,1X,..
     &',$)
      READ (ITI,214) NORD
  214 FORMAT (11(A4,1X))
C     NOW RECOGNISE ORDERS AND SET MARKERS
   64 DO 51 I = 1,11
   51 ICOM(I) = 0
      PSCAN=.FALSE.
      DO 52 I = 1,11
      IF (NORD(I) .EQ. ' ') GO TO 54
C     END OF LIST
      DO 53 J = 1,NMORD
      IF (.NOT. SAID(NORD(I),MORD(J))) GO TO 53
      ICOM(J) = 1
      PSCAN=PSCAN .OR.(J.LE.4)
      GO TO 52
   53 CONTINUE
   52 CONTINUE
   54 NUMORD=I
      IF (START) GO TO 62
      IF (CONT) GO TO 62
      WRITE(ITO,303) (NORD(II),II=1,I)
  303 FORMAT (' The orders which will be processed are : ',9(A5))
      CALL ASK(' OK ? Y(es) or N(o) : ')
      IF (.NOT. SAYS('Y')) GO TO 63
   62 NAMFIL='.POL'
      MESSAG=OP2
      CALL UPONE(MESSAG,3)
      LUNO=NOPFIL(INIT)
      MESSAG='dcards.cry'
      CALL UPONE(MESSAG,3)
      NAMFIL=' '
      NEWIN=NOPFIL(INIT)
      IF (NUMORD .GT.0) THEN
C IF PROCESSING SCANS ASK WHETHER P FIXED ETC
        IF (PSCAN) THEN
          CALL ASK ('Fix the polarisation? (Y/N default N)')
          PFIXED=SAYS('Y')
          IF (PFIXED) THEN
            CALL ASK('Give value of polarisation to fix')
            CALL RDREAL(POLN,1,IPT,10,IER)
          ENDIF
          CALL ASK ('Interactive choice of starting values? '
     &//'(Y/N default N)')
          INTACT=SAYS('Y')
        ENDIF
C IF PROCESSING SCANS or analysis OPEN PLOTTER WINDOW
        CALL ASK('Display on Tektronix or X-terminal (T/X)')
        IF (SAYS('T')) THEN
          TERM='/TEK4010'
        ELSE IF (SAYS('X')) THEN
          TERM='/XWIN'
C C122 Remove putenv as it is not supported
C            CALL PUTENV('PGPLOT_XW_WIDTH=0.75')
        ELSE
          GO TO 20
        ENDIF
        PGFIL=HCNAME('ps;)
        L=LENGT(PGFIL)
        LDEV(2)=PGOPEN(PGFIL(1:L)//'/CPS')
        IF (LDEV(2).LT.0) STOP 'Error opening pgplot device 2'
        LDEV(1)=PGOPEN(TERM)
        IF (LDEV(1).LT.0) STOP 'Error opening pgplot device 1'
C Set black on white background
        CALL PGSCR(0,1.0,1.0,1.0)
        CALL PGSCR(1,0.0,0.0,0.0)
        INPLOT=.TRUE.
        PGHARD=.FALSE.
        CALL PGASK(.FALSE.)
      ENDIF
C
C  PUT OUT HEADING
      IF (START) GO TO 3
   36 START=.FALSE.
      WRITE (LPT,130)
      WRITE (LPT,131)
      WRITE (LPT,132) ISNAME,IUNAME
      J2=40-5*NUMORD
      J1=J2/2
      J2=J2-J1
      WRITE (FMT1,134) J2,NUMORD,J1+4
      WRITE (LPT,FMT1) (NORD(II),II=1,NUMORD)
      IF (IGEO(3) .LT.0) THEN
        WRITE (LPT,135) ALAM,'Negative'
      ELSE
        WRITE (LPT,135) ALAM,'Positive'
      ENDIF
      WRITE (LPT,131)
      WRITE (LPT,133)
  130 FORMAT ('0',25X,14('*****')/26X,'*',22X,'CRYOPAD DATA PROCESSING'
     &,23X,'*')
  131 FORMAT (26X,'*',68X,'*')
  132 FORMAT (26X,'*',14X,'Sample Name:',A8,'  User Name:',A8,14X,'*')
  133 FORMAT (26X,14('*****')/)
  134 FORMAT ('(26X,''*'',',I2,'X,''Orders being Processed:'',',I2,
     &'(1X,A4)',I2,'X,'' *'')')
  135 FORMAT (26X,'*',14X,'Wavelength ',F8.4,7X,'Gamma ',A8,14X,'*')
  138 FORMAT ('* ',2F7.2)
      WRITE (LPT,HEADNG)
      LCOUNT=LCOUNT+18
C
C  ***************************************************************
C  *****                START TO READ DATA                   *****
C  ***************************************************************
    3 JK=NCHECK(1,0)
      IF (JK.LE.0) GO TO 90
      IF (JK.EQ.1) GO TO 1
      IF (JK.EQ.4 ) THEN
        IF (MESBUF(10:14) .EQ. 'IN20:')GO TO 3
        COMENT=MESBUF(11:)
        WRITE (LPT,127) COMENT
        LCOUNT=LCOUNT+1
        GO TO 3
      ENDIF
      IF (.NOT. START) GO TO (19,20),JK-1
C  MUST READ COMMON DATA TO START PROCESSING
      IF (.NOT.BEGIN)GO TO 3
      LCOUNT=LCOUNT+1
      WRITE (LPT,126)
      BEGIN=.FALSE.
      GO TO 3
C
C  READ SELECTED PARTS OF COMMON DATA
    1 RDCOM=.TRUE.
      ICD=0
    6 ICD=ICD+1
      IF (ICD.GT.NCOM) THEN
        RDCOM=.FALSE.
        IF (START) GO TO 36
        GO TO 3
      ENDIF
    4 GO TO (14,4,90,91,92,93),1-NCHECK(5,ICD)
   14 IS=KCOMOF(ICD)
      GO TO (2,35,33,23,13,7,8,30,15,16,18),ICD
C
C  HERE AFTER DATA:
   19 I=NCFIND(MESBUF(7:11),DWORD,NDAT)
      IF (I.LE.0) GO TO 3
      IS=KDATOF(I)
      GO TO (2,7,8,13),I
      GO TO 3
C
C  HERE AFTER ORDER: TO UPDATE DATA
   20 I=NCFIND(MESBUF(7:11),OWORD,NORDE)
      IF (I.EQ.0) GO TO 3
C  WORD NOT RECOGNISED
      IS = KORDOF(I)
      GO TO (30,31,31,24,40,40),I
      GO TO 3
C
C  SECTION GIVING PROCEDURES AFTER COMMON DATA OR DATA KEYWORDS
C  SAMPLE NAME
    2 IF (RDCOM) IUNAME=MESBUF(32:39)
      DUMNAM=MESBUF(IS:IS+7)
      IF (DUMNAM.EQ.ISNAME) GO TO 5
C  HERE FOR NEW SAMPLE
      IF (.NOT.START) THEN
        CALL TESTP(LPT,LCOUNT,1,HEADNG,2)
        LCOUNT=LCOUNT+1
        WRITE (LPT,120) ISNAME,DUMNAME
      ENDIF
      ISNAME=DUMNAM
      GO TO 5
C
C  WAVELENGTH
    7 READ(MESBUF(IS:),101) ADUM(1)
      IF (.NOT. CHGPAR(ADUM,ALAM,1)) GO TO 5
      IF (START) GO TO 10
      CALL TESTP(LPT,LCOUNT,1,HEADNG,2)
      LCOUNT=LCOUNT+1
      WRITE (LPT,122) ALAM,ADUM(1)
      WRITE (NEWIN,124) ALAM,UBM
   10 ALAM=ADUM(1)
      GO TO 5
C
C  UB MATRIX
    8 N=0
    9 READ (MESBUF(IS:),101) (ADUM(3*N+I),I=1,3)
      N=N+1
      IF (N.EQ.3) GO TO 11
      GO TO (9,4,90,91,92,93),1-NCHECK(2,0)
   11 IF (.NOT. CHGPAR(ADUM,UBM,9)) GO TO 5
      IF (START) GO TO 12
      CALL TESTP(LPT,LCOUNT,1,HEADNG,2)
      LCOUNT=LCOUNT+1
      WRITE (LPT,123)
   12 CALL GMEQ(ADUM,UBM,1,9)
      WRITE (NEWIN,124) ALAM,UBM
      GO TO 5
C
C  GEOMETRY CONTROL: Added Dec 1998- corrected May 1999
   13 READ (MESBUF(IS:),106) (IDUM(I),I=1,3)
      DO 301 I=1,3
      CHNG=IDUM(I).NE.IGEO(I)
      IF (CHNG) GO TO 302
  301 CONTINUE
      GO TO 5
  302 IF (.NOT. START) THEN
        CALL TESTP(LPT,LCOUNT,2,HEADNG,2)
        LCOUNT=LCOUNT+2
        WRITE (LPT,151) (IDUM(I),I=1,3),IGEO
      ENDIF
      CALL JGMEQ(IDUM,IGEO,1,3)
      GO TO 5
C
C  CONVERSION MATRIX NOT USED YET
   15 GO TO 5
C
C  DISPLAY: NOT USED
   16 GO TO 5
C
C  COIL TILT CORRECTION REMOVED
   17 GO TO 5
C
C DEAD-TIME
   18 READ (MESBUF(IS:),103) (ADUM(I),I=1,4)
      IF (.NOT.CHGPAR(ADUM,TMORTS,4)) GO TO 5
      IF (.NOT. START) THEN
      CALL TESTP(LPT,LCOUNT,2,HEADNG,2)
      LCOUNT=LCOUNT+2
      WRITE (LPT,150) ADUM(1),ADUM(3),ADUM(2),ADUM(4),
     &TMORTS(1),TMORTS(3),TMORTS(2),TMORTS(4)
      ENDIF
      CALL GMEQ(ADUM,TMORTS,1,4)
      GO TO 5
C  REFLECTION INDICES AND MEASUREMENT TYPE
   30 IF(IPOL.GT.1) THEN
        NSEQ=NSEQ+1
        NPTS=IPOL-1
        IPOL=1
        IF (PLTING)CALL STEREO
      ENDIF
      IF (RDCOM) THEN
        READ (MESBUF(IS:),101) HKL,MTYP
        GO TO 5
      ENDIF
      READ (MESBUF(IS:),101) HKL
C GET NEXT LINE TO READ DIFFRACTION ANGLES
      IS=32
      GO TO (33,5,90,91,92,93),1-NCHECK(3,1)
C
C  SET OR INCREMENT ANGLES: FIRST DISCOVER WHICH
   31 J=NCFIND(MESBUF(IS:IS+4),LWORD,4)
      IF (J.EQ.0) GO TO 3
      IS=IS+LOFF(J)
      IF (I.EQ.2) GO TO (5,33,34,34,35),J+1
C NUMBER OF INCREMENTS TO READ
      LSTEP=2
      LSTART=1
      LFINI=4
      IF (J.EQ.1) THEN
        LSTEP=1
        LFINI=3
      ELSE
        IF (J.EQ.4) LSTEP=1
        IF (J.EQ.3) LSTART=2
      ENDIF
      READ (MESBUF(IS:),102)(ADUM(L),L=LSTART,LFINI,LSTEP)
      IF (J.EQ.1) THEN
        CALL GMADD(ADUM,DANGS,DANGS,3,1)
      ELSE
        DO 37 L=LSTART,LFINI,LSTEP
   37   ANGS(L)=ANGS(L)+ADUM(L)
      ENDIF
      GO TO 5
C
C DIFFRACTION  ANGLES
   33 READ (MESBUF(IS:),102) DANGS
C   DANGS(2) IS THETA BRAGG - HAVE TO DECIDE IF HAS CHANGED
C IN ORDER TO KNOW WHEN TO CHANGE OUTPUT FILE *****
      GO TO 5
C
C POLARISATION  ANGLES
   34 II=J-1
      READ (MESBUF(IS:),102) (ANGS(I),I=II,4,2)
      GO TO 5
   35 READ (MESBUF(IS:),102) ANGS
      GO TO 5
C
C  READ DATE,TIME AND DVM
   22 IF (JK.NE.3) GO TO 3
      DATE=MESBUF(1:19)
      DVM=MESBUF(54:65)
      GO TO 5
C
C  LIMITS NOT USED FOR NOW
   23 GO TO 5
C
C  SCANS
   24 MSTYP=NCFIND(MESBUF(IS:IS+4),LWORD(1),5)
      IF (MSTYP.EQ.0) THEN
C  SCAN TYPE NOT RECOGNISED
        WRITE (LPT,123) MESBUF(IS:IS+4)
        GO TO 5
      ENDIF
      IS=IS+LOFF(MSTYP)-1
C  DON'T COUNT DIFRN ANGLE SCANS
      MSTYP=MSTYP-1
      CALL GMZER(AMSC,4,1)
      IF (MSTYP.EQ.0) THEN
        READ (MESBUF(IS:),104) (AMSC(L),L=1,3),NSTEP
 1104 format(3f8.2)
 1105 format(i5)
      ELSE
        LSTART=1
        LSTEP=2
        IF (MSTYP.EQ.2 .OR. MSTYP .EQ.4) LSTART=2
        IF (MSTYP.EQ.3) THEN
          LSTEP=1
          READ (MESBUF(IS:),102) (AMSC(L),L=LSTART,4,1),NSTEP
        ELSE
          READ (MESBUF(IS:),105) (AMSC(L),L=LSTART,4,2),NSTEP
        ENDIF
      ENDIF
      IF (MSTYP.EQ.0 .OR.ICOM(MSTYP).NE.1) THEN
C IF NOT BEING PROCESSED JUST UPDATE ANGLES
        IF (NSTEP.GT.0) THEN
          W=FLOAT(2*NSTEP)
        ELSE
          W=-FLOAT(NSTEP)
        ENDIF
        IF (MSTYP.EQ.0) THEN
          CALL GMSCA(ADUM,AMSC,W,3,1)
          CALL GMADD(DANGS,DANGS,ADUM,3,1)
        ELSE
          DO 26 L=LSTART,4,LSTEP
  26      ANGS(L)=ANGS(L)+W*AMSC(L)
        ENDIF
        GO TO 5
      ENDIF
      JK=MSTYP
      CALL MPSPRC(JK)
      IF (JK .LT.-1) GO TO 90
      IF (JK.EQ.999) GO TO 80
      GO TO 3
C
C  ANALYSIS ORDERS
   40 DO 41 L=JANAL,NMORD
      IF (ICOM(L).NE.1) GO TO 41
C SET J TO POINT INTO THE LWORD TABLE
      J=L-JANAL+LANAL
C SET BACK J TO RECOGNISE TYPE OF BETTER ANALYSIS
      IF (I.EQ.6) J=J-2
      IF (MESBUF(IS:IS+4).NE.LWORD(J)) GO TO 41
      JK=L
      CALL ANAPOL(JK)
      IF (JK.LT.-1) GO TO 90
      GO TO 3
   41 CONTINUE
      GO TO 3
C
C
C  AFTER READING DATA
    5 IF (RDCOM) GO TO 6
      GO TO 3
C
C  END OF DATA
   94 GO TO (1,20,20),JK
C  ERROR RETURN HAVING READ ANOTHER ORDER
C
      GO TO 3
C
C  END OF DATA
   91 JK=1
      GO TO 94
   92 JK=2
      GO TO 94
   93 JK=3
      GO TO 94
   90 JK=-(2+JK)
      IF (JK.GT.0) GO TO 94
C
C Close the plot-file
   80 IF (PLTING .AND. IPOL.GT.1) THEN
        NPTS=IPOL-1
        CALL STEREO
      ENDIF
      IF (INPLOT) THEN
        CALL PGEND(LDEV(1))
        CALL PGEND(LDEV(2))
        IF (PGHARD) CALL MESS(ITO,0,'Completing plot file '//PGFIL)
      ENDIF
      CALL CLOFIL(LUNI)
C
C  WRITE THE UPDATED COMMON DATA FILE
      MESSAG=COMNAM
      ICOMU=NOPFIL(1023)
      WRITE (ICOMU) ICOMDA,ICOMCH
      CALL CLOFIL(ICOMU)
      STOP
C  FORMATS FOR READING THE COMMON DATA
  100 FORMAT (A8,11X,A5,A3)
  101 FORMAT (3F10.4,18X,I5)
  102 FORMAT (4F8.2,I5)
  103 FORMAT (2(F11.8,F16.13))
  104 FORMAT (3F8.2,I5)
  105 FORMAT (2F8.2,I5)
  106 FORMAT (3I5)
C  FORMATS FOR READING THE DATA
  112 FORMAT (17X,F10.5)
  113 FORMAT (17X,2F8.2,I5)
  114 FORMAT (19X,2F8.2,I5)
  115 FORMAT (17X,4F8.4,I5)
  116 FORMAT ('(',I2,'X,4F8.2)')
C
C  FORMATS FOR ERROR AND WARNING MESSAGES
  120 FORMAT ('0 ***Warning: Change of Sample Old: ',A8,' New: ',A8)
  121 FORMAT (' Error reading common data')
  122 FORMAT ('0 ***Warning: Change of wavelength Old=',F10.4,' New ='
     &,F10.4/)
  123 FORMAT (' Scan type ',A5,' not recognised')
  124 FORMAT ('D WVLN',F10.4/'D GEOM 8'/'D L/R 1,',3(/'D UMAT',3F10.5))
  126 FORMAT ('0***Warning: File does not start with a common data',
     &'block'/)
  127 FORMAT (' *** ',A80)
  150 FORMAT ('  ***Warning: Change of dead-time Old: a = ',
     &E11.3,'+/-',E11.3,' b = ',E11.3,'+/-',E11.3/34X,'New: a = ',
     &E11.3,'+/-',E11.3,' b = ',E11.3,'+/-',E11.3)
  151 FORMAT ('  ***Warning: Change of Geometry, Old: '
     &,3I5/24X,'New: ',3I5)
      END
C
C
C
C
      FUNCTION NCHECK(M,LL)
C
C *** NCHECK modified by PJB Dec 1998 forlower case ***
C
CH Fundamental reading function for CRYPAD data
C
      COMMON /ALWORD/KEY(5),CWORD(11),DWORD(4),OWORD(6),LWORD(16)
     &,MORD(10)
      CHARACTER*5 KEY,CWORD,DWORD,OWORD,LWORD,MORD*4
      COMMON/NLWORD/NKEY,NCOM,NDAT,NORDE,NLWORD,NMORD,
     &JANAL,LANG,LANAL,LMISC,LEND
     &,KCOMOF(12),KDATOF(4),KORDOF(6),LOFF(16)
/CRPDN/
/CRPDC/
      COMMON /HEDING/ HEADNG
      CHARACTER*132 HEADNG
/IOUNIT/
/SCRACH/
C
      L=LL
      NCHECK=0
C
C  SECTION TO GET A NEW FILE NAME
    1 IF (IEND) THEN
        LDIR=LENGT(DATDIR)
        MESSAG=DATDIR(1:LDIR)//IP1
      ENDIF
    2 IF (IEND) THEN
        NAMFIL='.opf'
        LUNI=NOPFIL(131)
        IF (LUNI.LE.0) THEN
          NCHECK=-2
          CALL TESTP(LPT,LCOUNT,1,HEADNG,2)
          WRITE (LPT,13) IP1(1:6)
   13     FORMAT (' File ',A6,' not found in the data-base')
          IP2=' '
          GO TO 100
        ENDIF
        WRITE (LPT,16) IP1(1:6)
        WRITE (ITO,16) IP1(1:6)
   16   FORMAT (' Data now being read from ',A6)
        IEND=.FALSE.
C  READ HEADER; DO NOTHING WITH IT FOR NOW
        READ (LUNI,1000) MESBUF
      ENDIF
C
C  READ NEXT RECORD
      READ (LUNI,1000,END=52) MESBUF
C Convert it into upper case
      CALL UPONE(MESBUF,1)
 1000 FORMAT (A125)
C
C  IGNORE BLANK LINES
      IF (LENGT(MESBUF).LE.1) GO TO 1
C
C  SEARCH FOR KEYWORD
      I=NCFIND(MESBUF(1:5),KEY,5)
      IF (I .EQ. 0) GO TO (1,20,30,40,50),M
C IGNORE WARNING MESSAGES
      IF (I.EQ.5) GO TO 1
C SKIP IN20 SPURIOUS COMMENTS
      IF (I.EQ.4 .AND. M.NE.1) GO TO 1
C
    3 NCHECK=I
      IF (M.NE.1) NCHECK=-2-I
C  KEYWORD FOUND WHEN NOT LOOKING FOR ONE, SET ERROR
      GO TO 100
C
C  DATA RUN OUT
   52 IEND=.TRUE.
      IF (IP2.NE.' ') THEN
        IF (IP1 .EQ. IP2) THEN
          NCHECK=-2
          IP2=' '
        ENDIF
      ENDIF
      LDIR=LENGT(DATDIR)
      MESSAG=DATDIR(1:LDIR)//IP1
      CALL INCREM(IP1,MESSAG)
      CALL CLOFIL(LUNI)
      IF (NCHECK .EQ.-2) GO TO 100
      CALL TESTP(LPT,LCOUNT,1,HEADNG,2)
      GO TO 2
C
C  MAKE SURE NO NON-NUMERICAL CHARACTERS
   20 DO 21 I=1,5
      IF (MESBUF(I:I).EQ.' '.OR. MESBUF(I:I).EQ.'-'
     &.OR. MESBUF(I:I).EQ.'.') GO TO 21
      IF (NDIGIT(MESBUF(I:I)) .EQ. -1) GO TO 22
   21 CONTINUE
      GO TO 100
   22 CALL TESTP(LPT,LCOUNT,3,HEADNG,2)
      LCOUNT=LCOUNT+2
      WRITE (LPT,12) MESBUF(1:20)
   12 FORMAT ('0 Characters "',A20,'" Read when expecting a number'/)
      NCHECK=-1
      GO TO 100
C
C  CHECK THE FIRST 5 CHARACTERS IN A LINE
   30 IF (MESBUF(1:5).NE. LWORD(L))NCHECK=-1
      GO TO 100
C
C  ADVANCE BY LL LINES
   40 L=L-1
      IF (L.EQ.0) GO TO 100
      GO TO 1
C
C  ERROR IN SPECIFICATION OF RECORD
   90 CALL MESS(ITO,0,'Error in specification of record; '//MESSAG)
      CALL INFILE
      GO TO 1
C
C  CHECK THE FIRST 5 CHARACTERS IN A LINE READ FROM THE COMMON DATA
   50 LL=NCFIND(MESBUF(1:5),CWORD,NCOM)
      IF (LL.EQ.0) NCHECK=-1
      GO TO 100
  100 RETURN
      END
C
C
C
C
      SUBROUTINE INFILE
C
C *** INFILE new by PJB Oct 96 ***
C
CH Opens a file on the ILL data base, or elsewhere
C
      CHARACTER*3 CYCLE
      LOGICAL SAYS
/CRPDC/
/IOUNIT/
/SCRACH/
C
      CALL GETENV('CRPDATA',DATDIR)
      DATDIR=DATDIR//'/'
      L=LENGT(DATDIR)
      IF (L.NE.0) THEN
        IF (DATDIR(L:L).NE.'/')  DATDIR=DATDIR(1:L)//'/'
        CALL ASK('Data will be read from directory '//DATDIR(1:L)//
     &' OK? (Y/N)')
        IF (SAYS('Y')) GO TO 2
      ENDIF
      CALL GETENV('ILLDATA',DATDIR)
      L=LENGT(DATDIR)
      IF (L.EQ.0) THEN
        DATDIR='/usr/illdata'
        L=LENGT(DATDIR)
      ENDIF
        CALL ASK('Data base is '//DATDIR(1:L)//
     &' OK? (Y/N)')
        IF (SAYS('N')) CALL MESS(ITO,0,' Please set the environment'//
     &' variable ILLDATA to the correct path for the ill data base')
    1 CALL ASK('Give cycle number (RETURN gives current cycle')
      CALL RDINTG(ICYC,1,IPT,8,IER)
      IF (IER .EQ.100) ICYC=0
      IF (ICYC.EQ.0) THEN
        DATDIR=DATDIR(1:L)//'/data/crpd/'
      ELSE IF (IER.NE.0) THEN
        GO TO 1
      ELSE IF (ICYC.EQ.-1) THEN
        DATDIR=DATDIR(1:L)//'/data-1/crpd/'
      ELSE
        WRITE (CYCLE,10) ICYC
   10 FORMAT (I3)
        DATDIR=DATDIR(1:L)//'/'//CYCLE//'/crpd/'
      ENDIF
    2 CALL ASK('Give name of first and (last) files to process')
      CALL RDWORD(IP1,LEN,1,IPT,11,0,IER)
      IF (IER.NE.0) GO TO 2
      CALL RDWORD(IP2,LEN,IPT,IPT,30,0,IER)
      IF (IER.EQ.100) THEN
        IP2=' '
      ELSE
        IF (IER.NE.0) GO TO 2
      ENDIF
      CALL UPONE(IP1,3)
      CALL UPONE(IP2,3)
      RETURN
      END
C
C
C
C
      SUBROUTINE MPSPRC(M)
C
C *** MPSPRC new by PJB Oct 1990 ***
C
CH Process *MPS commands
C
      LOGICAL TESTOV,SAYS
      DIMENSION FCOUNT(3,2),RATE(2),VRATE(2)
      DIMENSION XI(500),YI(500)
/CONSTA/
      COMMON/NLWORD/NKEY,NCOM,NDAT,NORDE,NLWORD,NMORD,
     &JANAL,LANG,LANAL,LMISC,LEND
     &,KCOMOF(12),KDATOF(4),KORDOF(6),LOFF(16)
/CRPDN/
/CRPDC/
      COMMON /FITS/PARS(4),DPAR(4),KPAR(4),NP,ISEQP
/IOUNIT/
      COMMON /HEDING/ HEADNG
/TITLE/
/SCAN/
      LOGICAL PFIXED,INTACT
      CHARACTER*132 HEADNG,SCNTIT*100,SCANT(4)*10,SCANG(6)*11,BLANK*5
      CHARACTER*12 PARNM(4)
      DATA SCANT/'Both  Phi ','Both Theta','Theta/Phi ','Currents'/
      DATA SCNTIT/'(''  Step  Theta-in    Phi-in Theta-out   Phi-out
     &P        DP   SumInt  D(SumInt)'')'/
      DATA SCANG/'Theta in','Phi in ','Theta out',' Phi out ',
     &'Current in','Current out'/
      DATA BLANK/'(X)'/
      DATA PARNM/'Polarisation','Offset','Scale','Spare'/
C
C  SAVE INFORMATION ON TYPE
      MM=M
      MSC=MM
      IF (ISEQ.GT.NSEQ) GO TO 100
      CALL TESTP(LPT,LCOUNT,4,BLANK,1)
      LCOUNT=LCOUNT+3
C  READ HEADER LINES
      CALL RDHEAD(M)
      IF (M.LT.0) RETURN
C  WRITE HEADER
      WRITE (LPT,120) NSEQ,SCANT(MM),HKL,DANGS(2),TEMP,DATE,COMENT
  120 FORMAT (/' Scan No',I4,'of ',A10,' angles ',
     &' hkl=',3F6.2,' Gamma=',F7.2,' Temperature=',A10,' measured ',A19/
     &' Commentary: ',A80)
C set title
      L=LENGT(COMENT)
      IF (L.GT.40) L=40
      WRITE (ITITLE,122) DATE,TEMP,COMENT(1:L)
  122 FORMAT (A19,' Temp  =',A10, A40)
      HEADNG=SCNTIT
      WRITE (LPT,HEADNG)
  121 FORMAT (1X,A100)
      IF (NSTEP.LT.0) THEN
        NS=-NSTEP
        CALL GMEQ(ANGS,SANG,4,1)
      ELSE
        NS=2*NSTEP+1
C  FOR CENTRED SCANS GET STARTING ANGLES
        DO 20 I=1,4
        SANG(I)=ANGS(I)-FLOAT(NSTEP)*AMSC(I)
   20   CONTINUE
      ENDIF
      IS=2
      JS=LANAL
      IF (MM.EQ.1) JS=JS-5
      IF (MM.EQ.3) IS=4
      IF (MM.EQ.2) JS=JS+2
      IF (MM.EQ.4) JS=JS-1
      IF (MM.EQ.5) JS=JS-1
      MMM=MM
      IF (MM.EQ.4) MMM=2
      AMAX=0.
      PLMIN=1.
      PLMAX=-1.
      DO 8 I=1,4
      IF (ABS(AMSC(I)).LE.AMAX) GO TO 8
      JANG=I
      AMAX=ABS(AMSC(I))
    8 CONTINUE
C
    2 M = NCHECK(3,JS)
      IF (M.LT.-1) RETURN
C  END OF DATA OR ANOTHER KEYWORD
      IF (M.EQ.-1) GO TO 2
C  TO READ ANOTHER LINE
C SKIP A LINE
C      M=NCHECK(4,1)   it is blank so skipped anyway
C
      DO 5 II=1,NS
      M=NCHECK(2,2)
      IF (M.LT.0) GO TO 4
    7 IF (IS.EQ.2) READ (MESBUF,102)
     &(ANGS(I),I=MMM,4,2),((FCOUNT(I,J),J=1,2),I=1,3)
      IF (IS.EQ.4) READ (MESBUF,103)
     &(ANGS(I),I=1,IS),((FCOUNT(I,J),J=1,2),I=1,3)
C NOW GET THE RATES AND THE LOST COUNTS CORRECTION
      DO 10 J=1,2
      IF (FCOUNT(2,J).EQ.0) GO TO 12
      IF (FCOUNT(3,J).EQ.0) GO TO 12
      TRATE=FCOUNT(1,J)/FCOUNT(2,J)
      VTRATE = TRATE/FCOUNT(2,J)
      CALL LSTCTS(TRATE,VTRATE)
      RATE(J)= (FCOUNT(1,J)/FCOUNT(3,J))*TRATE
   11 VRATE(J)=(RATE(J)/FCOUNT(3,J))*VTRATE
   10 CONTINUE
      IF (TESTOV(RATE(1)-RATE(2),RATE(1)+RATE(2))) GO TO 12
      PL(II)=(RATE(1)-RATE(2))/(RATE(1)+RATE(2))
      VAR(II)=ANGS(JANG)
      IF (VAR(II).GT.VMAX .OR. II.EQ.1) VMAX=VAR(II)
      IF (VAR(II).LT.VMIN .OR. II.EQ.1) VMIN=VAR(II)
      IF (PL(II).GT.PLMAX) PLMAX=PL(II)
      IF (PL(II).LT.PLMIN) PLMIN=PL(II)
      DP(II)=SQRT(RATE(1)*RATE(1)*VRATE(2)+RATE(2)*RATE(2)*VRATE(1))
      DP(II)=2.*DP(II)/((RATE(1)+RATE(2))**2)
      TRATE=RATE(1)+RATE(2)
      DTRATE=SQRT(VRATE(1)+VRATE(2))
      CALL TESTP(LPT,LCOUNT,1,HEADNG,2)
      WRITE (LPT,104) II,ANGS,PL(II),DP(II),TRATE,DTRATE
    5 CONTINUE
C
   4  IF (II.LT.NS) NS=II-1
      IF (NS.LE.3) GO TO 100
      CALL TESTP(LPT,LCOUNT,2,HEADNG,1)
      LCOUNT=LCOUNT+2
C SET ALL PARS TO BE REFINED
      CALL JGMZER(KPAR,4,1)
C Fix polarisation if required
      IF (PFIXED) THEN
        KPAR(1)=1
        PARS(1)=POLN
      ENDIF
C  DON'T REFINE ANGLE SCALE FOR THETA SCANS
      IF (MOD(JANG,2).NE.0) KPAR(3)=1
      IF (ABS(PLMIN).GT..1 .OR.ABS(PLMAX).GT..1.OR. MM.NE.2) THEN
        NP=3
        CALL FITTIT(NS,0)
      ELSE
        NP=4
C        CALL ITFITS(NS,NP)
      ENDIF
C
C plot the data
   49 DO 44 IDEV=1,2
      IF (IDEV.EQ.2) THEN
        CALL ASK('Hard copy required? (Y/N)')
        IF (.NOT. SAYS('Y')) GO TO 44
        PGHARD=.TRUE.
      ENDIF
      CALL PGSLCT(LDEV(IDEV))
      CALL PGSLW(3)
      CALL PGPAGE
      CALL PGVPORT(0.1,0.65,0.1,0.9)
      CALL PGWINDOW(VMIN,VMAX,1.05*PLMIN,1.05*PLMAX)
      CALL PGBOX('ABCGNST',0.0,0,'ABGCNST',0.0,0)
      IF (MSC.EQ.4) THEN
        J=MOD(JANG-1,2)+5
        MESBUF=SCANG(J)//'(amps)'
      ELSE
        MESBUF=SCANG(JANG)//'(degrees)'
      ENDIF
      CALL PGLABEL(MESBUF,'Polarisation',ITITLE)
      DO 43 I=1,NS
      CALL PGPOINT(1,VAR(I),PL(I),17)
      CALL PGERRY(1,VAR(I),PL(I)+DP(I),PL(I)-DP(I),0,0.0)
   43 CONTINUE
      NCYCS=iabs(JFIX((VMAX-VMIN)*PARS(3)/TWOPI))
      NST=100*NCYCS
      IF (NST.GT.499) NST=499
      STEP=(VMAX-VMIN)/FLOAT(NST)
      I=0
      DO 45 X=VMIN,VMAX,STEP
      I=I+1
      XI(I)=X
      YI(I)=FUNC(X,PARS,NP,SA,MSC)
   45 CONTINUE
      CALL PGLINE(I,XI,YI)
C now the info box
      CALL PGVPORT(0.70,0.95,0.05,0.95)
      CALL PGWINDOW(0.0,1.,0.0,1.)
      CALL PGSFS(2)
      CALL PGSLS(1)
      CALL PGSCH(0.75)
      DPOS=0.025
      DPOS2=DPOS/2
      AL=(FLOAT(NP)+10.5)*DPOS
      POS=(1.0+AL)/2.
      CALL PGRECT(0.,1.,POS-AL,POS,)
      XI(1)=0.
      XI(2)=1.
      POS=POS-DPOS
      CALL PGMTEXT('LV',-3.,POS,0.,'Scan Data')
      YI(1)=POS-DPOS2
      YI(2)=POS-DPOS2
      CALL PGLINE(2,XI,YI)
      POS=POS-DPOS
      MESBUF='File  '//IP1
      CALL PGMTEXT('LV',-3.,POS,0.,MESBUF)
      POS=POS-DPOS
      WRITE (MESBUF,1041) ISEQP
 1041 FORMAT ('Scan',8X,I5)
      CALL PGMTEXT('LV',-3.,POS,0.,MESBUF)
      POS=POS-DPOS
      DO 46 I=1,2
      DO 47 J=1,2
      II=2*(I-1)+J
      IJ=II
      IF (J.EQ.2 .AND. MSC.EQ.4) II=4+I
      WRITE (MESBUF,1040) SCANG(II),ANGS(IJ)
 1040 FORMAT (A9,3X,F7.4)
      CALL PGMTEXT('LV',-3.,POS,0.,MESBUF)
      POS=POS-DPOS
   47 CONTINUE
   46 CONTINUE
      YI(1)=POS
      YI(2)=POS
      CALL PGLINE(2,XI,YI)
      POS=POS-DPOS2
      CALL PGMTEXT('LV',-3.,POS,0.0,'Fitted Parameters')
      YI(1)=POS-DPOS2
      YI(2)=POS-DPOS2
      CALL PGLINE(2,XI,YI)
      POS=POS-DPOS-DPOS2
      DO 48 I=1,NP
      MESBUF=PARNM(I)//'      '
      IF (I.NE.2) THEN
        IF (KPAR(I).EQ.0) THEN
          CALL ESDFMT(PARS(I),DPAR(I),MESBUF(14:),14)
        ELSE
          WRITE (MESBUF(14:),1042) PARS(I)
        ENDIF
 1042 FORMAT (F8.3,' Fixed')
      ELSE
        IF (MSC.EQ.4) THEN
          PAROUT=PARS(2)/PARS(3)
          DPARUT=DPAR(2)/PARS(3)
        ELSE
          PAROUT=DEGREE(PARS(2))
          DPARUT=DEGREE(DPAR(2))
        ENDIF
        IF (KPAR(I).EQ.0) THEN
          CALL ESDFMT(PAROUT,DPARUT,MESBUF(14:),14)
        ELSE
          WRITE (MESBUF(14:),1042) PAROUT
        ENDIF
      ENDIF
      CALL PGMTEXT('LV',-3.,POS,0.,MESBUF)
      POS=POS-DPOS
   48 CONTINUE
      IF (INTACT.AND. IDEV.EQ.1) THEN
        MODE=1
        CALL FITTIT(NS,MODE)
        IF (MODE.EQ.1)GO TO 49
      ENDIF
   44 CONTINUE
C
      M=0
      CALL ASK('Continue or quit (C/Q default C)')
      IF (SAYS('Q')) M=999
C
  100 NSEQ = NSEQ+1
      GO TO 99
C  ERRORS
C  DATA HAS RUN OUT
    3 M=-1
      RETURN
C
C  NO DATA
   12 CALL TESTP(LPT,LCOUNT,1,HEADNG,2)
      WRITE (LPT,106) KH
      RETURN
C
C  R NOT SIGNIFICANT
   13 CALL TESTP(LPT,LCOUNT,1,HEADNG,2)
      WRITE (LPT,107) KH
C
C  FOR NON-CENTRED SCANS UPDATE ANGLES
   99 IF (NSTEP.LT.0) THEN
        DO 21 I=1,4
   21   ANGS(I)=ANGS(I)+AMSC(I)*FLOAT(NS-1)
      ENDIF
      RETURN
C
  101 FORMAT (A19,34X,A12)
  102 FORMAT (2(F8.2),2(F10.1,1X),2(F10.4,1X),F10.1,1X,F10.1)
  103 FORMAT (4(F8.1),2(F10.1,1X),2(F10.4,1X),F10.1,1X,F10.1)
  104 FORMAT (1X,I5,4F10.2,4F10.5,A12,3X,A19)
  105 FORMAT (2I5,2F8.2,2F10.6,2X,A12,3X,A19)
  106 FORMAT (10X,3I5,'   Zero time for measurement')
  107 FORMAT (10X,3I5,'   R less than its error')
  108 FORMAT (10X,3I5,'   Zero monitor count')
  109 FORMAT (38X,4F8.2)
  110 FORMAT (5X,A19)
      END
C
C
C
C
      SUBROUTINE ANAPOL(JK)
C
C *** ANAPOL new by PJB Oct-91 ***
C
CH To treat analysis orders
C
      LOGICAL INERR
      DIMENSION COMP(3,2),DCOMP(3),SPCORD(3,2),SPANG(3),
     &TRIAL(3)
      COMMON /ALWORD/KEY(5),CWORD(11),DWORD(4),OWORD(6),LWORD(16)
     &,MORD(10)
      CHARACTER*5 KEY,CWORD,DWORD,OWORD,LWORD,MORD*4
      COMMON/NLWORD/NKEY,NCOM,NDAT,NORDE,NLWORD,NMORD,
     &JANAL,LANG,LANAL,LMISC,LEND
     &,KCOMOF(12),KDATOF(4),KORDOF(6),LOFF(16)
/CRPDN/
/CRPDC/
/IOUNIT/
/POLKA/
/TITLE/
C
C  SAVE TYPE INFO 1 FOR IN 2 FOR OUT
      MTYP=MOD(JK-JANAL,2) +1
C READ NUMBER OF CYCLES
      READ (MESBUF(LOFF(JK):),209) CYC
  209 FORMAT(F8.1)
      NCYC=JFIX(CYC)
C Get temperature of previous measurement
      READ(TEMP,420,ERR=46) PREVT
      GO TO 44
C IF ERROR GIVE IT AN IMPOSSIBLE VALUE
   46 PREVT=-10.
  420 FORMAT (F8.2)
C  READ HEADER
   44 CALL RDHEAD(JK)
      IF (JK.LT.0) GO TO 100
C READ NEW TEMPERATURE
      READ(TEMP,420,ERR=43) STARTT
      GO TO 45
   43 STARTT=-10.
C  LOOK FOR 'Polar'
   45 INERR=.FALSE.
      ICYC=0
    1 JK=NCHECK(3,LEND-1)
      IF (JK.EQ.-1) GO TO 1
      IF (JK.LT.-1) GO TO 3
      READ (MESBUF(17:),210,ERR=4) TRIAL(1),spcord(1,2)
      READ (MESBUF(43:),211,ERR=4) TRIAL(2),spcord(2,2)
      READ (MESBUF(62:),212,ERR=4) TRIAL(3),spcord(3,2)
      IF (ICYC.GT.0)THEN
        DO 50 I=2,3
        DIF=ABS(TRIAL(I)-SPCORD(I,1))
        IF (DIF.GT. 5. .AND. DIF .GT. 3.*SPCORD(I,2)) INERR=.TRUE.
   50   CONTINUE
      ENDIF
      CALL GMEQ(TRIAL,SPCORD,1,3)
      ICYC=ICYC+1
  210 FORMAT (F7.4,1X,F6.4)
  211 FORMAT (F6.2,1X,F5.2)
  212 FORMAT (F6.2,1X,F5.2)
      IF (ICYC.LT. NCYC) GO TO 1
      CALL RDHEAD(JK)
      IF (JK.GE.0) THEN
C READ FINAL TEMPERATURE
        READ(TEMP,420,ERR=48) ENDT
        GO TO 47
   48   ENDT=-10.
      ENDIF
   47   IF (PLTING) THEN
          IF (ABS(PREVT-ENDT)/ABS(PREVT+ENDT).GT.0.025) THEN
C 5% DIFFERENCE ASSUME REAL TEMPERATURE STEP AND START NEW PLOT
          IF(IPOL.GT.1) THEN
            NSEQ=NSEQ+1
            NPTS=IPOL-1
            CALL STEREO
            IPOL=1
          ENDIF
        ENDIF
      ENDIF
      GO TO 5
C READ ERROR
    4 JK=-1
  201 FORMAT (3F8.4,5X,3(F8.4,1X,F6.2,1X))
    3 IF (ICYC .EQ.0) RETURN
C CREATE TITLE
    5 IF (PLTING) THEN
        IF (ABS(STARTT-ENDT)/ABS(STARTT+ENDT).GT.0.025) THEN
          WRITE (ITITLE,213) ISNAME,STARTT,ENDT,DATE
  213 FORMAT(A8,' T',F6.2,'-',F6.2,'K on ',A19)
        ELSE
          WRITE (ITITLE,214) ISNAME,STARTT,DATE
  214  FORMAT(A8,' T =',F6.2,'K on ',A19)
        ENDIF
      ENDIF
C FIND COMPONENTS AND ANGLES OF FIXED POLARISATION
      CALL POLAN2(ANGS,DANGS(2),3-MTYP,COMP,SPANG)
C IMPOSE MINIMUM ANGULAR ACCURACY 1 DEGREE
      IF (SPCORD(2,2).LT.1.0) SPCORD(2,2)=1.0
      IF (SPCORD(3,2).LT.1.0) SPCORD(3,2)=1.0
C USE THE LAST (AND BEST) RESULT
C CALCULATE POLARISATIOMS
      CALL COMPON(SPCORD,COMP(1,MTYP),DCOMP)
      WRITE (LUNO,207) HKL,MTYP,TEMP,DATE,ISNAME
  207 FORMAT (3F8.3,I5,1X,A8,1X,A19,1X,A8)
      WRITE (LUNO,208) COMP,DCOMP
  208 FORMAT (9F8.4)
      WRITE (LPT,203) NSEQ,HKL,MTYP,TEMP,DATE,COMENT(1:20)
      WRITE (LPT,206) COMP,DCOMP
  203 FORMAT (1X,I5,3F8.3,I5,2X,A8,2X,A19,2X,A20)
  206 FORMAT (30X,9F8.4)
      IF (IPOL.EQ.0) GO TO 100
      IF (PLTING) THEN
         ERRCH(IPOL)=' '
         IF (INERR) ERRCH(IPOL)='*'
        CALL GMEQ(SPCORD(1,1),PANGS(1,2,IPOL),1,3)
        CALL GMEQ(SPCORD(1,2),DPANGS(1,IPOL),1,3)
        CALL GMEQ(SPANG,PANGS(1,1,IPOL),1,3)
        IPOL=IPOL+1
      ENDIF
C
  100 RETURN
      END
C
C
C
C
      SUBROUTINE FITTIT(NS,MODE)
C
C *** FITTIT new by PJB Oct 89 ***
C
CH Fits a sine curve
      DIMENSION FTOMIN(100),W(3000),SD(3),WD(9),VPAR(4)
      INTEGER ISIGN
      LOGICAL SAYS,CHANGE
/CONSTA/
      COMMON /FITS/PARS(4),DPAR(4),KPAR(4),NP,ISEQP
/IOUNIT/
/SCAN/
      LOGICAL PFIXED,INTACT
C
      IF (MODE.EQ.1) GO TO 25
C  ESTIMATE PARAMETERS
      IF (.NOT. PFIXED)PARS(1)=AMAX1(ABS(PLMAX),ABS(PLMIN))
      PARS(3)=1.
      SPAN=VMAX-VMIN
      IF (MSC.EQ.4) THEN
        ICHNGE=1
        ISIGN=1
        IF(PL(1).LT.0) ISIGN=-1
        DO 40 I=2,NS
        JSIGN=1
        IF (PL(I).LT.0)JSIGN=-1
        IF (JSIGN.NE. ISIGN) THEN
          IF (ICHNGE.NE.1) THEN
            GO TO 41
          ENDIF
          ISLOPE=ISIGN-JSIGN
          ICHNGE=I
          ISIGN=JSIGN
        ENDIF
   40   CONTINUE
        PARS(3)=PIBY2/SPAN
        PARS(2)=0.
        GO TO 42
   41   PARS(3)=PI/(VAR(I)-VAR(ICHNGE))
   42   IF (ICHNGE.NE.1) THEN
          PARS(2)=VAR(ICHNGE)*PARS(3)-PIBY2
          IF (ISLOPE.LT.0) PARS(2)=PARS(2)+PI
        ENDIF
      ELSE IF (SPAN.GT.90.) THEN
        STEP=ABS(VAR(1)-VAR(2))
        N2=NINT(90./STEP)+1
        SPAN=FLOAT(N2-1)*STEP
      ELSE
        N2=NS
      ENDIF
        A1=VAR(1)
        A2=VAR(1)+SPAN
      IF (MSC .NE. 4) THEN
C convert angles to radians
        A1=RADIAN(A1)
        A2=RADIAN(A2)
        TMP1=PL(N2)*COS(A1)-PL(1)*COS(A2)
        TMP2=PL(N2)*SIN(A1)-PL(1)*SIN(A2)
        PARS(2)=ATAN2(TMP1,-TMP2)
      ENDIF
      PAROUT=PARS(2)
      IF (MSC.NE.4) PAROUT=DEGREE(PAROUT)
      WRITE (LPT,13) PARS(1),PAROUT,PARS(3)
      WRITE (ITO,13) PARS(1),parout,PARS(3)
   13 FORMAT (' Initial parameter values : ',3F10.4)
      CHANGE=.FALSE.
   25 IF (INTACT) THEN
        CALL ASK('Change them? (Y/N) default N')
        CHANGE=SAYS('Y')
       ENDIF
   22 IF (CHANGE) THEN
        CALL MESS(ITO,0,'Give parameter number, value, and 0/1'
     &//'for refine/fix. RETURN to go to refinement')
   20   CALL ASK('? ')
        CALL RDINTG(JP,1,IPT,5,IER)
        IF (IER.EQ.100) GO TO 21
        IF (IER.NE.0) GO TO 20
        CALL RDREAL(PARS(JP),IPT,IPT,IPT+10,IER)
        IF (IER.NE.0) GO TO 20
        CALL RDINTG(KPAR(JP),IPT,IPT,IPT+5,IER)
        IF (JP.EQ.2 .AND. MSC.NE. 4) PARS(2)=RADIAN(PARS(2))
        GO TO 20
C REPORT PARAMETERS
   21   PAROUT=PARS(2)
        IF (MSC.NE.4) PAROUT=DEGREE(PAROUT)
        WRITE (ITO,103) PARS(1),KPAR(1),parout,KPAR(2),PARS(3),KPAR(3)
  103 FORMAT (' New parameter values : ',3(F10.4,'(',I1,')'))
        CALL ASK('OK ? (Y/N default Y)')
        CHANGE= (SAYS('N'))
        IF (CHANGE) GO TO 22
      ELSE
        IF (MODE.EQ.1) then
          MODE=2
          GO TO 100
        ENDIF
      ENDIF
C SET PARAMETERS
      NPR=0
      DO 24 JP=1,4
      IF (KPAR(JP).EQ.0) THEN
        NPR=NPR+1
        VPAR(NPR)=PARS(JP)
      ENDIF
   24 CONTINUE
      ACC=.000005
      IP=0
      ICYC=0
      CALL VA05A(NS,NPR,FTOMIN,VPAR,.005,.5,ACC,100,IP,W)
      WRITE (LPT,15) IP,ICYC
      WRITE (ITO,15) IP,ICYC
   15 FORMAT (' The final value of IP is',I2,' after ',I3,
     &' cycles')
      CALL SERROR(NS,NPR,FTOMIN,VPAR,W,S,WD,SD)
      IPR=0
      DO 9 I=1,NP
      IF (KPAR(I).EQ.0) THEN
        IPR=IPR+1
        PARS(I)=VPAR(IPR)
        DPAR(I)=ABS(SD(IPR)*VPAR(IPR))
      ELSE
        DPAR(I)=0
      ENDIF
    9 CONTINUE
      PAROUT=PARS(2)
      DPARUT=DPAR(2)
      IF (MSC.NE.4) THEN
        PAROUT=DEGREE(PAROUT)
        DPARUT=DEGREE(DPARUT)
      ENDIF
      WRITE (ITO,14) PARS(1),DPAR(1),PAROUT,
     &DPARUT,PARS(3),DPAR(3)
   14 FORMAT (' Parameter values : ',F10.4,' +/- ',F10.4/
     &2(20X,F10.4,' +/- ',F10.4/))
      WRITE (LPT,16) PARS(1),DPAR(1),PAROUT,DPARUT
      IF (NPAR.EQ.3) WRITE (LPT,17)PARS(3),DPAR(3)
   16 FORMAT (' The fitted sine wave has amplitude',F8.4,
     &' +/-',F8.4,' with maximum at',F8.2,' +/-',F8.2)
   17 FORMAT (' The scan angles should be scaled by',F8.4,
     &' +/-',F8.4)
      WRITE (LPT,18)
   18 FORMAT (/)
  100 RETURN
      END
C
C
C
C
      SUBROUTINE ITFITS(NS,NPAR)
C
C *** ITFITS modified by PJB Oct 90 ***
C
CH Another fitting routine
C
      DIMENSION FTOMIN(100),W(3000),SD(4),WD(16)
/CRPDN/
      COMMON /FITS/PARS(4),DPAR(4),KPAR(4),NP,ISEQP
/IOUNIT/
/SCAN/
C
      NP=NPAR
C PHI-IN SCANS DEPEND ON SCATTERING ANGLE
C JANG=2 MEANS PHI-IN SCAN
      IF(JANG.EQ.2) THEN
        SA=RADIAN(DANGS(2))
      ELSE
      SA=0.
      ENDIF
C  ESTIMATE PARAMETERS
      PARS(1)=0.
      PARS(2)=0.
      PARS(3)=0.
      PARS(4)=1.
      SPAN=VMAX-VMIN
      IF (SPAN.GT.90.) THEN
        STEP=ABS(VAR(1)-VAR(2))
        N2=NINT(90./STEP)+1
        SPAN=FLOAT(N2-1)*STEP
      ELSE
        N2=NS
      ENDIF
      A1=RADIAN(VAR(1))
      A2=RADIAN(VAR(1)+SPAN)
      TMP1=PL(N2)*COS(A1)-PL(1)*COS(A2)
      TMP2=PL(N2)*SIN(A1)-PL(1)*SIN(A2)
C      PARS(2)=ATAN2(TMP1,TMP2)
      WRITE (ITO,13) DEGREE(PARS(1)),DEGREE(PARS(2)),DEGREE(PARS(3)),
     &PARS(4)
   13 FORMAT ('  Init param values:',4F10.4)
      ACC=.000005
      IP=0
      ICYC=0
      CALL VA05A(NS,NPAR,FTOMIN,PARS,.005,.5,ACC,100,IP,W)
      WRITE (ITO,15) IP,ICYC
   15 FORMAT ('  The final value of IP is',I2,' after ',I3,
     &' cycles')
      CALL SERROR(NS,NPAR,FTOMIN,PARS,W,S,WD,SD)
      DO 9 I=1,NPAR
      DPAR(I)=ABS(SD(I)*PARS(I))
    9 CONTINUE
      WRITE (ITO,14) DEGREE(PARS(1)),DEGREE(DPAR(1)),
     &DEGREE(PARS(2)),DEGREE(DPAR(2)),DEGREE(PARS(3)),
     &DEGREE(DPAR(3)),PARS(4),DPAR(4)
   14 FORMAT (' Parameter values : ',F10.4,' +/- ',F10.4/
     &3(20X,F10.4,' +/- ',F10.4/))
      WRITE (LPT,16)DEGREE(PARS(2)),DEGREE(DPAR(2)),
     &DEGREE(PARS(3)),DEGREE(DPAR(3))
      WRITE (LPT,62)DEGREE(PARS(1)),DEGREE(DPAR(1))
      WRITE (LPT,17)PARS(4),DPAR(4)
   16 FORMAT (' The fitted curve gives the small theta as ',F8.2,
     &' +/-',F8.2,' and large theta ',F8.2,' +/-',F8.2)
   17 FORMAT (' The scan angles should be scaled by',F8.4,
     &' +/-',F8.4)
   62 FORMAT (' Gamma value is',F8.2,'+/-',F8.2)
      WRITE (LPT,18)
   18 FORMAT (/)
      RETURN
      END
C
C
C
C
      SUBROUTINE CALFUN(N,NVALS,F,B)
C
C *** CALFUN for CRYPAD by PJB Oct 89 ***
C
CH calculation routine used by VA05A
C
      DIMENSION B(NVALS),F(N),C(4)
      LOGICAL TESTOV
      COMMON /FITS/PARS(4),DPAR(4),KPAR(4),NP,ISEQP
/SCAN/
C
      ICYC=ICYC+1
      IPR=0
      DO 2 IP=1,NP
      IF (KPAR(IP).EQ.0) THEN
        IPR=IPR+1
        C(IP)=B(IPR)
      ELSE
        C(IP)=PARS(IP)
      ENDIF
    2 CONTINUE
      DO 1 I=1,N
      ANUM=(PL(I)-FUNC(VAR(I),C,NP,SA,MSC))
      IF (TESTOV(ANUM,DP(I))) THEN
        F(I)=ANUM
      ELSE
        F(I)=ANUM/DP(I)
      ENDIF
    1 CONTINUE
      RETURN
      END
C
C
C
C
      FUNCTION FUNC(X,B,NP,SA,MSC)
C *** FUNC probobsolete by VN Oct 90 ***
C
CH Cryopad 1 coil corrections
      DIMENSION B(4)
C
      xx=x
      IF (MSC.NE.4) XX=RADIAN(X)
      IF (NP.LT.4) THEN
        FUNC=B(1)*COS(B(3)*(XX)-B(2))
      ELSE
        T=(COS(B(3))*COS(B(3))-SIN(B(2))*SIN(B(2)))**.5
        E=SIN(B(4)*(XX))*COS(B(1))*
     &(SIN(B(3))*COS(SA)-SIN(B(2))*SIN(SA))
        G=(1.-COS(B(4)*(XX)))*T*COS(B(1))*
     &(SIN(B(2))*COS(SA)+SIN(B(3))*SIN(SA))
        H=(1.-COS(B(4)*(XX)))*T*T*SIN(B(1))+
     &COS(B(4)*(XX))*SIN(B(1))
        FUNC=E+G+H
      ENDIF
      RETURN
      END
C
C
C
C
      SUBROUTINE RDHEAD(JK)
C
C *** RDHEAD new by PJB Oct-90 ***
C
CH Reads the standard heading of a measurement
C
C JK=0 IF NO ERROR
      COMMON/NLWORD/NKEY,NCOM,NDAT,NORDE,NLWORD,NMORD,
     &JANAL,LANG,LANAL,LMISC,LEND
     &,KCOMOF(12),KDATOF(4),KORDOF(6),LOFF(16)
/CRPDN/
/CRPDC/
C
      DO 1 I=1,3
      L=LMISC+I-1
      JK=NCHECK(3,L)
      IF (JK.LT.0) GO TO 100
      IF (I.EQ.1) READ (MESBUF(LOFF(L):),10) ANGS
   10 FORMAT (4F8.2)
      IF (I.EQ.2) DATE=MESBUF(LOFF(L):)
      IF (I.EQ.3) TEMP=MESBUF(LOFF(L):LOFF(L)+9)
    1 CONTINUE
 100  RETURN
      END
C
C
C
C
      BLOCK DATA PAGEHD
C
C *** PAGEHD modified by PJB Dec 98 ***
C Coil corrections removed and geometry included in data words Dec 98
CH Tables of all character sequences which are recognised on the input
      COMMON /HEDING/ HEADNG
      CHARACTER*132 HEADNG
C
      COMMON /ALWORD/KEY(5),CWORD(11),DWORD(4),OWORD(6),LWORD(16)
     &,MORD(10)
      CHARACTER*5 KEY,CWORD,DWORD,OWORD,LWORD,MORD*
C Number of entries in each table, data must match the dimensions above
C NCOM is the number of lines to be read from the COMMON data
      COMMON/NLWORD/NKEY,NCOM,NDAT,NORDE,NLWORD,NMORD,
     &JANAL,LANG,LANAL,LMISC,LEND
     &,KCOMOF(12),KDATOF(4),KORDOF(6),LOFF(16)
C
      DATA HEADNG/' (''0PUT IN PROPER HEADING  Date    Time''/)'/
      DATA NKEY,NCOM,NDAT,NORDE,NLWORD,NMORD
     &/5,11,4,6,16,10/
C JANAL marks the start of the analysis orders
C LANG,LANAL,LMISC,LEND ARE POINTERS INTO THE LWORD TABLE
      DATA JANAL,LANG,LANAL,LMISC,LEND/9,1,11,13,17/
C
C Offsets of data in the formats
      DATA KCOMOF/13,15,21,18,18,12,11,21,29,23,30,18/
      DATA KDATOF/19,18,17,36/
C      DATA KORDOF/12,12,17,12,13,23/
      DATA KORDOF/12,12,17,12,19,23/
      DATA LOFF/21,9,7,12,11,0,0,0,55,55,0,0,41,6,41,32/
C
C  LISTS OF WORDS:
C First "Key" words
      DATA KEY/'COMMO','DATA:','ORDER','COMME','WARNI'/
C Then words read from the common data block
      DATA CWORD/'SAMPL','THETA','DIFFR','LIMIT','GEOME','WAVEL'
     &,'UB MA','REFLE','CONVE','DISPL','DEAD '/
C Words read after DATA:
      DATA DWORD/'SAMPL','WAVEL','UB MA','GEOME'/
C Words read after ORDER:
      DATA OWORD/' HKL ','SET  ','INCRE','SCAN ','ANALY','BETTE'/
C Other identifying words
      DATA LWORD/'DIFFR','THETA','FI''S:','ALL A','CURRE',
     &'THE_I','THE_O','CHI_I','CHI_O','CUR_I','INPUT','OUTPU',
     &'ANGLE','CRPD:','O/P: ','POLAR'/
C Orders to process
      DATA MORD/'*MPT','*MPF','*MPA','*MSC','*ATI','*ATO',
     &'*AFI','*AFO','*API','*APO'/
      END
C
C
C
C
      SUBROUTINE POLAN2(PANG,GAMMA,ID,COMP,SPANG)
C
C *** POLAN2 new by PJB Jan 1995 ***
C
CH Calculates polaristion angles for cryopad II
C
      DIMENSION PANG(2,2),COMP(3,2),SPANG(3)
/CRPDN/
       GAMOFF=0.5*RADIAN(GAMMA)
C SWITCH BETWEEN IN OR OUT
      PSIGN=1.0
      IF (ID.EQ.2)PSIGN=-1.0
      COSTH=COS(RADIAN(PANG(1,ID)))
      COSTP=COSTH*COS(RADIAN(PANG(2,ID)))
C Use IGEO(3) to control signs
      IF (IGEO(3).GT.0) THEN
        TPHI1=PSIGN*SIN(RADIAN(PANG(2,ID)))*COSTH
        TPHI2=SIN(RADIAN(PANG(1,ID)))
      ELSE
        TPHI1=-PSIGN*SIN(RADIAN(PANG(2,ID)))*COSTH
        TPHI2=-SIN(RADIAN(PANG(1,ID)))
      ENDIF
      THETP=ACOS(COSTP)
      PHIP=ATAN2(TPHI1,TPHI2)-PSIGN*GAMOFF
C
      SINTP=SIN(THETP)
      COMP(1,ID)=COS(PHIP)*SINTP
      COMP(2,ID)=SIN(PHIP)*SINTP
      COMP(3,ID)=COSTP
      SPANG(1)=1.
      SPANG(2)=DEGREE(THETP)
      SPANG(3)=DEGREE(PHIP)
C
      RETURN
      END
C
C
C
C
      SUBROUTINE STEREO
C
C STEREO modified for PGPLOT Aug 95 ***
C
CH Draws stereographic projections of polarisation directions
C
      DIMENSION XP(51),YP(51),ISYMB(4),POL(50),PL(2)
      LOGICAL SAYS
      CHARACTER *60 BUF
/BRAGG/
/CONSTA/
/CRPDN/
/DGEOM/
/POLKA/
/TITLE/
      DATA ISYMB/22,17,7,13/
      DATA OFFST1,OFFST2,OFFST3 /.02,.04,.07/
C
      CALL ASK(' Plot stereogram? Y(es),N(o),Q(uit)=no more plots: ')
      IF (SAYS('N')) GO TO 100
      IF (SAYS('Q')) THEN
        PLTING=.FALSE.
        GO TO 100
      ENDIF
C
C PLOT THE STEREOGRAM
      DO 1 IDEV=1,2
      IF (IDEV.EQ.2) THEN
        CALL ASK('Hard copy required? (Y/N)')
        IF (.NOT. SAYS('Y')) GO TO 1
        PGHARD=.TRUE.
      ENDIF
      CALL PGSLCT(LDEV(IDEV))
C DARKEN THE YELLOW
      CALL PGSCR(7,0.5,0.5,0.)
      CALL PGSLW(3)
      CALL PGPAGE
c     CALL PGVPORT(0.05,0.5,0.1,0.9)
      CALL PGVPORT(0.08,0.53,0.1,0.9)
      CALL PGWNAD(-1.,1.1,-1.,1.1)
      CALL PGSCI(1)
      XP(1)=-1.
      XP(2)=1.
      YP(1)=0.
      YP(2)=0.
      CALL PGLINE(2,XP,YP)
      CALL PGLINE(2,YP,XP)
      CALL PGLABEL(' ',' ',ITITLE)
C
C DRAW THE CIRCLE
      ASTEP=PIBY2/50
      ANG=0
      DO 2 IQUAD=1,4
      DO 3 I=1,51
      XP(I)=COS(ANG)
      YP(I)=SIN(ANG)
      ANG=ANG+ASTEP
    3 CONTINUE
      CALL PGLINE(51,XP,YP)
      ANG=ANG-ASTEP
    2 CONTINUE
      CALL PGSCH(1.)
      CALL PGPTEXT(1.+OFFST1,0.,0.,0.,'X')
      CALL PGPTEXT(0.,1.+OFFST1,0.,0.5,'Y')
C
C PLOT THE POINTS
      ICOL=1
      DO 5 NP=1,NPTS
      ICOL=ICOL+1
      IF (ICOL.GT.16) ICOL=2
      CALL PGSCI(ICOL)
      SIGN=1
      DO 6 INOUT=1,2
      ICHR=INOUT*2
      THET=RADIAN(PANGS(2,INOUT,NP))
      IF (THET.GT.PIBY2) THEN
        THET=PI-THET
        FAC=TAN(RADIAN(PANGS(2,INOUT,NP))/2.)
        CHRSZ=2.
        ICHR=ICHR-1
      ELSE
        CHRSZ=1.3
      ENDIF
      FAC=TAN(THET/2.)
      XP(1)=FAC*COS(RADIAN(PANGS(3,INOUT,NP)))
      YP(1)=FAC*SIN(RADIAN(PANGS(3,INOUT,NP)))
C OPPOSITE OFFSETs FOR UP AND DOWN POINTS NEAR THE CENTRE
      IF (180-PANGS(2,INOUT,NP).LT.4) THEN
        YP(2)=YP(1)+OFFST3/2.
      ELSE
        YP(2)=YP(1)-OFFST3
      ENDIF
      XP(2)=XP(1)+OFFST2*SIGN
      CALL PGSCH(CHRSZ)
      CALL PGPOINT(1,XP(1),YP(1),ISYMB(ICHR))
      IF (NP.LT.10) THEN
        WRITE (BUF,11) NP
   11 FORMAT (I1)
      ELSE
        WRITE (BUF,12) NP
   12 FORMAT (I2)
      ENDIF
      CALL PGSCH(1.)
      CALL PGPTEXT(XP(2),YP(2),0.,0.5,BUF)
      SIGN=-SIGN
    6 CONTINUE
      POL(NP)=PL(2)/PL(1)
    5 CONTINUE
C
C  PLOT POLARISATIONS
      ICOL=1
      CALL PGVPORT(0.55,0.9,0.05,0.99)
      CALL PGWINDOW(0.0,1.,0.0,1.)
      CALL PGSFS(2)
      CALL PGSLS(1)
      CALL PGSCH(1.)
      CALL PGSCI(ICOL)
      DPOS=0.03
      DPOS2=DPOS/2
      AL=(FLOAT(NP)+2)*DPOS
      POS=(1.0+AL)/2.
      WRITE (BUF,15) HKL
   15 FORMAT ('Reflection:',F6.2,2(1X,F6.2))
      CALL PGMTEXT('LV',-0.5,POS+DPOS,0.,BUF)
      CALL PGRECT(0.,1.,POS-AL,POS)
      YP(1)=POS-AL
      YP(2)=POS
      XP(1)=0.16
      XP(2)=0.16
      CALL PGLINE(2,XP,YP)
      XP(1)=0.52
      XP(2)=0.52
      CALL PGLINE(2,XP,YP)
      XP(1)=0.76
      XP(2)=0.76
      CALL PGLINE(2,XP,YP)
      XP(1)=0.
      XP(2)=1.
      POS=POS-DPOS
      CALL PGTEXT(.01,POS,'Point  Polarisation')
      CALL PGTEXT(.62,POS,'\\(0634)')
      CALL PGTEXT(.84,POS,'\\(0647)')
      YP(1)=POS-DPOS
      YP(2)=POS-DPOS
      CALL PGLINE(2,XP,YP)
      POS=POS-2.*DPOS
      DO 7 NP=1,NPTS
      ICOL=ICOL+1
      IF (ICOL.GT.16) ICOL=2
      CALL PGSCI(ICOL)
      WRITE (BUF,13) ERRCH(NP),NP
  13  FORMAT (A1,I2,6X)
      CALL ESDFMT(PANGS(1,2,NP),DPANGS(1,NP),BUF(5:),10)
      CALL PGTEXT(0.02,POS,BUF)
      CALL ESDFMT(PANGS(2,2,NP),DPANGS(2,NP),BUF,8)
      CALL PGTEXT(0.51,POS,BUF)
      CALL ESDFMT(PANGS(3,2,NP),DPANGS(3,NP),BUF,8)
      CALL PGTEXT(0.75,POS,BUF)
      POS=POS-DPOS
    7 CONTINUE
    1 CONTINUE
C
  100 RETURN
      END
C
C
C
C
      SUBROUTINE COMPON(SPC,COMP,DCOMP)
C
C ** COMPON new by PJB Aug 1995 ***
C
CH  To get the components of polarisation and their esd's
C
      DIMENSION SPC(3,2),COMP(3),DCOMP(3)
      RTHET=RADIAN(SPC(2,1))
      RDTHET=RADIAN(SPC(2,2))
      RPHI=RADIAN(SPC(3,1))
      RDPHI=RADIAN(SPC(3,2))
      PSTHET=SPC(1,1)*SIN(RTHET)
      PCTHET=SPC(1,1)*COS(RTHET)
      CSPHI=COS(RPHI)
      SNPHI=SIN(RPHI)
      COMP(1)=PSTHET*CSPHI
      COMP(2)=PSTHET*SNPHI
      COMP(3)=PCTHET
      DPOL=(SPC(1,2)/SPC(1,1))**2
      SQRD=(PCTHET*CSPHI*RDTHET)**2 + (PSTHET*SNPHI*RDPHI)**2 +
     &(COMP(1)**2)*DPOL
      DCOMP(1)=SQRT(SQRD)
      SQRD=(PCTHET*SNPHI*RDTHET)**2 + (PSTHET*CSPHI*RDPHI)**2 +
     &(COMP(2)**2)*DPOL
      DCOMP(2)=SQRT(SQRD)
      SQRD=(PSTHET*RDTHET)**2 + (COMP(3)**2)*DPOL
      DCOMP(3)=SQRT(SQRD)
      RETURN
      END
C
C
C
C
C LEVEL 50      PROGRAM D3OP97
      PROGRAM D3OP97
C
C *** D3OP97 updated by PJB  02-Feb-1998 ***
C
CC 2D
CH Analysis of raw D3 data
C
CD Reads the data files, written by the polarised neutron
CD diffractometer D3, from the ILL ASCII data base and processes
CD them according to the chosen options.
CD The processing procedure depends upon the orders being processed
CD and it is not useful to process different classes of order in the
CD same run. The  different classes are:
CD    A. Flipping ratios (*BPB and *HKM, *SRM type 0)
CD    B. Angle scans (*AIS and *HKM, *SRM type 1)
CD       Note that COL5D3 may be more appropriate in this case
CD    C. Centering data
CD
CD A. Flipping ratios
CD    The program reads the detector counts, monitor counts and times
CD    for the measurements in two spin states for the peak and for the
CD    background. A dead time correction is made and the results used
CD    to calculate the flipping
CD    ratios. Checks are carried out on the consistency of successive
CD    measurements of the same peak, and of the reproducibility of the peak
CD    count between the measurement value and the value found in the peak
CD    search.
CD B. Angle Scans
CD    After making a lost counts correction the recorded counts in eqch
CD    channel are printed together with the value of the primary scanned
CD    angle and a cumulative sum of the counts. These may be used to estimate
CD    a crude integrated intensity.
CD    To obtain better integrated intensities use COL5D3.
CD
CD C. The results of the centering orders can be extracted for use in
CD    determining the UB matrix, lattice parameters etc.
C
CI A sequence of the ASCII data files written by D3. These are
CI normally taken from the ILL database, but will be taken from the
CI path given in the environment variable D3DATA if that is defined. The
CI current (Sept 1998) path for the ILL data base is /usr/illdata,
CI if another path is needed it can be given in the environment
CI variable ILLDATA. The sequence of files is terminated by a
CI missing file in the sequence:
CI      fname(n+1)= fname(n) + 1
CI where 9+1=a, a+1=b ... and z+1=10
C
CO A listing file which reports the processing which was done and
CO any changes which were made to the experimental configuration (eg.
CO changes of wavelength, filter etc) during the run.
CO
CO A file "dcards.cry" to which the polarisation, UB matrix and wavelength are
CO written each time they change.
CO
CO If flipping ratio measurements are being processed the results are
CO written on an output file with default extension ".fli". The data
CO recorded for each reflection are: a sequence number, the hkl, the
CO diffractometer angles \$\omega\$,  \$\gamma\$ and \$\nu\$,
CO the flipping ratio and its standard deviation, the peak count
CO in cps (background corrected), the temperature and  magnetic
CO field and finally the date and time of the
CO measurement. FORMAT (4I5,3F8.2,2F10.6,F10.1,32A1).
CO This file is suitable for input to ARRNGE with DTYP 1.
CO
CO A binary file comdat.bin which records the parameters which were
CO defined during the processing, and which will be reused in future
CO runs of D3OP97 which then do not need to be initialised.
C
CR When running the program the user is asked whether to "Initialise"
CR or "Not" or whether to "Continue". The reply is "Y"es to start a new
CR experiment or if the common data have been changed since the last
CR run, i.e. the sample, experimental conditions, or wavelength are
CR different. Reply "C"ontinue to proceed without asking questions. If
CR the reply is C processing will continue from the next file in
CR sequence after the last processed in the previous run. The reply
CR should be "N"o if there is a break in the sequence of output files.
CR
CR If the reply is Y or N futher questions are posed to allow the
CR source of data to be identified. The replies to most questions
CR should be self evident. The cycle number is 0 or "return"
CR for the current cycle, -1 for the previous cycle, otherwise the 3
CR digit cycle number eg 964 for the 4th cycle in 1994.
CR
CR The first and optionally last files to
CR process should be in lower case without an extension.
CR
CR The orders to be processed should be one or more of *BPB, *AIS, *CEN
CR *HKL, *HKM, *SRM  But as mentioned above it is not
CR usually useful to process different classes of order in the same run.
C
CN Uses new UNIX database. The path from which to read the
CN data can be specified by the environment variable D3DATA
CN The path for the data base can be given in the environment variable
CN ILLDATA. It defaults to /usr/illdata (Sept98).
CN Non-Integer indices can be printed
C
C **********************************************************************
C
C                            D 3 O P 9 7
C
C  NEW D3 PROCESSING PROGRAM FOR MAD SYSTEM 1997 VERSION for UNIX DATA
C
C **********************************************************************
C
      DIMENSION IDUM(4),ADUM(9),ICOMDA(52)
      CHARACTER*6 TERM
      CHARACTER*60 DEFT
      CHARACTER*260 ICOMCH,DUMNAM*8
      CHARACTER*4 MORD(9),UNORD
      DIMENSION ICOM(9)
      LOGICAL START,BEGIN,SAYS,RDCOM,CHGPAR,CONT,ISEFF
      CHARACTER*100 FMT1
      COMMON /ALWORD/LWORD(27),KEY(6),JWORD(3)
      CHARACTER*5 LWORD,KEY,JWORD
/D3OPC/
/D3OPN/
/GLOBAL/
      COMMON /HEDING/ HEADNG
      CHARACTER*135 HEADNG
/IOUNIT/
      COMMON /NWORDS/NLWORD,NLWRD1,NKEY,NJWORD,NCOM,NPTAB(22)
/SCRACH/
      EQUIVALENCE(ICOMDA,IGEO),(ICOMCH,ISNAME)
      DATA MORD/'*HKM','*AIS','*BPB','*POB','*HKL','*SRM','*CEN','*CEA'
     &,'*RTE'/
      DATA NMORD/9/
C
      START=.TRUE.
      BEGIN=.TRUE.
      IEND=.TRUE.
C  TO CHOOSE APPEND FOR WRITE FILES
      INIT=124
C
C  SET UP
      CALL INITIL('D3OP97')
   56 CALL ASK('INITIALISE ? Answer Y(es), N(o) C(ont) or H(elp)')
      IF (SAYS('H')) THEN
        CALL MESS(ITO,0,'Reply Yes if you are starting a new '//
     &  'experiment or if the common data have been')
        CALL MESS(ITO,0,'changed since the last run, i.e. the '//
     &  'sample, experimental conditions, UBM or')
        CALL MESS(ITO,0,'wavelength are different')
        CALL MESS(ITO,0,'Reply Continue to continue processing as '//
     &  'before in the standard file sequence')
        CALL MESS(ITO,0,'Reply No if you want the opportunity to '//
     &  'change a file-name or the orders to be processed')
        GO TO 56
      ENDIF
C
      CONT=SAYS('C')
      IF (SAYS('Y')) GO TO 59
      RDCOM=.FALSE.
      MESSAG='COMDAT.BIN'
      CALL UPONE(MESSAG,3)
      ICOMU=NOPFIL(1021)
      READ (ICOMU) ICOMDA,ICOMCH
      START=.FALSE.
      DO 46 I=1,4
      LUN(I)=-LUN(I)
   46 CONTINUE
      CALL CLOFIL(ICOMU)
      IF (CONT) GO TO 57
      CALL ASK('User is: '//IUNAME//' Sample is: '//ISNAME//
     & ' OK ? Y(es) or N(o)')
      IF (.NOT. SAYS('Y')) GO TO 59
      LDIR=LENGT(DATDIR)
      CALL MESS(ITO,0,'Data will be read from '//DATDIR(1:LDIR)//IP1)
      CALL ASK('OK ? Y(es) or N(o)')
      IF (.NOT. SAYS('Y')) THEN
        CALL INFILE
      ENDIF
C
   57 IF (CONT) GO TO 64
      L=LENGT(OP2)
      WRITE (MESSAG,226) L
      WRITE(ITO,MESSAG)OP2,NSEQ(1)
  226 FORMAT ('('' Results will be appended to file '',A',I3,
     1','' starting at sequence number'',I5)')
      CALL ASK('OK ? Y(es) or N(o)')
      IF (SAYS('Y')) GO TO 64
      CALL ASK('Give new output file-name')
      OP2=MESSAG
      LUN(2)=0
      INIT=122
      GO TO 61
C
C  COMMON DATA FILE NOT FOUND
   60 CALL ASK('Common data file COMDAT.BIN was not found. Continue ?'//
     & 'Y(e)s or N(o)')
      IF (.NOT. SAYS('Y')) STOP
C
C  HERE TO INITIALISE
C  SET STATUS NEW FOR WRITE FILES
   59 INIT=122
   58 CALL INFILE
      CALL ASK('Give output file name')
      OP2=MESSAG
   61 CALL ASK('Sequence number for first reflection?')
      CALL RDINTG(NSEQ(1),1,IPT,80,IER)
      IF (.NOT. START) GO TO 64
C     PUT IN THOSE D3 INSTRUCTIONS TO BE PROCESSED IN THIS RUN
   63 CALL ASK('Give the orders to be processed in this run, A4,1X,..')
      READ (ICARD,214) NORD
  214 FORMAT (10(A4,1X))
C     NOW RECOGNISE ORDERS AND SET MARKERS
   64 DO 51 I = 1,NMORD
   51 ICOM(I) = 0
      DO 52 I = 1,NMORD
      IF (NORD(I) .EQ. ' ') GO TO 54
C     END OF LIST
      DO 53 J = 1,NMORD
C ALLOW LOWER CASE ORDERS
      UNORD=NORD(I)
      CALL UPPER(UNORD)
      IF (UNORD .NE. MORD(J)) GO TO 53
      ICOM(J) = 1
      GO TO 52
   53 CONTINUE
   52 CONTINUE
   54 NUMORD=I
C FORCE READ TEMPERATURE TO BE PROCESSED
      IF (ICOM(9).EQ.0) THEN
        ICOM(9)=1
        NUMORD=I+1
      ENDIF
      IMEAS=0
      IF (START .OR. CONT) GO TO 62
      WRITE(ITO,303) (NORD(II),II=1,I)
  303 FORMAT (' The orders which will be processed are : ',6(A5))
      CALL ASK('OK ? Y(es) or N(o)')
      IF (.NOT. SAYS('Y')) GO TO 63
   62 NAMFIL='.FLI'
      IF (ICOM(1).EQ.1) THEN
C ask which type of measurement
        CALL ASK('Which type of hkm scan? (return gives BPB)')
        CALL RDINTG(IMEAS,1,10,IPT,IER)
        IF (IER.NE.0) IMEAS=0
      ENDIF
C      IF (ICOM(2).EQ.1 .OR. IMEAS.EQ.1) THEN
C IF PROCESSING SCANS OPEN PLOTTER WINDOW
C       CALL ASK('Display on Tektronix or X-terminal (T/X)')
C       IF (SAYS('T')) THEN
C         TERM='/TEK4010'
C       ELSE IF (SAYS('X')) THEN
C         TERM='/XWIN'
C       ELSE
C         GO TO 20
C       ENDIF
C       CALL PUTENV('PGPLOT_ILL_DEV_1='//TERM)
C       CALL PUTENV('PGPLOT_ILL_DEV_2=/PS')
C       CALL PGOPJB(0,IER,3,3)
C       IF (IER.NE.0) STOP 'ERROR OPENING PGPLOT'
C       CALL PGPAPER(0.0,1.)
C      CALL PGSLCT(1,IOLD,IER)
C      CALL PGASK(.TRUE.)
C      ENDIF
      MESSAG=OP2
      LUNO=NOPFIL(INIT)
      OP2=NAMFIL
      MESSAG='DCARDS.CRY'
      CALL UPONE(MESSAG,3)
      NAMFIL=' '
      NEWIN=NOPFIL(INIT)
C
C  PUT OUT HEADING
      IF (START) GO TO 3
   36 START=.FALSE.
      WRITE (LPT,130)
      WRITE (LPT,131)
      CALL ADDSPC(ISNAME,8)
      CALL ADDSPC(IUNAME,8)
      WRITE (LPT,132) ISNAME,IUNAME
      CALL ADDSPC(MONOID,8)
      CALL ADDSPC(FILTER,8)
      WRITE (LPT,135) MONOID,FILTER
      J2=40-5*NUMORD
      J1=J2/2
      J2=J2-J1
      WRITE (FMT1,134) J2,NUMORD,J1
      WRITE (LPT,FMT1) (NORD(II),II=1,NUMORD)
      WRITE (LPT,131)
      WRITE (LPT,133)
C      WRITE (LPT,136) TMORTS(1),TMORTS(3),TMORTS(2),TMORTS(4)
  130 FORMAT ('0',25X,13('*****')/26X,'*',22X,'D3 DATA PROCESSING'
     1,23X,'*')
  131 FORMAT (26X,'*',63X,'*')
  132 FORMAT (26X,'*',11X,'Sample Name:',A8,'  User Name:',A8,12X,'*')
  133 FORMAT (26X,13('*****')/)
  134 FORMAT ('(26X,''*'',',I2,'X,''Orders being Processed:'',',I2,
     1'(1X,A4)',I2,'X,''*'')')
  135 FORMAT (26X,'*',11X,'Monochromator: ',A8,'   Filter: ',
     1A8,10X,'*')
  136 FORMAT ('0       Dead time parameters: a = ',
     1E11.3,'+/-',E11.3,' b = ',E11.3,'+/-',E11.3//)
      WRITE (LPT,HEADNG)
      LCOUNT=28
C  *****START TO READ DATA*****
    3 JK=NCHECK(1,0)
      IF (JK.LE.0) GO TO 90
      IF (JK.EQ.1) GO TO 1
      IF (.NOT. START) GO TO 20
C  MUST READ COMMON DATA TO START PROCESSING
      IF (.NOT.BEGIN)GO TO 3
      LCOUNT=LCOUNT+1
      CALL MESS(LPT,0,' ***Warning: File does not start with a '//
     & 'common data block')
      BEGIN=.FALSE.
      GO TO 3
C
C  READ SELECTED PARTS OF COMMON DATA
    1 RDCOM=.TRUE.
      ICD=0
   30 ICD=ICD+1
      IF (ICD.GT.NCOM) THEN
        RDCOM=.FALSE.
        IF (START) GO TO 36
        GO TO 3
      ENDIF
      IS=1
    4 GO TO (14,4,90,91,92,93), 1-NCHECK(3,ICD)
   14 GO TO (2,17,6,7,18,19,8,13,15,16,25,21),ICD
C
C  COME HERE AFTER DATA OR ORDER TO UPDATE DATA
   20 I=NCFIND(MESBUF(7:11),LWORD,NLWRD1)
      IF (I.EQ.0) GO TO 3
C  WORD NOT RECOGNISED
      II=NPTAB(I)
      IS = 7
      IF(I.EQ.9) IS=1
      IF(I.EQ.10) IS=2
      GO TO (2,3,6,7,18,19,8,3,15,16,25,21,42,43,13,44,71,23,
     124,17,45,45,50),I
C
C  SECTION GIVING PROCEDURES AFTER DATA KEYWORDS
C  SAMPLE NAME
    2 IF (RDCOM) THEN
        READ (MESBUF,100)DUMNAM,IUNAME
      ELSE
        READ (MESBUF(IS:),100)DUMNAM
      ENDIF
      IF (DUMNAM.EQ.ISNAME) GO TO 5
C  HERE FOR NEW SAMPLE
      ISNAME=DUMNAM
      IF (START) GO TO 5
      CALL TESTP(LPT,LCOUNT,1,HEADNG,2)
      LCOUNT=LCOUNT+1
      CALL MESS(LPT,1,MESBUF)
      GO TO 5
C
C  GEOMETRY
    6 IF (RDCOM) THEN
        READ(MESBUF,101) IGEO
      ELSE
        READ(MESBUF,111) IGEO
      ENDIF
      GO TO 5
C
C  WAVELENGTH
    7 READ(MESBUF(IS:),102) ADUM(1)
      IF (.NOT. CHGPAR(ADUM,ALAM,1)) GO TO 5
      IF (START) GO TO 10
      CALL TESTP(LPT,LCOUNT,1,HEADNG,2)
      LCOUNT=LCOUNT+1
      WRITE (LPT,122) ALAM,ADUM(1)
  122 FORMAT ('  ***Warning: Change of wavelength Old=',F10.4,' New ='
     1,F10.4)
      WRITE (NEWIN,124) ALAM,UBM
   10 ALAM=ADUM(1)
      GO TO 5
C
C  UB MATRIX
    8 N=0
    9 READ (MESBUF(IS:),103) (ADUM(3*N+I),I=1,3)
      N=N+1
      IF (N.EQ.3) GO TO 11
      GO TO (9,4,90,91,92,93),1-NCHECK(2,0)
   11 IF (.NOT. CHGPAR(ADUM,UBM,9)) GO TO 5
      IF (START) GO TO 12
      CALL TESTP(LPT,LCOUNT,1,HEADNG,2)
      LCOUNT=LCOUNT+1
      CALL MESS(LPT,0,' ***Warning: Change of UB-Matrix')
   12 CALL GMEQ(ADUM,UBM,1,9)
      WRITE (NEWIN,124) ALAM,UBM
  124 FORMAT ('D WVLN',F10.4/'D GEOM 8'/'D L/R 1',3,(/'D UMAT',3F10.5))
      GO TO 5
C
C  INDICES AND MEASUREMENT TYPE
   13 IF (RDCOM) THEN
        READ(MESBUF,104)H,IMTYP
        GO TO 30
      ENDIF
      READ(MESBUF,114)H,IMTYP
      IF (JK.NE.3 .OR. ICOM(II).NE.1 .OR. IMTYP.NE.IMEAS) GO TO 3
C  SWITCH TO PROCESS A MEASUREMENT
      M=1
      GO TO (40,41,42) ,IMTYP+1
C
C  ANGLE SCAN DATA
   15 READ(MESBUF(IS:),105) (AIS(I),I=1,3),IAIS
      IF (RDCOM) GO TO 30
      IF (JK.NE.3 .OR. ICOM(II).NE.1) GO TO 3
      M=1
   41 CALL AISPRC(M,LUNS)
      IF (M.GE.0 .OR. M.EQ.-1) GO TO 3
C  NO ERRORS
      JK=-(2+M)
      IF (JK .LE.0) GO TO 90
      GO TO 3
C
C  B-P-B DATA OR ORDER
   16 READ (MESBUF(IS:),106) NBPB
      IF (RDCOM) GO TO 30
      IF (JK.NE.3 .OR. ICOM(II).NE.1) GO TO 3
      M=3
   40 CALL BPBPRC(M)
      IF (M.GE.0 .OR. M.EQ.-1) GO TO 3
C  NO ERRORS
      JK=-(2+M)
      IF (JK .LE.0) GO TO 90
C  END OF DATA
   94 GO TO (1,20,20),JK
C  ERROR RETURN HAVING READ ANOTHER ORDER
      GO TO 3
C
C  BLIND SPOTS
   17 IF (RDCOM) THEN
        READ (MESBUF,112) BLSPS
      ELSE
        READ(MESBUF,113) BLSPS
      ENDIF
      GO TO 5
C
C MONOCHROMATOR
   18 READ (MESBUF(IS:),115) DUMNAM,IPOL
      IF (DUMNAM .EQ. MONOID) GO TO 5
      IF (.NOT. START) THEN
        CALL TESTP(LPT,LCOUNT,1,HEADNG,2)
        LCOUNT=LCOUNT+1
        CALL MESS(LPT,0,' ***Warning: Change of monochromator Old : '//
     &  MONOID//' New : '//DUMNAM)
      ENDIF
      MONOID=DUMNAM
      GO TO 5
C
C FILTER
   19 READ (MESBUF(IS:),116) DUMNAM
      GO TO 22
   23 READ (MESBUF,107) DUMNAM
      GO TO 22
   24 READ (MESBUF,108) DUMNAM
   22 IF (DUMNAM.EQ.FILTER) GO TO 5
      IF (.NOT. START) THEN
        CALL TESTP(LPT,LCOUNT,1,HEADNG,2)
        LCOUNT=LCOUNT+1
        CALL MESS(LPT,0,' ***Warning: Change of Filter Old : '//
     &  FILTER//' New : '//DUMNAM)
      ENDIF
      FILTER=DUMNAM
      GO TO 5
C
C DEAD-TIME
   25 READ (MESBUF(IS:),109) (ADUM(I),I=1,4)
      IF (.NOT.CHGPAR(ADUM,TMORTS,4)) GO TO 5
      IF (.NOT. START) THEN
        CALL TESTP(LPT,LCOUNT,2,HEADNG,2)
        LCOUNT=LCOUNT+2
        WRITE (LPT,150) ADUM(1),ADUM(3),ADUM(2),ADUM(4),
     &  TMORTS(1),TMORTS(3),TMORTS(2),TMORTS(4)
  150   FORMAT ('  ***Warning: Change of dead-time Old: a = ',
     &  E11.3,'+/-',E11.3,' b = ',E11.3,'+/-',E11.3/34X,'New: a = ',
     &  E11.3,'+/-',E11.3,' b = ',E11.3,'+/-',E11.3)
      ENDIF
      CALL GMEQ(ADUM,TMORTS,1,4)
      GO TO 5
C
C POLARISATION
C POL ORDER SWITCHES UP OR DOWN,  COMMON  or /DPL CHANGES VALUES
   21 IF (JK.GT.1) GO TO 5
      READ(MESBUF(IS:),110) (ADUM(I),I=1,4)
      IF (.NOT.CHGPAR(ADUM,POLARS,4)) GO TO 5
      ISEFF=(ADUM(3).GT.0)
      IF (.NOT.START) THEN
        CALL TESTP(LPT,LCOUNT,2,HEADNG,2)
        LCOUNT=LCOUNT+2
        IF (ISEFF) THEN
          WRITE (LPT,129) POLARS,(ADUM(I),I=1,4)
  129 FORMAT ('  ***Warning: Change of polarisation Old: P =',F8.4,
     & ' +/-',F8.4,'e = ',F8.4,'+/-',F8.4/36X,'New P =',F8.4,
     & '+/-',F8.4,'e = ',F8.4,'+/-',F8.4)
        ELSE
          WRITE (LPT,128) POLARS,(ADUM(I),I=1,4)
  128 FORMAT ('  ***Warning: Change of polarisation Old: Pup =',F8.4,
     & ' +/-',F8.4,'Pdown = 'F8.4,'+/-',F8.4/36X,'New: Pup =',F8.4,
     & '+/-',F8.4,'Pdown= 'F8.4,'+/-',F8.4)
        ENDIF
      ENDIF
      CALL GMEQ(ADUM,POLARS,4,1)
      IF (ISEFF) THEN
        WRITE (NEWIN,140) POLARS
  140 FORMAT ('P ',4F10.4)
      ELSE
        WRITE (NEWIN,141) POLARS
  141 FORMAT ('P UP ',2F10.4,' DOWN',2F10.4)
        ENDIF
      GO TO 5
C
C AFTER READING DATA
    5 IF (RDCOM) GO TO 30
      GO TO 3
C
C  READ ANGLES IF SET
   70 IF (JK.EQ.3) READ(MESBUF,119) ANG
      GO TO 3
C
C  READ DATE,TIME AND DVM
   71 IF (JK.NE.3) GO TO 3
      DATE=MESBUF(21:39)
      DVM=MESBUF(54:65)
      GO TO 3
C   28 II=I-3
C      GO TO (25,26,27,42,43,44),II
C
C  POB SCAN
   42 IF (JK.NE.3 .OR. ICOM(II).NE.1) GO TO 3
      CALL POBPRC(M)
      IF (M.LT.0) GO TO 90
      GO TO 3
C
C  HKL SET
   43 READ (MESBUF,118) H
      GO TO 3
C
C  STANDARD REFLECTION
   44 READ (MESBUF,117) H
      IF (JK.NE.3 .OR. ICOM(II).NE.1) GO TO 3
C  SET FOR STANDARD
      M=2
      GO TO (40,41,42),IMTYP+1
C
C  CENTREING
   45 READ (MESBUF(2:),118) H
      IF (JK.NE.3 .OR. ICOM(II).NE.1) GO TO 3
      CALL CENPRC(MC)
      IF (MC.GE.0) GO TO 3
      JK=MC
      GO TO 90
C
C  READ TEMPERATURE
   50 MC=NCHECK(3,NLWRD1+4)
      IF (MC.EQ.0) READ(MESBUF,120) TEMPER
      IF (MC.GE.-1) GO TO 3
      JK=MC
      GO TO 90
C
C  END OF DATA
   91 JK=1
      GO TO 94
   92 JK=2
      GO TO 94
   93 JK=3
      GO TO 94
   90 JK=-(2+JK)
      IF (JK.GT.0) GO TO 94
      WRITE(ITO,125)NSEQ(1)
  125 FORMAT (' Next free sequence number is',I5)
C
C Close any plotter output
C      IF (ICOM(2).NE.0) THEN
C        CALL PGEND3(0)
C      ENDIF
C  WRITE THE UPDATED COMMON DATA FILE
      MESSAG='COMDAT.BIN'
      CALL UPONE(MESSAG,3)
      ICOMU=NOPFIL(1023)
      WRITE (ICOMU) ICOMDA,ICOMCH
      CALL CLOFIL(ICOMU)
      STOP
C  FORMATS FOR READING THE DATA AND COMMON DATA
  100 FORMAT (13X,A8,12X,A8)  !SAMPLE  AND USER NAME
  101 FORMAT (17X,3I5)   !GEOMETRY
  102 FORMAT (11X,F10.4)  !WAVELENGTH
  103 FORMAT (11X,3F10.6)  !UB MATRIX
  104 FORMAT (19X,3F10.4,18X,I5) !HKL AND MTYPE
  105 FORMAT (16X,3F8.4,I8)  !ANGLE SCAN DATA
  106 FORMAT (34X,I8)   !BPB REPEAT NO
  107 FORMAT (31X,A8)   !PHOTO - FILTER
  108 FORMAT (27X,A8)                   !SET BEAM - FILTER
  109 FORMAT (17X,2(F11.8,F16.13))      !DEAD TIME
  110 FORMAT (14X,4F8.4)                !POLARISATION
  111 FORMAT (23X,3I8)          !GEOMETRY
  112 FORMAT (12X,8F8.2)                !BLIND SPOTS
C  113 FORMAT (22X,8F8.2)               !SOFTWARE LIMITS
  113 FORMAT (36X,8F8.2)                !format changed May 99
  114 FORMAT (21X,3F10.4,I5)     !HKM
  115 FORMAT (18X,A8,11X,I2)            !MONOCHROMATOR
  116 FORMAT (8X,A8)                    !FILTER
  117 FORMAT (30X,3F10.5)  !STANDARD
  118 FORMAT (11X,3F10.4)         !HKL
  119 FORMAT (41X,3F8.4)                !ANGLES
  120 FORMAT (14X,A8   )                !TEMPERATURE
      END
C
C
C
C
      SUBROUTINE BPBPRC(M)
C
C *** BPBPRC modified by PJB Jun 90 to check reproducubility of peak ***
C
CH Processes BPB scans
C
      LOGICAL INTIND,PKSR
      DIMENSION FJCOUN(3,2),FCOUNT(3,2,2),RATE(2,2),VRATE(2,2),PEAK(2)
     & ,VPEAK(2),TOTMON(2),KH(3),CALANG(3)
/D3OPC/
/D3OPN/
/IOUNIT/
      COMMON /HEDING/ HEADNG
      CHARACTER*135 HEADNG
      COMMON /NWORDS/NLWORD,NLWRD1,NKEY,NJWORD,NCOM,NPTAB(22)
      CHARACTER*2 ISTAN(3),AWORD(3)*5
      DATA ISTAN/'  ','**',' #'/
      DATA AWORD/'Omega','Theta',' Nu'/
C
C  SAVE INFORMATION ON TYPE
      MM=M
C
C  CLEAR THE COUNT BUFFER
      DO 16 I=1,3
      DO 16 J=1,2
      DO 16 K=1,2
   16 FCOUNT(I,J,K)=0.
C
      PKSR=.FALSE.
      CPSMAX=0
      IF (M.EQ.3) GO TO 20
C
    2 M = NCHECK(3,NLWRD1+1)
      IF (M.LT.-1) GO TO 100
C  END OF DATA OR ANOTHER KEYWORD
      IF (M.EQ.-1) THEN
        IF (PKSR) THEN
          DO 30 I=1,8
          IF (MESBUF(I:I).EQ.' ') GO TO 30
          IF((MESBUF(I:I).LT.'0' .OR.MESBUF(I:I).GT.'9')
     &    .AND.MESBUF(I:I).NE.'.'.AND. MESBUF(I:I).NE.'-') GO TO 2
   30     CONTINUE
          READ (MESBUF(74:),1100) CPS,DCPS
 1100     FORMAT (2F10.4)
          IF (CPS.GT.CPSMAX) THEN
            CPSMAX=CPS
            DCPSM=DCPS
          ENDIF
        ENDIF
        GO TO 2
      ENDIF
C  TO READ ANOTHER LINE
    1 READ(MESBUF,1000) (ANG(I),I=1,3)
 1000 FORMAT (35X,3F8.4)
C
   19 M=NCHECK(5,0)
      IF (M.LT.-1) GO TO 100
C  END OF DATA OR ANOTHER KEYWORD
      IF (M.NE.0) THEN
        IF (MESBUF(1:5).EQ.'SHAFT') THEN
          M=NCHECK(5,0)
          IF (M.LT.-1) GO TO 100
        ENDIF
      ENDIF
      PKSR=M.EQ.0
      IF (PKSR) THEN
        CALL GMEQ(ANG,CALANG,3,1)
        GO TO 2
      ENDIF
   18 if (mesbuf(1:4).eq.'D3B:')READ (MESBUF,101) DATE
  101 FORMAT (4X,A19)
      M=NCHECK(5,0)
      if (mesbuf(1:4).eq.'O/P:')READ (MESBUF,108) TEMPER,FIELD,DVM
  108 FORMAT (39X,A8,6X,A8,6X,A8)
C
   20 M=NCHECK(3,NLWRD1+2)
      IF (M.LT.-1) RETURN
C  END OF DATA OR ANOTHER KEYWORD
      IF (M.EQ.-1) GO TO 20
C
C  TRY AGAIN
    4 DO 5 II=1,NBPB
      DO 6 KK=1,3
      K=MOD(KK,2)+1
      M=NCHECK(2,0)
      IF (M.LT.0) GO TO 8
C
C  ERROR
    7 READ (MESBUF,102) ((FJCOUN(I,J),J=1,2),I=1,3)
  102 FORMAT (2(F10.1,1X),2(F10.4,1X),F10.1,1X,F10.1)
      DO 9 I=1,3
      DO 9 J=1,2
    9 FCOUNT(I,J,K)=FCOUNT(I,J,K)+FJCOUN(I,J)
    6 CONTINUE
C blank lines are skipped on input
C      M=NCHECK(4,1)
      IF (M.LT.0) GO TO 8
    5 CONTINUE
C
C  NOW GET THE RATES AND THE LOST COUNTS CORRECTION
    8 IF (II .LT.2) GO TO 100
C***
C EXTRA FOR VME RATHER THAN FCU FLIPPER CONTROL
      DO 15 K=1,2
      TOTMON(K)=FCOUNT(3,1,K)+FCOUNT(3,2,K)
      TOTIM=FCOUNT(2,1,K)+FCOUNT(2,2,K)
      IF (TOTIM.EQ.0) GO TO 12
      DO 15 J=1,2
      FCOUNT(3,J,K)=TOTMON(K)*FCOUNT(2,J,K)/TOTIM
   15 CONTINUE
C***
      DO 10 J=1,2
      DO 11 K=1,2
      IF (FCOUNT(2,J,K).EQ.0) GO TO 12
      IF (FCOUNT(3,J,K).EQ.0) GO TO 12
      TRATE=FCOUNT(1,J,K)/FCOUNT(2,J,K)
      VTRATE = TRATE/FCOUNT(2,J,K)
      CALL LSTCTS(TRATE,VCRATE,TMORTS)
      IF (TRATE .LT. 0 .OR. TRATE .GT.2.) GO TO 14
      RATE(J,K)= (FCOUNT(1,J,K)/FCOUNT(3,J,K))*TRATE
C   11 VRATE(J,K)=(RATE(J,K)/FCOUNT(3,J,K))*VTRATE
   11 VRATE(J,K)=
     &(VTRATE*TRATE**2+VCRATE)*(FCOUNT(2,J,K)/FCOUNT(3,J,K))**2
C
      PEAK(J)=RATE(J,1)-RATE(J,2)
      VPEAK(J)=VRATE(J,1)+VRATE(J,2)
      IF (PEAK(J).LE. SQRT(VPEAK(J))) GO TO 13
   10 CONTINUE
      R = PEAK(1)/PEAK(2)
C PART COMING FROM STATISTICAL ERROR IN DETECTOR COUNTS
      VRONR1= (VPEAK(1)/(PEAK(1)**2)) + (VPEAK(2)/(PEAK(2)**2))
C***
C PART COMING FROM STATISTICAL ERROR IN MOMITOR COUNTS
      VRONR2= (1./TOTMON(1)+1./TOTMON(2))*
     &(RATE(1,1)/PEAK(1)-RATE(2,1)/PEAK(2))**2
C***
      DR=R*SQRT(VRONR1+VRONR2)
      HTPK=(PEAK(1)+PEAK(2))*(FCOUNT(3,1,1)+FCOUNT(3,2,1))
     & /(2.*(FCOUNT(2,1,1)+FCOUNT(2,2,1)))
      BKG=(RATE(1,2)+RATE(2,2))*(FCOUNT(3,1,2)+FCOUNT(3,2,2))
     & /(2.*(FCOUNT(2,1,2)+FCOUNT(2,2,2)))
      IF (CPSMAX.NE.0) THEN
        CPSMAX=CPSMAX-BKG
        FEROR=DCPSM/CPSMAX
        IF (FEROR.LT..2)FEROR=.2
        IF (ABS(CPSMAX-HTPK)/CPSMAX .GT. FEROR) THEN
          CALL TESTP(LPT,LCOUNT,1,HEADNG,2)
          WRITE (LPT,1101) CPSMAX,HTPK
 1101     FORMAT (' *** Warning peak count not reproduced. ',
     &    F7.0 'in peak search, ',F7.0,' in BPB scan.')
        ENDIF
        DO 31 I=1,3
        IF (ABS(ANG(I)-CALANG(I)) .GT. .5) THEN
          CALL TESTP(LPT,LCOUNT,1,HEADNG,2)
          WRITE (LPT,1102) AWORD(I),CALANG(I),ANG(I)
 1102     FORMAT(' *** Warning observed and calculated angles ',A5,
     &    ' differ by more than 0.5 degrees: calculated ',F8.2,
     &    ' observed ',F8.2)
        ENDIF
   31   CONTINUE
      ENDIF
C
      CALL TESTP(LPT,LCOUNT,1,HEADNG,2)
      IF (INTIND(H,KH)) THEN
        WRITE (LPT,104) NSEQ(1),ISTAN(MM),KH,ANG,R,DR,HTPK,BKG,
     &  TEMPER,FIELD,DVM,DATE
  104   FORMAT (1X,I4,A2,3(I5,1X),3F8.2,2F10.6,F8.1,1X,F6.1,1X,
     &  3(A8,1X),A19)
        WRITE (LUNO,105) NSEQ(1),KH,ANG,R,DR,HTPK,TEMPER,DATE
  105   FORMAT (4I5,3F8.2,2F10.6,F10.1,2X,A8,3X,A19)
      ELSE
        WRITE (LPT,114) NSEQ(1),ISTAN(MM),H,ANG,R,DR,HTPK,BKG,
     &  TEMPER,FIELD,DVM,DATE
  114   FORMAT (1X,I4,A2,3F6.2,3F8.2,2F10.6,F8.1,1X,F6.1,1X,
     &  3(A8,1X),A19)
        WRITE (LUNO,115) NSEQ(1),H,ANG,R,DR,HTPK,TEMPER,DATE
  115   FORMAT (I5,3F6.2,3F8.2,2F10.6,F10.1,2X,A8,3X,A19)
      ENDIF
      NSEQ(1) = NSEQ(1)+1
      GO TO 100
C
C  ERRORS
C  DATA RUN OUT
    3 M=-1
      GO TO 100
C
C  NO DATA
   12 CALL TESTP(LPT,LCOUNT,1,HEADNG,2)
      WRITE (LPT,106) KH
  106 FORMAT (10X,3I5,'   Zero time for measurement')
      GO TO 100
C
C  R NOT SIGNIFICANT
   13 CALL TESTP(LPT,LCOUNT,1,HEADNG,2)
      WRITE (LPT,107) KH
  107 FORMAT (10X,3I5,'   R less than its error')
      GO TO 100
C
C  LOST COUNTS TOO BIG
   14 CALL TESTP(LPT,LCOUNT,1,HEADNG,2)
      WRITE (LPT,109) KH
  109 FORMAT (10X,3I5,'  Detector saturated')
 100  RETURN
      END
C
C
C
C
      SUBROUTINE POBPRC(M)
C
C *** POBPRC BY PJB OCT 88 ***
C
CH POB processing not implemented
/IOUNIT/
C
      CALL MESS(LPT,0,'P-O-B SCAN PROCESSING NOT IMPLEMENTED')
      RETURN
      END
C
C
C
C
      SUBROUTINE AISPRC(M,LUNS)
C
C *** AISPRC BY PJB OCT 88 ***
C
CH crude processing of angle scans
C
      CHARACTER*8 ANGNAM,TITLE*80
      DIMENSION XANG(201),COUNT(201),VCOUNT(201),R(201),DR(201)
      DIMENSION FCOUNT(3,2),RATE(2),VRATE(2),PEAK(2),VPEAK(2),KH(3)
/D3OPC/
/D3OPN/
/IOUNIT/
      COMMON /HEDING/ HEADNG
      CHARACTER*135 HEADNG
      COMMON /NWORDS/NLWORD,NLWRD1,NKEY,NJWORD,NCOM,NPTAB(22)
/SCRACH/
C
C
   19 M=NCHECK(5,0)
      IF (M.LT.-1)GO TO 100
      IF (M.NE.0) GO TO 19
C  END OF DATA OR ANOTHER KEYWORD
   18 READ (MESBUF,101) ANGNAM
  101 FORMAT (A8)
C
C open output file if required
      IF (LUN(2).LE.0) THEN
        CALL TESTP(LPT,LCOUNT,1,HEADNG,2)
        I=INDEX(OP2,'.')-1
        MESSAG=OP2(1:I)
        NAMFIL='.AIS'
        IF (LUN(2).LT.0) THEN
          LUN(2)=NOPFIL(124)
        ELSE
          LUN(2)=NOPFIL(122)
        ENDIF
      ENDIF
C
C WHICH ANGLE IS SCANNED?
      IANGLE=1
      DO 40 I=1,3
      IF (AIS(I).EQ.0.) GO TO 40
      IANGLE=I
      GO TO 41
   40 CONTINUE
   41 IF (IAIS.LT.0) THEN
        NSTEP=1-IAIS
      ELSE
        NSTEP=2*IAIS+1
      ENDIF
      CNTMAX=0
      WRITE (TITLE,120) IP1(1:6),NSEQ(2),H,TEMPER
  120 FORMAT (' File: ',A6,' Scan:',I2.2,' hkl =',3F8.3,2X,
     &'T =',A8)
      l=LENGT(TITLE)+1
      WRITE (TITLE(L:),122) ANGNAM
  122 FORMAT (' Scan in ',A6)
      WRITE (LUN(2),121) TITLE
      WRITE (LPT,121) TITLE
  121 FORMAT (1X,A80)
      TITLE(L:)=' '
      DO 21 ISTEP=1,NSTEP
   20 M=NCHECK(2,0)
      IF (M.LT.-1) GO TO 100
C  END OF DATA OR ANOTHER KEYWORD
      IF (M.EQ.-1) GO TO 20
    7 READ (MESBUF,102) ANGL,((FCOUNT(I,J),J=1,2),I=1,3)
  102 FORMAT (F8.2,2(F10.1,1X),2(F10.4,1X),F10.1,1X,F10.1)
      XANG(ISTEP)=ANGL
C  NOW GET THE RATES AND THE LOST COUNTS CORRECTION
    8 DO 10 J=1,2
      IF (FCOUNT(2,J).EQ.0) GO TO 12
      IF (FCOUNT(3,J).EQ.0) GO TO 12
      TRATE=FCOUNT(1,J)/FCOUNT(2,J)
      VTRATE = TRATE/FCOUNT(2,J)
      CALL LSTCTS(TRATE,VTRATE,TMORTS)
      IF (TRATE .LT. 0 .OR. TRATE .GT.2.) GO TO 14
      RATE(J)= (FCOUNT(1,J)/FCOUNT(3,J))*TRATE
   11 VRATE(J)=(RATE(J)/FCOUNT(3,J))*VTRATE
   10 CONTINUE
      R(ISTEP)=RATE(1)/RATE(2)
      DR(ISTEP)=R(ISTEP)*SQRT((VRATE(1)/RATE(1))**2
     &+(VRATE(2)/RATE(2))**2)
C      WRITE (LPT,110) ANGL,((RATE(I),VRATE(I)),I=1,2),R(ISTEP),DR(ISTEP)
C the previous line won't compile under SG UNIX system 5.2 !!
      WRITE (LPT,110) ANGL,RATE(1),VRATE(1),RATE(2),VRATE(2)
     &,R(ISTEP),DR(ISTEP)
  110 FORMAT (F8.2,2X,4F10.1,2F10.4)
      COUNT(ISTEP)=(RATE(1)+RATE(2))
      VCOUNT(ISTEP)=(VRATE(1)+VRATE(2))
      IF (COUNT(ISTEP).GT.CNTMAX) CNTMAX=COUNT(ISTEP)
      LAST=ISTEP
   21 CONTINUE
C SCALE ALL TO CPS FROM MONITOR
      RMON=(FCOUNT(3,1)+FCOUNT(3,2))/(FCOUNT(2,1)+FCOUNT(2,2))
      CNTMAX=CNTMAX*RMON
      CALL GMSCA(COUNT,COUNT,RMON,LAST,1)
      R2=RMON*RMON
      SCAL=1./RMON
      CALL GMSCA(VCOUNT,VCOUNT,R2,LAST,1)
C      DO 44 IDEV=1,2
C      CALL PGSLCT(IDEV,IOLD,IER)
C      CALL PGENV(XANG(1),XANG(LAST),0.,CNTMAX,0,2)
C      CALL PGLABEL(ANGNAM,'Count Rate (n/sec)',TITLE)
C      DO 43 I=1,LAST
C      CALL PGPOINT(1,XANG(I),COUNT(I),17)
C      SIG=SQRT(VCOUNT(I))
C      CALL PGERRY(1,XANG(I),COUNT(I),COUNT(I)+SIG,COUNT(I)-SIG,0.0)
C      IF (IDEV.EQ.1) WRITE (LUN(2),124) I,XANG(I),COUNT(I),SIG
C  124 FORMAT (I4,F8.2,2F12.4)
C   43 CONTINUE
C   44 CONTINUE
      NSEQ(2)=NSEQ(2)+1
      GO TO 100
C
C  NO DATA
   12 CALL TESTP(LPT,LCOUNT,1,HEADNG,2)
      WRITE (LPT,106) KH
  106 FORMAT (10X,3I5,'   Zero time for measurement')
      GO TO 100
C
C  LOST COUNTS TOO BIG
   14 CALL TESTP(LPT,LCOUNT,1,HEADNG,2)
      WRITE (LPT,109) KH
  109 FORMAT (10X,3I5,'  Detector saturated')
C
  100 RETURN
      END
C
C
C
C
      SUBROUTINE CENPRC(M)
C
C *** CENPRC by PJB 1990 ***
C
CH Procceses centreing commands
C
C
      LOGICAL INTIND
      CHARACTER*10 FILNOM
      DIMENSION K(3)
/D3OPC/
/D3OPN/
      COMMON /HEDING/ HEADNG
      CHARACTER*135 HEADNG
/IOUNIT/
      COMMON /NWORDS/NLWORD,NLWRD1,NKEY,NJWORD,NCOM,NPTAB(22)
/SCRACH/
      IF (LUN(3).LE.0) THEN
        CALL TESTP(LPT,LCOUNT,1,HEADNG,2)
        IF (LUN(3).EQ.0) THEN
          MESSAG='File of centered angles'
          NAMFIL='.CEN'
          LUN(3)=NOPFIL(112)
          OP3=FILNOM(LUN(3))
        ELSE
          MESSAG=OP3
          LUN(3)=NOPFIL(24)
        ENDIF
      ENDIF
C
      CALL TESTP(LPT,LCOUNT,1,HEADNG,2)
    1 M=NCHECK(3,NLWRD1+3)
      IF (M.LT.-1) THEN
        WRITE (LPT,14) H,'not Centred'
   14   FORMAT (7X,3F6.2,22X,A11)
        GO TO 100
      ENDIF
      IF (M.EQ.-1) GO TO 1
      READ (MESBUF,10)H,ANG
   10 FORMAT (21X,3F8.4,3F8.2)
      WRITE (LUN(3),11) H,ANG
   11 FORMAT (3F10.4,3F8.2)
      IF (INTIND(H,K)) THEN
        WRITE (LPT,12)K,ANG,'  Centred'
   12   FORMAT (7X,3(I5,1X),3F8.2,A9)
      ELSE
        WRITE (LPT,13)H,ANG,'  Centred'
   13   FORMAT (7X,3F6.2,3F8.2,A9)
      ENDIF
  100 RETURN
      END
C
C
C
C
      FUNCTION NCHECK(M,LL)
C
C *** NCHECK BY PJB OCT 88 ***
C
CH The fundamental data input routine for D3 data
C
      CHARACTER*5 WARN(1)
      COMMON /ALWORD/LWORD(27),KEY(6),JWORD(3)
      CHARACTER*5 LWORD,KEY,JWORD
      CHARACTER*10 NEWNAM,FILNOM,OLDNAM,FILE*6
/D3OPC/
/D3OPN/
      COMMON /HEDING/ HEADNG
      CHARACTER*135 HEADNG
/IOUNIT/
      COMMON /NWORDS/NLWORD,NLWRD1,NKEY,NJWORD,NCOM,NPTAB(22)
/SCRACH/
C
      DATA NWARN,WARN/1,'TIMEO'/
C
      L=LL
      NCHECK=0
C
C  SECTION TO GET A NEW FILE NAME
    1 IF (IEND) THEN
        LDIR=LENGT(DATDIR)
        MESSAG=DATDIR(1:LDIR)//IP1
    2   NAMFIL='.opf'
        LUNI=NOPFIL(131)
        IF (LUNI.LE.0) THEN
          NCHECK=-2
          CALL TESTP(LPT,LCOUNT,1,HEADNG,2)
          WRITE (LPT,13) IP1(1:6)
   13     FORMAT (' File ',A6,' not found in the data-base')
          IP2=' '
          GO TO 100
        ENDIF
        WRITE (LPT,16) IP1(1:6)
        WRITE (ITO,16) IP1(1:6)
   16   FORMAT (' Data now being read from ',A6)
        IEND=.FALSE.
C RESET SCAN SEQUENCE NUMBER
        NSEQ(2)=1
C  READ HEADER; DO NOTHING WITH IT FOR NOW
        READ (LUNI,1000) MESBUF
      ENDIF
C
C  READ NEXT RECORD
      READ (LUNI,1000,END=52) MESBUF
C turn any lower case chars to upper case
      CALL UPONE(MESBUF,1)
 1000 FORMAT (A125)
C
C  IGNORE BLANK LINES
      IF (LENGT(MESBUF).LE.1) GO TO 1
C
C  SEARCH FOR KEYWORD
      I=NCFIND(MESBUF(1:5),KEY,NKEY)
      IF (I .EQ. 0) GO TO (1,20,30,40,50),M
C IGNORE WARNING TYPE MESSAGES  WHEN LOOKING FOR KEYWORD
      IF (I.GE.4 .AND. (M.EQ.1.OR.M.EQ.3)) GO TO 1
C
    3 NCHECK=I
      IF (M.NE.1) THEN
C
C  CHECK FOR SERIOUS WARNINGS, SKIP IF NOT SERIOUS
        IF (I.EQ.5) THEN
          IF (NCFIND(MESBUF(10:14),WARN,NWARN).EQ.0) GO TO 1
        ENDIF
        NCHECK=-2-I
C  KEYWORD FOUND WHEN NOT LOOKING FOR ONE, SET ERROR
      ENDIF
      GO TO 100
C
C  DATA RUN OUT
   52 IEND=.TRUE.
      IF (IP2.NE.' ') THEN
        IF (IP1 .EQ. IP2) THEN
          NCHECK=-2
          IP2=' '
        ENDIF
      ENDIF
      LDIR=LENGT(DATDIR)
      MESSAG=DATDIR(1:LDIR)//IP1
      CALL INCREM(IP1,MESSAG)
      CALL CLOFIL(LUNI)
      IF (NCHECK .EQ.-2) GO TO 100
      CALL TESTP(LPT,LCOUNT,1,HEADNG,2)
      GO TO 2
C
C  MAKE SURE NO NON-NUMERICAL CHARACTERS
   20 DO 21 I=1,5
      IF (MESBUF(I:I).EQ.' ' .OR. MESBUF(I:I).EQ.'-') GO TO 21
      IF (NDIGIT(MESBUF(I:I)) .EQ. -1) GO TO 22
   21 CONTINUE
      GO TO 100
   22 CALL TESTP(LPT,LCOUNT,3,HEADNG,2)
      LCOUNT=LCOUNT+2
      WRITE (LPT,12) MESBUF(1:20)
   12 FORMAT ('0 Characters "',A20,'" Read when expecting a number'/)
      NCHECK=-1
      GO TO 100
C
C  CHECK THE FIRST 5 CHARACTERS IN A LINE
   30 IF (MESBUF(1:5).NE. LWORD(L))NCHECK=-1
      GO TO 100
C
C  ADVANCE BY LL LINES
   40 L=L-1
      IF (L.EQ.0) GO TO 100
      GO TO 1
C
C  ERROR IN SPECIFICATION OF RECORD
   90 CALL MESS(ITO,0,'Error in specification of record; '//MESSAG)
      CALL INFILE
      GO TO 1
C
   50 IF (NCFIND(MESBUF(4:9),JWORD,NJWORD).EQ.0) NCHECK=-1
  100 RETURN
      END
C
C
C
C
      SUBROUTINE INFILE
C
      CHARACTER*6 NEWNAM,ENDNAM,FNAM
      CHARACTER*3 CYCLE
      LOGICAL SAYS
/D3OPC/
/GLOBAL/
/SCRACH/
C
      CALL GETENV('D3DATA',DATDIR)
      L=LENGT(DATDIR)
      IF (L.NE.0) THEN
        CALL ASK('Data will be read from directory '//DATDIR(1:L)//
     &' OK? (Y/N)')
        IF (SAYS('Y')) GO TO 2
      ENDIF
      CALL GETENV('ILLDATA',DATDIR)
      L=LENGT(DATDIR)
      IF (L.EQ.0) THEN
        DATDIR='/usr/illdata'
        L=LENGT(DATDIR)
      ENDIF
        CALL ASK('Data base is '//DATDIR(1:L)//
     &' OK? (Y/N)')
        IF (SAYS('N')) CALL MESS(ITO,' Please set the environment'//
     &' variable ILLDATA to the correct path for the ill data base')
    1 CALL ASK('Give cycle number (RETURN gives current cycle')
      CALL RDINTG(ICYC,1,IPT,8,IER)
      IF (IER .EQ.100) THEN
        ICYC=0
        DATDIR=DATDIR(1:L)//'/data/d3/'
      ELSE
        IF (IER.NE.0) GO TO 1
        WRITE (CYCLE,10) ICYC
   10 FORMAT (I3)
        DATDIR=DATDIR(1:L)//'/'//CYCLE//'/d3/'
      ENDIF
    2 CALL ASK('Give name of first and (last) files to process')
      CALL RDWORD(IP1,LEN,1,IPT,11,0,IER)
      IF (IER.NE.0) GO TO 2
      CALL RDWORD(IP2,LEN,IPT,IPT,30,0,IER)
      IF (IER.EQ.100) THEN
        IP2=' '
      ELSE
        IF (IER.NE.0) GO TO 2
      ENDIF
      CALL UPONE(IP1,3)
      CALL UPONE(IP2,3)
      RETURN
      END
C
C
C
C
      BLOCK DATA PAGEHD
      COMMON /ALWORD/LWORD(27),KEY(6),JWORD(3)
      CHARACTER*5 LWORD,KEY,JWORD
/D3OPN/
      COMMON /NWORDS/NLWORD,NLWRD1,NKEY,NJWORD,NCOM,NPTAB(22)
      COMMON /HEDING/ HEADNG
      CHARACTER*135 HEADNG
      DATA HEADNG/' (''0Seq No       h    k    l   Omega  2Theta     Nu
     &      R        dR     Pk cps Bg cps    Temp    Field   DVM
     &Date      Time''/)'/
      DATA LWORD/'SAMPL','BLIND','GEOME','WAVEL','MONOC','FILTE',
     & 'UB MA','REFLE','ANGLE','B-P-B','DEAD ','POLAR','P-O-B',
     & ' HKL ','HKL M','STAND','DATE ','PHOTO','SET B','SOFTW',
     & 'CENTR','CENTR','READ ','SHAFT','  COU','***CE','TEMPE'/
      DATA JWORD/'OMEGA','GAMMA','   NU'/
      DATA KEY/'COMMO','DATA:','ORDER','COMMA','WARNI','DTI: '/
C  NLWORD IS NUMBER OF 5 LETTER STRINGS TO RECOGNISE AS DATA OF WHICH
C  NLWRD1 FOLLOW A data/order-WORD
C  NKEY NUMBER OF SPECIAL KEY WORDS
C  NJWORD NUMBER OF SHAFT ANGLE NAMES
C  NCOM NUMBER OF ITEMS TO BE READ FROM COMMON DATA (IST NCOM OF LWORD)
      DATA NLWORD,NLWRD1,NKEY,NJWORD,NCOM/27,23,6,3,12/
C TABLE NPTAB ASSOCIATES THE ORDERS WITH THE DATA WORDS
      DATA NPTAB/0,0,0,0,0,0,0,0,2,3,0,0,4,5,1,6,0,0,0,0,7,8/
C LUN(4) SET TO 0 TO INDICATE FILES NOT OPEN
      DATA LUN/0,0,0,0/
      END
C
C
C
C
C LEVEL 50      PROGRAM D3OP88
      PROGRAM D3OP88
C
C *** D3OP88 by PJB Oct 88 ***
C
C **********************************************************************
C
C                            D 3 O P 8 8
C
C              NEW D3 PROCESSING PROGRAM FOR MAD SYSTEM
C
C **********************************************************************
C
      DIMENSION IDUM(4),ADUM(9),ICOMDA(45),LUN(2)
      CHARACTER*120 ICOMCH,DEFT*60
      CHARACTER*4 MORD(6)
      CHARACTER*8 DUMNAM
      DIMENSION ICOM(6)
      LOGICAL START,BEGIN,SAYS,RDCOM,CHGPAR
      CHARACTER*100 FMT1
      COMMON /ALWORD/LWORD(22),KEY(4),JWORD(3)
      CHARACTER*5 LWORD,KEY,JWORD
/D3OPC/
/D3OPN/
/FINAME/
      COMMON /HEDING/ HEADNG
      CHARACTER*135 HEADNG
/IOUNIT/
      COMMON /NWORDS/NLWORD,NKEY,NJWORD,NCOM,NPTAB(20)
/SCRACH/
      CHARACTER *1 IREP
      EQUIVALENCE(IREP,MESSAG(1:1))
      EQUIVALENCE(ICOMDA,IGEO),(ICOMCH,ISNAME)
      DATA MORD/'*HKM','*AIS','*BPB','*POB','*HKL','*SRM'/
C
      START=.TRUE.
      BEGIN=.TRUE.
C  TO CHOOSE APPEND FOR WRITE FILES
      INIT=124
C
C  SET UP
      DEFT='.OPF'
      DEFT(5:)='SPCT:'
      DEFT(23:)='[ASDATA.D3.NEW]'
      LCOUNT=6
      CALL INITIL('D3OP88')
   56 CALL ASK('INITIALISE ? Answer Y(es), N(o) or H(elp)')
      IF (SAYS('H')) THEN
        CALL MESS(ITO,1,'Reply Yes if you are starting a new '//
     &  'experiment or if the common data have been')
        CALL MESS(ITO,0,' changed since the last run, i.e. the '//
     &  'sample, experimental conditions, UBM or')
        CALL MESS(ITO,0,' wavelength are different')
        GO TO 56
      ENDIF
C
      IF (.NOT. SAYS('N')) GO TO 59
      MESSAG='COMDAT.BIN'
      ICOMU=NOPFIL(1021)
      LCOUNT=LCOUNT+1
      READ (ICOMU) ICOMDA,ICOMCH
      START=.FALSE.
      CALL CLOFIL(ICOMU)
      CALL MESS(ITO,0,'Sample is: '//ISNAME//' User is: '//IUNAME//
     & '  OK ? Y(es) or N(o)')
      IF (.NOT. SAYS('Y')) GO TO 59
      CALL ASK('Data will be read from '//IP1//' OK ? Y(es) or N(o)')
      IF (.NOT. SAYS('Y')) THEN
        CALL ASK('Give name of file and reactor cycle number')
        IP1=MESSAG
      ENDIF
C
      CALL OPMED
      WRITE(ITO,226)OP2,NSEQ
  226 FORMAT (' Results will be appended to file ',A10/
     & ' starting at sequence number',I5)
      CALL ASK('OK ? Y(es) or N(o)')
      IF (SAYS('Y')) GO TO 64
      CALL ASK('Give new output file-name')
      OP2=MESSAG(1:10)
      INIT=122
      GO TO 61
C
C  COMMON DATA FILE NOT FOUND
   60 CALL MESS(ITO,0,'Common data file COMDAT.BIN was not found.')
      CALL ASK('Continue ? Y(es) or N(o)')
      IF (.NOT. SAYS('Y')) STOP
C
C  HERE TO INITIALISE
C  SET STATUS NEW FOR WRITE FILES
   59 INIT=122
   58 CALL ASK('Give name of file and reactor cycle number')
      IP1=MESSAG
      CALL OPMED
      CALL ASK('Give output file name')
      OP2=MESSAG(1:10)
   61 CALL ASK('Sequence number for first reflection?')
      CALL RDINTG(NSEQ,1,IPT,80,IER)
      IF (.NOT. START) GO TO 64
C     PUT IN THOSE D3 INSTRUCTIONS TO BE PROCESSED IN THIS RUN
   63 CALL ASK('Give the orders to be processed in this run, '//
     & 'A4,1X,..')
      READ (ICARD,214) NORD
  214 FORMAT (10(A4,1X))
C
C     NOW RECOGNISE ORDERS AND SET MARKERS
   64 DO 51 I = 1,6
   51 ICOM(I) = 0
      DO 52 I = 1,6
      IF (NORD(I) .EQ. ' ') GO TO 54
C     END OF LIST
      DO 53 J = 1,6
      IF (NORD(I) .NE. MORD(J)) GO TO 53
      ICOM(J) = 1
      GO TO 52
   53 CONTINUE
   52 CONTINUE
   54 NUMORD=I
      IMEAS=0
C  FORCE BPB MEASUREMENT SINCE ONLY THIS TYPE CAN BE PROCESSED AT PRESENT
      IF (.NOT. START) THEN
        WRITE(ITO,303) (NORD(II),II=1,I)
  303   FORMAT (' The orders which will be processed are : ',6(A5))
        CALL ASK('OK ? Y(es) or N(o)')
        IF (.NOT. SAYS('Y')) GO TO 63
      ENDIF
C
      NAMFIL='.FLI'
      MESSAG=OP2
      LUNO=NOPFIL(INIT)
      OP2=NAMFIL
      MESSAG='DCARDS.CRY'
      NAMFIL=' '
      NEWIN=NOPFIL(INIT)
C
C  PUT OUT HEADING
      IF (START) GO TO 3
   36 START=.FALSE.
      WRITE (LPT,130)
      WRITE (LPT,131)
      WRITE (LPT,132) ISNAME,IUNAME
      WRITE (LPT,135) MONOID,FILTER
      J2=40-5*NUMORD
      J1=J2/2
      J2=J2-J1
      WRITE (FMT1,134) J2,NUMORD,J1
      WRITE (LPT,FMT1) (NORD(II),II=1,NUMORD)
      WRITE (LPT,131)
      WRITE (LPT,133)
C      WRITE (LPT,136) TMORTS(1),TMORTS(3),TMORTS(2),TMORTS(4)
  130 FORMAT ('0',25X,13('*****')/26X,'*',22X,'D3 DATA PROCESSING'
     & ,23X,'*')
  131 FORMAT (26X,'*',63X,'*')
  132 FORMAT (26X,'*',11X,'Sample Name:',A8,'  User Name:',A8,12X,'*')
  133 FORMAT (26X,13('*****')/)
  134 FORMAT ('(26X,''*'',',I2,'X,''Orders being Processed:'',',I2,
     & '(1X,A4)',I2,'X,''*'')')
  135 FORMAT (26X,'*',11X,'Monochromator: ',A8,'   Filter: ',
     & A8,10X,'*')
  136 FORMAT ('0       Dead time parameters: a = ',
     & E11.3,'+/-',E11.3,' b = ',E11.3,'+/-',E11.3//)
      WRITE (LPT,HEADNG)
      LCOUNT=LCOUNT+19
C
C  *****START TO READ DATA*****
    3 JK=NCHECK(1,0)
      IF (JK.LE.0) GO TO 90
      IF (JK.NE.1) THEN
        IF (.NOT. START) GO TO 20
C  MUST READ COMMON DATA TO START PROCESSING
        IF (.NOT.BEGIN)GO TO 3
        LCOUNT=LCOUNT+1
        CALL MESS(LPT,0,' ***Warning: File does not start with a '//
     &  'common data block')
        BEGIN=.FALSE.
        GO TO 3
      ENDIF
C
C  READ SELECTED PARTS OF COMMON DATA
    1 RDCOM=.TRUE.
      ICD=0
   30 ICD=ICD+1
      IF (ICD.GT.NCOM) THEN
        RDCOM=.FALSE.
        IF (START) GO TO 36
        GO TO 3
      ENDIF
      IS=1
    4 GO TO (14,4,90,91,92,93), 1-NCHECK(3,ICD)
   14 GO TO (2,17,6,7,18,19,8,13,15,16,25,21),ICD
C
C  COME HERE AFTER DATA OR ORDER TO UPDATE DATA
   20 I=NCFIND(MESBUF(7:11),LWORD,NLWORD-2)
      IF (I.EQ.0) GO TO 3
C  WORD NOT RECOGNISED
      II=NPTAB(I)
      IS = 7
      IF(I.EQ.9) IS=1
      IF(I.EQ.10) IS=2
      GO TO (2,3,6,7,18,19,8,3,15,16,25,21,42,43,13,44,71,23,24,17),I
C
C  SECTION GIVING PROCEDURES AFTER DATA KEYWORDS
C  SAMPLE NAME
    2 IF (RDCOM) THEN
        READ (MESBUF,100)DUMNAM,IUNAME
      ELSE
        READ (MESBUF(IS:),100)DUMNAM
      ENDIF
      IF (DUMNAM.EQ.ISNAME) GO TO 5
C  HERE FOR NEW SAMPLE
      ISNAME=DUMNAM
      IF (START) GO TO 5
      CALL TESTP(LPT,LCOUNT,1,HEADNG,2)
      LCOUNT=LCOUNT+1
      CALL MESS(LPT,1,MESBUF)
      GO TO 5
C
C  GEOMETRY
    6 IF (RDCOM) THEN
        READ(MESBUF,101) IGEO
      ELSE
        READ(MESBUF,111) IGEO
      ENDIF
      GO TO 5
C
C  WAVELENGTH
    7 READ(MESBUF(IS:),102) ADUM(1)
      IF (.NOT. CHGPAR(ADUM,ALAM,1)) GO TO 5
      IF (START) GO TO 10
      CALL TESTP(LPT,LCOUNT,1,HEADNG,2)
      LCOUNT=LCOUNT+1
      WRITE (LPT,122) ALAM,ADUM(1)
  122 FORMAT ('  ***Warning: Change of wavelength Old=',F10.4,' New ='
     &,F10.4)
      WRITE (NEWIN,124) ALAM,UBM
  124 FORMAT ('D WVLN',F10.4/'D GEOM 8'/'D L/R 1'3,(/'D UMAT',3F10.5))
   10 ALAM=ADUM(1)
      GO TO 5
C
C  UB MATRIX
    8 N=0
    9 READ (MESBUF(IS:),103) (ADUM(3*N+I),I=1,3)
      N=N+1
      IF (N.EQ.3) GO TO 11
      GO TO (9,4,90,91,92,93),1-NCHECK(2,0)
   11 IF (.NOT. CHGPAR(ADUM,UBM,9)) GO TO 5
      IF (.NOT. START) THEN
        CALL TESTP(LPT,LCOUNT,1,HEADNG,2)
        LCOUNT=LCOUNT+1
        CALL MESS(' ***Warning: Change of UB-Matrix')
      ENDIF
C
      CALL GMEQ(ADUM,UBM,1,9)
      WRITE (NEWIN,124) ALAM,UBM
      GO TO 5
C
C  INDICES AND MEASUREMENT TYPE
   13 IF (RDCOM) THEN
        READ(MESBUF,104)H,IMTYP
        GO TO 30
      ENDIF
C
      READ(MESBUF,114)H,IMTYP
      IF (JK.NE.3 .OR. ICOM(II).NE.1 .OR. IMTYP.NE.IMEAS) GO TO 3
C  SWITCH TO PROCESS A MEASUREMENT
      M=1
      GO TO (40,41,42) ,IMTYP+1
C
C  ANGLE SCAN DATA
   15 READ(MESBUF(IS:),105) (AIS(I),I=1,3),IAIS
      IF (RDCOM) GO TO 30
      IF (JK.NE.3 .OR. ICOM(II).NE.1) GO TO 3
      M=1
   41 CALL AISPRC(M,LUNS)
      IF (M.GE.0 .OR. M.EQ.-1) GO TO 3
C  NO ERRORS
      JK=-(2+M)
      IF (JK .LE.0) GO TO 90
      GO TO 3
C
C  B-P-B DATA OR ORDER
   16 READ (MESBUF(IS:),106) NBPB
      IF (RDCOM) GO TO 30
      IF (JK.NE.3 .OR. ICOM(II).NE.1) GO TO 3
      M=3
   40 CALL BPBPRC(M)
      IF (M.GE.0 .OR. M.EQ.-1) GO TO 3
C  NO ERRORS
      JK=-(2+M)
      IF (JK .LE.0) GO TO 90
C
C  END OF DATA
   94 GO TO (1,20,20),JK
C  ERROR RETURN HAVING READ ANOTHER ORDER
      GO TO 3
C
C  BLIND SPOTS
   17 IF (RDCOM) THEN
        READ (MESBUF,112) BLSPS
      ELSE
        READ(MESBUF,113) BLSPS
      ENDIF
      GO TO 5
C
C MONOCHROMATOR
   18 READ (MESBUF(IS:),115) DUMNAM,IPOL
      IF (DUMNAM .EQ. MONOID) GO TO 5
      IF (.NOT. START) THEN
        CALL TESTP(LPT,LCOUNT,1,HEADNG,2)
        LCOUNT=LCOUNT+1
        CALL MESS(LPT,0,' ***Warning: Change of monochromator '//
     &  'Old : '//MONOID//' New : '//DUMNAM)
      ENDIF
      MONOID=DUMNAM
      GO TO 5
C
C FILTER
   19 READ (MESBUF(IS:),116) DUMNAM
      GO TO 22
   23 READ (MESBUF,107) DUMNAM
      GO TO 22
   24 READ (MESBUF,108) DUMNAM
   22 IF (DUMNAM.EQ.FILTER) GO TO 5
      IF (.NOT. START) THEN
        CALL TESTP(LPT,LCOUNT,1,HEADNG,2)
        LCOUNT=LCOUNT+1
        CALL MESS(LPT,0,' ***Warning: Change of Filter '//
     &  'Old : '//FILTER//' New : '//DUMNAM)
      ENDIF
      FILTER=DUMNAM
      GO TO 5
C
C DEAD-TIME
   25 READ (MESBUF(IS:),109) (ADUM(I),I=1,4)
      IF (.NOT.CHGPAR(ADUM,TMORTS,4)) GO TO 5
      IF (.NOT. START) THEN
        CALL TESTP(LPT,LCOUNT,2,HEADNG,2)
        LCOUNT=LCOUNT+2
        WRITE (LPT,150) ADUM(1),ADUM(3),ADUM(2),ADUM(4),
     &  TMORTS(1),TMORTS(3),TMORTS(2),TMORTS(4)
  150   FORMAT ('  ***Warning: Change of dead-time Old: a = ',
     &  E11.3,'+/-',E11.3,' b = ',E11.3,'+/-',E11.3/34X,'New: a = ',
     &  E11.3,'+/-',E11.3,' b = ',E11.3,'+/-',E11.3)
      ENDIF
      CALL GMEQ(ADUM,TMORTS,1,4)
      GO TO 5
C
C POLARISATION
C POL ORDER SWITCHES UP OR DOWN, DATA OR COMMON CHANGES VALUES
   21 IF (JK.EQ.3) GO TO 5
      READ(MESBUF(IS:),110) (ADUM(I),I=1,4)
      IF (.NOT.CHGPAR(ADUM,POLARS,4)) GO TO 5
      IF (.NOT.START) THEN
        CALL TESTP(LPT,LCOUNT,2,HEADNG,2)
        LCOUNT=LCOUNT+2
        WRITE (LPT,129) POLARS,(ADUM(I),I=1,4)
  129   FORMAT ('  ***Warning: Change of polarisation Old: P =',F8.4,
     &  '+/-',F8.4,'e = ',F8.4,'+/-',F8.4/36X,'New P =',F8.4,
     &  '+/-',F8.4,'e = ',F8.4,'+/-',F8.4)
      ENDIF
      CALL GMEQ(ADUM,POLARS,4,1)
      WRITE (NEWIN,140) POLARS
  140 FORMAT ('P ',4F10.4)
      GO TO 5
C
C AFTER READING DATA
    5 IF (RDCOM) GO TO 30
      GO TO 3
C
C  READ ANGLES IF SET
   70 IF (JK.EQ.3) READ(MESBUF,119) ANG
      GO TO 3
C
C  READ DATE,TIME AND DVM
   71 IF (JK.NE.3) GO TO 3
      DATE=MESBUF(1:19)
      DVM=MESBUF(54:65)
      GO TO 3
C   28 II=I-3
C      GO TO (25,26,27,42,43,44),II
C
C  POB SCAN
   42 IF (JK.NE.3 .OR. ICOM(II).NE.1) GO TO 3
      CALL POBPRC(M)
      IF (M.LT.0) GO TO 90
      GO TO 3
C
C  HKL SET
   43 READ (MESBUF,118) H
      GO TO 3
C
C  STANDARD REFLECTION
   44 READ (MESBUF,117) H
      IF (JK.NE.3 .OR. ICOM(II).NE.1) GO TO 3
C  SET FOR STANDARD
      M=2
      GO TO (40,41,42),IMTYP+1
C
C  END OF DATA
   91 JK=1
      GO TO 94
   92 JK=2
      GO TO 94
   93 JK=3
      GO TO 94
   90 JK=-(2+JK)
      IF (JK.GT.0) GO TO 94
      WRITE(ITO,125)NSEQ
  125 FORMAT (' Next free sequence number is',I5)
C
C  CLOSE DATA BASE
      ISTAT=MED_CLOSE()
C
C  WRITE THE updated COMMON DATA FILE
      MESSAG='COMDAT.BIN'
      ICOMU=NOPFIL(1023)
      WRITE (ICOMU) ICOMDA,ICOMCH
      CALL CLOFIL(ICOMU)
      STOP
C  FORMATS FOR READING THE DATA AND COMMON DATA
  100 FORMAT (13X,A8,12X,A8)  !SAMPLE  AND USER NAME
  101 FORMAT (17X,3I5)   !GEOMETRY
  102 FORMAT (11X,F10.4)  !WAVELENGTH
  103 FORMAT (11X,3F10.6)  !UB MATRIX
  104 FORMAT (19X,3F10.4,18X,I5) !HKL AND MTYPE
  105 FORMAT (16X,3F8.4,I8)  !ANGLE SCAN DATA
  106 FORMAT (34X,I8)   !BPB REPEAT NO
  107 FORMAT (31X,A8)   !PHOTO - FILTER
  108 FORMAT (27X,A8)                   !SET BEAM - FILTER
  109 FORMAT (17X,2(F11.8,F16.13))      !DEAD TIME
  110 FORMAT (14X,4F8.4)                !POLARISATION
  111 FORMAT (23X,3I8)          !GEOMETRY
  112 FORMAT (12X,8F8.2)                !BLIND SPOTS
  113 FORMAT (16X,8F8.2)                !SOFTWARE LIMITS
  114 FORMAT (21X,3F10.4,I5)     !HKM
  115 FORMAT (18X,A8,11X,I2)            !MONOCHROMATOR
  116 FORMAT (8X,A8)                    !FILTER
  117 FORMAT (30X,3F10.5)  !STANDARD
  118 FORMAT (11X,3F10.4)         !HKL
  119 FORMAT (41X,3F8.4)                !ANGLES
      END
C
C
C
C
      SUBROUTINE BPBPRC(M)
C
C *** BPBPRC by PJB Oct 88 ***
C
CH Processes BPB measurements
C
      CHARACTER*8 DUMNAM
      DIMENSION FJCOUN(3,2),FCOUNT(3,2,2),RATE(2,2),VRATE(2,2),PEAK(2)
     & ,VPEAK(2),KH(3)
/D3OPC/
/D3OPN/
/IOUNIT/
      COMMON /HEDING/ HEADNG
      CHARACTER*135 HEADNG
      COMMON /NWORDS/NLWORD,NKEY,NJWORD,NCOM,NPTAB(20)
      CHARACTER*2 ISTAN(3)
      DATA ISTAN/'  ','**',' #'/
C
C  SAVE INFORMATION ON TYPE
      MM=M
C
C  CLEAR THE COUNT BUFFER
      DO 17 I=1,3
      DO 16 J=1,2
      DO 16 K=1,2
   16 FCOUNT(I,J,K)=0.
   17 KH(I)=JFIX(H(I))
C
      IF (M.EQ.3) GO TO 20
C
    2 M = NCHECK(3,NLWORD-1)
      IF (M.LT.-1) GO TO 100
C  END OF DATA OR ANOTHER KEYWORD
      IF (M.EQ.-1) GO TO 2
C  TO READ ANOTHER LINE
    1 READ(MESBUF,1000) (ANG(I),I=1,3)
 1000 FORMAT (35X,3F8.4)
C
   19 M=NCHECK(5,0)
      IF (M.LT.-1) GO TO 100
C  END OF DATA OR ANOTHER KEYWORD
      IF (M.EQ.0) GO TO 2
C  TO READ ANOTHER LINE
   18 READ (MESBUF,101) DATE
  101 FORMAT (4X,A19)
      M=NCHECK(5,0)
      READ (MESBUF,108) TEMPER,FIELD,DVM
  108 FORMAT (39X,A8,6X,A8,6X,A8)
C
   20 M=NCHECK(3,NLWORD)
      IF (M.LT.-1) RETURN
C  END OF DATA OR ANOTHER KEYWORD
      IF (M.EQ.-1) GO TO 20
C
C  TRY AGAIN
    4 DO 5 II=1,NBPB
      DO 6 KK=1,3
      K=MOD(KK,2)+1
      M=NCHECK(2,0)
      IF (M.LT.0) GO TO 8
C
C  ERROR
    7 READ (MESBUF,102) ((FJCOUN(I,J),J=1,2),I=1,3)
  102 FORMAT (2(F10.1,1X),2(F10.4,1X),F10.1,1X,F10.1)
      DO 9 I=1,3
      DO 9 J=1,2
    9 FCOUNT(I,J,K)=FCOUNT(I,J,K)+FJCOUN(I,J)
    6 CONTINUE
C      M=NCHECK(4,1)
      IF (M.LT.0) GO TO 8
    5 CONTINUE
C
C  NOW GET THE RATES AND THE LOST COUNTS CORRECTION
    8 DO 10 J=1,2
      IF (II .LT.2) GO TO 100
C
      DO 11 K=1,2
      IF (FCOUNT(2,J,K).EQ.0) GO TO 12
      IF (FCOUNT(3,J,K).EQ.0) GO TO 12
      TRATE=FCOUNT(1,J,K)/FCOUNT(2,J,K)
      VTRATE = TRATE/FCOUNT(2,J,K)
      CALL LSTCTS(TRATE,VTRATE,TMORTS)
      IF (TRATE .LT. 0 .OR. TRATE .GT.2.) GO TO 14
      RATE(J,K)= (FCOUNT(1,J,K)/FCOUNT(3,J,K))*TRATE
   11 VRATE(J,K)=(RATE(J,K)/FCOUNT(3,J,K))*VTRATE
C
      PEAK(J)=RATE(J,1)-RATE(J,2)
      VPEAK(J)=VRATE(J,1)+VRATE(J,2)
      IF (PEAK(J).LE. SQRT(VPEAK(J))) GO TO 13
   10 CONTINUE
      R = PEAK(1)/PEAK(2)
      DR= R*SQRT((VPEAK(1)/(PEAK(1)**2)) + (VPEAK(2)/(PEAK(2)**2)))
      HTPK=(PEAK(1)+PEAK(2))*(FCOUNT(3,1,1)+FCOUNT(3,2,1))
     & /(2.*(FCOUNT(2,1,1)+FCOUNT(2,2,1)))
      BKG=(RATE(1,2)+RATE(2,2))*(FCOUNT(3,1,2)+FCOUNT(3,2,2))
     & /(2.*(FCOUNT(2,1,2)+FCOUNT(2,2,2)))
C
      CALL TESTP(LPT,LCOUNT,1,HEADNG,2)
      WRITE (LPT,104) NSEQ,ISTAN(MM),KH,ANG,R,DR,HTPK,BKG,TEMPER,
     & FIELD,DVM,DATE
  104 FORMAT (1X,I5,A2,2X,3I5,3F8.2,2F10.6,F8.1,1X,F6.1,1X,
     & 3(A8,1X),A19)
      WRITE (LUNO,105) NSEQ,KH,ANG,R,DR,DVM,DATE
  105 FORMAT (4I5,3F8.2,2F10.6,2X,A8,3X,A19)
      NSEQ = NSEQ+1
      GO TO 100
C
C  ERRORS
C  DATA RUN OUT
    3 M=-1
      GO TO 100
C
C  NO DATA
   12 CALL TESTP(LPT,LCOUNT,1,HEADNG,2)
      WRITE (LPT,106) KH
  106 FORMAT (10X,3I5,'   Zero time for measurement')
      GO TO 100
C
C  R NOT SIGNIFICANT
   13 CALL TESTP(LPT,LCOUNT,1,HEADNG,2)
      WRITE (LPT,107) KH
  107 FORMAT (10X,3I5,'   R less than its error')
      GO TO 100
C
C  LOST COUNTS TOO BIG
   14 CALL TESTP(LPT,LCOUNT,1,HEADNG,2)
      WRITE (LPT,109) KH
  109 FORMAT (10X,3I5,'  Detector saturated')
 100  RETURN
      END
C
C
C
C
      SUBROUTINE POBPRC(M)
C
C *** POBPRC by PJB Oct 88 ***
C
/IOUNIT/
C
      CALL MESS(LPT,0,'P-O-B SCAN PROCESSING NOT IMPLEMENTED')
      RETURN
      END
C
C
C
C
      SUBROUTINE AISPRC(M,LUNS)
C
C *** AISPRC by PJB Oct 88 ***
C
      CHARACTER*8 ANGNAM,DUMNAM
      DIMENSION FCOUNT(3,2),RATE(2),VRATE(2),PEAK(2)
     & ,VPEAK(2),KH(3)
/D3OPC/
/D3OPN/
/IOUNIT/
      COMMON /HEDING/ HEADNG
      CHARACTER*135 HEADNG
      COMMON /NWORDS/NLWORD,NKEY,NJWORD,NCOM,NPTAB(20)
C
C
   19 M=NCHECK(5,0)
      IF (M.LT.-1)GO TO 100
      IF (M.NE.0) GO TO 19
C  END OF DATA OR ANOTHER KEYWORD
   18 READ (MESBUF,101) ANGNAM
  101 FORMAT (A8)
C
      IF (IAIS.LT.0) THEN
        NSTEP=1-IAIS
      ELSE
        NSTEP=2*IAIS+1
      ENDIF
      DO 21 ISTEP=1,NSTEP
   20 M=NCHECK(2,0)
      IF (M.LT.-1) GO TO 100
C  END OF DATA OR ANOTHER KEYWORD
      IF (M.EQ.-1) GO TO 20
    7 READ (MESBUF,102) ANGL,((FCOUNT(I,J),J=1,2),I=1,3)
  102 FORMAT (F8.2,2(F10.1,1X),2(F10.4,1X),F10.1,1X,F10.1)
C  NOW GET THE RATES AND THE LOST COUNTS CORRECTION
    8 DO 10 J=1,2
      IF (FCOUNT(2,J).EQ.0) GO TO 12
      IF (FCOUNT(3,J).EQ.0) GO TO 12
      TRATE=FCOUNT(1,J)/FCOUNT(2,J)
      VTRATE = TRATE/FCOUNT(2,J)
      CALL LSTCTS(TRATE,VTRATE,TMORTS)
      IF (TRATE .LT. 0 .OR. TRATE .GT.2.) GO TO 14
      RATE(J)= (FCOUNT(1,J)/FCOUNT(3,J))*TRATE
   11 VRATE(J)=(RATE(J)/FCOUNT(3,J))*VTRATE
   10 CONTINUE
      R=RATE(1)/RATE(2)
      DR=R*SQRT((VRATE(1)/RATE(1))**2+(VRATE(2)/RATE(2))**2)
      WRITE (LPT,110) ANGL,((RATE(I),VRATE(I)),I=1,2),R,DR
  110 FORMAT (F8.2,2X,4F10.1,2F10.4)
   21 CONTINUE
      GO TO 100
C
C  NO DATA
   12 CALL TESTP(LPT,LCOUNT,1,HEADNG,2)
      WRITE (LPT,106) KH
  106 FORMAT (10X,3I5,'   Zero time for measurement')
      GO TO 100
C
C  LOST COUNTS TOO BIG
   14 CALL TESTP(LPT,LCOUNT,1,HEADNG,2)
      WRITE (LPT,109) KH
  109 FORMAT (10X,3I5,'  Detector saturated')
C
  100 RETURN
      END
C
C
C
C
      FUNCTION NCHECK(M,LL)
C
C *** NCHECK by PJB Oct 88 ***
C
      CHARACTER*5 WARN(1), DUMNAM*8
      CHARACTER*10 NEWNAM,FILNOM,FILE*6
      COMMON /ALWORD/LWORD(22),KEY(4),JWORD(3)
      CHARACTER*5 LWORD,KEY,JWORD
/D3OPC/
/D3OPN/
/FINAME/
      COMMON /HEDING/ HEADNG
      CHARACTER*135 HEADNG
/IOUNIT/
/LOONEY/
      COMMON /NWORDS/NLWORD,NKEY,NJWORD,NCOM,NPTAB(20)
/SCRACH/
C
      DATA NWARN,WARN/1,'TIMEO'/
C
      L=LL
      NCHECK=0
C
C  SECTION TO GET A NEW FILE FROM THE DATA BASE
    1 IF (IREC.LE.0) THEN
        MESSAG=IP1
        CALL RDWORD(NEWNAM,LEN,1,IPT,11,0,IER)
        IF (IER.NE.0) GO TO 90
%        DO 501 I=1,%FILE%
        IF (LUNTAB(I).EQ.LUNI) GO TO 502
  501   CONTINUE
  502   FILNAM(I)=NEWNAM
        CALL RDINTG(ICYC,IPT,IPT1,80,IER)
        IF (IER.EQ.100) THEN
          ICYC=0
        ELSE
          IF (IER.NE.0) GO TO 90
        ENDIF
        FILE=NEWNAM(1:6)
        ISTAT=MED_FIND(FILE,ICYC,IREC,IEND)
        IF (ISTAT.EQ.0) THEN
          NCHECK=-2
          WRITE (LPT,13) FILE,ICYC
          WRITE (ITO,13) FILE,ICYC
   13     FORMAT (' File ',A6,' from reactor cycle ',I4
     &    ,' not found in the data-base')
          GO TO 100
        ENDIF
        WRITE (LPT,16) FILE
        WRITE (ITO,16) FILE
   16 FORMAT (' Data now being read from ',A6)
        IEND=IEND+IREC-1
C  READ HEADER; DO NOTHING WITH IT FOR NOW
        READ (LUNI,REC=IREC) MESBUF
        IREC=IREC+1
      ENDIF
C
C  READ NEXT RECORD
      READ (LUNI,REC=IREC) MESBUF
      IREC=IREC+1
      IF (IREC.GT.IEND) GO TO 52
C
C  IGNORE BLANK LINES
      IF (LENG(MESBUF,79).LE.1) GO TO 1
C
C  SEARCH FOR KEYWORD
      I=NCFIND(MESBUF(1:5),KEY,NKEY)
      IF (I .EQ. 0) GO TO (1,20,30,40,50),M
C IGNORE WARNING TYPE MESSAGES  WHEN LOOKING FOR KEYWORD
      IF (I.GE.4 .AND. M.EQ.1) GO TO 1
C
    3 NCHECK=I
      IF (M.NE.1) THEN
C
C DTI: MESSAGES
        IF (I.EQ.6) THEN
C SKIP THREE LINES
          IREC=IREC+3
          IF (IREC.GT.IEND) GO TO 52
        ELSE
C
C  CHECK FOR SERIOUS WARNINGS, SKIP IF NOT SERIOUS
          IF (I.EQ.5) THEN
            IF (NCFIND(MESBUF(10:14),WARN,NWARN).EQ.0) GO TO 1
          ENDIF
        ENDIF
        NCHECK=-2-I
C  KEYWORD FOUND WHEN NOT LOOKING FOR ONE, SET ERROR
      ENDIF
      GO TO 100
C
C  DATA RUN OUT
   52 CALL INCREM(FILNOM(LUNI),NEWNAM)
      IP1(1:6)=NEWNAM
      CALL TESTP(LPT,LCOUNT,1,HEADNG,2)
      IREC=-1
      GO TO 1
C
C  MAKE SURE NO NON-NUMERICAL CHARACTERS
   20 DO 21 I=1,5
      IF (MESBUF(I:I).EQ.' ' .OR. MESBUF(I:I).EQ.'-') GO TO 21
      IF (NDIGIT(MESBUF(I:I)) .EQ. -1) GO TO 22
   21 CONTINUE
      GO TO 100
   22 CALL TESTP(LPT,LCOUNT,3,HEADNG,2)
      LCOUNT=LCOUNT+2
      WRITE (LPT,12) MESBUF(1:20)
   12 FORMAT ('0 Characters "',A20,'" Read when expecting a number'/)
      NCHECK=-1
      GO TO 100
C
C  CHECK THE FIRST 5 CHARACTERS IN A LINE
   30 IF (MESBUF(1:5).NE. LWORD(L))NCHECK=-1
      GO TO 100
C
C  ADVANCE BY LL LINES
   40 L=L-1
      IF (L.EQ.0) GO TO 100
      GO TO 1
C
C  ERROR IN SPECIFICATION OF RECORD
   90 CALL MESS(ITO,0,'Error in specification of record; '//MESSAG)
      CALL ASK('Give filename (A6) and cycle number (I5)')
      IP1=MESSAG
      GO TO 1
C
   50 IF (.NOT. NCFIND(MESBUF(1:5),JWORD,3)) NCHECK=-1
  100 RETURN
      END
C
C
C
C
      SUBROUTINE OPMED
C
C *** OPMED by PJB Oct 88 ***
C
CH To open the data-base for D3OP88
C
      DIMENSION IDUM(2)
/IOUNIT/
/LOONEY/
C
      DO 1 J=1,2
%      DO 2 I=1,%FILE%
      IF (IOTAB(I).EQ.0)THEN
        IDUM(J)=LUNTAB(I)
        IOTAB(I)=IDUM(J)
        IREC=0
        GO TO 1
      ENDIF
    2 CONTINUE
    1 CONTINUE
      LUNI=IDUM(1)
      IF(.NOT.MED_OPEN('D3  ',IDUM(2),LUNI))STOP
     & ' Error opening the data base'
      RETURN
      END
C
C
C
C
      BLOCK DATA PAGEHD
      COMMON /ALWORD/LWORD(22),KEY(6),JWORD(3)
      CHARACTER*5 LWORD,KEY,JWORD
      COMMON /NWORDS/NLWORD,NKEY,NJWORD,NCOM,NPTAB(20)
      COMMON /HEDING/ HEADNG
      CHARACTER*135 HEADNG
      DATA HEADNG/' (''0Seq No       h    k    l   Omega  2Theta     N
     &u       R        dR    Pk cps  Bg cps  Temp    Field     DVM
     &        Date    Time''/)'/
      DATA LWORD/'SAMPL','BLIND','GEOME','WAVEL','MONOC','FILTE',
     &'UB MA','REFLE','ANGLE','B-P-B','DEAD ','POLAR','P-O-B',
     &' HKL ','HKL M','STAND','READ ','PHOTO','SET B','SOFTW',
     &'SHAFT','  COU'/
      DATA JWORD/'   OM','   GA','   NU'/
      DATA KEY/'COMMO','DATA:','ORDER','COMMA','WARNI','DTI: '/
C  NLWORD IS NUMBER OF 5 LETTER STRINGS TO RECOGNISE AS DATA
C  NKEY NUMBER OF SPECIAL KEY WORDS
C  NJWORD NUMBER OF SHAFT ANGLE NAMES
C  NCOM NUMBER OF ITEMS TO BE READ FROM COMMON DATA (IST NCOM OF LWORD)
      DATA NLWORD,NKEY,NJWORD,NCOM/22,6,3,12/
      DATA NPTAB/0,0,0,0,0,0,0,0,2,3,0,0,4,5,1,6,0,0,0,0/
      END
C
C
C
C
      LOGICAL FUNCTION CHGPAR(A,B,N)
C
C *** CHGPAR by PJB Oct 88 ***
C
CH Indicates whether two real arrays are the same
CA On entry A and B are real arrays of length N
CA On exit CHGPAR is TRUE if they are different (i.e. CHanGed PARameters)
CA                   FALSE if same
C
      DIMENSION A(N),B(N)
      DO 1  I=1,N
      IF (ABS(A(I)-B(I)) .LT. 10.E-12) GO TO 1
      CHGPAR=.TRUE.
      GO TO 100
    1 CONTINUE
      CHGPAR=.FALSE.
  100 RETURN
      END
C
C
C
C
C LEVEL 50      PROGRAM D3OP90
      PROGRAM D3OP90
C
C *** D3OP90 by PJB from D3OP88 Jun 90 ***
C
CN Implements Continue option and new order *CEN processed
CN Non-Integer indices now printed
C
C **********************************************************************
C
C                            D 3 O P 9 0
C
C  NEW D3 PROCESSING PROGRAM FOR MAD SYSTEM 1990 VERSION
C
C **********************************************************************
C
      DIMENSION IDUM(4),ADUM(9),ICOMDA(46),LUN(2)
      CHARACTER*60 DEFT
      CHARACTER*120 ICOMCH,DUMNAM*8
      CHARACTER*4 MORD(8)
      DIMENSION ICOM(8)
      LOGICAL START,BEGIN,SAYS,RDCOM,CHGPAR,CONT
      CHARACTER*100 FMT1
      COMMON /ALWORD/LWORD(25),KEY(6),JWORD(3)
      CHARACTER*5 LWORD,KEY,JWORD
/D3OPC/
/D3OPN/
/FINAME/
      COMMON /HEDING/ HEADNG
      CHARACTER*135 HEADNG
/IOUNIT/
      COMMON /NWORDS/NLWORD,NLWRD1,NKEY,NJWORD,NCOM,NPTAB(20)
/SCRACH/
      EQUIVALENCE(ICOMDA,IGEO),(ICOMCH,ISNAME)
      DATA MORD/'*HKM','*AIS','*BPB','*POB','*HKL','*SRM','*CEN','*CEA'/
      DATA NMORD/8/
C
      START=.TRUE.
      BEGIN=.TRUE.
C  TO CHOOSE APPEND FOR WRITE FILES
      INIT=124
C
C  SET UP
      DEFT='.OPF'
      DEFT(5:)='SPCT:'
      DEFT(23:)='[ASDATA.D3.NEW]'
      CALL INITIL('D3OP90')
   56 CALL ASK('INITIALISE ? Answer Y(es), N(o) or H(elp)')
      IF (SAYS('H')) THEN
        CALL MESS(ITO,0,'Reply Yes if you are starting a new '//
     &  'experiment or if the common data have been')
        CALL MESS(ITO,0,'changed since the last run, i.e. the '//
     &  'sample, experimental conditions, UBM or')
        CALL MESS(ITO,0,'wavelength are different')
        CALL MESS(ITO,0,'Reply Continue to continue processing as '//
     &  'before in the standard file sequence')
        CALL MESS(ITO,0,'Reply No if you want the opportunity to '//
     &  'change a file-name or the orders to be processed')
        GO TO 56
      ENDIF
C
      IF (SAYS('Y')) GO TO 59
      MESSAG='COMDAT.BIN'
      ICOMU=NOPFIL(1021)
      READ (ICOMU) ICOMDA,ICOMCH
      START=.FALSE.
      LUNC=-LUNC
      CALL CLOFIL(ICOMU)
      CONT= SAYS('C')
      IF (CONT) GO TO 57
      CALL ASK('Sample is: '//ISNAME//' User is: '//ISNAME//
     & ' OK ? Y(es) or N(o)')
      IF (.NOT. SAYS('Y')) GO TO 59
      CALL MESS(ITO,0,'Data will be read from '//IP1)
      CALL ASK('OK ? Y(es) or N(o)')
      IF (.NOT. SAYS('Y')) THEN
        CALL ASK('Give name of file and reactor cycle number')
        IP1=MESSAG
      ENDIF
C
   57 CALL OPMED
      IF (CONT) GO TO 64
      WRITE(ITO,226)OP2,NSEQ
  226 FORMAT (' Results will be appended to file ',A10/' starting
     1 at sequence number',I5)
      CALL ASK('OK ? Y(es) or N(o)')
      IF (SAYS('Y')) GO TO 64
      CALL ASK('Give new output file-name')
      OP2=MESSAG(1:10)
      INIT=122
      GO TO 61
C
C  COMMON DATA FILE NOT FOUND
   60 CALL ASK('Common data file COMDAT.BIN was not found. Continue ?'//
     & 'Y(e)s or N(o)')
      IF (.NOT. SAYS('Y')) STOP
C
C  HERE TO INITIALISE
C  SET STATUS NEW FOR WRITE FILES
   59 INIT=122
   58 CALL ASK('Give name of file and reactor cycle number')
      IP1=MESSAG
      CALL ASK('Give output file name')
      OP2=MESSAG(1:10)
   61 CALL ASK('Sequence number for first reflection?')
      CALL RDINTG(NSEQ,1,IPT,80,IER)
      IF (.NOT. START) GO TO 64
C     PUT IN THOSE D3 INSTRUCTIONS TO BE PROCESSED IN THIS RUN
   63 CALL ASK('Give the orders to be processed in this run, A4,1X,..')
      READ (ICARD,214) NORD
  214 FORMAT (10(A4,1X))
C     NOW RECOGNISE ORDERS AND SET MARKERS
   64 DO 51 I = 1,NMORD
   51 ICOM(I) = 0
      DO 52 I = 1,NMORD
      IF (NORD(I) .EQ. ' ') GO TO 54
C     END OF LIST
      DO 53 J = 1,NMORD
      IF (NORD(I) .NE. MORD(J)) GO TO 53
      ICOM(J) = 1
      GO TO 52
   53 CONTINUE
   52 CONTINUE
   54 NUMORD=I
      IMEAS=0
C  FORCE BPB MEASUREMENT SINCE ONLY THIS TYPE CAN BE PROCESSED AT PRESENT
      IF (START .OR. CONT) GO TO 62
      WRITE(ITO,303) (NORD(II),II=1,I)
  303 FORMAT (' The orders which will be processed are : ',6(A5))
      CALL ASK('OK ? Y(es) or N(o)')
      IF (.NOT. SAYS('Y')) GO TO 63
   62 NAMFIL='.FLI'
      MESSAG=OP2
      LUNO=NOPFIL(INIT)
      OP2=NAMFIL
      MESSAG='DCARDS.CRY'
      NAMFIL=' '
      NEWIN=NOPFIL(INIT)
      CALL OPMED
C
C  PUT OUT HEADING
      IF (START) GO TO 3
   36 START=.FALSE.
      WRITE (LPT,130)
      WRITE (LPT,131)
      WRITE (LPT,132) ISNAME,IUNAME
      WRITE (LPT,135) MONOID,FILTER
      J2=40-5*NUMORD
      J1=J2/2
      J2=J2-J1
      WRITE (FMT1,134) J2,NUMORD,J1
      WRITE (LPT,FMT1) (NORD(II),II=1,NUMORD)
      WRITE (LPT,131)
      WRITE (LPT,133)
C      WRITE (LPT,136) TMORTS(1),TMORTS(3),TMORTS(2),TMORTS(4)
  130 FORMAT ('0',25X,13('*****')/26X,'*',22X,'D3 DATA PROCESSING'
     1,23X,'*')
  131 FORMAT (26X,'*',63X,'*')
  132 FORMAT (26X,'*',11X,'Sample Name:',A8,'  User Name:',A8,12X,'*')
  133 FORMAT (26X,13('*****')/)
  134 FORMAT ('(26X,''*'',',I2,'X,''Orders being Processed:'',',I2,
     1'(1X,A4)',I2,'X,''*'')')
  135 FORMAT (26X,'*',11X,'Monochromator: ',A8,'   Filter: ',
     1A8,10X,'*')
  136 FORMAT ('0       Dead time parameters: a = ',
     1E11.3,'+/-',E11.3,' b = ',E11.3,'+/-',E11.3//)
      WRITE (LPT,HEADNG)
      LCOUNT=28
C  *****START TO READ DATA*****
    3 JK=NCHECK(1,0)
      IF (JK.LE.0) GO TO 90
      IF (JK.EQ.1) GO TO 1
      IF (.NOT. START) GO TO 20
C  MUST READ COMMON DATA TO START PROCESSING
      IF (.NOT.BEGIN)GO TO 3
      LCOUNT=LCOUNT+1
      CALL MESS(LPT,0,' ***Warning: File does not start with a '//
     & 'common data block')
      BEGIN=.FALSE.
      GO TO 3
C
C  READ SELECTED PARTS OF COMMON DATA
    1 RDCOM=.TRUE.
      ICD=0
   30 ICD=ICD+1
      IF (ICD.GT.NCOM) THEN
        RDCOM=.FALSE.
        IF (START) GO TO 36
        GO TO 3
      ENDIF
      IS=1
    4 GO TO (14,4,90,91,92,93), 1-NCHECK(3,ICD)
   14 GO TO (2,17,6,7,18,19,8,13,15,16,25,21),ICD
C
C  COME HERE AFTER DATA OR ORDER TO UPDATE DATA
   20 I=NCFIND(MESBUF(7:11),LWORD,NLWRD1)
      IF (I.EQ.0) GO TO 3
C  WORD NOT RECOGNISED
      II=NPTAB(I)
      IS = 7
      IF(I.EQ.9) IS=1
      IF(I.EQ.10) IS=2
      GO TO (2,3,6,7,18,19,8,3,15,16,25,21,42,43,13,44,71,23,
     124,17,45,45),I
C
C  SECTION GIVING PROCEDURES AFTER DATA KEYWORDS
C  SAMPLE NAME
    2 IF (RDCOM) THEN
        READ (MESBUF,100)DUMNAM,IUNAME
      ELSE
        READ (MESBUF(IS:),100)DUMNAM
      ENDIF
      IF (DUMNAM.EQ.ISNAME) GO TO 5
C  HERE FOR NEW SAMPLE
      ISNAME=DUMNAM
      IF (START) GO TO 5
      CALL TESTP(LPT,LCOUNT,1,HEADNG,2)
      LCOUNT=LCOUNT+1
      CALL MESS(LPT,1,MESBUF)
      GO TO 5
C
C  GEOMETRY
    6 IF (RDCOM) THEN
        READ(MESBUF,101) IGEO
      ELSE
        READ(MESBUF,111) IGEO
      ENDIF
      GO TO 5
C
C  WAVELENGTH
    7 READ(MESBUF(IS:),102) ADUM(1)
      IF (.NOT. CHGPAR(ADUM,ALAM,1)) GO TO 5
      IF (START) GO TO 10
      CALL TESTP(LPT,LCOUNT,1,HEADNG,2)
      LCOUNT=LCOUNT+1
      WRITE (LPT,122) ALAM,ADUM(1)
  122 FORMAT ('  ***Warning: Change of wavelength Old=',F10.4,' New ='
     1,F10.4)
      WRITE (NEWIN,124) ALAM,UBM
   10 ALAM=ADUM(1)
      GO TO 5
C
C  UB MATRIX
    8 N=0
    9 READ (MESBUF(IS:),103) (ADUM(3*N+I),I=1,3)
      N=N+1
      IF (N.EQ.3) GO TO 11
      GO TO (9,4,90,91,92,93),1-NCHECK(2,0)
   11 IF (.NOT. CHGPAR(ADUM,UBM,9)) GO TO 5
      IF (START) GO TO 12
      CALL TESTP(LPT,LCOUNT,1,HEADNG,2)
      LCOUNT=LCOUNT+1
      CALL MESS(LPT,0,' ***Warning: Change of UB-Matrix')
   12 CALL GMEQ(ADUM,UBM,1,9)
      WRITE (NEWIN,124) ALAM,UBM
  124 FORMAT ('D WVLN',F10.4/'D GEOM 8'/'D L/R 1',3(/'D UMAT',3F10.5))
      GO TO 5
C
C  INDICES AND MEASUREMENT TYPE
   13 IF (RDCOM) THEN
        READ(MESBUF,104)H,IMTYP
        GO TO 30
      ENDIF
      READ(MESBUF,114)H,IMTYP
      IF (JK.NE.3 .OR. ICOM(II).NE.1 .OR. IMTYP.NE.IMEAS) GO TO 3
C  SWITCH TO PROCESS A MEASUREMENT
      M=1
      GO TO (40,41,42) ,IMTYP+1
C
C  ANGLE SCAN DATA
   15 READ(MESBUF(IS:),105) (AIS(I),I=1,3),IAIS
      IF (RDCOM) GO TO 30
      IF (JK.NE.3 .OR. ICOM(II).NE.1) GO TO 3
      M=1
   41 CALL AISPRC(M,LUNS)
      IF (M.GE.0 .OR. M.EQ.-1) GO TO 3
C  NO ERRORS
      JK=-(2+M)
      IF (JK .LE.0) GO TO 90
      GO TO 3
C
C  B-P-B DATA OR ORDER
   16 READ (MESBUF(IS:),106) NBPB
      IF (RDCOM) GO TO 30
      IF (JK.NE.3 .OR. ICOM(II).NE.1) GO TO 3
      M=3
   40 CALL BPBPRC(M)
      IF (M.GE.0 .OR. M.EQ.-1) GO TO 3
C  NO ERRORS
      JK=-(2+M)
      IF (JK .LE.0) GO TO 90
C  END OF DATA
   94 GO TO (1,20,20),JK
C  ERROR RETURN HAVING READ ANOTHER ORDER
      GO TO 3
C
C  BLIND SPOTS
   17 IF (RDCOM) THEN
        READ (MESBUF,112) BLSPS
      ELSE
        READ(MESBUF,113) BLSPS
      ENDIF
      GO TO 5
C
C MONOCHROMATOR
   18 READ (MESBUF(IS:),115) DUMNAM,IPOL
      IF (DUMNAM .EQ. MONOID) GO TO 5
      IF (.NOT. START) THEN
        CALL TESTP(LPT,LCOUNT,1,HEADNG,2)
        LCOUNT=LCOUNT+1
        CALL MESS(LPT,0,' ***Warning: Change of monochromator Old : '//
     &  MONOID//' New : '//DUMNAM)
      ENDIF
      MONOID=DUMNAM
      GO TO 5
C
C FILTER
   19 READ (MESBUF(IS:),116) DUMNAM
      GO TO 22
   23 READ (MESBUF,107) DUMNAM
      GO TO 22
   24 READ (MESBUF,108) DUMNAM
   22 IF (DUMNAM.EQ.FILTER) GO TO 5
      IF (.NOT. START) THEN
        CALL TESTP(LPT,LCOUNT,1,HEADNG,2)
        LCOUNT=LCOUNT+1
        CALL MESS(LPT,0,' ***Warning: Change of Filter Old : '//
     &  FILTER//' New : '//DUMNAM)
      ENDIF
      FILTER=DUMNAM
      GO TO 5
C
C DEAD-TIME
   25 READ (MESBUF(IS:),109) (ADUM(I),I=1,4)
      IF (.NOT.CHGPAR(ADUM,TMORTS,4)) GO TO 5
      IF (.NOT. START) THEN
        CALL TESTP(LPT,LCOUNT,2,HEADNG,2)
        LCOUNT=LCOUNT+2
        WRITE (LPT,150) ADUM(1),ADUM(3),ADUM(2),ADUM(4),
     &  TMORTS(1),TMORTS(3),TMORTS(2),TMORTS(4)
  150   FORMAT ('  ***Warning: Change of dead-time Old: a = ',
     &  E11.3,'+/-',E11.3,' b = ',E11.3,'+/-',E11.3/34X,'New: a = ',
     &  E11.3,'+/-',E11.3,' b = ',E11.3,'+/-',E11.3)
      ENDIF
      CALL GMEQ(ADUM,TMORTS,1,4)
      GO TO 5
C
C POLARISATION
C POL ORDER SWITCHES UP OR DOWN, DATA OR COMMON CHANGES VALUES
   21 IF (JK.EQ.3) GO TO 5
      READ(MESBUF(IS:),110) (ADUM(I),I=1,4)
      IF (.NOT.CHGPAR(ADUM,POLARS,4)) GO TO 5
      IF (.NOT.START) THEN
        CALL TESTP(LPT,LCOUNT,2,HEADNG,2)
        LCOUNT=LCOUNT+2
        WRITE (LPT,129) POLARS,(ADUM(I),I=1,4)
  129 FORMAT ('  ***Warning: Change of polarisation Old: P =',F8.4,
     & ' +/-',F8.4,'e = ',F8.4,'+/-',F8.4/36X,'New P =',F8.4,
     & '+/-',F8.4,'e = ',F8.4,'+/-',F8.4)
      ENDIF
      CALL GMEQ(ADUM,POLARS,4,1)
      WRITE (NEWIN,140) POLARS
  140 FORMAT ('P ',4F10.4)
      GO TO 5
C
C AFTER READING DATA
    5 IF (RDCOM) GO TO 30
      GO TO 3
C
C  READ ANGLES IF SET
   70 IF (JK.EQ.3) READ(MESBUF,119) ANG
      GO TO 3
C
C  READ DATE,TIME AND DVM
   71 IF (JK.NE.3) GO TO 3
      DATE=MESBUF(21:39)
      DVM=MESBUF(54:65)
      GO TO 3
C   28 II=I-3
C      GO TO (25,26,27,42,43,44),II
C
C  POB SCAN
   42 IF (JK.NE.3 .OR. ICOM(II).NE.1) GO TO 3
      CALL POBPRC(M)
      IF (M.LT.0) GO TO 90
      GO TO 3
C
C  HKL SET
   43 READ (MESBUF,118) H
      GO TO 3
C
C  STANDARD REFLECTION
   44 READ (MESBUF,117) H
      IF (JK.NE.3 .OR. ICOM(II).NE.1) GO TO 3
C  SET FOR STANDARD
      M=2
      GO TO (40,41,42),IMTYP+1
C
C  CENTREING
   45 READ (MESBUF(2:),118) H
      IF (JK.NE.3 .OR. ICOM(II).NE.1) GO TO 3
      CALL CENPRC(MC)
      IF (MC.GE.0) GO TO 3
      JK=MC
      GO TO 90
C
C  END OF DATA
   91 JK=1
      GO TO 94
   92 JK=2
      GO TO 94
   93 JK=3
      GO TO 94
   90 JK=-(2+JK)
      IF (JK.GT.0) GO TO 94
      WRITE(ITO,125)NSEQ
  125 FORMAT (' Next free sequence number is',I5)
C
C  CLOSE DATA BASE
      ISTAT=MED_CLOSE()
C
C  WRITE THE UPDATED COMMON DATA FILE
      MESSAG='COMDAT.BIN'
      ICOMU=NOPFIL(1023)
      WRITE (ICOMU) ICOMDA,ICOMCH
      CALL CLOFIL(ICOMU)
      STOP
C  FORMATS FOR READING THE DATA AND COMMON DATA
  100 FORMAT (13X,A8,12X,A8)  !SAMPLE  AND USER NAME
  101 FORMAT (17X,3I5)   !GEOMETRY
  102 FORMAT (11X,F10.4)  !WAVELENGTH
  103 FORMAT (11X,3F10.6)  !UB MATRIX
  104 FORMAT (19X,3F10.4,18X,I5) !HKL AND MTYPE
  105 FORMAT (16X,3F8.4,I8)  !ANGLE SCAN DATA
  106 FORMAT (34X,I8)   !BPB REPEAT NO
  107 FORMAT (31X,A8)   !PHOTO - FILTER
  108 FORMAT (27X,A8)                   !SET BEAM - FILTER
  109 FORMAT (17X,2(F11.8,F16.13))      !DEAD TIME
  110 FORMAT (14X,4F8.4)                !POLARISATION
  111 FORMAT (23X,3I8)          !GEOMETRY
  112 FORMAT (12X,8F8.2)                !BLIND SPOTS
  113 FORMAT (22X,8F8.2)                !SOFTWARE LIMITS
  114 FORMAT (21X,3F10.4,I5)     !HKM
  115 FORMAT (18X,A8,11X,I2)            !MONOCHROMATOR
  116 FORMAT (8X,A8)                    !FILTER
  117 FORMAT (30X,3F10.5)  !STANDARD
  118 FORMAT (11X,3F10.4)         !HKL
  119 FORMAT (41X,3F8.4)                !ANGLES
      END
C
C
C
C
      SUBROUTINE BPBPRC(M)
C
C *** BPBPRC modified by PJB Jun 90 to check reproducubility of peak ***
C
CH Processes BPB measurements
C
      LOGICAL INTIND,PKSR
      DIMENSION FJCOUN(3,2),FCOUNT(3,2,2),RATE(2,2),VRATE(2,2),PEAK(2)
     & ,VPEAK(2),KH(3),CALANG(3)
/D3OPC/
/D3OPN/
/IOUNIT/
      COMMON /HEDING/ HEADNG
      CHARACTER*135 HEADNG
      COMMON /NWORDS/NLWORD,NLWRD1,NKEY,NJWORD,NCOM,NPTAB(20)
      CHARACTER*2 ISTAN(3),AWORD(3)*5
      DATA ISTAN/'  ','**',' #'/
      DATA AWORD/'Omega','Theta',' Nu'/
C
C  SAVE INFORMATION ON TYPE
      MM=M
C
C  CLEAR THE COUNT BUFFER
      DO 16 I=1,3
      DO 16 J=1,2
      DO 16 K=1,2
   16 FCOUNT(I,J,K)=0.
C
      PKSR=.FALSE.
      CPSMAX=0
      IF (M.EQ.3) GO TO 20
C
    2 M = NCHECK(3,NLWRD1+1)
      IF (M.LT.-1) GO TO 100
C  END OF DATA OR ANOTHER KEYWORD
      IF (M.EQ.-1) THEN
        IF (PKSR) THEN
          DO 30 I=1,8
          IF (MESBUF(I:I).EQ.' ') GO TO 30
          IF((MESBUF(I:I).LT.'0' .OR.MESBUF(I:I).GT.'9')
     &    .AND.MESBUF(I:I).NE.'.'.AND. MESBUF(I:I).NE.'-') GO TO 2
   30     CONTINUE
          READ (MESBUF(74:),1100) CPS,DCPS
 1100     FORMAT (2F10.4)
          IF (CPS.GT.CPSMAX) THEN
            CPSMAX=CPS
            DCPSM=DCPS
          ENDIF
        ENDIF
        GO TO 2
      ENDIF
C  TO READ ANOTHER LINE
    1 READ(MESBUF,1000) (ANG(I),I=1,3)
 1000 FORMAT (35X,3F8.4)
C
   19 M=NCHECK(5,0)
      IF (M.LT.-1) GO TO 100
C  END OF DATA OR ANOTHER KEYWORD
      PKSR=M.EQ.0
      IF (PKSR) THEN
        CALL GMEQ(ANG,CALANG,3,1)
        GO TO 2
      ENDIF
   18 READ (MESBUF,101) DATE
  101 FORMAT (4X,A19)
      M=NCHECK(5,0)
      READ (MESBUF,108) TEMPER,FIELD,DVM
  108 FORMAT (39X,A8,6X,A8,6X,A8)
C
   20 M=NCHECK(3,NLWRD1+2)
      IF (M.LT.-1) RETURN
C  END OF DATA OR ANOTHER KEYWORD
      IF (M.EQ.-1) GO TO 20
C
C  TRY AGAIN
    4 DO 5 II=1,NBPB
      DO 6 KK=1,3
      K=MOD(KK,2)+1
      M=NCHECK(2,0)
      IF (M.LT.0) GO TO 8
C
C  ERROR
    7 READ (MESBUF,102) ((FJCOUN(I,J),J=1,2),I=1,3)
  102 FORMAT (2(F10.1,1X),2(F10.4,1X),F10.1,1X,F10.1)
      DO 9 I=1,3
      DO 9 J=1,2
    9 FCOUNT(I,J,K)=FCOUNT(I,J,K)+FJCOUN(I,J)
    6 CONTINUE
C      M=NCHECK(4,1)
      IF (M.LT.0) GO TO 8
    5 CONTINUE
C
C  NOW GET THE RATES AND THE LOST COUNTS CORRECTION
    8 DO 10 J=1,2
      IF (II .LT.2) GO TO 100
C
      DO 11 K=1,2
      IF (FCOUNT(2,J,K).EQ.0) GO TO 12
      IF (FCOUNT(3,J,K).EQ.0) GO TO 12
      TRATE=FCOUNT(1,J,K)/FCOUNT(2,J,K)
      VTRATE = TRATE/FCOUNT(2,J,K)
      CALL LSTCTS(TRATE,VTRATE,TMORTS)
      IF (TRATE .LT. 0 .OR. TRATE .GT.2.) GO TO 14
      RATE(J,K)= (FCOUNT(1,J,K)/FCOUNT(3,J,K))*TRATE
   11 VRATE(J,K)=(RATE(J,K)/FCOUNT(3,J,K))*VTRATE
C
      PEAK(J)=RATE(J,1)-RATE(J,2)
      VPEAK(J)=VRATE(J,1)+VRATE(J,2)
      IF (PEAK(J).LE. SQRT(VPEAK(J))) GO TO 13
   10 CONTINUE
      R = PEAK(1)/PEAK(2)
      DR= R*SQRT((VPEAK(1)/(PEAK(1)**2)) + (VPEAK(2)/(PEAK(2)**2)))
      HTPK=(PEAK(1)+PEAK(2))*(FCOUNT(3,1,1)+FCOUNT(3,2,1))
     & /(2.*(FCOUNT(2,1,1)+FCOUNT(2,2,1)))
      BKG=(RATE(1,2)+RATE(2,2))*(FCOUNT(3,1,2)+FCOUNT(3,2,2))
     & /(2.*(FCOUNT(2,1,2)+FCOUNT(2,2,2)))
      IF (CPSMAX.NE.0) THEN
        CPSMAX=CPSMAX-BKG
        FEROR=DCPSM/CPSMAX
        IF (FEROR.LT..2)FEROR=.2
        IF (ABS(CPSMAX-HTPK)/CPSMAX .GT. FEROR) THEN
          CALL TESTP(LPT,LCOUNT,1,HEADNG,2)
          WRITE (LPT,1101) CPSMAX,HTPK
 1101     FORMAT (' *** Warning peak count not reproduced. ',
     &    F7.0 'in peak search, ',F7.0,' in BPB scan.')
        ENDIF
        DO 31 I=1,3
        IF (ABS(ANG(I)-CALANG(I)) .GT. .5) THEN
          CALL TESTP(LPT,LCOUNT,1,HEADNG,2)
          WRITE (LPT,1102) AWORD(I),CALANG(I),ANG(I)
 1102     FORMAT(' *** Warning observed and calculated angles ',A5,
     &    ' differ by more than 0.5 degrees: calculated ',F8.2,
     &    ' observed ',F8.2)
        ENDIF
   31   CONTINUE
      ENDIF
C
      CALL TESTP(LPT,LCOUNT,1,HEADNG,2)
      IF (INTIND(H,KH)) THEN
        WRITE (LPT,104) NSEQ,ISTAN(MM),KH,ANG,R,DR,HTPK,BKG,
     &  TEMPER,FIELD,DVM,DATE
  104   FORMAT (1X,I4,A2,3(I5,1X),3F8.2,2F10.6,F8.1,1X,F6.1,1X,
     &  3(A8,1X),A19)
        WRITE (LUNO,105) NSEQ,KH,ANG,R,DR,HTPK,DVM,DATE
  105   FORMAT (4I5,3F8.2,2F10.6,F10.1,2X,A8,3X,A19)
      ELSE
        WRITE (LPT,114) NSEQ,ISTAN(MM),H,ANG,R,DR,HTPK,BKG,
     &  TEMPER,FIELD,DVM,DATE
  114   FORMAT (1X,I4,A2,3F6.2,3F8.2,2F10.6,F8.1,1X,F6.1,1X,
     &  3(A8,1X),A19)
        WRITE (LUNO,115) NSEQ,H,ANG,R,DR,HTPK,DVM,DATE
  115   FORMAT (I5,3F6.2,3F8.2,2F10.6,F10.1,2X,A8,3X,A19)
      ENDIF
      NSEQ = NSEQ+1
      GO TO 100
C
C  ERRORS
C  DATA RUN OUT
    3 M=-1
      GO TO 100
C
C  NO DATA
   12 CALL TESTP(LPT,LCOUNT,1,HEADNG,2)
      WRITE (LPT,106) KH
  106 FORMAT (10X,3I5,'   Zero time for measurement')
      GO TO 100
C
C  R NOT SIGNIFICANT
   13 CALL TESTP(LPT,LCOUNT,1,HEADNG,2)
      WRITE (LPT,107) KH
  107 FORMAT (10X,3I5,'   R less than its error')
      GO TO 100
C
C  LOST COUNTS TOO BIG
   14 CALL TESTP(LPT,LCOUNT,1,HEADNG,2)
      WRITE (LPT,109) KH
  109 FORMAT (10X,3I5,'  Detector saturated')
 100  RETURN
      END
C
C
C
C
      SUBROUTINE POBPRC(M)
C
C *** POBPRC BY PJB OCT 88 ***
C
/IOUNIT/
C
      CALL MESS(LPT,0,'P-O-B SCAN PROCESSING NOT IMPLEMENTED')
      RETURN
      END
C
C
C
C
      SUBROUTINE AISPRC(M,LUNS)
C
C *** AISPRC BY PJB OCT 88 ***
C
      CHARACTER*8 ANGNAM
      DIMENSION FCOUNT(3,2),RATE(2),VRATE(2),PEAK(2),VPEAK(2),KH(3)
/D3OPC/
/D3OPN/
/IOUNIT/
      COMMON /HEDING/ HEADNG
      CHARACTER*135 HEADNG
      COMMON /NWORDS/NLWORD,NLWRD1,NKEY,NJWORD,NCOM,NPTAB(20)
C
C
   19 M=NCHECK(5,0)
      IF (M.LT.-1)GO TO 100
      IF (M.NE.0) GO TO 19
C  END OF DATA OR ANOTHER KEYWORD
   18 READ (MESBUF,101) ANGNAM
  101 FORMAT (A8)
C
      IF (IAIS.LT.0) THEN
        NSTEP=1-IAIS
      ELSE
        NSTEP=2*IAIS+1
      ENDIF
      DO 21 ISTEP=1,NSTEP
   20 M=NCHECK(2,0)
      IF (M.LT.-1) GO TO 100
C  END OF DATA OR ANOTHER KEYWORD
      IF (M.EQ.-1) GO TO 20
    7 READ (MESBUF,102) ANGL,((FCOUNT(I,J),J=1,2),I=1,3)
  102 FORMAT (F8.2,2(F10.1,1X),2(F10.4,1X),F10.1,1X,F10.1)
C  NOW GET THE RATES AND THE LOST COUNTS CORRECTION
    8 DO 10 J=1,2
      IF (FCOUNT(2,J).EQ.0) GO TO 12
      IF (FCOUNT(3,J).EQ.0) GO TO 12
      TRATE=FCOUNT(1,J)/FCOUNT(2,J)
      VTRATE = TRATE/FCOUNT(2,J)
      CALL LSTCTS(TRATE,VTRATE,TMORTS)
      IF (TRATE .LT. 0 .OR. TRATE .GT.2.) GO TO 14
      RATE(J)= (FCOUNT(1,J)/FCOUNT(3,J))*TRATE
   11 VRATE(J)=(RATE(J)/FCOUNT(3,J))*VTRATE
   10 CONTINUE
      R=RATE(1)/RATE(2)
      DR=R*SQRT((VRATE(1)/RATE(1))**2+(VRATE(2)/RATE(2))**2)
      WRITE (LPT,110) ANGL,((RATE(I),VRATE(I)),I=1,2),R,DR
  110 FORMAT (F8.2,2X,4F10.1,2F10.4)
   21 CONTINUE
      GO TO 100
C
C  NO DATA
   12 CALL TESTP(LPT,LCOUNT,1,HEADNG,2)
      WRITE (LPT,106) KH
  106 FORMAT (10X,3I5,'   Zero time for measurement')
      GO TO 100
C
C  LOST COUNTS TOO BIG
   14 CALL TESTP(LPT,LCOUNT,1,HEADNG,2)
      WRITE (LPT,109) KH
  109 FORMAT (10X,3I5,'  Detector saturated')
C
  100 RETURN
      END
C
C
C
C
      SUBROUTINE CENPRC(M)
C
CH  PROCESS CENTREING COMMANDS
C
C
      LOGICAL INTIND
      CHARACTER*10 FILNOM
      DIMENSION K(3)
/D3OPC/
/D3OPN/
      COMMON /HEDING/ HEADNG
      CHARACTER*135 HEADNG
/IOUNIT/
      COMMON /NWORDS/NLWORD,NLWRD1,NKEY,NJWORD,NCOM,NPTAB(20)
/SCRACH/
      IF (LUNC.LE.0) THEN
        CALL TESTP(LPT,LCOUNT,1,HEADNG,2)
        IF (LUNC.EQ.0) THEN
          MESSAG='File of centered angles'
          NAMFIL='.CEN'
          LUNC=NOPFIL(112)
          OP3=FILNOM(LUNC)
        ELSE
          MESSAG=OP3
          LUNC=NOPFIL(24)
        ENDIF
      ENDIF
C
      CALL TESTP(LPT,LCOUNT,1,HEADNG,2)
    1 M=NCHECK(3,NLWRD1+3)
      IF (M.LT.-1) THEN
        WRITE (LPT,14) H,'not Centred'
   14   FORMAT (7X,3F6.2,22X,A11)
        GO TO 100
      ENDIF
      IF (M.EQ.-1) GO TO 1
      READ (MESBUF,10)H,ANG
   10 FORMAT (21X,3F8.4,3F8.2)
      WRITE (LUNC,11) H,ANG
   11 FORMAT (3F10.4,3F8.2)
      IF (INTIND(H,K)) THEN
        WRITE (LPT,12)K,ANG,'  Centred'
   12   FORMAT (7X,3(I5,1X),3F8.2,A9)
      ELSE
        WRITE (LPT,13)H,ANG,'  Centred'
   13   FORMAT (7X,3F6.2,3F8.2,A9)
      ENDIF
  100 RETURN
      END
C
C
C
C
      FUNCTION NCHECK(M,LL)
C
C *** NCHECK BY PJB OCT 88 ***
C
      CHARACTER*5 WARN(1)
      COMMON /ALWORD/LWORD(25),KEY(6),JWORD(3)
      CHARACTER*5 LWORD,KEY,JWORD
      CHARACTER*10 NEWNAM,FILNOM,FILE*6
/D3OPC/
/D3OPN/
/FINAME/
      COMMON /HEDING/ HEADNG
      CHARACTER*135 HEADNG
/IOUNIT/
/LOONEY/
      COMMON /NWORDS/NLWORD,NLWRD1,NKEY,NJWORD,NCOM,NPTAB(20)
/SCRACH/
C
      DATA NWARN,WARN/1,'TIMEO'/
C
      L=LL
      NCHECK=0
C
C  SECTION TO GET A NEW FILE FROM THE DATA BASE
    1 IF (IREC.LE.0) THEN
        MESSAG=IP1
        CALL RDWORD(NEWNAM,LEN,1,IPT,11,0,IER)
        IF (IER.NE.0) GO TO 90
%        DO 501 I=1,%FILE%
        IF (LUNTAB(I).EQ.LUNI) GO TO 502
  501   CONTINUE
  502   FILNAM(I)=NEWNAM
        CALL RDINTG(ICYC,IPT,IPT1,IPT+5,IER)
        IF (IER.EQ.100) THEN
          ICYC=0
        ELSE
          IF (IER.NE.0) GO TO 90
        ENDIF
        FILE=NEWNAM(1:6)
        CALL UPPER(FILE)
        ISTAT=MED_FIND(FILE,ICYC,IREC,IEND)
        IF (ISTAT.EQ.0) THEN
          NCHECK=-2
          CALL TESTP(LPT,LCOUNT,1,HEADNG,2)
          WRITE (LPT,13) FILE,ICYC
          WRITE (ITO,13) FILE,ICYC
   13     FORMAT (' File ',A6,' from reactor cycle ',I4
     &    ,' not found in the data-base')
          GO TO 100
        ENDIF
        WRITE (LPT,16) FILE
        WRITE (ITO,16) FILE
   16   FORMAT (' Data now being read from ',A6)
        IEND=IEND+IREC-1
C  READ HEADER; DO NOTHING WITH IT FOR NOW
        READ (LUNI,REC=IREC) MESBUF
        IREC=IREC+1
      ENDIF
C
C  READ NEXT RECORD
      READ (LUNI,REC=IREC) MESBUF
      IREC=IREC+1
      IF (IREC.GT.IEND) GO TO 52
C
C  IGNORE BLANK LINES
      IF (LENG(MESBUF,79).LE.1) GO TO 1
C
C  SEARCH FOR KEYWORD
      I=NCFIND(MESBUF(1:5),KEY,NKEY)
      IF (I .EQ. 0) GO TO (1,20,30,40,50),M
C IGNORE WARNING TYPE MESSAGES  WHEN LOOKING FOR KEYWORD
      IF (I.GE.4 .AND. (M.EQ.1.OR.M.EQ.3)) GO TO 1
C
    3 NCHECK=I
      IF (M.NE.1) THEN
C
C DTI: MESSAGES
        IF (I.EQ.6) THEN
C SKIP THREE LINES
          IREC=IREC+3
          IF (IREC.GT.IEND) GO TO 52
        ELSE
C
C  CHECK FOR SERIOUS WARNINGS, SKIP IF NOT SERIOUS
          IF (I.EQ.5) THEN
            IF (NCFIND(MESBUF(10:14),WARN,NWARN).EQ.0) GO TO 1
          ENDIF
        ENDIF
        NCHECK=-2-I
C  KEYWORD FOUND WHEN NOT LOOKING FOR ONE, SET ERROR
      ENDIF
      GO TO 100
C
C  DATA RUN OUT
   52 CALL INCREM(FILNOM(LUNI),NEWNAM)
      IP1(1:6)=NEWNAM
      CALL TESTP(LPT,LCOUNT,1,HEADNG,2)
      IREC=-1
      GO TO 1
C
C  MAKE SURE NO NON-NUMERICAL CHARACTERS
   20 DO 21 I=1,5
      IF (MESBUF(I:I).EQ.' ' .OR. MESBUF(I:I).EQ.'-') GO TO 21
      IF (NDIGIT(MESBUF(I:I)) .EQ. -1) GO TO 22
   21 CONTINUE
      GO TO 100
   22 CALL TESTP(LPT,LCOUNT,3,HEADNG,2)
      LCOUNT=LCOUNT+2
      WRITE (LPT,12) MESBUF(1:20)
   12 FORMAT ('0 Characters "',A20,'" Read when expecting a number'/)
      NCHECK=-1
      GO TO 100
C
C  CHECK THE FIRST 5 CHARACTERS IN A LINE
   30 IF (MESBUF(1:5).NE. LWORD(L))NCHECK=-1
      GO TO 100
C
C  ADVANCE BY LL LINES
   40 L=L-1
      IF (L.EQ.0) GO TO 100
      GO TO 1
C
C  ERROR IN SPECIFICATION OF RECORD
   90 CALL MESS(ITO,0,'Error in specification of record; '//MESSAG//
     & 'Give filename (A6) and cycle number (I5)')
      IP1=MESSAG
      GO TO 1
C
   50 IF (.NOT. NCFIND(MESBUF(1:5),JWORD,3)) NCHECK=-1
  100 RETURN
      END
C
C
C
C
      SUBROUTINE OPMED
C
C *** OPMED BY PJB OCT 88 ***
C
CH To open the data-base for D3OP90
C
      DIMENSION IDUM(2)
/IOUNIT/
/LOONEY/
C
      DO 1 J=1,2
%      DO 2 I=1,%FILE%
      IF (IOTAB(I).EQ.0)THEN
        IDUM(J)=LUNTAB(I)
        IOTAB(I)=IDUM(J)
        IREC=0
        GO TO 1
      ENDIF
    2 CONTINUE
    1 CONTINUE
      LUNI=IDUM(1)
      IF(.NOT.MED_OPEN('D3  ',IDUM(2),LUNI))STOP
     & ' Error opening the data base'
      RETURN
      END
C
C
C
C
      BLOCK DATA PAGEHD
      COMMON /ALWORD/LWORD(25),KEY(6),JWORD(3)
      CHARACTER*5 LWORD,KEY,JWORD
/D3OPN/
      COMMON /NWORDS/NLWORD,NLWRD1,NKEY,NJWORD,NCOM,NPTAB(22)
      COMMON /HEDING/ HEADNG
      CHARACTER*135 HEADNG
      DATA HEADNG/' (''0Seq No       h    k    l   Omega  2Theta     N
     &u       R        dR    Pk cps  Bg cps  Temp    Field     DVM
     &        Date    Time''/)'/
      DATA LWORD/'SAMPL','BLIND','GEOME','WAVEL','MONOC','FILTE',
     & 'UB MA','REFLE','ANGLE','B-P-B','DEAD ','POLAR','P-O-B',
     & ' HKL ','HKL M','STAND','DATE ','PHOTO','SET B','SOFTW',
     & 'CENTR','CENTR','SHAFT','  COU','***CE'/
      DATA JWORD/'   OM','   GA','   NU'/
      DATA KEY/'COMMO','DATA:','ORDER','COMMA','WARNI','DTI: '/
C  NLWORD IS NUMBER OF 5 LETTER STRINGS TO RECOGNISE AS DATA OF WHICH
C  NLWRD1 FOLLOW A data/order-WORD
C  NKEY NUMBER OF SPECIAL KEY WORDS
C  NJWORD NUMBER OF SHAFT ANGLE NAMES
C  NCOM NUMBER OF ITEMS TO BE READ FROM COMMON DATA (IST NCOM OF LWORD)
      DATA NLWORD,NLWRD1,NKEY,NJWORD,NCOM/25,22,6,3,12/
C TABLE NPTAB ASSOCIATES THE ORDERS WITH THE DATA WORDS
      DATA NPTAB/0,0,0,0,0,0,0,0,2,3,0,0,4,5,1,6,0,0,0,0,7,8/
C LUNC SET TO 0 TO INDICATE CENTREING FILE NOT OPEN
      DATA LUNC/0/
      END
C
C
C
C
      LOGICAL FUNCTION CHGPAR(A,B,N)
C
C *** CHGPAR BY PJB OCT 88 ***
C
CH Indicates whether two real arrays are the same
CA On entry A and B are real arrays of length N
CA On exit CHGPAR is TRUE if they are different (i.e. CHanGed PARameters)
CA                   FALSE if same
C
      DIMENSION A(N),B(N)
      DO 1  I=1,N
      IF (ABS(A(I)-B(I)) .LT. 10.E-12) GO TO 1
      CHGPAR=.TRUE.
      GO TO 100
    1 CONTINUE
      CHGPAR=.FALSE.
  100 RETURN
      END
C
C
C
C
      LOGICAL FUNCTION INTIND(H,K)
C
CH True if the indices H(3) are integer
CA K(3) returned as the integer values
C
      DIMENSION H(3),K(3),HI(3)
      LOGICAL INTIN
C
      CALL INDFIX(H,K)
      CALL INDFLO(HI,K)
      DO 1 I=1,3
      INTIN=ABS(H(I)-HI(I)).LT..0001
      IF (.NOT. INTIN) GO TO 2
    1 CONTINUE
    2 INTIND=INTIN
      RETURN
      END
C
C
C
C
C LEVEL 50      PROGRAM D3OP99
      PROGRAM D3OP99
C
C *** D3OP99 from D3OP99 by PJB  21-June 1999 ***
C
CC 2D
CH Analysis of raw D3 data 1999 version
C
CD Reads the data files, written by the polarised neutron
CD diffractometer D3, from the ILL ASCII data base and processes
CD them according to the chosen options.
CD The processing procedure depends upon the orders being processed
CD and it is not useful to process different classes of order in the
CD same run. The  different classes are:
CD    A. Flipping ratios (*BPB and *HKM, *SRM type 0)
CD    B. Angle scans (*AIS and *HKM, *SRM type 1)
CD       Note that COL5D3 may be more appropriate in this case
CD    C. Centering data
CD
CD A. Flipping ratios
CD    The program reads the detector counts, monitor counts and times
CD    for the measurements in two spin states for the peak and for the
CD    background. A dead time correction is made and the results used
CD    to calculate the flipping
CD    ratios. Checks are carried out on the consistency of successive
CD    measurements of the same peak, and of the reproducibility of the peak
CD    count between the measurement value and the value found in the peak
CD    search.
CD B. Angle Scans
CD    After making a lost counts correction the recorded counts in eqch
CD    channel are printed together with the value of the primary scanned
CD    angle and a cumulative sum of the counts. These may be used to estimate
CD    a crude integrated intensity.
CD    To obtain better integrated intensities use COL5D3.
CD
CD C. The results of the centering orders can be extracted for use in
CD    determining the UB matrix, lattice parameters etc.
C
CI A sequence of the ASCII data files written by D3. These are
CI normally taken from the ILL database, but will be taken from the
CI path given in the environment variable D3DATA if that is defined. The
CI current (Sept 1998) path for the ILL data base is /usr/illdata,
CI if another path is needed it can be given in the environment
CI variable ILLDATA. The sequence of files is terminated by a
CI missing file in the sequence:
CI      fname(n+1)= fname(n) + 1
CI where 9+1=a, a+1=b ... and z+1=10
C
CO A listing file which reports the processing which was done and
CO any changes which were made to the experimental configuration (eg.
CO changes of wavelength, filter etc) during the run.
CO
CO A file "dcards.cry" to which the polarisation, UB matrix and wavelength are
CO written each time they change.
CO
CO If flipping ratio measurements are being processed the results are
CO written on an output file with default extension ".fli". The data
CO recorded for each reflection are: a sequence number, the hkl, the
CO diffractometer angles \$\omega\$,  \$\gamma\$ and \$\nu\$,
CO the flipping ratio and its standard deviation, the peak count
CO in cps (background corrected), the temperature and  magnetic
CO field and finally the date and time of the
CO measurement. FORMAT (4I5,3F8.2,2F10.6,F10.1,32A1).
CO This file is suitable for input to ARRNGE with DTYP 1.
CO
CO A binary file comdat.bin which records the parameters which were
CO defined during the processing, and which will be reused in future
CO runs of D3OP97 which then do not need to be initialised.
C
CR When running the program the user is asked whether to "Initialise"
CR or "Not" or whether to "Continue". The reply is "Y"es to start a new
CR experiment or if the common data have been changed since the last
CR run, i.e. the sample, experimental conditions, or wavelength are
CR different. Reply "C"ontinue to proceed without asking questions. If
CR the reply is C processing will continue from the next file in
CR sequence after the last processed in the previous run. The reply
CR should be "N"o if there is a break in the sequence of output files.
CR
CR If the reply is Y or N futher questions are posed to allow the
CR source of data to be identified. The replies to most questions
CR should be self evident. The cycle number is 0 or "return"
CR for the current cycle, -1 for the previous cycle, otherwise the 3
CR digit cycle number eg 964 for the 4th cycle in 1994.
CR
CR The first and optionally last files to
CR process should be in lower case without an extension.
CR
CR The orders to be processed should be one or more of *BPB, *AIS, *CEN
CR *HKL, *HKM, *SRM  But as mentioned above it is not
CR usually useful to process different classes of order in the same run.
C
CN Uses new UNIX database. The path from which to read the
CN data can be specified by the environment variable D3DATA
CN The path for the data base can be given in the environment variable
CN ILLDATA. It defaults to /usr/illdata (Sept98).
CN Non-Integer indices can be printed
CN If "Continue" checks to see whether more data are available on the last
CN file read in the prevous run.
C
C **********************************************************************
C
C                            D 3 O P 9 9
C
C  NEW D3 PROCESSING PROGRAM FOR MAD SYSTEM 1997 VERSION for UNIX DATA
C  UPDATED June 1999 for changed formats
C
C **********************************************************************
C
      DIMENSION ADUM(9),ICOMDA(54)
      CHARACTER*30 ICOMCH(10),DUMNAM*8
      CHARACTER*4 MORD(9),UNORD
      DIMENSION ICOM(9)
      LOGICAL START,BEGIN,SAYS,RDCOM,CHGPAR,CONT,ISEFF
      CHARACTER*100 FMT1
      COMMON /ALWORD/LWORD(27),KEY(6),JWORD(3)
      CHARACTER*5 LWORD,KEY,JWORD
/D3OPC/
/D3OPN/
/GLOBAL/
      COMMON /HEDING/ HEADNG
      CHARACTER*135 HEADNG
/IOUNIT/
      COMMON /NWORDS/NLWORD,NLWRD1,NKEY,NJWORD,NCOM,NPTAB(22)
/SCRACH/
      EQUIVALENCE(ICOMDA,IGEO),(ICOMCH,ISNAME)
      DATA MORD/'*HKM','*AIS','*BPB','*POB','*HKL','*SRM','*CEN','*CEA'
     &,'*RTE'/
      DATA NMORD/9/
C
      START=.TRUE.
      BEGIN=.TRUE.
      IEND=.TRUE.
      LINENO=0
      LINORD=0
C  TO CHOOSE APPEND FOR WRITE FILES
      INIT=124
C
C  SET UP
      CALL INITIL('D3OP99')
C LUN(4) SET TO 0 TO INDICATE FILES NOT OPEN
      CALL JGMZER(LUN,4,1)
   56 CALL ASK('INITIALISE ? Answer Y(es), N(o) C(ont) or H(elp)')
      IF (SAYS('H')) THEN
        CALL MESS(ITO,0,'Reply Yes if you are starting a new '//
     &'experiment or if the common data have been')
        CALL MESS(ITO,0,'changed since the last run, i.e. the '//
     &'sample, experimental conditions, UBM or')
        CALL MESS(ITO,0,'wavelength are different')
        CALL MESS(ITO,0,'Reply Continue to continue processing as '//
     &'before in the standard file sequence')
        CALL MESS(ITO,0,'Reply No if you want the opportunity to '//
     &'change a file-name or the orders to be processed')
        GO TO 56
      ENDIF
C
      CONT=SAYS('C')
      IF (SAYS('Y')) GO TO 59
      RDCOM=.FALSE.
      MESSAG='COMDAT.BIN'
      CALL UPONE(MESSAG,NSYSTM)
      ICOMU=NOPFIL(1021)
      READ (ICOMU) ICOMDA,ICOMCH
      START=.FALSE.
      DO 46 I=1,4
      LUN(I)=-LUN(I)
   46 CONTINUE
      CALL CLOFIL(ICOMU)
      IF (CONT) THEN
        IP1=IPOLD
        GO TO 57
      ENDIF
      CALL ASK('User is: '//IUNAME//' Sample is: '//ISNAME//
     &' OK ? Y(es) or N(o)')
      IF (.NOT. SAYS('Y')) GO TO 59
      LDIR=LENGT(DATDIR)
      IP1=IPOLD
      CALL MESS(ITO,0,'Data will be read from '//DATDIR(1:LDIR)//IP1)
      CALL ASK('OK ? Y(es) or N(o)')
      OLDFIL= SAYS('Y')
      IF (.NOT. OLDFIL) CALL INFILE
C
   57 OLDFIL = OLDFIL .OR. CONT
      IF (CONT) GO TO 64
      L=LENGT(OP2)
      WRITE (MESSAG,226) L
      WRITE(ITO,MESSAG)OP2,NSEQ(1)
  226 FORMAT ('('' Results will be appended to file '',A',I3,
     &','' starting at sequence number'',I5)')
      CALL ASK('OK ? Y(es) or N(o)')
      IF (SAYS('Y')) GO TO 64
      CALL ASK('Give new output file-name')
      OP2=MESSAG
      LUN(2)=0
      INIT=122
      GO TO 61
C
C  COMMON DATA FILE NOT FOUND
C   60 CALL ASK('Common data file COMDAT.BIN was not found. Continue ?'//
C     &'Y(e)s or N(o)')
C      IF (.NOT. SAYS('Y')) STOP
C
C  HERE TO INITIALISE
C  SET STATUS NEW FOR WRITE FILES
   59 INIT=122
      CALL INFILE
      CALL ASK('Give output file name')
      OP2=MESSAG
   61 CALL ASK('Sequence number for first reflection?')
      CALL RDINTG(NSEQ(1),1,IPT,80,IER)
      IF (.NOT. START) GO TO 64
C     PUT IN THOSE D3 INSTRUCTIONS TO BE PROCESSED IN THIS RUN
   63 CALL ASK('Give the orders to be processed in this run, A4,1X,..')
      READ (ICARD,214) NORD
  214 FORMAT (10(A4,1X))
C     NOW RECOGNISE ORDERS AND SET MARKERS
   64 DO 51 I = 1,NMORD
   51 ICOM(I) = 0
      DO 52 I = 1,NMORD
      IF (NORD(I) .EQ. ' ') GO TO 54
C     END OF LIST
      DO 53 J = 1,NMORD
C ALLOW LOWER CASE ORDERS
      UNORD=NORD(I)
      CALL UPPER(UNORD)
      IF (UNORD .NE. MORD(J)) GO TO 53
      ICOM(J) = 1
      GO TO 52
   53 CONTINUE
   52 CONTINUE
   54 NUMORD=I
C FORCE READ TEMPERATURE TO BE PROCESSED
      IF (ICOM(9).EQ.0) THEN
        ICOM(9)=1
        NUMORD=I+1
      ENDIF
      IF (START .OR. CONT) GO TO 62
      WRITE(ITO,303) (NORD(II),II=1,I)
  303 FORMAT (' The orders which will be processed are : ',6(A5))
      CALL ASK('OK ? Y(es) or N(o)')
      IF (.NOT. SAYS('Y')) GO TO 63
   62 NAMFIL='.FLI'
      IF (ICOM(1).EQ.1) THEN
C ask which type of measurement
        IF (.NOT. CONT) THEN
          CALL ASK('Which type of hkm scan? (return gives BPB)')
          CALL RDINTG(IMEAS,1,IPT,10,IER)
          IF (IER.NE.0) IMEAS=0
        ENDIF
      ENDIF
C      IF (ICOM(2).EQ.1 .OR. IMEAS.EQ.1) THEN
C IF PROCESSING SCANS OPEN PLOTTER WINDOW
C       CALL ASK('Display on Tektronix or X-terminal (T/X)')
C       IF (SAYS('T')) THEN
C         TERM='/TEK4010'
C       ELSE IF (SAYS('X')) THEN
C         TERM='/XWIN'
C       ELSE
C         GO TO 20
C       ENDIF
C       CALL PUTENV('PGPLOT_ILL_DEV_1='//TERM)
C       CALL PUTENV('PGPLOT_ILL_DEV_2=/PS')
C       CALL PGOPJB(0,IER,3,3)
C       IF (IER.NE.0) STOP 'ERROR OPENING PGPLOT'
C       CALL PGPAPER(0.0,1.)
C      CALL PGSLCT(1,IOLD,IER)
C      CALL PGASK(.TRUE.)
C      ENDIF
      MESSAG=OP2
      LUNO=NOPFIL(INIT)
      OP2=NAMFIL
      MESSAG='DCARDS.CRY'
      CALL UPONE(MESSAG,NSYSTM)
      NAMFIL=' '
      NEWIN=NOPFIL(INIT)
C
C  PUT OUT HEADING
      IF (START) GO TO 3
   36 START=.FALSE.
      WRITE (LPT,130)
      WRITE (LPT,131)
      CALL ADDSPC(ISNAME,8)
      CALL ADDSPC(IUNAME,8)
      WRITE (LPT,132) ISNAME,IUNAME
      CALL ADDSPC(MONOID,8)
      CALL ADDSPC(FILTER,8)
      WRITE (LPT,135) MONOID,FILTER
      J2=40-5*NUMORD
      J1=J2/2
      J2=J2-J1
      WRITE (FMT1,134) J2,NUMORD,J1
      WRITE (LPT,FMT1) (NORD(II),II=1,NUMORD)
      WRITE (LPT,131)
      WRITE (LPT,133)
      WRITE (LPT,136) TMORTS(1),TMORTS(3),TMORTS(2),TMORTS(4)
  130 FORMAT ('0',25X,13('*****')/26X,'*',22X,'D3 DATA PROCESSING'
     &,23X,'*')
  131 FORMAT (26X,'*',63X,'*')
  132 FORMAT (26X,'*',11X,'Sample Name:',A8,'  User Name:',A8,12X,'*')
  133 FORMAT (26X,13('*****')/)
  134 FORMAT ('(26X,''*'',',I2,'X,''Orders being Processed:'',',I2,
     &'(1X,A4)',I2,'X,''*'')')
  135 FORMAT (26X,'*',11X,'Monochromator: ',A8,'   Filter: ',
     &A8,10X,'*')
  136 FORMAT ('0       Dead time parameters: a = ',
     &E11.3,'+/-',E11.3,' b = ',E11.3,'+/-',E11.3//)
      WRITE (LPT,HEADNG)
      LCOUNT=28
C  *****START TO READ DATA*****
    3 LINORD=LINENO-1
C SAVE POSITION O FTHIS LINE
      JK=NCHECK(1,0)
      IF (JK.LE.0) GO TO 90
      IF (JK.EQ.1) GO TO 1
      IF (.NOT. START) GO TO 20
C  MUST READ COMMON DATA TO START PROCESSING
      IF (.NOT.BEGIN)GO TO 3
      LCOUNT=LCOUNT+1
      CALL MESS(LPT,0,' ***Warning: File does not start with a '//
     &'common data block')
      BEGIN=.FALSE.
      GO TO 3
C
C  READ SELECTED PARTS OF COMMON DATA
    1 RDCOM=.TRUE.
      ICD=0
   30 ICD=ICD+1
      IF (ICD.GT.NCOM) THEN
        RDCOM=.FALSE.
        IF (START) GO TO 36
        GO TO 3
      ENDIF
      IS=1
    4 GO TO (14,4,90,91,92,93), 1-NCHECK(3,ICD)
   14 GO TO (2,17,6,7,18,19,8,13,15,16,25,21),ICD
C
C  COME HERE AFTER DATA OR ORDER TO UPDATE DATA
   20 I=NCFIND(MESBUF(7:11),LWORD,NLWRD1)
      IF (I.EQ.0) GO TO 3
C  WORD NOT RECOGNISED
      II=NPTAB(I)
      IS = 7
      IF(I.EQ.9) IS=1
      IF(I.EQ.10) IS=2
      GO TO (2,3,6,7,18,19,8,3,15,16,25,21,42,43,13,44,71,23,
     &24,17,45,45,50),I
C
C  SECTION GIVING PROCEDURES AFTER DATA KEYWORDS
C  SAMPLE NAME
    2 IF (RDCOM) THEN
        READ (MESBUF,100)DUMNAM,IUNAME
      ELSE
        READ (MESBUF(IS:),100)DUMNAM
      ENDIF
      IF (DUMNAM.EQ.ISNAME) GO TO 5
C  HERE FOR NEW SAMPLE
      ISNAME=DUMNAM
      IF (START) GO TO 5
      CALL TESTP(LPT,LCOUNT,1,HEADNG,2)
      LCOUNT=LCOUNT+1
      CALL MESS(LPT,1,MESBUF)
      GO TO 5
C
C  GEOMETRY
    6 IF (RDCOM) THEN
        READ(MESBUF,101) IGEO
      ELSE
        READ(MESBUF,111) IGEO
      ENDIF
      GO TO 5
C
C  WAVELENGTH
    7 READ(MESBUF(IS:),102) ADUM(1)
      IF (.NOT. CHGPAR(ADUM,ALAM,1)) GO TO 5
      IF (START) GO TO 10
      CALL TESTP(LPT,LCOUNT,1,HEADNG,2)
      LCOUNT=LCOUNT+1
      WRITE (LPT,122) ALAM,ADUM(1)
  122 FORMAT ('  ***Warning: Change of wavelength Old=',F10.4,' New ='
     &,F10.4)
      WRITE (NEWIN,124) ADUM(1),UBM
   10 ALAM=ADUM(1)
      GO TO 5
C
C  UB MATRIX
    8 N=0
    9 READ (MESBUF(IS:),103) (ADUM(3*N+I),I=1,3)
      N=N+1
      IF (N.EQ.3) GO TO 11
      GO TO (9,4,90,91,92,93),1-NCHECK(2,0)
   11 IF (.NOT. CHGPAR(ADUM,UBM,9)) GO TO 5
      IF (START) GO TO 12
      CALL TESTP(LPT,LCOUNT,1,HEADNG,2)
      LCOUNT=LCOUNT+1
      CALL MESS(LPT,0,' ***Warning: Change of UB-Matrix')
   12 CALL GMEQ(ADUM,UBM,1,9)
      WRITE (NEWIN,124) ALAM,UBM
  124 FORMAT ('D WVLN',F10.4/'D GEOM 8'/'D L/R 1',3(/'D UMAT',3F10.5))
      GO TO 5
C
C  INDICES AND MEASUREMENT TYPE
   13 IF (RDCOM) THEN
        READ(MESBUF,104)H,IMTYP
        GO TO 30
      ENDIF
      READ(MESBUF,114)H,IMTYP
      IF (JK.NE.3 .OR. ICOM(II).NE.1 .OR. IMTYP.NE.IMEAS) GO TO 3
C  SWITCH TO PROCESS A MEASUREMENT
      M=1
      GO TO (40,41,42) ,IMTYP+1
C
C  ANGLE SCAN DATA
   15 READ(MESBUF(IS:),105) (AIS(I),I=1,3),IAIS
      IF (RDCOM) GO TO 30
      IF (JK.NE.3 .OR. ICOM(II).NE.1) GO TO 3
      M=1
   41 CALL AISPRC(M,LUNS)
      IF (M.GE.0 .OR. M.EQ.-1) GO TO 3
C  NO ERRORS
      JK=-(2+M)
      IF (JK .LE.0) GO TO 90
      GO TO 3
C
C  B-P-B DATA OR ORDER
   16 READ (MESBUF(IS:),106) NBPB
      IF (RDCOM) GO TO 30
      IF (JK.NE.3 .OR. ICOM(II).NE.1) GO TO 3
      M=3
   40 CALL BPBPRC(M)
      IF (M.GE.0 .OR. M.EQ.-1) GO TO 3
C  NO ERRORS
      JK=-(2+M)
      IF (JK .LE.0) GO TO 90
C  END OF DATA
   94 GO TO (1,20,20),JK
C  ERROR RETURN HAVING READ ANOTHER ORDER
      GO TO 3
C
C  BLIND SPOTS
   17 IF (RDCOM) THEN
        READ (MESBUF,112) BLSPS
      ELSE
        READ(MESBUF,113) BLSPS
      ENDIF
      GO TO 5
C
C MONOCHROMATOR
   18 READ (MESBUF(IS:),115) DUMNAM,IPOL
      IF (DUMNAM .EQ. MONOID) GO TO 5
      IF (.NOT. START) THEN
        CALL TESTP(LPT,LCOUNT,1,HEADNG,2)
        LCOUNT=LCOUNT+1
        CALL MESS(LPT,0,' ***Warning: Change of monochromator Old : '//
     &MONOID//' New : '//DUMNAM)
      ENDIF
      MONOID=DUMNAM
      GO TO 5
C
C FILTER
   19 READ (MESBUF(IS:),116) DUMNAM
      GO TO 22
   23 READ (MESBUF,107) DUMNAM
      GO TO 22
   24 READ (MESBUF,108) DUMNAM
   22 IF (DUMNAM.EQ.FILTER) GO TO 5
      IF (.NOT. START) THEN
        CALL TESTP(LPT,LCOUNT,1,HEADNG,2)
        LCOUNT=LCOUNT+1
        CALL MESS(LPT,0,' ***Warning: Change of Filter Old : '//
     &FILTER//' New : '//DUMNAM)
      ENDIF
      FILTER=DUMNAM
      GO TO 5
C
C DEAD-TIME
   25 READ (MESBUF(IS:),109) (ADUM(I),I=1,4)
      IF (.NOT.CHGPAR(ADUM,TMORTS,4)) GO TO 5
      IF (.NOT. START) THEN
        CALL TESTP(LPT,LCOUNT,2,HEADNG,2)
        LCOUNT=LCOUNT+2
        WRITE (LPT,150) ADUM(1),ADUM(3),ADUM(2),ADUM(4),
     &TMORTS(1),TMORTS(3),TMORTS(2),TMORTS(4)
  150   FORMAT ('  ***Warning: Change of dead-time Old: a = ',
     &E11.3,'+/-',E11.3,' b = ',E11.3,'+/-',E11.3/34X,'New: a = ',
     &E11.3,'+/-',E11.3,' b = ',E11.3,'+/-',E11.3)
      ENDIF
      CALL GMEQ(ADUM,TMORTS,1,4)
      GO TO 5
C
C POLARISATION
C POL ORDER SWITCHES UP OR DOWN,  COMMON  or /DPL CHANGES VALUES
   21 IF (JK.GT.1) GO TO 5
      READ(MESBUF(IS:),110) (ADUM(I),I=1,4)
      IF (.NOT.CHGPAR(ADUM,POLARS,4)) GO TO 5
      ISEFF=(ADUM(3).GT.0)
      IF (.NOT.START) THEN
        CALL TESTP(LPT,LCOUNT,2,HEADNG,2)
        LCOUNT=LCOUNT+2
        IF (ISEFF) THEN
          WRITE (LPT,129) POLARS,(ADUM(I),I=1,4)
  129 FORMAT ('  ***Warning: Change of polarisation Old: P =',F8.4,
     &' +/-',F8.4,'e = ',F8.4,'+/-',F8.4/36X,'New P =',F8.4,
     &'+/-',F8.4,'e = ',F8.4,'+/-',F8.4)
        ELSE
          WRITE (LPT,128) POLARS,(ADUM(I),I=1,4)
  128 FORMAT ('  ***Warning: Change of polarisation Old: Pup =',F8.4,
     &' +/-',F8.4,'Pdown = ',F8.4,'+/-',F8.4/36X,'New: Pup =',F8.4,
     &'+/-',F8.4,'Pdown= ',F8.4,'+/-',F8.4)
        ENDIF
      ENDIF
      CALL GMEQ(ADUM,POLARS,4,1)
      IF (ISEFF) THEN
        WRITE (NEWIN,140) POLARS
  140 FORMAT ('P ',4F10.4)
      ELSE
        WRITE (NEWIN,141) POLARS
  141 FORMAT ('P UP ',2F10.4,' DOWN',2F10.4)
        ENDIF
      GO TO 5
C
C AFTER READING DATA
    5 IF (RDCOM) GO TO 30
      GO TO 3
C
C  READ ANGLES IF SET
C   70 IF (JK.EQ.3) READ(MESBUF,119) ANG
C      GO TO 3
C
C  READ DATE,TIME AND DVM
   71 IF (JK.NE.3) GO TO 3
      DATE=MESBUF(21:39)
      DVM=MESBUF(54:65)
      GO TO 3
C   28 II=I-3
C      GO TO (25,26,27,42,43,44),II
C
C  POB SCAN
   42 IF (JK.NE.3 .OR. ICOM(II).NE.1) GO TO 3
      CALL POBPRC(M)
      IF (M.LT.0) GO TO 90
      GO TO 3
C
C  HKL SET
   43 READ (MESBUF,118) H
      GO TO 3
C
C  STANDARD REFLECTION
   44 READ (MESBUF,117) H
      IF (JK.NE.3 .OR. ICOM(II).NE.1) GO TO 3
C  SET FOR STANDARD
      M=2
      GO TO (40,41,42),IMTYP+1
C
C  CENTREING
   45 READ (MESBUF(2:),118) H
      IF (JK.NE.3 .OR. ICOM(II).NE.1) GO TO 3
      CALL CENPRC(MC)
      IF (MC.GE.0) GO TO 3
      JK=MC
      GO TO 90
C
C  READ TEMPERATURE
   50 MC=NCHECK(3,NLWRD1+4)
      IF (MC.EQ.0) READ(MESBUF,120) TEMPER
      IF (MC.GE.-1) GO TO 3
      JK=MC
      GO TO 90
C
C  END OF DATA
   91 JK=1
      GO TO 94
   92 JK=2
      GO TO 94
   93 JK=3
      GO TO 94
   90 JK=-(2+JK)
      IF (JK.GT.0) GO TO 94
      WRITE(ITO,125)NSEQ(1)
  125 FORMAT (' Next free sequence number is',I5)
C
C Close any plotter output
C      IF (ICOM(2).NE.0) THEN
C        CALL PGEND3(0)
C      ENDIF
C  WRITE THE UPDATED COMMON DATA FILE
      MESSAG='COMDAT.BIN'
      CALL UPONE(MESSAG,NSYSTM)
      ICOMU=NOPFIL(1023)
      WRITE (ICOMU) ICOMDA,ICOMCH
      CALL CLOFIL(ICOMU)
      STOP
C  FORMATS FOR READING THE DATA AND COMMON DATA
  100 FORMAT (13X,A8,12X,A8)
  101 FORMAT (17X,3I5)
  102 FORMAT (11X,F10.4)
  103 FORMAT (11X,3F10.6)
  104 FORMAT (19X,3F10.4,18X,I5)
  105 FORMAT (16X,3F8.4,I8)
  106 FORMAT (34X,I8)
  107 FORMAT (31X,A8)
  108 FORMAT (27X,A8)
  109 FORMAT (17X,2(F11.8,F16.13))
C  109 FORMAT (17X,4(F11.8)) !DEAD TIME
  110 FORMAT (14X,4F8.4)
  111 FORMAT (23X,3I8)
  112 FORMAT (12X,8F8.2)
C  113 FORMAT (22X,8F8.2)               !SOFTWARE LIMITS
  113 FORMAT (40X,8F8.2)
  114 FORMAT (21X,3F10.4,I5)
  115 FORMAT (18X,A8,11X,I2)
  116 FORMAT (8X,A8)
  117 FORMAT (30X,3F10.5)
  118 FORMAT (11X,3F10.4)
  119 FORMAT (41X,3F8.4)
  120 FORMAT (14X,A8   )
      END
C
C
C
C
      SUBROUTINE BPBPRC(M)
C
C *** BPBPRC modified by PJB Jun 90 to check reproducubility of peak ***
C
CH Processes BPB scans
C
      LOGICAL INTIND,PKSR
      CHARACTER *17 DATIM
      DIMENSION FJCOUN(3,2),FCOUNT(3,2,2),RATE(2,2),VRATE(2,2),PEAK(2)
     &,VPEAK(2),TOTMON(2),KH(3),CALANG(3)
/D3OPC/
/D3OPN/
/IOUNIT/
      COMMON /HEDING/ HEADNG
      CHARACTER*135 HEADNG
      COMMON /NWORDS/NLWORD,NLWRD1,NKEY,NJWORD,NCOM,NPTAB(22)
      CHARACTER*2 ISTAN(3),AWORD(3)*5
      DATA ISTAN/'  ','**',' #'/
      DATA AWORD/'Omega','Theta',' Nu'/
C
C  SAVE INFORMATION ON TYPE
      MM=M
C
C  CLEAR THE COUNT BUFFER
      DO 16 I=1,3
      DO 16 J=1,2
      DO 16 K=1,2
   16 FCOUNT(I,J,K)=0.
C
      PKSR=.FALSE.
      CPSMAX=0
      IF (M.EQ.3) GO TO 20
C
    2 M = NCHECK(3,NLWRD1+1)
      IF (M.LT.-1) GO TO 100
C  END OF DATA OR ANOTHER KEYWORD
      IF (M.EQ.-1) THEN
        IF (PKSR) THEN
          DO 30 I=1,8
          IF (MESBUF(I:I).EQ.' ') GO TO 30
          IF((MESBUF(I:I).LT.'0' .OR.MESBUF(I:I).GT.'9')
     &.AND.MESBUF(I:I).NE.'.'.AND. MESBUF(I:I).NE.'-') GO TO 2
   30     CONTINUE
          READ (MESBUF(75:),1100) DATIM,CPS,DCPS
 1100     FORMAT (A17,2F10.4)
          IF (CPS.GT.CPSMAX) THEN
            CPSMAX=CPS
            DCPSM=DCPS
          ENDIF
        ENDIF
        GO TO 2
      ENDIF
C  TO READ ANOTHER LINE
    1 READ(MESBUF,1000) (ANG(I),I=1,3)
 1000 FORMAT (35X,3F8.4)
C
      M=NCHECK(5,0)
      IF (M.LT.-1) GO TO 100
C  END OF DATA OR ANOTHER KEYWORD
      IF (M.NE.0) THEN
        IF (MESBUF(1:5).EQ.'SHAFT') THEN
          M=NCHECK(5,0)
          IF (M.LT.-1) GO TO 100
        ENDIF
      ENDIF
      PKSR=M.EQ.0
      IF (PKSR) THEN
        CALL GMEQ(ANG,CALANG,3,1)
        GO TO 2
      ENDIF
      IF (MESBUF(1:4).EQ.'D3B:')READ (MESBUF,101) DATE
  101 FORMAT (4X,A19)
      M=NCHECK(5,0)
      IF (MESBUF(1:4).EQ.'O/P:')READ (MESBUF,108) TEMPER,FIELD,DVM
  108 FORMAT (39X,A8,6X,A8,6X,A8)
C
   20 M=NCHECK(3,NLWRD1+2)
      IF (M.LT.-1) RETURN
C  END OF DATA OR ANOTHER KEYWORD
      IF (M.EQ.-1) GO TO 20
C
C  TRY AGAIN
      DO 5 II=1,NBPB
      DO 6 KK=1,3
      K=MOD(KK,2)+1
      M=NCHECK(2,0)
      IF (M.LT.0) GO TO 8
C
C  ERROR
      READ (MESBUF,102) ((FJCOUN(I,J),J=1,2),I=1,3),DATIM
  102 FORMAT (2(F10.1,1X),2(F10.4,1X),2(F10.1,1X),A17)
      DO 9 I=1,3
      DO 9 J=1,2
    9 FCOUNT(I,J,K)=FCOUNT(I,J,K)+FJCOUN(I,J)
    6 CONTINUE
C blank lines are skipped on input
C      M=NCHECK(4,1)
      IF (M.LT.0) GO TO 8
    5 CONTINUE
C
C  NOW GET THE RATES AND THE LOST COUNTS CORRECTION
    8 IF (II .LT.2) GO TO 100
C***
C EXTRA FOR VME RATHER THAN FCU FLIPPER CONTROL
      DO 15 K=1,2
      TOTMON(K)=FCOUNT(3,1,K)+FCOUNT(3,2,K)
      TOTIM=FCOUNT(2,1,K)+FCOUNT(2,2,K)
      IF (TOTIM.EQ.0) GO TO 12
      DO 15 J=1,2
      FCOUNT(3,J,K)=TOTMON(K)*FCOUNT(2,J,K)/TOTIM
   15 CONTINUE
C***
      DO 10 J=1,2
      DO 11 K=1,2
      IF (FCOUNT(2,J,K).EQ.0) GO TO 12
      IF (FCOUNT(3,J,K).EQ.0) GO TO 12
      TRATE=FCOUNT(1,J,K)/FCOUNT(2,J,K)
      VTRATE = TRATE/FCOUNT(2,J,K)
      CALL LSTCTS(TRATE,VCRATE,TMORTS)
      IF (TRATE .LT. 0 .OR. TRATE .GT.2.) GO TO 14
      RATE(J,K)= (FCOUNT(1,J,K)/FCOUNT(3,J,K))*TRATE
C   11 VRATE(J,K)=(RATE(J,K)/FCOUNT(3,J,K))*VTRATE
   11 VRATE(J,K)=
     &(VTRATE*TRATE**2+VCRATE)*(FCOUNT(2,J,K)/FCOUNT(3,J,K))**2
C
      PEAK(J)=RATE(J,1)-RATE(J,2)
      VPEAK(J)=VRATE(J,1)+VRATE(J,2)
      IF (PEAK(J).LE. SQRT(VPEAK(J))) GO TO 13
   10 CONTINUE
      R = PEAK(1)/PEAK(2)
C PART COMING FROM STATISTICAL ERROR IN DETECTOR COUNTS
      VRONR1= (VPEAK(1)/(PEAK(1)**2)) + (VPEAK(2)/(PEAK(2)**2))
C***
C PART COMING FROM STATISTICAL ERROR IN MONITOR COUNTS
      VRONR2= (1./TOTMON(1)+1./TOTMON(2))*
     &(RATE(1,1)/PEAK(1)-RATE(2,1)/PEAK(2))**2
C***
      DR=R*SQRT(VRONR1+VRONR2)
      HTPK=(PEAK(1)+PEAK(2))*(FCOUNT(3,1,1)+FCOUNT(3,2,1))
     &/(2.*(FCOUNT(2,1,1)+FCOUNT(2,2,1)))
      BKG=(RATE(1,2)+RATE(2,2))*(FCOUNT(3,1,2)+FCOUNT(3,2,2))
     &/(2.*(FCOUNT(2,1,2)+FCOUNT(2,2,2)))
      IF (CPSMAX.NE.0) THEN
        CPSMAX=CPSMAX-BKG
        FEROR=DCPSM/CPSMAX
        IF (FEROR.LT..2)FEROR=.2
        IF (ABS(CPSMAX-HTPK)/CPSMAX .GT. FEROR) THEN
          CALL TESTP(LPT,LCOUNT,1,HEADNG,2)
          WRITE (LPT,1101) CPSMAX,HTPK
 1101     FORMAT (' *** Warning peak count not reproduced. ',
     &F7.0,'in peak search, ',F7.0,' in BPB scan.')
        ENDIF
        DO 31 I=1,3
        IF (ABS(ANG(I)-CALANG(I)) .GT. .5) THEN
          CALL TESTP(LPT,LCOUNT,1,HEADNG,2)
          WRITE (LPT,1102) AWORD(I),CALANG(I),ANG(I)
 1102     FORMAT(' *** Warning observed and calculated angles ',A5,
     &' differ by more than 0.5 degrees: calculated ',F8.2,
     &' observed ',F8.2)
        ENDIF
   31   CONTINUE
      ENDIF
C
      CALL TESTP(LPT,LCOUNT,1,HEADNG,2)
      IF (INTIND(H,KH)) THEN
        WRITE (LPT,104) NSEQ(1),ISTAN(MM),KH,ANG,R,DR,HTPK,BKG,
     &TEMPER,FIELD,DVM,DATE
  104   FORMAT (1X,I4,A2,3(I5,1X),3F8.2,2F10.6,F8.1,1X,F6.1,1X,
     &3(A8,1X),A19)
        WRITE (LUNO,105) NSEQ(1),KH,ANG,R,DR,HTPK,TEMPER,DATE
  105   FORMAT (4I5,3F8.2,2F10.6,F10.1,2X,A8,3X,A19)
      ELSE
        WRITE (LPT,114) NSEQ(1),ISTAN(MM),H,ANG,R,DR,HTPK,BKG,
     &TEMPER,FIELD,DVM,DATE
  114   FORMAT (1X,I4,A2,3F6.2,3F8.2,2F10.6,F8.1,1X,F6.1,1X,
     &3(A8,1X),A19)
        WRITE (LUNO,115) NSEQ(1),H,ANG,R,DR,HTPK,TEMPER,DATE
  115   FORMAT (I5,3F6.2,3F8.2,2F10.6,F10.1,2X,A8,3X,A19)
      ENDIF
      NSEQ(1) = NSEQ(1)+1
      GO TO 100
C
C  ERRORS
C  DATA RUN OUT
C    3 M=-1
C      GO TO 100
C
C  NO DATA
   12 CALL TESTP(LPT,LCOUNT,1,HEADNG,2)
      WRITE (LPT,106) KH
  106 FORMAT (10X,3I5,'   Zero time for measurement')
      GO TO 100
C
C  R NOT SIGNIFICANT
   13 CALL TESTP(LPT,LCOUNT,1,HEADNG,2)
      WRITE (LPT,107) KH
  107 FORMAT (10X,3I5,'   R less than its error')
      GO TO 100
C
C  LOST COUNTS TOO BIG
   14 CALL TESTP(LPT,LCOUNT,1,HEADNG,2)
      WRITE (LPT,109) KH
  109 FORMAT (10X,3I5,'  Detector saturated')
 100  RETURN
      END
C
C
C
C
      SUBROUTINE POBPRC(M)
C
C *** POBPRC BY PJB OCT 88 ***
C
CH POB processing not implemented
/IOUNIT/
C
      CALL MESS(LPT,0,'P-O-B SCAN PROCESSING NOT IMPLEMENTED')
      RETURN
      END
C
C
C
C
      SUBROUTINE AISPRC(M,LUNS)
C
C *** AISPRC BY PJB OCT 88 ***
C
CH crude processing of angle scans
C
      CHARACTER*8 ANGNAM,TITLE*80
      DIMENSION XANG(201),COUNT(201),VCOUNT(201),R(201),DR(201)
      DIMENSION FCOUNT(3,2),RATE(2),VRATE(2),KH(3)
/D3OPC/
/D3OPN/
/IOUNIT/
      COMMON /HEDING/ HEADNG
      CHARACTER*135 HEADNG
      COMMON /NWORDS/NLWORD,NLWRD1,NKEY,NJWORD,NCOM,NPTAB(22)
/SCRACH/
C
C     LUNS=LUNS
   19 M=NCHECK(5,0)
      IF (M.LT.-1)GO TO 100
      IF (M.NE.0) GO TO 19
C  END OF DATA OR ANOTHER KEYWORD
      READ (MESBUF,101) ANGNAM
  101 FORMAT (A8)
C
C open output file if required
      IF (LUN(2).LE.0) THEN
        CALL TESTP(LPT,LCOUNT,1,HEADNG,2)
        I=INDEX(OP2,'.')-1
        MESSAG=OP2(1:I)
        NAMFIL='.AIS'
        IF (LUN(2).LT.0) THEN
          LUN(2)=NOPFIL(124)
        ELSE
          LUN(2)=NOPFIL(122)
        ENDIF
      ENDIF
C
C WHICH ANGLE IS SCANNED?
      IANGLE=1
      DO 40 I=1,3
      IF (AIS(I).EQ.0.) GO TO 40
      IANGLE=I
      GO TO 41
   40 CONTINUE
   41 IF (IAIS.LT.0) THEN
        NSTEP=1-IAIS
      ELSE
        NSTEP=2*IAIS+1
      ENDIF
      CNTMAX=0
      WRITE (TITLE,120) IP1(1:6),NSEQ(2),H,TEMPER
  120 FORMAT (' File: ',A6,' Scan:',I2.2,' hkl =',3F8.3,2X,
     &'T =',A8)
      l=LENGT(TITLE)+1
      WRITE (TITLE(L:),122) ANGNAM
  122 FORMAT (' Scan in ',A6)
      WRITE (LUN(2),121) TITLE
      WRITE (LPT,121) TITLE
  121 FORMAT (1X,A80)
      TITLE(L:)=' '
      DO 21 ISTEP=1,NSTEP
   20 M=NCHECK(2,0)
      IF (M.LT.-1) GO TO 100
C  END OF DATA OR ANOTHER KEYWORD
      IF (M.EQ.-1) GO TO 20
      READ (MESBUF,102) ANGL,((FCOUNT(I,J),J=1,2),I=1,3)
  102 FORMAT (F8.2,2(F10.1,1X),2(F10.4,1X),F10.1,1X,F10.1)
      XANG(ISTEP)=ANGL
C  NOW GET THE RATES AND THE LOST COUNTS CORRECTION
      DO 10 J=1,2
      IF (FCOUNT(2,J).EQ.0) GO TO 12
      IF (FCOUNT(3,J).EQ.0) GO TO 12
      TRATE=FCOUNT(1,J)/FCOUNT(2,J)
      VTRATE = TRATE/FCOUNT(2,J)
      CALL LSTCTS(TRATE,VTRATE,TMORTS)
      IF (TRATE .LT. 0 .OR. TRATE .GT.2.) GO TO 14
      RATE(J)= (FCOUNT(1,J)/FCOUNT(3,J))*TRATE
      VRATE(J)=(RATE(J)/FCOUNT(3,J))*VTRATE
   10 CONTINUE
      R(ISTEP)=RATE(1)/RATE(2)
      DR(ISTEP)=R(ISTEP)*SQRT((VRATE(1)/RATE(1))**2
     &+(VRATE(2)/RATE(2))**2)
C      WRITE (LPT,110) ANGL,((RATE(I),VRATE(I)),I=1,2),R(ISTEP),DR(ISTEP)
C the previous line won't compile under SG UNIX system 5.2 !!
      WRITE (LPT,110) ANGL,RATE(1),VRATE(1),RATE(2),VRATE(2)
     &,R(ISTEP),DR(ISTEP)
  110 FORMAT (F8.2,2X,4F10.1,2F10.4)
      COUNT(ISTEP)=(RATE(1)+RATE(2))
      VCOUNT(ISTEP)=(VRATE(1)+VRATE(2))
      IF (COUNT(ISTEP).GT.CNTMAX) CNTMAX=COUNT(ISTEP)
      LAST=ISTEP
   21 CONTINUE
C SCALE ALL TO CPS FROM MONITOR
      RMON=(FCOUNT(3,1)+FCOUNT(3,2))/(FCOUNT(2,1)+FCOUNT(2,2))
      CNTMAX=CNTMAX*RMON
      CALL GMSCA(COUNT,COUNT,RMON,LAST,1)
      R2=RMON*RMON
      SCAL=1./RMON
      CALL GMSCA(VCOUNT,VCOUNT,R2,LAST,1)
C      DO 44 IDEV=1,2
C      CALL PGSLCT(IDEV,IOLD,IER)
C      CALL PGENV(XANG(1),XANG(LAST),0.,CNTMAX,0,2)
C      CALL PGLABEL(ANGNAM,'Count Rate (n/sec)',TITLE)
C      DO 43 I=1,LAST
C      CALL PGPOINT(1,XANG(I),COUNT(I),17)
C      SIG=SQRT(VCOUNT(I))
C      CALL PGERRY(1,XANG(I),COUNT(I),COUNT(I)+SIG,COUNT(I)-SIG,0.0)
C      IF (IDEV.EQ.1) WRITE (LUN(2),124) I,XANG(I),COUNT(I),SIG
C  124 FORMAT (I4,F8.2,2F12.4)
C   43 CONTINUE
C   44 CONTINUE
      NSEQ(2)=NSEQ(2)+1
      GO TO 100
C
C  NO DATA
   12 CALL TESTP(LPT,LCOUNT,1,HEADNG,2)
      WRITE (LPT,106) KH
  106 FORMAT (10X,3I5,'   Zero time for measurement')
      GO TO 100
C
C  LOST COUNTS TOO BIG
   14 CALL TESTP(LPT,LCOUNT,1,HEADNG,2)
      WRITE (LPT,109) KH
  109 FORMAT (10X,3I5,'  Detector saturated')
C
  100 RETURN
      END
C
C
C
C
      SUBROUTINE CENPRC(M)
C
C *** CENPRC by PJB 1990 ***
C
CH Procceses centreing commands
C
C
      LOGICAL INTIND
      CHARACTER*10 FILNOM
      DIMENSION K(3)
/D3OPC/
/D3OPN/
      COMMON /HEDING/ HEADNG
      CHARACTER*135 HEADNG
/IOUNIT/
      COMMON /NWORDS/NLWORD,NLWRD1,NKEY,NJWORD,NCOM,NPTAB(22)
/SCRACH/
      IF (LUN(3).LE.0) THEN
        CALL TESTP(LPT,LCOUNT,1,HEADNG,2)
        IF (LUN(3).EQ.0) THEN
          MESSAG='File of centered angles'
          NAMFIL='.CEN'
          LUN(3)=NOPFIL(112)
          OP3=FILNOM(LUN(3))
        ELSE
          MESSAG=OP3
          LUN(3)=NOPFIL(24)
        ENDIF
      ENDIF
C
      CALL TESTP(LPT,LCOUNT,1,HEADNG,2)
    1 M=NCHECK(3,NLWRD1+3)
      IF (M.LT.-1) THEN
        WRITE (LPT,14) H,'not Centred'
   14   FORMAT (7X,3F6.2,22X,A11)
        GO TO 100
      ENDIF
      IF (M.EQ.-1) GO TO 1
      READ (MESBUF,10)H,ANG
   10 FORMAT (21X,3F8.4,3F8.2)
      WRITE (LUN(3),11) H,ANG
   11 FORMAT (3F10.4,3F8.2)
      IF (INTIND(H,K)) THEN
        WRITE (LPT,12)K,ANG,'  Centred'
   12   FORMAT (7X,3(I5,1X),3F8.2,A9)
      ELSE
        WRITE (LPT,13)H,ANG,'  Centred'
   13   FORMAT (7X,3F6.2,3F8.2,A9)
      ENDIF
  100 RETURN
      END
C
C
C
C
      FUNCTION NCHECK(M,LL)
C
C *** NCHECK BY PJB OCT 88 ***
C
CH The fundamental data input routine for D3 data
C
      CHARACTER*5 WARN(1)
      COMMON /ALWORD/LWORD(27),KEY(6),JWORD(3)
      CHARACTER*5 LWORD,KEY,JWORD
/D3OPC/
/D3OPN/
      COMMON /HEDING/ HEADNG
      CHARACTER*135 HEADNG
/IOUNIT/
      COMMON /NWORDS/NLWORD,NLWRD1,NKEY,NJWORD,NCOM,NPTAB(22)
/SCRACH/
C
      DATA NWARN,WARN/1,'TIMEO'/
C
      L=LL
      NCHECK=0
C
C  SECTION TO GET A NEW FILE NAME
    1 IF (IEND) THEN
        LDIR=LENGT(DATDIR)
        MESSAG=DATDIR(1:LDIR)//IP1
      ENDIF
    2 IF (IEND) THEN
        NAMFIL='.opf'
        LUNI=NOPFIL(131)
        IF (LUNI.LE.0) THEN
          NCHECK=-2
          CALL TESTP(LPT,LCOUNT,1,HEADNG,2)
          WRITE (LPT,13) IP1(1:6)
   13     FORMAT (' File ',A6,' not found in the data-base')
          IP2=' '
          GO TO 100
        ENDIF
        IPOLD=IP1
        WRITE (LPT,16) IP1(1:6)
        WRITE (ITO,16) IP1(1:6)
   16   FORMAT (' Data now being read from ',A6)
        IEND=.FALSE.
C RESET SCAN SEQUENCE NUMBER
        NSEQ(2)=1
C  READ HEADER; DO NOTHING WITH IT FOR NOW
        READ (LUNI,1000) MESBUF
C TO READ THE END OF FILES ALREADY PARTIALLY PROCESSED
        IF (OLDFIL) THEN
          OLDFIL=.FALSE.
          DO 4 L=1,LINORD
          READ (LUNI,1000,END=51)
    4     CONTINUE
          LINENO=LINORD
        ELSE
          LINENO=0
          LINORD=0
        ENDIF
      ENDIF
C
C  READ NEXT RECORD
      READ (LUNI,1000,END=52) MESBUF
      LINENO=LINENO+1
C turn any lower case chars to upper case
      CALL UPONE(MESBUF,1)
 1000 FORMAT (A125)
C
C  IGNORE BLANK LINES
      IF (LENGT(MESBUF).LE.1) GO TO 1
C
C  SEARCH FOR KEYWORD
      I=NCFIND(MESBUF(1:5),KEY,NKEY)
      IF (I .EQ. 0) GO TO (1,20,30,40,50),M
C IGNORE WARNING TYPE MESSAGES  WHEN LOOKING FOR KEYWORD
      IF (I.GE.4 .AND. (M.EQ.1.OR.M.EQ.3)) GO TO 1
C
      NCHECK=I
      IF (M.NE.1) THEN
C
C  CHECK FOR SERIOUS WARNINGS, SKIP IF NOT SERIOUS
        IF (I.EQ.5) THEN
          IF (NCFIND(MESBUF(10:14),WARN,NWARN).EQ.0) GO TO 1
        ENDIF
        NCHECK=-2-I
C  KEYWORD FOUND WHEN NOT LOOKING FOR ONE, SET ERROR
      ENDIF
      GO TO 100
C
C  DATA RUN OUT
   51 LINORD=0
   52 IEND=.TRUE.
      IF (IP2.NE.' ') THEN
        IF (IP1 .EQ. IP2) THEN
          NCHECK=-2
          IP2=' '
        ENDIF
      ENDIF
      LDIR=LENGT(DATDIR)
      MESSAG=DATDIR(1:LDIR)//IP1
      CALL INCREM(IP1,MESSAG)
      CALL CLOFIL(LUNI)
      IF (NCHECK .EQ.-2) GO TO 100
      CALL TESTP(LPT,LCOUNT,1,HEADNG,2)
      GO TO 2
C
C  MAKE SURE NO NON-NUMERICAL CHARACTERS
   20 DO 21 I=1,5
      IF (MESBUF(I:I).EQ.' ' .OR. MESBUF(I:I).EQ.'-') GO TO 21
      IF (NDIGIT(MESBUF(I:I)) .EQ. -1) GO TO 22
   21 CONTINUE
      GO TO 100
   22 CALL TESTP(LPT,LCOUNT,3,HEADNG,2)
      LCOUNT=LCOUNT+2
      WRITE (LPT,12) MESBUF(1:20)
   12 FORMAT ('0 Characters "',A20,'" Read when expecting a number'/)
      NCHECK=-1
      GO TO 100
C
C  CHECK THE FIRST 5 CHARACTERS IN A LINE
   30 IF (MESBUF(1:5).NE. LWORD(L))NCHECK=-1
      GO TO 100
C
C  ADVANCE BY LL LINES
   40 L=L-1
      IF (L.EQ.0) GO TO 100
      GO TO 1
C
C  ERROR IN SPECIFICATION OF RECORD
C   90 CALL MESS(ITO,0,'Error in specification of record; '//MESSAG)
C      CALL INFILE
C      GO TO 1
C
   50 IF (NCFIND(MESBUF(4:9),JWORD,NJWORD).EQ.0) NCHECK=-1
  100 RETURN
      END
C
C
C
C
      SUBROUTINE INFILE
C
      CHARACTER*3 CYCLE
      LOGICAL SAYS
/D3OPC/
/GLOBAL/
/SCRACH/
C
      CALL GETENV('D3DATA',DATDIR)
      L=LENGT(DATDIR)
      IF (L.NE.0) THEN
        CALL ASK('Data will be read from directory '//DATDIR(1:L)//
     &' OK? (Y/N)')
        IF (SAYS('Y')) GO TO 2
      ENDIF
      CALL GETENV('ILLDATA',DATDIR)
      L=LENGT(DATDIR)
      IF (L.EQ.0) THEN
        DATDIR='/usr/illdata'
        L=LENGT(DATDIR)
      ENDIF
        CALL ASK('Data base is '//DATDIR(1:L)//
     &' OK? (Y/N)')
        IF (SAYS('N')) CALL MESS(ITO,0,' Please set the environment'//
     &' variable ILLDATA to the correct path for the ill data base')
    1 CALL ASK('Give cycle number (RETURN gives current cycle')
      CALL RDINTG(ICYC,1,IPT,8,IER)
      IF (IER .EQ.100) THEN
        ICYC=0
        DATDIR=DATDIR(1:L)//'/data/d3/'
      ELSE
        IF (IER.NE.0) GO TO 1
        WRITE (CYCLE,10) ICYC
   10 FORMAT (I3)
        DATDIR=DATDIR(1:L)//'/'//CYCLE//'/d3/'
      ENDIF
    2 CALL ASK('Give name of first and (last) files to process')
      CALL RDWORD(IP1,LEN,1,IPT,11,0,IER)
      IF (IER.NE.0) GO TO 2
      CALL RDWORD(IP2,LEN,IPT,IPT,30,0,IER)
      IF (IER.EQ.100) THEN
        IP2=' '
      ELSE
        IF (IER.NE.0) GO TO 2
      ENDIF
      CALL UPONE(IP1,NSYSTM)
      CALL UPONE(IP2,NSYSTM)
      RETURN
      END
C
C
C
C
      BLOCK DATA PAGEHD
      COMMON /ALWORD/LWORD(27),KEY(6),JWORD(3)
      CHARACTER*5 LWORD,KEY,JWORD
      COMMON /NWORDS/NLWORD,NLWRD1,NKEY,NJWORD,NCOM,NPTAB(22)
      COMMON /HEDING/ HEADNG
      CHARACTER*135 HEADNG
      DATA HEADNG/' (''0Seq No       h    k    l   Omega  2Theta     Nu
     &R        dR     Pk cps Bg cps    Temp    Field   DVM
     &Date      Time''/)'/
      DATA LWORD/'SAMPL','BLIND','GEOME','WAVEL','MONOC','FILTE',
     &'UB MA','REFLE','ANGLE','B-P-B','DEAD ','POLAR','P-O-B',
     &' HKL ','HKL M','STAND','DATE ','PHOTO','SET B','SOFTW',
     &'CENTR','CENTR','READ ','SHAFT','  COU','***CE','TEMPE'/
      DATA JWORD/'OMEGA','GAMMA','   NU'/
      DATA KEY/'COMMO','DATA:','ORDER','COMMA','WARNI','DTI: '/
C  NLWORD IS NUMBER OF 5 LETTER STRINGS TO RECOGNISE AS DATA OF WHICH
C  NLWRD1 FOLLOW A data/order-WORD
C  NKEY NUMBER OF SPECIAL KEY WORDS
C  NJWORD NUMBER OF SHAFT ANGLE NAMES
C  NCOM NUMBER OF ITEMS TO BE READ FROM COMMON DATA (IST NCOM OF LWORD)
      DATA NLWORD,NLWRD1,NKEY,NJWORD,NCOM/27,23,6,3,12/
C TABLE NPTAB ASSOCIATES THE ORDERS WITH THE DATA WORDS
      DATA NPTAB/0,0,0,0,0,0,0,0,2,3,0,0,4,5,1,6,0,0,0,0,7,8/
      END
C
C
C
C
C LEVEL 50      PROGRAM EXTCAL
      PROGRAM EXTCAL
C
C *** EXTCAL updated by PJB  18-Nov-1997 ***
C
C ******************************************************************************
C
C                            E X T C A L
C
C  PROGRAM TO WRITE THE GOBS FILE FOR LSQ WITH EXTINCTION
C LOOKS FOR "I MULx (x=P,H,K OR L) N" WITH N > 0 IF FLOATING INDICES
C
C ******************************************************************************
CC 7D
CH Calculates extinction coefficients and writes a data file for least squares
C
CD Reads one or more files containing reflection indices, structure factors
CD and their standard deviations. Each file may correspond to data measured
CD on a different scale or with a different wavelength. Using the given
CD wavelength, the program calculates the 4 coefficients involved in
CD the Becker Coppens extinction correction and writes a single file
CD containing the original hkl's stucture factors and esd'd followed by the 4
CD coefficients and finally a scaling zone number which is incremented by 1
CD for each input file given. In calculating CEXT(1) the program assumes
CD a constant path length of 2mm.
C
CI The crystal data file which must contain:
CI     S cards giving the symmetry
CI     A  C card with the cell dimensions
CI     An E card indicating the type of extinction cerrection required
CI If the indices are non-integral
CI    I cards giving multipliers for the indices (MULx x=P,H,K or L),
CI       or a Q PROP card (as used in ARRNGE)
CI
CI The data files containing lists of h, k, l, Fobs, esd(Fobs)
CI in format (3I5,2F10) or (3F8.3,2F10) for floating indices, these
CI are the formats written by ABSMSF.
C
CO The usual listing file reporting what was read from the CDF
CO An output file giving: h, k, l, Fobs, esd(Fobs), CEXT(i),i=1,4, iscale,
CO FORMAT (3I5,6F10.4,I5) or (3F8.3,6F10.4,I5) ie. suitable for input to
CO least squares programs  in MODE 5 or 8.
C
CR On runung the program the user is asked for the name of the crystal data
CR file and then asked to choose a name for the output file. Following
CR that, for each input file, the user must give its name (default
CR extension .sf), the measurement wavelength and an optional scale
CR factor. Replying to this question with just "RETURN" terminates
CR the program.
C
CN The scale factor allows data measured on very different scales to be
CN brought to approximately the same level. Useful if using unit weights in
CN least squares.
CN
CN Note that this program does not deal with path dependent
CN extinction. AVEXAR should be used if the path dependence is thought
CN to be important.
C
      DIMENSION K(3),H(3)
      CHARACTER*40 FILNAM
      LOGICAL LATABS
/EXTN/
/IOUNIT/
/SCRACH/
C
      CALL PREFIN('EXTCAL')
      CALL SYMOP
      CALL RECIP
      CALL EXTINC(1,0.)
      CALL INPUTI
      CALL ICDFMT(INC,ITEMS)
      NAMFIL='.SF'
      LUNO=NOPFIL(102)
      IS=0
C
   9  CALL ASK('Give input file name, wavelength and scale (RETURN '//
     & 'if no more)')
      CALL RDWORD(FILNAM,LEN,1,IE,41,-1,IER)
      IF (IER.NE.0) THEN
        IF (IER.EQ.100) GO TO 100
        CALL MESS(ITO,0,'Illegal file name')
        GO TO 9
      ENDIF
C
      CALL RDREAL(ALAMB,IE,I,80,IER)
      IF (IER.NE.0) GO TO 9
      CALL RDREAL(SCALE,I,IE,80,IER)
      IF (IER.NE.0) SCALE=1.
      MESSAG=FILNAM
      NAMFIL='.SF'
      LUN=NOPFIL(131)
      IF (LUN.LE.0) GO TO 9
      WRITE (LPT,17) ALAMB,NAMFIL,SCALE
   17 FORMAT (/' Data measured with lambda =',F7.3,' read from ',A10,
     & ' and multiplied by',F8.3/)
      IS = IS+1
   3  IF (INC .EQ. 0)READ (LUN,13,END=9) K,FOBS,DF
      IF (INC .EQ. 1)READ (LUN,133,END=9) H,FOBS,DF
   13 FORMAT (3I5,3F10.4)
 133  FORMAT (3F8.3,3F10.4)
      IF (INC .EQ. 0) THEN
        CALL INDFLO(H,K)
        IF (LATABS(H)) GO TO 3
      ENDIF
      FOBS = FOBS/SCALE
      DF = DF/SCALE
      TM = 2.0
      CALL EXTPAR(H,ALAMB,TM)
      IF (INC .EQ. 0) WRITE (LPT,15) K,FOBS,DF,(CEXT(I),I=1,4),IS
      IF (INC .EQ. 1) WRITE (LPT,155) H,FOBS,DF,(CEXT(I),I=1,4),IS
   15 FORMAT (1X,3I5,6F10.4,I5)
 155  FORMAT (1X,3F8.3,6F10.4,I5)
      IF (INC .EQ. 0) WRITE (LUNO,16) K,FOBS,DF,(CEXT(I),I=1,4),IS
      IF (INC .EQ. 1) WRITE (LUNO,166) H,FOBS,DF,(CEXT(I),I=1,4),IS
   16 FORMAT (3I5,6F10.4,I5)
 166  FORMAT (3F8.3,6F10.4,I5)
      GO TO 3
C
  100 STOP
      END
C
C
C
C
C LEVEL 50      PROGRAM FORFAC
      PROGRAM FORFAC
C
C *** FORFAC updated by PJB for change in RADFUN C139 July 2005 ***
C
C ******************************************************************************
C
C                             F O R F A C
C
C TO CALCULATE FORM-FACTORS AND RADIAL DENSITIES FROM SLATER TYPE WAVE-FUNCTIONS
C
C ******************************************************************************
C
CC 4D
CH Calculates form factors and radial electron densities from Slater type radial
CH wave-functions
C
CD Reads sets of Slater-type radial wave-functions from W RADF cards and
CD calculates the radial electron densities and the corresponding form factor
CD integrals <j0>, <j2> and <j4>. The calculated factors are written out in a form suitable for
CD form suitable for inclusion in a crystal data file.
C
CI The crystal data file should contain:
CI      An F card with FTYP = 5  for each atom whose form factor is required
CI      W <atom> RADF cards giving the wave-functions for each of the <atom>
CI      names on the F cards.
C
CO The usual listing file which reports the data read. The messages about the
CO absence of symmetry operators etc. may be ignored.
CO For each <atom>
CO the terms in the radial wave-function are listed followed by a table giving
CO \$\qquad r\quad u(r) \quad u^2(r) \quad \int _0^ru^2(r)dr\$.
CO A file containing the form factors <j0>, <j2> and <j4> for each atom
CO written as F cards FTYP 3, ie a table containing pairs of \$\sinth\$ and
CO form-factor values. The names given to the form factors are the first two
CO letters of the atom name given on the W RADF cards plus J0, J2, or J4 as
CO appropriate. The tables extend from \$\sinth = 0 \$  to 1.6 \$\inA\$
C
CN Note that the number with which the form factor names end is not strictly
CN in conformity with the CCSL labelling convention. They may need to be
CN changed before inclusion in a complete crystal data file.
C
CR On running the program the user need only give the name of the crystal
CR data file and a name for the file on which the F cards should be written.
C
      CHARACTER*4 NAME,WORD
      DIMENSION FOF(22,3),SK(22)
/ATNAM/
/CARDRC/
/FONAM/
/FORMDA/
/IOUNIT/
/POSNS/
/RADINT/
/SCRACH/
C
      CALL PREFIN('FORFAC')
      CALL SETFOR
      ICARD='File for F card output'
CS ILL      NAMFIL='.CRY'
CS RAL      NAMFIL='.CCL'
      LPT1=NOPFIL(112)
      NATOM=NUMFNM
      DO 30 NF=1,NATOM
      ATNAME(NF)=FONAME(NF)
   30 CONTINUE
C
C     NOW START TO READ W CARDS
      INREAD(23)=-IABS(INREAD(23))
      ID=IABS(INREAD(23))
      NCARD=ICDNO(23)
      IF (NCARD.EQ.0) THEN
        CALL ERRMES(1,1,
     & 'No W cards read; W-RADF cards needed for FORFAC')
        GO TO 100
      ENDIF
C  INITIALISE
      IEND=-1
      CALL RADFUN(IEND,IEND)
C
      DO 25 NC=1,NCARD
      CALL INPUTW(IAT,WORD,ID,IPT)
      IF (WORD.EQ.'RADF') CALL RADFUN(IAT,IPT)
   25 CONTINUE
C
C  ALL RADF CARDS READ, CHECK THEM
      DO 10 JAT=1,NATOM
C126 IAT is the IRADF value for JAT
C139 IRADF contains -JAT until radfun(IAT,0) obeyed once
      IAT=NFIND(-JAT,IRADF,NRADF)
      ASTEP=0.628318
      BSTEP=0.05
      ILIM=11
      RSTEP=.05
      RLIM=1.0
      R=0.
      NAME=ATNAME(JAT)
      CALL MESS(LPT,1,'*********')
      CALL MESS(LPT,0,'*  '//NAME//' *')
      CALL MESS(LPT,0,'*********')
      CALL RADFUN(IAT,0)
      IF (IERR.NE.0)  CALL ERRMES(0,0,'in FORFAC')
C
      IMAX=NTERMS(IAT)
      NAME=ATNAME(IAT)
      CALL MESS(LPT,1,'Radial Wave Function for  '//NAME)
      CALL MESS(LPT,2,'     r        U(R)        U2(r)     Rad.Int.')
      DO 20 KK=1,2
    6 U = 0.
      U2=0.
      RINT=0.
      DO 77 I = 1,IMAX
      RXX=R*FF(2,I,IAT)
      IF (RXX.GT.50.) GO TO 77
      IF (R.NE.0) U=U+FF(1,I,IAT)*R**N(I,IAT)*EXP(-RXX)
      DO 7 J = 1,IMAX
      IX = N(I,IAT)+N(J,IAT)
      IXX=IX+2
      XI=FF(2,I,IAT)+FF(2,J,IAT)
      RX=R*XI
      IF (RX.GT.50.) GO TO 7
      AMP=FF(1,I,IAT)*FF(1,J,IAT)*EXP(-RX)
      SUM=FACT(IXX)/(XI**(IXX+1))
      TERM=SUM
      IF (R.EQ.0.) GO TO 9
      DO 8 L=1,IXX
      TERM=TERM*(RX)/FLOAT(L)
    8 SUM=SUM+TERM
    9 RINT=RINT+AMP*SUM
      IF (R.NE.0.) GO TO 21
      IF (IX.EQ.0) U2=U2+AMP
      GO TO 7
   21 U2 = U2 + AMP*(R**IX)
   7  CONTINUE
   77 CONTINUE
      RINT=1.-RINT
      WRITE(LPT,2002) R,U,U2,RINT
2002  FORMAT (1X,F7.2,3(2X,F10.5))
      R=R+RSTEP
      IF (R.LT.RLIM) GO TO 6
      RLIM=3.*RLIM
   20 RSTEP=2.*RSTEP
C
      CALL MESS(LPT,1,'   Form Factors for '//NAME)
      CALL MESS(LPT,2,'   SinTh/Lam   <j0>      <j2>      <j4>')
      FOF(1,1)=1.0
      FOF(1,2)=0.0
      FOF(1,3)=0.0
      I=1
      AK=0.
      SK(I)=0.
      GO TO 23
    3 AK=AK+ASTEP
      SK(I)=SK(I-1)+BSTEP
      DO 4 J = 1,3
      L = 2*(J-1)
    4 FOF(I,J) = FORMFC(AK,L,0,IAT)
   23 WRITE(LPT,2005) SK(I),(FOF(I,J),J=1,3)
2005  FORMAT (F10.2,2X,3F10.5)
      I=I+1
      IF (I.LE.ILIM) GO TO 3
      BSTEP=2.*BSTEP
      ASTEP=2.*ASTEP
      IF (ILIM.EQ.22) GO TO 22
      ILIM=22
      GO TO 3
   22 DO 5 J = 1,3
      L = 2*(J-1)
      II=0
      DO 11 K=1,4
      WRITE (LPT1,2010)  NAME(1:2),L,(SK(II+I),FOF(II+I,J),I=1,5)
2010  FORMAT ('F ',A2,'J',1I1,4X,'3',5(F5.2,F8.4))
   11 II=II+5
   5  WRITE (LPT1,2010)  NAME(1:2),L,(SK(II+I),FOF(II+I,J),I=1,2)
      CALL NEWPAG(LPT)
   10 CONTINUE
 100  STOP
      END
C
C
C
C
C LEVEL 50      PROGRAM FORFIG
      PROGRAM FORFIG
C
C *** FORFIG corrected by PJB Mar 87 ***
C
C *****************************************************************************
C
C                            F O R F I G
C
C  NEW FOURIER PROGRAM TO DRAW A MAP WITH ATOM POSITIONS PLOTTED.  SIMILAR TO
C FOURPL, BUT INSTEAD OF A CONTOUR LIST ATOM POSITIONS ARE INDICATED BY SYMBOLS,
C AND A KEY TO THE SYMBOLS IS GIVEN
C
C *****************************************************************************
C
CC 5D
CH General fourier inversion program showing atom positions
C
CD A general program to calculate Fourier sums. It allows fourier sections,
CD projections, general plane sections and error maps to be calculated.
CD Facilities are provided for saving and restoring maps to and from file. The
CD output can be recorded by printer and/or plotted as a contoured map.
CD This program is similar to FOURPL except that the atom positions are marked
CD on the maps and identified by their symbols in a key which is drawn in place
CD of the list of contours
CD The program may be loaded with different graphics libraries to obtain output
CD for different graphics output devices.
C
CI The crystal data file must contain:
CI      A cards giving the atomic positions
CI      A C card with the cell dimensions
CI      S cards giving the symmetry
CI      M cards defining which maps to draw and how they are defined
CI        (see the CCSL users' manual)
CI A file containing the data from which the Fourier sum is to be calculated
CI This is in general supposed to contain h, k, l, F1, F2, F3 ... in
CI format (3I5,nF10.5). The number of F's to be read and ther interpretation
CI depends on the values of FTYP and DTYP read from the M cards. The range of
CI hkl must span the asymmetric unit of reciprocal space and not more.
CI If there is an M GET card: a file containing a previously "saved" map.
CI If there is an M READ card: a file containing a previously dumped map.
C
CO The usual listing file reporting the data which have been read. If there is
CO an M PRIN card this file also contains the values of the fourier summation
CO at the points requested. These numbers are rounded to integers so the
CO scale (given by M SCAL) must be chosen to ensure they are not all zero.
CO
CO If there is an M PLOT card: graphical output whose form depends upon the
CO graphical library being used.
CO
CO If there is an M SAVE card: An output file containing the "saved" maps.
C
CR Ensure that the terminal from which the program is to be run is appropriate
CR to the graphics library with which the program was linked.
CR On running the program the user is asked for the name of the crystal data
CR file, and the name of the file containing data for the Fourier
CR coefficients (reflection data). Any further dialogue is driven by the
CR graphics library and is usually confined to an enquiry as to whether a
CR hard copy of a map is required. If no contour values are given on M cards
CR and an M PLOT card is present, the program will ask for them interactively.
C
CN To obtain output to different graphics devices the program must be linked
CN with the appropriate version of the hardware dependent subroutines PIGLET
CN etc. from the PIG section of CCSL Currently available are:
CN     PIGLET ............. for Benson plotter
CN     PIGPG .............. for PGPLOT library (T.J. Pearson)
CN     PIGTEK ............. forTektronix library
CN     PIGGKS ............. for GKS
CN     PIGPOS ............. Postscript output
CN and, except in the case of PIGPOS, the appropriate graphics library
C
%      DIMENSION CFOUND(%CONT%)
      DIMENSION JP(4)
      LOGICAL PLOTED,START,OPED
/IOUNIT/
/MAPDA/
/PLOMAP/
      DATA PLOTED,START,OPED/.FALSE.,.TRUE.,.TRUE./
C
      CALL PREFIN('FORFIG')
      CALL RECIP
      CALL OPSYM(2)
      CALL SETFOU
   12 CALL FORIER(IIN,IOP,START)
      IF (IIN .EQ.0 .OR. IOP.EQ.0) GO TO 20
      GO TO (1,2,6,6,6), IIN
    1 CALL GETMAP
      GO TO 10
    2 CALL READMP
      GO TO 10
    6 IF (OPED) LUNI= NOPFIL(1)
      OPED=.FALSE.
      GO TO (3,4,5), IIN-2
    3 CALL FOUR1Z
      GO TO 11
    4 CALL FOURGP
      GO TO 11
    5 CALL ERRMAP
      GO TO 11
C
   11 REWIND LUNI
C
C  NOW WHAT OUTPUT?
   10 IF (MOD(IOP,2).EQ.1) THEN
         WRITE (LPT,2000) NOBSIN,NUSED
2000  FORMAT (/'Layer of Fourier calculated reading',I10,' reflections',
     & ' and using',I10)
        CALL PRNTMP(21)
      ENDIF
      I=IOP/2
      IF (MOD(I,2).EQ.1) THEN
C OBEY ANY SPECIAL CODE NEEDED AT PICTURE START:
      CALL PIGLET(WIDPIC,HGTPIC,888)
      CALL PICMOV
C
C SET THAT WE ARE IN PICTURE SPACE:
      CALL SPCSET(3)
C SELECT BLACK PEN:
      CALL PIGLET(0.,0.,-1)
C AND DRAW A FRAME ROUND THE WHOLE PICTURE:
      CALL FRAME(0.,0.,WIDPIC,HGTPIC)
C
C WRITE TITLE:
      CALL MAPTIT
C
C DRAW FRAME FOR MAP AND LABEL IT:
      CALL MAPFRA
C
C DRAW ACTUAL CONTOURS:
      CALL MAPDRW(CFOUND,IC,IBMAX,IFMAX)
C
C NO MORE CONTOURS WANTED - DRAW TEXT BLOCK UNDER PICTURE
      CALL PLTTXT
C
C PLOT ATOM POSITIONS
      IF (.NOT. PLOTED) CALL ATOPOS
      CALL ATMPLO(IFND,NFND,JP)
C
C  WRITE KEY TO ATOM LABELS
      CALL MAPKEY(IFND,NFND,JP)
C
C OBEY ANY SPECIAL CODE AT THE FINISH OF ONE PICTURE:
      CALL PIGLET(WIDPIC,HGTPIC,-888)
      PLOTED=.TRUE.
      ENDIF
      I=I/2
      IF (MOD(I,2).EQ.1) THEN
      CALL SAVMAP
      ENDIF
      IF (NDIM .NE.2) GO TO 12
C
C  FINISH OFF
   20 IF (PLOTED )CALL PIGLET(20.,20.,-999)
      STOP
      END
C
C
C
C
C LEVEL 50      PROGRAM FOUGPL
      PROGRAM FOUGPL
C
C *** FOUGPL new by PJB July 2017 C4.38 ***
C *****************************************************************************
C
C                           F O U G P L
C
C    GENERAL FOURIER PROGRAM, INCLUDING PLANE SECTIONS, PROJECTIONS, GENERAL
C PLANE SECTIONS AND ERROR MAPS, WITH SAVING AND RESTORING FACILITIES TO/FROM
C FILE, AND OUTPUT TO screen or printable files using gnuplot
C
C *****************************************************************************
C
CC 5D
C
CH General fourier inversion program output through gnuplot
C
CD A general program to calculate Fourier sums. It allows fourier sections,
CD projections, general plane sections and error maps to be calculated.
CD Facilities are provided for saving and restoring maps to and from file. The
CD output can be recorded by printer and/or plotted as a contoured map using gnuplot.
CC
CI The system  must be able to access the GNUPLOT graphing utility
CI The crystal data file must contain:
CI      A C card with the cell dimensions
CI      S cards giving the symmetry
CI      M cards defining which maps to draw and how they are defined
CI        (see the CCSL users' manual)
CI A file containing the data from which the Fourier sum is to be
CI calculated. This is in general supposed to contain h, k, l, F1, F2, F3 ...
CI in format (3I5,nF10.5). The number of F's to be read and ther interpretation
CI depends on the values of FTYP and DTYP read from the M cards. The range of
CI hkl must span the asymmetric unit of reciprocal space and not more.
CI If there is an M GET card: a file containing a previously "saved" map.
CI If there is an M READ card: a file containing a previously dumped map.
C
CO The usual listing file reporting the data which have been read. If there is
CO an M PRIN card this file also contains the values of the fourier summation
CO at the points requested. These numbers are rounded to integers so the
CO scale (given by M SCAL) must be chosen to ensure they are not all zero.
CO
CO If there is an M PLOT card: graphical output whose form depends upon the
CO graphical library being used.
CO
CO If there is an M SAVE card: An output file containing the "saved" maps.
C
CR On running the program the user is asked for the name of the crystal data
CR file, and the name of the file containing data for the Fourier
CR coefficients (reflection data).
CR He will also be asked to choose from the available terminal devices and
CR forms of hard copy output for the map (usually eps or jpg), The options
CR are read from the file "gnuplt" in the CCSL options directory.
C
C
%      DIMENSION NEEDM(%MCRD%)
C4.31 No further need for UNUSYD
      LOGICAL PLOTED,START,OPED
/IOUNIT/
/MAPDA/
/MREAD/
/PLOMAP/
      DATA PLOTED,START,OPED/.FALSE.,.TRUE.,.TRUE./
C MASK FOR MCARDS NEEDED (-1 means ignore)
C               NDIM FTYP MESH AXES PRIN PLOT CM/A CONT SAVE READ DTYP
      DATA NEEDM/0,   0,   0,    0,   0,   0,   0,   0,   0,   0,   0,
     & 0,   0,   0,  0,  -1,  -1,   0,  -1/
C     DELT SCAL GET SMAX GRID AXME LABL MAXE
C
      CALL PREFIN('FOUGPL')
      CALL RECIP
      CALL OPSYM(2)
C142 Setfou now needs mask of required MCARDS
      CALL SETFOU(NEEDM)
C143 Call to STGPLT REPLACES STPLOT
       CALL GPPREF
      IF (IMREAD(6) .GT. 0) CALL STGPLT
      CALL ERRMES(0,0,'to FOUGPL')
   12 CALL FORIER(IIN,IOP,START)
      IF (IIN .EQ.0 .OR. IOP.EQ.0) GO TO 20
      GO TO (1,2,6,6,6), IIN
    1 CALL GETMAP
      GO TO 10
    2 CALL READMP
      GO TO 10
    6 IF (OPED) LUNI= NOPFIL(1)
      OPED=.FALSE.
      GO TO (3,4,5), IIN-2
    3 CALL USYM(1)
      CALL FOUR1Z
      GO TO 11
    4 CALL FOURGP
      GO TO 11
    5 CALL ERRMAP
      GO TO 11
C
   11 REWIND LUNI
C
C  NOW WHAT OUTPUT?
   10 IF (MOD(IOP,2).EQ.1) THEN
         WRITE (LPT,2000) NOBSIN,NUSED
2000  FORMAT (/'Layer of Fourier calculated reading',I10,' reflections',
     & ' and using',I10)
        CALL PRNTMP(21)
      ENDIF
      I=IOP/2
      IF (MOD(I,2).EQ.1) THEN
      CALL PLOTGP
      ENDIF
      I=I/2
      IF (MOD(I,2).EQ.1) THEN
      CALL SAVMAP
      ENDIF
      IF (NDIM .NE. 2) GO TO 12
C
C  FINISH OFF
C   20 IF (PLOTED )CALL PIGLET(20.,20.,-999)
   20 STOP
      END
C
C
C
C
C LEVEL 50      PROGRAM FOURPL
      PROGRAM FOURPL
C
C *** FOURPL updated by PJB Nov 2016 C4.31 ***
C *****************************************************************************
C
C                           F O U R P L
C
C    GENERAL FOURIER PROGRAM, INCLUDING PLANE SECTIONS, PROJECTIONS, GENERAL
C PLANE SECTIONS AND ERROR MAPS, WITH SAVING AND RESTORING FACILITIES TO/FROM
C FILE, AND OUTPUT TO screen or printable files.
C
C *****************************************************************************
C
CC 5D
C
CH General fourier inversion program
C
CD A general program to calculate Fourier sums. It allows fourier sections,
CD projections, general plane sections and error maps to be calculated.
CD Facilities are provided for saving and restoring maps to and from file. The
CD output can be recorded by printer and/or plotted as a contoured map.
CD This same program masquerades under the name of FOURL\_TK when loaded with the
CD Textronix library, as FOURPL\_PG when loaded with the PGPLOT library and as
CD FOURPL\_PS when loaded with the postscript plotting routines.
C
CI The crystal data file must contain:
CI      A C card with the cell dimensions
CI      S cards giving the symmetry
CI      M cards defining which maps to draw and how they are defined
CI        (see the CCSL users' manual)
CI A file containing the data from which the Fourier sum is to be
CI calculated. This is in general supposed to contain h, k, l, F1, F2, F3 ...
CI in format (3I5,nF10.5). The number of F's to be read and ther interpretation
CI depends on the values of FTYP and DTYP read from the M cards. The range of
CI hkl must span the asymmetric unit of reciprocal space and not more.
CI If there is an M GET card: a file containing a previously "saved" map.
CI If there is an M READ card: a file containing a previously dumped map.
C
CO The usual listing file reporting the data which have been read. If there is
CO an M PRIN card this file also contains the values of the fourier summation
CO at the points requested. These numbers are rounded to integers so the
CO scale (given by M SCAL) must be chosen to ensure they are not all zero.
CO
CO If there is an M PLOT card: graphical output whose form depends upon the
CO graphical library being used.
CO
CO If there is an M SAVE card: An output file containing the "saved" maps.
C
CR Ensure that the terminal from which the program is to be run is appropriate
CR to the graphics library with which the program was linked.
CR On running the program the user is asked for the name of the crystal data
CR file, and the name of the file containing data for the Fourier
CR coefficients (reflection data). Any further dialogue is driven by the
CR graphics library and is usually confined to an enquiry as to whether a
CR hard copy of a map is required. If no contour values are given on M cards
CR and an M PLOT card is present, the program will ask for them interactively.
C
CN To obtain the different versions of the program it must be linked with
CN the appropriate version of the hardware dependent subroutines PIGLET
CN etc. from thethe PIG section of the library. Currently available are:
CN     PIGPL .............. for Benson plotter (obsolete)
CN     PIGPG .............. for PGPLOT library (T.J. Pearson)
CN     PIGTEK ............. forTektronix library (obsolete)
CN     PIGGKS ............. for GKS
CN     PIGPOS ............. Postscript output
CN     PIGNUP ............. Gnuplot output
CN and, except in the case of PIGPOS and PIGNUP, the appropriate graphics library
C
%      DIMENSION CFOUND(%CONT%),NEEDM(%MCRD%)
C4.31 No further need for UNUSYD
      LOGICAL PLOTED,START,OPED
/IOUNIT/
/MAPDA/
/MREAD/
/PLOMAP/
      DATA PLOTED,START,OPED/.FALSE.,.TRUE.,.TRUE./
C MASK FOR MCARDS NEEDED (-1 means ignore)
C               NDIM FTYP MESH AXES PRIN PLOT CM/A CONT SAVE READ DTYP
      DATA NEEDM/0,   0,   0,    0,   0,   0,   0,   0,   0,   0,   0,
     & 0,   0,   0,  0,  -1,  -1,   0,  -1/
C     DELT SCAL GET SMAX GRID AXME LABL MAXE
C
      CALL PREFIN('FOURPL')
      CALL RECIP
      CALL OPSYM(2)
C142 Setfou now needs mask of required MCARDS
      CALL SETFOU(NEEDM)
C143 Call to STPLOT now in main program was in SETFOU
      IF (IMREAD(6) .GT. 0) CALL STPLOT
      CALL ERRMES(0,0,'to FOURPL')
   12 CALL FORIER(IIN,IOP,START)
      IF (IIN .EQ.0 .OR. IOP.EQ.0) GO TO 20
      GO TO (1,2,6,6,6), IIN
    1 CALL GETMAP
      GO TO 10
    2 CALL READMP
      GO TO 10
    6 IF (OPED) LUNI= NOPFIL(1)
      OPED=.FALSE.
      GO TO (3,4,5), IIN-2
    3 CALL USYM(1)
      CALL FOUR1Z
      GO TO 11
    4 CALL FOURGP
      GO TO 11
    5 CALL ERRMAP
      GO TO 11
C
   11 REWIND LUNI
C
C  NOW WHAT OUTPUT?
   10 IF (MOD(IOP,2).EQ.1) THEN
         WRITE (LPT,2000) NOBSIN,NUSED
2000  FORMAT (/'Layer of Fourier calculated reading',I10,' reflections',
     & ' and using',I10)
        CALL PRNTMP(21)
      ENDIF
      I=IOP/2
      IF (MOD(I,2).EQ.1) THEN
C OBEY ANY SPECIAL CODE NEEDED AT PICTURE START:
      CALL PIGLET(WIDPIC,HGTPIC,888)
      CALL PICMOV
C
C SET THAT WE ARE IN PICTURE SPACE:
      CALL SPCSET(3)
C SELECT BLACK PEN:
      CALL PIGLET(0.,0.,-1)
C AND DRAW A FRAME ROUND THE WHOLE PICTURE:
      CALL FRAME(0.,0.,WIDPIC,HGTPIC)
C
C WRITE TITLE:
      CALL MAPTIT
C
C DRAW FRAME FOR MAP AND LABEL IT:
      CALL MAPFRA
C
C DRAW ACTUAL CONTOURS:
      CALL MAPDRW(CFOUND,IC,IBMAX,IFMAX)
C
C NO MORE CONTOURS WANTED - DRAW TEXT BLOCK UNDER PICTURE
      CALL PLTTXT
C
C FINALLY, COMPLETE PICTURE BY LISTING FOUND CONTOURS:
      IF (IC .GT. 0) CALL MAPCON(CFOUND,IC,IBMAX,IFMAX)
C
C PLOT ATOM POSITIONS IF REQUIRED
      IF (IMREAD(18) .GT. 0)   THEN
        CALL ATMPLT(OUTLIM(1,3))
        CALL ATMPIG
      ENDIF
C
C OBEY ANY SPECIAL CODE AT THE FINISH OF ONE PICTURE:
      CALL PIGLET(WIDPIC,HGTPIC,-888)
      PLOTED=.TRUE.
      ENDIF
      I=I/2
      IF (MOD(I,2).EQ.1) THEN
      CALL SAVMAP
      ENDIF
      IF (NDIM .NE. 2) GO TO 12
C
C  FINISH OFF
   20 IF (PLOTED )CALL PIGLET(20.,20.,-999)
      STOP
      END
C
C
C
C
C LEVEL 50      PROGRAM FREFOR
      PROGRAM FREFOR
C
C *** FREFOR by JCM 18 May 88 ***
C
C *****************************************************************************
C
C                        F R E F O R
C
C SAMPLE PROGRAM SHOWING TWO THINGS:
C    1) HOW TO USE CCSL WITH NO CRYSTAL DATA FILE (HENCE NO CALL PREFIN)
C    2) HOW TO READ A REFLECTION FILE IN CCSL FREE FORMAT.  WHAT THIS PROGRAM
C       ACTUALLY DOES IS CONVERT A FILE FROM FREE TO FIXED FORMAT, BUT IT SHOULD
C       BE USEFUL AS A GUIDE TO HOW TO ALTER A MAIN PROGRAM TO ACCEPT
C       FREE FORMAT DATA INPUT.
C
C *****************************************************************************
C
C THE COMMON /SCRACH/ IS NECESSARY BECAUSE THAT IS WHERE RDINTG, RDREAL, RDWORD
C ETC EXPECT THEIR INPUT BUFFER:
/SCRACH/
      CALL INITIL('FREFOR')
C USE SPECIFIC UNIT IN THIS ONE-OFF PROGRAM - IN A CCSL MAIN PROGRAM THE UNIT
C WOULD ALREADY HAVE A NAME, AND BE OPENED:
      OPEN (1,FILE='TEST.DSP',STATUS='OLD')
   1  READ(1,10,END=2) ICARD
  10  FORMAT (A80)
      IPT=1
C READ 3 INTEGERS AND 2 REALS:
      CALL RDINTG(K,IPT,IPT,80,IER)
      CALL RDINTG(L,IPT,IPT,80,IER)
      CALL RDINTG(M,IPT,IPT,80,IER)
      CALL RDREAL(A,IPT,IPT,80,IER)
      CALL RDREAL(B,IPT,IPT,80,IER)
      WRITE (12,11) K,L,M,A,B
  11  FORMAT (1X,3I5,2F10.1)
      GO TO 1
   2  STOP
      END
C
C
C
C
C LEVEL 50      PROGRAM FWLSQ
      PROGRAM FWLSQ
C
C *** FWLSQ updated by JCM 17 Nov 87 ***
C
C ******************************************************************************
C
C                         F W L S Q
C
C ******************************************************************************
C
C
C MAIN PROGRAM FWLSQ FOR AN EXAMPLE OF SIMPLE LEAST SQUARES REFINEMENT, IN THIS
C CASE BEING OF 5, 7 OR 9 COEFFICIENTS IN FORSYTH & WELLS EXPONENTIAL APPROX.
C TO SCATTERING FACTORS.
C
C WHAT IS SIMPLE ABOUT IT IS THAT IT DOES NOT INVOLVE STRUCTURE FACTORS.  INDEED
C IT DOESN'T INVOLVE ANYTHING VERY MUCH, BUT THE MECHANISM SHOWS HOW CCSL CAN
C DEAL WITH REFINEMENT GENERALLY.  NO CONSTRAINTS ARE INVOLVED.
C
C THE MAIN PROGRAM - THIS - FIRST SETS UP THE PROBLEM.  THAT IS, IT FEEDS INTO
C THE COMMON /PRBLEM INFORMATION ABOUT:
C
C     HOW MANY FAMILIES OF PARAMETERS, AND THEIR NAMES
C     FOR EACH FAMILY, HOW MANY GENERA, AND THE NAMES OF EACH GENUS
C     FOR EACH GENUS, HOW MANY SPECIES, AND THEIR NAMES
C
C THERE ARE VARIOUS WAYS WE COULD APPROACH THIS, TWO OBVIOUS ONES BEING:
C   A) TO GIVE EACH PARAMETER A SIMPLE NAME, EACH IN FAMILY 1 GENUS 1, OR
C   B) TO CALL ALL PARAMETERS THE SAME THING WITH A SERIAL NUMBER.
C
C SO FOR (A):
C THE ANSWERS TO THE FIRST TWO QUESTIONS ARE BOTH 1 (WITH TRIVIAL NAMES LIKE 4
C SPACES) AND TO THE THIRD IS SOMETHING LIKE 9, NAMED A1, B1, A2, B2, A3, B3,
C A4, B4, A5
C
C OR FOR (B):
C AS AN EXAMPLE OF AN ARRAY, WE COULD HAVE 2 GENERA OF FAMILY 1 (WITH THE
C FIRST BEING EMPTY - FAMILY 1 GENUS 1 IS ALWAYS THERE) - AND CALL OUR 5, 7 OR 9
C COEFFICIENTS SOMETHING LIKE COEF(1), COEF(2) ETC.  THESE ARE FAMILY 1,
C GENUS 2, GENUS NAME 'COEF', SPECIES TYPE FOR THIS GENUS = NUMERICAL.
C
C AS AN INITIAL IMPLEMENTATION WE DO THIS LATTER, (B)
C
C
C THAT IS THE 'ON WHAT ARE WE WORKING?' SIDE OF THE PROBLEM.  THE 'WHAT ARE WE
C DOING WITH THEM?' SIDE IS NOT NEEDED HERE EXPLICITLY, BECAUSE WE ARE DOING A
C STANDARD THING KNOWN TO THE SYSTEM, AND HAVE ALREADY WRITTEN ROUTINES LIKE
C STLSFW WHICH WILL READ AND INTERPRET "L" CARDS WITH THIS SORT OF REFINEMENT IN
C MIND, AND CALCFW WHICH WILL RETURN A CALCULATED VALUE OF THE FUNCTION ON WHICH
C WE ARE REFINING.
C
C IT COULD WELL REDEFINE SOME OF THE ARRAY SIZES, AS IT HAS AT MOST 9 VARIABLES,
C BUT ANY REDEFINITION INVOLVES RECOMPILING THE LIBRARY, SO IN GENERAL WOULD NOT
C BE BOTHERED WITH UNLESS ESSENTIAL.
C
C IT THEN READS THE DATA.  SOME LSQ INPUT COMES ON L CARDS, AND THERE IS ALSO
C THE POSSIBILITY OF DRIVING IT USING I CARDS.
C (I IS FOR "INSTRUCTIONS, POSSIBLY INTERACTIVE";  I CARD INFORMATION CAN BE
C REQUESTED INTERACTIVELY ON THOSE MACHINES LUCKY ENOUGH TO BE ABLE TO.)
C
C IN THIS SIMPLE CASE WE NEED TO KNOW:
C   N, THE NUMBER OF COEFFICIENTS - 5, 7 OR 9 IS USUAL - AND WE WOULD DEDUCE
C THIS FROM THE NUMBER OF INITIAL VALUES GIVEN.
C   TRIAL VALUES FOR THESE COEFFICIENTS.
C
C STLSFW READS THESE TRIAL VALUES INTO SOME SPECIAL COMMON, /FWVALS/, READY FOR
C USE.
C
      CHARACTER *4 IFWWRD(2)
      LOGICAL PRINT,PRNCYC
      DIMENSION ALSQ(100),IFWDSP(3,2)
/IOUNIT/
/OBSCAL/
/PRBLEM/
/REFINE/
/SCRACH/
      DATA IFWWRD/' ','COEF'/
      DATA IFWDSP/1,1,0, 1,2,0/
C
      CALL PREFIN('FWLSQ')
      MATSZ=100
C
C SET UP PROBLEM:
      NFAM=1
      NGENS(1)=2
      NSPC(1)=9
C
C SPECIES TYPES OF GENERA IN F1 (0=NONE, -VE=INTEGERS)
      LF1SP(1)=0
      LF1SP(2) =-9
C
C WORDS RELEVANT TO THIS PROBLEM FROM DATA INTO COMMON:
      CALL LSETUP(2,IFWDSP,IFWWRD)
C
      MESSAG='Observations file'
      LUNI=NOPFIL(11)
      CALL NEWCD
C
C READ POSSIBLE I CARD, ALL L CARDS (THERE ARE NO  L FIX, L VARY OR L RELA
C CARDS FOR THIS SIMPLE REFINEMENT):
      CALL STLSFW
C
C SET UP VARIABLES AND BASIC VARIABLES (THERE ARE NO CONSTRAINTS):
      CALL PARSFW
C
C
C CYCLE:
      DO 1 ICYC=NCYC1,LASTCY
C IS PRINTING OF OBS AND CALC LIST REQUESTED THIS CYCLE?
      PRINT=PRNCYC(1)
      IF (PRINT) THEN
        CALL MESS(LPT,2,'Observed and calculated values :')
        CALL MESS(LPT,0,'sin theta/lambda       Obs f              '//
     &  'Calc f     Diff      Weight')
      ENDIF
C
C INITIALISE R FACTOR SUMS:
      CALL RFACS(1)
C
C SET UP TRIANGULAR MATRIX POINTERS, CLEAR OUT LSQ MATRIX AND RHS:
      CALL MATSET(ALSQ,MATSZ)
C
C COUNT USED OBSERVATIONS (THERE IS NOT AT PRESENT ANY WAY OF NOT USING ONE)
      NOBS=0
   5  READ(LUNI,1000,END=3) STHETA,OBS,DOBS
1000  FORMAT (3F12.4)
      CALL CALCFW(STHETA)
C CALCFW FORMS GCALC,  PUTS DG/DV INTO DERIVV FOR ALL VARIABLES, AND SETS UP
C ALL REQUIRED QUANTITIES IN OBSCAL FOR SUBSEQUENT CALLS OF MATTOT AND RFACS
C
C MAKE BASIC VARIABLE DERIVATIVES FROM VARIABLE DERIVATIVES:
      CALL RELATE
      DIFF = OBS - GCALC
C
C UNIT WEIGHTS FOR NOW:
      WT=1.
      SQRTWT=1.
      WDIFF=DIFF
C
      IF (PRINT) WRITE (LPT,2003) STHETA,OBS,GCALC,DIFF,WT
2003  FORMAT (' ',F12.4,2F10.3,F10.5,F10.4)
C
C ADD IN TO R FACTORS:
      WT=1.
      WDIFF=DIFF
      CALL RFACS(2)
C
C ADD DERIVATIVES IN TO LSQ MATRIX:
      CALL MATTOT(ALSQ,MATSZ)
      NOBS=NOBS+1
C NEXT OBSERVATION:
      GO TO 5
C
C HERE ON NO MORE OBSERVATIONS - REWIND OBSERVATIONS FILE AND PRINT R FACTORS:
   3  REWIND LUNI
      CALL RFACS(3)
C
C INVERT MATRIX, CALCULATE SHIFTS AND ESD'S; APPLY AND PRINT:
      CALL MATINV(ALSQ,MATSZ)
      CALL MATSHF(ALSQ,MATSZ)
      CALL APSHFW
   1  CONTINUE
C
C PRINT CORRELATION MATRIX; PRODUCE NEW INPUT DATA FILE:
      CALL MATCOR(ALSQ,MATSZ)
      CALL NWINFW
 100  STOP
      END
C
C
C
C
C LEVEL 50      PROGRAM GENDAT
      PROGRAM GENDAT
C
C *** GENDAT by PJB Sep 87 ***
C
C************************************************************************
C
C                            G E N D A T
C
C  TO GENERATE A COMPLETE SET OF REFLECTIONS FROM A SET DEFINED WITHIN AN
C  ASYMMETRIC UNIT
C
C************************************************************************
C
      LOGICAL USED,ENDIP
%      DIMENSION H(3,%SY*2%),EH(3),HI(3),K(3),F(2)
/IOUNIT/
/NSYM/
C
C SET UP
      CALL PREFIN('GENDAT')
      CALL SYMOP
C
C GET FILE-NAMES
      LUNI=NOPFIL(1)
      LUNO=NOPFIL(2)
C
C  SET MODEF AND MODED
C MODEF=5 FOR PHASED DIFFERENCE
      MODEF=5
C  MODEF =3 FOR DATA AS h,k,l A(calc), B(calc), F(obs)
      MODED=2
C
C NOBSIN COUNTS DATA READ, NUSED COUNTS THOSE USED
      NOBSIN=0
      NUSED=0
C
C  NOW READ REFLECTIONS
    7 USED=.FALSE.
      CALL FOUINP(K,F,ALPHA,MODED,MODEF,ENDIP)
      IF (ENDIP) GO TO 100
C
      NOBSIN=NOBSIN+1
      CALL INDFLO(HI,K)
C
      CALL CHOOSF(F,SF,ALPHA,ALPH,MODEF)
C
C DOUBLE ALL BUT 000 REFLN. AS WE ARE ONLY USING HALF RECIPROCAL SPACE:
      IF  ((K(1).NE.0).OR.(K(2).NE.0).OR.(K(3).NE.0))
     & SF=2.*SF
C
C DEAL WITH SYMMETRY EQUIVALENTS:
C TO MAKE EQVEC ACCEPT FIRST SET OF INDICES
      MI=0
C TRANSFORM HI (GIVEN H) TO OCCUPY FIRST PLACE IN TABLE FOR EQVEC:
      CALL GMEQ(HI,H(1,1),1,3)
      DO 8 N = 1,NOPC
      CALL SYMEQU(HI,H,K,N,MI,UU,BETA)
      IF (UU.EQ.0.) GO TO 8
      USED=.TRUE.
      ALPHA1 = ALPH*UU + BETA
      A=SF*COS(ALPHA1)
      B= SF*SIN(ALPHA1)
      WRITE (LUNO,2000) K,A,B
2000  FORMAT (3I5,2F10.4)
C
    8 CONTINUE
      IF (USED) NUSED=NUSED+1
      GO TO 7
C
C  ALL REFLECTIONS NOW READ
 100  STOP
      END
C
C
C
C
C LEVEL 50      PROGRAM GENREF
      PROGRAM GENREF
C ** GENREF corrected by PJB May 2011 Friedel pairs **
C  for D3 working with new MAD
C
C *********************************************************************
C
C                          G E N R E F
C
C *********************************************************************
C
CC 2D
CH  To generate reflections and create a D3 measuring file
CD  The program generates reflections and creates a D3 measuring file
CD  with extension ".ips" containing those which satisfy specified
CD  criteria. If the filename requested is XXXXXn the last instruction
CD  in the measuring file is *CIS XXXXXm where m=n+1. Only reflections having
CD  accessible setting angles are included.
C
CD  The following criteria can be selected interactively by the user
CD   A. The minimum and maximum \$\nu\$ (angle of elevation of the detector)
CD   B. The maximum \$\rho\$ (angle of elevation of the scattering vector)
CD   C. The minimum and maximum \sinth
CD   D. The minimum and maximum nuclear structure factors
CD   E. The maximum number of equivalent reflections included
CD   F. The frequency of measurement of the standard reflection
CD   G. Lower and upper limits for \$\gamma\$ (the detector angle 2\$\theta\$
CD    for \$\nu=0\$)
CD
CD  Standard reflection measurements can be included at requested
CD  intervals
C
CI The crystal data file must contain:
CI     Symmetry information on S cards
CI     The unit cell definition on a C card
CI     The atomic positions on A cards
CI     The nuclear scattering lengths on F cards
CI     The wavelength, geometry definition and UB matrix on D cards
C
CO A listing file: "genref.lis: which reports how the crystal data file was
CO interpreted and lists the reflections to be measured together with their
CO structure factors and the angles \$\gamma\$, \$\nu\$ and \$\rho\$.
CO
CO A file xxxxx.ips where xxxxx is a name selected by the
CO user. This file will contain a list of orders:
CO          hkm h, k, l
CO          .
CO          .
CO in which there is an "hkm" line for each reflection satisfying the given
CO criteria.
C
CR On running the program the user is asked for the name of the crystal data
CR file, the name for the output file (xxxxxn), and is asked to select the
CR criteria to be used to choose reflections. For each choice there is a
CR default value. Typing a "RETURN" at any point while entering the choices
CR within a group causes the defaults to be used for the rest of the
CR parameters in the group. Typing an "=" at any point selects the default
CR (or previous) value for a particular parameter.
CR The selection phase of the program can be repeated several times with each
CR run producing files containing reflections satisfying the currently
CR selected criteria. I
CRIf the filename xxxxxm is chosen for the first output file, the output
CR filename in the second run will be xxxxxm+1 and so on.
C
      DIMENSION HR(3,48),H(3),K(3),VALA(8),VALB(2),IVAL(3),ANG(4,48),
     &PHASE(48),HS(3,28),IPTR(500),TEST(500),FNN(500)
     &,AANG(3,500),KK(3,500),RHO(500)
      CHARACTER*4 VCHR(2),WORD
      CHARACTER*10 FILNAM(2),FILNOM
      LOGICAL LERCHK,UP
/FRIED/
/IOUNIT/
/NSYM/
/SCRACH/
      LOGICAL ENDREF,ISPABS,ABSENT,NOSTAN,SAID,SAYS
      COMPLEX FCALC
      INTEGER NUMR
      DATA VALA/-25.,5.,45.,0.01,1.5,0.,110.,1.0/
      DATA VALB/.01,90./
      DATA IVAL/0,0,7/
      DATA VCHR/'all','none'/
C
      CALL PREFIN('GENREF')
C
C  SET UP CRYSTALLOGRAPHY
      CALL SETFC
      CALL SETDC
      CALL SYMUNI
      UP=.TRUE.
C
      NAMFIL='.XBU'
      CALL UPONE(NAMFIL,3)
      IOPN=102
   35 LUN=NOPFIL(IOPN)
      FILNAM(1)=FILNOM(LUN)
C
    1 WRITE (ITO,10)(VALA(I),I=1,5)
   10 FORMAT (' Give nu limits, rho max and sinth/lam limits'/
     &' c/r or = gives defaults',F7.2,' to',F7.2,', ',F6.1,' and',
     & F6.3,' to',F6.3)
   11 FORMAT (A80)
   12 FORMAT (' Error in  input')
      READ (ITI,11) ICARD
      IPT1=1
      DO 2 I=1,5
      CALL RDREAL(VAL,IPT1,IPT2,80,IER)
      IF (IER.EQ.0) THEN
        VALA(I)=VAL
      ELSE
C IER=-16 MEANS HAS READ =, IER=100 MEANS c/r
        IF (IER.NE.-16) THEN
          IF (IER.NE.100)THEN
            WRITE (ITO,12)
            GO TO 1
          ENDIF
        ELSE
          IPT2=IPT2+1
        ENDIF
      ENDIF
      IPT1=IPT2
    2 CONTINUE
C
    7 WRITE (ITO,14)(VALB(I),I=1,2)
   14 FORMAT (' Give FNmin, FNmax ',/
     &' c/r  or = gives default',F7.2,' to',F7.2)
      READ (ITI,11) ICARD
      IPT1=1
      DO 5 I=1,2
      CALL RDREAL(VAL,IPT1,IPT2,80,IER)
      IF (IER.EQ.0) THEN
        VALB(I)=VAL
      ELSE
C IER=-16 MEANS HAS READ =, IER=100 MEANS c/r
        IF (IER.NE.-16) THEN
          IF (IER.NE.100)THEN
            WRITE (ITO,12)
            GO TO 7
          ENDIF
        ELSE
          IPT2=IPT2+1
        ENDIF
      ENDIF
      IPT1=IPT2
    5 CONTINUE
C
    8 WRITE (ITO,15)(VCHR(I),I=1,2)
   15 FORMAT (' Give number of equivalents to measure and ',
     &'frequency of standards',/
     &' c/r  or = gives default ',A3,' and ',A4)
      READ (ITI,11) ICARD
      IPT1=1
      DO 9 I=1,2
      CALL RDWORD(WORD,LEN,IPT1,IPT2,80,0,IER)
      IF (IER.EQ.0) THEN
        IVAL(I)=0
        VCHR(I)=WORD
        IF (I .EQ.1 .AND. .NOT. SAID(WORD(1:3),'ALL')) GO TO 61
        IF (I .EQ.2 .AND. .NOT. SAID(WORD(1:3),'NON')) GO TO 61
      ELSE
C IER=-16 MEANS HAS READ =, IER=100 MEANS c/r
        IF (IER.EQ.100) GO TO 30
        IF (IER.EQ.-16) THEN
          IPT1=IPT2+1
          GO TO 9
        ENDIF
          CALL RDINTG(IVAL(I),IPT1,IPT2,80,IER)
          IF (IER.NE.0) GO TO 61
      ENDIF
      IPT1=IPT2
      GO TO 9
   61 WRITE (ITO,62)
   62 FORMAT (' Illegal input')
      GO TO 8
    9 CONTINUE
C
C LIMITS IN GAMMA
   30 WRITE (ITO,300) VALA(6),VALA(7)
  300 FORMAT (' Give lower and upper limits in gamma,'/
     &' c/r or = gives default',F8.2,' to',F8.2)
      READ (ITI,11) ICARD
      IPT1=1
      DO 31 I=6,7
      CALL RDREAL(VAL,IPT1,IPT2,80,IER)
      IF (IER.EQ.0) THEN
        VALA(I)=VAL
      ELSE
C IER=-16 MEANS HAS READ =, IER=100 MEANS c/r
        IF (IER.NE.-16) THEN
          IF (IER.NE.100)THEN
            WRITE (ITO,12)
            GO TO 30
          ENDIF
        ELSE
          IPT2=IPT2+1
        ENDIF
      ENDIF
      IPT1=IPT2
   31 CONTINUE
C
C Width of centreing scans
   40 WRITE (ITO,301) VALA(8),IVAL(3)
  301 FORMAT (' Give Width for centreing scan (degrees) and number '/
     &'of points, c/r or = gives default',F8.2,' and',I4)
      READ (ITI,11) ICARD
      IPT1=1
      DO 41 I=1,2
      if (i.eq.1) then
        CALL RDREAL(VAL,IPT1,IPT2,80,IER)
       IF (IER.EQ.0) VALA(8)=VAL
      else
        CALL RDINTG(IV,IPT1,IPT2,80,IER)
       IF (IER.EQ.0) IVAL(3)=IV
      endif
      if (ier.ne.0) then
C IER=-16 MEANS HAS READ =, IER=100 MEANS c/r
        IF (IER.NE.-16) THEN
          IF (IER.NE.100)THEN
            WRITE (ITO,12)
            GO TO 40
          ENDIF
        ELSE
          IPT2=IPT2+1
        ENDIF
      ENDIF
      IPT1=IPT2
   41 CONTINUE
C
C WRITE HEADING
      WRITE (LPT,303)
  303 FORMAT (/'    h    k    l    Fcalc      Omega     Gamma      Nu',
     &'       Rho     Move')
C
      NOSTAN=(IVAL(2).EQ.0)
      NEQU=IVAL(1)
      IF (NEQU.EQ.0) NEQU=NOP
C
      CALL SETGEN(VALA(5))
C
      NUMR=0
      NS=0
      NSS=0
C
C4.23 Always generate -(hkl) but only once even if non-centric
      NFRY=1
      IF (.NOT. CENTRC) NFRY=2

    3 CALL GETGEN(H,ENDREF)
      IF (ENDREF) GO TO 6
      IF (ISPABS(H)) GO TO 3
      CALL INDFIX(H,K)
C      write (lpt,1010),K
C 1010 FORMAT (3I4)
C
C  USER'S TESTS ON K
C      IF (OMIT(K)) GO TO 3
C
C  CHECK THAT SINTH/LAM IS WITHIN LIMITS
      S=VCTMOD(0.5,H,2)
      IF (S.LT.VALA(4) .OR. S.GT.VALA(5)) GO TO 3
C
C  AND THAT FN IS WITHIN RANGE
      FN=CABS(FCALC(H))
      IF(FN.LT.VALB(1).OR.FN.GT.VALB(2)) GO  TO 3
C
      CALL SYMREF(H,HR,NUM,PHASE)
      IC=0
      NR=1
      DO 4 N=1,NUM
C4.23 Always generate -(hkl) but only once even if non-centric
      do 4 IC=1,NFRY
      IF (IC.EQ.2) THEN
        CALL GMREV(HR(1,N),H,3,1)
        CALL EQVEC(HR,H,NUM,M,0)
        IF (M.LE.NUM) GO  TO 4
      ELSE
        CALL GMEQ(HR(1,N),H,3,1)
      ENDIF
      CALL ANGLD3(H,ANG(1,NR),ABSENT)
      IF (ABSENT) GO TO 4
      IF (ANG(3,NR).LT.VALA(1) .OR. ANG(3,NR).GT.VALA(2)) GO TO 4
      IF (ANG(4,NR).GT.VALA(3).OR. ANG(4,NR).LT. -VALA(3)) GO TO 4
      IF (ANG(2,NR).LT.VALA(6).OR. ANG(2,NR).GT. VALA(7)) GO TO 4
      CALL GMEQ(H,HS(1,NR),3,1)
      TEST(NR)=ABS(ANG(3,NR))
      NR=NR+1
    4 CONTINUE
      NR=NR-1
C SELECT REFLECTIONS WITH SMALLEST ABS(NU)
      CALL SORTX(TEST,IPTR,NR)
      NUM=MIN0(NR,NEQU)
      DO 71 N=1,NUM
      IP=IPTR(N)
C SAVE THE GOOD REFLECTIONS FOR SORTING
      IF (.NOT. LERCHK(2,NUMR,500,-1,'Reflections to store')) go to 6
      CALL INDFIX(HS(1,IP),KK(1,NUMR))
C      WRITE (LPT,4001) NUMR,(KK(i,NUMR),i=1,3),FN,(ANG(I,IP),i=1,4)
C 4001 FORMAT (i4,3i5,F10.4,5F10.2)
C Save first three angles
        CALL GMEQ(ANG(1,IP),AANG(1,NUMR),3,1)
        RHO(NUMR)=ANG(4,IP)
        FNN(NUMR)=FN
   71 CONTINUE
      GO TO 3
C
C Try to optimise for minimum movement (omega)
    6 Call mindom(iptr,aang,numr,test,UP)
C or min total increment
C      call minmov(iptr,aang,numr,test)
      do 73 n=1,numr
      ip=iptr(n)
      WRITE (LPT,51) (KK(i,ip),i=1,3),FNN(ip),(AANG(I,IP),i=1,3)
     &,RHO(IP),test(ip)
      WRITE (LUN,13)(KK(i,ip),i=1,3),VALA(8),IVAL(3)
CXXX Changed format for provisional mad commands
C4.15 Depolarise beam for search
   13 FORMAT ('hkl0 ',3i4/'spi 0'/'cen om ',F6.2,I4,' 1'/'>bpb')
   51 FORMAT (3i5,F10.4,5F10.2)
      NS=NS+1
C      IF(.NOT.NOSTAN .AND. NS.GE.IVAL(2)) THEN
C        WRITE (LUN,53)
CXXXChanged format
C   53 FORMAT ('srm')
C        NS=0
C        NSS=NSS+1
C      ENDIF
   73 CONTINUE
      call clofil(lun)
C
      WRITE (LPT,54)FILNAM(1),NUMR,VALA(6),VALA(7),VALB(1)
     &,VALB(2),VALA(4),VALA(5)
      IF (.NOT. NOSTAN) WRITE (LPT,56) NSS,IVAL(2)
   54 FORMAT (' The output file ',A10,' contains',I5,' reflections'/
     &' with gamma in the range ',F7.2,' to',F7.2
     &/' having nuclear structure factors between',F6.2,' and',F6.2/
     &'and Sinth/lamda between',F6.3,' and',F6.3/)

   56 FORMAT (1X,I4,' standards are included, one every'
     &,I4,' reflections')
      FILNAM(2)=FILNAM(1)
      CALL INCREM(FILNAM(2),FILNAM(1))
      L=INDEX(FILNAM(1),'.')
      write (lun,60) (FILNAM(1)(I:I),I=1,L)
   60 format ('CIS ',8A1)
      CALL ASK(' Change limits? Y(es) or N(o)')
      IF (.NOT. SAYS('Y')) STOP
      UP=.NOT. UP
      MESSAG=filnam(1)
      IOPN=222
      GO TO 35
      END
C
C
C
C
      SUBROUTINE ANGLD3(H,A,ABSENT)
C
CC 2B
CH Calculate diffraction angles for D3 geometry
C
CA On entry H holds the reflection indices
CA on exit A(1=4) hold the angles omega,gamma,nu and rho
CA ABSENT is true if the diffraction geometry can not be satisfied
C
      DIMENSION H(3),A(4),OH(3),RH(3)
      LOGICAL ABSENT
C
/DGEOM/
C
      ABSENT=.TRUE.
      IF (IGEOM.NE.8) STOP 'WRONG GEOMETRY'
C
      CALL ORTHO(H,OH,2)
      CALL GMPRD(UM,OH,RH,3,3,1)
      CALL UNIVEC(RH,D)
      A(4)=DEGREE(ASIN(RH(3)))
      SINTH=WLGTH*D*0.5
      IF (SINTH.GT. 1.000) GO TO 100
C
      SINNU=2*SINTH*RH(3)
      IF (SINNU.GT.1.00 .OR. SINNU.LT.-1.) GO TO 100
      COSNU=SQRT(1.-(SINNU*SINNU))
      COSTH=1.-(2*SINTH*SINTH)
      COSGAM=COSTH/COSNU
      IF (COSGAM.GT.1 .OR. COSGAM.LT.-1) GO TO 100
      A(2)=DEGREE(ACOS(COSGAM))
      ANU=ATAN2(SINNU,COSNU)
      A(3)=DEGREE(ANU)
      PHI = DEGREE(ATAN2(RH(2),RH(1)))
      CALL SINCOS(RH(3),COSRHO)
      COSOM=SINTH/COSRHO
      OMEGA=DEGREE(ACOS(COSOM))
      A(1)=OMEGA-PHI
      IF (A(1).LT.0) THEN
        A(1)=A(1)+180.
      ELSE
        A(1)=A(1)-180.
      ENDIF
      ABSENT=.FALSE.
C
  100 RETURN
      END
C
C
C
C
      SUBROUTINE MINMOV(ip,ang,num,work)
C
CC 2C
CH Trys to optimise movement of shafts between reflections
C
      dimension ip(num),ang(3,num),work(*)
C
      call jgmzer(ip,num,1)
      next=1
      ip(1)=1
      do 1 nn=2,num
      tmin=1000.
      do 2 n=1,num
      if (ip(n) .eq. 0) then
       test=0.
        do 3 i=1,3
        a1=ang(i,n)
        a2=ang(i,next)
        test=test+abs(ang(i,n) -ang(i,next) )
    3   continue
C        write (*,1001) next,n,test,(ang(i,next), ang(i,n),i=1,3)
C 1001   format (6x,2i4,f8.2,3(2f8.2,2x))
        if (test .lt.tmin) then
          tmin=test
          nmin=n
        endif
      endif
    2 continue
      ip(nmin)=nn
      next=nmin
      work(nn)=tmin
    1 continue
      write (*,1000) (nn,ip(nn),work(nn),nn=1,num)
 1000 format (2i5,f8.2)
      return
      end
C
C
C
C
      SUBROUTINE MINDOM(ip,ang,num,work,UP)
C
CC 2C
CH Trys to optimise movement of shafts between reflections minimising delta omega
C
      dimension ip(num),ang(3,num),work(*)
      LOGICAL UP
      do 1 i=1,num
      if (up) then
        work(i)=ang(1,i)
      else
        WORK(I)=-ang(1,i)
      endif
    1 continue
      call sortx(work,ip,num)
      return
      end
C
C
C
C
C LEVEL 50      program GET3J
      PROGRAM GET3J
C
C ***  GET3J added to MAI by PJB April 03 ***
C
CH To calculate vector coupling and 3j coefficients
C
CC 9D
CD The GET3J program calculates the vector coupling, and  3j coefficients for
CD angular momenta entered interactively at the terminal.
CP None
C
      DIMENSION AJ(6)
      CALL INITIL('GET3J')
    1 CALL ASK('Enter j1,j2,j3,m1,m2,m3')
      CALL RDNUMS(AJ,1,6,NUM,IER)
      IF (NUM .EQ.0) STOP
      IF (IER.NE.0 .OR. NUM.NE.6) GO TO 1
    2 CONTINUE
      VEC=VECOUP(AJ(1),AJ(4),AJ(2),AJ(5),AJ(3),-AJ(6))
      IJ=NINT(AJ(1)-AJ(2)-AJ(6))
      THREJ=VEC*SQRT(1/(2.*AJ(3)+1.))
      IF (MOD(IJ,2) .NE.0) THREJ=-THREJ
      CALL RATFRC(THREJ,I,J)
      WRITE (ITO,10) AJ(1),AJ(2),AJ(3),THREJ,I,J,
     &AJ(4),AJ(5),AJ(6)
   10 FORMAT(/1X,' 3j symbol',3F4.1,'  =',F12.5' Root ',I4,
     &' over ',I4/11X,3F4.1)
      CALL RATFRC(VEC,I,J)
      WRITE (ITO,11) AJ(1),AJ(4),AJ(2),AJ(5),AJ(3),-AJ(6),VEC,I,J
   11 FORMAT ('Vector coupling coef ficient:'/' <',4F4.1,'|',2F4.1,'>',
     &F10.5,' Root ',I4,' over ',I4)
      GO TO 1
      END
C
C
C
C
C LEVEL 50      PROGRAM GETMPL
      PROGRAM GETMPL
C
C *** GETMPL updated by JCM 17 Oct 89 ***
C
C ****************************************************************************
C
C                              G E T M P L
C
C  TO GENERATE INDICES AND CALCULATE AND OUTPUT STRUCTURE FACTORS
C  WITH MULTIPOLE FORM-FACTORS
C
C ****************************************************************************
      COMPLEX FMPCAL,FC
      DIMENSION VAL(5),IU(3),U(3)
      LOGICAL ENDREF,OUTPUT,LAYER,ISPABS,SAYS
      CHARACTER*100 VFMT
/FORMDA/
/IOUNIT/
/MPODA/
/NSYM/
/POLFOR/
/POSNS/
/SCRACH/
%      COMMON/SCRAT/K(3),H(3,%NSFS%),IS(%NSFS%),M(%NSFS%)
      DATA VFMT/'(''     h    k    l  Sinth/Lam       A         B'',
     & ''      Fcalc   Multpcy''/)'/
C
      LAYER=.FALSE.
      CALL PREFIN('GETMPL')
C
      SMIN=0.
  30  CALL ASK('Output reflections in layers or increasing Sin'//
     & 'Theta/lambda? (L or S)')
      IF (SAYS('L')) GO TO 40
      IF (.NOT. SAYS('S')) GO TO 30
C
      CALL ASK('Maximum (& minimum if non-zero) SinTheta/Lambda?')
      CALL RDNUMS(VAL,1,2,N,IER)
      IF (N .EQ. 1) THEN
        SMAX=VAL(1)
      ELSE
        SMIN=AMIN1(VAL(1),VAL(2))
        SMAX=AMAX1(VAL(1),VAL(2))
        WRITE (LPT,2081) SMIN
2081    FORMAT (' Minimum sin theta/lambda =',F10.4)
      ENDIF
      GO TO 41
C
   40 CALL MESS(ITO,0,'Give maximum sintheta/lambda,')
      CALL ASK('zone axis symbols & number of highest layer')
      CALL RDREAL(SMAX,1,IPT,80,IER)
      DO 49 I=1,3
  49  CALL RDREAL(U(I),IPT,IPT,80,IER)
      CALL RDINTG(NL,IPT,IPT,80,IER)
      LAYER=.TRUE.
      CALL INDFIX(U,IU)
      WRITE(LPT,2082) NL,IU
2082  FORMAT (/' Output ',I4,' layers up zone axis',3I5)
C
  41  WRITE (LPT,2080) SMAX
2080  FORMAT (' Maximum sin theta/lambda =',F10.4)
      CALL ASK('Store structure factors on file? Y or N')
      OUTPUT=(SAYS('Y'))
C
C  SET UP CRYSTALLOGRAPHY
      CALL SYMOP
      CALL RECIP
      CALL ATOPOS
      CALL SETANI
      CALL PFSET
C CREATE MONOPOLES FOR ALL ATOMS WITHOUT J CARDS
      NEW=0
      DO 21 N=1,NATOM
      IF (MPNMTB(N).EQ.0) THEN
        NEW=NEW+1
        NMPAT=NMPAT+1
        MPATAB(NMPAT)=N
        MPNMTB(N)=NMPAT
      ENDIF
C USE NORMAL(NON-MAGNETIC) FORM FACTORS
C122 Bring into line with MPLSQ
      IF (MPLFOR(MPNMTB(N),1) .EQ.0) MPLFOR(MPNMTB(N),1)=NFORMF(N)
   21 CONTINUE
   21 CONTINUE
      CALL PFEND(NEW)
C NOW SET UP THE FORM-FACTORS
      CALL SETFOR
      CALL PFOUT
      CALL SYMUNI
      CALL SETGEN(SMAX)
      CALL ERRMES(0,0,'for GETMPL')
C
C  HEADING
      CALL CENTRE(LPT,100,
     & '***** CALCULATION OF STRUCTURE FACTORS ***** ',74)
      LIN=3
      IF (OUTPUT) THEN
        LPT1=NOPFIL(2)
        LIN=LIN+1
        CALL MESS(LPT,0,
     & '                   Structure factors output to '//NAMFIL)
      ENDIF
C
C  NOW GENERATE REFLECTIONS
      CALL MESS(LPT,1,' ')
      WRITE (LPT,VFMT)
      NUM=1
    1 CALL GETGEN(H(1,NUM),ENDREF)
      IF (ENDREF) GO TO 3
      IF (ISPABS(H(1,NUM))) GO TO 1
      SNTH=VCTMOD(0.5,H(1,NUM),2)
      IF (SNTH .LT. SMIN) GO TO 1
      IF (.NOT.LAYER) GO TO 42
      DO 43 N=1,NOPC
      CALL ROTSYM(H(1,NUM),RH,N,2)
      TEST=SCALPR(U,RH)
      IF (ABS(TEST).GT.FLOAT(NL)) GO TO 43
      IF (TEST.LT.0) CALL GMREV(RH,RH,3,1)
      CALL GMEQ(RH,H(1,NUM),3,1)
      GO TO 42
   43 CONTINUE
      GO TO 1
   42 IS(NUM)=JFIX((SNTH+10.*ABS(TEST))*(10**4))
      NUM=NUM+1
%      IF (NUM.LE. %NSFS%) GO TO 1
      WRITE (ITO,3000) SMAX
%3000  FORMAT (' There are more than the allowed maximum of %NSFS%',
     & ' reflections'/' inside the SinTheta/lambda limit of',F7.3)
C
C  SORT ON SINTHETA/LAMDA
    3 NUM=NUM-1
      CALL SORTN(IS,M,NUM)
C
C  AND PRINT OUT RESULTS
      DO 6 N=1,NUM
      J=M(N)
      FC = FMPCAL(H(1,J))
      FMOD = SQRT(REAL(FC*CONJG(FC)))
      SNTH=FLOAT(IS(J))
      SNTH=SNTH/(10**4)
      IF (LAYER) THEN
        TEST=FLOAT(JFIX(SNTH/10.))
        SNTH=SNTH-10.*TEST
      ENDIF
      CALL TESTP(LPT,LIN,1,VFMT,1)
      CALL INDFIX(H(1,J),K)
      IN=MULBOX(H(1,J))
      WRITE (LPT,2007) K,SNTH,FC,FMOD,IN
2007  FORMAT (1X,3I5,4F10.4,I5)
      IF (OUTPUT) WRITE (LPT1,2008) K,FC
2008  FORMAT (3I5,3F10.4)
    6 CONTINUE
      STOP
      END
C
C
C
C
C LEVEL 50      PROGRAM GETMSF
      PROGRAM GETMSF
C
C *** GETMSF documented by PJB  18-Nov-1997 ***
C
C ****************************************************************************
C
C                              G E T M S F
C
C  TO GENERATE INDICES AND CALCULATE AND OUTPUT MAGNETIC AND NUCLEAR
C                          STRUCTURE FACTORS
C
C ****************************************************************************
C
CC 17D
CH To generate magnetic and fundamental reflection indices and calculate the
CH corresponding stucture factors.
C
CD GETMSF generates the indices of all independent magnetic and
CD fundmental reflections within  given limits of \sinth. The
CD calculation may be carried out in layers  perpendicular to a given
CD zone axis, in which case only reflections in layers up to a given
CD layer number are included. The structure factors  of all reflections
CD which lie within the given limits are calculated. Generated
CD reflections are sorted in increasing order of \sinth. If the
CD calculation is being carried out in layers each layer is sorted
CD separately and printed in order of increasing layer number. The
CD indices of magnetic reflections are deduced from the magnetic
CD propagation vector given on a Q PROP card
C
CI The crystal data file must contain all cards needed for magnetic
CI and nuclear structure factor calculations vis:
CI       S cards giving the symmetry.
CI       A C card with the cell dimensions.
CI       A cards defining the atoms, their positions and isotropic
CI       temperature factors.
CI       F cards giving the  magnetic and non-magnetic scattering
CI       factors
CI       Q cards defining the magnetic structure
CI optionally:
CI       T cards giving anisotropic temperature factors
C
CO A listing file which reports the structural data read from the CDF and
CO gives a list of generated reflections, their \sinth\ values the real and
CO imaginary parts A and B of their structure factors and the real and
CO imaginary parts of the three components of the magnetic interaction
CO vector for the fundamental domain. These are followed by the squares of
CO the nuclear and magnetic scattering amplitudes, the total squared
CO scattering amplitude and the reflection multiplicity.
C
CO Optionally an output file containing hkl, A,B, and the the real
CO and imaginary parts of the three components of the magnetic interaction
CO vector for the fundamental domain can also be written. FORMAT (3I5,8F10.4)
CO if the magnetic reflections have integer indices, (3F8.3,8F10.4) if not.
C
CR On running the program the user is asked for the name of the crystal
CR data file, then to choose whether the calculation should be done in
CR layers or just in increasing \sinth. Next the limits in \sinth\ are
CR required. Only the maximum is obligatory, the default minimum is zero. If
CR the calculation is to be done in layers the user will be asked to give
CR the zone-axis symbols and the number of the highest layer to
CR include. Finally the user can choose whether to record the results to file,
CR and if so will be asked to choose a file name.
C
CN For non-centrosymmetric structures FRIE 1 should be given on an I card
CN if Friedel pairs are not to be treated as independent
CN The maximum number of reflections which can be generated is given
CN by the CCSL variable NSFS which has a default of 3000.
C
      EXTERNAL DOMAG1
%      DIMENSION H(3,%NSFS%),IS(%NSFS%),MULT(%NSFS%),M(%NSFS%)
      DIMENSION IU(3),RH(3),U(3),VAL(5),K(3)
      COMPLEX FCALC,FC
      LOGICAL ENDREF,OUTPUT,LAYER,SAYS,LATABS,MAGABS
      CHARACTER*145 VFMT
/BRAGG/
/IOUNIT/
/NSYM/
/QCAL/
/SATELL/
/SCRACH/
      DATA VFMT/' (5X,''h'',4X,''k'',4X,''l'',2X,''Sinth/Lam   Anucl'',
     &4X,''Bnucl    AmagX  BmagX   AmagY  BmagY   AmagZ  BmagZ    FNsqr
     &d   FMsqrd    Fsqrd   Multy''/)'/
C
      LAYER=.FALSE.
      CALL PREFIN('GETMSF')
C  SET UP CRYSTALLOGRAPHY
      CALL SETFCM(DOMAG1)
      CALL MAGCNC
      CALL DOMAG1(2)
      CALL SYMUNI
      CALL ERRMES(0,0,'for GETMSF')
C
      SMIN=0.
  30  CALL ASK('Output reflections in layers or increasing Sin'//
     & 'Theta/lambda? (L or S)')
      LAYER=(SAYS('L'))
      IF (.NOT. SAYS('S') .AND. .NOT. LAYER) GO TO 30
C
   31 CALL ASK('Maximum (& minimum if non-zero) SinTheta/Lambda?')
      CALL RDNUMS(VAL,1,2,N,IER)
      IF (IER.NE.0) GO TO 31
      IF (N .EQ. 1) THEN
        SMAX=VAL(1)
      ELSE
        SMIN=AMIN1(VAL(1),VAL(2))
        SMAX=AMAX1(VAL(1),VAL(2))
        WRITE (LPT,2081) SMIN
2081    FORMAT (' Minimum sin theta/lambda =',F10.4)
      ENDIF
      WRITE (LPT,2080) SMAX
2080  FORMAT (' Maximum sin theta/lambda =',F10.4)
      IF (.NOT. LAYER) GO TO 41
C
   40 CALL ASK('Zone axis symbols & number of highest layer')
      IPT=1
      DO 49 I=1,3
      CALL RDREAL(U(I),IPT,IPT,80,IER)
      IF (IER.NE.0) GO TO 40
   49 CONTINUE
      CALL RDINTG(NL,IPT,IPT,80,IER)
      IF (IER.NE.0) GO TO 40
      CALL INDFIX(U,IU)
      WRITE(LPT,2082) NL,IU
2082  FORMAT (/' Output ',I4,' layers up zone axis',3I5)
C
  41  CALL ASK('Store structure factors on file? Y or N')
      OUTPUT=(SAYS('Y'))
C
      CALL SETGEN(SMAX)
C
      CALL SETGEN(SMAX)
      IF (IPROP.GE.1) THEN
        VFMT(10:10)='6'
        VFMT(17:17)='6'
        VFMT(24:24)='4'
      ENDIF
C
C  NOW GENERATE REFLECTIONS
      TEST=0.
      NUM=1
      MAGREF=2
      IF (IPROP.EQ.0) MAGREF=1
      NFLAG=-9999
      DO 2 IMAG=1,MAGREF
    1 IF (IMAG.EQ.1) THEN
        CALL GENMUL(H(1,NUM),ENDREF,MULT(NUM))
      ELSE
        CALL GENMAG(H(1,NUM),ENDREF,MULT(NUM),SMAX,NFLAG)
      ENDIF
      IF (ENDREF) GO TO 2
      S=VCTMOD(0.5,H(1,NUM),2)
      IF (S .GT. SMAX .OR. S .LT. SMIN) GO TO 1
      IF (.NOT. LAYER) GO TO 42
        DO 43 N=1,NOPC
        CALL ROTSYM(H(1,NUM),RH,N,2)
        TEST=SCALPR(U,RH)
        IF (ABS(TEST).GT.FLOAT(NL)) GO TO 43
        IF (TEST.LT.0) CALL GMREV(RH,RH,3,1)
        CALL GMEQ(RH,H(1,NUM),3,1)
      GO TO 42
   43 CONTINUE
      GO TO 1
   42 IS(NUM)=JFIX((S+10.*ABS(TEST))*(10**4))
      NUM=NUM+1
%      IF (NUM+NKSTAR.LE. %NSFS%) GO TO 1
      WRITE (ITO,3000) SMAX
%3000  FORMAT (' There are more than the allowed maximum of %NSFS%',
     & ' reflections'/' inside the SinTheta/lambda limit of',F7.3)
    2 CONTINUE
C
C  SORT ON SINTHETA/LAMDA
      NUM=NUM-1
      CALL SORTN(IS,M,NUM)
C
C  RESTORE FULL SYMMETRY
      IF (NKSTAR .GT. 1) CALL SYMBAK
C
C  HEADING
      CALL CENTRE(LPT,100,'***** Calculation of Magnetic and '//
     & 'Nuclear Structure Factors ***** ',90)
      LIN=3
      IF (OUTPUT) THEN
        LPT1=NOPFIL(2)
        LIN=LIN+1
        CALL MESS(LPT,0,
     & '                   Structure factors output to '//NAMFIL)
      ENDIF
C
C  AND PRINT OUT RESULTS
      CALL MESS(LPT,1,' ')
      WRITE (LPT,VFMT)
      DO 5 N=1,NUM
      J=M(N)
      DO 6 NN=N+1,NUM
      JJ=M(NN)
      IF (IS(JJ).GT.IS(J)) GO TO 7
      DO 8 I=1,3
      IF (ABS(H(I,J)-H(I,JJ)).GT..0001) GO TO 6
    8 CONTINUE
C MATCH FOUND SKIP
      GO TO 5
    6 CONTINUE
    7 S=FLOAT(IS(J))
      S=S/(10**4)
      IF (LAYER) THEN
        TEST=FLOAT(JFIX(S/10.))
        S=S-10.*TEST
      ENDIF
      STHL=S
      IF (MAGABS(H(1,J),ISS)) THEN
       CALL CGMZER(Q,1,3)
        FMMOD=0.
        FMCSQR=0.
      ELSE
        CALL FMCALC(H(1,J),FMCMOD,FMCSQR)
      ENDIF
      FC=0.
      IF (.NOT.LATABS(H(1,J))) FC=FCALC(H(1,J))
      FNSQR = REAL(FC*CONJG(FC))
      FSQR = FNSQR + FMCSQR
      CALL TESTP(LPT,LIN,1,VFMT,1)
      IN=MULT(J)
      IF (IPROP.LE.0) THEN
        CALL INDFIX(H(1,J),K)
        WRITE (LPT,2007) K,S,FC,(Q(I,1),I=1,3),FNSQR,FMCSQR,FSQR,IN
2007    FORMAT (1X,3I5,3X,F8.4,2X,2F7.3,2X,3(2F7.3,1X),3(1X,F8.2),2X,I5)
        IF (OUTPUT) WRITE (LPT1,2008) K,FC,(Q(I,1),I=1,3)
2008    FORMAT (3I5,8F10.4)
      ELSE
        WRITE (LPT,2010)(H(I,J),I=1,3),S,FC,(Q(I,1),I=1,3),FNSQR,
     &  FMCSQR,FSQR,IN
2010    FORMAT (1X,3F7.3,2X,F8.4,2X,2F7.3,2X,3(2F7.3,1X),3(1X,F8.2)
     &  ,2X,I5)
        IF (OUTPUT) WRITE (LPT1,2011) (H(I,J),I=1,3),FC,(Q(I,1),I=1,3)
2011    FORMAT (3F8.3,8F10.4)
      ENDIF
    5 CONTINUE
      STOP
      END
C
C
C
C
C LEVEL 50      PROGRAM GETSFZ
      PROGRAM GETSFZ
C
C *** GETSFZ updated by PJB  18-Nov-1997 ***
C
C ****************************************************************************
C
C                              G E T S F Z
C
C  TO GENERATE INDICES AND CALCULATE AND OUTPUT STRUCTURE FACTORS
C
C ****************************************************************************
C
CC 4D
CH To generate reflection indices and calculate the corresponding stucture
CH factors.
C
CD GETSFZ generates the indices of all independent reflections within
CD given limits of \sinth. The calculation may be carried out in layers
CD perpendicular to a given zone axis, in which case only reflections in
CD layers up to a given layer number are included. The structure factors
CD of all reflections which lie within the given limits are calculated.
CD Generated reflections are sorted in increasing order of \sinth. If
CD the calculation is being carried out in layers each layer is sorted
CD separately and printed in order of increasing layer number.
C
CI The crystal data file must contain all cards needed for structure
CI factor calculations vis:
CI       S cards giving the symmetry
CI       A C card with the cell dimensions
CI       A cards defining the atoms, their positions and isotropic
CI       temperature factors
CI       F cards giving the scattering factors
CI  optionally:
CI    T cards giving anisotropic temperature factors
C
CO A listing file which reports the structural data read from the CDF and
CO gives a list of generated reflections, their \sinth\ values the real and
CO imaginary parts A and B of their structure factors, the modulus of the
CO structure factor \$|F_c|\$ and the multiplicity of the reflection.
C
CO Optionally an output file containing hkl, A,B, and \$|F_c|\$ in
CO format (3I5,3F10.4) can also be written.
C
CR On running the program the user is asked for the name of the crystal
CR data file, then to choose whether the calculation should be done in
CR layers or just in increasing \sinth. Next the limits in \sinth\ are
CR required. Only the maximum is obligatory, the default minimum is zero.
CR If the calculation is to be done in layers the user will be asked to give
CR the zone-axis symbols and the number of the highest layer to include.
CR Finally the user can choose whether to record the results to file, and if
CR so will be asked to choose a file name.
C
CN For non-centrosymmetric structures FRIE 1 should be given on an I card
CN if Friedel pairs are not to be treated as independent.
CN The maximum number of reflections which can be generated is given by the
CN CCSL variable NSFS which has a default of 3000.
C
      COMPLEX FCALC,FC
      LOGICAL ENDREF,OUTPUT,LAYER,ISPABS,SAYS
      CHARACTER*1 IREP
      CHARACTER*100 VFMT
/IOUNIT/
/NSYM/
/SCRACH/
%      COMMON/SCRAT/K(3),H(3,%NSFS%),IS(%NSFS%),M(%NSFS%),IU(3),
     & U(3),RH(3),VAL(5)
      DATA VFMT/'(''     h    k    l  Sinth/Lam       A         B
     & Fcalc   Multpcy''/)'/
C
      CALL PREFIN('GETSFZ')
      CALL SETFC
      CALL SYMUNI
      CALL ERRMES(0,0,'To GETSFZ')
C
      SMIN=0.
  30  CALL ASK('Output reflections in layers or increasing Sin'//
     & 'Theta/lambda? (L or S)')
      IREP=ICARD(1:1)
      LAYER=(SAYS('L'))
      IF (.NOT. SAYS('S') .AND. .NOT. LAYER) GO TO 30
C
   31 CALL ASK('Maximum (& minimum if non-zero) SinTheta/Lambda?')
      CALL RDNUMS(VAL,1,2,N,IER)
      IF (IER.NE.0) GO TO 31
      IF (N .EQ. 1) THEN
        SMAX=VAL(1)
      ELSE
        SMIN=AMIN1(VAL(1),VAL(2))
        SMAX=AMAX1(VAL(1),VAL(2))
        WRITE (LPT,2081) SMIN
2081    FORMAT (' Minimum sin theta/lambda =',F10.4)
      ENDIF
      WRITE (LPT,2080) SMAX
2080  FORMAT (' Maximum sin theta/lambda =',F10.4)
      IF (.NOT.LAYER) GO TO 41
C
   40 CALL ASK('Zone axis symbols & number of highest layer')
      IPT=1
      DO 49 I=1,3
      CALL RDREAL(U(I),IPT,IPT,80,IER)
      IF (IER.NE.0) GO TO 40
   49 CONTINUE
      CALL RDINTG(NL,IPT,IPT,80,IER)
      IF (IER.NE.0) GO TO 40
      CALL INDFIX(U,IU)
      WRITE(LPT,2082) NL,IU
2082  FORMAT (/' Output ',I4,' layers up zone axis',3I5)
C
  41  CALL ASK('Store structure factors on file? Y or N')
      OUTPUT=(SAYS('Y'))
C
      CALL SETGEN(SMAX)
C
C  HEADING
      CALL CENTRE(LPT,100,
     & '***** CALCULATION OF STRUCTURE FACTORS ***** ',75)
      LIN=3
      IF (OUTPUT) THEN
        LPT1=NOPFIL(2)
        LIN=LIN+1
        CALL MESS(LPT,0,
     & '                   Structure factors output to '//NAMFIL)
      ENDIF
C
C  NOW GENERATE REFLECTIONS
      CALL MESS(LPT,1,' ')
      WRITE (LPT,VFMT)
      NUM=1
    1 CALL GETGEN(H(1,NUM),ENDREF)
      IF (ENDREF) GO TO 3
      IF (ISPABS(H(1,NUM))) GO TO 1
      S=VCTMOD(0.5,H(1,NUM),2)
      IF (S .LT. SMIN) GO TO 1
      IF (.NOT.LAYER) GO TO 42
      DO 43 N=1,NOPC
      CALL ROTSYM(H(1,NUM),RH,N,2)
      TEST=SCALPR(U,RH)
      IF (ABS(TEST).GT.FLOAT(NL)) GO TO 43
      IF (TEST.LT.0) CALL GMREV(RH,RH,3,1)
      CALL GMEQ(RH,H(1,NUM),3,1)
      GO TO 42
   43 CONTINUE
      GO TO 1
   42 IS(NUM)=JFIX((S+10.*ABS(TEST))*(10**4))
      NUM=NUM+1
%      IF (NUM.LE. %NSFS%) GO TO 1
      WRITE (ITO,3000) SMAX
%3000  FORMAT (' There are more than the allowed maximum of %NSFS%',
     & ' reflections'/' inside the SinTheta/lambda limit of',F7.3)
C
C  SORT ON SINTHETA/LAMDA
    3 NUM=NUM-1
      CALL SORTN(IS,M,NUM)
C
C  AND PRINT OUT RESULTS
      DO 6 N=1,NUM
      J=M(N)
      FC = FCALC(H(1,J))
      FMOD = SQRT(REAL(FC*CONJG(FC)))
      S=FLOAT(IS(J))
      S=S/(10**4)
      IF (LAYER) THEN
        TEST=FLOAT(JFIX(S/10.))
        S=S-10.*TEST
      ENDIF
      CALL TESTP(LPT,LIN,1,VFMT,1)
      CALL INDFIX(H(1,J),K)
      IN=MULBOX(H(1,J))
      WRITE (LPT,2007) K,S,FC,FMOD,IN
2007  FORMAT (1X,3I5,4F10.4,I5)
      IF (OUTPUT) WRITE (LPT1,2008) K,FC,FMOD
2008  FORMAT (3I5,3F10.4)
    6 CONTINUE
      STOP
      END
C
C
C
C
C LEVEL 50      PROGRAM GPCARD
      PROGRAM GPCARD
C
C *** GPCARD updated by JCM 10 May 88 ***
C
C **************************************************************************
C
C                           G P C A R D
C
C  PROGRAM TO WRITE THE M AXES, AND M MESH CARDS FOR A GENERAL PLANE
C  FOURIER SECTION TO PASS THROUGH THREE NAMED ATOMS.
C
C **************************************************************************
C
      CHARACTER*4 WORD,MAPWRD(3)
      DIMENSION AX(3,3),V(3,3),RX(3,3),AMSH(3,2)
/CARDRC/
/IOUNIT/
/POSNS/
/SYMDA/
/SCRACH/
      DATA AMSH /-.5,1.5,.05,-.5,1.5,.05/
      DATA MAPWRD /'PRIN','SAVE','PLOT'/
C
      CALL PREFIN('GPCARD')
      CALL SYMOP
      CALL OPSYM(1)
      CALL RECIP
      CALL ATOPOS
C
      DO 1 IT=1,3
    2 WRITE (ITO,500) IT
  500 FORMAT (' Give name and operator number for atom number',I3,': ')
      READ (ITI,501) ICARD
  501 FORMAT (A80)
      CALL RDWORD(WORD,LWRD,1,IPT,5,0,IER)
      IF (IER.NE.0) THEN
        WRITE (ITO,502) ICARD
  502   FORMAT (' Illegal format: '/1X,A80)
        GO TO 2
      ENDIF
      CALL RDINTG(NUM,IPT,IPT2,80,IER)
      IF (IER.NE.0) THEN
        IF (IER .NE.100) THEN
          WRITE (ITO,502) ICARD
          GO TO 2
        ELSE
          NUM=1
        ENDIF
      ENDIF
      IAT=IATOM(WORD)
      IF (IAT.EQ.0) THEN
        CALL ERRATM(WORD,-1,' ')
        GO TO 2
      ENDIF
      IF (NUM.LT.0) CALL GMREV(X(1,IAT),X(1,IAT),3,1)
      CALL ROTSYM(X(1,IAT),RX(1,IT),IABS(NUM),1)
      CALL GMADD(RX(1,IT),TRANS(1,IABS(NUM)),RX(1,IT),3,1)
      WRITE (LPT,505) IT,(RX(I,IT),I=1,3)
  505 FORMAT (/' Coordinates of atom',I3,2X,3F8.4)
    1 CONTINUE
C
C  NOW MAKE UP AXES
      DO 3 I=1,2
      CALL GMSUB(RX(1,I+1),RX(1,1),AX(1,I),3,1)
      CALL ORTHO(AX(1,I),V(1,I),1)
    3 CONTINUE
      CALL UNIVEC(V(1,1),D)
      CALL VECPRD(V(1,1),V(1,2),V(1,3))
      CALL VECPRD(V(1,3),V(1,1),V(1,2))
      CALL ORTHO(V(1,2),AX(1,2),-1)
      CALL ORTHO(V(1,3),AX(1,3),-1)
C
C  GET THE INVERSE MATRIX AND TRANSFORMED ORIGIN
      CALL GMEQ(AX,V,3,3)
      CALL TRINV3(V,D)
      CALL GMPRD(RX(1,1),V,RX(1,2),1,3,3)
      DO 5 I=1,2
      AMSH(1,I)=AMSH(1,I)+RX(I,2)
    5 AMSH(2,I)=AMSH(2,I)+RX(I,2)
      ZVAL=RX(3,2)
C
C  REPORT RESULTS
      WRITE (LPT,506) AX,(RX(I,2),I=1,3),AMSH,ZVAL
  506 FORMAT (/' Axes of map: ',3F8.4/2(14X,3F8.4/)
     & /' Transformed origin :',3F8.4//
     &' Mesh for map on transformed axes :',3F8.4/35X,3F8.4//
     &' z value for section :',F8.4)
C  NOW PREPARE TO WRITE THE CARDS
C
C  FIRST FIND IF M MESH OR M AXES EXIST
      IB=IABS(INREAD(13))
      IN=ICDNO(13)
      IF (IN.NE.0) THEN
        CALL FINDCD('M','MESH',4,0,LMSH)
        CALL FINDCD('M','AXES',4,0,LAX)
        IF (LMSH.NE.0) LMSH=LMSH+IB-1
        IF (LAX.NE.0) LAX=LAX+IB-1
      ELSE
        IB=1
      ENDIF
C
      ICARD='Modified crystal data file'
      ICARD(41:)='.CRY'
      LUNI=NOPFIL(112)
C
      ID=1
  21  READ (IO10,REC=ID,FMT=514) ICARD
  514 FORMAT (A80)
      IF (ID.EQ.IB) THEN
        WRITE (LUNI,510) AMSH
  510   FORMAT ('M MESH',6F10.4)
        WRITE (LUNI,511) AX
  511   FORMAT ('M AXES',9F8.4)
      ELSE
        IF (ID.EQ.LAX .OR. ID.EQ.LMSH) GO TO 22
        IF (ID.LT.IB .OR. ID.GE.IB+IN) GO TO 24
        CALL RDWORD(WORD,LWRD,2,IPT,6,0,IER)
        DO 26 I=1,3
        IF (WORD.NE.MAPWRD(I)) GO TO 26
        WRITE (LUNI,513) WORD,ZVAL
  513   FORMAT ('M ',A4,F10.4)
        GO TO 22
   26   CONTINUE
      ENDIF
C
   24 L=LENG(ICARD,80)
      WRITE (LUNI,512) (ICARD(I:I),I=1,L)
  512 FORMAT (80A1)
   22 ID=ID+1
      IF (ID .LE. NTOTAL(1)) GO TO 21
C
  100 STOP
      END
C
C
C
C
C LEVEL 50      PROGRAM GRAFIC
      PROGRAM GRAFIC
C
C *** GRAFIC divided between device dependent and independent parts Dec 2016 ***
C
C ****************************************************************************
C
C                       G R A F I C
C
C MAIN PROGRAM GRAFPG Quick and easy general purpose graphing program
C
C ****************************************************************************
C
CC 14D
CH  Quick and easy general purpose graphing program
C
CD Program to draw scatter graphs and curves from tables of numbers
CD Device dependent output is done by appropriate GRAFDV subroutines
CD in the plotter libraries
C
CI A Table or tables of numbers some of which are to be plotted
CI A header is prefixed to the table to indicate what to plot. It should
CI contain the lines:
CI Title  Text which will be used as a title for the graph
CI (see the PGPLOT manual to insert greek chatacters, subscripts etc)
CI Xaxis  Label for the x-axis
CI Yaxis  Label for the y-axis
CI Range  xmin xmax ymin ymax
CI      the ranges of values in x and y to be plotted. If range is not given
CI      the program will try to choose a suitable one.
CI Then for each set of y-values in the table which follows
CI Point  n1 n2  red circle filled
CI      The first number (n1) identifies the set of y-values, and the second
CI      (n2) is a multiplier for the symbol size. The remaining text describes
CI      the graph markers. The options for colours are :
CI       black, red, green, blue, orange, magenta, azure and gold
CI      The options for the shape are:
CI       circle, square, triangle, star','plussign, time(egg timer) and asterix'
CI      The words are recognised independent of case; only the first four
CI      characters are significant. The shapes: circle, square, triangle, star
CI      and time may be "filled" or "open".
CI Some symbols are not available with some devices:the nearest substitute will be used
CI      will be used
CI The line which immediately preceeds a table for a scatter plot should be:
CI Datap  nc ix idx iy1 idy1 iy2 idy2 ........
CI      nc   is the number of columns in the table they should be separated by
CI           spaces or commas (not tabs).
CI      ix   is the number of the column containing the x values
CI           idx is the number of the column containing the esd's in x or
CI           0 if error bars in x are not required
CI      for each set of y values
CI      iyn  is is the number of the column containing these y values
CI      idyn is the number of the column containing the esd's in y or
CI      0 if error bars in these y's are not required.
CI To plot curves the table giving the points to be joined should be preceeded
CI by lines describing the type of line to draw:
CI Cline: n iw colour type
CI    n identifies to which curve in the next table it applies
CI    iw is an integer which fixes the width of line to be drawn (the graph
CU    axes have width 2)
CI    the allowed "colours" for lines are the same as for graph markers.
CI    the "type" of line is one of: full, dashed, dado(dash dot), dotted,
CI    or dadd(dash dot dash)
CI The line which immediately preceeds a table giving points on a curve (or
CI line) should be :
CI Curve: nc ix iy1 iy2  ........
CI      nc, ix and iyn have the same meanings as for Datap (see above)

C
CO A postscipt file named GRAFIC_yyyyyXX.ps, where yyyyy is taken from the
CO data file name XX are two digits chosen by the
CO program) will be created if a "hard copy" is asked for.
C
CR On running the program the user is asked for the name of the data file.
CR Then to choose between Tectronix or X for screen output. Finally the
CR option is given to save a postscript version of the plotted graph.
C
      PARAMETER (MAXSET=20,MAXBLK=10,MXVALS=20,IIMAX=MXVALS/2)
      EXTERNAL GFDEFS
      DIMENSION VMAX(2),VMIN(2),ALIM(4),LL(3),A(MXVALS),ii(IIMAX),
     &SYMSIZ(MAXSET),NVALS(2,MAXBLK),IDX(2,MAXBLK),IDY(2,MAXSET),
     &ISYM(MAXSET),ICOL(MAXSET),IPLOT(MAXBLK)
      CHARACTER*20 dtitle(maxset)
      LOGICAL SAID,START,FIRST,NOLIM,INDAT,LERCHK
      CHARACTER *10 WORD
      CHARACTER *80 TEXT(3)
      CHARACTER *5 WORDS(8),KEYWRD
/IOUNIT/
/GFWRDS/
/GFNUMS/
/SCRACH/
/WHEN/
C
C      DATA LSYMB/4,6,7,12,2,5,3/
C      DATA MSYMB/17,16,13,18/
      DATA WORDS/'TITLE','XAXIS','YAXIS','RANGE','DATAP','CURVE',
     &'POINT','CLINE'/
C
      CALL INITIL('GRAFIC')
      CALL JGMZER(ISYM,MAXSET,1)
      CALL JGMZER(ICOL,MAXSET,1)
      CALL GMZER(SYMSIZ,MAXSET,1)
      MXSETS=0
C Open A TEMPORARY file to hold DATA
      MESSAG='grafda.dat'
      LDAT=NOPFIL(226)
      NSET = 0
      NBLK=0
      INDAT = .FALSE.
      START =.TRUE.
      FIRST =.TRUE.
      CALL JGMZER(IPOINT,20,1)
      JSYM = 0
C READ DATA
      LUNI=NOPFIL(1)
    1 READ (LUNI,10,END=2) ICARD
C SKIP BLANK LINES
      IF (LENGT(ICARD).LT.2) GO TO 1
   10 FORMAT(A80)
      CALL RDWORD(KEYWRD,LEN,1,IPT,8,0,IER)
      IF (IER.EQ.0) THEN  ! Keyword read
        IF (INDAT) THEN
          INDAT = .FALSE.
C Write a blank line on LDT to mark end of BLOCK
           write (ldat,10)''
C New data set
         ENDIF
        CALL UPONE(KEYWRD,1)
        NC=NCFIND(KEYWRD,WORDS,8)
        GO TO (20,20,20,21,22,22,24,24),NC
        GO TO 1
      ENDIF
      IF (INDAT) GO TO 3
      GO TO 1
C
C TO READ DATA LINES
    3 NVLS=NVALS(1,NBLK)
      call ERRCHK(1,NVLS,MXVALS,0,
     &'Values on data line, increase MXVALS')
      CALL RDNUMS(A,1,NVLS,NUM,IER)
      IF (IER.NE.0 .OR. NUM.NE.NVLS) THEN
        CALL ERRMES(1,1,'Error reading data')
        GO TO 2
       ENDIF
C      WRITE (ITO,10) ICARD
      write (ldat,10) icard
      if (nolim) then
C To check the range
        if (START) then
          vmax(1)=a(idx(1,NBLK))
          vmin(1)=a(idx(1,NBLK))
          vmax(2)=a(idy(1,NSET))
          vmin(2)=a(idy(1,NSET))
          START=.false.
        else
          vmin(1)=amin1(vmin(1),a(idx(1,NBLK)))
          vmax(1)=amax1(vmax(1),a(idx(1,NBLK)))
        endif
        DO 4 I=3,NVLS,2
         vmin(2)=amin1(vmin(2),a(idy(1,NSET)))
         vmax(2)=amax1(vmax(2),a(idy(1,NSET)))
    4   continue
      endif
      GO TO 1
C
C READ TITLE AND AXIS LABELS
   20 LL(NC)=LENGT(ICARD)
      IF (LL(NC).GE.IPT) THEN
        TEXT(NC)=ICARD(IPT:LL(NC))
        LL(NC)=LL(NC)-IPT+1
      ELSE
        LL(NC) = 0
      ENDIF
      GO TO 1
C
C READ RANGE
   21 CALL RDNUMS(ALIM,IPT,4,NUM,IER)
      NOLIM=(IER.EQ.100 .OR. NUM.NE.4)
      GO TO 1
C
C READ DATA FORMAT
   22 IPLOT(NBLK)=NC-4 ! datap or curve
      IP=7-NC
      NV=IP*(NVALS(2,NBLK)+1)+1
      DO 23 I=1,NV
        CALL RDINTG(II(I),IPT,IPT,IPT+10,IER)
        IF (IER.EQ.100) THEN
          call errin2(NV,1,'Not enough data values','expected')
        ELSE IF (IER.NE.0) THEN
          CALL ERRMES(1,1,'Reading data format')
          go to 2
        endif
   23 CONTINUE
      NVALS(1,NBLK) = II(1)
      call jgmeq(ii(2),IDX(1,NBLK),IP,1)
      if (ip.eq.1) IDX(2,NBLK) =0
      IFST=2+IP
      DO 25 I=IFST,NV,IP
         nset=nset+1
        CALL JGMEQ(II(I),IDY(1,NSET),IP,1)
        if (ip.eq.1) IDY(2,NSET) =0
   25 CONTINUE
C  Now expect data table
      INDAT=.TRUE.
      first=.TRUE.
      GO TO 1
C
C READ SYMBOLS and COLOURS for points and lines
   24 if (FIRST)  THEN    ! first set in new data block
        IF (.NOT. LERCHK(2,NBLK,MAXBLK,-1,'DATA BLOCKS')) GO TO 26
        NVALS(2,NBLK)=0   ! to count the number of sets in the block
        JSYM=NSET
        FIRST=.FALSE.
      endif
      NVALS(2,NBLK)=NVALS(2,NBLK)+1
      IF (.NOT. LERCHK(2,JSYM,MAXSET,-1,'DATA SETS')) then
        call errin2(JSYM,1,'Number of sets','too large')
        go to 26
      endif
      CALL RDINTG(JSY,IPT,IPT1,IPT+10,IER)
      IF (IER.NE.0) go to 26
      ipt=ipt1
      JSYM = NSET+JSY
      CALL RDREAL(SYMSIZ(JSYM),IPT,IPT1,IPT+10,IER)
      IF (IER.NE.0) go to 26
      ipt=ipt1
      CALL RDWORD(WORD,LEN,IPT,IPT1,IPT+10,0,IER)
      IF (IER.NE.0) GO TO 26
      L = LGFCOL(WORD)
      IF (L.EQ.0) GO TO 26
C save the grafic color number
      ICOL(JSYM) = L
      ipt=ipt1
      CALL RDWORD(WORD,LEN,IPT,IPT,IPT+10,0,IER)
      IF (IER.NE.0) GO TO 26
      IF (NC.EQ.7) THEN
        L = LGFSYM(WORD)
          CALL RDWORD(WORD,LEN,IPT,IPT,IPT+10,0,IER)
          IF (IER.NE.0) go to 26
C Add 100 for filled symbol first 3 symbols are not fillable
         IF (L.GT.3) THEN
           IF (SAID(WORD(1:4),'fill'))  L=L+100
        ENDIF
        ISYM(JSYM)=L
      ELSE
        L = NCFIND(WORD(1:4),GFLSTY,NGFLS)
        IF (L.EQ.0) THEN
          write (ito,1001) WORD(1:4),(GFLSTY(i),i=1,NGFLS)
 1001    format ('Looking for ',a, ' in'/(15(a,2x)))
          GO TO 26
        ENDIF
        ISYM(JSYM) = L
      ENDIF
C Remaining characters on ICARD give the set title truncated to 20 chars
      l= lengt(Icard)-ipt
      if (l.gt.19)  l=19
      dtitle(jsym)=icard(ipt:ipt+l)
      go to 1
   26 CALL ERRMES(1,-1,'Reading point or line description '//word)
      write (ito,10) ICARD
      GO TO 1
C
C END OF DATA: FIND MAX AND MIN VALUES
    2 CALL ERRMES(0,0,'to GRAFPG')
      NSETS=NSET
      NBLKS=NBLK
      IF (NOLIM) THEN
C open up max and min values a bit
        EX=(VMAX(I)-VMIN(I))*.05
        ALIM(1)=VMIN(1)-EX
        ALIM(2)=VMAX(1)+EX
        ALIM(3)=VMIN(2)-EX
        ALIM(4)=VMAX(2)+EX
C Else use the values given by RANGE
      ENDIF
C Call the subroutine to drive the chosen grafic device
C (currently pgplot or gnuplot)
      call grafdv(LDAT,NSETS,NBLKS,TEXT,ALIM,ISYM,SYMSIZ,
     &ICOL,NVALS,IDX,IDY,IPLOT,dtitle)
      STOP
      END
C
C
C
C
C LEVEL 50      PROGRAM GRLSQ
      PROGRAM GRLSQ
C
C *** GRLSQ updated by PJB C!)% April 2001 ***
C
C ******************************************************************************
C
C                       G R L S Q
C
C
C MAIN PROGRAM GRLSQ FOR STRUCTURE FACTOR LEAST SQUARES REFINEMENT WITH
C POSSIBLE EXTINCTION CORRECTIONS, TAKING GROUPS OF CALCULATED VALUES TO EACH
C OBS.
C
C ******************************************************************************
C
      CHARACTER *4 ISFWRD(29)
      LOGICAL PRNCYC,ONCARD
      LOGICAL DFLTSF,LDUMMY
      EXTERNAL DFLTSF,LDUMMY,PARRUN,VARSSF
%      DIMENSION ALSQ(%MATS%),ISWDSP(3,29)
      DIMENSION K(3),H(3)
/DERVAR/
/EXTN/
/FCAL/
/IOUNIT/
/NEWOLD/
/NSYM/
/OBSCAL/
/POSNS/
/PRBLEM/
/REFINE/
/SCLDAT/
** NB UPDATE LIKE SFLSQ TO USE XYZB,XYZS FACILITIES
      DATA ISFWRD/' ','SCAL','TFAC','X','Y','Z',
     & 'B11','B22','B33','B23','B13',
     & 'B12','SCAT','SITE','ITF',
     & 'XYZ','BIJ','XYZT','FAM1',
     & 'FAM2','DOMR','MOSC','CELL','A*','B*','C*',
     & 'D*','E*','F*'/
      DATA ISWDSP/1,1,0, 1,2,0, 1,1,1, 2,0,1, 2,0,2, 2,0,3,
     & 2,0,4, 2,0,5, 2,0,6, 2,0,7, 2,0,8,
     & 2,0,9, 2,0,10, 2,0,11, 2,0,12,
     & -1,0,0, -2,0,0, -3,0,0, 1,0,0,
     & 2,0,0, 1,1,8, 1,1,9, -4,0,0, 1,1,2, 1,1,3, 1,1,4,
     & 1,1,5, 1,1,6, 1,1,7/
C
C ALTER VALUE HERE IF NECESSARY:
%      MATSZ=%MATS%
C
C SET UP STRUCTURE FACTOR CALCULATION:
      CALL PREFIN('GRLSQ')
      MAG=.FALSE.
      CALL SETFC
      CALL SYMUNI
C
C SPECIFY PROBLEM:
      NFAM=2
      NGENS(1)=2
      NGENS(2)=NATOM
      NSPC(1)=20
      NSPC(2)=12
C
C SPECIES TYPES FOR EACH GENUS OF FAMILY 1:
      LF1SP(1)=9
      LF1SP(2)=-20
C
C WORDS RELEVANT TO THIS PROBLEM FROM DATA INTO COMMON:
      CALL LSETUP(29,ISWDSP,ISFWRD)
C NAMES SET UP SO THAT:
C FAMILY 1 GENUS 1 HAS SPECIES TFAC, DOMR, MOSC (WITH POSSIBILITIES
C FOR SLACK GEOMETRIC CONSTRAINTS, AND THEREFORE REFINEMENT OF
C A* ETC.)
C FAMILY 1 GENUS 2 HAS GENUS NAME SCAL, SPECIES INDICATED TO BE 1,2,3 ETC
C
C FAMILY 2 IS AS USUAL THE PARAMETERS WHICH DEPEND ON THE ATOM.  GENUS NAMES
C ARE THEREFORE THE SAME AS ATOM NAMES, AND SPECIES NAMES ARE:
C X Y Z B11 B22 B33 B23 B13 B12 SCAT SITE ITF
C
      CALL CENTRE(LPT,3,'Least Squares Refinement',80)
      CALL CENTRE(LPT,0,'Grouped structure factor program',80)
C READ I AND (MOST) L CARDS:
      CALL STLSSF
C READ E CARD:
      CALL EXTINC(1,0.)
C "PRIN" ON I CARD MEANS "PRINT OBS V CALC LIST" - FIND ALSO
C "PRFC" TO MEAN "PRINT EACH FC AS CALCULATED":
      IF (ONCARD('I','PRFC',P)) THEN
C
C PRFC:
        IPRNT(2)=JFIX(P)
        CALL MESS(LPT,1,'Printing of Fcs wanted')
        CALL DEPRIN(IPRNT(2))
      ENDIF
C
C SET UP PARAMETERS AS VARIABLES:
C THE SAME 'PARS' ROUTINE AS FOR SFLSQ AND EXLSQ  WILL DO:
      CALL PARSSF(LDUMMY)
C
C FOR NOW, MAKE VARIABLES ONCE AND FOR ALL:
      CALL VARMAK(DFLTSF,PARRUN,VARSSF,LDUMMY)
C
C READ OBS DATA AND SEND OUT TO TEMPORARY UNIT FOR REINPUT EACH CYCLE:
      CALL INOBGR(ISCR)
C
      DONE=.FALSE.
      DO 1 ICYC=NCYC1,LASTCY
C IS PRINTING OF INTENSITY LIST REQUESTED THIS CYCLE?
      IF (PRNCYC(1)) THEN
        CALL MESS(LPT,2,'Intensity listing :')
        CALL MESS(LPT,0,'        G(obs)      G(calc)      Diff   '//
     &  'No. of Fc      Scale    Weight')
      ENDIF
      IF (PRNCYC(2)) THEN
        WRITE (LPT,2000)
2000    FORMAT (/78X,' Fc Listing:')
        IF (.NOT. CENTRC) THEN
          WRITE (LPT,2001)
2001      FORMAT (75X,'    h    k    l       A     B    ',
     &    'Fc mod     G calc')
        ELSE
          WRITE (LPT,2002)
2002      FORMAT (75X,'    h    k    l     Fc      G calc')
        ENDIF
      ENDIF
C
C INITIALISE R FACTOR SUMS:
      CALL RFACS(1)
C SET UP POINTERS IN TRIANGULAR MATRIX AND CLEAR OUT LSQ MATRIX AND RHS:
      CALL MATSET(ALSQ,MATSZ)
C
C COUNT USED OBSERVATIONS (THERE IS NOT AT PRESENT ANT WAY OF NOT USING ONE)
      NOBS=0
      REWIND ISCR
C
C INOBGR HAS TURNED THE VARIOUS FORMATS FOR INPUT INTO ONE, WITH THE OPTION
C THAT IF MODER=5 CEXT() HAVE ALSO BEEN WRITTEN
C
   2  READ (ISCR,END=3) NK,OBS,DOBS,ISCALE,ICODE
      IF (MODER .EQ. 5) READ(ISCR,END=3) CEXT
C PUT ISCALE WITHIN PERMITTED RANGE:
      IF ((ISCALE .EQ. 0) .OR. (ISCALE .GT. NSCALE)) ISCALE=1
      YCALC=0.
      IF (LVARV .GT. 0) CALL GMZER(DERIVV,1,LVARV)
C
C CALCULATE FUNCTION TO MATCH OBSERVED, AND ITS DERIVATIVES:
C CYCLE OVER NK SETS OF H,K,L:
      DO 39 I=1,NK
      READ(ISCR) K,FAC
      CALL INDFLO(H,K)
      CALL CALCGR(H,FAC)
C CALCGR FORMS GCALC,  PUTS DG/DV INTO DERIVV FOR ALL VARIABLES, AND SETS UP
C ALL REQUIRED QUANTITIES IN OBSCAL FOR SUBSEQUENT CALLS OF MATREF AND RFACS
      IF (PRNCYC(2)) THEN
        IF (.NOT. CENTRC) THEN
          WRITE (LPT,2011) K,FC,FCMOD,GCALC
2011      FORMAT (55X,3I5,4F12.4)
        ELSE
          WRITE (LPT,2011) K,REAL(FC),GCALC
        ENDIF
      ENDIF
C
  39  CONTINUE
C
C THIS IS SO THAT WE CAN USE EXISTING RFACS:
      GCALC=YCALC
C MAKE DERIVATIVES WRT BASIC VARIABLES FROM THOSE WRT VARIABLES:
      CALL RELATE
C
C DIFFERENCES AND WEIGHTS:
      DIFF = OBS - GCALC
      CALL WGHTSF
C GETS WEIGHT AND SQRTWT INTO COMMON
C
C INTENSITY LISTING IF REQUIRED:
      IF (PRNCYC(1)) WRITE (LPT,2003) OBS,GCALC,DIFF,NK,
     & SCALE(ISCALE),WT
2003  FORMAT (' ',2F14.3,F14.4,I5,2F14.4)
C
C ADD IN TO R FACTORS:
      CALL RFACS(2)
C
C ADD DERIVATIVES IN TO LSQ MATRIX:
      CALL MATTOT(ALSQ,MATSZ)
      NOBS=NOBS+1
C
C NEXT OBSERVATION:
      GO TO 2
C
C HERE ON NO MORE OBSERVATIONS - PRINT R FACTORS:
   3  CALL RFACS(3)
C
C INVERT MATRIX, CALCULATE SHIFTS AND ESD'S; APPLY AND PRINT:
      CALL MATINV(ALSQ,MATSZ)
      CALL MATSHF(ALSQ,MATSZ)
      CALL APSHSF(LDUMMY)
C ON PENULTIMATE CYCLE PRODUCE NEW CRYSTAL DATA FILE:
      IF (DONE) GO TO 38
      DONE=(AMAXSH.LT.CONV .OR. ICYC.EQ.LASTCY-1 .OR. NCYC.EQ.1)
      IF (DONE) CALL NWINSF(LDUMMY)
   1  CONTINUE
C
C PRINT CORRELATION MATRIX:
  38  CALL MATCOR(ALSQ,MATSZ)
 100  STOP
      END
C
C
C
C
C LEVEL 50      PROGRAM GRPCNV
      PROGRAM GRPCNV
C
C *** GRPCNV BY WTAH, UPDATED BY JCM 27 MAR 90 ***
C
C ******************************************************************************
C
C                           G R P C N V
C
C ******************************************************************************
      DIMENSION NA(20),XC(3,2)
      CHARACTER RSYM(24)*25,ALAB(150)*6,LTT(4)*9,ATOMLAB*6,PRGTYP*3,
     * TLAB(20)*2,LAB*2,CCENT*8,FILNOM*10,FNAM*10
      CHARACTER*1 OCENT,LTYP,SGN,DEN,NUM,LATT
/ANISO/
/ATNAM/
/CELPAR/
/FINAME/
/IOUNIT/
/NSYM/
/NTITL/
/POSNS/
/SYMDA/
/TITLE/
/SCRACH/
      CHARACTER AXIS(3)*1
      DATA AXIS/'X','Y','Z'/
C
*-------------------  INITIALISE READING OF CARDS
      CALL PREFIN('GRPCNV')
C
*-------------------  STORE FILE NAME (NO EXTENSION)
      FNAM=FILNAM(2)
      NDOT=INDEX(FNAM,'.')
      FNAM(NDOT:)=' '
C
*-------------------     TITLE CARD
      CALL INPUTN(LPT)
C
*-------------------     CELL CARD
      CALL RECIP
      DO 5 I=1,3
      XC(I,1)=CELL(I,1,1)
      XC(I,2)=DEGREE(ACOS(CELL(I,2,1)))
5     CONTINUE
C
*-------------------  SYMMETRY CARDS
      CALL SYMOP
      DO 10 I=1,NOPC
      NCHR=0
      RSYM(I)=' '
      DO 20 J=1,3
* CONVERT TO CHARACTERS
      DO 30 K=1,3
      IF (ABS(SYM(K,J,I)).GT.0.01) THEN
        IF (SYM(K,J,I).LT.0.0) THEN
          NCHR=NCHR+1
          RSYM(I)(NCHR:NCHR)='-'
        ELSE IF (NCHR.GT.0.AND.RSYM(I)(NCHR:NCHR).NE.',') THEN
          NCHR=NCHR+1
          RSYM(I)(NCHR:NCHR)='+'
        ENDIF
        NCHR=NCHR+1
        RSYM(I)(NCHR:NCHR)=AXIS(K)
      ENDIF
30    CONTINUE
C
      CALL NUMDEN(TRANS(J,I),NN,ND,1,NK)
      IF (NK.NE.0) THEN
        SGN='+'
        IF (NK.LT.0) SGN='-'
        NUM=CHAR(ICHAR('1')+NN-1)
        DEN=CHAR(ICHAR('1')+ND-1)
        RSYM(I)(NCHR+1:NCHR+4)=SGN//NUM//'/'//DEN
        NCHR=NCHR+4
      ENDIF
C
      IF (J.LT.3) THEN
        NCHR=NCHR+1
        RSYM(I)(NCHR:NCHR)=','
      ENDIF
20    CONTINUE
10    CONTINUE
C
*------------------- FIND LATTICE TYPE
      DO 40 I=1,NLAT
      LTT(I)=' '
      K1=0
      DO 50 J=1,3
      CALL NUMDEN(TRANS(J,I),NN,ND,1,NK)
      IF (NK.EQ.0) THEN
        LTT(I)(K1+1:K1+3)='0'//'/'//'0'
        K1=K1+3
      ELSE
        NUM=CHAR(ICHAR('1')+NN-1)
        DEN=CHAR(ICHAR('1')+ND-1)
        LTT(I)(K1+1:K1+3)=NUM//'/'//DEN
        K1=K1+3
      ENDIF
50    CONTINUE
40    CONTINUE
      LTYP=LATT(LTT,NLAT)
C
*-------------------  ATOM CARDS
      CALL ATOPOS
      DO 60 I=1,NATOM
      ALAB(I)=' '
      ALAB(I)(1:4)=ATNAME(I)
      ALAB(I)=ATOMLAB(ALAB(I))
60    CONTINUE
C
*-------------------  INQUIRE WHICH GRAPHICS DATA FILE FORMAT
1000  CALL MESS(ITO,0,'WHICH STRUCTURE PLOTTING PROGRAM IS REQUIRED')
      CALL ASK('(ORT)EP,(PLU)TO,(STR)UPLO,(CHE)MX,(SCH)AKAL ?')
      PRGTYP=MESSAG(1:3)
      IF (PRGTYP.EQ.'ORT') THEN
        NAMFIL='.ORT'
      ELSE IF (PRGTYP.EQ.'PLU') THEN
        NAMFIL='.PLU'
      ELSE IF (PRGTYP.EQ.'STR') THEN
        NAMFIL='.STR'
      ELSE IF (PRGTYP.EQ.'CHE') THEN
        NAMFIL='.NTH'
      ELSE IF (PRGTYP.EQ.'SCH') THEN
        NAMFIL='.SCH'
      ELSE
        CALL MESS(ITO,0,'PROGRAM NAME NOT RECOGNISED ????? ')
        GOTO 1000
      ENDIF
C
*------------------- OPEN DATA FILE
      LG=-9999
      MESSAG=FNAM
      CALL OPNFIL(LG,122)
      IF (PRGTYP.EQ.'ORT') THEN
*-------------------  ORTEP DATA FORMAT
*  TEMPERATURE FACTORS
* WILL CONVERT FROM B'S TO U'S
        CALL SETANI
        PI8=78.9568
* CENTROSYMETRIC TEST
        OCENT='A'
        IF (CENTRC) OCENT='C'
        WRITE(LG,'(A6,80A1)') 'TITLE  ',(ITITLE(I:I),I=1,NTITLE)
        WRITE(LG,'(A4,6(2X,F9.4))') 'CELL',
     *  ((XC(I,J),I=1,3),J=1,2)
        WRITE(LG,'(A4,2(1X,A1))') 'LATT',OCENT,LTYP
        WRITE(LG,'(A4,1X,A25))') ('SYMM',RSYM(I),I=1,NOPC)
        DO 80 I=1,NATOM
        IF (IAPT(I).NE.0) THEN
          WRITE(LG,'(A4,1X,A6,1X,4(F9.4,1X),A1)')
     *    'ATOM',ALAB(I),(X(J,I),J=1,3),1.0,'='
          WRITE(LG,'(6(F9.4,1X))') (ATF(J,IAPT(I))/PI8,J=1,6)
        ELSE IF (ABS(TF(I)).GT.0.001) THEN
          WRITE(LG,'(2(A6,1X),5(F9.4,1X))')
     *    'ATOM  ',ALAB(I),(X(J,I),J=1,3),1.0,TF(I)/PI8
        ELSE
          WRITE(LG,'(2(A6,1X),4(F9.4,1X))')
     *    'ATOM  ',ALAB(I),(X(J,I),J=1,3),1.0
        ENDIF
80      CONTINUE
C
      ELSE IF (PRGTYP.EQ.'STR') THEN
*-------------------  STRUPLO DATA FORMAT
        WRITE(LG,'(A4,1X,80A1)') 'TITL',(ITITLE(I:I),I=1,NTITLE)
        WRITE(LG,'(A4,1X,6(F9.4,1X))') 'CELL',
     *  ((XC(I,J),I=1,3),J=1,2)
        WRITE(LG,'(A4,1X,A25))') ('SYMM',RSYM(I),I=1,NOPC)
        WRITE(LG,'(A4,1X,A4)') 'SPGR',LTYP//'***'
        WRITE(LG,'(A4,1X,I2,1X,I1,1X,I4)') 'SHAD',9,1,-400
        WRITE(LG,'(A3)') 'END'
        NLB=0
        DO 90 I=1,NATOM
        JA=0
        DO 100 J=1,NLB
        IF(ALAB(I)(1:2).EQ.TLAB(J)) THEN
          NA(J)=NA(J)+1
          JA=J
        ENDIF
100     CONTINUE
        IF (JA.EQ.0) THEN
          NLB=NLB+1
          TLAB(NLB)=ALAB(I)(1:2)
          NA(NLB)=1
          JA=NLB
        ENDIF
        LAB=TLAB(JA)
        IF (LAB(2:2).EQ.'(') LAB(2:2)=' '
        WRITE(LG,'(A2,1X,I2,3X,3(F8.5,1X))')
     *  LAB,NA(JA),(X(J,I),J=1,3)
90      CONTINUE
      ELSE IF (PRGTYP.EQ.'CHE') THEN
        NAMFIL='.NTH'
      ELSE IF (PRGTYP.EQ.'CHE') THEN
C
*-------------------  CHEMX NORTH DATA FORMAT
        WRITE(LG,'(A1,1X,I1,1X,A4,6(2X,F8.3))')
     *  '*',0,'CELL',((XC(I,J),I=1,3),J=1,2)
        WRITE(LG,'(A1,1X,I2,1X,10A1)') '*',2,(ITITLE(I:I),I=1,10)
        DO 95 I=1,NATOM
        WRITE(LG,'(A4,3(2X,F8.5))') ATNAME(I),(X(J,I),J=1,3)
95      CONTINUE
C
* WRITE SYMM DATA IN COMMAND LOG FILE
        CCENT='/NOCENT'
        IF (CENTRC) CCENT='/CENT   '
* OPEN SYM FILE
        LS=-9999
        MESSAG=FNAM
      NAMFIL='.SYM'
      CALL OPNFIL(LS,122)
      WRITE (LS,'(A8)') 'SET PACK'
      WRITE (LS,'(A8,1X,A1)') '/LATTICE',LTYP
      WRITE (LS,'(A8)') CCENT
      WRITE (LS,'(A9,1X,A25)') ('/SYMMETRY',RSYM(I),I=2,NOPC)
      WRITE (LS,'(A6,6(1X,I3))') '/RANGE',0,1,0,1,0,1
      WRITE (LS,'(A7,6(1X,I3))')
     * '/WINDOW',0,1,0,1,0,1
      WRITE (LS,'(A7)') '/FINISH'
      WRITE (LS,'(A6)') 'MODIFY'
      WRITE (LS,'(A5)') '/PACK'
      WRITE (LS,'(A7)') '/FINISH'
      CALL CLOFIL(LS)
      ELSE IF (PRGTYP.EQ.'PLU') THEN
C
*-------------------  PLUTO DATA FORMAT
      WRITE(LG,'(A5,1X,80A1)') 'TITLE',(ITITLE(I:I),I=1,NTITLE)
      WRITE(LG,'(A4,6(1X,F9.4))') 'CELL',
     * ((XC(I,J),I=1,3),J=1,2)
      WRITE(LG,'(A4,1X,A25)')
     * ('SYMM',RSYM(I),I=1,NOPC)
      NLB=0
      DO 110 I=1,NATOM
      JA=0
      DO 120 J=1,NLB
      IF(ALAB(I)(1:2).EQ.TLAB(J)) THEN
      NA(J)=NA(J)+1
      JA=J
      ENDIF
120   CONTINUE
      IF (JA.EQ.0) THEN
      NLB=NLB+1
      TLAB(NLB)=ALAB(I)(1:2)
      NA(NLB)=1
      JA=NLB
      ENDIF
      LAB=TLAB(JA)
      L1=2
      L2=1
      IF (LAB(2:2).EQ.'(') L1=1
      IF (NA(JA).GT.9) L2=2
      WRITE(LG,'(A<L1>,I<L2>,3(1X,F7.4))')
     * LAB(1:L1),NA(JA),(X(J,I),J=1,3)
110    CONTINUE
      WRITE (LG,'(A)') 'END'
      ELSE IF (PRGTYP.EQ.'SCH') THEN
C
*-------------------  SCHAKAL DATA FORMAT
      WRITE(LG,'(A4,1X,80A1)') 'TITL',(ITITLE(I:I),I=1,NTITLE)
      WRITE(LG,'(A4,1X,6(F9.4,1X))') 'CELL',
     * ((XC(I,J),I=1,3),J=1,2)
      WRITE(LG,'(A4,1X,A25))') ('SYMM',RSYM(I),I=1,NOPC)
      DO 130 I=1,NATOM
      WRITE(LG,'(A4,3(2X,F8.5))') ATNAME(I),(X(J,I),J=1,3)
130   CONTINUE
      WRITE(LG,'(A15)') 'BOX 0.2 0.2 0.2'
      WRITE(LG,'(A3)') 'END'
      ENDIF
C
*------------------- CLOSE DATA FILE
      CALL CLOFIL(LG)
      END
C
C
C
C
*** NOTE FROM JUDY - INVESTIGATE USE OF "UPPER" HERE
      CHARACTER*(*) FUNCTION CAPS(STRNG)
      CHARACTER*(*) STRNG
      CHARACTER CHR*1
*------------------- CHANGE LOWER TO UPPER CASE
      NA1=ICHAR('a')
      NA2=ICHAR('A')
      NZ1=ICHAR('z')
      NZ2=ICHAR('Z')
      LETT=LEN(STRNG)
      DO 10 I=1,LETT
      CHR=STRNG(I:I)
      J1=ICHAR(CHR)
      IF(J1.GE.NA1.AND.J1.LE.NZ1) THEN
      J2=NA2+(J1-NA1)
      CHR=CHAR(J2)
      ENDIF
      CAPS(I:I)=CHR
10    CONTINUE
      RETURN
      END
C
C
C
C
      CHARACTER*6 FUNCTION ATOMLAB(STRNG)
      CHARACTER STRNG*6,TWO*2,CAPS*2
*------------------- CHECK AND ADJUST ATOM LABEL
      NA2=ICHAR('A')
      NZ2=ICHAR('Z')
      LETT=LEN(STRNG)
      ATOMLAB=' '
      TWO=STRNG(1:2)
      TWO=CAPS(TWO)
      NT2=ICHAR(TWO(2:2))
      IF (NT2.GE.NA2.AND.NT2.LE.NZ2) THEN
      ATOMLAB(1:2)=TWO
      I=2
      ELSE
      ATOMLAB(1:1)=TWO(1:1)
      I=1
      ENDIF
      ATOMLAB(I+1:I+1)='('
20    I=I+1
      IF (STRNG(I:I).EQ.' ') GOTO 30
      ATOMLAB(I+1:I+1)=STRNG(I:I)
      GOTO 20
30    ATOMLAB(I+1:I+1) =')'
      RETURN
      END
C
C
C
C
      CHARACTER*1 FUNCTION LATT(LTT,NLAT)
      CHARACTER LTT(4)*9,LAT(7)*10,CHR*4
      DATA LAT/'0/00/00/0P','0/01/21/2A','1/20/01/2B','1/21/20/0C',
     * '1/21/21/2I','1/32/32/3R','2/31/31/3R'/
C
*------------------- FIND LATTICE TYPE
      N1=0
      CHR=' '
      LATT=' '
      DO 10 I=1,7
      DO 20 J=1,NLAT
      IF (LTT(J).EQ.LAT(I)(1:9)) THEN
      N1=N1+1
      CHR(N1:N1)=LAT(I)(10:10)
      ENDIF
20    CONTINUE
10    CONTINUE
      IF (CHR.EQ.'PABC') THEN
      LATT='F'
      ELSE IF (CHR.EQ.'PRR ') THEN
      LATT='R'
      ELSE IF (N1.LE.2) THEN
      LATT=CHR(N1:N1)
      ENDIF
      RETURN
      END
C
C
C
C
C LEVEL 50      PROGRAM INCMSF
      PROGRAM INCMSF
C
C *** INCMSF updated  by PJB C4.20 C4.12 write headers using HDROUT ******
C
C *****************************************************************************
C
C                            I N C M S F
C
C TO TAKE MEANS OF INTENSITIES FOR STRUCTURES WITH NON-ZERO PROPAGATION
C VECTORS AND CALCULATE THE RELATIVE POPULATIONS OF THE DIFFERENT K DOMAINS.
C THE DOMAIN INTENSITIES ARE SCALED TO THE WHOLE CRYSTAL AND MEAN STRUCTURE
C FACTORS CALCULATED
C
C *****************************************************************************
C
CC 2D
CH To calculate the mean structure factors of satellite reflections from
CH data arranged by ARRINC
CD INCMSF reads the data file written by ARRINC and finds the means of
CD the intensities of the non-fundamental reflections. It will apply
CD an absorption correction if G cards are given.
CD It uses the mean intensities to calculate the relative populations of
CD the different configuration domains and finally scales all intensities
CD to the volume of the whole crystal and deduces the mean structure factors
CD and their standard deviations.
CD Uses Harwell library routine MA44A for lsq determination of domain
CD populations
CI The crystal data file must contain:
CI     A Q PROP card giving the propagation vector
CI     An I card which indicates the options chosen in ARRINC
CI         The words on I cards which are recognised are: DTYP and RNUM, DTYP
CI         is mandatory.
CI Optionally:
CI     G cards defining the crystal size, shape and absorption  coefficient
CI     D cards defining the diffraction geometry used in the measurement
CI     If either are absent, no absorption correction will be made.
CI
CI The data file written by ARRINC. Its default extension is ".arr"
C
CO A listing file which reports how the crystal data file was
CO interpreted. This file also gives the least squares matrix used to obtain
CO the domain populations, and the domain populations calculated from
CO it. These are followed by a list of reflections indexed in domain 1 together
CO with their mean experimental structure factors. Finally some statistics
CO indicating the agreement between supposedly equivalent quantities are
CO reported.
CO
CO A file with default extension ".sf" which contains the indices, mean
CO structure factors and standard deviations of measured reflections. The
CO format is (3I5,2F10.4) if the indices are integer and (3F8.3,2F10.4) if not.
C
CR On running the program the user is asked for the name of the crystal data
CR file, the name of the input file (it should be one written by ARRINC) and
CR a name for the output file to contain the experimental structure factors.
C
CN Any fundamental reflections in the input file are ignored.
CN Domain populations can only be calculated when the same reflection has been
CN measured for more than one domain. Reflections belonging to domains whose
CN populations are not determined are ignored as they cannot be scaled. In
CN such cases the overall scale does not correspond to the whole crystal
CN volume.

C
      DIMENSION LUN(2),POP(24),ISDOM(24),
     &DWORK(5),DSUMS(4)
      DIMENSION HI(3),H(3),HR(3),KSOP(24)
      LOGICAL INDOM,LERCHK
      CHARACTER*56 HEDING
/ABSDAT/
/CARDRC/
/IOUNIT/
/NSYM/
/REFS/
/SATELL/
/SCRACH/
/STATS/
C
C Dimensions which have to be changed if problem size changes
      DIMENSION AMAT(2,1000),ID(2,1000),RHS(1000),RMAT(24,1000)
C Dimension of AMAT etc above
      DATA NMAX/1000/
      DATA HEDING/'(5X,''h'',4X,''k'',4X,''l'',10X,''Fobs'',7X,''DFobs
     &''/)'/
C
      CALL PREFIN('INCMSF')
      CALL SYMOP
      CALL RECIP
      CALL INPUTI
      CALL IICD3
      CALL ICDINC
      CALL ICDFMT(INC,ITEMS)
C SET UP A TABLE GIVING ONE OPERATOR WHICH GENERATES EACH DOMAIN
      KSOP(1)=1
      I=2
      DO 71 J=2,NOPC
      IF (KSTAB(J).NE.I) GO TO 71
      KSOP(I)=J
      I=I+1
      IF (I.GT.NKC) GO TO 70
   71 CONTINUE
C
   70 IF (INC.NE.0) THEN
        HEDING(2:2)='6'
        HEDING(9:9)='7'
        HEDING(16:16)='7'
        HEDING(23:24)='12'
        CALL GMZER(AMAT,24,24)
      ENDIF
      SCALE(1)=1.
      SCALE(2)=1.
      LH=2
      NAMFIL='.ARR'
      LUN(1)=NOPFIL(101)
      LUNI=LUN(1)
      NAMFIL='.SF '
      LOUT=NOPFIL(102)
C4.12  Call ARRHED to read header info
      CALL ARRHED
C prepare to do absorption correction if G cards are given
      IF (ICDNO(7).NE.0) THEN
        CALL SETABS
C FORCE ABSORPTION INTEGRAL
        MODEA=1
        CALL ABSCOR(0)
C4.20 to put abs coeff in header
        MODEH=1
      ELSE
        CALL SETDC
      ENDIF
      CALL ERRMES(0,0,'to INCMSF')
C
C4.20 Write header on structure factor output
      CALL HDROUT(LOUT,1,MODEH)
C
C FIRST CYCLE FOR DOMAIN POPULATIONS
C121 SKIP IT IF ONLY ONE DOMAIN
      IF (NKC.EQ.1) THEN
        POP(1)=1
        GO TO 50
      ENDIF
      INDOM=.FALSE.
      WRITE (LPT,1101)
 1101 FORMAT (/' Data used to determine the domain populations'/
     &2X,2('Obs No  Domain   Intensity '))
C Leave slot 1 for the normalisation constraint
      NOBS=1
C Number of domains actually sampled
      NDOM = 0
C INITIALISE STATISTICS
      CALL STATIS(-1)
      CALL JGMZER(ISDOM(NKC),NKC,1)
    1 IEND= INPUAR(1,LUN)
      IF (IEND.NE.0) GO TO 2
C SKIP IF END OF DOMAIN GROUP OR A FUNDAMENTAL
      JJJ=JJ(NR,1)
      IF (II.NE.0 .AND. JJJ.GT.50) THEN
        IF (ICDNO(7).NE.0) CALL ABSCOR(1)
        CALL STATIS(1)
        IF (AMEAN(1).LT.DEV(1)) GO TO 1
        IDOM=JJJ/100
        ICHNGE=MOD(JJJ,100)
        IF (IDOM.NE.0) THEN
          IF (.NOT. INDOM) THEN
            IF (ICHNGE .EQ. 6) THEN
              JDOM=IDOM
              AFIRST=AMEAN(1)
              VFIRST=(DEV(1)/(AFIRST)**2)**2
              INDOM=.TRUE.
            ENDIF
          ELSE
C ADD TO THE LEAST SQUARES MATRIX FOR THE DOMAIN POPULATIONS
            IF (.NOT.LERCHK(2,NOBS,NMAX,-1,'Observations for domain '
     &      //'population, the rest will be ignored')) GO TO 2
            VTHIS=(DEV(1)/(AMEAN(1))**2)**2
            WEIGHT=1/(VTHIS+VFIRST)
            WRITE (LPT,1100) NOBS,JDOM,AFIRST,IDOM,AMEAN(1)
 1100 FORMAT (1X,I6,2X,2(2X,I6,3X,F10.4))
            IF (ISDOM(IDOM).EQ.0) THEN
              NDOM = NDOM+1
              ISDOM(IDOM) = NDOM
            ENDIF
            ID(2,NOBS)=ISDOM(IDOM)
            IF (ISDOM(JDOM).EQ.0) THEN
              NDOM = NDOM+1
              ISDOM(JDOM) = NDOM
            ENDIF
            ID(1,NOBS)=ISDOM(JDOM)
            AMAT(1,NOBS)=WEIGHT/AFIRST
            AMAT(2,NOBS)=WEIGHT/AMEAN(1)
            INDOM=(ICHNGE.EQ.6)
          ENDIF
        ENDIF
      ENDIF
      GO TO 1
    2 CALL POPDOM(AMAT,POP,ISDOM,ID,RMAT,RHS,NKC,NDOM,NOBS)
C
   50 CALL NEWPAG(LPT)
      WRITE (LPT,HEDING)
      LINO=3
      REWIND LUN(1)
      CALL GMZER(DSUMS,4,1)
C REINITIALISE STATISTICS
      CALL STATIS(-1)
      num = 0
    3 IEND= INPUAR(1,LUN)
      IF (IEND.NE.0) GO TO 100
      num = num+1
C skip if end of domain group
      IF (II.NE.0) THEN
        IF (ICDNO(7).NE.0) CALL ABSCOR(1)
        CALL STATIS(1)
C Skip if a fundamental
        IF (JJ(NR,1).LT.100) GO TO 7
C Normalise magnetic intensities to correspond to whole crystal
        IDOM=JJ(NR,1)/100
        ICHNGE=JJ(NR,1)-100*IDOM
        IF (IDOM.EQ.0) GO TO 7
C Skip if this domain's population is not known
        IF (POP(IDOM).LT.10E-4) GO TO 3
C ELSE SCALE TO WHOLE CRYSTAL
        AMEAN(1)=AMEAN(1)/POP(IDOM)
        DEV(1)=DEV(1)/POP(IDOM)
        IF (.NOT. INDOM) THEN
          IF (ICHNGE .NE. 6) GO TO 3
C INITIALISE DOMAIN AVERAGE
          CALL WTMEAN(AMEAN(1),DEV(1),0,DWORK)
          INDOM=.TRUE.
        ENDIF
        CALL WTMEAN(AMEAN(1),DEV(1),2,DWORK)
        GO TO 3
      ELSE
C GET DOMAIN AVERAGE IF INDOM IS TRUE
        IF (INDOM) THEN
          CALL WTMEAN(AMEAN(1),DEV(1),-1,DWORK)
          DSUMS(1)=DSUMS(1)+AMEAN(1)
          DSUMS(2)=DSUMS(2)+DEV(1)
          DSUMS(3)=DSUMS(3)+ DWORK(2) -AMEAN(1)*DWORK(1)
          DSUMS(4)=DSUMS(4)+ 1.
          INDOM=.FALSE.
        ENDIF
      ENDIF
C
C  CALCULATE F FROM F**2
    7 IF (AMEAN(1).LT.0) THEN
        F=0
        DF=SQRT(DEV(1))
      ELSE
        F=SQRT(AMEAN(1))
        IF (DEV(1).LT.AMEAN(1)) THEN
          DF=0.5*(SQRT(AMEAN(1)+DEV(1))-SQRT(AMEAN(1)-DEV(1)))
        ELSE
          DF=SQRT(DEV(1))
        ENDIF
      ENDIF
C
C IF FUNDAMENTAL
      IF (JJ(NR,1).LT.100) THEN
        CALL GMEQ(R(II+1,1),HI,3,1)
      ELSE
C PUT THE REFLECTION INDICES INTO THE FIRST DOMAIN
        CALL GMEQ(R(II+1,1),H,3,1)
        DO 4 NO=1,NKC
        CALL ROTSYM(H,HI,KSOP(NO),2)
        CALL INDFND(HR,K,HI,JS)
        IF (JS.EQ.1) GO TO 5
    4   CONTINUE
        CALL ERRMES(1,0,'Can''t find index in first domain')
    5   CALL INCIND(HR,K,HI,JS)
      ENDIF
C
      CALL TESTP(LPT,LINO,1,HEDING,LH)
      IF (INC .NE. 0) THEN
        WRITE (LOUT,2006) HI,F,DF
2006    FORMAT (3F8.3,2F10.4)
        WRITE (LPT,2005) HI,F,DF
2005    FORMAT (1X,3F8.3,2X,2F12.3)
      ELSE
        CALL INDFIX(HI,K)
        WRITE (LPT,2001)(K(I,1),I=1,3),F,DF
2001    FORMAT (3I5,2X,2F12.3)
        WRITE (LOUT,2002) (K(I,1),I=1,3),F,DF
2002    FORMAT (3I5,2F10.4)
      ENDIF
      GO TO 3
C
C  END OF DATA GIVE STATITSICS
  100 R1=100.*SUMS(2)/SUMS(1)
      AMNF2=SUMS(12)/SUMS(11)
      WRITE (LPT,2000) R1
      WRITE (ITO,2000) R1
      IF (SUMS(6).GT.1) THEN
        R2=100.*SUMS(4)/SUMS(3)
        CHI1=SUMS(5)/(SUMS(6)-1.)
        WRITE (LPT,2021) NINT(SUMS(6)),CHI1,R2
        WRITE (ITO,2021) NINT(SUMS(6)),CHI1,R2
      ELSE
        WRITE (LPT,2011)
        WRITE (ITO,2011)
      ENDIF
      IF (SUMS(10).GT.1) THEN
        R3=100.*SUMS(8)/SUMS(7)
        CHI2=SUMS(9)/(SUMS(10)-1.)
        WRITE (LPT,2022) NINT(SUMS(10)),CHI2,R3
        WRITE (ITO,2022) NINT(SUMS(10)),CHI2,R3
      ELSE
        WRITE (LPT,2012)
        WRITE (ITO,2012)
      ENDIF
      IF (DSUMS(2).GT.0) THEN
        R4=100.*DSUMS(2)/DSUMS(1)
        CHI3=DSUMS(3)/(DSUMS(4)-1.)
        WRITE (LPT,2015) NINT(DSUMS(4)),CHI3,R4
        WRITE (ITO,2015) NINT(DSUMS(4)),CHI3,R4
      ENDIF
      WRITE (LPT,2023) AMNF2
      WRITE (ITO,2023) AMNF2
      write (ito,5555) num
 5555 format ('there were ',I6,' calls to statis')
      STOP
 2000 FORMAT (/' The R on Fsqrd based on counting statistics is',
     & 2X,F8.2,'%')
 2021 FORMAT ( /' The chisquared for',I4,' repeated measurements is ',
     & F8.2/' and the associated R on Fsqrd is',15X,F8.2,'%')
 2022 FORMAT (/' The chisquared  for',I4,' equivalent reflections is',
     &F 8.2/' with an associated R on Fsqrd of',16X,F8.2,'%')
 2023 FORMAT (/' The average F squared over all measured reflections',
     & ' is',F10.2)
 2011 FORMAT (/' There were no repeated measurements ')
 2012 FORMAT (/' No equivalent reflections were measured')
 2015  FORMAT (/' The chisquared for ', I5,' reflections measured in ',
     &'different domains is '
     & ,F8.2/' with an associated R on Fsqrd of ',F8.2,'%'/)
      END
C
C
C
C
      SUBROUTINE POPDOM(AMAT,POP,ISDOM,ID,RMAT,RHS,NK,NDOM,NOBS)
C
CH Determines the domain populations
CC 2B
      DIMENSION AMAT(2,NOBS),POP(NK),RMAT(NOBS,NDOM),ISDOM(NK)
     &,ID(2,NOBS),RHS(NOBS),IW(24),WRK(48),V(24,24),SDEV(24),RPOP(24)
/IOUNIT/
C
C NDOM is the number of domains measured
      IF (NDOM .EQ.1) THEN
        POP(1)=1.
        GO TO 100
      ENDIF
      CALL GMZER(RMAT,NOBS,NDOM)
      DO 2 N=2,NOBS
      RMAT(N,ID(1,N))=AMAT(1,N)
      RMAT(N,ID(2,N))=-AMAT(2,N)
    2 CONTINUE
      CALL GMZER(RHS,NOBS,1)
C ADD THE CONSTRAINED (NORMALISATION) EQUATION
      DO 6 IC=1,NDOM
      RMAT(1,IC)=1.
    6 continue
C ASSUME UNMEASURED DOMAINS HAVE THEIR PROPER SHARE
      RHS(1)=FLOAT(NDOM)/FLOAT(NK)
      CALL MA44A(NOBS,NDOM,1,RMAT,NOBS,RHS,.TRUE.,RPOP,IW,
     &WRK,VAR,ITO,-1)
      IF (VAR.LT.0) CALL ERRIN2(NINT(VAR),0,
     &'MA44A has returned error flag',' ')
      CALL MA44C(NOBS,NDOM,1,RMAT,NOBS,IW,WRK,VAR,ITO,
     &-1,V,NDOM,SDEV)
      IF (VAR.LT.0) CALL ERRIN2(NINT(VAR),0,
     &'MA44C has returned error flag',' ')
      II=1
      WRITE (ITO,1001)
      WRITE (LPT,1001)
 1001 FORMAT('Domain populations:')
      DO 5 I=1,NK
      IF (ISDOM(I).EQ.0) GO TO 5
      POP(I)=RPOP(ISDOM(I))
      WRITE (ITO,1000)  I,POP(I),SDEV(ISDOM(I))
      WRITE (LPT,1000)  I,POP(I),SDEV(ISDOM(I))
 1000 FORMAT (10X,I4,F8.4,'+/-',F6.4)
      II=II+1
    5 CONTINUE
  100 RETURN
      END
C
C
C
C
      SUBROUTINE MA44A (M, N, M1, A, IA, B, RES, X, IW, W, VAR, LP, MP)
CX
CC 6C
CH  Harwell Library General linear least squares with linear equality constraints
C######DATE   12 MAR 1985     COPYRIGHT UKAEA, HARWELL.
C
C       CALCULATE THE SOLUTION OF THE GENERAL LINEAR LEAST SQUARES
C    PROBLEM OPTIONALLY WITH LINEAR EQUALITY CONSTRAINTS. THE PROBLEM IS
C    PRESENTED AS M LINEAR EQUATIONS IN N UNKNOWNS, THE FIRST M1
C    EQUATIONS DEFINING THE CONSTRAINTS.
C       ADDITIONAL RIGHT HAND SIDES MAY BE PASSED TO MA44B/BD,
C    WHICH WILL TAKE ADVANTAGE OF PREVIOUS WORK.
C       THE VARIANCE-COVARIANCE MATRIX AND AN ESTIMATE OF THE RESIDUAL
C    VARIANCE IS PROVIDED BY MA44C/CD.
C       CALCULATION OF RESIDUALS AND PROVISION OF PRINTED OUTPUT ARE
C    ARE ADDITIONAL OPTIONS.
C
      REAL             A(IA,1), B(1), X(1), W(1), VAR
      LOGICAL RES
      INTEGER IW(1)
C
C    M    ON ENTRY: NO. OF EQUATIONS (INCLUDING CONSTRAINTS). NOT
C         ALTERED.
C    N    ON ENTRY: NO. OF UNKNOWNS. NOT ALTERED.
C    M1   ON ENTRY: NO. OF CONSTRAINTS. NOT ALTERED.
C    A    ON ENTRY: HOLDS THE MATRIX OF THE EQUATIONS; ON RETURN: HOLDS
C         THE TRIANGULARIZED MATRIX AND TRANSFORMATIONS; SIZE: M*N.
C    IA   ON ENTRY: FIRST DIMENSION OF A. NOT ALTERED.
C    B    ON ENTRY: HOLDS RIGHT HAND SIDE; ON RETURN: TRANSFORMED RIGHT
C         HAND SIDE ( OR OPTIONALLY THE RESIDUALS ); SIZE: M.
C    RES  ON ENTRY: TRUE IF RESIDUALS WANTED, OTHERWISE FALSE. NOT
C         ALTERED.
C    X    ON RETURN: THE SOLUTION; SIZE: N.
C    IW   ON RETURN: COLUMN INTERCHANGES. AT STEP K, COLUMNS K AND
C         IW(K) ARE INTERCHANGED. SIZE: N.
C    W    ON RETURN: TRANSFORMATION INFORMATION; SIZE: 2*N
C    VAR  ON RETURN: ESTIMATE OF RESIDUAL VARIANCE, OR A NEGATIVE
C         NUMBER, REPRESENTING AN ERROR FLAG.
C            -1: ARGUMENT RESTRICTION VOILATED.
C            -2: FIRST M1 ROWS OF A ARE NOT LINEARLY INDEPENDENT.
C            -3: THE COLUMNS OF A ARE NOT LINEARLY INDEPENDENT.
C     LP  ON ENTRY: UNIT NUMBER FOR DIAGNOSTIC MESSAGES. IF NOT
C         POSITIVE, NO MESSAGES ARE PRINTED. NOT ALTERED.
C     MP  ON ENTRY: UNIT NUMBER FOR MONITORING PRINTOUT. IF NOT
C         POSITIVE, NO MESSAGES ARE PRINTED. NOT ALTERED.
C
C    RESTRICTIONS:  M.GE.N, N.GT.0, M1.LE.N, M1.GE.0
C
C    REFERENCE: BJORCK AND GOLUB (1967), BIT 7, 322-337.
C
C       PRIVATE VARIABLES
      REAL             AMX, BETA, ONE, SIGMA, TEST, WX, ZERO
      REAL             RAMX
      REAL             SCPROD
      ZERO = 0.D0
      ONE =  1.D0
C
      IF (M.LT.N .OR. N.LE.0 .OR. N.LT.M1 .OR. M1.LT.0) GO TO 310
C
C       PRINT HEADINGS ETC.
      IF (MP.GT.0) WRITE(MP,10) M1,M-M1,N
   10 FORMAT (/35H MA44A : CONSTRAINT EQUATIONS    = , I3/9X, 7HLEAST S,
     & 19HQUARES EQUATIONS = , I3/9X, 26HNUMBER OF PARAMETERS    = , I3)
C
C     INITIALIZE COLUMN SCALE FACTORS
      DO 20 J=1,N
        W(N+J) = ZERO
   20 CONTINUE
C     CALCULATE COLUMN SCALING FACTORS.
      DO 50 I=1,M
        AMX = ZERO
        DO 30 J=1,N
          AMX = AMAX1( ABS(A(I,J)),AMX)
   30   CONTINUE
        IF (AMX.EQ.ZERO) GO TO 50
        RAMX=ONE/AMX
        DO 40 J=1,N
          W(N+J) = AMAX1(W(N+J), ABS(A(I,J))*RAMX)
   40   CONTINUE
   50 CONTINUE
      DO 60 J=1,N
        IF (W(N+J).EQ.ZERO) GO TO 290
        W(N+J) = ONE/(W(N+J)*W(N+J))
   60 CONTINUE
C
C MAIN TRANSFORMATION LOOP
      DO 240 K=1,N
        IF (K.EQ.M1+1) GO TO 70
        IF (K.NE.1) GO TO 100
C
C     BEGIN TRANSFORMATION STEP Q1 ON CONSTRAINT EQUATIONS.
        NX = M1
        MX = M1
        MX1 = MX + 1
        GO TO 80
C
C     BEGIN TRANSFORMATION STEP Q2 ON EQUATIONS OF CONDITION.
   70   MX = M
        NX = N
        MX1 = MX + 1
C
C     CALCULATE INITIAL PARTIAL COLUMN NORMS AND SELECT LARGEST.
C     SOLUTION ARRAY USED AS TEMPORY STORAGE SPACE FOR NORMS.
   80   AMX = ZERO
        DO 90 J=K,N
          SCPROD=ZERO
          DO 85 IPROD=K+1,MX1
          SCPROD=SCPROD+A(IPROD-1,J)*A(IPROD-1,J)
   85     CONTINUE
          X(J) = SCPROD
          TEST =  ABS(X(J))*W(N+J)
          IF (TEST.LE.AMX) GO TO 90
          JX = J
          AMX = TEST
   90   CONTINUE
        GO TO 120
C
C     CALCULATE PARTIAL COLUMN NORMS USING OLD VALUES AND SELECT LARGEST
  100   AMX = ZERO
        DO 110 J=K,N
          X(J) = X(J) - A(K-1,J)*A(K-1,J)
          TEST =  ABS(X(J))*W(N+J)
          IF (TEST.LE.AMX) GO TO 110
          JX = J
          AMX = TEST
  110   CONTINUE
  120   IF (JX.EQ.K) GO TO 140
C
C     INTERCHANGE COLUMNS SO THAT COL. WITH LARGEST NORM IS USED
C     AS PIVOT
        DO 130 I=1,M
          WX = A(I,JX)
          A(I,JX) = A(I,K)
          A(I,K) = WX
  130   CONTINUE
C     INTERCHANGE COLUMN NORMS.
        WX = X(JX)
        X(JX) = X(K)
        X(K) = WX
C     INTERCHANGE COLUMN SCALE FACTORS.
        WX = W(N+JX)
        W(N+JX) = W(N+K)
        W(N+K) = WX
C     RECORD COLUMN INTERCHANGES.
  140   IW(K) = JX
C
C     CALCULATE THE TRANSFORMATION.
        SCPROD=ZERO
        DO 145 IPROD=K+1,MX1
        SCPROD=SCPROD+A(IPROD-1,K)*A(IPROD-1,K)
  145   CONTINUE
        X(K) = SCPROD
        IF (X(K).LE.ZERO) GO TO 270
        SIGMA =  SQRT(X(K))* SIGN(ONE,A(K,K))
C     U(K) STORED IN W(K) AND U(I) IN A(I,K)  I.GT.K
        W(K) = SIGMA + A(K,K)
        BETA = ONE/(SIGMA*W(K))
C     PIVOT ELEMENT.
        A(K,K) = -SIGMA
        K1 = K + 1
C     IF THIS IS THE LAST TRANSFORMATION OF THIS STEP BRANCH
        IF (K.EQ.NX) GO TO 170
C     APPLY THE TRANSFORMATION.
        CALL MA44D (A(K+1,K+1),A(K+1,K),A(K,K+1),IA,N-K,MX-K,W(K),BETA)
        GO TO 240
  170   IF (K.NE.M1) GO TO 250
        IF (K.EQ.N) GO TO 190
C     FINISH OFF TRANSFORMATION.
        DO 180 J=K1,N
          A(K,J) = -A(K,J)
  180   CONTINUE
C
C     FORM MULTIPLIERS FOR ELIMINATION.
  190   M11 = M1 + 1
        IF(M11.GT.M)GO TO 211
        CALL MA44E (A,A,IA,M1,M)
  211   IF (N.EQ.M1) GO TO 250
C     CARRY OUT ELIMINATION.
        CALL MA44F (A,A,IA,M1,N,M)
  240 CONTINUE
C
C     BETA(K) STORED IN W(N+I)  I=1 TO N
  250 DO 260 J=1,N
        W(N+J) = -(ONE/(W(J)*A(J,J)))
  260 CONTINUE
      VAR=ZERO
      CALL MA44B (M, N, M1, A, IA, B, RES, X, IW, W, VAR, LP, MP)
      GO TO 330
  270 VAR = -2
      IF (K.GT.M) GO TO 290
      IF (LP.GT.0) WRITE (LP,280)
  280 FORMAT (/50H MA44A  ERROR: FIRST M1 ROWS OF A ARE NOT LINEARLY,
     & 12H INDEPENDENT)
      GO TO 330
  290 VAR = -3
      IF (LP.GT.0) WRITE (LP,300)
  300 FORMAT (/48H MA44A  ERROR: THE COLUMNS OF A ARE NOT LINEARLY,
     & 12H INDEPENDENT)
      GO TO 330
  310 VAR = -1
      IF (LP.LE.0) GO TO 330
      WRITE (LP,320)
  320 FORMAT (/45H MA44A  ERROR: ARGUMENT RESTRICTIONS VIOLATED)
      WRITE (LP,10) M1,M-M1,N
  330 RETURN
      END
C
C
C
C
      SUBROUTINE MA44D (A,B,C,IA,NK,MXK,WK,BETA)
CX
CC 6C
CH  Harwell LIbrary subroutine Used by MA44A
      REAL             A(IA,*),B(IA,*),C(IA,*)
      REAL             ZERO,H,WK,BETA
      DATA ZERO/0.0E0/
      DO 160 J=1,NK
      H=ZERO
      DO 155 I=1,MXK
      H=H+B(I,1)*A(I,J)
  155 CONTINUE
      H =-(BETA*(H+WK*C(1,J)))
      DO 150 I=1,MXK
      A(I,J) = A(I,J) + H*B(I,1)
  150 CONTINUE
      C(1,J) = C(1,J) + H*WK
  160 CONTINUE
      RETURN
      END
C
C
C
C
      SUBROUTINE MA44E (A,B,IA,M1,M)
CX
CC 6C
CH  Harwell LIbrary subroutine Used by MA44A
      REAL             A(IA,*),B(IA,*),ONE,RCPAJJ,WX,ZERO
      DATA ONE/1.0E0/,ZERO/0.0E0/
      DO 210 J=1,M1
      RCPAJJ=ONE/A(J,J)
      DO 200 I=M1+1,M
      WX=ZERO
      DO 205 KJ=1,J-1
      WX=WX+A(I,KJ)*A(KJ,J)
  205 CONTINUE
      B(I,J) = (B(I,J)-WX)*RCPAJJ
  200 CONTINUE
  210 CONTINUE
      RETURN
      END
C
C
C
C
      SUBROUTINE MA44F (A,B,IA,M1,N,M)
CX
CC 6C
CH  Harwell LIbrary subroutine Used by MA44A
      REAL             A(IA,*),B(IA,*),SCPROD,ZERO
      DATA ZERO/0.0E0/
      DO 230 J=M1+1,N
      DO 220 I=M1+1,M
      SCPROD=ZERO
      DO 210 IP=1,M1
      SCPROD=SCPROD+A(I,IP)*A(IP,J)
  210 CONTINUE
      B(I,J) = B(I,J) - SCPROD
  220 CONTINUE
  230 CONTINUE
      RETURN
      END
C
C
C
C
      SUBROUTINE MA44B (M, N, M1, A, IA, B, RES, X, IW, W, VAR, LP, MP)
C
CX
CC 6C
CH  Harwell LIbrary subroutine Used by MA44A
CD       SUPPLY A NEW RIGHT HAND SIDE TO A SYSTEM
CD       OF EQUATIONS SOLVED PREVIOUSLY, THE VARIABLES M,N,M1,A,IA,IW
CD       AND W ARE ASSUMED TO HAVE BEEN UNCHANGED.
C
      REAL             A(IA,1), B(1), X(1), W(1), VAR
      LOGICAL RES
      INTEGER IW(1)
C
C    M    ON ENTRY: NO. OF EQUATIONS (INCLUDING CONSTRAINTS).
C         NOT ALTERED.
C    N    ON ENTRY: NO. OF UNKNOWNS. NOT ALTERED.
C    M1   ON ENTRY: NO. OF CONSTRAINTS. NOT ALTERED.
C    A    ON ENTRY: HOLDS THE TRIANGULARIZED MATRIX AND TRANSFORMATIONS;
C         SIZE: M*N. NOT ALTERED.
C    IA   ON ENTRY: FIRST DIMENSION OF A. NOT ALTERED.
C    B    ON ENTRY: HOLDS RIGHT HAND SIDE; ON RETURN: TRANSFORMED RIGHT
C         HAND SIDE (OR OPTIONALLY THE RESIDUALS); SIZE: M.
C    X    ON RETURN: THE SOLUTION; SIZE: N.
C    IW   ON ENTRY: COLUMN INTERCHANGES; SIZE: N. NOT ALTERED.
C    W    ON ENTRY: TRANSFORMATION INFORMATION; SIZE: 2*N
C         NOT ALTERED.
C    VAR  ON ENTRY: AS LEFT BY MA44AD.
C         ON RETURN: ESTIMATE OF RESIDUAL VARIANCE, OR A NEGATIVE
C         NUMBER, REPRESENTING AN ERROR FLAG.
C            -1: ARGUMENT RESTRICTION VIOLATED.
C     LP  ON ENTRY: UNIT NUMBER FOR DIAGNOSTIC MESSAGES. IF NOT
C         POSITIVE, NO MESSAGES ARE PRINTED. NOT ALTERED.
C     MP  ON ENTRY: UNIT NUMBER FOR MONITORING PRINTOUT. IF NOT
C         POSITIVE, NO MESSAGES ARE PRINTED. NOT ALTERED.
C
C    RESTRICTIONS:  M.GE.N, N.GT.0, M1.LE.N, M1.GE.0, VAR.GE.0
C       PRIVATE VARIABLES
      REAL              H, WX, ZERO ,SCPROD
      ZERO = 0.0E0
C
      M11 = M1 + 1
      IF (M.LT.N .OR. N.LE.0 .OR. N.LT.M1 .OR. M1.LT.0) GO TO 230
      IF (VAR.LT.ZERO) GO TO 230
C
C       PRINT HEADINGS ETC.
      IF(MP.GT.0)WRITE(MP,10) M1,M-M1,N
   10 FORMAT (/35H MA44B : CONSTRAINT EQUATIONS    = , I3/9X, 7HLEAST S,
     & 19HQUARES EQUATIONS = , I3/9X, 26HNUMBER OF PARAMETERS    = , I3)
C
C     APPLY TRANSFORMATION Q1 TO FIRST M1 RIGHT HAND SIDES.
      IF (M1-1) 70, 50, 20
   20 DO 40 K1=2,M1
        K = K1 - 1
        SCPROD=ZERO
        DO 25 IPROD=K1,M1
        SCPROD=SCPROD+A(IPROD,K)*B(IPROD)
   25   CONTINUE
        H=SCPROD
        H = W(N+K)*(H+W(K)*B(K))
        DO 30 I=K1,M1
          B(I) = B(I) - A(I,K)*H
   30   CONTINUE
        B(K) = B(K) - W(K)*H
   40 CONTINUE
   50 B(M1) = -B(M1)
C
C     ELIMINATION STEP.
      IF(M11.GT.M)GO TO 70
      DO 60 I=M11,M
      SCPROD=ZERO
      DO 55 IPROD=1,M1
      SCPROD=SCPROD+A(I,IPROD)*B(IPROD)
   55 CONTINUE
        B(I) = B(I) - SCPROD
   60 CONTINUE
   70 IF (N.EQ.M1) GO TO 100
C
C     APPLY TRANSFORMATION Q2.
      DO 90 K=M11,N
        K1 = K + 1
        H = ZERO
        IF(M.GT.K)THEN
          SCPROD=ZERO
          DO 75 IPROD=K+1,M
          SCPROD=SCPROD+A(IPROD,K)*B(IPROD)
   75     CONTINUE
          H=SCPROD
        ENDIF
        H = W(N+K)*(H+W(K)*B(K))
        IF(K1.GT.M)GO TO 85
        DO 80 I=K1,M
          B(I) = B(I) - A(I,K)*H
   80   CONTINUE
   85   B(K) = B(K) - W(K)*H
   90 CONTINUE
C
C     BACK SUBSTITUTION TO OBTAIN SOLUTION WHICH IS STORED TEMPORARILY
C     IN B(I), I=1 TO N.
  100 B(N) = B(N)/A(N,N)
      IF (N.EQ.1) GO TO 120
      NN = N - 1
      DO 110 I1=1,NN
        I = N - I1
        SCPROD=ZERO
        DO 105 IPROD=I+1,N
        SCPROD=SCPROD+A(I,IPROD)*B(IPROD)
  105   CONTINUE
        WX = B(I) - SCPROD
        B(I) = WX/A(I,I)
  110 CONTINUE
C
C     PUT THE SOLUTION IN ITS CORRECT ORDER AND STORE IN X(J), J=1,N.
  120 DO 130 I1=1,N
        I = N + 1 - I1
        IX = IW(I)
        X(I) = B(I)
        X(I) = X(IX)
        X(IX) = B(I)
  130 CONTINUE
C
C     COMPUTE ESTIMATE OF RESIDUAL VARIANCE
      VAR = ZERO
      IF (M.GT.N) THEN
        SCPROD=ZERO
        DO 135 IPROD=N+1,M
        SCPROD=SCPROD+B(IPROD)*B(IPROD)
  135   CONTINUE
        VAR = SCPROD/(M-N)
      ENDIF
      IF (.NOT.RES) GO TO 180
C     COMPUTE RESIDUALS.
      DO 140 I=1,N
        B(I) = ZERO
  140 CONTINUE
      IF (M.EQ.N) GO TO 180
      M11 = M1 + 1
      DO 150 I=M11,M
        B(I) = -B(I)
  150 CONTINUE
      IF (N.EQ.M1) GO TO 180
      DO 170 KK=M11,N
        K = M11 + N - KK
        K1 = K + 1
        H = ZERO
        IF(M.GT.K)THEN
          SCPROD=ZERO
          DO 155 IPROD=K+1,M
          SCPROD=SCPROD+A(IPROD,K)*B(IPROD)
  155     CONTINUE
          H=SCPROD
        ENDIF
        H = W(N+K)*(H+W(K)*B(K))
        IF(K1.GT.M)GO TO 165
        DO 160 I=K1,M
          B(I) = B(I) - A(I,K)*H
  160   CONTINUE
  165   B(K) = B(K) - W(K)*H
  170 CONTINUE
C
C     PRINT SOLUTION AND RESIDUALS.
C
  180 IF (MP.LE.0) GO TO 250
      WRITE (MP,190)
  190 FORMAT (/17H MA44B : SOLUTION)
      WRITE (MP,200) (I,X(I),I=1,N)
  200 FORMAT (3(I4, 1PE22.14))
      WRITE (MP,210) VAR
  210 FORMAT (/35H MA44B : RESIDUAL VARIANCE ESTIMATE, 1PE14.6)
      IF (.NOT.RES) GO TO 250
      WRITE (MP,220)
  220 FORMAT (/18H MA44B : RESIDUALS)
      WRITE (MP,200) (I,B(I),I=1,M)
      GO TO 250
  230 VAR = -1
      IF (LP.LE.0) GO TO 250
      WRITE (LP,240)
  240 FORMAT (/46H MA44B : ERROR: ARGUMENT RESTRICTIONS VIOLATED)
      WRITE (LP,10) M1,M-M1,N
  250 RETURN
      END
C
C
C
C
      SUBROUTINE MA44C (M, N, M1, A, IA, IW, W, VAR, LP, MP, V, IV, STD)
C     OBTAIN VARIANCE-COVARIANCE MATRIX
C
CX
CC 6C
CH  Harwell LIbrary subroutine Used by MA44A
      REAL             A(IA,1), W(1), V(IV,1), VAR, STD(1)
      INTEGER IW(1)
C
C    M    ON ENTRY: NO. OF EQUATIONS ( INCLUDING CONSTRAINTS ).
C         NOT ALTERED.
C    N    ON ENTRY: NO. OF UNKNOWNS. NOT ALTERED.
C    M1   ON ENTRY: NO. OF CONSTRAINTS. NOT ALTERED.
C    A    ON ENTRY: HOLDS THE TRIANGULARIZED MATRIX AND
C         TRANSFORMATIONS; SIZE: M*N. NOT ALTERED.
C    IA   ON ENTRY: FIRST DIMENSION OF A. NOT ALTERED.
C    IW   ON ENTRY: COLUMN INTERCHANGES; SIZE: N. NOT ALTERED.
C    W    ON ENTRY: TRANSFORMATION INFORMATION; SIZE: 2*N
C         NOT ALTERED.
C    VAR  ON ENTRY: ESTIMATE OF RESIDUAL VARIANCE. ALTERED TO -1
C         IF IT IS NOT POSTIVE OR OTHER ARGUMENT RESTRICTIONS ARE
C         VIOLATED. OTHERWISE NOT ALTERED.
C     LP  ON ENTRY: UNIT NUMBER FOR DIAGNOSTIC MESSAGES. IF NOT
C         POSITIVE, NO MESSAGES ARE PRINTED. NOT ALTERED.
C     MP  ON ENTRY: UNIT NUMBER FOR MONITORING PRINTOUT. IF NOT
C         POSITIVE, NO MESSAGES ARE PRINTED. NOT ALTERED.
C    V    ON RETURN: HOLDS VARIANCE-COVARIANCE MATRIX; SIZE: N*N.
C    IV   ON ENTRY: FIRST DIMENSION OF V. NOT ALTERED.
C    STD  ON RETURN: SOLUTION STANDARD DEVIATIONS; SIZE: N.
C
      REAL              ONE, WK1, WX, ZERO, SCPROD
      ZERO = 0.0E0
      ONE = 1.0E0
C
      W(1)=W(1)
C    RESTRICTIONS:  M.GE.N, N.GT.0, M1.LE.N, M1.GE.0
      IF (M.LT.N .OR. N.LE.0 .OR. N.LT.M1 .OR. M1.LT.0) GO TO 210
      IF (VAR.LT.ZERO) GO TO 210
C
      IF (M.EQ.N) GO TO 110
      IF (N.EQ.M1) GO TO 120
C
C       LET R BE UPPER TRIANGLE OF A. INVERT R.
      DO 20 II=1,N
        I = N + 1 - II
        V(I,I) = ONE/A(I,I)
        IF (I.EQ.1) GO TO 20
        I1 = I - 1
        DO 10 JJ=1,I1
          J = I - JJ
          SCPROD=ZERO
          DO 5 IPROD=J+1,I
          SCPROD=SCPROD+A(J,IPROD)*V(IPROD,I)
    5     CONTINUE
          WK1 = -SCPROD
          V(J,I) = WK1/A(J,J)
   10   CONTINUE
   20 CONTINUE
C
C        NOW FORM (R**-1)(K)TRANS(R**-1),  WHERE (K) IS
C        THE IDENTITY MATRIX WITH FIRST M1 DIAGONALS ZERO
      DO 50 I=1,N
        DO 40 J=I,N
          K = MAX0(J,M1+1)
          SCPROD=ZERO
          DO 35 IPROD=K,N
          SCPROD=SCPROD+V(I,IPROD)*V(J,IPROD)
   35     CONTINUE
          V(I,J) = VAR*SCPROD
          V(J,I) = V(I,J)
   40   CONTINUE
   50 CONTINUE
C
C       RE-ORDER ROWS AND COLUMNS
      DO 90 I1=1,N
        I = N + 1 - I1
        K = IW(I)
        IF (I.EQ.K) GO TO 90
        DO 70 J=1,N
          WX = V(J,I)
          V(J,I) = V(J,K)
          V(J,K) = WX
   70   CONTINUE
        DO 80 J=1,N
          WX = V(I,J)
          V(I,J) = V(K,J)
          V(K,J) = WX
   80   CONTINUE
   90 CONTINUE
C
C       CALCULATE STANDARD DEVIATIONS
      DO 100 I=1,N
        STD(I) =  SQRT(V(I,I))
  100 CONTINUE
      GO TO 150
C
C       SPECIAL CASE M = N
  110 VAR = ZERO
C       SPECIAL CASE M1 = N
  120 DO 140 I=1,N
        STD(I) = ZERO
        DO 130 J=1,N
          V(I,J) = ZERO
  130   CONTINUE
  140 CONTINUE
C
  150 IF (MP.LE.0) GO TO 240
      WRITE (MP,160) VAR
  160 FORMAT (/35H MA44C : RESIDUAL VARIANCE ESTIMATE, 1PE14.6//
     & 37H MA44C : SOLUTION STANDARD DEVIATIONS)
      WRITE (MP,170) (J,STD(J),J=1,N)
  170 FORMAT (5(I4, 1PE14.6))
      WRITE (MP,180)
  180 FORMAT (/35H MA44C : VARIANCE-COVARIANCE MATRIX)
      DO 190 I=1,N
        WRITE (MP,200) (I,J,V(I,J),J=1,N)
  190 CONTINUE
  200 FORMAT (4(I5, I3, 1PE12.4))
      GO TO 240
C
C       ERROR CONDITIONS
C
  210 VAR = -1
      IF (LP.LE.0) GO TO 240
      WRITE (LP,220)
  220 FORMAT (/46H MA44C : ERROR: ARGUMENT RESTRICTIONS VIOLATED)
      WRITE (LP,230) M1,M-M1,N,VAR
  230 FORMAT (/35H MA44C : CONSTRAINT EQUATIONS    = , I3/9X, 7HLEAST S,
     & 19HQUARES EQUATIONS = , I3/9X, 26HNUMBER OF PARAMETERS    = ,
     & I3/9X, 26HVARIANCE ESTIMATE       = , 1PE12.4)
  240 RETURN
      END
C
C
C
C
C LEVEL 50      PROGRAM LINFOU
      PROGRAM LINFOU
C
C *** LINFOU by PJB ***
C
C ******************************************************************************
C
C                               L I N F O U
C
C   PROGRAM TO CALCULATE THE FOURIER DENSITY ALONG A LINE
C
C ******************************************************************************
C
C
      CHARACTER*10 IWORD(3,3)
      DIMENSION KLIM(3)
/CARDRC/
/CELPAR/
/IOUNIT/
/MAPDA/
      COMMON/SCRAT/X(3,2),JUNK(10195)
      EQUIVALENCE (KLIM(1),NH)
      DATA IWORD/'  Fc','alc ','    ','   F','obs ','    ',
     & 'Fobs','-Fca','lc  '/
C
      CALL PREFIN('LINFOU')
      CALL SYMOP
      CALL RECIP
      CALL INPUTN(LPT)
      CALL INPUTM
      LUNI=NOPFIL(11)
      MODEF=3
C
      CALL GMUNI(U,3,3)
      DO 5 I=1,3
      KLIM(I)=IFIX(VCTMOD(2.*SMAX,U(1,I),1))
    5 CONTINUE
C
    2 READ (ICRYDA,12,END=1) X,N
   12 FORMAT (6F10.4,I5)
      WRITE (LPT,11) X
   11 FORMAT (/' Fourier along the line from',F6.4,2(',',F6.4),' to',
     & F6.4,2(',',F6.4))
      DO 3 I=1,3
      OUTLIM(1,I)=X(I,1)
      OUTLIM(3,I)=(X(I,2)-X(I,1))/FLOAT(N)
    3 CONTINUE
C
      NX=N+1
      SCALF2=V(2)
      CALL FOUR1D
      II=0
      DO 4 M=1,3
      J=0
      DO 6 I=1,NY,2
      J=J+1
    6 JUNK(J)=JFIX(DENS(II+I))
      WRITE (LPT,10) (IWORD(I,M),I=1,3)
      WRITE (LPT,13) (JUNK(I),I=1,NX)
   10 FORMAT (//' **************'/' * ',2A4,A2,' *'/' **************'/)
   13 FORMAT (10I10/)
    4 II=II+NY
      REWIND LUNI
      GO TO 2
C
    1 STOP
      END
C
C
C
C
C LEVEL 50      PROGRAM LOGPLT
      PROGRAM LOGPLT
C
C *** LOGPLT by PJB Aug 86 ***
C
C *****************************************************************************
C
C                              L O G P L T
C
C *****************************************************************************
C
      DIMENSION K(3),F(2),S1(2),S2(2),S3(2),S4(2),S5(2),AM(2),C(2)
/IOUNIT/
/PLOTCH/
/PLTS/
/SCRACH/
C
      CALL INITIL('LOGPLT')
      NAMFIL='.SF'
      LUN=NOPFIL(101)
C
      DO 3 I=1,2
      S1(I) = 0.
      S2(I) = 0.
      S3(I) = 0.
      S4(I) = 0.
      S5(I) = 0.
    3 CONTINUE
C
      NTEX(1)='h**2+k**2+l**2'
      NTEX(2)='Log(Fobs)'
C
*********************************************************
* EDITED TO HERE FOR MESS
*********************************************************
    8 CALL ASK(' Give lengths of x and y axes in cms (2F)')
      CALL RDNUMS(X(1,2),1,2,NUM,IER)
      IF (NUM.NE.2 .OR. IER.NE.0) GO TO 8
C
C  READ DATA ONCE TO GET MAX AND MIN VALUES
      XMIN=100000.
      XMAX=0
      YMIN=10000.
      YMAX=0.
   51 READ (LUN,14,END=52) K,F
   14 FORMAT (3I5,2F10.5)
      IF (F(1).LT. 1.) GO TO 1
      XJ=FLOAT(K(1)**2+K(2)**2+K(3)**2)
      XY = ALOG(F(1))
      XMIN=AMIN1(XMIN,XJ)
      XMAX=AMAX1(XMAX,XJ)
      YMIN=AMIN1(YMIN,XY)
      YMAX=AMAX1(YMAX,XY)
      I=1
      IF (MOD(K(1)+K(2)+K(3),2).EQ.0) I=2
      S1(I) = S1(I)+1.
      S2(I) = S2(I)+XJ
      S3(I) = S3(I)+XY
      S4(I) = S4(I)+XJ*XJ
      S5(I) = S5(I)+XJ*XY
C
      GO TO 51
   52 DO 4 I=1,2
      D = S2(I)*S2(I)-S1(I)*S4(I)
      AM(I) = (S3(I)*S2(I)-S1(I)*S5(I))/D
      C(I) = (S2(I)*S5(I)-S4(I)*S3(I))/D
    4 CONTINUE
      YMAX=AMAX1(YMAX,C(1),C(2))
      CALL GETSCL(XMIN,XMAX,1)
      CALL GETSCL(YMIN,YMAX,2)
      CALL PLOTO(0.,0.,1.0,0)
C
      REWIND LUN
    1 READ (LUN,14,END=2) K,F
      IF (F(1).LT. 1.) GO TO 1
      XJ=FLOAT(K(1)**2+K(2)**2+K(3)**2)
      XY = ALOG(F(1))
      ER = ALOG(F(1)+F(2))-XY
      CALL PLOTO(XJ,XY,ER,1)
C
      GO TO 1
C
    2 AX=X(1,4)
      AY=X(2,4)-.4*X(2,3)
      DO 5 I=1,2
      WRITE (ITO,15) I,AM(I),C(I)
   15 FORMAT (/' ',I3,'Slope =',F10.5,'  Intercept =',F10.3)
      CALL PLCONV(AX,AY,4,Y1,Y2,7)
      MESSAG=' '
      WRITE (MESSAG,16) AM(I),C(I)
   16 FORMAT ('Slope =',F8.5,' Intercept =',F8.3)
      ILEN=LENGT(MESSAG)
      CALL SPCSET(7)
      CALL KANGA2(Y1,Y2,TLEN,MESSAG,ILEN)
C
      CALL PLOTO(0.,C(I),ER,-3)
      XMAX=X(1,1)+X(1,4)
      YMAX=X(2,1)+X(2,4)
      AAY = XMAX*AM(I) + C(I)
      IF (AY.GT. YMAX) THEN
      AAY=YMAX
      XMAX=(AAY-C(I))/AM(I)
      ENDIF
      ER=0.
      CALL PLOTO(XMAX,AAY,ER,-1)
      AY=AY-.4*X(2,3)
    5 CONTINUE
C
C  FINISH OFF
      CALL PIGLET(PW,PH,-999)
C
      STOP
      END
C
C
C
C
C LEVEL 50      PROGRAM MADUBM
      PROGRAM MADUBM
C
C *** MADUBM printing corrected by PJB C98 Oct-2000 ***
C
C *************************************************************************
C
C                        M A D U B M
C
C
C *************************************************************************
CC 2D
CH To generate D cards for the UB matrix read from a record stored on the
CH ILL data base
C
CD Reads the header part of a numor recorded by one of the
CD diffractometers D15, D9, D10, D16 or D19 and extracts the UB matrix and
CD wavelength. These data are converted into CCSL "D" card format and
CD appended to the crystal data file specified by the user.
CI There are no pre-requirements for the contents of the crystal data file
CI which may therefore be a new file.
CO A listing file giving the record number (numor) the wavelength and the UB
CO matrix.
CO
CO The updated crystal data file
C
CR On running the program the user is asked for the crystal data file on which
CR to write the D cards. This may be a new file, or one to which the D cards
CR should be appended. Following that, the instrument name, the
CR cycle number and the record number (numor) from which the UB matrix
CR should be read, are requested. The instrument should be one
CR of D15, D9, D10, D16 or D19.
CR The current reactor cycle is 0 (default), the previous
CR cycle -1, other cycles are given as 3 digit numbers: eg 962 for the second
CR cycle in 1996.
CR If the environment variable MADDATA is defined then the record will be read
CR from the file 'numor' with path MADDATA.
CN Note that if D cards are already present in a crystal data file they will
CN not be overwritten. The user must ensure that only one set is present
CN before using the crystal data file.
      DIMENSION RVAL(50),U(9),TABLE(1),IVALUE(31),TEXT(2)
      CHARACTER*4 INSTR,INAMS(5),TEXT*80,MADDAT*100
      LOGICAL SAYS,NOPATH
/IOUNIT/
/SCRACH/
      DATA INAMS/'d15 ','d9  ','d10 ','d16 ','d19'/
C
      CALL INITIL('MADUBM')
      MESSAG='File for D Cards'
      NAMFIL='.CRY'
      LUNI=NOPFIL(114)
      MADDAT=' '
      CALL GETENV('MADDATA',MADDAT)
      L=LENGT(MADDAT)
      NOPATH=(L.LT.1)
      IF (NOPATH) THEN
    2   CALL ASK('Instrument name?')
        INSTR=ICARD(1:4)
        IF (SAYS('D')) INSTR(1:1)='d'
        MANIP=NCFIND(INSTR,INAMS,5)
        IF (MANIP.EQ.0) THEN
          WRITE (ITO,109) INSTR
  109     FORMAT (' Instrument ',A4,' not known')
          GO TO 2
        ENDIF
      ENDIF
    1 IF (NOPATH) THEN
        CALL ASK('Give numor and cycle number for UB-matrix')
        MADDAT=INSTR
      ELSE
        CALL ASK('Give numor for UB-matrix')
        ICYC=-999
      ENDIF
      CALL RDINTG(NUMOR,1,IPT,6,IER)
      IF (IER .NE.0) THEN
        WRITE (ITO,104)
  104   FORMAT (' Error giving numor')
        GO TO 1
      ENDIF
      IF (NOPATH) THEN
        CALL RDINTG(ICYC,IPT,IPT1,IPT+5,IER)
        IF (IER.NE.0) ICYC=0
      ENDIF
      NSCN=0
      ISTA=LISPEC(MADDAT,ICYC,NUMOR,TEXT,IT,IVALUE,NI,RVAL,NF,TABLE,
     &NSCN)
      IF (ISTA.LT.0) THEN
        WRITE (ITO,105) NUMOR,ICYC
  105   FORMAT (' Record number',I5,' from cycle',I5,
     &   ' not found in the data-base')
        GO TO 1
      ENDIF
C
      U(1)=RVAL(12)
      U(2)=-RVAL(9)
      U(3)=RVAL(15)
      U(4)=RVAL(13)
      U(5)=-RVAL(10)
      U(6)=RVAL(16)
      U(7)=RVAL(14)
      U(8)=-RVAL(11)
      U(9)=RVAL(17)
      ALAM=RVAL(18)
C deduce geometry type
      IF (IVALUE(8) .EQ.2) THEN
        IGEO=8
      ELSE IF (ABS(RVAL(8)).GT.0.1) THEN
        IGEO=7
      ELSE IF (RVAL(5).GT.90.) THEN
        IGEO=11
      ELSE
        IGEO=6
      ENDIF
      IF (NOPATH) THEN
        WRITE (LPT,115) INSTR,NUMOR,ICYC
  115 FORMAT (1X,A4,' record',I7,' from cycle',I5)
      ELSE
  116 FORMAT (/' Record',I7,' from ',100A1)
        WRITE (LPT,116) NUMOR, (MADDAT(I:I),I=1,L)
      ENDIF
      WRITE (LUNI,106) ALAM,IGEO
      WRITE (LUNI,107) U
      WRITE (LPT,108) ALAM,IGEO
      WRITE (LPT,111) (U(I),I=1,3),(RVAL(8+I),I=1,3)
      WRITE (LPT,110) (U(3+I),I=1,3),(RVAL(11+I),I=1,3)
      WRITE (LPT,110) (U(6+I),I=1,3),(RVAL(14+I),I=1,3)
  108 FORMAT (/' Wavelength:', F10.4 ,' Geometry type: ',I2)
  111 FORMAT (/' CCSL UB matrix:',3F9.5 ,'   MAD UB matrix:',3f9.5)
  110 FORMAT (16X,3F9.5 ,17X,3F9.5)
  106 FORMAT ('D WVLN',F10.4/'D GEOM',I5/'D L/R  2')
  107 FORMAT (2('D UMAT',3F10.6/),'D UMAT',3F10.6)
      STOP
      END
C
C
C
C
C LEVEL 50      PROGRAM MAG3D
      PROGRAM MAG3D
C
C *** MAG3D Postscript arrows included C110 ***
C
CC 17D
CH To draw magnetic structures in 3D
CD MAG3D is a program to draw magnetic structures, described in a
CD standard crystal data file, on a terminal screen. The picture can be
CD rotated to obtain a satisfactory viewing angle and a high quality
CD representation of the structure can finally be written in postscript
CD format.
CI The crystal data file must contain all the information that would
CI be required for magnetic structure factor calculations viz:
CI      Symmetry (S) cards
CI      Cell (C) card
CI      Atom (A) cards
CI      Form factor (F) cards
CI      Magnetic structure (Q) cards
CI in addition special "X" cards are required to describe the graphical
CI output these are:
C
CI      X ARRO <Data> to define the proportions of arrows representing
CI        the magnetic moments.
CI        The <Data> are 5 real numbers: the head length, the head radius,
CI        the tail radius and the linewidth, all given as fractions of
CI        the total length of the arrow. The final number is the scale
CI        relating the length of an arrow in Angstroms to its moment
CI        in Bohr magnetons.
C
CI      X CM/A <Scale>
CI        <Scale> gives the scale of the picture in cms/Angstrom unit.
C
CI      X PERS <Data>   to define the perspective
CI        The <Data> are 3 real numbers: the cosine and sine of the angle
CI        that the direction perpendicular to the plane of the projection
CI        makes, in projection, with the negative x axis of the picture;
CI        and a factor giving the contraction in projection of vector
CI        components perpendicular to the plane of projection.
C
CI      X <Atom Name> SYMB <Data>  indicating how to draw each type of
CI        atom.
CI        There should be one SYMB card with a matching <Atom Name> for
CI        each A card.
CI        The <Data> are 2 real numbers: the radius of the atom in Angstrom
CI        units and the grey level to be used to paint it. Grey levels
CI        are in the range 0 to 1 with 0 being jet black and 1 pure white.
C
CI      X TRAN  <Data>    The transformation matrix
CI        The <Data> are 9 real numbers describing the transformation from
CI        orthogonal crystallographic axes to the projection axes for
CI        which x is perpendicular to the projection plane, z is
CI        vertical and y horizontal in the projection plane. The data
CI        are the direction cosines of the projection axes x,y,z on the
CI        crystal axes.
C
CI Example X cards for Fe2Ti
C
CI X PERS .5 .7660 .6428
CI X ARRO .333 0.1667 .0833 .02 1.2
CI X TRAN 1 0 0 0 1 0 0 0 1
CI X SYMB Fe1 .25 0.25
CI X SYMB Fe2 .25 0.25
CI X SYMB Ti .4 .8
CI X CM/A 1
CI
C
CO The usual listing file MAG3D.LIS reporting what was read from the
CO crystal data file and how it was interpreted.
CO
CO An optional screen dump of the graphic terminal can be obtained after
CO each picture is drawn if the plotter driver supports "hard copy".
CO
CO At the end of the program a "postscript" output file can be written
CO which gives a high quality rendering of the final picture. This file
CO will have the same name as the crystal data file and the
CO extension .PS.
CN The program can be run in conjunction with any graphical output
CN device for which a CCSL graphical driver(PIGLET) is available. It is
CN most conveniently run from an  X-terminal or one which emulates a
CN Tektronix 4010.
CR Once running, the program the user will be asked in the usual way for the
CR name of the crystal data file. Next the numbers of unit cells
CR to be drawn in the directions of the a,b and c crystallographic axes,
CR are required. They should be given in that order.
CR The screen will then switch to  graphic mode and the magnetic
CR structure will be drawn. When the drawing is complete the user is
CR asked whether a hard copy of the graphic screen is required. There is
CR then an option to rotate the picture about any of the the projection
CR axes; if this is selected the rotated  structure is drawn. When no
CR further rotation is requested the user may, if he wishes, record a new
CR crystal data file containing the latest rotation matrix. Finally the
CR user is given the option of making a "PostScript" output file. If this
CR is chosen a file with a name of the form 'CDF'.ps (where 'CDF' is
CR name of the crystal data file) is written before the program ends.
C
      EXTERNAL DOMAG1
      DIMENSION AM(2,3),POS(3,48),RX(3),TMP(4),PX(3),P(3),Q(3),SV(3),
     &SW(3),R(3),ROT(3,3),TEMP(3,3),ANGS(3),PL(3),SVV(3,2),KPI(3),KP(3),
     &KLIM(3,2),KL(3,2),ST(3),PLAT(3),KSOP(24)
      CHARACTER*10 FILNOM
      LOGICAL SAYS,DONE,NEWOP,FIRST,START
C
      COMMON/ARRAYS/ ARRAT(2,300),ARRAZ(300),IARRAT(300),INDA(300),
     &ALINE(2,100),BLINE(2,100),ALINEZ(100),BLINEZ(100),INDL(100),
     &ALEN(300),PHIP(300),ARRS(4,300),NAMAR(300),
     &ALABL(2,3),ALABZ(3),LAB(3),PHIL(4,3),BLABL(2,3)
      COMMON /ATMLAB/IDEN(20),LISTAR(20),NATLAB,XLEN,YLEN,
     &XMIN,YMIN,XLIM,YLIM,SYMAX
/ATNAM/
/CARDRC/
/CONSTA/
/IOUNIT/
/MAGDAT/
/NTITL/
      COMMON /PICDAT/CTHP,STHP,FHEAD,FRHEAD,FRTAIL,TRAN(9),
     &RA(20),HATCH(20)
/PICDEF/
/PLODAT/
      COMMON /POSTSC/INPATH,FILL,XP,YP,LETSPC(7),PSIZE(5),RTFONT(5),
     &NFONT,POSTC
      LOGICAL INPATH,FILL,POSTC
/POSNS/
/NSYM/
/SATELL/
/SCRACH/
/SYMDA/
/SYMMAG/
/TITLE/
C
      POSTC=.FALSE.
      START=.TRUE.
      NLINES=0
      NARAT=0
      NARS=0
      CALL PREFIN('MAG3D')
C SET UP CRYSTALLOGRAPHY
      CALL SETFCM(DOMAG1)
      CALL MAGCNC
      CALL DOMAG1(2)
      MODUL=(MTYP.EQ.3 .OR. MTYP.EQ.4)
      IHELIX=1
      IF (MTYP.EQ.3) IHELIX=2
C SET UP A TABLE GIVING ONE OPERATOR WHICH GENERATES EACH DOMAIN
      KSOP(1)=1
      I=2
      DO 71 J=2,NOPC
      IF (KSTAB(J).NE.I) GO TO 71
      KSOP(I)=J
      I=I+1
      IF (I.GT.NKC) GO TO 70
   71 CONTINUE
C
C READ X CARDS GIVING PICTURE DEFINITIONS
   70 CALL MAG3DX
      CALL ERRMES(0,0,'for MAG3D')
C
C FIND MAXIMUM ARROW LENGTH
      AMUMAX=0
      DO 30 I=1,NMAG
      DO 30 J=1,IHELIX
      IF (SMOD(J,I).GT.AMUMAX) AMUMAX=SMOD(J,I)
   30 CONTINUE
      AMUMAX=0.5*AMUMAX*APERMB
C MAKE AT LEAST THE LENGTH OF AN AXIS MARKER
      AMUMAX=AMAX1(AMUMAX,1.5)
C IDENTIFY ATOMS FOR LABELS
      CALL ATLABS(1)
C
C  INITIAL DIALOGUE
   22 CALL ASK('Number of cells in x,y, and z directions')
      CALL RDNUMS(TMP,1,4,N,IER)
      IF (IER.NE.0) GO TO 22
C SET THE MESH LIMITS
      CALL JGMZER(KLIM(1,1),3,1)
      CALL INDFIX(TMP,KLIM(1,2))
C
C  GET PLOTTER
      CALL PIGLET(0.,0.,0)
C
C  READ AND MEASURE TITLE
      CALL INPUTN(LPT)
      CALL KANGA2(0.,0.,TLEN,ITITLE,-NTITLE)
C  SPACE FOR TITLE
      TLEN=TLEN+2.*CHUNIT
C
C
C RE-ENTRY POINT AFTER ROTATION
C MAX AND MIN IN X AND Y
   50 XVMAX=-999.
      XVMIN=999.
      YVMAX=-999.
      YVMIN=999.
      NLINES=0
      NARAT=0
      NARS=0
      DO 7 J=1,2
      CALL INDFLO(R,KLIM(1,J))
      DO 7 I=0,3
      IF (I.NE.0) THEN
        CALL GMZER(RX,3,1)
        RX(I)=FLOAT(KLIM(I,2))
        IF (J.EQ.1) THEN
          CALL GMADD(R,RX,P,3,1)
        ELSE
          CALL GMSUB(R,RX,P,3,1)
        ENDIF
      ELSE
        CALL GMEQ(R,P,3,1)
      ENDIF
      CALL PERSPC(P,Q,1)
      XV=Q(1)
      YV=Q(2)
      IF (XV.GT.XVMAX) XVMAX=XV
      IF (XV.LT.XVMIN) XVMIN=XV
      IF (YV.GT.YVMAX) YVMAX=YV
      IF (YV.LT.YVMIN) YVMIN=YV
    7 CONTINUE
      WIDTH=XVMAX-XVMIN
      HEIGHT=YVMAX-YVMIN
C
C  TITLE CHARACTERS
      CHU1=(WIDTH)/TLEN
      CH1=CHU1*CHUNIT*ASPECT
      IF (CH1 .GT. 1.0) THEN
        CH1=1.
        CHU1=CH1/(CHUNIT*ASPECT)
      ENDIF
C
C  SIZE OF PICTURE
      AMARG=0.1*AMAX1(HEIGHT,WIDTH)
C  ALLOW FOR PROJECTING ARROWS
      PW=WIDTH +2.*AMARG+2*APERMB
      PH=HEIGHT+2.*AMARG+5.*CH1+2*APERMB
      IF (START)CALL PIGLET(PW,PH,999)
      CALL PIGLET(PW,PH,888)
      START=.FALSE.
C
C  SET GRAPH SPACE
      AM(1,1)=1
      AM(1,2)=0.
      AM(2,1)=0.
      AM(2,2)=1
C  ORIGIN OFFSET
      AM(1,3)=-XVMIN+AMARG+AMUMAX
      AM(2,3)=-YVMIN+AMARG+5.*CH1+AMUMAX
      CALL PLTRIN(AM,4,3)
C SET POSTSCRIPT PAGESIZE AND ORIGIN
      PWIDTH=WIDTH+AMUMAX*2.
      PHGHT=HEIGHT+AMUMAX*2. +(3./CMPERA)
      X0=-XVMIN+AMUMAX
      Y0=-YVMIN+AMUMAX
C
C
C  CHARACTER SPACE FOR TITLE
      TWID=TLEN*CHU1
      WDIF=(PW-TWID)/2.
      AM(1,1)=CHU1
      AM(2,2)=CHU1*ASPECT
      AM(2,1)=0.
      AM(1,2)=0.
      AM(1,3)=WDIF
      AM(2,3)=AMARG
      CALL PLTRIN(AM,5,3)
      CALL SPCSET(5)
      CALL FRAME(0.,0.,TLEN,2.*CHUNIT)
      CALL KANGA2(CHUNIT,0.5*CHUNIT,TL,ITITLE,NTITLE)
C
C  CHARACTER SPACE FOR AXIS LABELS
      CH2=0.5
      CHU2=CH2/CHUNIT
      AM(1,1)=CHU2
      AM(2,2)=CHU2*ASPECT
      AM(1,3)=0.
      AM(2,3)=0.
      CALL PLTRIN(AM,6,4)
C
C  DRAW THE CELLS
      CALL SPCSET(4)
      DONE=.TRUE.
      DO 1 I=1,3
      CALL JGMEQ(KLIM(1,1),KPI,3,1)
      CALL JGMZER(KP,3,1)
      KP(I)=KLIM(I,2)-KLIM(I,1)
      CALL JGMEQ(KLIM,KL,3,2)
      KL(I,2)=KL(I,1)
      CALL INDFLO(RX,KP)
C SET THAT WE WANT ALL LIMITS
      ISW=7
    2 CALL INDFLO(R,KPI)
      CALL PERSPC(R,Q,1)
      CALL KANGA1(Q(1),Q(2),3)
      CALL ERRCHK(2,NLINES,100,-1,'Too many lines to store')
      ALINE(1,NLINES)=Q(1)
      ALINE(2,NLINES)=Q(2)
      ALINEZ(NLINES)=Q(3)
      CALL GMADD(R,RX,R,3,1)
      CALL PERSPC(R,Q,1)
      CALL KANGA1(Q(1),Q(2),2)
      BLINE(1,NLINES)=Q(1)
      BLINE(2,NLINES)=Q(2)
      BLINEZ(NLINES)=Q(3)
      IF (DONE) THEN
C  MAKE A SPECIAL POSTSCRIPT ARROW FOR THE AXIS LABEL
        LAB(I)=I
        CALL ORTHO(R,ST,1)
        CALL GMPRD(TRAN,ST,SV,3,3,1)
        CALL UNIVEC(SV,AL)
        CALL ARTILT(SV,PHIL(1,I))
        CALL GMSCA(SV,ST,AL+0.6,3,1)
        CALL PERSPC(ST,Q,0)
        ALABL(1,I)=Q(1)
        ALABL(2,I)=Q(2)
        ALABZ(I)=Q(3)
        CALL GMSCA(SV,ST,AL+1.1,3,1)
        CALL PERSPC(ST,Q,0)
        AL=SQRT(Q(1)*Q(1)+Q(2)*Q(2))
        ALS=(0.3/AL)+1.
        CALL GMSCA(Q,BLABL(1,I),ALS,2,1)
        CALL LABAXE(ALABL(1,I),BLABL(1,I),1.0,PHIL(1,I),I)
      ENDIF
      CALL LATGEN(KPI,KP,KL,DONE,ISW,ISWO)
      IF (DONE) GO TO 1
      CALL JGMEQ(KP,KPI,3,1)
      GO TO 2
    1 CONTINUE
C
C  GENERATE THE ATOMIC POSITIONS
      DO 5 NA=1,NATOM
      NMAG=MAGAT(NA)
      IF (NMAG.NE.0) THEN
C  SET THE SPIN DIRECTION FOR THIS ATOM
        CALL SPHPOL(ANGM(1,NMAG),ANGM(2,NMAG),SPIND(1,1,1,NMAG),3)
        IF (MTYP.EQ.3)
     &  CALL SPHPOL(ANGM(3,NMAG),ANGM(4,NMAG),SPIND(1,1,2,NMAG),3)
      ENDIF
      CALL GMEQ(X(1,NA),POS(1,1),1,3)
      FIRST=.TRUE.
C MARK WHICH ARE NEEDED FOR LABELS
      DO 35 N=1,NATLAB
      IF (IDEN(N).EQ.NA) LISTAR(N)=NARAT+1
   35 CONTINUE
      M=1
      DO 6 IC=1,3-2*NCENT,-2
      DO 4 N=1,NOPC
      CALL ROTSYM(X(1,NA),PX,N,1)
      if (ic.lt.0) call gmrev(px,px,3,1)
      CALL GMADD(PX,TRANS(1,N),PX,3,1)
      NEWOP=.TRUE.
      DO 14 NL=1,NLAT
      CALL GMADD(PX,ALAT(1,NL),RX,3,1)
      CALL EQPOS(POS(1,1),RX,M,M1,48)
      IF (M1.GT. M .OR. FIRST) THEN
        M=M1
        FIRST=.FALSE.
        CALL GMSUB(RX,POS(1,M),PLAT,3,1)
C64 GMADD CHANGED TO GMSUB order of subraction reversed
C82 order of subraction reversed
        CALL GMSUB(ALAT(1,NL),PLAT,PLAT,3,1)
C GET PHASE OFFSET
      IF (NMAG.NE.0 .AND. NEWOP) THEN
        PH0=0
        jop=0
        IF (MODUL) THEN
          if (n .eq.1) then
            jop=1
            if (ic.eq.-1 .and. mstab(1) .gt.0)  jop=-1
C111 this was    (mstab(n).ne.IC)
          else if (abs(mstab(n)).ne. 1) then
C If this operator is not in the magnetic group need a phi value
            jop=mstab(n)
          endif
          if (jop.ne.0) then
%           JP=NFIND(JOP,LPHI(1,NMAG),4)
            IF (JP .EQ.0) call ERRIN2(JOP,0,'PSI value for the '//
     &      'sublattice of '//ATNAME(NA)//' generated by operator',
     &      ' not found')
            PH0=PH0+RADIAN(PHIH(JP,NMAG))
          endif
        endif
      endif
C  DRAW THE ARROWS AND ATOMS
C
C  WORK OVER UNIT CELLS
        CALL JGMEQ(KLIM(1,1),KP,3,1)
C SET THE BOUNDARY SWITCH
        J=1
        ISW=0
        DO 11 I=1,3
        IF (ABS(POS(I,M)).LT..0001) ISW=ISW+J
        J=2*J
   11   CONTINUE
   15   CALL INDFLO(PL,KP)
        CALL JGMEQ(KP,KPI,3,1)
        CALL GMADD(POS(1,M),PL,R,3,1)
        CALL PERSPC(R,Q,1)
        CALL ERRCHK(2,NARAT,300,-1,'Too many positions generated')
        ARRAT(1,NARAT)=Q(1)
        ARRAT(2,NARAT)=Q(2)
        ARRAZ(NARAT)=Q(3)
        NAMAR(NARAT)=NA
C FOR MAGNETIC ATOMS
        IF (NMAG.NE.0) THEN
          IF (NEWOP) THEN
            DO 9 I=1,IHELIX
            CALL GMPRD(OTRSYM(1,1,N),SPIND(1,1,I,NMAG),SVV(1,I),3,3,1)
C  IF INVERSION IS INCLUDED
            IF (IC.EQ.-1) THEN
              CALL GMPRD(OTRSYM(1,1,NOPC+1),SVV(1,I),SW,3,3,1)
              CALL GMEQ(SW,SVV(1,I),3,1)
            ENDIF
    9       CONTINUE
            NEWOP=.FALSE.
          ENDIF
          DO 96 IK=1,NKC
C PHASE FOR THIS PROPAGATION VECTOR
          CALL GMADD(PLAT,PL,PL,3,1)
          PHASE=PH0+TWOPI*SCALPR(AKSTAR(1,IK),PL)
C         PHASE=EXOPHS(PHASE)
          PHP=SMOD(1,NMAG)*COS(PHASE)
          CALL GMSCA(SVV(1,1),SW,PHP,3,1)
          IF (IHELIX.EQ.2) THEN
            PHP=SMOD(2,NMAG)*SIN(PHASE)
            CALL GMSCA(SVV(1,2),ST,PHP,3,1)
            CALL GMADD(ST,SW,SW,3,1)
          ENDIF
          IF (IK.EQ.1) THEN
              CALL GMEQ(SW,SV,3,1)
            WRITE (LPT,231) N,IC,NL,KP,IK,PH0,PHASE,SV
          ELSE
C ROTATION FOR THIS PROPAGATION VECTOR
            CALL GMPRD(OTRSYM(1,1,KSOP(IK)),SW,ST,3,3,1)
C ADD THE CONTRIBUTIONS FOR MULTI-K STRUCTURES
            CALL GMADD(SV,ST,SV,3,1)
            WRITE (LPT,231) N,IC,NL,KP,IK,PH0,PHASE,ST
          ENDIF
  231     FORMAT(1X,3I3,2X,3I3,2X,I3,2F10.4,2X,3F8.3)
   96     CONTINUE
          WRITE (LPT,230) N,IC,KP,PH0,PHASE,SV
  230     FORMAT(1X,2I3,2X,3I3,2F10.4,2X,3F8.3)
C  TRANSFORM TO ROTATED SYSTEM
          CALL GMPRD(TRAN,SV,ST,3,3,1)
          CALL GMEQ(ST,SV,3,1)
          CALL UNIVEC(SV,AL)
          IF (AL.GT..0005) THEN
            AL=AL*APERMB
            CALL ERRCHK(2,NARS,300,-1,'Too many arrows generated')
            IARRAT(NARAT)=NARS
            ALEN(NARS)=AL
            CALL ARTILT(SV,ARRS(1,NARS))
            WRITE (LPT,5000) R,SV,DEGREE(ARRS(1,NARS)),
     &      (ARRS(I,NARS),I=2,4)
 5000 FORMAT(1X,3F8.2,2X,3F10.5,F8.2,3F8.4)
            A=Q(1)
            B=Q(2)
            CALL AROW3D(A,B,AL,ARRS(1,NARS))
          ELSE
            IARRAT(NARAT)=0
            CALL SPCSET(4)
            CALL CIRCLE(Q(1),Q(2),RA(NA),NINT(HATCH(NA)*10.))
          ENDIF
        ELSE
          IARRAT(NARAT)=0
          CALL SPCSET(4)
          CALL CIRCLE(Q(1),Q(2),RA(NA),NINT(HATCH(NA)*10))
        ENDIF
          CALL LATGEN(KPI,KP,KLIM,DONE,ISW,ISWO)
          IF (.NOT. DONE) GO TO 15
      ENDIF
   14 CONTINUE
    4 CONTINUE
    6 CONTINUE
    5 CONTINUE
C
C  FINISH OFF
      CALL PIGLET(A,B,-888)
      CALL GRAFOF
      CALL ASK ('Rotation of picture? Y(es) or N(o)')
      IF (SAYS('Y')) THEN
   51   WRITE (ITO,107)
  107 FORMAT (' Axis definition: x points out of screen'/
     &17X,'y is in the screen pointing right'/
     &17X,'z is vertical')
        CALL ASK(' Give angles for rotation about x, y and z axes')
        CALL RDNUMS(ANGS,1,3,NUM,IER)
        IF (IER.NE.0) GO TO 51
        CALL GRAFON
        J=2
        K=3
        DO 52 I=1,3
        IF (ABS(ANGS(I)).LT..01) GO TO 53
        ANGS(I)=RADIAN(ANGS(I))
        CALL GMUNI(ROT,3,3)
        ROT(J,J)=COS(ANGS(I))
        ROT(K,K)=ROT(J,J)
        ROT(J,K)=-SIN(ANGS(I))
        ROT(K,J)=-ROT(J,K)
        CALL GMEQ(TRAN,TEMP,3,3)
        CALL GMPRD(ROT,TEMP,TRAN,3,3,3)
   53   J=K
        K=I
   52   CONTINUE
        GO TO 50
      ELSE
        CALL ASK(' Save rotation matrix? Y(es) or N(o)')
        IF (SAYS('Y')) THEN
          CALL FINDCD('X','TRAN',4,0,ICD)
          WRITE (ICARD,110) TRAN
  110 FORMAT ('X TRAN',9F8.4)
          CALL NEWCRY(ICD,'X',LUNO)
          CALL CLOFIL(LUNO)
        ENDIF
      ENDIF
      CALL PIGLET(A,B,-999)
      CALL ASK(' Postscript output file? Y(es) or N(o)')
        IF (SAYS('Y')) THEN
        CALL POSOUT(NARAT,NLINES)
        CALL MESS(ITO,0,'Postscript output on '//FILNOM(IPLO))
      ENDIF
      STOP
      END
C
C
C
C
      SUBROUTINE AROW3D(XP,YP,AL,ARDAT)
C
C *** AROW3D improved by PJB March 1992 ***
C
C Draws 3d arrows on the plotter
C
CC 17B
CH To draw 3D arrows
C
CA XP,YP is the position for the arrow in space 4
CA AL is the length in Angstoms(space 4)
CA Arrow drawing data in ARDAT(4): can be filled in by subroutine ARTILT
CA           PHI1 (ARDAT(1)) is the angle of rotation of the projected
CA                arrow from the x axis of the picture (in radians)
CA           PHI2 (ARDAT(2)) is the angle of rotation of the minor axis of
CA                projected ellipses from the projected arrow direction.
CA           FR (ARDAT(3)) is the perspective foreshortening factor in the
CA               direction parallel to the projection of the arrow
CA           EX (ARDAT(4)) is the ratio of the minor to major axes of
CA               projected ellipses
CP MAG3DX to put the arrow definition in COMMON PICDEF
C
CN Uses plotter space 5 to keep the transformation for the arrow rotation
C
C  DEFINITION OF THE PROPORTIONS:
C            FHEAD is the ratio if the head length to AL
C            FRHEAD is the ratio of the head radius to AL
C            FRTAIL is the ratio of the tail radius to AL
C
      DIMENSION AM(2,3),X(2),Y(2),XT(2),YT(2),YTT(2),XS(2,2),YS(2,2),
     &THET(2),THT(2),THR(2),HANG(2),TANG(2,2),SLOPE(2),ARDAT(4)
      LOGICAL IN,HEADIN,INSIDE,FLAT
/CONSTA/
      COMMON /PICDAT/CTHP,STHP,FHEAD,FRHEAD,FRTAIL,TRAN(9),
     &RA(20),HATCH(20)
C
      PHI1=ARDAT(1)
      PHI2=ARDAT(2)
      FR=ARDAT(3)
      IN=(ARDAT(4).LT.0)
      EX=ABS(ARDAT(4))
      FLAT=(EX.LT. .0001)
C SET SPACE 5 FOR ARROW DRAWING
      AM(1,1)=COS(PHI1)*AL/2.
      AM(1,2)=SIN(PHI1)*AL/2.
      AM(2,2)=AM(1,1)
      AM(2,1)=-AM(1,2)
      AM(1,3)=XP
      AM(2,3)=YP
      CALL PLTRIN(AM,5,4)
      CALL SPCSET(5)
C
      HEAD=2*FHEAD*FR
      ARRO=FR
      YJUNC=ARRO-HEAD
      YEND=-ARRO
C
      T1=COS(PHI2)
      T2=SIN(PHI2)
C
C CALCULATE TANGENT POINTS
      A=FRHEAD
      B=EX*FRHEAD
C
C POINT ON AXIS
      XP=HEAD*T2/A
      YP=HEAD*T1/B
      EX2=EX*EX
      R2=(XP*XP+YP*YP)
      HEADIN=(R2.LE.1.)
      IF (.NOT.HEADIN) THEN
        SLOPEA=-(XP*YP)
        SLOPEB=SQRT(R2-1.)
        AMUL=EX/(1.-XP*XP)
        SLOPE(1)=AMUL*(SLOPEA+SLOPEB)
        SLOPE(2)=AMUL*(SLOPEA-SLOPEB)
        DO 1 I=1,2
        THET(I)=ATAN2(-EX2,SLOPE(I))
        CT=COS(THET(I))
        ST=SIN(THET(I))
        AMUL=B/SQRT(CT*CT*EX2+ST*ST)
        TEST1=SIGN(1.,YP*B-SLOPE(I)*A*XP)
C  TEST TO SEE WHETHER THIS IS THE RIGHT SIDE OF THE ELIPSE
        TEST2=SIGN(1.,ST-CT*SLOPE(I))
        IF (ABS(TEST1-TEST2).GT. .0005) THEN
          CT=-CT
          ST=-ST
          THET(I)=THET(I)+PI
        ENDIF
        XT(I)=AMUL*(CT*T1-ST*T2)
        YT(I)=AMUL*(ST*T1+CT*T2)
        THET(I)=THET(I)+PHI2
    1   CONTINUE
C DRAW ARROW HEAD
        CALL KANGA1(0.,ARRO,3)
        CALL KANGA1(XT(1),ARRO-HEAD+YT(1),2)
        CALL KANGA1(0.,ARRO,3)
        CALL KANGA1(XT(2),ARRO-HEAD+YT(2),2)
      ELSE
        IF (.NOT.IN) CALL elipse(0.,ARRO,.05*A,1.,0.,0.,TWOPI)
      ENDIF
C GEOMETRY FOR STALK
      F=FRTAIL/FRHEAD
      DEN2=EX*EX*T2*T2+T1*T1
      DEN=SQRT(DEN2)
      BIT=A*EX*SQRT(1.-F*F)*DEN
      CT2=A*F*DEN
C INTERSECTION OF STALK WITH ARROWHEAD ELLIPSE
      X(1)=-((T1*CT2+T2*BIT)/DEN2)
      X(2)=(T1*CT2-T2*BIT)/DEN2
      TMP=CT2*EX2*T2
      Y(1)=(TMP-T1*BIT)/DEN2
      Y(2)=(-TMP-T1*BIT)/DEN2
C ANGLES AND COORDS FOR JOINTS WITH STALK ELLIPSE
      ANG=ATAN2(-(EX2*T2),T1)
      XRT=-CT2
      YRT=CT2*T1*T2*(EX2-1)/DEN2
      THR(1)=ANG+PHI2
      THR(2)=ANG+PI+PHI2
      DO 2 I=1,2
      THT(I)=ATAN2(Y(I),X(I))+PHI2
      YTT(I)=X(I)*T2+Y(I)*T1
    2 CONTINUE
      INSIDE=(YJUNC+YTT(1).LT.YEND)
C STALK INSIDE ARROW HEAD ELLIPSE
      XS(1,1)=-XRT
      YS(1,2)=YRT+YEND
      XS(1,2)=+XRT
      YS(2,2)=-YRT+YEND
      IF (IN) THEN
        YS(1,1)=YRT+YJUNC
        YS(2,1)=-YRT+YJUNC
        HANG(1)=0
        HANG(2)=TWOPI
        TANG(1,1)=THR(1)
        TANG(2,1)=THR(2)
        TANG(1,2)=0
        TANG(2,2)=TWOPI
        IF (.NOT.INSIDE) THEN
          HANG(1)=THT(2)
          HANG(2)=THT(1)
        ENDIF
      ELSE
        YS(1,1)=YTT(1)+YJUNC
        YS(2,1)=YTT(2)+YJUNC
        IF (HEADIN) THEN
          HANG(1)=0
          HANG(2)=TWOPI
        ELSE
          HANG(1)=THET(1)
          HANG(2)=THET(2)
        ENDIF
        TANG(1,2)=THR(2)
        TANG(2,2)=THR(1)
      ENDIF
C DRAW THE ELLIPSES AND THE STALK
      CALL elipse(0.,YJUNC,FRHEAD,EX,PHI2,HANG(1),HANG(2))
      IF (IN) CALL elipse(0.,YJUNC,FRTAIL,EX,PHI2,TANG(1,1),TANG(2,1))
      IF (IN .OR. .NOT. INSIDE) THEN
        CALL elipse(0.,YEND,FRTAIL,EX,PHI2,TANG(1,2),TANG(2,2))
        CALL KANGA1(XRT,YS(1,1),3)
        CALL KANGA1(XRT,YS(1,2),2)
        CALL KANGA1(-XRT,YS(2,1),3)
        CALL KANGA1(-XRT,YS(2,2),2)
      ENDIF
      RETURN
      END
C
C
C
C
      SUBROUTINE ARTILT(R,ARDAT)
C
C *** ARTILT NEW BY PJB MARCH 1992 ***
C
CC 17B
CH To define the tilt parameters for 3d arrows
CA On entry: R is a unit vector parallel to the spin, on the orthogonal
CA           coordinate system of the picture.
CA On exit:  Arrow drawing data in ARDAT(4)
CA           PHI1 (ARDAT(1)) is the angle of rotation of the projected
CA                arrow from the x axis of the picture (in radians)
CA           PHI2 (ARDAT(2)) is the angle of rotation of the minor axis of
CA                projected ellipses from the projected arrow direction.
CA           FR (ARDAT(3)) is the perspective foreshortening factor in the
CA               direction parallel to the projection of the arrow
CA           FT (ARDAT(4)) is the ratio of the minor to major axes of
CA               projected ellipses
CP MAG3DX to set the perspective transformation in COMMON PICDAT and the
CP arrow definition in PICDEF
C
      DIMENSION R(3),RP(3),T(3),TP(3),TMP(3),ARDAT(4)
      LOGICAL IN,TESTOV,FLAT
      COMMON /PICDAT/CTHP,STHP,FHEAD,FRHEAD,FRTAIL,TRAN(9),
     &RA(20),HATCH(20)
C
      CALL PERSPC(R,RP,0)
      PHI1=ATAN2(RP(1),RP(2))
      FR=SQRT(RP(1)*RP(1)+RP(2)*RP(2))
      FLAT=(ABS(RP(3)) .LT. .001)
C  SET IN TO SAY WHETHER POINTING IN OR OUT OF PAPER
      IN=(RP(3).LT.0)
C FIND THE VECTOR PERPENDICULAR TO R IN THE PROJECTION PLANE
C THIS IS THE MAJOR AXIS OF THE ELLIPSE
      SUM=(R(2)*R(2)+R(3)*R(3))
      IF (TESTOV(1.,SUM)) THEN
        SX=1.
        SY=0.
        TP(1)=0.
        TP(2)=1.
        FT=1.
        PHI2=0.
      ELSE
        ANORM=1./SQRT(SUM)
        SX=R(3)*ANORM
        SY=-(R(2)*ANORM)
C THEN THE VECTOR PERPENDICULAR TO R WHOSE PROJECTION IS PERPENDICULAR TO S
C GET THE CONSTANTS FROM THE PERSPECTIVE TRANSFORMATION
        T(1)=-1.
        T(2)=0
        T(3)=0
        CALL PERSPC(T,TMP,0)
        T(1)=SUM
        T(2)=-(R(1)*R(2))-R(2)*R(3)*TMP(2)+R(3)*R(3)*TMP(1)
        T(3)=-(R(1)*R(3))-R(2)*R(3)*TMP(1)+R(2)*R(2)*TMP(2)
        CALL UNIVEC(T,DT)
        CALL PERSPC(T,TP,0)
        IF (FLAT) IN=(TP(1)*RP(1)+TP(2)*RP(2).GT.0)
C THIS IS THE MINOR AXIS
        FT=SQRT(TP(1)*TP(1)+TP(2)*TP(2))
        SN=(SX*RP(1)+SY*RP(2))/SQRT(SX*SX+SY*SY)
        CS=(TP(1)*RP(1)+TP(2)*RP(2))/FT
        PHI2=ATAN2(-SN,CS)
      ENDIF
C
      IF (IN) FT=-FT
      ARDAT(1)=PHI1
      ARDAT(2)=PHI2
      ARDAT(3)=FR
      ARDAT(4)=FT
      RETURN
      END
C
C
C
C
      SUBROUTINE ARROW(P,AL,S,ID)
C
C *** ARROW NEW BY PJB DECEMBER 1991 ***
C
CC 17B
CH Writes postscript output to plot an arrow in MAG3D
C
      DIMENSION P(2),S(4),Q(2)
      COMMON /GRAYS/IOLD
/IOUNIT/
      COMMON /PICDAT/CTHP,STHP,FHEAD,FRHEAD,FRTAIL,TRAN(9),
     &RA(20),HATCH(20)
/PICDEF/
C
      IF (ID.NE.IOLD) THEN
        IOLD=ID
        GRAY3=HATCH(ID)
        IBASE=NINT(GRAY3*12)
        I1=MOD(IBASE+4,12)
        GRAY1=FLOAT(I1)/12.
        I1=MOD(IBASE+8,12)
        GRAY2=FLOAT(I1)/12.
        WRITE (IPLO,10) AMIN1(GRAY1,GRAY2),AMAX1(GRAY1,GRAY2),GRAY3
   10   FORMAT (3F6.2,' Graydef')
      ENDIF
      CALL GMSCA(P,Q,CMPERA,2,1)
      SAL=AL*CMPERA
      RAD=RA(ID)*CMPERA
      ANG=DEGREE(S(1))
      IF (S(4).GT.0) THEN
        WRITE (IPLO,11) Q,SAL,RAD,ANG,S(3),ABS(S(4))
   11   FORMAT (4F8.2,F8.1,2F8.4,' Arrowout')
      ELSE
        WRITE (IPLO,12) Q,SAL,RAD,ANG,S(3),ABS(S(4))
   12   FORMAT (4F8.2,F8.1,2F8.4,' Arrowin')
      ENDIF
      RETURN
      END
C
C
C
C
      SUBROUTINE ATLAB(P,NAME)
C
C *** ATLAB new by PJB March 1992 ***
C
CC 17C
CH Writes an atom name on the postscript output file
CA P gives the position and NAME the name
C
      DIMENSION P(2),Q(2)
      CHARACTER*4 NAME
C
/IOUNIT/
      COMMON /PICDAT/CTHP,STHP,FHEAD,FRHEAD,FRTAIL,TRAN(9),
     &RA(20),HATCH(20)
/PICDEF/
C
      CALL GMSCA(P,Q,CMPERA,2,1)
      WRITE (IPLO,10) NAME,Q
   10 FORMAT ('(',A4,')',2F6.1,' Atlab')
      RETURN
      END
C
C
C
C
      SUBROUTINE ATLABS(MODE)
C
C *** ATLABS new by PJB April 92 ***
C
CC 17C
CH Makes a key for the atom symbols in MAG3D
CA A multiple entry subprogram driven by MODE
CA MODE = 1  Identify the inequivalent atoms
CA MODE = 2  Arrange the space needed for the key
CA MODE = 3  Write the key
C
      DIMENSION R(2)
C
      COMMON/ARRAYS/ ARRAT(2,300),ARRAZ(300),IARRAT(300),INDA(300),
     &ALINE(2,100),BLINE(2,100),ALINEZ(100),BLINEZ(100),INDL(100),
     &ALEN(300),PHIP(300),ARRS(4,300),NAMAR(300),
     &ALABL(2,3),ALABZ(3),LAB(3),PHIL(4,3),BLABL(2,3)
      COMMON /ATMLAB/IDEN(20),LISTAR(20),NATLAB,XLEN,YLEN,
     &XMIN,YMIN,XLIM,YLIM,SYMAX
/ATNAM/
      COMMON /PICDAT/CTHP,STHP,FHEAD,FRHEAD,FRTAIL,TRAN(9),
     &RA(20),HATCH(20)
/PICDEF/
/POSNS/
      DATA FONTSZ/0.86/
C
      FONTSC=FONTSZ/CMPERA
      GO TO (10,20,30), MODE
C
C MODE 1 TO COUNT THE IDENTIFYING ATOMS
   10 NATLAB=1
      IDEN(1)=1
      DO 1 IAT=1,NATOM
      DO 2 IA=1,NATLAB
      IF (ABS(RA(IAT)-RA(IDEN(IA))).LT..001.AND.
     &ABS(HATCH(IAT)-HATCH(IDEN(IA))).LT..001) GO TO 1
    2 CONTINUE
      NATLAB=NATLAB+1
      IDEN(NATLAB)=IAT
    1 CONTINUE
      GO TO 100
C
C  ESTIMATE LENGTH NEEDED FOR ATOM LABELS
   20 XLEN=0.
      YLEN=0.
      SYMAX=0.
      DO 4 IA=1,NATLAB
      L=IDEN(IA)
      J=IARRAT(LISTAR(IA))
      IF (J.NE.0) THEN
        XBIT=ALEN(J)*ABS(SIN(ARRS(1,J)))*ARRS(3,J)
        XBIT=AMAX1(2.*RA(L),XBIT)
        YBIT=ALEN(J)*ABS(COS(ARRS(1,J)))*ARRS(3,J)
        YBIT=AMAX1(2.*RA(L),YBIT)
      ELSE
        XBIT=2.*RA(L)
        YBIT=2.*RA(L)
      ENDIF
      SYMAX=AMAX1(XBIT,SYMAX)
      CLEN=FONTSC*FLOAT(LENGT(ATNAME(L))+1)
      XBIT=XBIT+CLEN
      XLEN=AMAX1(XLEN,XBIT)
      YBIT=AMAX1(YBIT,FONTSC)
      YLEN=YLEN+YBIT+FONTSC
    4 CONTINUE
      SYMAX=SYMAX/2.
      NC=IFIX(YLEN/(PHGHT-(2.5/CMPERA)))+1
      XMIN=PWIDTH-X0+SYMAX+0.8*FONTSC
      PWIDTH=PWIDTH+XLEN*FLOAT(NC)
      YLEN=YLEN/FLOAT(NC)
      YMIN=-Y0+((PHGHT-(3./CMPERA)-YLEN))/2.
      YLIM=YMIN+YLEN
      GO TO 100
C
C ENTER HERE TO WRITE THE ATOM LABELS
   30 R(1)=XMIN
      R(2)=YLIM
      DO 5 IA=1,NATLAB
      L=IDEN(IA)
      J=IARRAT(LISTAR(IA))
      IF (J.NE.0 .AND. ALEN(J).GT..001) THEN
        YBIT=ALEN(J)*ABS(COS(ARRS(1,J)))*ARRS(3,J)
        YBIT=AMAX1(2.*RA(L),YBIT)
        XBIT=ALEN(J)*ABS(SIN(ARRS(1,J)))*ARRS(3,J)
        XBIT=AMAX1(2.*RA(L),XBIT)
        R(2)=R(2)-YBIT/2
        CALL ARROW(R,ALEN(J),ARRS(1,J),L)
      ELSE
        XBIT=2.*RA(L)
        YBIT=2.*RA(L)
        R(2)=R(2)-YBIT/2
        CALL ATOM(R,NAMAR(LISTAR(IA)))
      ENDIF
      R(1)=R(1)+SYMAX+0.2*FONTSC
      R(2)=R(2)-0.4*FONTSC
      CALL ATLAB(R,ATNAME(L))
      R(2)=R(2)-(YBIT/2.)-(0.6*FONTSC)
      IF (R(2) .LT.YMIN) THEN
        R(2)=YLIM
        R(1)=XMIN+XLEN
      ENDIF
      R(1)=XMIN
    5 CONTINUE
C
  100 RETURN
      END
C
C
C
C
      SUBROUTINE ATOM(P,ID)
C
C *** ATOM new by PJB Dec 91 ***
C
CC 17B
CH Writes postscript output to plot an atom in MAG3D
C
      DIMENSION P(2),Q(2)
      COMMON /GRAYS/IOLD
/IOUNIT/
      COMMON /PICDAT/CTHP,STHP,FHEAD,FRHEAD,FRTAIL,TRAN(9),
     &RA(20),HATCH(20)
/PICDEF/
C
      CALL GMSCA(P,Q,CMPERA,2,1)
      SRA=RA(ID)*CMPERA
      WRITE (IPLO,10) Q,SRA,HATCH(ID)
   10 FORMAT (4F8.2,' Atom')
      RETURN
      END
C
C
C
C
      SUBROUTINE ELIPSE(X,Y,R,EX,ANG,ANG1,ANG2)
C
C *** ELIPSE new by PJB Mar 92 ***
C
CH To draw an arc of an ellipse
CC 14C

CA X,Y are the coordinates of the centre.
CA R is the length of the major axis
CA EX is the ratio of the minor to the major axis
CA ANG is the angle by which the major axis is inclined to the x-axis
CA The arc is drawn from ANG1 to ANG2 measured counter clockwise from
CA the x-axis.
C
/CONSTA/
/PLTRAN/
C
C  FIRST WORK OUT A GOOD STEP LENGTH:
      CALL PLCONV(0.,R,NSPCE,X3,Y3,3)
      AL=SQRT(X3*X3+Y3*Y3)
      SC=.1/AL
C
C TRANSFORMATION
      T1=COS(ANG)
      T2=-SIN(ANG)
C STARTING POINT:
      ANGS=ANG1-ANG
      ANGF=ANG2-ANG
      IF (ANGF.LT.ANGS) ANGF=ANGF+TWOPI
      NSTEP=INT((ANGF-ANGS)/SC)+1
      SC=(ANGF-ANGS)/FLOAT(NSTEP)
      SN=SIN(ANGS)
      CS=COS(ANGS)
      RE=R*EX/SQRT(SN*SN+(EX*CS)**2)
      XR=RE*CS
      YR=RE*SN
      X0=X+T1*XR+T2*YR
      Y0=Y-T2*XR+T1*YR
      CALL KANGA1(X0,Y0,3)
      A=ANGS+SC
      DO 1 I=1,NSTEP
      SN=SIN(A)
      CS=COS(A)
      RE=R*EX/SQRT(SN*SN+(EX*CS)**2)
      XR=RE*CS
      YR=RE*SN
      X1=X+T1*XR+T2*YR
      Y1=Y-T2*XR+T1*YR
      CALL KANGA1(X1,Y1,2)
      A=A+SC
    1 CONTINUE
      X1=X1-X0
      RETURN
      END
C
C
C
C
      SUBROUTINE INVPRS(P,Q)
C
C *** INVPRS new by PJB March 1992 ***
C
CC 14C
CH Inverse perspective transformation
CD Given the x,y components of the 2D representation in P and the
CD x(out of plane) component of the 3D vector in Q, fills in the
CD other two components.
C
      DIMENSION P(2),Q(3)
      COMMON /PICDAT/CTHP,STHP,FHEAD,FRHEAD,FRTAIL,TRAN(9),
     &RA(20),HATCH(20)
C
      Q(2)=P(1)+Q(1)*CTHP
      Q(3)=P(2)+Q(1)*STHP
      RETURN
      END
C
C
C
C
      SUBROUTINE LABAXE(P1,P2,AL,S,ID)
C
C *** LABAXE revised by PJB Apr 92 ***
C
CC 14B
CH Labels the axes of a diagram
C
      DIMENSION P1(2),P2(2),S(4)
      CHARACTER*1 LAB(3)
      COMMON /GRAYS/IOLD
      COMMON /PICDAT/CTHP,STHP,FHEAD,FRHEAD,FRTAIL,TRAN(9),
     &RA(20),HATCH(20)
/PLODAT/
      DATA AHEAD,ARTAIL,ARHEAD/.333,0.025,.075/
      DATA LAB/'a','b','c'/
C
C  SUBSTITUTE AXIS ARROW IN COMMOM
      A1=FHEAD
      A2=FRHEAD
      A3=FRTAIL
      FHEAD=AHEAD
      FRHEAD=ARHEAD
      FRTAIL=ARTAIL
C AXIS ARROW
      X=P1(1)
      Y=P1(2)
      CALL AROW3D(X,Y,AL,S)
      CALL SPCSET(6)
      CALL PLCONV(P2(1),P2(2),4,Q1,Q2,6)
      Q1=Q1-0.25*CHUNIT
      Q2=Q2-0.25*CHUNIT
      CALL KANGA2(Q1,Q2,BL,LAB(ID),1)
      CALL SPCSET(4)
C RESTORE arrow proportions
      FHEAD=A1
      FRHEAD=A2
      FRTAIL=A3
      RETURN
      END
C
C
C
C
      SUBROUTINE LAXIS(P1,P2,S,ID)
C
C *** LAXIS new by PJB Apr 92 ***
C
CC 14C
CH Puts arrows and labels to identify the axes of a postscript picture
C
      DIMENSION P1(2),P2(2),Q(2),S(4)
      CHARACTER*1 LAB(3)
      COMMON /GRAYS/IOLD
/IOUNIT/
      COMMON /PICDAT/CTHP,STHP,FHEAD,FRHEAD,FRTAIL,TRAN(9),
     &RA(20),HATCH(20)
/PICDEF/
      DATA AHEAD,ARTAIL,ARHEAD/.333,0.025,.075/
      DATA LAB/'a','b','c'/
C
      CALL GMSCA(P1,Q,CMPERA,2,1)
C AXIS ARROW
      WRITE (IPLO,13) AHEAD,ARTAIL,ARHEAD,FRLINE
      WRITE (IPLO,10)
   10 FORMAT ('0 .1 .0 Graydef')
      IOLD=0
      SAL=CMPERA
      RAD=ARTAIL*SAL/2.
      IF (S(3).GT.0) THEN
        WRITE (IPLO,11) Q,SAL,RAD,DEGREE(S(1)),ABS(S(3)),S(4)
   11   FORMAT (4F8.2,F8.1,2F8.4,' Arrowout')
      ELSE
        WRITE (IPLO,12) Q,SAL,RAD,DEGREE(S(1)),ABS(S(3)),S(4)
   12   FORMAT (4F8.2,F8.1,2F8.4,' Arrowin')
      ENDIF
      CALL GMSCA(P2,Q,CMPERA,2,1)
      WRITE (IPLO,14) LAB(ID),Q
   14 FORMAT ('(',A1,')',2F6.1,' Axis')
C RESTORE arrow proportions
      WRITE (IPLO,13) FHEAD,FRTAIL/2,FRHEAD/2,FRLINE
   13 FORMAT (4F8.4,' Arrowdef')
      RETURN
      END
C
C
C
C
      SUBROUTINE LINE(P1,P2)
C
C *** LINE new by PJB Dec 91 ***
C
CC 14C
CH Writes postscript output to plot a line in MAG3D
C
      DIMENSION P1(2),P2(2),Q1(2),Q2(2)
/IOUNIT/
      COMMON /PICDAT/CTHP,STHP,FHEAD,FRHEAD,FRTAIL,TRAN(9),
     &RA(20),HATCH(20)
/PICDEF/
C
      CALL GMSCA(P1,Q1,CMPERA,2,1)
      CALL GMSCA(P2,Q2,CMPERA,2,1)
      WRITE (IPLO,10) Q1,Q2
   10 FORMAT (2F8.2,' moveto .05 setlinewidth ',2F8.2,' lineto stroke')
      RETURN
      END
C
C
C
C
      SUBROUTINE MAG3DX
C
C *** MAG3DX new by PJB Mar 92 ***
C
CC 17A
CH To read the "X" cards for MAG3D
C
      DIMENSION A(6)
      LOGICAL DONE(20)
      CHARACTER*4 NAME
/ATNAM/
/IOUNIT/
      COMMON /PICDAT/CTHP,STHP,FHEAD,FRHEAD,FRTAIL,TRAN(9),
     &RA(20),HATCH(20)
/PICDEF/
/POSNS/
/SCRACH/
C
      CALL ERRCHK(1,NATOM,20,0,'Too many atoms for MAG3D')
      DO 6 I=1,20
    6 DONE(I)=.FALSE.
      CALL FINDCD('X','PERS',4,0,LCD)
      IF (LCD.LE.0) GO TO 1
      CALL RDNUMS(A,7,6,NUM,IER)
      IF (IER.NE.0 .OR. NUM.LT. 3) GO TO 1
      CTHP=A(1)*A(2)
      STHP=A(1)*A(3)
      CALL FINDCD('X','CM/A',4,0,LCD)
      IF (LCD.LE.0) THEN
        CMPERA=1
      ELSE
        CALL RDREAL(CMPERA,7,IPT,50,IER)
        IF (IER.NE.0) GO TO 1
      ENDIF
      CALL FINDCD('X','ARRO',4,0,LCD)
      IF (LCD.LE.0) GO TO 1
      CALL RDNUMS(A,7,6,NUM,IER)
      IF (IER.NE.0 .OR. NUM.LT. 5) GO TO 1
      FHEAD=A(1)
      FRHEAD=A(2)
      FRTAIL=A(3)
      FRLINE=A(4)
      APERMB=A(5)
      CALL FINDCD('X','TRAN',4,0,LCD)
      IF (LCD.LE.0) GO TO 1
      CALL RDNUMS(TRAN,7,9,NUM,IER)
      IF (IER.NE.0 .OR. NUM.NE. 9) GO TO 1
      K=0
    3 CALL FINDCD('X','SYMB',4,K,LCD)
      IF (LCD.LE. 0) GO TO 4
      K=LCD
      CALL RDWORD(NAME,LEN,7,IPT,20,0,IER)
      IF (IER.NE.0) GO TO 1
      NA=IATOM(NAME)
      IF (NA .EQ.0) CALL ERRMES(1,1,
     & NAME//' not found in list of atom names')
      CALL RDNUMS(A,IPT,6,NUM,IER)
      IF (IER.NE.0 .OR. NUM.LT.2) GO TO 1
      RA(NA)=A(1)
      HATCH(NA)=A(2)
      DONE(NA)=.TRUE.
      GO TO 3
    4 DO 5 NA=1,NATOM
      IF (.NOT.DONE(NA)) CALL ERRMES(1,1,'No symbol information for '
     &//ATNAME(NA))
    5 CONTINUE
      CALL ERRMES(0,0,'for MAG3D')
      RETURN
    1 WRITE (ITO,11) ICARD
   11 FORMAT (' Error reading geometry definitions, data read:'/1X,A80)
      STOP
      END
C
C
C
C
      FUNCTION MINZ(IQ,IP)
C
C *** MINZ new by PJB Mar 92 ***
C
CC 17B
CH Determines what next to plot in MAG3D
C
CA IQ and IP mark the current positions in the arrays of atoms,lines and
CA labels. IQ directly and IP with respect to the sorted arrays.
CA IQ is given on entry and Ip is set in the subprogram.
CN The function returns 1,2,or 3 to indicate that an atom, a line or an
CN axis label should be plotted next. The return value 4 indicates the end.
C
      DIMENSION IQ(3),IP(3)
      COMMON/ARRAYS/ ARRAT(2,300),ARRAZ(300),IARRAT(300),INDA(300),
     &ALINE(2,100),BLINE(2,100),ALINEZ(100),BLINEZ(100),INDL(100),
     &ALEN(300),PHIP(300),ARRS(4,300),NAMAR(300),
     &ALABL(2,3),ALABZ(3),LAB(3),PHIL(4,3),BLABL(2,3)
C
      IF (IQ(2).NE.0) THEN
        IP(2)=INDL(IQ(2))
        MINI=2
      ELSE
        MINI=1
      ENDIF
      IF (IQ(1).NE.0) THEN
        IP(1)=INDA(IQ(1))
      ELSE
        IF (MINI.EQ.1) MINI=3
      ENDIF
      IF (IQ(3).NE.0) THEN
        IP(3)=LAB(IQ(3))
      ELSE
        IF (MINI.EQ.3) THEN
          MINZ=4
          RETURN
        ENDIF
      ENDIF
      IF (MINI.EQ.2) THEN
        IF (IQ(1).NE.0 .AND.ARRAZ(IP(1)).LT.ALINEZ(IP(2))) THEN
          MINI=1
          IF (IQ(3).NE.0 .AND.ALABZ(IP(3)).LT.ARRAZ(IP(1))) MINI=3
        ELSE
          IF (IQ(3).NE.0 .AND. ALABZ(IP(3)).LT.ALINEZ(IP(2))) MINI=3
        ENDIF
      ELSE IF (MINI.EQ.1) THEN
        IF (IQ(3).NE.0 .AND. ALABZ(IP(3)).LT.ALINEZ(IP(2))) MINI=3
      ENDIF
      MINZ=MINI
      RETURN
      END
C
C
C
C
      LOGICAL FUNCTION OVERLA(II,JJ,RAD,P)
C
C *** OVERLA new by PJB Mar 92 ***
C
CC 17C
CH Determines whether a line goes through an atom
CA II labels the atom in the arrays ARRAT, ARRAZ etc.
CA JJ labesl a line in the arrays ALINE, BLINE etc.
CA RAD is the radius of the atom.
CA If OVERLA is TRUE ie line and atom intersect P is returned containing
CA the perspective coordinates of the intersection point nearest to the
CA viewer
C
      DIMENSION P(3),C(3),AL(3),BL(3),U(3),V(3),W(3)
      COMMON/ARRAYS/ ARRAT(2,300),ARRAZ(300),IARRAT(300),INDA(300),
     &ALINE(2,100),BLINE(2,100),ALINEZ(100),BLINEZ(100),INDL(100),
     &ALEN(300),PHIP(300),ARRS(4,300),NAMAR(300),
     &ALABL(2,3),ALABZ(3),LAB(3),PHIL(4,3),BLABL(2,3)
C
C  CONVERT ATOM  CENTRE AND BOTH ENDS OF LINE BACK TO 3D
      C(1)=ARRAZ(II)
      CALL INVPRS(ARRAT(1,II),C)
      AL(1)=ALINEZ(JJ)
      CALL INVPRS(ALINE(1,JJ),AL)
      BL(1)=BLINEZ(JJ)
      CALL INVPRS(BLINE(1,JJ),BL)
C GET VECTOR V BETWEEN CENTRE AND START OF LINE
      CALL GMSUB(AL,C,V,3,1)
C AND VECTOR U REPRESENTING THE LINE
      CALL GMSUB(BL,AL,U,3,1)
C MAKE IT A UNIT VECTOR
      CALL UNIVEC(U,D)
      CALL VECPRD(U,V,W)
C D TO BE THE DISTANCE BETWEEN THE CENTRE AND THE LINE
      CALL UNIVEC(V,D)
      IF (D.GT.RAD) THEN
C THE LINE DOES NOT GO THROUGH THE ATOM
        OVERLA=.FALSE.
        RETURN
      ENDIF
      D=SQRT(RAD*RAD-D*D)
C D IS HALF LENGTH OF INTERSECTING CHORD
      FACT=SCALPR(V,U)+D
C FACT IS THE LENGTH TO FURTHER INTERSECTION
      CALL GMSCA(U,U,FACT,3,1)
C RESCALE U AND ADD START POINT TO GET U TO BE COORDINATES OF INTERSECTION
      CALL GMADD(U,AL,U,3,1)
C PROJECT BACK INTO 2D
      CALL PERSPC(U,P,0)
      OVERLA=.TRUE.
      RETURN
      END
C
C
C
C
      SUBROUTINE PERSPC(R,S,IS)
C
C *** PERSPC new by PJB Jan 91 ***
C
CC 14B
CH Perspective transformation
CA IS Indicates the space in which R is given
CA IS=0 Orthogonal and no transformation
CA IS=1 or 2 for real or reciprocal respectively, both with transformation
CP The common PICDAT must be set up to contain the perspective factors
CP and any required transformation
C
      DIMENSION R(3),S(3),OR(3),TR(3)
      COMMON /PICDAT/CTHP,STHP,FHEAD,FRHEAD,FRTAIL,TRAN(9),
     &RA(20),HATCH(20)
C
      IF (IS.LE.0) THEN
        CALL GMEQ(R,TR,3,1)
      ELSE
        CALL ORTHO(R,OR,IS)
        CALL GMPRD(TRAN,OR,TR,3,3,1)
      ENDIF
      S(1)=TR(2)-TR(1)*CTHP
      S(2)=TR(3)-TR(1)*STHP
      S(3)=TR(1)
      RETURN
      END
C
C
C
C
      SUBROUTINE POSORT(NARRAS,NLINES)
C
CC 17C
CH Sorts the arrows and atoms for postscript output of MAG3D
CA NARRAS is the number of atom/arrows to be plotted
CA NLINES is the number of lines to be plotted
C
      DIMENSION IP(3),IQ(3),TEMP(20),ITEMP(20),IT(20),P(3)
      LOGICAL OVERLA
      COMMON/ARRAYS/ ARRAT(2,300),ARRAZ(300),IARRAT(300),INDA(300),
     &ALINE(2,100),BLINE(2,100),ALINEZ(100),BLINEZ(100),INDL(100),
     &ALEN(300),PHIP(300),ARRS(4,300),NAMAR(300),
     &ALABL(2,3),ALABZ(3),LAB(3),PHIL(4,3),BLABL(2,3)
      COMMON /PICDAT/CTHP,STHP,FHEAD,FRHEAD,FRTAIL,TRAN(9),
     &RA(20),HATCH(20)
C
      CALL SORTX(ARRAZ,INDA,NARRAS)
      CALL SORTX(ALINEZ,INDL,NLINES)
      IQL=1
   60 JJ=0
      II=INDL(IQL)
      DO 61 I=IQL,NLINES
      IF (ALINEZ(INDL(I)).GT. ALINEZ(II)) GO TO 62
      JJ=JJ+1
      TEMP(JJ)=BLINEZ(INDL(I))
      ITEMP(JJ)=INDL(I)
   61 CONTINUE
   62 IT(1)=1
      IF (JJ.GT.1) CALL SORTX(TEMP,IT,JJ)
      DO 63 J=1,JJ
      IT(J)=INDL((IT(J)+IQL-1))
   63 CONTINUE
      CALL JGMEQ(IT,INDL(IQL),JJ,1)
      IQL=IQL+JJ
      IF (IQL.LE.NLINES) GO TO 60
C
      CALL SORTX(ALABZ,LAB,3)
      DO 1 I=1,3
    1 IQ(I)=1
C
    2 GO TO (21,22,23,100), MINZ(IQ,IP)
C    ,ARRAZ,INDA,ALINE,INDL,ALABZ,LAB)
   21 I=IARRAT(IP(1))
      IF (I.GT.0) THEN
        CALL ARROW(ARRAT(1,IP(1)),ALEN(I),ARRS(1,I),NAMAR(IP(1)))
      ELSE
        I=-I
        CALL ATOM(ARRAT(1,IP(1)),NAMAR(IP(1)))
      ENDIF
      IQ(1)=IQ(1)+1
      IF (IQ(1).GT.NARRAS) IQ(1)=0
      GO TO 2
C
   22 IQL=IQ(2)
      Z=ALINEZ(INDL(IQL))
  228 II=INDL(IQL)
      IF (ALINEZ(II).GT.Z) THEN
        IQ(2)=IQL
        GO TO 2
      ENDIF
      DO 223 I=IQ(1),NARRAS
      RAD=RA(NAMAR(INDA(I)))
      IF (ARRAZ(INDA(I)).GE.BLINEZ(II)-RAD) GO TO 226
      IF (OVERLA(INDA(I),II,RAD,P)) THEN
        CALL LINE(ALINE(1,II),P)
        CALL GMEQ(P,ALINE(1,II),2,1)
        ALINEZ(II)=P(3)
        DO 224 L=IQL+1,NLINES
        IF (ALINEZ(II).LT.ALINEZ(INDL(L))) GO TO 225
        IF (ALINEZ(II).EQ.ALINEZ(INDL(L))) THEN
          IF (BLINEZ(II).GT.BLINEZ(INDL(L))) GO TO 225
        ENDIF
        INDL(L-1)=INDL(L)
  224   CONTINUE
        L=NLINES+1
  225   INDL(L-1)=II
        GO TO 228
      ENDIF
  223 CONTINUE
C
  226 CALL LINE(ALINE(1,II),BLINE(1,II))
      IQL=IQL+1
      IF (IQL.LE.NLINES) GO TO 228
      IQ(2)=0
      GO TO 2
C
   23 CALL LAXIS(ALABL(1,IP(3)),BLABL(1,IP(3)),PHIL(1,IP(3)),IP(3))
      IQ(3)=IQ(3)+1
      IF (IQ(3).GT.3) IQ(3)=0
      GO TO 2
  100 RETURN
      END
C
C
C
C
      SUBROUTINE POSOUT(NARS,NLINES)
C
C *** POSOUT new by PJB Apr 92 ***
C
CC 17B
CH Drives the postscript output for MAG3D
CA NARRAS is the number of atom/arrows to be plotted
CA NLINES is the number of lines to be plotted
C
      CHARACTER *10 FILNOM
      CHARACTER *40 VFMT
/CARDRC/
/IOUNIT/
/NTITL/
      COMMON /PICDAT/CTHP,STHP,FHEAD,FRHEAD,FRTAIL,TRAN(9),
     &RA(20),HATCH(20)
/PICDEF/
/TITLE/
/SCRACH/
/WHEN/
      CHARACTER LINES(80)*1
      EQUIVALENCE (ICARD,LINES)
C
      DATA VFMT/'(''('',A40,'') Title afont setfont'')'/
      DATA A4X,A4Y,BORDER/21.0,29.7,1.0/
      DATA PTPCM /28.346/
C
      MESSAG=FILNOM(ICRYDA)
      I=INDEX(MESSAG,'.')
      IF (I.EQ.0) I=LENGT(MESSAG)+1
      MESSAG(I:)='.PS'
      CALL UPONE(MESSAG(I:),3)
      IPLO=NOPFIL(222)
C PUT OUT POSTSCRIPT HEADING
      WRITE (IPLO,1000) MAIN,FILNOM(IPLO),DATIM
 1000 FORMAT ('%!-Adobe-2.0 /%%Creator ',A6/
     & '%%Title: ',A10/'%%CreationDate: ',A24/
     &'%%DocumentFonts AvantGarde-Demi AvantGarde-Book'/
     &'%%Pages: 1'/'%%Bounding box attend'/'%%EndComments')
C COPY IN PROCEDURES:
      CALL PSPROC(IPLO)
      LUNI=NOPFIL(221)
C
C ARRANGE SPACE FOR ATOM LABELS
      CALL ATLABS(2)
      PY=PHGHT*CMPERA
      PX=PWIDTH*CMPERA
C rotate if necessary
      IF (PWIDTH.GT.PHGHT) THEN
        WRITE (IPLO,16) A4X
   16 FORMAT (F6.1,' 0 translate 90 rotate')
        PAPWID=A4Y
        PAPHGT=A4X
      ELSE
        PAPWID=A4X
        PAPHGT=A4Y
      ENDIF
      XSCALE=1.0
      PSCALE=1.0
      pxb=px+border
      pyb=py+border
      IF (PXB.GT.PAPWID) XSCALE=PAPWID/PXB
      IF (PYB.GT.PAPHGT) PSCALE=PAPHGT/PYB
      IF (XSCALE.LT.PSCALE) PSCALE=XSCALE
      IF (PSCALE.LT.1.) THEN
        PAPWID=PAPWID/PSCALE
        PAPHGT=PAPHGT/PSCALE
        WRITE(IPLO,110) PSCALE,PSCALE
  110   FORMAT (2f8.4,' scale')
        ASCALE=CMPERA*PSCALE
        WRITE (ITO,19) PX,PY,ASCALE
        WRITE (LPT,19) PX,PY,ASCALE
   19   FORMAT (' Picture size',F6.1,' by',F6.1,
     &  ' is too big for A4 paper.'/' Scale changed to ',f6.2,' cm/A')
      ENDIF
C  CENTRE PICTURE
      PDX=(PAPWID-PXB)/2
      PDY=(PAPHGT-PYB)/2
C
      WRITE (IPLO,17) PX,PY,PDX,PDY
   17 FORMAT ('/pwid',F6.1,' def /phgt',F6.1,' def'/2F6.1,' translate')
C
      WRITE (VFMT(7:8),13) NTITLE
   13 FORMAT (I2)
      WRITE(IPLO,VFMT)ITITLE(1:NTITLE)
C
C  MOVE TO PICTURE ORIGIN
      WRITE (IPLO,18) X0*CMPERA,Y0*CMPERA
   18 FORMAT (2F6.1,' translate')
C
C set arrow proportions
      WRITE (IPLO,12) FHEAD,FRTAIL/2,FRHEAD/2,FRLINE
   12 FORMAT (4F8.4,' Arrowdef')
C
C  DRAW CELLS ATOMS AND ARROWS
      CALL POSORT(NARS,NLINES)
C WRITE ATOM LABELS
      CALL ATLABS(3)
C calculate bounding box
      ptscal=pscale*ptpcm*cmpera
      ixmin=ifix(pdx*ptscal)
      iymin=ifix(pdy*ptscal)
      ixmax = iymin+ifix(pxb*ptscal) +2
      iymax=ixmin+ifix(pyb*ptscal) +2
      WRITE (IPLO,14)ixmin,iymin,ixmax,iymax
   14 FORMAT (' showpage'/'%%Trailer'/'%%BoundingBox ',4i6)
      RETURN
      END
C
C
C
C
      SUBROUTINE PSPOUT(LUNO,CHARS,N)
C
CC 17B
CH Formats and prints CHARS on LUNO in lines only breaking at spaces
      CHARACTER *(*) CHARS
      DATA LINE/80/
C *** Corrected July 2005 C138 by PJB ***
      I =1
    1 J = I+LINE
C139 Out when at end of buffer (J > N)
      IF (J.GT.N) THEN
        JJ=N+1
      ELSE
        DO 2 JJ=J,I,-1
        IF (CHARS(JJ:JJ) .EQ.' ') GO TO 3
    2   CONTINUE
      ENDIF
    3 WRITE (LUNO,10) (CHARS(II:II),II=I,JJ-1)
   10 FORMAT (80A1)
      I = JJ+1
      IF (I.LE.N) GO TO 1
      RETURN
      END
C
C
C
C
      SUBROUTINE PSPROC(LUN)
C
CC 17B
CH Print postscript arrow procedures on unit LUN
      CHARACTER*3018 PSP,PROLOG *(264)
/IOUNIT/
      DATA PROLOG /'/bd {bind def} bind def /S {stroke}bd /RM {rmoveto}b
     &d /M {moveto}bd /CP {closepath}bd /NP {newpath}bd /R {rotate}bd /T
     & {translate}bd /RL {rlineto}bd /SF {setfont}bd /SC {scalefont}bd /
     &SL {setlinewidth}bd /SH {show}bd /GS {gsave}bd /GR {grestore}bd /S
     &G {setgray}bd '/
      DATA PSP/'/sqrt { /sqr exch def 1 10 {dup 2 copy mul sqr exch sub
     &exch div 2 div add } repeat } def /Axis { M dup stringwidth pop 2
     &div neg afsize 0.4 mul neg RM SH } def /Atlab { exch lfsize add ex
     &ch M SH } def /Head { SG /hgt exch def /base exch def 2 copy NP M
     &base neg hgt neg RL base 2 mul 0 RL CP fill 0 SG 2 copy M base neg
     & hgt neg RL M base hgt neg RL S } def /Ellipse { NP GS SG exch dup
     & /aax exch def div 3 1 roll T 1 exch scale 0 0 aax 0 360 arc CP fi
     &ll 0 SG 0 0 aax 0 360 arc CP S GR } def /Stick { NP SG /len exch d
     &ef /wid exch def 2 copy M wid 0 RM 0 len RL wid 2 mul neg 0 RL 0 l
     &en neg RL CP fill 0 SG M wid 0 RM 0 len RL wid 2 mul neg 0 RM 0 le
     &n neg RL S } def /Arrowdef { /linwid exch def /headr exch def /tai
     &lr exch def dup /headf exch def 0.5 exch sub /tailft exch def } de
     &f /Graydef { /gray3 exch def /gray2 exch def /gray1 exch def } def
     & /Atom { NP GS SG /aax exch def T 0 0 aax 0 360 arc CP fill 0 SG l
     &inwid SL 0 0 aax 0 360 arc CP S GR } def /Arrowout { GS /sn exch d
     &ef /cs exch def 5 3 roll T neg R exch dup 3 1 roll div /ballr exch
     & def dup scale tailft cs mul /ttop exch def 0.5 cs mul /hfcs exch
     &def linwid SL 0 hfcs neg tailr dup sn mul gray1 Ellipse tailr ball
     &r lt { 1 tailr ballr div dup mul sub sqrt ballr mul cs mul /tailbi
     &t exch def 0 hfcs neg tailr hfcs gray1 Stick 0 0 ballr dup gray3 E
     &llipse 0 tailbit tailr dup sn mul gray1 Ellipse ttop ballr gt { 0
     &ttop tailr dup sn mul gray1 Ellipse 0 tailbit tailr ttop gray1 Sti
     &ck } if 0 tailbit tailr ttop tailbit sub gray1 Stick } { 0 hfcs ne
     &g tailr hfcs ttop add gray1 Stick } ifelse headf cs mul /headfs ex
     &ch def headr sn mul /headrs exch def 0 ttop headr headrs gray1 Ell
     &ipse 0 hfcs headfs headrs le { .05 0 360 arc CP fill } { 1 headrs
     &headfs div dup mul sub sqrt /frac exch def frac headr mul frac dup
     & mul headfs mul gray1 Head } ifelse GR } def /Arrowin { GS /sn exc
     &h def /cs exch def 5 3 roll T neg R exch dup 3 1 roll div /ballr e
     &xch def dup scale linwid SL 0 0.5 cs mul headf cs mul dup /headfs
     &exch def headr sn mul dup /headrs exch def le { pop pop } { 1 head
     &rs headfs div dup mul sub sqrt /frac exch def frac headr mul frac
     &dup mul headfs mul gray1 Head } ifelse 0 tailft cs mul headr headr
     &s gray2 Ellipse 0 tailft cs mul tailr dup sn mul gray1 Ellipse tai
     &lr ballr lt { 1 tailr ballr div dup mul sub sqrt ballr mul cs mul
     &/tailbit exch def 0 0 tailr tailft cs mul gray1 Stick 0 0 ballr du
     &p gray3 Ellipse 0 tailbit neg tailr dup sn mul gray1 Ellipse 0 0.5
     & cs mul neg tailr 0.5 tailbit sub cs mul gray1 Stick } { 0 0.5 cs
     &mul neg tailr tailft 0.5 add cs mul gray1 Stick } ifelse 0 0.5 neg
     & cs mul tailr dup sn mul gray2 Ellipse GR } def /Title { tfont SF
     &dup stringwidth pop dup pwid 1 sub ge {pwid exch div 30 cm div mul
     & /AvantGarde-Demi findfont exch SC SF pwid 1 sub} if neg pwid add
     &2 div phgt 2 sub M SH } def /cm 28.35 def /tfont /AvantGarde-Demi
     & findfont 30 cm div SC def /lfont /AvantGarde-Book findfont 24 cm
     & div dup /lfsize exch def SC def /afont /AvantGarde-Demi findfont
     &20 cm div dup /afsize exch def SC def cm cm scale afont SF'/
      DATA NCHR,MCHR/3018,264/
C
      WRITE (LUN,10)
      CALL PSPOUT(LUN,PROLOG,MCHR)
      WRITE (LUN,11)
      CALL PSPOUT(LUN,PSP,NCHR)
      WRITE (LUN,12)
   10 FORMAT ('%%Begin Prolog')
   11 FORMAT ('%Arrow procedures')
   12 FORMAT ('% End Arrow procedures'/'%%End Prolog'/'%% Page:1')
      RETURN
      END
C
C
C
C
C LEVEL 50      PROGRAM MAGLSQ
      PROGRAM MAGLSQ
C
C *** MAGLSQ updated for CPVEC C4.26 March 2013 ***
C
C ****************************************************************************
C
C                       M A G L S Q
C
C
C MAIN PROGRAM FOR STRUCTURE FACTOR LEAST SQUARES REFINEMENT, OF
C MIXED NUCLEAR AND MAGNETIC STRUCTURE FACTORS WITH EXTINCTION CORRECTIONS
C MAGNETIC SYMMETRY ALLOWED TO BE LESS THAN NUCLEAR SYMMETRY.
C
C ****************************************************************************
C
CC 6D
CH Least squares refinement from magnetic structure factor data
C
CD Main program for least squares refinement, of magnetic structure factor data
CD from (possibly) mixed nuclear and magnetic reflections
CD the magnetic symmetry is allowed to be less than the nuclear symmetry.
C
CI The crystal data file must contain all cards needed for magnetic
CI and nuclear structure factor calculations vis:
CI       S cards giving the symmetry.
CI       A C card with the cell dimensions.
CI       A cards defining the atoms, their positions and isotropic.
CI       temperature factors.
CI       F cards giving the  magnetic and non-magnetic scattering
CI       factors
CI       Q cards defining the magnetic structure
CI optionally:
CI       T cards giving anisotropic temperature factors
CI Additionally:
CI       L cards indicating which parameters should be refined
CI          (see the CCSL users' manual)
CI       I cards which may have the words words NCYC, CYCL1, PRIN,
CI           MCOR and CONV
CI           NCYC the number of least squares cycles (default 3)
CI           CYC1 the number to be assigned to the first cycle (default 1)
CI           PRIN frequency at which output lists are printed
CI               PRIN = 0 no printing
CI               PRIN = 1 first cycle
CI               PRIN = 2 last cycle
CI               PRIN = 3 first and last cycles
CI               PRIN = 4 every cycle
CI           MCOR controls the correlations printed at the end of the job
CI               (default +70)
CI               MCOR = 0 whole correlation matrix printed
CI               MCOR = -ve no printing
CI               MCOR = +ve correlations above MCOR printed
CI           CONV convergence criterion; LSQ cycling is terminated if the
CI               maximum shift/esd < CONV (default 0.01)
CI One or more data files which should be  lists of hkl and observations of the
CI type and in the format indicated by the values of REFI and MODE. For
CI single data sets MODE and REFI may be given on an L card, but with multiple
CI data sets they must be given interactively along with the file name. The
CI relative wieghts to be given to different data sets is also given there.
C
CO The usual listing file reporting the data which have been read. This file
CO also contains the output listings requested by the I PRIN card  as well as
CO the R-factors and chisqrd at the end of each least squares cycle.
CO A new crystal data file corresponding to the structure at the end of the
CO least squares refinement.
C
CR On running the program the user is asked for the name of the crystal data
CR file and the name of the file containing the structure factor data.
CR The value of \$\chi^2\$  at the end of each cycle is reported on the
CR terminal.
CR Just before the last cycle user is asked for a name for the new crystal
CR data file.
C
C
      CHARACTER *4 ISFWRD(3)
      LOGICAL DFLTMG,DOMAG2,CLAIMD
      EXTERNAL DFLTMG,LFCALC,LMCALC,LPVCAL,DOMAG2,PARRUN,VARSSF,DOMAG1
%      DIMENSION ALSQ(%MATS%)
      DIMENSION ISWDSP(3,3),LMODE(5)
/CARDRC/
/DERBAS/
/DGEOM/
/DSOURC/
/EXTN/
/FCAL/
/IOUNIT/
/MCAL/
/NEWOLD/
/OBSCAL/
/POLDA/
/POSNS/
/PRBLEM/
/REFINE/
/SCRACH/
/SYMMAG/
%      DATA NPSI/%PSIS%/
      DATA ISFWRD/
     & 'SCAL','DOMR','MOSC'/
      DATA ISWDSP/
     & 1,2,0, 1,1,8, 1,1,9/
C BLOCK DATA F2PARS NOW USED
C  THE ALLOWED OPTIONS FOR MODER IN MAGLSQ ARE JUST:
C   3.   H,K,L,OBS,STANDARD DEVIATION OF OBS, (SCALE GROUP),(CODE)
C   5.   H,K,L,OBS,STD DEVN,C1 C2 C3 C4, WHERE C1-C4 ARE THE
C        CONSTANTS INVOLVED IN EXTINCTION CORRECTIONS
C   7.   H,K,L (FLOATING) OBS,STD DEVN,(SCALE GROUP), (CODE)
C   8.   H,K,L(FLOATING),OBS,STD DEVN,C1 C2 C3 C4, WHERE C1-C4
C        ARE THE CONSTANTS INVOLVED IN THE EXTINCTION CORRECTION
C WHERE BOTH THE SCALE GROUP AND CODE ARE OPTIONAL.  IF THE SCALE GROUP IS
C READ AS ZERO, IT WILL BE SET = 1.
C   THE CODE IS NOT AT PRESENT USED; IT IS ENVISAGED THAT IT MAY BE USEFUL
C IN REJECTING SELECTED OBSERVATIONS LATER.
C MASK of ALLOWED MODER
      DATA NTRUE,LMODE/5,3,5,7,8,12/
C
C ALTER VALUE HERE IF NECESSARY, WITH DIMENSION OF ALSQ:
%      MATSZ=%MATS%
C
C SET UP STRUCTURE FACTOR CALCULATION:
      CALL PREFIN('MAGLSQ')
C
C SET "MAGNETIC"
      MAG=.TRUE.
C
      CALL SETFCM(DOMAG1)
C
C SPECIFY PROBLEM:
      NFAM=2
      NGENS(1)=2
      NGENS(2)=NATOM
      NSPC(1)=22
      IF (CPVEC) THEN
         NSPC(2)=24
C SPECIES TYPES FOR EACH GENUS OF FAMILY 1:
         LF1SP(1)=13
      ELSE
        LF1SP(1)=9
        NSPC(2)=18+NPSI
      ENDIF
C
C SPECIES TYPES FOR EACH GENUS OF FAMILY 1:
      LF1SP(1)=9
      LF1SP(2)=-20
C
C WORDS RELEVANT TO THIS PROBLEM FROM DATA INTO COMMON:
      CALL LSETSF(3,ISWDSP,ISFWRD)
C
C NAMES SET UP SO THAT:
C FAMILY 1 GENUS 1 HAS SPECIES TFAC, DOMR, MOSC (WITH PROVISION FOR
C A* ETC FOR GEOMETRIC CONSTRAINTS)
C   '    1    '  2 HAS GENUS NAME SCAL, SPECIES INDICATED TO BE 1,2,3 ETC
C
C FAMILY 2 IS AS USUAL THE PARAMETERS WHICH DEPEND ON THE ATOM.  GENUS NAMES
C ARE THEREFORE THE SAME AS ATOM NAMES, AND SPECIES NAMES ARE:
C X Y Z B11 B22 B33 B23 B13 B12 SCAT SITE ITF,
C THE MAGNETIC MOMENTS MU AND MU1 ORIENTATION PARAMETERS THET PHI THE1 PHI1
C AND POSSIBLE SUB-LATTICE PHASE ANGLES PSI1 PSI2 PSI3 FOR SPIRALS
      CALL CENTRE(LPT,3,'Least Squares Refinement',80)
      CALL CENTRE(LPT,0,'Magnetic and nuclear structure factor '//
     & 'program',80)
C
C READ I AND (MOST) L CARDS:
      CALL STLSSF
C READ E CARD:
      CALL EXTINC(1,0.)
C find out whether PATHs should be calculated
      PATHS =(IEXTYP.NE.0 .AND. ICDNO(7).NE.0)
      IF (PATHS) CALL SETABS
C
C  SET MONO-DOMAIN
      IF (IREF .EQ. 5)  MTYP=2
C  POLARISATION DIRECTION ETC read with data
C READ ALL THE DATA
      CALL DATASF(NTRUE,LMODE)
C
C SET UP PARAMETERS AS VARIABLES:
      CALL LOGMAG
      CALL PARSSF(DOMAG2)
      CALL DOMAG1(2)
      MUMODE=IOUT/512
      IF (MUMODE.GT. 0) CALL CPVMUS(MUMODE)
      CALL ERRMES(0,0,'to MAGLSQ(2)')
      CALL VARMAK(DFLTMG,PARRUN,VARSSF,DOMAG2)
C
      DONE=.FALSE.
      DO 1 ICYC=NCYC1,LASTCY
      IF (CPVEC) THEN
        CALL LSQCYC(ALSQ,MATSZ,LFCALC,LPVCAL)
      ELSE
        CALL LSQCYC(ALSQ,MATSZ,LFCALC,LMCALC)
      ENDIF
C  APPLY AND PRINT SHIFTS:
      CALL APSHSF(DOMAG2)
C ON PENULTIMATE CYCLE PRODUCE NEW CRYSTAL DATA FILE:
      IF (DONE) GO TO 39
      DONE=(AMAXSH.LT.CONV .OR. ICYC.EQ.LASTCY-1 .OR. NCYC.EQ.1)
      IF (DONE) CALL NWINSF(DOMAG2)
C RESET SPIN VECTORS IF ABOUT TO DO ANOTHER CYCLE
      IF (ICYC.NE.LASTCY) THEN
        CLAIMD = DOMAG2(0,5)
        IF (HELI) CALL VARMAK(DFLTMG,PARRUN,VARSSF,DOMAG2)
      ENDIF
   1  CONTINUE
C
C PRINT CORRELATION MATRIX:
  39  CALL MATCOR(ALSQ,MATSZ)
      IF (CPVEC) THEN
        CALL CPVESD
        CALL CPVMUS(MUMODE)
      ENDIF
      STOP
      END
C
C
C
C
C LEVEL 50      PROGRAM MAGPOW
      PROGRAM MAGPOW
C
C *** MAGPOW by PJB March 1994 ***
C
CC 17D
CH To generate indices of reflections in a magnetic powder diagram
C ****************************************************************************
C
C                             M A G P O W
C
C               TO GENERATE INDICES OF MAGNETIC REFLECTIONS
C
C ****************************************************************************
C
CD MAGPOW reads a crystal data file and, using a wavelength given
CD interactively, calculates the angles 2\$\theta\$, at which reflections will
CD occur. For each reflection the square of the structure factor, the
CD multiplicity, the factor relating \$F^2\$ to intensity, and the intensity
CD of the corresponding powder line are tabulated.
C
CI The crystal data file must contain:
CI        S card(s) giving the space group symmetry (note that a
CI        single card saying "S GRUP n" card should suffice n
CI        is the space group number)
CI        A C card with the cell dimensions
CI        A cards with the atomic positions
CI        F cards with the form factors or scattering lengths
CI        Q cards to define the magnetic structure
C
CO A listing file: magpow.lis which reports how the crystal data file
CO was interpreted and gives the results of the calculation. The results
CO columns and their headings are:
CO      h k l:     for the magnetic reflection indices
CO      H K L:     the indices of the fundamental from which
CO                   the reflection is derived, followed by + or - to indicate
CO                   whether the propagation vector was added or subtracted.
CO      2theta:    the scattering angle
CO      FNsqr:     the square of the nuclear structure factor
CO      FMsqr:     the square of the magnetic structure factor
CO      Intensity: The expected intensity of the powder line
CO
CO The format of the results file, if one is requested
CO is (5I5) It contains, for each reflection, the indices h, k, l of the
CO fundamental reflection from which it is derived, 1, -1 or 0 to
CO indicate whether the propagation vector is to be added, subtracted or not
CO used; the final number gives the multiplicity.
C
CR On running the program the user is asked for the name of the crystal data
CR data file, the wavelength, the maximum and optionally the
CR minimum 2\$\theta\$ for which results are required; also whether the
CR results should be written to a file and  so the name of the file.
C
C
      EXTERNAL DOMAG1
%      DIMENSION H(3,%NSFS%),IS(%NSFS%),MULT(%NSFS%),M(%NSFS%)
      DIMENSION VAL(5),K(3),HF(3),ISIG(3)
      COMPLEX FCALC,FC
      LOGICAL ENDREF,OUTPUT,LAYER,SAYS,MAGABS,LATABS
      CHARACTER*150 VFMT
      CHARACTER*1 SIG(3)
/BRAGG/
/IOUNIT/
/QCAL/
/SATELL/
/SCRACH/
      DATA VFMT/'(6X,''h'',7X,''k'',7X,''l'',5X,''  H   K   L      '',
     &''2Theta      FNsqr     FMsqr     Intensity''/)'/
      DATA SIG,ISIG/'+','-',' ',1,-1,0/
C
      LAYER=.FALSE.
      CALL PREFIN('MAGPOW')
C
      SMIN=0.
C
   30 CALL ASK('Wavelength and Maximum (& minimum if non-zero) 2Theta?')
      CALL RDNUMS(VAL,1,3,N,IER)
      IF (N .LT. 2 .OR. N .GT.3 .OR. IER .NE.0) GO TO 30
      ALAM=VAL(1)
      WRITE (LPT,2082) ALAM
 2082 FORMAT (' Wavelength ',F8.4)
      IF (N.EQ.2) THEN
        AMAX=VAL(2)
      ELSE
        AMIN=AMIN1(VAL(2),VAL(3))
        AMAX=AMAX1(VAL(2),VAL(3))
        SMIN=SIN(RADIAN(AMIN/2.))/ALAM
        WRITE (LPT,2081) AMIN
2081    FORMAT (' Minimum 2Theta =',F8.2)
      ENDIF
      SMAX=SIN(RADIAN(AMAX/2.))/ALAM
C
      WRITE (LPT,2080) AMAX
2080  FORMAT (' Maximum 2Theta=',F8.2)
      CALL ASK('Store indices on file? Y or N')
      OUTPUT=(SAYS('Y'))
C
C  SET UP CRYSTALLOGRAPHY
      CALL SETFCM(DOMAG1)
      CALL MAGCNC
      CALL DOMAG1(2)
      CALL SYMUNI
      CALL ERRMES(0,0,'for MAGPOW')
      CALL SETGEN(SMAX)
      CALL ERRMES(0,0,'for MAGPOW')
C
C  NOW GENERATE REFLECTIONS
      TEST=0.
      NUM=1
      MAGREF=2
      IF (IPROP.EQ.0) MAGREF=1
      NFLAG=-9999
      DO 2 IMAG=1,MAGREF
    1 IF (IMAG.EQ.1) THEN
        CALL GENMUL(H(1,NUM),ENDREF,MULT(NUM))
      ELSE
        CALL GENMAG(H(1,NUM),ENDREF,MULT(NUM),SMAX,NFLAG)
      ENDIF
      IF (ENDREF) GO TO 2
      S=VCTMOD(0.5,H(1,NUM),2)
      IF (S .GT. SMAX .OR. S .LT. SMIN) GO TO 1
      IS(NUM)=JFIX(S*(10**4))
      NUM=NUM+1
%      IF (NUM+NKSTAR.LE. %NSFS%) GO TO 1
      WRITE (ITO,3000) SMAX
%3000  FORMAT (' There are more than the allowed maximum of %NSFS%',
     & ' reflections'/' inside the SinTheta/lambda limit of',F7.3)
    2 CONTINUE
C
C  SORT ON SINTHETA/LAMDA
      NUM=NUM-1
      CALL SORTN(IS,M,NUM)
C
C  RESTORE FULL SYMMETRY
      IF (NKSTAR .GT. 1) CALL SYMBAK
C
C  HEADING
      CALL CENTRE(LPT,100,'***** Calculation of magnetic powder '//
     &'diagram  *****',90)
      LIN=3
      IF (OUTPUT) THEN
        LPT1=NOPFIL(2)
        LIN=LIN+1
        CALL MESS(LPT,0,
     & '                   Indices output to '//NAMFIL)
      ENDIF
C
C  AND PRINT OUT RESULTS
      CALL MESS(LPT,1,' ')
      WRITE (LPT,VFMT)
      DO 5 N=1,NUM
      J=M(N)
      DO 6 NN=N+1,NUM
      JJ=M(NN)
      IF (IS(JJ).GT.IS(J)) GO TO 7
      DO 8 I=1,3
      IF (ABS(H(I,J)-H(I,JJ)).GT..0001) GO TO 6
    8 CONTINUE
C MATCH FOUND SKIP
      GO TO 5
    6 CONTINUE
    7 S=FLOAT(IS(J))
      S=S/(10**4)
      STHL=S
      IF (MAGABS(H(1,J),ISS)) THEN
        CALL CGMZER(Q,1,3)
        FMCMOD=0.
        FMCSQR=0.
      ELSE
        CALL FMCALC(H(1,J),FMCMOD,FMCSQR)
        IF (ISS.GT.0) THEN
          CALL GMSUB(H(1,J),PROP,HF,3,1)
          ISAT=1
        ELSE IF (ISS.LT.0) THEN
          CALL GMADD(H(1,J),PROP,HF,3,1)
          ISAT=2
        ELSE
          ISAT=3
        ENDIF
      ENDIF
      FNSQR=0.
      IF (.NOT.LATABS(H(1,J))) THEN
        FC=FCALC(H(1,J))
        ISAT=3
        FNSQR = REAL(FC*CONJG(FC))
      ENDIF
      IF (ISAT.EQ.3) CALL GMEQ(H(1,J),HF,3,1)
      FSQR = FNSQR + FMCSQR
      CALL TESTP(LPT,LIN,1,VFMT,1)
      IN=MULT(J)
      STHET=S*ALAM
      THETA=ASIN(STHET)
      FAC=2.*STHET*STHET*COS(THETA)
      ANG=2.*DEGREE(THETA)
      AINT=FLOAT(IN)*FSQR/FAC
      CALL INDFIX(HF,K)
      WRITE (LPT,2007) (H(I,J),I=1,3),K,SIG(ISAT),ANG,FNSQR,FMCSQR,AINT
2007  FORMAT (1X,3F8.3,2X,3I4,1X,A1,2X,F8.2,2X,2F10.4,2X,F10.3)
      IF (OUTPUT) WRITE (LPT1,2008) K,ISIG(ISAT),IN
2008  FORMAT (5I5)
    5 CONTINUE
      STOP
      END
C
C
C
C
C LEVEL 50      PROGRAM MAXENT
      PROGRAM MAXENT
C
C **** MAXENT from MAGMAX (Papoular) updated by PJB April 2008
C
C *****************************************************************************
C
C                           M A X E N T
C Two or three dimensional maximum entropy reconstruction using the
C MEMSYS III library. Adapted for CCSL from R. Papoular's MAGMAX programs.
C
C *****************************************************************************
C
CH 2D or 3D MAXENT reconstruction using MEMSYS3 and CCSL
C
CC 5D
CD A program to calculate maximum entropy reconstructions from sets
CD of experimental Fourier coefficients covering either a 2D or a 3D space
CD and given with their estimated standard deviations. The program is based
CD on R. Papoular's MAGMAX programs and uses the MEMSYS III Library.
C
CI The crystal data file must contain:
CI      A C card with the cell dimensions
CI      S cards giving the symmetry
CI      M cards defining the axes for the reconstruction and the grid
CI        on which it will be calculated.
CI    M MAXE     Options for maximum entropy calculation
CI               MSTOP: stopping criterion,
CI               MODEL: type of default model, and if MODEL=0 or 2
CI               DEFVAL: the value for the constant density.
Ci   If the MAXE card is not given the program will get the
CI               options interactively.
CI    M GRID     Grid for Maximum entropy calculation, 6 (2D) or 9(3D) numbers,
CI               being: X(START) X(END) X(STEP), and the same in Y and (Z)
CI    M AXME     Axes of Maximum entropy calculation
CO The usual listing file reporting the data which have been read.
CO A file containing the reconstuction; this consists of a header o the form:
CO       CCSL  (MEMSYS III - 3D) Data from good.msf
CO         50  50  50
CO        0.000 1.000   1.000 0.000 0.000
CO        0.000 1.000   0.000 1.000 0.000
CO        0.000 1.000   0.000 0.000 1.000
CO       -0.839E-03   0.393E-02
CO The first line indicates the type of reconstruction and the data source
CO The second gives the number of points in the X,Y,and Z directions
CO (nx, ny, nz).
CO The next three lines give for each of these axes the start and end points
CO as fraction of the total axis length, followed by the zone axis symbols
CO defining the axis.
CO The final line of the header gives the maximum and minimum values which
CD occur in the reconstruction.
CO The nx*ny*nz values calculated follow in format (8E10.3).
C
CN The program must be linked with the MEMSYS III library memsys.f which
CN is not included with CCSL, and also requires the header files mecoms.inc,
CN mecomp.inc, mecomc.inc and mecoml.inc.
C
C
C**** REGULAR MEM COMMON's
C
      INCLUDE  'mecoms.inc'
      INCLUDE  'mecomp.inc'
      INCLUDE  'mecomc.inc'
      INCLUDE  'mecoml.inc'
C
C**** SPECIFIC COMMON's
C
      DIMENSION K(3)
      COMMON /HISTORY/ I,AIM,CHISQ,DEF,TEST
/IOUNIT/
/SCRACH/
/XENDA/
C
      CALL PREFIN('MAXENT')
      LO = LPT
      MESSAG='Structure factor data file'
      LUNI = nopfil(11)
C      LD=LUNI
C Initialisation For MEMSYS
      IOUDG   =   6
      MEMRUN =   0
      NRAND  =   1
      ISEED  =   5
      TOL    = 0.01
      SOLD   = 0.0
      BMSOLD= 0.0
C
C Initailse MEMSYS pointers etc
      CALL XENINI
C
C SET UP THE CRYSTALLOGRAPHY
      NPT=NPOINT
      CALL SETXEN(NPT)
      MJ=NPT
      NJ=1
C
C Read the reflection data and set multiplicities
      IF (NDIMEN.EQ.3) THEN
        CALL XENKRD
      ELSE
        CALL XENK2D(UU(1,3,1))
      ENDIF
      CALL ERRMES(0,0,'TO MAXENT')
C
C CREATE THE POINT SPREAD MATRIX
      CALL XENPSM
      CALL ERRMES(0,0,'TO MAXENT')
C
C CHECK OPUS / TROPUS CONSISTENCY.
       CALL MEMTRQ(4321,ERR)
       WRITE(ITO,400) ERR
       WRITE(LPT,400) ERR
       CALL MEMTRQ(1234,ERR)
       WRITE(ITO,400) ERR
       WRITE(LPT,400) ERR
  400 FORMAT(/,'  Fractional OPUS/TROPUS inconsistency  =',1PE12.4)
C
C COMPUTE THE RAW FOURIER TRANSFORM
      CALL RAWMAP
C
C CHOICE OF MEM OPTIONS
      CALL MEMOPT(METHOD,LEVEL,RATE)
C
C**** CYCLING MEM
C
      CALL UINIT
      I     = 0
      ISTAT = 1
C
    1 IF (ISTAT.NE.0) THEN
        WRITE(ITO,100) I
        WRITE(ITO,200) AIM*MK
        WRITE(ITO,300) LEVEL
  100 FORMAT(/,2X,'Iter ',I5,/,'  ----------')
  200 FORMAT(2X,'Aim    === ',F10.2)
  300 FORMAT(2X,'Ilevel === ',8X,I2)
C
        CALL  MEM3(METHOD , LEVEL , MEMRUN , NRAND , ISEED ,
     &   AIM    , RATE  , DEF    , ACC   , TOL   ,
     &   ALPHA  , BETA  , S      , TEST  , CHISQ ,
     &   SIGMA  , PROB  , GOOD   , OMEGA , ISTAT )
         MEMRUN = 1
C
C COMPUTE CURRENT DEFAULT,ENTROPY AND MASS.
        CALL CYCLE3(BMSOLD,SOLD)
        I = I + 1
        GO TO 1
      ENDIF
C
C AFTER LAST CYCLE WRITE OUT THE MEM MAP
      CALL OUTMAP(ST(KB(1)),MJ,'.mem')
C
C REPORT OBSERVED AND CALCULATED STRUCTURE FACTORS
      CALL OPUS(1,38)
C
       WRITE(LPT,1001)
 1001 FORMAT (//
     &'    h    k    l     FMobs    FMcalc     sigFM   O-C/sig')
      NHK=KB(34)
      DO 2 NUMHKL=1,MK
      FMCALC  = ST(KB(38)+NUMHKL-1)
      CALL INDFIX(ST(NHK),K)
      FMOBS   = ST(KB(21)+NUMHKL-1)
      SIGFOBS = 1.0/ST(KB(22)+NUMHKL-1)
      OBSCA  = (FMOBS-FMCALC)/SIGFOBS
      WRITE(LPT,1000) K,FMOBS,FMCALC,SIGFOBS,OBSCA
 1000 FORMAT(3I5,4F10.5)
      NHK=NHK+3
    2 CONTINUE
C
C**** FORMAT STATEMENTS.
C
C
C ERROR ESTIMATION  NOT YET IMPLEMENTED
      STOP
      END
C
C
C
C
      SUBROUTINE CYCLE3(BMSOLD,SOLD)
C#
      INCLUDE  'mecoms.inc'
      INCLUDE  'mecomp.inc'
C##
      COMMON /HISTORY/ I,AIM,CHISQ,DEF,TEST
/IOUNIT/
/XENDA/
C
      CALL UINIT
      LJ=MJ
C      WRITE(LPT,100) DEF
  100 FORMAT(2X,'Initial default === ',G13.6)
C
C COMPUTE CURRENT ENTROPY
      ENTROP = 0.
      AMASS  = 0.
      BMASS  = 0.
      DO 1 J=KB(1),KB(1)+MJ-1
      AMASS = AMASS +  ABS(ST(J))
      BMASS = BMASS +  ST(J )
    1 CONTINUE
      IF (AMASS .EQ. 0.) AMASS = 1.E-10
C
C===> DUE TO THE INCLUSION OF DELTA_S IN THE MEM INTEGRAND
C===> BMASS HAS TO BE MODIFIED TO CANCEL DELTA_S EFFECT !!!
      BMASS = BMASS*VOLEL
      DO 2 J=KB(1),KB(1)+MJ-1
      FRACT = ABS(ST(J)) /AMASS
      IF (FRACT.EQ. 0.) FRACT = 1.E-10
      ENTROP = ENTROP - FRACT*ALOG(FRACT)
    2 CONTINUE
C
      WRITE(ITO,200) BMASS  , BMSOLD
      WRITE(ITO,300) ENTROP , SOLD
  200 FORMAT(2X,'Current mass    === ',G13.6,' ... last      : ',G13.6)
  300 FORMAT(2X,'Current entropy === ',G13.6,' ... last sflf : ',G13.6)
      SOLD    = ENTROP
      BMSOLD = BMASS
C
C**** WRITES ON THE LISTING FILE
      IF (I .EQ. 0) THEN
        WRITE (LPT,'(//)')
        WRITE (LPT,400)
      ENDIF
      WRITE(LPT,402) I,AIM*MK,CHISQ,TEST,ENTROP,BMASS,DEF
C
  400 FORMAT(    '   I       Aim      C          Test       Entropy',
     &'    Tot. Mass    Setdef ')
  402 FORMAT(I4,1X,F10.2,5(2X,G10.3))
      RETURN
      END
C
C
C
C
      SUBROUTINE MEMOPT(METHOD,LEVEL,RATE)
C#
      INCLUDE  'mecoms.inc'
      INCLUDE  'mecomp.inc'
C#
      LOGICAL activ
      CHARACTER *10 FILNOM
      COMMON /HISTORY/ I,AIM,CHISQ,DEF,TEST
/IOUNIT/
/SCRACH/
/XENDA/

C**** MAXIMUM ENTROPY OPTIONS
      activ = MSTOP .ge. 0
       WRITE(LPT,1001)
 1001 FORMAT (/' Maximum entropy options:')
C

      if (activ) then
        IM0=MSTOP
        IM1 = MODEL
        go to 11
      endif
    1 WRITE(ITO,1000)
 1000 FORMAT(/' Stopping criterion : .............................'/
     &' M0 = 0           :Historic maximum entropy.........'/
     &' M0 = 1           :Classic maximum entropy..........'/
     &' M0 = 2           :Classic automatic, noise scaling.'/
     &' M0 = 3           :Ad hoc; alpha fixed..............')
      CALL ASK('Your choice')
      CALL RDINTG(IM0,1,IPT,10,IER)
      IF (IER.EQ.100) STOP
   11 IF (IM0 .LT.0 .OR. IM0.GT.3) THEN
        WRITE (ITO,1002) IM0
 1002 FORMAT ('Stopping option', I3,
     &' illegal, must be between 0 and 3')
        GO TO 1
      ENDIF
      WRITE (LPT,1000)
      WRITE (LPT,1004)IM0
 1004 FORMAT (10x,'Your choice:',I3)
C
      if (activ) go to 12
    3 WRITE (ITO,1003)
 1003 FORMAT (' Type of default model :..........................'/
     &' M1 = 0            :DEF = constant with positive entropy..'/
     &' M1 = 1            :User supplied in <20> (positive).'/
     &' M1 = 2            :DEF = constant with posi/nega entropy.'/
     &' M1 = 3            :User supplied in <20> (pos/neg)..')
      CALL ASK('Your choice')
      CALL RDINTG(IM1,1,IPT,10,IER)
      IF (IER.EQ.100) STOP
   12 IF (IM1 .LT.0 .OR. IM1.GT.3) THEN
      WRITE (ITO,1009) IM1
 1009 FORMAT ('Default model', I3,
     &' illegal, must be between 0 and 3')
        GO TO 3
      ENDIF
      WRITE (LPT,1003)
      WRITE (LPT,1004)IM1
C
C THESE OPTIONS ARE GIVEN DEFAULT VALUES, COULD BE CHOSEN DIFERENTLY
C IF EVER REQUIRED
      IM2 = 0
      IM3 = 0
C
      WRITE (LPT,1005)
 1005 FORMAT(/' Type of noise : ..................................'/
     &' M2 = 0           :1/sigma given in area <22>.......'/
     &' M2 = 1           :1/sigma = ACC = cte..............'/
     & ' M2 = 2           :Data are Poisson counts..........')
      WRITE(LPT,1004) IM2
C
      WRITE(LPT,1006)
 1006 FORMAT (/' Nonlinearity : ...................................'/
     &' M3 = 0           :Data are linear..................'/
     &' M3 = 1           :Data are nonlinear --> MEMEX.....')
      WRITE(LPT,1004) IM3
C
      METHOD = IM3*1000 + IM2*100 + IM1*10 + IM0
C
      IF (IM0 .NE. 3) THEN
        AIM = 1.0
      ELSE
        WRITE(*,*) '  Please input   AIM = value of alpha'
        WRITE(*,'(A,$)')  ' [smaller values fit data better]'
        READ(*,*) AIM
      ENDIF
C
      IF (IM1.EQ.0.OR.IM1.EQ.2) THEN  ! modele m=cte
        if (defval .ne.0) then
          def=defval
        else
        CALL ASK('Value for constant density : ')
          CALL RDREAL(DEF,1,IPT,12,IER)
          IF (IER.EQ.100) STOP
        endif
        write (lpt,1012) def
 1012 Format ('Value for constant density is',f8.4)
        DO 4 J=1,MJ
        ST(J + KB(20)- 1)  = DEF
    4   CONTINUE
      ELSE                           ! modele m donne dans un fichier
        MESSAG='File containing the model '
        LUN=NOPFIL(11)
        write (lpt,1011) filnom(lun)
 1011 Format ('Model density from',a10)
C
        DO 5 J=1,6
        READ(LUN,1007)
    5   CONTINUE
        READ(LUN,1007) (ST(I),I=KB(20),KB(20)+MJ-1)
 1007   FORMAT (8E10.3)
        CALL CLOFIL(LUN)
      ENDIF
C
C DEFAULT VALUES FOR OUTPUT DIAGNOSTICS, COULD BE CHANGED
            IL0 = 0
            IL1 = 1
      WRITE(LPT,1008)
 1008 FORMAT (/' Progress diagnostics :............................'/
     &' L0 = 0          :Switches these off ..............'/
     &' L0 = 1          :Names main routines as entered ..'/
     &' L0 = 2          :Additional flowcharting ........'/
     &' L0 = 3          :Additional call to UDIAG (debug)')
      WRITE(LPT,1004) IL0
C
      WRITE(LPT,1010)
 1010 FORMAT(' Numerical diagnostics :...........................'/
     & ' L1 = 0          :Switches these off ..............'/
     & ' L1 = 1          :Gives the major ones.............'/
     & ' L1 = 2          :Additional technical diagnostics')
      WRITE(LPT,1004) IL1
C
      LEVEL = IL1*10 + IL0
      RATE = 0.3
C
      RETURN
      END
C
C
C
C
      SUBROUTINE OPUS(J,K)
C#
      INCLUDE  'mecoms.inc'
      INCLUDE  'mecomp.inc'
C##
      COMMON /PSF/ R(NHKL,NPOINT)
C
C      write (55,1001)
 1001 format (/'OPUS')
      DO 1 KK=1,MK
    1 ST(KB(K)+KK-1)=0.
      DO 3 KK=1,MK
      DO 2 JJ=1,MJ
      ST(KB(K)+KK-1) = ST(KB(K)+KK-1) + R(KK,JJ)*ST(KB(J)+JJ-1)
 1000 format (i4,f10.4/)
 1002 format (2i4,3f10.4)
C      write (55,1002)  kk,jj,ST(KB(K)+KK-1),R(KK,JJ),ST(KB(J)+JJ-1)
    2 CONTINUE
C      write (55,1000)  kk,ST(KB(K)+KK-1)
    3 CONTINUE
C
      RETURN
      END
C
C
C
C
      SUBROUTINE OUTMAP(ST,MJ,EXT)
C
CH  WRITES OUT THE RESULT  FILE
C
      DIMENSION ST(MJ)
      CHARACTER *(*)EXT
      CHARACTER *2 dimen(3)
      CHARACTER *10 FILNOM,NOMFIL
C
/IOUNIT/
%       COMMON /LENGTH/ LJ(3),LK,ICTAB(%SYMO%)
/SCRACH/
/XENDA/
      DATA DIMEN/'  ','2D','3D'/
C
      NOMFIL=FILNOM(LUNI)
      I=INDEX(NOMFIL,'.')
      IF (I.EQ.0) THEN
        MESSAG=NOMFIL
      ELSE
        MESSAG=NOMFIL(1:I-1)
        ENDIF
      NAMFIL=EXT
      LMAP=NOPFIL(122)
C
      WRITE(LMAP,501),DIMEN(NDIMEN),FILNOM(LUNI)
  501 FORMAT ('CCSL  (MEMSYS III - ',A2,') Data from ',A10)
      WRITE(LMAP,500) LJ
  500 FORMAT (3I4)
      WRITE (LMAP,502) ((XLIM(I,J),J=1,2),(UU(J,I,1),J=1,3),I=1,NDIMEN)
  502 FORMAT (2F6.3,2X,3F6.3)
C
      XMIND=0.0
      XMAXD=0.0
C
      DO 2 J=1,MJ
      XMAXD= AMAX1(ST(J),XMAXD)
      XMIND=AMIN1(ST(J),XMIND)
    2 CONTINUE
      WRITE (LMAP,503) XMIND,XMAXD
  503 FORMAT(E10.3,2X,E10.3)
C
      WRITE(LMAP,600) (ST(J),J=1,MJ)
C      do 1 j=1,mj
C      if (st(j).gt.0.1 )  WRITE(lpt,601) J,ST(j)
C    1 continue
  600 FORMAT(8E10.3)
  601 format (i6,8f10.3)
C
      CALL CLOFIL (LMAP)
      RETURN
      END
C
C
C
C
      SUBROUTINE RAWMAP
C#
      INCLUDE  'mecoms.inc'
      INCLUDE  'mecomp.inc'

C
/CELPAR/
/IOUNIT/
/NSYM/
C
C**** RENORMALIZES THE DATA FILE WITH K-DEGENERACIES.

            K1 = KB(21)
            K2 = KB(37)
            K3 = KB(38)

        DO K=1,MK
               ST(K3+K-1) = ST(K1+K-1)/ST(K2+K-1)
           ENDDO

      CALL TROPUS(38,2)
C      write (56,1002) (st(j),j= kb(2),kb(2)+mj)
1002  format (5f10.4)

C
C**** NORMALIZATION FOR RAW INVERSE FOURIER TRANSFORM
C
      SCALE=FLOAT(MJ)/(V(1)*V(1))*FLOAT(NOP)
      write (ito,1004) Scale
 1004 format (' scale for raw map: ',f10.4)
       CALL GMSCA(ST(KB(2)),ST(KB(2)),SCALE,MJ,1)
C      SPINDENS = SPINDENS*FLTLJ/(VOLD*VOLD)*FLOAT(ICARE)
      CALL OUTMAP(ST(KB(2)),MJ,'.map')
      RETURN
      END
C
C
C
C
      logical function rdinf(lun,h,f,df,first)

CH Reads one data item for a given type of mapr, in a given format.
CA     MODED=0: user-supplied routine QFOUIN should set K, F, ALPHA, ENDIP
CA     MODED=1: read H,K,L FCAL,FOBS,(D)
CA     MODED=2: read H,K,L, mod(FCAL), phase angle, FOBS, (D)
CA     MODED=3: read H,K,L, A, B, FOBS, (D)
CA     MODED=4: read H,K,L, FOBS (or FCAL), (D)
CA On entry MODEF indicates the Fourier type required, from M FTYP card
CA     MODEF=1:   FCAL
CA     MODEF=2:   FOBS (Centrosymmetric)
CA     MODEF=3:   mod(FOBS)*phase(FCAL)
CA     MODEF=4:   FOBS-FCAL
CA     MODEF=5:   (mod(FOBS)-mod(FCAL))*phase(FCAL)
CA     MODEF=6:   FOBS*FOBS (Patterson)
CA On exit  K is a 1x3 integer vector holding h,k,l
CA          F is a 1x2 vector holding whichever of FOBS, etc were requested
CA          ALPHA, if relevant, holds the phase
CA          ENDIP is a logical set TRUE if the end of the input has occurred.
      dimension h(3),dat(7),numd(4)
      logical first
/IOUNIT/
/MAPDA/
/SCRACH/
      DATA NUMD/3,4,4,2/

      rdinf=.true.
   4  READ (lun,1000,END=101) ICARD
1000  FORMAT (A80)
      L=LENGT(ICARD)
      IF (L .EQ. 0) GO TO 4
      if (.not. first) go to 5
      first=.false.
      DO 3 I=L,1,-1
      M=LETTER(ICARD(I:I))
      IF (M .EQ. 5) GO TO 3
      IF (M .GT. 0) THEN
C ASSUME TITLE GIVEN:
       CALL INPUTN(-1)
       GO TO 4
      ENDIF
   3  CONTINUE
C
    5 nmax=3+NUMD(MODED)
      call rdnums(dat,1,nmax,num,ier)
      if (ier.ne. 0) then
        call errin2(ier,-1,' ','reading data file')
      else if
     &  (num.lt.nmax .and. .not.(moded .eq.4 .and. num.eq.nmax-1)) then
        call errin2(MODED,0,'Too few values in data for MODED','')
        go to 4
      endif
      CALL gmeq(dat,h,3,1)
C4.8 Check sinth/lambda inside limit
      STHL=VCTMOD(0.5,H,2)
      IF (STHL.GT.SMAX) then
        write (lpt,1001) h,sthl,smax
 1001   FORMAT(4x,1x,3f5.2,1x,'Sin(Theta)/lambda =',f6.3,
     &  ' outside limit',f6.3)
        go to 4
      endif
      if (moded .eq. 4 .and. num .eq.nmax-1) go to 15
      GO TO (11,12,13,14) , MODED
C
C H,K,L, FCAL,FOBS,(D)
  11  df=dat(6)
      go to (21,22,23,24,25,26) MODEF
C
C H,K,L, mod(FCAL), phase angle, FOBS, (D)
  12  go to 98
C
C H,K,L, A, B, FOBS, (D)
  13  go to 98
C
C H,K,L, FCAL (or FOBS, D)
   14 df=dat(5)
      dat(5)=dat(4)
      GO TO (99,22,99,99,99,26),MODEF
   15 dat(5)=dat(4)
      GO TO (21,99,99,99,99,99),MODEF
C
C FCAL
   21 f=dat(4)
      df=0.01*f
      go to 100
C
C FOBS (Centrosymmetric)
   22 f=dat(5)
      go to 100
C
C mod(FOBS)*phase(FCAL)
   23 f=sign(dat(5),dat(4))
      go to 100
C
C   FOBS-FCAL
   24 f=dat(5)-dat(4)
      go to 100
C
C (mod(FOBS)-mod(FCAL))*phase(FCAL)
   25 f=abs(dat(5))-abs(dat(4))
      f=sign(f,dat(4))
      go to 100
C
C  FOBS*FOBS (Patterson)
   26 f=dat(5)*dat(5)
      df=abs(2.*dat(5)*df)
      go to 100
C
C ERROR:
  98  CALL ERRIN2(MODED,0,'MODED','not allowed with MAXENT')
  99  CALL ERRMES(1,0,'MODEF & MODED values incompatible')
C
C  MARK END OF DATA
  101 rdinf=.FALSE.
 100  RETURN
      END
C
C
C
C
      SUBROUTINE SETXEN(NPT)
CH
CH Sets up the crystallography
C
C Ontry NPT is max number of image points allowed
C On exit it is set to the number required
C
      CHARACTER *1 AXE(3)
%      DIMENSION RU(3),NEEDM(%MCRD%)
/CELPAR/
/IOUNIT/
%       COMMON /LENGTH/ LJ(3),LK,ICTAB(%SYMO%)
/MAPDA/
/MREAD/
/NSYM/
/XENDA/
      DATA AXE/'x','y','z'/
C MASK FOR MCARDS NEEDED
C               NDIM FTYP MESH' AXES PRIN PLOT CM/A CONT SAVE READ DTYP
      DATA NEEDM/ 0,   0,  -1,   -1,  -1,  -1,  -1,  -1,  -1,  -1,   0,
     &-1,  -1,   -1,  0,   0,   0,  -1,  0/
C     DELT SCAL GET SMAX GRID AXME LABL MAXE
C
C
      CALL SYMOP
      CALL OPSYM(2)
      CALL RECIP
C Read and check M cards
      call setfou(needm)
      CALL SYMUNI
      CALL ERRMES(0,0,'to MAXENT')
      LK=1
      DO 5 I=1,NDIM
      if (xlim(i,3).lt.1.) then
        LJ(I)=NINT((XLIM(I,2)-XLIM(I,1))/XLIM(I,3))
      else
        LJ(i)=NINT(XLIM(i,3))
        XLIM(i,3)=(XLIM(i,2)-xlim(i,1))/xlim(i,3)
      endif
        LK=LJ(i)*LK
    5   CONTINUE
      WRITE (LPT,1000) ((XLIM(I,J),j=1,3),i=1,3)
1000  FORMAT (/' Grid for output of calculation is:  Initial     ',
     &'Final   Step'/
     & 3(36X,3F10.5/))
      IF (NDIMEN .EQ.3) THEN
C Compute volume element
        RVOL=DETER3(UU(1,1,1))
        FVOL=XLIM(1,3)*XLIM(2,3)*XLIM(3,3)
        VOLEL = V(1)*RVOL*FVOL
      ELSE
C Compute area element
        CALL VECPRD(UU(1,1,1),UU(1,2,1),RU)
        RVOL= VCTMOD(1.,RU,2)
        FVOL=XLIM(1,3)*XLIM(2,3)
        VOLEL = RVOL*FVOL/V(2)
      ENDIf
C
C Compatible symmetry elements
      CALL JGMZER(ICTAB,NOPC,1)
      ICTAB(1)=1
      DO 1 IO=2,NOPC
      ICTAB(IO)=1
      IF (NDIMEN .EQ.3) GO TO 1
      CALL ROTSYM(UU(1,3,1),RU,IO,1)
      CALL EQVEC(UU(1,3,1),RU,1,M,0)
      IF (M .NE.1) THEN
        call gmrev(ru,ru,3,1)
        CALL EQVEC(UU(1,3,1),RU,1,M,0)
      endif
      IF (M .NE.1)ICTAB(IO)=0
    1 CONTINUE
      write (lpt,1001) (I,ICTAB(I),I=1,NOPC)
 1001 format (/' Table of compatible operators:'/2(12(I3,' =',I2)/))
C
      WRITE(LPT,5000) LK,(AXE(I),LJ(I),I=1,3)
C
 5000 FORMAT(/,'  Size of image:',5x,I6,
     &3(/10x,'resolution along ',A1,':',I3))
C
      CALL ERRCHK(1,LK,NPT,0,'Grid points: Limited by MEMSYS'
     &//'requirements in U-routines')
      NPT=LK
C
C       NJ   = 1
C
C**** BOUNDS OF IMAGE
       WRITE (LPT,6000) (AXE(I),(XLIM(I,J),J=1,2),I=1,3)
C
 6000 FORMAT(/,'  Bounds of image (in reduced units):',
     &3(/10x,'min-max along ',A1,':',2F10.3))
C
      RETURN
      END
C
C
C
C
      SUBROUTINE TROPUS(K,J)
C#
C#
      INCLUDE  'mecoms.inc'
      INCLUDE  'mecomp.inc'
C##
      COMMON /PSF/ R(NHKL,NPOINT)
C
C      write (55,1001)
 1001 format (/'TROPUS')
      DO 1 JJ=1,MJ
      ST(KB(J)+JJ-1)=0.
      DO 2 KK=1,MK
      ST(KB(J)+JJ-1) = ST(KB(J)+JJ-1) + ST(KB(K)+KK-1)*R(KK,JJ)
 1000 format (i4,3f10.4)
    2 CONTINUE
C      write (55,1000)  jj, ST(KB(J)+JJ-1), ST(KB(K)+KK-1),R(KK,JJ)
    1 CONTINUE
      RETURN
      END
C
C
C
C
C
      SUBROUTINE XENINI
CH Initialisation for MEMSYS pointers etc
C#
      INCLUDE  'mecoms.inc'
      INCLUDE  'mecomp.inc'
C##
C
C  INITIALIZE POINTERS
      DO I=1,40
         KA(I) = 0
      ENDDO
C
C Set addresses within ST
      KB(1) = 1                        ! FILE 1    : ... THE IMAGE
      KB(2) = KB(1) + NPOINT     ! FILE 2    : ... WORKING SPACE
      KB(3) = KB(2) + NPOINT     ! FILE 3-19 : ... UNUSED
      KB(4) = KB(3)
      KB(5) = KB(4)
      KB(6) = KB(5)
      KB(7) = KB(6)
      KB(8) = KB(7)
      KB(9) = KB(8)
      KB(10)= KB(9)
      KB(11)= KB(10)
      KB(12)= KB(11)
      KB(13)= KB(12)
      KB(14)= KB(13)
      KB(15)= KB(14)
      KB(16)= KB(15)
      KB(17)= KB(16)
      KB(18)= KB(17)
      KB(19)= KB(18)
      KB(20)= KB(19)             ! FILE 20   : ... Prior density
C
      KB(21)= KB(20)+ NPOINT     ! FILE 21   : ... DATA SET
      KB(22)= KB(21)+ NHKL       ! FILE 22   : ... 1/SIGMA
      KB(23)= KB(22)+ NHKL       ! FILE 23   : ... MULTIPLIERS W
      KB(24)= KB(23)+ NHKL       ! FILE 24   : ... NORMALISED RESIDUALS
      KB(25)= KB(24)+ NHKL       ! FILE 25-28: ... WORKING SPACE
      KB(26)= KB(25)+ NHKL
      KB(27)= KB(26)+ NHKL
      KB(28)= KB(27)+ NHKL
      KB(29)= KB(28)+ NHKL
      KB(30)= KB(29)
      KB(31)= KB(30)
      KB(32)= KB(31)
      KB(33)= KB(32)
      KB(34)= KB(33)
      KB(35)= KB(34)+ NHKL
      KB(36)= KB(35)+ NHKL       ! FILE 36   : ... DATA ABSCISSAE
C                                                   (CURRENT scale)
      KB(37)= KB(36)+ NHKL       ! FILE 37   : ... K0 DEGENERACY FACTORS
      KB(38)= KB(37)+ NHKL       ! FILE 38   : ... RENORMALIZED DATA FILE
C                                                   (with degeneracies)
      KB(39)= KB(38)+ NHKL       ! FILE 39   : ... DEFINITION OF BINS
      KB(40)= KB(39)
C
C****INITIALIZATION OF THE MEM PACKAGE
C
      CALL MEINIT
      RETURN
      END
C
C
C
C
      SUBROUTINE XENK2D(UVW)
CH Reads the reflection data and determines multiplicities fpr 2D calculation
C#
      INCLUDE  'mecoms.inc'
      INCLUDE  'mecomp.inc'
C##
C
      LOGICAL FIRST,RDINF
      DIMENSION UVW(3),A(3),H(3),RH(3),TH(3,24)
/CONSTA/
/IOUNIT/
/NSYM/
/SCRACH/
/SYMDA/
C
      LK=0
      LHK=KB(34)
      NK=1
C COMPUTES MULTIPLICITY FOR ALL (H,K,L)
      WRITE(LPT,1000)
 1000 FORMAT (' Reflections included :'/
     &' Num    H    K    L    Op1  Op2    H    K    L    ',
     &'Phase     Fobs    sigma(fObs)  Degene.'/10x,'as read',
     &20x,'as used')
C
      first=.true.
    3 if (.NOT. rdinf(luni,a,f,df,first)) go to 100
      call asunit(a,h,iop,mul)
      is=0
      do 2 ic=1,2
      do 1 io=1,NOPC
      call rotsym(h,rh,io,2)
      test=scalpr(rh,uvw)
      if (abs(test).gt..001) go to 1
      if (is.eq.0) then
        MM=1
        call gmeq(rh,th,3,1)
        jop=io
      else
        call eqvec(th,rh,is,MM,NOPC)
        if (MM.le.is) go to 1
      endif
      is=MM
    1 continue
      call gmrev(h,h,3,1)
    2 continue
      DEGENK=0.
      if (is.eq.0) go to 98
      if (lk.eq.0) then
        CALL GMEQ(th(1,1),ST(LHK),3,1)
        M=1
      else
C To ensure an asymmetric unit
        call eqvec(st(lhk),th(1,1),Lk,M,NHKL)
      endif
      if (M.le.LK) then
        WRITE (LPT,1001) (th(i,1),i=1,3),(A(I),I=1,3)
 1001 FORMAT ('Reflection',3F5.0,' obtained from',3f5.0,
     &' is already present at number',I4)
      else
        lk=M
        test=scalpr(a,trans(1,iop))+scalpr(a,trans(1,jop))
        phase=twopi*amod(test,1.)
        ST(KB(21)+LK-1) = F*cos(phase)
        ST(KB(22)+LK-1) = 1./DF
        DEGENK=FLOAT(NOP)/FLOAT(IS)
 1002   FORMAT(i4,1x,3f5.2,1x,2(i4,1x),1x,3f5.2,f8.3,1x,2f10.4,4x,F4.0)
        ST(KB(37)+LK-1) = DEGENK
      ENDIF
   99 WRITE(LPT,1002) LK,(A(i),i=1,3),iop,JOP,(th(i,1),i=1,3),
     &  phase,(a(i),i=4,5)
     &  ,DEGENK
   98 GO TO 3
C
  100 MK=LK
      RETURN
      END
C
C
C
C
      SUBROUTINE XENKRD
CH Reads the reflection data and determines multiplicities
C#
      INCLUDE  'mecoms.inc'
      INCLUDE  'mecomp.inc'
C##
C
      DIMENSION H(3),a(3)
      LOGICAL RDINF,first
/CONSTA/
/IOUNIT/
/NSYM/
/SCRACH/
/SYMDA/
C
      LK=0
      LHK=KB(34)
      NK=1
C COMPUTES MULTIPLICITY FOR ALL (H,K,L)
C
      WRITE(LPT,1000)
 1000 FORMAT (' Reflections included :'/
     &' Num    H    K    L    Nop    H    K    L    ',
     &'Phase     F       sigma(F)    Degene.'/10x,'as read',
     &13x,'in AS unit')
C
      first=.true.
  100 if (.NOT. rdinf(luni,a,f,df,first)) go to 200
C To ensure an asymmetric unit
      call asunit(a,h,iop,mul)
      if (lk.eq.0) then
        CALL GMEQ(H,ST(LHK),3,1)
        M=1
      else
        call eqvec(st(lhk),h,Lk,M,NHKL)
      endif
      if (M.le.LK) then
        WRITE (LPT,1001) h,a
 1001 FORMAT ('Reflection',3f5.0,' obtained from',3f5.0,
     &' is already present at number',I4)
      else
        lk=M
        phase=twopi*amod(scalpr(a,trans(1,iop)),1.)
        ST(KB(21)+LK-1) = f*cos(phase)
        ST(KB(22)+LK-1) = 1./df
        MUL=MULBOX(H)
        DEGENK=FLOAT(NOP)/FLOAT(MUL)
        WRITE(LPT,1002) LK,a,iop,H,phase,f,df
     &  ,DEGENK
 1002   FORMAT(i4,1x,3f5.2,1x,i4,1x,1x,3f5.2,f8.3,1x,2f10.4,4x,F4.0)
      ENDIF
      ST(KB(37)+LK-1) = DEGENK
      GO TO 100
C
  200 MK=LK
      RETURN
      END
C
C
C
C
      SUBROUTINE XENPSM
CH Creates the point spread MATRIX
CN The PSF vector R is here defined as a nhkl*npoint x 1 vector
CN So that it can subsequently be treated as a MKxMJ vector
C#
      INCLUDE  'mecoms.inc'
      INCLUDE  'mecomp.inc'
C##
C
      DIMENSION XP(3),XQ(3),XMIN(3),H(3),EH(3)
/CONSTA/
/IOUNIT/
%       COMMON /LENGTH/ LJ(3),LK,ICTAB(%SYMO%)
      COMMON /PSF/ R(NHKL,NPOINT)
/NSYM/
/SYMDA/
/XENDA/
C
      KK=KB(34)
C SCALE BY VOLUME ELEMENTS
      SCALE = VOLEL/FLOAT(NOP)
C This bit offsets the volume elements by half a cell
      CALL GMSCA(XLIM(1,3),XMIN,0.5,3,1)
      CALL GMADD(XMIN,XLIM(1,1),XMIN,3,1)
      CALL GMZER(R,MK,MJ)
      KJ=0
      DO 2 K=1,MK
      CALL GMEQ(ST(KK),H,3,1)
C
C Sum over compatible SYMMETRY EQUIVALENTS:
      DO 8 N = 1,NOPC
      if (ICTAB(n).eq.0) go to 8
      CALL ROTSYM(H,EH,N,2)
      TRA =SCALPR(EH,TRANS(1,N))
      J=1
      CALL GMEQ(XMIN,XP,3,1)
C PUT XP INTO OLD CELL AS XQ
   20 CALL GMPRD(XP,UU(1,1,2),XQ,1,3,3)
C Sum over SYMMETRY EQUIVALENTS:
      PHASE=TWOPI*(SCALPR(EH,XQ) + TRA)
C This is where we assume centrosymmetry
      R(K,J) = R(K,J) + 2*COS(PHASE)
C      write (lpt,1010) j, xp, xq
 1010 format (i8, 2(3f8.3,2x))
      J=J+1
      DO 21 II=1,3
      XP(II)=XP(II)+XLIM(II,3)
      IF (XP(II).LT.XLIM(II,2)) GO TO 20
      XP(II)=XMIN(II)
   21 CONTINUE
    8 CONTINUE
C SCALE BY VOLUME ELEMENTS
      DO 9 J=1,MJ
    9 R(K,J)=R(K,J)*SCALE
      KK=KK+3
C      write (lpt,1002) k,kj
C 1002 format (/i5,i5)
C      if (k.eq.1)  write (lpt,1001)
C     &(k,j,r(k,j),j=1,mj)
C 1001 format (2i4,f10.4)
      KJ=KJ+MJ
    2 CONTINUE
C
      RETURN
      END
C
C
C
C
C Three dummy routines needed by MEMSYS
C
      SUBROUTINE MEMEX(X,PHI,DPHI)
* Set   PHI  = response of nonlinear experiment as function of x
* Set   DPHI = differential responsivity
*
* This example has scaled and squared response on a background
*
      IMPLICIT REAL (A-H,O-Z)
*      PHI=100.+X*X/10.
*      DPHI=2.*X/10.
      END

      SUBROUTINE UGET(D,X,M)
*   Get a buffer of M reals from external address D to ST address X
*  ( Not called in standard "core" simulation )
      IMPLICIT REAL (A-H,O-Z)
      INTEGER D,X
      INCLUDE  'mecomp.inc'
      INCLUDE  'mecoms.inc'
*      COMMON /DISC/ DISC(2560)
*      DO 1 I=0,M-1
*        ST(X+I)=DISC(D+I)
*    1 CONTINUE
      END

      SUBROUTINE UPUT(D,X,M)
*   Put a buffer of M reals to external address D from ST address X
*  ( Not called in standard "core" simulation )
      IMPLICIT REAL (A-H,O-Z)
      INTEGER D,X
      INCLUDE  'mecomp.inc'
      INCLUDE  'mecoms.inc'
*      COMMON /DISC/ DISC(2560)
*      DO 1 I=0,M-1
*        DISC(D+I)=ST(X+I)
*    1 CONTINUE
      END
C
C LEVEL 50      PROGRAM MEANWT
      PROGRAM MEANWT
C
C *** MEANWT by PJB ***
C
C ****************************************************************************
C
C                             M E A N W T
C
C                     TO CALCULATE WEIGHTED MEANS
C
C ****************************************************************************
C
CC 9D
CH Interactive calculation of weighted means
C
CD The program calculates the weighted mean of sets of data typed at the
CD terminal
CI Data are read interactively from the terminal
CO A listing file which contains the input data and the results of all the
CO calculations
CR On running the program the user is asked successively to give x and dx
CR which are the value and esd of one of a set of observations whose mean is
CR required. If a RETURN rather than a value is typed the weighted mean of the
CR current set is calculated and printed on the terminal, followed by the
CR esd's calculated first from the deviations from the mean, and secondly
CR from the given esd's of the data.
CR A RETURN typed when there are no data in the set terminates the program.
C
CN If the esd's of the data are not known they can be given as 1 to give unit
CN weights.

C
      DIMENSION WORK(5),X(2)
/IOUNIT/
/SCRACH/
C
      CALL INITIL('MEANWT')
C
    3 CALL WTMEAN(X(1),X(2),0,WORK)
      CALL ASK('Give x and dx (return to get mean)')
    5 CALL RDNUMS(X,1,2,N,IER)
      IF (IER.NE.0 .OR. N .LT.2) GO TO 2
      WRITE (LPT,10) X
   10 FORMAT (' Data ',2F12.5)
      CALL WTMEAN(X(1),X(2),2,WORK)
      CALL ASK('                                 -')
      GO TO 5
C
    2 IF (WORK(4).EQ.0) STOP
      CALL WTMEAN(AMEAN,ESD,-1,WORK)
      E2=SQRT(1./WORK(3))
      IF (ABS(AMEAN).GT.999. .OR. E2.LT. 0.00001) THEN
        WRITE (LPT,14) AMEAN,ESD,E2
        WRITE (ITO,14) AMEAN,ESD,E2
   14 FORMAT ('      Mean and standard deviations   : ',3E12.5/)
      ELSE IF (E2.LT.0.001) THEN
        WRITE (LPT,13) AMEAN,ESD,E2
        WRITE (ITO,13) AMEAN,ESD,E2
   13 FORMAT ('      Mean and standard deviations   : ',3F12.6/)
      ELSE
        WRITE (LPT,12) AMEAN,ESD,E2
        WRITE (ITO,12) AMEAN,ESD,E2
   12 FORMAT ('      Mean and standard deviations   : ',3F12.4/)
      ENDIF
      GO TO 3
C
      END
C
C
C
C
C LEVEL 50      PROGRAM MG3DGL
      PROGRAM MG3DGL
C
C *** MG3DGL removed call to KSTARS C4.35 March 2017 ***
C
CC 17D
CH Prepares the data for an animated 3d display of a magnetic structure
CI The crystal data file must contain all the information that would
CI be required for magnetic structure factor calculations viz:
CI      Symmetry (S) cards
CI      Cell (C) card
CI      Atom (A) cards
CI      Form factor (F) cards
CI      Magnetic structure (Q) cards
CI in addition special "X" cards can be given to describe the graphical
CI output these are:
CI      X <Atom Name> SYMB <Data> indicating how to draw each type of
CI        atom.
CI        There may be only one SYMB card with a matching <Atom Name> for
CI        each A card.
CI        The <Data> are a real number, the radius of the atom in Angstrom
CI        units followed by the RGB components of the colour to be used to
CI        paint it (as floating point fractions).
CI        If the atom has a magnetic moment the name for the arrow colour
CI        must also be given.
CI
CI The radii and colours can also be set interactivly in the dsiplay program.
CO The usual listing file reporting what was read from the
CO crystal data file and how it was interpreted.
CO An ASCII format file which is to be passed to the OpenGL program
CO Mag3dGL which will display the structure.
C
CR The magnetic structure can then be displayed oon a MAC running OSX with
CR the Mag3dGL application.
C
      EXTERNAL DOMAG1
      DIMENSION POS(3,48),RX(3),TMP(3),PX(3),SV(3),
     &SW(3),R(3),PL(3),SVV(3,2),KPI(3),KP(3)
     &,KLIM(3,2),ST(3),PLAT(3),KSOP(24)
      LOGICAL DONE,NEWOP,FIRST
      CHARACTER * 10 FILNOM,CRYNAM
C
/ATNAM/
/CARDRC/
/CELPAR/
/CONSTA/
/IOUNIT/
/MAGDAT/
      COMMON /MGLDAT/APERMB,FHEAD,FRHEAD,FRTAIL,RA(50),RGBAT(3,50)
     &,RGBAR(3,20)
/POSNS/
/NSYM/
/SATELL/
/SCRACH/
/SYMDA/
/SYMMAG/
C
      CALL PREFIN('MG3DGL')
C SET UP CRYSTALLOGRAPHY
      CALL SETFCM(DOMAG1)
      CALL MAGCNC
      CALL DOMAG1(2)
      MODUL=(MTYP.EQ.3 .OR. MTYP.EQ.4)
      IHELIX=1
      IF (MTYP.EQ.3) IHELIX=2
C SET UP A TABLE GIVING ONE OPERATOR WHICH GENERATES EACH DOMAIN
      KSOP(1)=1
      I=2
      DO 1 J=2,NOPC
      IF (KSTAB(J).NE.I) GO TO 1
      KSOP(I)=J
      I=I+1
      IF (I.GT.NKC) GO TO 2
    1 CONTINUE
C
    2 CALL ERRMES(0,0,'to MG3DGL')
C
C OPEN OUTPUT FILE FOR OPENGL
      CRYNAM= FILNOM(ICRYDA)
      I = INDEX(CRYNAM,'.')
      MESSAG=CRYNAM(1:I)//'gl'
      LUNO=NOPFIL(222)
C
C  INITIAL DIALOGUE
    3 CALL ASK('Number of cells in x,y, and z directions')
      CALL RDNUMS(TMP,1,3,N,IER)
      IF (IER.NE.0) GO TO 3
C SET THE MESH LIMITS
      CALL JGMZER(KLIM(1,1),3,1)
      CALL INDFIX(TMP,KLIM(1,2))
C      WRITE (LUNO,1002) (KLIM(I,2),I=1,3)
C 1002 FORMAT (3I4)
C
C Write out orthogonal transformation
      CALL GMTRAN(ORTH(1,1,1),POS(1,1),3,3)
      WRITE (LUNO,1000) ((pos(I,J),I=1,3),J=1,3)
 1000 FORMAT (2(3F8.4/),3F8.4)
C  GENERATE THE ATOMIC POSITIONS
      DO 4 NA=1,NATOM
      MAGNO=MAGAT(NA)
      IF (MAGNO.NE.0) THEN
C  SET THE SPIN DIRECTION FOR THIS ATOM
        CALL SPHPOL(ANGM(1,MAGNO),ANGM(2,MAGNO),SPIND(1,1,1,MAGNO),3)
        IF (MTYP.EQ.3)
     &  CALL SPHPOL(ANGM(3,MAGNO),ANGM(4,MAGNO),SPIND(1,1,2,MAGNO),3)
      ENDIF
      CALL GMEQ(X(1,NA),POS(1,1),1,3)
      FIRST=.TRUE.
      M=1
C OFFSET TO PSI VALUES
      JOP=0
      DO 5 IC=1,3-2*NCENT,-2
      DO 6 N=1,NOPC
      CALL ROTSYM(X(1,NA),PX,N,1)
      IF (IC.LT.0) CALL GMREV(PX,PX,3,1)
      CALL GMADD(PX,TRANS(1,N),PX,3,1)
      NEWOP=.TRUE.
      DO 7 NL=1,NLAT
      CALL GMADD(PX,ALAT(1,NL),RX,3,1)
      CALL EQPOS(POS(1,1),RX,M,M1,48)
      IF (M1.GT. M .OR. FIRST) THEN
        M=M1
        FIRST=.FALSE.
        CALL GMSUB(RX,POS(1,M),PLAT,3,1)
        CALL GMSUB(ALAT(1,NL),PLAT,PLAT,3,1)
C GET PHASE OFFSET
        IF (MAGNO.NE.0 .AND. NEWOP) THEN
          PH0=0.
C        IF (MODUL .AND. ABS(MSTAB(N)).NE. 1) THEN
          IF (MODUL) THEN
            JP=IPTAB(N+JOP,MAGNO)
            PH0=PH0+RADIAN(PHIH(JP,MAGNO))
          ENDIF
        ENDIF
C
C  DRAW THE ARROWS AND ATOMS
C  WORK OVER UNIT CELLS
        CALL JGMEQ(KLIM(1,1),KP,3,1)
C SET THE BOUNDARY SWITCH
        J=1
        ISW=0
        DO 8 I=1,3
        IF (ABS(POS(I,M)).LT..0001) ISW=ISW+J
        J=2*J
    8   CONTINUE
    9   CALL INDFLO(PL,KP)
        CALL JGMEQ(KP,KPI,3,1)
        CALL GMADD(POS(1,M),PL,R,3,1)
        ITAG=0
C FOR MAGNETIC ATOMS
        IF (MAGNO.NE.0) THEN
          IF (NEWOP) THEN
            DO 10 I=1,IHELIX
            CALL GMPRD(OTRSYM(1,1,N),SPIND(1,1,I,MAGNO),SVV(1,I),3,3,1)
C  IF INVERSION IS INCLUDED
            IF (IC.EQ.-1) THEN
              CALL GMPRD(OTRSYM(1,1,NOPC+1),SVV(1,I),SW,3,3,1)
              CALL GMEQ(SW,SVV(1,I),3,1)
            ENDIF
   10       CONTINUE
            NEWOP=.FALSE.
          ENDIF
C Choose single or multi-q here
          NKQ=NKC
          NKQ=1
          DO 11 IK=1,NKQ
C PHASE FOR THIS PROPAGATION VECTOR
          CALL GMADD(PLAT,PL,PL,3,1)
          PHASE=PH0+TWOPI*SCALPR(AKSTAR(1,IK),PL)
C         PHASE=EXOPHS(PHASE)
          PHP=SMOD(1,MAGNO)*COS(PHASE)
          CALL GMSCA(SVV(1,1),SW,PHP,3,1)
          IF (IHELIX.EQ.2) THEN
            PHP=SMOD(2,MAGNO)*SIN(PHASE)
            CALL GMSCA(SVV(1,2),ST,PHP,3,1)
            CALL GMADD(ST,SW,SW,3,1)
          ENDIF
          IF (IK.EQ.1) THEN
            CALL GMEQ(SW,SV,3,1)
            WRITE (LPT,231) N,IC,NL,KP,IK,PH0,PHASE,plat,pl,r
          ELSE
C ROTATION FOR THIS PROPAGATION VECTOR
            CALL GMPRD(OTRSYM(1,1,KSOP(IK)),SW,ST,3,3,1)
C ADD THE CONTRIBUTIONS FOR MULTI-K STRUCTURES
            CALL GMADD(SV,ST,SV,3,1)
            WRITE (LPT,231) N,IC,NL,KP,IK,PH0,PHASE,ST
          ENDIF
  231     FORMAT(1X,3I3,2X,3I3,2X,I3,2F10.4,3(2X,3F8.3))
   11     CONTINUE
C          WRITE (LPT,230) N,IC,KP,PH0,PHASE,SV,R
C  230     FORMAT(1X,2I3,2X,3I3,2F10.4,2(2X,3F8.3))
          CALL UNIVEC(SV,AL)
          THETA= ACOS(SV(3))
          IF (1.-ABS(SV(3)) .GT. 10E-3) THEN
            SV(3)=0;
            CALL UNIVEC(SV,D)
          ELSE
            SV(1)=.7071
            SV(2)=.7071
          ENDIF
          IF (AL.GT..0005) THEN
            SIZE=AL
            ITAG=1
          ENDIF
        ENDIF
C PUT R INTO SCALED ORTHOGONAL COORDINATES
        CALL ORTHO(R,TMP,1)
        IF (ITAG .EQ .0) THEN
          WRITE (LUNO,1003) ATNAME(NA),ITAG, TMP
 1003     FORMAT (A4,I4,3F10.4,F8.4,F8.2,2F8.4)
        ELSE
          WRITE (LUNO,1003) ATNAME(NA),ITAG,TMP,SIZE,DEGREE(THETA),
     &     SV(1),SV(2)
        ENDIF
        CALL LATGEN(KPI,KP,KLIM,DONE,ISW,ISWO)
        IF (.NOT. DONE) GO TO 9
      ENDIF
    7 CONTINUE
    6 CONTINUE
      IF (FCENT(MAGNO)) JOP=NOPC
    5 CONTINUE
    4 CONTINUE
C
      STOP
      END
C
C
C
C
C LEVEL 50      PROGRAM MMPLSQ
      PROGRAM MMPLSQ
C
C *** MMPLSQ  restructured to use LSQCYC C4.19 March 2010 ***
C
C ****************************************************************************
C
C                       M M P L S Q
C
C
C MAIN PROGRAM FOR STRUCTURE FACTOR LEAST SQUARES REFINEMENT OF
C MAGNETIC STRUCTURE FACTORS WITH MULTIPOLE FORM FACTORS AND
C EXTINCTION CORRECTIONS
C MAGNETIC SYMMETRY ALLOWED TO BE LESS THAN NUCLEAR SYMMETRY.
C
C ****************************************************************************
C
CC 18D
CH Magnetic least squares with multipole description of form factors
C
CD Main program for least squares refinement, of magnetic structure factor data
CD with multopole description of magnetic form factors
CD from (possibly) mixed nuclear and magnetic reflections
CD the magnetic symmetry is allowed to be less than the nuclear symmetry.
C
CI The crystal data file must contain all cards needed for magnetic
CI and nuclear structure factor calculations vis:
CI       S cards giving the symmetry.
CI       A C card with the cell dimensions.
CI       A cards defining the atoms, their positions and isotropic.
CI       temperature factors.
CI       F cards giving the  magnetic and non-magnetic scattering
CI       factors
CI       J Cards describing the multipoles to be used
CI       Q cards defining the magnetic structure
CI       W ROTN cards giving the orientation of the multipole axes
CI       and possibly
CI       W RADF cards giving radial wave-funtions to be used to calculate
CI       the radial form factors
CI optionally:
CI       T cards giving anisotropic temperature factors
CI Additionally:
CI       L cards indicating which parameters should be refined
CI          (see the CCSL users' manual)
CI       I cards which may have the words words NCYC, CYCL1, PRIN,
CI           MCOR and CONV
CI           NCYC the number of least squares cycles (default 3)
CI           CYC1 the number to be assigned to the first cycle (default 1)
CI           PRIN frequency at which output lists are printed
CI               PRIN = 0 no printing
CI               PRIN = 1 first cycle
CI               PRIN = 2 last cycle
CI               PRIN = 3 first and last cycles
CI               PRIN = 4 every cycle
CI           MCOR controls the correlations printed at the end of the job
CI               (default +70)
CI               MCOR = 0 whole correlation matrix printed
CI               MCOR = -ve no printing
CI               MCOR = +ve correlations above MCOR printed
CI           CONV convergence criterion; LSQ cycling is terminated if the
CI               maximum shift/esd < CONV (default 0.01)
CI One or more data files which should be  lists of hkl and observations of the
CI type and in the format indicated by the values of REFI and MODE. For
CI single data sets MODE and REFI may be given on an L card, but with multiple
CI data sets they must be given interactively along with the file name. The
CI relative wieghts to be given to different data sets is also given there.
C
CO The usual listing file reporting the data which have been read. This file
CO also contains the output listings requested by the I PRIN card  as well as
CO the R-factors and chisqrd at the end of each least squares cycle.
CO A new crystal data file corresponding to the structure at the end of the
CO least squares refinement.
C
CR On running the program the user is asked for the name of the crystal data
CR file and the name of the file containing the structure factor data.
CR The value of \$\chi^2\$  at the end of each cycle is reported on the
CR terminal.
CR Just before the last cycle the user is asked for a name for the new crystal
CR data file
C.
      CHARACTER *4 ISFWRD(3)
      LOGICAL DFLTMP,DOTHER,CLAIMD
     &,DOMAG2
      EXTERNAL DFLTMP,MAGCNL,PARRUN,VARSSF,LFCALC,LMMPCA,DOTHER
%      DIMENSION ALSQ(%MATS%),ISWDSP(3,3)
      DIMENSION MODES(9)
/CARDRC/
/DERBAS/
/DSOURC/
/EXTN/
/FCAL/
/IOUNIT/
/NEWOLD/
/MAGDAT/
/MCAL/
/MPODA/
/OBSCAL/
/POLDA/
/POSNS/
/PRBLEM/
/REFINE/
/SFDATA/
/SCLDAT/
/SCRACH/
/SYMMAG/
%      DATA NPSI/%PSIS%/
      DATA ISFWRD/'SCAL','DOMR','MOSC'/
      DATA ISWDSP/1,2,0, 1,1,8, 1,1,9/
C141 BLOCK DATA F2PARS NOW USED
C MASK of ALLOWED MODER
C  THE ALLOWED OPTIONS FOR MODER IN MMPLSQ ARE JUST:
C   3.   H,K,L,OBS,STANDARD DEVIATION OF OBS, (SCALE GROUP),(CODE)
C   4.   H,K,L,GCAL,OBS,STANDARD DEVN. (O/P FROM MEANGM)
C   5.   H,K,L,OBS,STD DEVN,C1 C2 C3 C4, WHERE C1-C4 ARE THE
C        CONSTANTS INVOLVED IN EXTINCTION CORRECTIONS
C   7.   H,K,L (FLOATING) OBS,STD DEVN,(SCALE GROUP), (CODE)
C   8.   H,K,L(FLOATING),OBS,STD DEVN,C1 C2 C3 C4, WHERE C1-C4
C        ARE THE CONSTANTS INVOLVED IN THE EXTINCTION CORRECTION
      DATA NMODES,MODES/9,1,2,3,4,5,6,7,8,12/
C
C ALTER VALUE HERE IF NECESSARY, WITH DIMENSION OF ALSQ:
%      MATSZ=%MATS%
C
C SET UP STRUCTURE FACTOR CALCULATION:
      CALL PREFIN('MMPLSQ')
C
C SET 'MULTIPOLE' FOR RECOGNITION OF PARAMETERS:
      MPL=.TRUE.
C SET "MAGNETIC"
      MAG=.TRUE.
C
C  ONLY SOME OF SETFC HERE, REST AFTER DOMAG1
      CALL SYMOP
      CALL OPSYM(1)
      CALL RECIP
      CALL ATOPOS
      CALL SETANI
      CALL EXTINC(1,0.)
C find out whether PATHs should be calculated
      PATHS =(IEXTYP.NE.0 .AND. ICDNO(7).NE.0)
      IF (PATHS) CALL SETABS
C READ Q CARDS
      CALL DOMAG1(1)
C  SETFOR MUST BE AFTER DOMAG1 SO MAGNETIC FORM FACTOR NAMES ARE
C  RECOGNISED
C DOMAG1 must be before PFSET so that magnetic atoms and form factors are
C recognised
      CALL PFSET
C
C128 section imposing monopoles removed.
      CALL SETFOR
      CALL PFOUT
C
C SPECIFY PROBLEM:
      NFAM=5
      NGENS(1)=2
      NGENS(2)=NATOM
      NGENS(3)=0
      NGENS(4)=0
      NGENS(5)=1
      NSPC(1)=20
      NSPC(2)=18+NPSI
      NSPC(3)=0
      NSPC(4)=0
      NSPC(5)=NMPOL
C
C SPECIES TYPES FOR EACH GENUS OF FAMILY 1:
      LF1SP(1) =9
      LF1SP(2) =-20
C
C WORDS RELEVANT TO THIS PROBLEM FROM DATA INTO COMMON:
      CALL LSETSF(3,ISWDSP,ISFWRD)
C
C NAMES SET UP SO THAT:
C FAMILY 1 GENUS 1 HAS SPECIES TFAC, DOMR, MOSC (& ROOM FOR A* ETC)
C   '    1    '  2 HAS GENUS NAME SCAL, SPECIES INDICATED TO BE 1,2,3 ETC
C
C FAMILY 2 IS AS USUAL THE PARAMETERS WHICH DEPEND ON THE ATOM.  GENUS NAMES
C ARE THEREFORE THE SAME AS ATOM NAMES, AND SPECIES NAMES ARE:
C X Y Z B11 B22 B33 B23 B13 B12 SCAT SITE ITF,
C THE MAGNETIC MOMENT MU AND ORIENTATION ANG1, ANG2
C FAMILY 5 IS FOR THE MULTIPOLES
C
C
C READ I AND (MOST) L CARDS:
      CALL STLSSF
C
C READ ALL THE DATA
      CALL DATASF(NMODES,MODES)
C
C  GET POLARISATION DIRECTION ETC
      IF (IREF .EQ. 5) CALL SETPOL
C  SET MONO-DOMAIN
        IF (IREF.EQ.5) MTYP=2
C
C SET UP PARAMETERS AS VARIABLES:
      CALL LOGMAG
      CALL PARSSF(DOTHER)
      CLAIMD=DOMAG2(0,5)
      CALL DOMAG1(2)
      CALL ERRMES(0,0,'to MMPLSQ(2)')
      CALL VARMAK(DFLTMP,PARRUN,VARSSF,DOTHER)
C
      CALL ERRMES(0,0,'for magnetic multipoles')
C
C Least squares cycles
      DONE=.FALSE.
      DO 1 ICYC=NCYC1,LASTCY
      CALL LSQCYC(ALSQ,MATSZ,LFCALC,LMMPCA)
      CALL APSHSF(DOTHER)
C ON PENULTIMATE CYCLE PRODUCE NEW CRYSTAL DATA FILE:
      IF (DONE) GO TO 39
      DONE=(AMAXSH.LT.CONV .OR. ICYC.EQ.LASTCY-1 .OR. NCYC.EQ.1)
      IF (DONE) CALL NWINSF(DOTHER)
C RESET SPIN VECTORS IF ABOUT TO DO ANOTHER CYCLE
      IF (ICYC.NE.LASTCY) THEN
        CLAIMD = DOMAG2(0,5)
        IF (HELI) CALL VARMAK(DFLTMP,PARRUN,VARSSF,DOTHER)
      ENDIF
   1  CONTINUE
C
C PRINT CORRELATION MATRIX:
  39  CALL MATCOR(ALSQ,MATSZ)
      STOP
      END
C
C
C
C
C
      LOGICAL FUNCTION DOTHER(NN,MODE)
C
C *** DOTHER new by PJB June 2005 ***
C
CC 6A
CH Logical utility function to cope with new Least squares parameters
CD DOTHER is meant to simplify construction of new least squares programs
CD It just passes its arguments to other logical functions to
CD see whether they can deal with them
      LOGICAL DOMAG2,DOMPL2
C
/NEWOLD/
C
      DOTHER = DOMAG2(NN,MODE)
      IF (.NOT. DOTHER) DOTHER = DOMPL2(NN,MODE)
      RETURN
      END
C
C
C
C
C LEVEL 50      PROGRAM MPCLSQ
      PROGRAM MPCLSQ
C
C *** MPCLSQ  restructured to use LSQCYC C4.19 March 2010 ***
C
C ****************************************************************************
C
C                       M P C L S Q
C
C
C MAIN PROGRAM FOR LEAST SQUARES MAGNETIC STRUCTURE REFINEMENT,
C USING MULTIPOLE DESCRIPTION OF THE FORM FACTORS
C AND ANISOTROPIC SUSCEPTIBILITIES, ALLOWS EXTINCTION CORRECTIONS
C
C ****************************************************************************
C
CC 18D
CH Least squares multipole refinement from magnetic structure factor data
CH (paramagnetic version)
C
C
CD Main program for least squares refinement, of Flipping ratios with
CD Multipole description of form factors and anisotropic susceptibilities.
CD Extinction corrections can be included.
C
CI The crystal data file must contain all cards needed for structure factor
CI calculations vis:
CI       S cards giving the symmetry.
CI       A C card with the cell dimensions.
CI       A cards defining the atoms, their positions and isotropic.
CI       temperature factors.
CI       F cards giving the scattering factors
CI       J cards describing the multipoles to be used
CI       W ROTN cards giving the orientation of the multipole axes
CI       and possibly
CI       W RADF cards giving radial wave-funtions to be used to calculate
CI       the radial form factors
CI       Q cards defining the magnetic structure (Q STYP PARA) with, for each
CI         magnetic atom a
CI       Q <atomName> CHI card giving the starting values for the components of
CI         anisotropic suceptibility. If only one values is given the refinement
CI         will start from a isotropic susceptibility of that value
CI optionally:
CI       T cards giving anisotropic temperature factors
CI Additionally:
CI       L cards indicating which parameters should be refined
CI          (see the CCSL users' manual)
CI       I cards which may have the words words NCYC, CYCL1, PRIN,
CI       MCOR and CONV.
CI           NCYC the number of least squares cycles (default 3)
CI           CYC1 the number to be assigned to the first cycle (default 1)
CI           PRIN frequency at which output lists are printed
CI               PRIN = 0 no printing
CI               PRIN = 1 first cycle
CI               PRIN = 2 last cycle
CI               PRIN = 3 first and last cycles
CI               PRIN = 4 every cycle
CI           MCOR controls the correlations printed at tyhe end of the job
CI               (default +70)
CI               MCOR = 0 whole correlation matrix printed
CI               MCOR = -ve no printing
CI               MCOR = +ve correlations above MCOR printed
CI           CONV convergence criterion; LSQ cycling is terminated if the
CI               maximum shift/esd < CONV (default 0.01)
CI The data file should be a list of hkl and flipping ratios in the format
CI indicated by the L MODE and REFI cards (default extension .fr).
C
CO The usual listing file reporting the data which have been read. This file
CO also contains the output listings requested by the I PRIN card  as well as
CO the R-factors and chisqrd at the end of each least squares cycle.
CO A new crystal data file corresponding to the structure at the end of the
CO least squares refinement.
C
CR On running the program the user is asked for the name of the crystal data
CR file and the name of the file containing the structure factor data.
CR The value of \$\chi^2\$  at the end of each cycle is reported on the
CR terminal.
CR After the last cycle user is asked for a name for the new crystal data file.
C
      CHARACTER *4 ISFWRD(10)
      LOGICAL DFLTMC
      EXTERNAL DFLTMC,PARRUN,VARSSF,TCHMPC,LFCALC,DOTHER
%      DIMENSION ALSQ(%MATS%),ISWDSP(3,10)
      DIMENSION MODES(9)
/CARDRC/
/DERBAS/
/DGEOM/
/DSOURC/
/EXTN/
/FCAL/
/IOUNIT/
/MAGCHI/
/MCAL/
/NEWOLD/
/MPODA/
/NSYM/
/OBSCAL/
/POLFOR/
/POLDA/
/POSNS/
/PRBLEM/
/REFINE/
/RSTATS/
/SCLDAT/
/SCRACH/
/SFDATA/
      COMMON /SFHEDC/FRMATS(6),HEDWDS(6)
      CHARACTER * 50 FRMATS,HEDWDS*4
      COMMON /SFHEDP/NHEAD,LHEAD(7),HMASK(6)
      LOGICAL HMASK
      DATA ISFWRD/
     & 'SCAL','DOMR','MOSC',
     & 'CH11','CH22','CH33','CH23','CH31','CH12',
     & 'CHIJ'/
      DATA ISWDSP/
     & 1,2,0, 1,1,8, 1,1,9,
     & 2,0,13, 2,0,14, 2,0,15, 2,0,16, 2,0,17, 2,0,18,
     & -8,0,0/
C BLOCK DATA F2PARS USED FOR SF PARS
C  THE ALLOWED OPTIONS FOR MODER IN MPCLSQ ARE JUST:
C   3.   H,K,L,OBS,STANDARD DEVIATION OF OBS, (SCALE GROUP),(CODE)
C   5.   H,K,L,OBS,STD DEVN,C1 C2 C3 C4, WHERE C1-C4 ARE THE
C        CONSTANTS INVOLVED IN EXTINCTION CORRECTIONS
C   7.   H,K,L (FLOATING) OBS,STD DEVN,(SCALE GROUP), (CODE)
C   8.   H,K,L(FLOATING),OBS,STD DEVN,C1 C2 C3 C4, WHERE C1-C4
C        ARE THE CONSTANTS INVOLVED IN THE EXTINCTION CORRECTION
C WHERE BOTH THE SCALE GROUP AND CODE ARE OPTIONAL.  IF THE SCALE GROUP IS
C READ AS ZERO, IT WILL BE SET = 1.
C   THE CODE IS NOT AT PRESENT USED; IT IS ENVISAGED THAT IT MAY BE USEFUL
C IN REJECTING SELECTED OBSERVATIONS LATER.
      DATA NMODES,MODES/9,1,2,3,4,5,6,7,8,11/
C MASK of ALLOWED REFI
C      DATA REFIS/.FALSE.,.FALSE.,.TRUE.,.FALSE.,.TRUE.,.FALSE.,
C     &.TRUE.,.FALSE.,.TRUE./
C
C ALTER VALUE HERE IF NECESSARY, WITH DIMENSION OF ALSQ:
%      MATSZ=%MATS%
C
C SET 'MULTIPOLE' FOR RECOGNITION OF PARAMETERS:
      MPL=.TRUE.
      MAG=.TRUE.
      CHI=.TRUE.
C
C SET UP STRUCTURE FACTOR CALCULATION:
      CALL PREFIN('MPCLSQ')
      CALL SYMOP
      CALL OPSYM(1)
      CALL RECIP
      CALL ATOPOS
      CALL SETANI
      CALL DOCHI1(1)
      CALL PFSET
C128 section imposing monopoles removed.
      CALL SETFOR
      CALL PFOUT
C SPECIFY PROBLEM:
      NFAM=5
      NGENS(1)=2
      NGENS(2)=NATOM
      NGENS(3)=0
      NGENS(4)=0
      NGENS(5)=1
      NSPC(1)=22
      NSPC(2)=18
      NSPC(3)=0
      NSPC(4)=0
      NSPC(5)=NMPOL
C
C SPECIES TYPES FOR EACH GENUS OF FAMILY 1:
      LF1SP(1)  =9
      LF1SP(2)=-20
C
C WORDS RELEVANT TO THIS PROBLEM FROM DATA INTO COMMON:
C C4.26 LOGICAL CHI now used by LSETSF
      CALL LSETSF(10,ISWDSP,ISFWRD)
C
C NAMES SET UP SO THAT:
C FAMILY 1 GENUS 1 HAS SPECIES TFAC, DOMR, MOSC (WITH SPACE FOR A* ETC)
C   '    1    '  2 HAS GENUS NAME SCAL, SPECIES INDICATED TO BE 1,2,3 ETC
C
C FAMILY 2 IS AS USUAL THE PARAMETERS WHICH DEPEND ON THE ATOM.  GENUS NAMES
C ARE THEREFORE THE SAME AS ATOM NAMES, AND SPECIES NAMES ARE:
C X Y Z B11 B22 B33 B23 B13 B12 SCAT SITE ITF,
C THE MAGNETIC SUSCEPTIBILITY TENSOR COMPONENTS CH11, CH22 ...ETC
C FAMILY 5 IS FOR THE MULTIPOLES
      CALL CENTRE(LPT,3,'Least Squares Refinement',80)
      CALL CENTRE(LPT,0,'Multipole Paramagnetic structure factors ',80)
C
C
C READ I AND (MOST) L CARDS:
      CALL STLSSF
C
C READ E CARD:
      CALL EXTINC(1,0.)
C find out whether PATHs should be calculated
      PATHS =(IEXTYP.NE.0 .AND. ICDNO(7).NE.0)
      IF (PATHS) CALL SETABS
C
C SET UP PARAMETERS AS VARIABLES:
      CALL DOCHI1(2)
      CALL CHITRN
      CALL PARSSF(DOTHER)
      CALL VARMAK(DFLTMC,PARRUN,VARSSF,DOTHER)
C
C DATA HEADER NEEDS MAGNETIC FIELD
      WRITE (ITO,2022) 'In MAIN',NHEAD,(LHEAD(I),I=1,NHEAD)
 2022 FORMAT (A10,10I4)
      NHEAD=NHEAD+1
      LHEAD(NHEAD+1)=LHEAD(NHEAD)+1
      FRMATS(NHEAD)='(''Magnetic Field'',f8.2,'' T'')'
      HEDWDS(NHEAD)='MAGN'
      HMASK(NHEAD)=.FALSE.
C Save the index of the magnetic field in SRCPAR
      MAGP=LHEAD(NHEAD)
C
C READ ALL THE DATA
      CALL DATASF(NMODES,MODES)
      CALL ERRMES(0,0,'for multipole CHI LSQ')
C
C Least squares cycles
      DONE=.FALSE.
      DO 1 ICYC=NCYC1,LASTCY
      CALL LSQCYC(ALSQ,MATSZ,LFCALC,TCHMPC)
      CALL APSHSF(DOTHER)
      IF (DONE) GO TO 39
      DONE=(AMAXSH.LT.CONV .OR. ICYC.EQ.LASTCY-1 .OR. NCYC.EQ.1)
C ON PENULTIMATE CYCLE PRODUCE NEW CRYSTAL DATA FILE:
      IF (DONE) CALL NWINSF(DOTHER)
   1  CONTINUE
C
C PRINT CORRELATION MATRIX:
  39  CALL MATCOR(ALSQ,MATSZ)
C Calculate Induced moments
      CALL MUCALC(MAGP)
      STOP
      END
C
C
C
C
C
      LOGICAL FUNCTION DOTHER(NN,MODE)
C
C *** DOTHER new by PJB June 2005 ***
C
CC 6A
CH Logical utility function to cope with new Least squares parameters
CD DOTHER is meant to simplify construction of new least squares programs
CD It just passes its arguments to other logical functions to
CD see whether they can deal with them
      LOGICAL DOCHI2,DOMPL2
C
/NEWOLD/
C
      DOTHER = DOCHI2(NN,MODE)

C Avoid DOMPL2 calling  MAGCON:  constraints are done elsewhere for mpoles
      IF (.NOT. DOTHER  .AND. MODE .NE. 1)  DOTHER = DOMPL2(NN,MODE)
      RETURN
      END
C
C
C
C
      LOGICAL FUNCTION DFLTMC(IFAM,IGEN,ISPC)
C
C *** DFLTMC  new by PJB Jun 2005 ***
C
CX
CC 7A
CH Called as a substitute for DEFALT via VARMAK, giving default fix/vary
CH for otherwise unspecified parameters for magnetic structures.
CA On entry IFAM, ISPC, IGEN give family, genus, species of parameter
CA On exit LOGICAL DFLTMG is TRUE if the parameter is to be varied, or
CA                           FALSE if to be fixed.
CD For magnetic structures, fix all conventional structure parameters,
CD and vary all possible magnetic parameters.
C
/MAGDAT/
/MPODA/
/MPODAC/
C
      DFLTMC=.TRUE.
      GO TO (1,2,101,101,3) , IFAM
      GO TO 101
C
C FAMILY 1 - DEFAULT FIX ALL
   1  GO TO 101
C
C FAMILY 5 PICK OUT AND FIX MONOPOLES
    3 IF (MPNAM(ISPC)(2:3).EQ. '00') GO TO 101
C VARY ALL OTHER MULTIPOLES
      GO TO 100
C FAMILY 2 - DEFAULT FIX NUCLEAR PARAMETERS:
   2  IF (ISPC .LE. 12) GO TO 101
C
C  FIX MAGNETIC PARS OF NON-MAGNETIC ATOMS
      IF (MAGAT(IGEN).EQ.0) GO TO 101
C
C  Vary all chis
      GO TO 100
C
C FIX:
 101  DFLTMC=.FALSE.
 100  RETURN
      END
C
C
C
C
      SUBROUTINE TCHMPC(H)
C
C *** TCHMPC corrected by PJB  C4.22 March 2011 ***
C
CX
CC 17B
CH Calculates magnetic structure factor tensors and derivatives on K-based axes with
CH multipole form factors for anisotropic paramagnets
CA On entry H is the 1x3 vector containing h,k,l
CP RECIP, SYMOP, SETANI, SETFOR and DOCHI must have been obeyed to set up
CP the structure factor calculation.
CP The LSQ environment must have been set up by a suitable MAIN program (like
CP SFLSQ) which has called LSETUP and VARMAK.
CP
CD On exit, in /MCAL/:
CD    FMCMOD = modulus of FMC
CD    FMCSQR = squared modulus of FMC
CD    FMCDER is an array containing the derivatives of FMCMOD wrt the family
CD           2 (structure) parameters, ALL MULTIPLIED BY FMCMOD.
CD    (Note the difference from the specification of LFCALC's derivatives)
CD On exit, in /QCAL/:
CD    Q is an array containing the magnetic interaction vectors for each domain
CD      in general there will be NDOM*KCENT domains
CD On exit, in /QCALD/:
CD    FQCDER is an array containing the derivatives of the Q's with respect to
CD           all the family 2 parameters.
CD
CD All the above will be zero if h,k,l is a magnetic absence
CN Note the existence also of LFCALC (nuclear structure factors for LSQ)
CN                            FMCALC (magnetic structure factors)
CN                            FCALC  (nuclear structure factors)
C
%      COMPLEX DERIVM(6,%F2VA%),SUM1(6),TERM,TVEC(6),HR,FORMFA,
     &PSUM,PFACS(50),FMC(6),TERMF
      LOGICAL MAGABS
      DIMENSION RH(3),H(3),RS(6),UNIMAT(3,3),TRAN(6,6),CHISYT(6,6)
/ANISO/
/BRAGG/
/CONSTA/
/DSOURC/
/IOUNIT/
/MAGCHI/
/MAGDAT/
      DIMENSION CHIIJ(6,20),KCHIJ(6,20)
      EQUIVALENCE (ANGM,CHIIJ),(KSMOD,KCHIJ)
/MCAL/
/MPODA/
/MPODAC/
/NSYM/
/PHASE/
/POINTS/
/POLFOR/
/POSNS/
/PRBLEM/
/QCAL/
/QCALD/
/SATELL/
/SYMDA/
/SYMTAB/
      DATA UNIMAT/1.,0.,0.,0.,1.,0.,0.,0.,1./
C
C CLEAR ALL ANSWERS IN CASE ABSENT:
C
C Set single phase
      JPHASE=1
C CLEAR MODULUS AND SQUARE:
      FMCMOD=0.
      FMCSQR=0.
      SSQRD=STHL*STHL
      L2=NVARF(2,1,1)
      L25=L2+NVARF(5,1,1)
C OFFSETS TO REACH FAMILY 2 & FAMILY 5 VARIABLES (ASSUMED CONSECUTIVE):
      LO=LVFST1(2,1,1)
      IF (LO .EQ. -1) LO=LVFST1(5,1,1)
      LO5=LO+L2
C CLEAR DERIVATIVES:
      IF (L25.GT.0) THEN
        CALL GMZER(FCDERS,1,L25)
        CALL CGMZER(DERIVT,1,L25)
        CALL GMZER(FMCDER,1,L25)
        CALL CGMZER(DERIVM,6,L25)
      ENDIF
C
C OUT IF ABSENT:
      IF (MAGABS(H,IK)) GO TO 100
C
C  No DOMAINS with paramagnetic structures
      ND=0
C FMC COLLECTS THE MAGNETIC STRUCTURE FACTOR, A COMPLEX VECTOR,
C initialised here
      CALL CGMZER(FMC,1,6)
C
C FIRST SCATTERING FACTOR:
      IFF=0
C
C CYCLE OVER MAGNETIC ATOMS:
      DO 1 IM=1,NMAG
      IR=JMAGAT(IM)
C
C get the multipole form factor number for this atom
      IMPFOR =MPFOR(NMFORM(IM))
C  SET MP TO THE MULTIPOLE ATOM AND NMP1, NMP2 TO SCAN ITS MULTIPOLES:
      MP=MPNMTB(IR)
      IF (MP.EQ.0) THEN
        NMP1=0
        NMP2=-1
C form factors for non-multipole atoms
        IF (IMPFOR .NE.0 .AND. MPLFOR(1,IMPFOR).EQ.-999) THEN
          AKK = FOURPI*STHL
          PSUM=FORMFC(AKK,0,0,NMFORM(IM))
        ELSE
          PSUM=FORMFA(STHL,NMFORM(IM))
        ENDIF
      ELSE
        NMP1=MPTAB(MP)
        NMP2=MPTAB(MP+1)-1
C  RADIAL FORM FACTORS: only for multipole atoms
        CALL PFORMF(H,MP,PSUM,PFACS,0)
      ENDIF
C
      CALL CGMZER(SUM1,6,1)
C
C SYMMETRY CYCLE
      DO 3 IS=1,NOPC
      CALL GMTRAN(CHISYM(1,1,IS),CHISYT,6,6)
      CALL ROTSYM(H,RH,IS,-1)
C ANISOTROPIC T F (=1. IF NOT THERE) NEEDED SEPARATELY FOR LSQ:
      IF (MP.NE.0) CALL PFORMF(RH,MP,PSUM,PFACS,1)
      F1=TWOPI*(SCALPR(X(1,IR),RH)+SCALPR(TRANS(1,IS),H))
      ERS=ANITF(RH,IR)
      ARS=COS(F1)*ERS
      BRS=SIN(F1)*ERS
      TERM=CMPLX(ARS,BRS)
C APPLY FORM FACTOR HERE (IN SIMPLER APPLICATIONS IT IS OUTSIDE THE
C SYMMETRY LOOP):
      TERMF=TERM*PSUM
C FIND OUT WHAT THE SYMMETRY DOES TO THE SUSCEPTIBILITY
C  and GET THE SPIN DIRECTION FOR THIS ATOM
      CALL GMPRD(CHISYT,CHIIJ(1,IM),RS,6,6,1)
      CALL C1MSCA(RS,TVEC,TERMF,6,1)
C IF CENTROSYMMETRIC, COMPENSATE FOR USING ONLY HALF NUMBER OF OPERATORS:
      IF(CENTRC) CALL CMRSCA(TVEC,TVEC,2.0,6,1)
      CALL CGMADD(SUM1,TVEC,SUM1,6,1)
C
C NOW WE DO THE INNERMOST SUMS FOR THE DERIVATIVES OF FMCMOD WRT
C VARIABLES XYZ AND ALL BIJ.  WE USE THE
C COMPLEX VECTOR DERIVM TO ACCUMULATE THE DERIVATIVES OF THE REAL &
C IMAGINARY PARTS OF THE COMPLEX FC WRT EACH VARIABLE IN TURN.
C
      DO 7 I=1,3
      L = KX(I,IR)
      IF (L .GT. 0) THEN
        CALL C1MSCA(RS,TVEC,RH(I)*PSUM*CMPLX(-BRS,ARS),6,1)
        IF(CENTRC) CALL CMRSCA(TVEC,TVEC,2.0,6,1)
        CALL CGMADD(DERIVM(1,L-LO),TVEC,DERIVM(1,L-LO),1,6)
      ENDIF
   7  CONTINUE
C
C JUMP IF NOT ATF AT ALL:
      IA=IAPT(IR)
      IF (IA .EQ. 0) GO TO 6
      I2=2
      I3=3
      DO 4 I=1,3
      L = KATF(I,IA)
      IF (L .GT. 0) THEN
C114 I1 replaced by I in next line
        CALL C1MSCA(RS,TVEC,RH(I)*RH(I)*TERMF,6,1)
        IF(CENTRC) CALL CMRSCA(TVEC,TVEC,2.0,6,1)
        CALL CGMADD(DERIVM(1,L-LO),TVEC,DERIVM(1,L-LO),1,6)
      ENDIF
      L = KATF(3+I,IA)
      IF (L .GT. 0) THEN
        CALL C1MSCA(RS,TVEC,RH(I2)*RH(I3)*TERMF,6,1)
        IF(CENTRC) CALL CMRSCA(TVEC,TVEC,2.0,6,1)
        CALL CGMADD(DERIVM(1,L-LO),TVEC,DERIVM(1,L-LO),1,5)
      ENDIF
      I2=I3
      I3=I
    4 CONTINUE
C NOW DERIVATIVES FOR SUSCEPTIBILITIES
    6 DO 14 I=1,6
      L=KCHIJ(I,IM)
      IF (L .GT. 0) THEN
        CALL C1MSCA(CHISYT(1,I),TVEC,TERMF,1,6)
        IF(CENTRC) CALL CMRSCA(TVEC,TVEC,2.0,6,1)
        CALL CGMADD(DERIVM(1,L-LO),TVEC,DERIVM(1,L-LO),1,6)
C      WRITE (LPT,1000) CHISYM(1,I,IS,JSRC),TERMF,TVEC
      ENDIF
   14 CONTINUE
C
C NOW MULTIPOLES:
      DO 21 I=NMP1,NMP2
      L=KPOLMP(I)
      IF (L.GT.0) THEN
        CALL C1MSCA(RS,TVEC,TERM*PFACS(I-NMP1+1),1,6)
        IF(CENTRC) CALL CMRSCA(TVEC,TVEC,2.0,6,1)
        CALL CGMADD(DERIVM(1,L-LO),TVEC,DERIVM(1,L-LO),1,6)
      ENDIF
  21  CONTINUE
C
   3  CONTINUE
C END OF INNERMOST CYCLE OVER SYMMETRY
C
C SCALE MOMENT TO CMS-12 AND CORRECT FOR MULTIPLICITY
      HR=SITE(IR)*VALMUB*AMULT(IR)*FIELD
C HR IS PRODUCT OF ATOM DEPENDENT BUT SYMMETRY INDEPENDENT FACTORS
      CALL CGMSCA(SUM1,TVEC,HR,6,1)
      CALL CGMADD(FMC,TVEC,FMC,1,6)
C      WRITE (LPT,1001) SUM1,FMC
C 1001 format (2(3(2f8.4,2x),2x))
C
C  NOW WE TIDY UP THE XYZ AND BIJ DERIVATIVES, AND MAKE ITF and SITE
      DO 8 I=1,3
      L = KX(I,IR)
      IF (L .GT. 0)
     & CALL CGMSCA(DERIVM(1,L-LO),DERIVM(1,L-LO),TWOPI*HR,6,1)
      IF (IA .GT. 0) THEN
        L = KATF(I,IA)
        IF (L .GT. 0)
     &  CALL CGMSCA(DERIVM(1,L-LO),DERIVM(1,L-LO),HR,6,1)
      L = KATF(I+3,IA)
        IF (L .GT. 0)
     &  CALL CGMSCA(DERIVM(1,L-LO),DERIVM(1,L-LO),HR*2.,6,1)
      ENDIF
   8  CONTINUE
C NOW MULTIPOLES:
      DO 9 I=NMP1,NMP2
      L=KPOLMP(I)
      IF (L.GT.0) THEN
        CALL GMSCA(DERIVM(1,L-LO),DERIVM(1,L-LO),HR,6,1)
      ENDIF
  9   CONTINUE
C
C SITE OCCUPATION and ITF
      L = KSITE(IR)
      IF (L .GT. 0)
     & CALL CGMSCA(SUM1,DERIVM(1,L-LO),HR/SITE(IR),6,1)
      L = KTF(IR)
      IF (L .GT. 0)
     & CALL CGMSCA(SUM1,DERIVM(1,L-LO),-(SSQRD*HR),6,1)
C RESCALE CHI DERIVATIVES
      DO 19 I=1,3
      L=KCHIJ(I,IM)
      IF (L .GT. 0) CALL CGMSCA(DERIVM(1,L-LO),DERIVM(1,L-LO),HR,6,1)
      L=KCHIJ(I+3,IM)
      IF (L .GT. 0) CALL CGMSCA(DERIVM(1,L-LO),DERIVM(1,L-LO),HR,6,1)
   19 CONTINUE
C
   1  CONTINUE
C END OF CYCLE OVER ATOMIC POSITIONS
C
C  FMC Is now a COMPLEX tensor on ORTHOGONAL CRYST COORDINATES
C      write (lpt,3002) H,(real(FMC(i)),i=1,6)
C TRANSFORM TO K-BASED AXES
      CALL TRAN2K(H,TRAN,TKMAT)
      CALL RCMPRD(TRAN,FMC,TCALC,6,6,1)
C      write (lpt,3001) (real(tcalc(i)),i=1,6)
C Return Fmperp*DFmperp/DPar IN FMCDER
      DO 20 I = 1,L25
C      write (lpt,3001) (real(DERIVM(j,i)),j=1,6)
      CALL RCMPRD(TRAN,DERIVM(1,i),FTCDER(1,I),6,6,1)
C       WRITE (LPT,3001) (FTCDER(j,I),j=1,6)
   20 CONTINUE
C 3002 FORMAT (3F4.0,6F8.3)
C 3001 FORMAT (12x,6(2F8.3,1X))
C PROJECT OUT MAGNETIC SCATTERING ACCORDING TO DATA-TYPE
      CALL PRJECT(L25,TKMAT)
C
 100  RETURN
      END
C
C
C
C
C LEVEL 50      PROGRAM MPLSQ
      PROGRAM MPLSQ
C
C *** MPLSQ  restructured to use LSQCYC C4.19 March 2010 ***
C
C ****************************************************************************
C
C                       M P L S Q
C
C
C MAIN PROGRAM FOR STRUCTURE FACTOR LEAST SQUARES REFINEMENT,
C USING MULTIPOLE DESCRIPTION OF THE DENSITY, ALLOWS EXTINCTION CORRECTIONS
C
C ****************************************************************************
C
CC 18D
CH Structure factor least squares using multipole form factors
C
C
CD Main program for least squares refinement, of structure factors with
CD Multipole description of form factors
CD Extinction corrections can be included and the extinction parameters refined.
CD Geometric slack constraints can be included (see chaper 5 of the CCSL users
CD manual and the documentation of program BONDS)
C
CI The crystal data file must contain all cards needed for structure factor
CI calculations vis:
CI       S cards giving the symmetry.
CI       A C card with the cell dimensions.
CI       A cards defining the atoms, their positions and isotropic.
CI       temperature factors.
CI       F cards giving the scattering factors
CI       J cards describing the multipoles to be used
CI       W ROTN cards giving the orientation of the multipole axes
CI       and possibly
CI       W RADF cards giving radial wave-funtions to be used to calculate
CI       the radial form factors
CI optionally:
CI       T cards giving anisotropic temperature factors
CI Additionally:
CI       L cards indicating which parameters should be refined
CI          (see the CCSL users' manual)
CI       I cards which may have the words words NCYC, CYCL1, PRIN,
CI       MCOR and CONV.
CI           NCYC the number of least squares cycles (default 3)
CI           CYC1 the number to be assigned to the first cycle (default 1)
CI           PRIN frequency at which output lists are printed
CI               PRIN = 0 no printing
CI               PRIN = 1 first cycle
CI               PRIN = 2 last cycle
CI               PRIN = 3 first and last cycles
CI               PRIN = 4 every cycle
CI           MCOR controls the correlations printed at tyhe end of the job
CI               (default +70)
CI               MCOR = 0 whole correlation matrix printed
CI               MCOR = -ve no printing
CI               MCOR = +ve correlations above MCOR printed
CI           CONV convergence criterion; LSQ cycling is terminated if the
CI               maximum shift/esd < CONV (default 0.01)
CI One or more data files which should be  lists of hkl and observations of the
CI type and in the format indicated by the values of REFI and MODE. For
CI single data sets MODE and REFI may be given on an L card, but with multiple
CI data sets they must be given interactively along with the file name. The
CI relative wieghts to be given to different data sets is also given there.
C
CO The usual listing file reporting the data which have been read. This file
CO also contains the output listings requested by the I PRIN card  as well as
CO the R-factors and chisqrd at the end of each least squares cycle.
CO A new crystal data file corresponding to the structure at the end of the
CO least squares refinement.
C
CR On running the program the user is asked for the name of the crystal data
CR file and the name of the file containing the structure factor data.
CR The value of \$\chi^2\$  at the end of each cycle is reported on the
CR terminal.
CR After the last cycle user is asked for a name for the new crystal data file.
C
      CHARACTER *4 ISFWRD(30)
      LOGICAL DFLTMP,DOMPL2,ONCARD,FOUND,TESTOV
      EXTERNAL DFLTMP,DOMPL2,PARRUN,VARSSF,LMPCAL
%      DIMENSION ALSQ(%MATS%),ISWDSP(3,30)
      DIMENSION MODES(9)

/CARDRC/
C4.2 common DERBAS needed
/DERBAS/
/DSOURC/
/EXTN/
/FCAL/
/FORMDA/
/IOUNIT/
/NEWOLD/
/MPODA/
/NSYM/
/OBSCAL/
/POLFOR/
/POSNS/
/PRBLEM/
/REFINE/
/RSTATS/
/SFDATA/
/SCLDAT/
/SCRACH/
      DATA ISFWRD/' ','SCAL','TFAC','X','Y','Z',
     & 'B11','B22','B33','B23','B13',
     & 'B12','SCAT','SITE','ITF',
     & 'XYZ','BIJ','XYZT','FAM1','FAM5',
     & 'FAM2','DOMR','MOSC',
     & 'CELL','A*','B*','C*',
     & 'D*','E*','F*'/
** NB UPDATE LIKE SFLSQ TO USE XYZB,XYZS FACILITIES
      DATA ISWDSP/1,1,0, 1,2,0, 1,1,1, 2,0,1, 2,0,2, 2,0,3,
     & 2,0,4, 2,0,5, 2,0,6, 2,0,7, 2,0,8,
     & 2,0,9, 2,0,10, 2,0,11, 2,0,12,
     & -1,0,0, -2,0,0, -3,0,0, 1,0,0, 5,0,0,
     & 2,0,0, 1,1,8, 1,1,9,
     & -4,0,0, 1,1,2, 1,1,3, 1,1,4,
     & 1,1,5, 1,1,6, 1,1,7/
C  THE ALLOWED OPTIONS FOR MODER IN MPLSQ ARE JUST:
C   3.   H,K,L,OBS,STANDARD DEVIATION OF OBS, (SCALE GROUP),(CODE)
C   4.   H,K,L,GCAL,OBS,STANDARD DEVN. (O/P FROM MEANGM)
C   5.   H,K,L,OBS,STD DEVN,C1 C2 C3 C4, WHERE C1-C4 ARE THE
C        CONSTANTS INVOLVED IN EXTINCTION CORRECTIONS
C   7.   H,K,L (FLOATING) OBS,STD DEVN,(SCALE GROUP), (CODE)
C   8.   H,K,L(FLOATING),OBS,STD DEVN,C1 C2 C3 C4, WHERE C1-C4
C        ARE THE CONSTANTS INVOLVED IN THE EXTINCTION CORRECTION
C WHERE BOTH THE SCALE GROUP AND CODE ARE OPTIONAL.  IF THE SCALE GROUP IS
C READ AS ZERO, IT WILL BE SET = 1.
C   THE CODE IS NOT AT PRESENT USED; IT IS ENVISAGED THAT IT MAY BE USEFUL
C IN REJECTING SELECTED OBSERVATIONS LATER.
      DATA NMODES,MODES/9,1,2,3,4,5,6,7,8,12/
C
C
C ALTER VALUE HERE IF NECESSARY, WITH DIMENSION OF ALSQ:
%      MATSZ=%MATS%
C
C SET 'MULTIPOLE' FOR RECOGNITION OF PARAMETERS:
      MPL=.TRUE.
C
C SET UP STRUCTURE FACTOR CALCULATION:
      CALL PREFIN('MPLSQ')
      CALL SYMOP
      CALL OPSYM(1)
      CALL RECIP
      CALL ATOPOS
      CALL SETANI
      CALL EXTINC(1,0.)
C find out whether PATHs should be calculated
      PATHS =(IEXTYP.NE.0 .AND. ICDNO(7).NE.0)
      IF (PATHS) CALL SETABS
      CALL PFSET
C128 section imposing monopoles removed.
C NOW SET UP THE FORM-FACTORS
      CALL SETFOR
      CALL PFOUT
C SPECIFY PROBLEM:
      NFAM=5
      NGENS(1)=2
      NGENS(2)=NATOM
      NGENS(3)=0
      NGENS(4)=0
      NGENS(5)=1
      NSPC(1)=20
      NSPC(2)=12
      NSPC(3)=0
      NSPC(4)=0
      NSPC(5)=NMPOL
C
C SPECIES TYPES FOR EACH GENUS OF FAMILY 1:
      LF1SP(1)  =9
      LF1SP(2)=-20
C
C WORDS RELEVANT TO THIS PROBLEM FROM DATA INTO COMMON:
      CALL LSETUP(30,ISWDSP,ISFWRD)
C
C NAMES SET UP SO THAT:
C FAMILY 1 GENUS 1 HAS SPECIES TFAC, DOMR, MOSC (WITH SPACE FOR A* ETC)
C   '    1    '  2 HAS GENUS NAME SCAL, SPECIES INDICATED TO BE 1,2,3 ETC
C
C FAMILY 2 IS AS USUAL THE PARAMETERS WHICH DEPEND ON THE ATOM.  GENUS NAMES
C ARE THEREFORE THE SAME AS ATOM NAMES, AND SPECIES NAMES ARE:
C X Y Z B11 B22 B33 B23 B13 B12 SCAT SITE ITF,
C FAMILY 5 IS FOR THE MULTIPOLES
C
C
C READ I AND (MOST) L CARDS:
      CALL STLSSF
C
C READ ALL THE DATA
      CALL DATASF(NMODES,MODES)
C
C SET UP PARAMETERS AS VARIABLES:
      CALL PARSSF(DOMPL2)
      CALL VARMAK(DFLTMP,PARRUN,VARSSF,DOMPL2)
C
C Least squares cycles
      DONE=.FALSE.
      DO 1 ICYC=NCYC1,LASTCY
      IF (ICYC.EQ.LASTCY) THEN
        IF (.NOT. TESTOV(RNUM,RDEN)) THEN
          R1=100.*RNUM/RDEN
          WRITE (ITO,2001) R1
 2001     FORMAT (' Final R factor : ',F8.2)
        ENDIF
C IS AN OUTPUT FILE TO BE MADE?
        LUNOPF=0
        FOUND =ONCARD('I','OPFL',A)
        IF (FOUND .AND. A.NE.0.) THEN
          MESSAG='output file (return for none)'
          NAMFIL='.MPC'
          LUNOPF=NOPFIL(112)
        ENDIF
      ENDIF
      CALL LSQCYC(ALSQ,MATSZ,LMPCAL,DUMMY)
      CALL APSHSF(DOMPL2)
      IF (DONE) GO TO 39
      DONE=(AMAXSH.LT.CONV .OR. ICYC.EQ.LASTCY-1 .OR. NCYC.EQ.1)
      IF (DONE) CALL NWINSF(DOMPL2)
   1  CONTINUE
C
C PRINT CORRELATION MATRIX:
  39  CALL MATCOR(ALSQ,MATSZ)
      STOP
      END
C
C
C
C
C LEVEL 50      PROGRAM MVENTR
      PROGRAM MVENTR
C
C *** MVENTR by PJB APRIL 92 ***
C
CC 17D
CH To draw magnetic structures in 3D in SGI inventor format
CD MVENTR is a program to draw magnetic structures, described in a
CD standard crystal data file, in IRIS inventor ascii format.
CI The crystal data file must contain all the information that would
CI be required for magnetic structure factor calculations viz:
CI      Symmetry (S) cards
CI      Cell (C) card
CI      Atom (A) cards
CI      Form factor (F) cards
CI      Magnetic structure (Q) cards
CI in addition special "X" cards are required to describe the graphical
CI output these are:
CI
CI      X ARRO <Data>   to define the proportions of arrows representing
CI        the magnetic moments.
CI        The <Data> are 4 real numbers: the head length, the head radius,
CI        and the tail radius all given as fractions of the total length
CI        of the arrow. The final number is the scale relating the length
CI        of an arrow in Angstroms to its moment in Bohr magnetons.
CI
CI      X CM/A <Scale>
CI        <Scale> gives the scale of the picture in cms/Angstrom unit.
CI
CI      X <Atom Name> SYMB <Data> indicating how to draw each type of
CI        atom.
CI        There should be one SYMB card with a matching <Atom Name> for
CI        each A card.
CI        The <Data> are a real number, the radius of the atom in Angstrom
CI        units followed by the name of the colour to be used to paint it.
CI        If the atom has a magnetic moment the name for the arrow colour
CI        must also be given. The colour names recognised are:
CI            Red,Tomato,Crimson,Orange,Gold,Yellow,YelGreen,Green,Grass,Aqua,
CI            Azure,Skyblue,Blue,Navy,Violet,Magenta,Pink,Black,White,Grey,
CI            Bisque,Beige,Brown,Chocolate.
CI        Only the first 4 characters of the name need be given, they are case
CI        insensitive.
CI
CI Example X cards for Fe2Ti
CI
CI X ARRO .333 0.1667 .0833 1.2
CI X SYMB Fe1 .25 Skyblue Yellow
CI X SYMB Fe2 .25 Blue Yellow
CI X SYMB Ti .4 Pink
CI X CM/A 1
C
CO The usual listing file reporting what was read from the
CO crystal data file and how it was interpreted.
CO An IRIS inventor ascii format file which can be viewed on a Silicon
CO graphics workstation. It will have the leaf name of the CDF and
CO extension .iv.
C
CR On running the program the user will be asked in the usual way for the
CR name of the crystal data file and the name for the output file.
CR Next the numbers of unit cells to be drawn in the directions of the a,b
CR and c crystallographic axes, are required. They should be given in that
CR order.
CR The magnetic structure can then be displayed on a Silicon Graphics
CR workstation using the SceneViewer application. This may be started
CR by double clicking the output file icon, or giving the UNIX command
CR       SceneViewer <output file-name>

      EXTERNAL DOMAG1
      DIMENSION POS(3,48),RX(3),TMP(4),PX(3),SV(3),SW(3),
     &R(3),PL(3),SVV(3,2),KPI(3),KP(3),
     &KLIM(3,2),KL(3,2),ST(3),RA(3),RLINE(3,2,100)
      LOGICAL DONE,NEWOP,FIRST
C
/CARDRC/
/CONSTA/
/IOUNIT/
/MAGDAT/
/POSNS/
/NSYM/
/SATELL/
/SCRACH/
/SYMDA/
/SYMMAG/
C
      NLINES=0
      CALL PREFIN('MVENTR')
C SET UP CRYSTALLOGRAPHY
      CALL SETFCM(DOMAG1)
      CALL MAGCNC
      CALL DOMAG1(2)
      MODUL=(MTYP.EQ.3 .OR. MTYP.EQ.4)
      IHELIX=1
      IF (MTYP.EQ.3) IHELIX=2
C
C READ X CARDS GIVING PICTURE DEFINITIONS
      CALL MVENTX
      CALL ERRMES(0,0,'for MVENTR')
C
C  INITIAL DIALOGUE
   22 CALL ASK('Number of cells in x,y, and z directions')
      CALL RDNUMS(TMP,1,4,N,IER)
      IF (IER.NE.0) GO TO 22
C SET THE MESH LIMITS
      CALL JGMZER(KLIM(1,1),3,1)
      CALL INDFIX(TMP,KLIM(1,2))
C
C  READ TITLE
      CALL INPUTN(LPT)
C
C  WRITE PREAMBLE
      CALL NVENTR(0)
C
C  DRAW THE CELLS
      DONE=.TRUE.
      DO 1 I=1,3
      CALL JGMEQ(KLIM(1,1),KPI,3,1)
      CALL JGMZER(KP,3,1)
      KP(I)=KLIM(I,2)-KLIM(I,1)
      CALL JGMEQ(KLIM,KL,3,2)
      KL(I,2)=KL(I,1)
      CALL INDFLO(RX,KP)
C SET THAT WE WANT ALL LIMITS
      ISW=7
    2 CALL INDFLO(R,KPI)
      CALL ERRCHK(2,NLINES,50,-1,'Too many lines to store')
      CALL ORTHO(R,RLINE(1,1,NLINES),1)
      CALL GMADD(R,RX,R,3,1)
      CALL ORTHO(R,RLINE(1,2,NLINES),1)
      IF (DONE) THEN
C
C  MAKE A SPECIAL ARROW FOR THE AXIS LABEL
        CALL GMEQ(RLINE(1,2,NLINES),SV,3,1)
        CALL LABAX(SV,RA,I)
        CALL GMADD(RLINE(1,2,NLINES),RA,RLINE(1,2,NLINES),3,1)
C OUTPUT INDEXED LINE
      CALL LINES(RLINE,NLINES)
        NLINES=0
      ENDIF
      CALL LATGEN(KPI,KP,KL,DONE,ISW,ISWO)
      IF (DONE) GO TO 1
      CALL JGMEQ(KP,KPI,3,1)
      GO TO 2
    1 CONTINUE
      CALL LINES(RLINE,NLINES)
C
C
C WRITE PREAMBLE FOR ATOMS
      CALL NVENTR(1)
C  GENERATE THE ATOMIC POSITIONS
      DO 5 NA=1,NATOM
      NMAG=MAGAT(NA)
      IF (NMAG.NE.0) THEN
C  SET THE SPIN DIRECTION FOR THIS ATOM
        CALL SPHPOL(ANGM(1,NMAG),ANGM(2,NMAG),SPIND(1,1,1,NMAG),3)
        IF (MTYP.EQ.3)
     &  CALL SPHPOL(ANGM(3,NMAG),ANGM(4,NMAG),SPIND(1,1,2,NMAG),3)
      ENDIF
      CALL GMEQ(X(1,NA),POS(1,1),1,3)
      M=1
      FIRST=.TRUE.
      DO 4 N=1,NOPC
      CALL ROTSYM(X(1,NA),PX,N,1)
      CALL GMADD(PX,TRANS(1,N),PX,3,1)
      IF (MODUL) THEN
        ISUB=IPTAB(N,NMAG)
      ENDIF
      DO 6 IC=1,NCENT
      NEWOP=.TRUE.
      IF (MODUL .AND. IC.EQ.2) THEN
        ISUB=ISUB+IPTAB(NOPC+1,NMAG)
      ENDIF
      DO 14 NL=1,NLAT
      CALL GMADD(PX,ALAT(1,NL),RX,3,1)
      CALL EQPOS(POS(1,1),RX,M,M1,48)
      IF (M1.GT. M .OR. FIRST) THEN
        M=M1
        FIRST=.FALSE.
        CALL GMSUB(POS(1,M),RX,PL,3,1)
        CALL GMADD(PL,ALAT(1,NL),PL,3,1)
C GET PHASE OFFSET
        IF (NMAG.NE.0) THEN
          PH0=TWOPI*(SCALPR(PL,PROP))
          IF (MODUL) PH0=PH0+RADIAN(PHIH(ISUB,NMAG))
        ENDIF
C
C  DRAW THE ARROWS AND ATOMS
C
C  WORK OVER UNIT CELLS
        CALL JGMEQ(KLIM(1,1),KP,3,1)
C SET THE BOUNDARY SWITCH
        J=1
        ISW=0
        DO 11 I=1,3
        IF (ABS(POS(I,M)).LT..0001) ISW=ISW+J
        J=2*J
   11   CONTINUE
   15   CALL INDFLO(PL,KP)
        CALL JGMEQ(KP,KPI,3,1)
        CALL GMADD(POS(1,M),PL,R,3,1)
        CALL ORTHO(R,RA,1)
C FOR MAGNETIC ATOMS
        IF (NMAG.NE.0) THEN
          PHASE=PH0+TWOPI*SCALPR(PROP,PL)
C         PHASE=EXOPHS(PHASE)
          IF (NEWOP) THEN
            DO 9 I=1,IHELIX
            CALL GMPRD(OTRSYM(1,1,N),SPIND(1,1,I,NMAG),SVV(1,I),3,3,1)
C  IF INVERSION IS INCLUDED
            IF (IC.EQ.2) THEN
              CALL GMPRD(OTRSYM(1,1,NOPC+1),SVV(1,I),SW,3,3,1)
              CALL GMEQ(SW,SVV(1,I),3,1)
            ENDIF
    9       CONTINUE
            NEWOP=.FALSE.
          ENDIF
          PHP=SMOD(1,NMAG)*COS(PHASE)
          CALL GMSCA(SVV(1,1),SV,PHP,3,1)
          IF (IHELIX.EQ.2) THEN
            PHP=SMOD(2,NMAG)*SIN(PHASE)
            CALL GMSCA(SVV(1,2),ST,PHP,3,1)
            CALL GMADD(ST,SV,SV,3,1)
          ENDIF
          WRITE (LPT,230) N,IC,KP,PH0,PHASE,SV
  230     FORMAT(1X,2I3,2X,3I3,22F10.4,2X,3F8.3)
          CALL GMEQ(SV,ST,3,1)
          CALL UNIVEC(ST,AL)
          IF (AL.GT..0005) THEN
            CALL ARROW(RA,SV,NA)
          ENDIF
        ENDIF
        CALL ATOM(RA,NA)
        CALL LATGEN(KPI,KP,KLIM,DONE,ISW,ISWO)
        IF (.NOT. DONE) GO TO 15
      ENDIF
   14 CONTINUE
      IF (IC .EQ. NCENT-1) CALL GMREV(PX,PX,3,1)
    6 CONTINUE
    4 CONTINUE
    5 CONTINUE
C
      CALL NVENTR(2)
      STOP
      END
C
C
C
C
      SUBROUTINE ARROW(P,S,N)

      DIMENSION P(3),PV(3),S(3),SV(3),ROT(4)
      COMMON/VFRMTS/ROTFRM,TRNFRM,COLFRM,CYLFRM,SPHFRM,CONFRM,TXTFRM,
     &SEPFRM,FINFRM
      CHARACTER *56 ROTFRM,TRNFRM,COLFRM,CYLFRM,CONFRM
      CHARACTER *20 SEPFRM,FINFRM*12,TXTFRM*35,SPHFRM*35
/IOUNIT/
      COMMON /LAYOUT/INDENT,ITAB,YAX(3)
      COMMON /PICDEF/CMPERA,FHEAD,FRHEAD,FRTAIL,FRLINE,
     & APERMB,RA(20),RGB(3,2,20),BCOL(3),CCOL(3)
C
CH MAKES AN INVENTOR ARROW
C
      CALL GMSCA(P,PV,CMPERA,3,1)
      CALL GMEQ(S,SV,3,1)
      CALL UNIVEC(SV,AL)
      AL=AL*APERMB
      CALL MAKROT(SV,ROT)
      WRITE (SEPFRM(2:3),10) INDENT
   10 FORMAT (I2)
      WRITE (IPLO,SEPFRM)
      INDENT=INDENT+ITAB
      WRITE (TRNFRM(2:3),10) INDENT
      WRITE (IPLO,TRNFRM) PV
      WRITE (COLFRM(2:3),10) INDENT
      WRITE (IPLO,COLFRM) (RGB(I,2,N),I=1,3)
      WRITE (ROTFRM(2:3),10) INDENT
      WRITE (IPLO,ROTFRM) ROT
      T=-(0.5*FHEAD*AL)
      CALL GMSCA(YAX,PV,T,3,1)
      WRITE (IPLO,TRNFRM) PV
      WRITE (CYLFRM(2:3),10) INDENT
      WRITE (IPLO,CYLFRM) FRTAIL*AL,(1-FHEAD)*AL
      T=0.5*AL
      CALL GMSCA(YAX,PV,T,3,1)
      WRITE (IPLO,TRNFRM) PV
      WRITE (CONFRM(2:3),10) INDENT
      WRITE (IPLO,CONFRM) FRHEAD*AL,FHEAD*AL
      INDENT=INDENT-ITAB
      WRITE (FINFRM(2:3),10) INDENT
      WRITE (IPLO,FINFRM)
      RETURN
      END
C
C
C
C
      SUBROUTINE ATOM(R,N)
C
      DIMENSION R(3),RV(3)
      COMMON/VFRMTS/ROTFRM,TRNFRM,COLFRM,CYLFRM,SPHFRM,CONFRM,TXTFRM,
     &SEPFRM,FINFRM
      CHARACTER *56 ROTFRM,TRNFRM,COLFRM,CYLFRM,CONFRM
      CHARACTER *20 SEPFRM,FINFRM*12,TXTFRM*35,SPHFRM*35
/IOUNIT/
      COMMON /LAYOUT/INDENT,ITAB,YAX(3)
      COMMON /PICDEF/CMPERA,FHEAD,FRHEAD,FRTAIL,FRLINE,
     & APERMB,RA(20),RGB(3,2,20),BCOL(3),CCOL(3)
C
      CALL GMSCA(R,RV,CMPERA,3,1)
      WRITE (SEPFRM(2:3),10) INDENT
   10 FORMAT (I2)
      INDENT=INDENT+ITAB
      WRITE (IPLO,SEPFRM)
      WRITE (COLFRM(2:3),10) INDENT
      WRITE (IPLO,COLFRM) (RGB(I,1,N),I=1,3)
      WRITE (TRNFRM(2:3),10) INDENT
      WRITE (IPLO,TRNFRM) RV
      WRITE (SPHFRM(2:3),10) INDENT
      WRITE (IPLO,SPHFRM) RA(N)
      INDENT=INDENT-ITAB
      WRITE (FINFRM(2:3),10) INDENT
      WRITE (IPLO,FINFRM)
      RETURN
      END
C
C
C
C
      SUBROUTINE COLORS(NAME,CODE)
C
C  *** Colors new by PJB May-3-1994 ***
C
CH Sets CODE to the hex RGB code for the colour NAME
C
CD The colours recognised are: Red,Tomato,Crimson,Orange,Gold,Yellow,
CD                             YelGreen,Green,Grass,Aqua,Azure,Skyblue,
CD                             Blue,Navy,Violet,Magenta,Pink,Black,White,
CD                             Grey,Bisque,Beige,Brown and Chocolate.
CD They are identified by the first four characters of their names
C
      CHARACTER *4 NAME,UPNAME,COLNAM(24)
      CHARACTER *6 CODE,COLCOD(24)
      DATA COLNAM/'RED' ,'TOMA','CRIM','ORAN','GOLD','YELL',
     &'YELG','GREE','GRAS','AQUA','AZUR','SKYB',
     &'BLUE','NAVY','VIOL','MAGE','PINK','BLAC',
     &'WHIT','GREY','BISQ','BEIG','BROW','CHOC'/
      DATA COLCOD/'ff0000','ff6347','ff154d','ff7113','f5cf00','ffff00',
     &'bfff3e','00ff00','8bcd26','7fffd4','def5ff','87ceff',
     &'0000ff','2727a1','ce7ee6','f400f4','ff91c9','000000',
     &'ffffff','c0c0c0','ffe4c4','ffd39b','8d2f0d','722f17'/
C
      UPNAME=NAME
C ENSURE NAME IS UPPER CASE
      CALL UPONE(UPNAME,0)
      I=NCFIND(UPNAME,COLNAM,24)
      IF (I.EQ.0) THEN
        CODE=' '
      ELSE
        CODE=COLCOD(I)
      ENDIF
      RETURN
      END
C
C
C
C
      SUBROUTINE LABAX(RV,RS,IAXE)
C
      DIMENSION RV(3),RS(3),R(3),ROT(4)
      CHARACTER*1 LAB(3)
      COMMON/VFRMTS/ROTFRM,TRNFRM,COLFRM,CYLFRM,SPHFRM,CONFRM,TXTFRM,
     &SEPFRM,FINFRM
      CHARACTER *56 ROTFRM,TRNFRM,COLFRM,CYLFRM,CONFRM
      CHARACTER *20 SEPFRM,FINFRM*12,TXTFRM*35,SPHFRM*35
/IOUNIT/
      COMMON /LAYOUT/INDENT,ITAB,YAX(3)
      COMMON /PICDEF/CMPERA,FHEAD,FRHEAD,FRTAIL,FRLINE,
     & APERMB,RA(20),RGB(3,2,20),BCOL(3),CCOL(3)
      DATA LAB/'a','b','c'/
      DATA FRAC,FRRAC/1.,.2/
C
      CALL GMEQ(RV,R,3,1)
      CALL UNIVEC(R,AL)
      AL=3.*CMPERA
      CALL MAKROT(R,ROT)
      CALL GMSCA(R,RS,0.5*AL,3,1)
      CALL GMADD(RV,RS,R,3,1)
      WRITE (SEPFRM(2:3),10) INDENT
   10 FORMAT (I2)
      WRITE (IPLO,SEPFRM)
      INDENT = INDENT+ITAB
      WRITE (IPLO,12)
   12 FORMAT (7X,'LightModel { model PHONG }'
     &/7X,'MaterialBinding { value OVERALL }')
      WRITE (COLFRM(2:3),10) INDENT
      WRITE (IPLO,COLFRM) CCOL
      WRITE (TRNFRM(2:3),10) INDENT
      WRITE (IPLO,TRNFRM) R
      WRITE (ROTFRM(2:3),10) INDENT
      WRITE (IPLO,ROTFRM) ROT
      CALL GMSCA(YAX,R,0.5*FRAC*AL,3,1)
      WRITE (IPLO,TRNFRM) R
      WRITE (CONFRM(2:3),10) INDENT
      WRITE (IPLO,CONFRM) AL*FRRAC,FRAC*AL
      CALL GMSCA(YAX,R,0.8*FRAC*AL,3,1)
      WRITE (IPLO,TRNFRM) R
      WRITE (TXTFRM(2:3),10) INDENT
      WRITE (TXTFRM(26:27),10) LEN(LAB(IAXE))
      WRITE (IPLO,TXTFRM) LAB(IAXE)
      INDENT=INDENT-ITAB
      WRITE (FINFRM(2:3),10) INDENT
      WRITE (IPLO,FINFRM)
      RETURN
      END
C
C
C
C
      SUBROUTINE LINES(PTS,NPTS)
C
C *** LINES new by PJB April 94 ***
C
CH Writes inventor output for indexed lines
C
      DIMENSION PTS(3,2,NPTS),P(3,2)
/IOUNIT/
      COMMON /PICDEF/CMPERA,FHEAD,FRHEAD,FRTAIL,FRLINE,
     & APERMB,RA(20),RGB(3,2,20),BCOL(3),CCOL(3)
      COMMON/VFRMTS/ROTFRM,TRNFRM,COLFRM,CYLFRM,SPHFRM,CONFRM,TXTFRM,
     &SEPFRM,FINFRM
      CHARACTER *56 ROTFRM,TRNFRM,COLFRM,CYLFRM,CONFRM
      CHARACTER *20 SEPFRM,FINFRM*12,TXTFRM*35,SPHFRM*35
      COMMON /LAYOUT/INDENT,ITAB,YAX(3)
C
      WRITE (SEPFRM(2:3),11) INDENT
   11 FORMAT (I2)
      WRITE (IPLO,SEPFRM)
      INDENT=INDENT+ITAB
      WRITE (IPLO,12)
   12 FORMAT (7X,'LightModel { model PHONG }'
     &/7X,'MaterialBinding { value PER_PART }'
     &/7X,'DrawStyle { lineWidth 3 }')
      WRITE (COLFRM(2:3),11) INDENT
      WRITE (IPLO,COLFRM) CCOL
      DO 1 I=1,NPTS
      DO 2 J=1,2
      CALL GMSCA(PTS(1,J,I),P(1,J),CMPERA,3,1)
    2 CONTINUE
      IF (NPTS.EQ.1) THEN
        WRITE (IPLO,18) P
   18 FORMAT (7X,'Coordinate3 { point [',3F8.3,',',3F8.3,'] }')
      ELSE IF (I.EQ.1) THEN
        WRITE (IPLO,10) P
   10 FORMAT (7X,'Coordinate3 { point [',2(3F8.3,','))
      ELSE IF (I.EQ.NPTS) THEN
        WRITE (IPLO,13) P
   13 FORMAT (28X,3F8.3,',',3F8.3,'] }')
      ELSE
        WRITE (IPLO,14) P
   14 FORMAT(28X,2(3F8.3,','))
      ENDIF
    1 CONTINUE
C
      DO 3 I=1,NPTS,4
      IR=NPTS-I
      L=2*I-3
      IF (I.EQ.1) THEN
        WRITE (IPLO,15)
   15 FORMAT (7X,'IndexedLineSet { coordIndex [')
      ENDIF
      IF (IR.GE.4) THEN
        WRITE (IPLO,16) ((L+J),J=1,8)
   16 FORMAT (28X,4(2(I3,','),' -1,'))
      ELSE
        IF (IR .GT.0) WRITE (IPLO,16) ((L+J),J=1,2*IR)
        WRITE (IPLO,17) 2*NPTS-2,2*NPTS-1
   17 FORMAT (28X,I3,',',I3,'] }')
      ENDIF
    3 CONTINUE
      INDENT=INDENT-ITAB
      WRITE (FINFRM(2:3),11) INDENT
      WRITE (IPLO,FINFRM)
      RETURN
      END
C
C
C
C
      SUBROUTINE MAKROT(P,ROT)
C
      DIMENSION ROT(4),P(3),V(3),XAX(3)
      COMMON /LAYOUT/INDENT,ITAB,YAX(3)
      DATA XAX/1.,0.,0/
C
      CALL GMEQ(P,V,3,1)
      CALL UNIVEC(V,D)
      CALL VECPRD(YAX,V,ROT)
      CALL UNIVEC(ROT,SINA)
      COSA=SCALPR(V,YAX)
      IF (SINA.LT. .0001) CALL GMEQ(XAX,ROT,3,1)
      ROT(4)=ATAN2(SINA,COSA)
      RETURN
      END
C
C
C
C
      SUBROUTINE MVENTX
C
C *** MVENTX new by PJB May 94 ***
C
CH To read the "X" cards for MVENTR
C
      DIMENSION A(6)
      LOGICAL DONE(20)
      CHARACTER*4 NAME,CNAME*20,CODE*6
/ATNAM/
/IOUNIT/
/MAGDAT/
      COMMON /PICDEF/CMPERA,FHEAD,FRHEAD,FRTAIL,FRLINE,
     & APERMB,RA(20),RGB(3,2,20),BCOL(3),CCOL(3)
/POSNS/
/SCRACH/
C
      CALL ERRCHK(1,NATOM,20,0,'Too many atoms for MVENTR')
      DO 6 I=1,NATOM
    6 DONE(I)=.FALSE.
      CALL FINDCD('X','CM/A',4,0,LCD)
      IF (LCD.LE.0) THEN
        CMPERA=1
      ELSE
        CALL RDREAL(CMPERA,7,IPT,50,IER)
        IF (IER.NE.0) GO TO 1
      ENDIF
      CALL FINDCD('X','ARRO',4,0,LCD)
      IF (LCD.LE.0) GO TO 1
      CALL RDNUMS(A,7,5,NUM,IER)
      IF (IER.NE.0 .OR. NUM.LT. 5) GO TO 1
      FHEAD=A(1)
      FRHEAD=A(2)
      FRTAIL=A(3)
      APERMB=A(5)
      CALL FINDCD('X','BCOL',4,0,LCD)
      IF (LCD.LE.0) THEN
        CNAME='black'
      ELSE
        CALL RDWORD(CNAME,LENWD,7,IPT,80,0,IER)
        IF (IER.NE.0) GO TO 1
      ENDIF
      CALL COLORS(CNAME(1:4),CODE)
      IF (CODE.EQ.' ') THEN
        CALL ERRCH2(CNAME,1,'Colour','not recognised')
      ELSE
        CALL HEXCOL(CODE,BCOL)
      ENDIF
      CALL FINDCD('X','CCOL',4,0,LCD)
      IF (LCD.LE.0) THEN
        CNAME='white'
      ELSE
        CALL RDWORD(CNAME,LENWD,7,IPT,80,0,IER)
        IF (IER.NE.0) GO TO 1
      ENDIF
      CALL COLORS(CNAME(1:4),CODE)
      IF (CODE.EQ.' ') THEN
        CALL ERRCH2(CNAME,1,'Colour','not recognised')
      ELSE
        CALL HEXCOL(CODE,CCOL)
      ENDIF
      K=0
    3 CALL FINDCD('X','SYMB',4,K,LCD)
      IF (LCD.LE. 0) GO TO 4
      K=LCD
      CALL RDWORD(NAME,LEN,7,IPT,20,0,IER)
      IF (IER.NE.0) GO TO 1
      NA=IATOM(NAME)
      IF (NA .EQ.0) CALL ERRMES(1,1,
     & NAME//' not found in list of atom names')
      MAT=MAGAT(NA)
      NVAL=1
      IF (MAT.GT.0) NVAL=NVAL+1
      CALL RDREAL(RA(NA),IPT,IPT1,IPT+20,IER)
      IF (IER.NE.0) GO TO 1
C GET RGB VALUES
      CALL RDWORD(CNAME,LENWD,IPT1,IPT,80,0,IER)
      CALL COLORS(CNAME(1:4),CODE)
      IF (CODE.EQ.' ') THEN
        CALL ERRCH2(CNAME,1,'Colour','not recognised')
      ELSE
        CALL HEXCOL(CODE,RGB(1,1,NA))
      ENDIF
      IF (MAGAT(NA).GT.0) THEN
        CALL RDWORD(CNAME,LENWD,IPT,IPT1,80,0,IER)
        CALL COLORS(CNAME(1:4),CODE)
        IF (CODE.EQ.' ') THEN
          CALL ERRCH2(CNAME,1,'Colour','not recognised')
        ELSE
          CALL HEXCOL(CODE,RGB(1,2,NA))
        ENDIF
      ENDIF
      DONE(NA)=.TRUE.
      GO TO 3
    4 DO 5 NA=1,NATOM
      IF (.NOT.DONE(NA)) CALL ERRMES(1,1,'No symbol information for '
     &//ATNAME(NA))
    5 CONTINUE
      CALL ERRMES(0,0,'for MVENTR')
      RETURN
    1 WRITE (ITO,11) ICARD
   11 FORMAT (' Error reading geometry definitions, data read:'/1X,A80)
      STOP
      END
C
C
C
C
      SUBROUTINE NVENTR(MODE)
C
      DIMENSION ROT(4)
      CHARACTER *35 FMT1*50,FMT2,FMT3
      CHARACTER *10 FNAM,FILNOM
C
/CARDRC/
/CONSTA/
/IOUNIT/
      COMMON /LAYOUT/INDENT,ITAB,YAX(3)
/SCRACH/
      COMMON/VFRMTS/ROTFRM,TRNFRM,COLFRM,CYLFRM,SPHFRM,CONFRM,TXTFRM,
     &SEPFRM,FINFRM
      CHARACTER *56 ROTFRM,TRNFRM,COLFRM,CYLFRM,CONFRM
      CHARACTER *20 SEPFRM,FINFRM*12,TXTFRM*35,SPHFRM*35
      DATA FMT1/'( 1X,''Font { size 14 }'')'/
      DATA FMT2/'( 1X,''Material { shininess 1 }'')'/
      DATA FMT3/'( 1X,''Complexity { value 0.2 }'')'/
      DATA ROT/.57735,.57735,.57735,1./
C
      GO TO (1,2,3), MODE+1
C
    1 FNAM=FILNOM(ICRYDA)
      I=INDEX(FNAM,'.')
      IF (I.NE.0) FNAM(I:)='.iv'
    4 CALL ASK('Name for inventor file (default:'//FNAM//')')
      IF (MESSAG.EQ.' ') MESSAG=FNAM
      NAMFIL='.iv'
      IPLO=NOPFIL(122)
      IF (IPLO.LE.0) GO TO 4
      WRITE (IPLO,10)
   10 FORMAT ('#Inventor V1.0 ascii'/)
      WRITE (SEPFRM(2:3),11) INDENT
      WRITE (IPLO,SEPFRM)
      INDENT=INDENT+ITAB
      WRITE (FMT1(2:3),11) INDENT
      WRITE (IPLO,FMT1)
      WRITE (ROTFRM(2:3),11) INDENT
      ROT(4)=-(TWOPI/3.)
      WRITE (IPLO,ROTFRM) ROT
      GO TO 100
    2 WRITE (SEPFRM(2:3),11) INDENT
   11 FORMAT (I2)
      INDENT=INDENT+ITAB
      WRITE (IPLO,SEPFRM)
      WRITE( FMT2(2:3),11) INDENT
      WRITE (FMT3(2:3),11) INDENT
      WRITE (IPLO,FMT2)
      WRITE (IPLO,FMT3)
      GO TO 100
    3 INDENT=INDENT-ITAB
      WRITE (FINFRM(2:3),11) INDENT
      WRITE (IPLO,FINFRM)
      IF (INDENT.GT.1) GO TO 3
      GO TO 100
  100 RETURN
      END
C
C
C
C
      SUBROUTINE HEXCOL(CODE,RGB)
C
      DIMENSION RGB(3),ICOL(3)
      CHARACTER *6 CODE

      READ (CODE,10) ICOL
   10 FORMAT (3Z2)
      DO 1 I=1,3
      RGB(I)=FLOAT(ICOL(I))/255.
    1 CONTINUE
      RETURN
      END
C
C
C
C
      BLOCK DATA FRMATS
C
      COMMON/VFRMTS/ROTFRM,TRNFRM,COLFRM,CYLFRM,SPHFRM,CONFRM,TXTFRM,
     &SEPFRM,FINFRM
      CHARACTER *56 ROTFRM,TRNFRM,COLFRM,CYLFRM,CONFRM
      CHARACTER *20 SEPFRM,FINFRM*12,TXTFRM*35,SPHFRM*35
      COMMON /LAYOUT/INDENT,ITAB,YAX(3)
      DATA ROTFRM/'( 1X,''Rotation { rotation '',3F8.3,F8.4,'' }'')'/
      DATA TRNFRM/'( 1X,''Translation { translation '',3F8.3,'' }'')'/
      DATA COLFRM/'( 1X,''BaseColor { rgb [''3F6.3''] }'')'/
      DATA CYLFRM/
     &'( 1X,''Cylinder { radius'',F8.3,'' height'',F8.3,'' }'')'/
      DATA SPHFRM/'( 1X,''Sphere { radius'',F8.3,'' }'')'/
      DATA CONFRM
     &/'( 1X,''Cone { bottomRadius'',F8.3,'' height'',F8.3,''}'')'/
      DATA TXTFRM/'( 1X,''Text2 { string "'',A10,''" }'')'/
      DATA SEPFRM/'( 1X,''Separator {'')'/
      DATA FINFRM/'( 1X,''}'')'/
      DATA INDENT,ITAB,YAX/1,6,0.,1.,0./
      END
C
C
C
C
      FUNCTION EXOPHS(PHASE)
C
CH Modulates the phase for exotic magnetic structures
CD This version for spin-slip
C
/CONSTA/
C
      NUM=NINT(3.*PHASE/PI)
      PHI=FLOAT(NUM)*PI/3.
      EXOPHS=PHI
      RETURN
      END
C
C
C
C
C LEVEL 50      PROGRAM MXEQSH
      PROGRAM MXEQSH
C
C *** MXEQSH new by PJB June 2006 ***
C
C *****************************************************************************
C
C                           M X E Q S H
C
C    Program to plot sections from a MAXENT map with SHGRID interpolation
C
C *****************************************************************************
C
CC 5D
C
CH Plots general sections from a MAXENT map using SHGRID onterpolation
CH Needs  QSHEP  : ALGORITHM 661, COLLECTED ALGORITHMS FROM ACM.
C

CD output can be printed and/or plotted as a contoured map.
CI The crystal data file must contain:
CI      A C card with the cell dimensions
CI      S cards giving the symmetry
CI      M cards defining which maps to draw and how they are defined
CI        (see the CCSL users' manual)
CI A file containing the MAXENT map, as generated by MAGMAX3D or similar
CI default extension .mem.
C
CO The usual listing file reporting the data which have been read. If there is
CO an M PRIN card this file also contains the values of the density
CO at the points requested. These numbers are rounded to integers so the
CO scale (given by M SCAL) must be chosen to ensure they are not all zero.
CO
CO If there is an M PLOT card: graphical output whose form depends upon the
CO graphical library being used.
CO
CR Ensure that the terminal from which the program is to be run is appropriate
CR to the graphics library with which the program was linked.
CR On running the program the user is asked for the name of the crystal data
CR file, and the name of the file containing the MAXENT output (default
CR extension .mem).
CR coefficients (reflection data). Any further dialogue is driven by the
CR graphics library and is usually confined to an enquiry as to whether a
CR hard copy of a map is required. If no contour values are given on M cards
CR and an M PLOT card is present, the program will ask for them interactively.
C
CN To obtain the different versions of the program it must be linked with
CN the appropriate version of the hardware dependent subroutines PIGLET
CN etc. from thethe PIG section of the library. Currently available are:
CN     PIGPL .............. for Benson plotter (obsolete)
CN     PIGPG .............. for PGPLOT library (T.J. Pearson)
CN     PIGGKS ............. for GKS
CN     PIGPOS ............. Postscript output
CN and, except in the case of PIGPOS, the appropriate graphics library
C
C Set to max allowed in MEMSYS
      PARAMETER (NPOINT=56*56*56)
%      DIMENSION CFOUND(%CONT%),NEEDM(%MCRD%),VALS(NPOINT)
      CHARACTER *10 MFILE
      LOGICAL PLOTED
/IOUNIT/
/MAPDA/
      COMMON /MAXENT/GRID(3,3),NXP(3),xlim(3,3)
     &,xorig(3),UOUT (3,3),NDIMEN
/MREAD/
/PLOMAP/
      DATA PLOTED/.FALSE./
C MASK FOR MCARDS NEEDED (-1 means ignore)
C               NDIM FTYP MESH' AXES PRIN PLOT CM/A CONT SAVE READ DTYP
      DATA NEEDM/-1,  -1,   0,    0,   0,   0,   0,   0,  -1,  -1,  -1,
     &-1,   0,  -1, -1,  -1,  -1,   0,   -1/
C     DELT SCAL GET SMAX GRID AXME LABL MAXE
C
      CALL PREFIN('MXEQSH')
      CALL RECIP
      CALL GETMEM(MFILE,VALS,NPOINT)
      CALL SETFOU(NEEDM)
      NDIM = NDIMEN
      IF (IMREAD(6) .GT. 0) CALL STPLOT
      CALL ERRMES(0,0,'to MXEQSH')
      IOP = 0
    1 CALL NEXZED(IOP,ZED)
      IF (IOP.EQ.0) GO TO 20
      CALL GETSEC(ZED,VALS)
C
C
C  NOW WHAT OUTPUT?
   10 IF (MOD(IOP,2).EQ.1) CALL PRNTMP(21)
      I=IOP/2
      IF (MOD(I,2).EQ.1) THEN
C OBEY ANY SPECIAL CODE NEEDED AT PICTURE START:
        CALL PIGLET(WIDPIC,HGTPIC,888)
        CALL PICMOV
C
C SET THAT WE ARE IN PICTURE SPACE:
        CALL SPCSET(3)
C SELECT BLACK PEN:
        CALL PIGLET(0.,0.,-1)
C AND DRAW A FRAME ROUND THE WHOLE PICTURE:
        CALL FRAME(0.,0.,WIDPIC,HGTPIC)
C
C WRITE TITLE:
      CALL MAPTIT
C
C DRAW FRAME FOR MAP AND LABEL IT:
        CALL MAPFRA
C
C DRAW ACTUAL CONTOURS:
        CALL MAPDRW(CFOUND,IC,IBMAX,IFMAX)
C
C NO MORE CONTOURS WANTED - DRAW TEXT BLOCK UNDER PICTURE
        IF (MODET.EQ.1) CALL UNUSYM
        CALL ATMPLT(ZED-0.01,ZED+0.01)
        CALL MEFOOT(MFILE)
C
C FINALLY, COMPLETE PICTURE BY LISTING FOUND CONTOURS:
        IF (IC .GT. 0) CALL MAPCON(CFOUND,IC,IBMAX,IFMAX)
C
C OBEY ANY SPECIAL CODE AT THE FINISH OF ONE PICTURE:
        CALL PIGLET(WIDPIC,HGTPIC,-888)
        PLOTED=.TRUE.
      ENDIF
      GO TO 1
C
C  FINISH OFF
   20 IF (PLOTED )CALL PIGLET(20.,20.,-999)
      STOP
      END
C
C
C
C
      SUBROUTINE GENPTS(XX,YY,ZZ,FF,NNP,NTERP,VALS)
      DIMENSION XX(*),YY(*),ZZ(*),FF(*),VALS(*)
      LOGICAL BINDIG
C
      DIMENSION PT(3,3),H(3),TVEC(3),XTRAN(3,3)
     &,RVEC(3),RRVEC(3),NPT(3),TESTV(3),HH(3)
      COMMON /PNTGEN/STEP(3,3),VECEND(3,3),BOXOR(3),ALATV(3,4),NPRIM
     &,ZEDVEC(3)
/IOUNIT/
      COMMON /MAXENT/GRID(3,3),NXP(3),XLIM(3,3)
     &,XORIG(3),UOUT (3,3),NDIMEN
C
      IDIMEN=1
      IF (NDIMEN .EQ.2) IDIMEN=3
      CALL GMINV(XLIM,XTRAN,3)
      WRITE (LPT,1005) XTRAN
 1005 format  ('Transformation  ',3F10.5,
     &         '  ME points to   ',3F10.5,
     &         'fractional cryst',3F10.5)
C
      CALL GMZER(PT,3,3)
C TO USE ORIGIN POINT
      CALL GMEQ(PT,H,3,1)
      L=0
    2 DO 6 ILAT=1,NPRIM
      CALL GMADD(H,ALATV(1,ILAT),HH,3,1)
      CALL GMADD (BOXOR,HH,HH,3,1)
      CALL INDFIX(HH,NPT)
C      WRITE (LPT,1002) NPT,(PT(I,1),I=1,3),TESTV
 1002 FORMAT (3I4,3F8.3,2X,3F10.2)
C WE WANT THIS POINT
      CALL GMADD(HH,XORIG,HH,3,1)
      CALL GMPRD(XTRAN,HH,TVEC,3,3,1)
      CALL ORTHO(TVEC,RVEC,1)
      DO 7 IZ=1,IDIMEN
      IF (IZ.EQ.1) THEN
        CALL GMEQ(RVEC,RRVEC,3,1)
      ELSE IF (IZ.EQ.2) THEN
        CALL GMSUB(RVEC,ZEDVEC,RRVEC,3,1)
      ELSE
        CALL GMADD(RVEC,ZEDVEC,RRVEC,3,1)
      ENDIF
      CALL ERRCHK(2,NNP,NTERP,0,
     &'points for the interpolation,(increase NTERP)')
      XX(NNP)=RRVEC(1)
      YY(NNP)=RRVEC(2)
      ZZ(NNP)=RRVEC(3)
      JJ=JPOINT(NPT)
      FF(NNP)=VALS(JJ)
      IF (BINDIG(IOUT,32)) WRITE (LPT,1001)
     &NNP,ILAT,NPT,TVEC,XX(NNP),YY(NNP),ZZ(NNP),FF(NNP),JJ
 1001 FORMAT (I6,4I4,2X,2(3F7.3,2X),F10.3,I8)
    7 CONTINUE
    6 CONTINUE
C  NEW VALUES ARE IN H; RESET PT
      DO 3 J = 1,L
    3 CALL GMEQ(H,PT(1,J),1,3)
    4 DO 1 L = 1,NDIMEN
      CALL GMADD(PT(1,L),STEP(1,L),H,1,3)
      DO 21 J=1,NDIMEN
      TEST = SCALPR(H,VECEND(1,J))
C      WRITE (LPT,1006) L,J,H,(VECEND(I,L),I=1,3),TEST
 1006 FORMAT (2I4,2(3F10.4,2X),F10.4)
      TESTV(J)=TEST
      IF (TEST .GT.1) THEN
        CALL GMADD(H,BOXOR,RVEC,3,1)
        CALL INDFIX(RVEC,NPT)
        IF (BINDIG(IOUT,32)) WRITE (LPT,1007) J,NPT,TESTV(J)
 1007 FORMAT (I4,2X,3I4,F8.4)
        GO TO 1
      ENDIF
   21 CONTINUE
      GO TO 2
    1 CONTINUE
C
C
C  IF HERE HAVE NO MORE VALUES OF H,K,L TO OFFER
  101 WRITE (LPT,1000) NNP
 1000 format (I8,' points for the interpolation')
      RETURN
      END
C
C
C
C
      SUBROUTINE GETMEM(MFILE,VALS,NPOINT)
C
CH Reads the .mem file
      DIMENSION A(3) ,TMAT(3,3) ,VALS(*)
      CHARACTER *10 MFILE,FILNOM
/IOUNIT/
      COMMON /MAXENT/GRID(3,3),NXP(3),xlim(3,3)
     &,xorig(3),UOUT (3,3),NDIMEN
/SCRACH/
C
      NAMFIL='.mem'
      MESSAG='file containing maxent map (default ext .mem)'
      LUNI=NOPFIL(111)
      NDIMEN=3
C Read the .mem file
   20 READ (LUNI,10)
   10 FORMAT(A80)
      MFILE=FILNOM(LUNI)
      READ (LUNI,10) ICARD
      CALL RDNUMS(A,1,3,NDIM,IER)
      IF (IER .NE.0) CALL ERRMES(0,0,'bad data')
      CALL INDFIX(A,NXP)
      IF (NXP(3).EQ.0) NDIMEN=2
      DO 1 I=1,3
      IF (I.EQ.3 .AND. NDIMEN.EQ.2) THEN
        NXP(3)=1
        GRID(3,1)=0
        GRID(3,2)=1.0
        GRID(3,3)=1.0
        CALL VECPRD(UOUT(1,1),UOUT(1,2),UOUT(1,3))
        CALL FCTOR(UOUT(1,3),N)
        DO 2 II=1,2
        CALL VECPRD(UOUT(1,3),UOUT(1,II),TVEC)
        CALL FCTOR(TVEC,N)
        IF (IABS(N).GT.1) THEN
          FAC=1./FLOAT(IABS(N))
          CALL GMSCA(UOUT(1,II),UOUT(1,II),FAC,3,1)
        ENDIF
    2   CONTINUE
      ELSE
        READ (LUNI,12) GRID(I,1),GRID(I,2),(UOUT (J,I),J=1,3)
   12 FORMAT (2F6.3,2X,3F6.3)
        GRID(I,3)=(GRID(I,2)-GRID(I,1))/A(I)
C Calculated points are at the centres of the cells
      GRID(i,1)=GRID(i,1)+0.5*GRID(i,3)
      GRID(i,2)=GRID(i,2)-0.5*GRID(i,3)
      XORIG(I)=0.5
      ENDIF
    1 CONTINUE
      WRITE (LPT,1001) ' AXES OF MAXENT CALCULATION:     ',UOUT
 1001 FORMAT (A29,3F8.3,2(/29X,3F8.3))
      READ (LUNI,13) VMIN,VMAX
   13 FORMAT(E10.3,E12.3)
      NX=NXP(1)
      NXY=NX*NXP(2)
      NXYZ=NXY*NXP(3)
      CALL ERRCHK(1,NXYZ,NPOINT,0,'Too many values to store')
      READ (LUNI,11)(VALS(I),I=1,NXYZ)
   11 format (8E10.3)
C
      WRITE (ITO,14) NXYZ
      WRITE (LPT,14) NXYZ
      WRITE (LPT,15) ((GRID(I,J),J=1,3),I=1,3)
   15 format (' Grid of Maxent calculation: ',3F8.3/2(29X,3F8.3/))
   14 FORMAT (1X,I8,' Values read ')
      CALL CLOFIL(LUNI)
C Matrix to transform grid points to fractional cryst
      DO 3 I=1,3
      CALL GMSCA(UOUT (1,I),TMAT(1,I),GRID(I,3),3,1)
    3 CONTINUE
      CALL GMINV(TMAT,XLIM,3)
      WRITE (LPT,1000) XORIG,XLIM
 1000 FORMAT (' Origin of Maxent Map:',7X,3F8.3/
     &' Matrix for calculated nodes:',3F8.3,2(/29X,3F8.3))
      RETURN
      END
C
C
C
C
      SUBROUTINE GETSEC(Z,VALS)

      PARAMETER (NTERP=10000, NTERP9=8000*9
     &,NRP=26,NRPTS=26*26*26)
C ARRAYS FOR SHGRID
      DIMENSION XX(NTERP),YY(NTERP),ZZ(NTERP),FF(NTERP),LCELL(NRPTS)
     &,LNEXT(NTERP),XYZMIN(3),XYZDEL(3),RSQ(NTERP),A(NTERP9)
C
      DIMENSION ALIM(3,3),VEC(3),DVEC(3,2),VALS(*)
     &,SVEC(3),PVEC(3)
/IOUNIT/
/MAPDA/
C Data for shgrid
      data NQ/17/, NW/32/
C
      CALL GMTRAN(OUTLIM,ALIM,3,3)
      ALIM(3,1)=Z
      ALIM(3,2)=Z
      CALL THEBOX(U,ALIM)
      NUM=0
      CALL GENPTS(XX,YY,ZZ,FF,NUM,NTERP,VALS)
C GET THE SHGRID FUNCTION
      FNR = (FLOAT(NUM)/3.)**(1./3.)
      NR=NINT(FNR)
C COMPUTE PARAMETERS DEFINING THE INTERPOLANT Q.
      CALL QSHEP3 (NUM,XX,YY,ZZ,FF,NQ,NW,NR, LCELL,LNEXT,XYZMIN,
     &     XYZDEL,RMAX,RSQ,A,IER)
C Stop if error
      IF (IER .NE. 0) call errin2(ier,0,'number','in  QSHEP3')
C
C FOR EACH POINT OF THE PLOTTED MAP
      NMPT=0
      CALL GMSCA(U(1,1),SVEC,ALIM(1,1),3,1)
      CALL GMSCA(U(1,1),DVEC(1,1),ALIM(1,3),3,1)
      CALL GMSCA(U(1,2),VEC,ALIM(2,1),3,1)
      CALL GMSCA(U(1,2),DVEC(1,2),ALIM(2,3),3,1)
      CALL GMADD(SVEC,VEC,SVEC,3,1)
      CALL GMSCA(U(1,3),VEC,ALIM(3,1),3,1)
      CALL GMADD(SVEC,VEC,SVEC,3,1)
      DO 2 IY=1,NY
      CALL GMEQ(SVEC,VEC,3,1)
      DO 3 IX=1,NX
      NMPT=NMPT+1
C      CALL GMEQ(VEC,PVEC,3,1)
      CALL ORTHO(VEC,PVEC,1)
      dens(nmpt)=0.
C DO THE INTERPOLATION
      DENS(NMPT) = QS3VAL(PVEC(1),PVEC(2),PVEC(3),NUM,XX,YY,ZZ,FF,
     & NR,LCELL,LNEXT,XYZMIN,XYZDEL,RMAX,RSQ,A)
      if (abs(dens(nmpt)) .lt. 10e-6)
     &WRITE (LPT,1001)
     &NMPT,IX,IY,VEC,PVEC,dens(NMPT)
      dens(NMPT) = DENS(NMPT)*SCALF1
 1001 FORMAT (I6,2I4,3F8.3,2X,3F8.2,f10.5)
      CALL GMADD(VEC,DVEC(1,1),VEC,3,1)
    3 CONTINUE
      CALL GMADD(SVEC,DVEC(1,2),SVEC,3,1)
    2 CONTINUE
      RETURN
      END
C
C
C
C
      function jpoint(npt)
      dimension npt(3)
      COMMON /MAXENT/GRID(3,3),NXP(3),xlim(3,3)
     &,xorig(3),UOUT (3,3),NDIMEN
C
      jp=0
      do 1 i=NDIMEN,1,-1
      jp=jp*nxp(i)
      n = npt(i)
    2 if (n.ge.nxp(i)) then
        n = n-nxp(i)
        go to 2
      endif
    3 if (n.lt.0) then
        n = n+nxp(i)
        go to 3
      endif
      jp=jp+n
    1 continue
      jpoint=jp+1
      return
      end
C
C
C
C
      SUBROUTINE MEFOOT(MFILE)
C
C *** MEFOOTfrom PLTTXT by PJB April 2006 ***
C
CX
CC 5B
CH Plots a block of explanatory text under a plotted Maxent map.
C
CD Plots the block of text which lists all the necessary details for
CD identification of the map.  Does this in what is for the Fourier plotting
CD "character 1 space", space number 5.
C
CO Outputs to graphical device as set up by PIGLET
C
      CHARACTER *1 IXCHR(2)
      CHARACTER *10 MFILE
      CHARACTER *80 LINE
/IOUNIT/
/MAPDA/
/PLODAT/
      DATA IXCHR/'X','Y'/
C
C WE SHOULD BE NOW WORKING IN CHAR 1 SPACE:
      CALL SPCSET(5)
C
C BLACK PEN:
      CALL PIGLET(0.,0.,-1)
C
C COLLECT LENGTH OF LONGEST LINE FOR FRAME SIZE:
      A=0.
C
C LINES OF TEXT:
      IF (NDIM.EQ.2) then
        write (line,1000) (nint(u(i,3)),i=1,3)
 1000   format ('Maximum entropy projection down', 3i5)
      else
        write (line,1001) outlim(1,3),(NINT(u(i,3)),i=1,3)
 1001   format ('Maximum entropy section at',f8.4,' on', 3i5)
      endif
      l = lengt(line)
      CALL KANGA2(CHUNIT,7.5*CHUNIT,TEMP,LINE,l)
      IF (TEMP .GT. A) A=TEMP
C
C LINES DESCRIBING AXES:
      Y=5.3*CHUNIT
      DO 1 J=1,2
      write (line,1002) IXCHR(J),(NINT(u(i,j)),i=1,3),
     &(outlim(i,j),i=1,2)
 1002 format (A1,' parallel to ',3i5,' from',f8.4,' to',f8.4)
      l = lengt(line)
      CALL KANGA2(CHUNIT,Y,TEMP,LINE,l)
      IF (TEMP .GT. A) A=TEMP
    1 Y=Y-CHUNIT*2.
C
C Source of data AND SCALE FACTOR:
      write (line,1003) MFILE,scalF1
 1003 FORMAT ('Data from ',a10,' multiplied by',f10.2)
      l = lengt(line)
      CALL KANGA2(CHUNIT,1.3*CHUNIT,TEMP,LINE,l)
      IF (TEMP .GT. A) A=TEMP
C
C DRAW BOXES TO BE ROUND EXPLANATORY TEXT:
 101  CALL FRAME(0.,0.,A+2.*CHUNIT,9.*CHUNIT)
      CALL KANGA1(0.,3.*CHUNIT,3)
      CALL KANGA1(A+2.*CHUNIT,3.*CHUNIT,2)
      CALL KANGA1(A+2.*CHUNIT,7.*CHUNIT,3)
      CALL KANGA1(0.,7.*CHUNIT,2)
      RETURN
      END
C
C
C
C
      SUBROUTINE NEXZED(IOP,Z)
C
CA On entry iop=0 a for the first call
CA On exit  iop contains bit 1 = print
CA                       bit 2 = plot
C
CP Must be set up by a call of SETFOU, reading the relevant M cards
C
CD    ZPRVAL for printing
CD    ZPLVAL for plotting
C
/CONTUR/
/IOUNIT/
/MAPDA/
/MAPPR/
/SCRACH/
C
C  THEN SWITCH IF NOT STARTING
      IF (IOP .EQ. 0) THEN
C
C 3D - FIND ALL VALUES OF Z IN 2 LISTS:
        IPR=1
        IF (IZPR .EQ. 0) THEN
          ZCPR=99999.
        ELSE
          ZCPR=ZPRVAL(1)
        ENDIF
        IPL=1
        IF (IZPL .EQ. 0) THEN
          ZCPL=99999.
        ELSE
          ZCPL=ZPLVAL(1)
        ENDIF
C
      ELSE
        IOP=0
      ENDIF
C  START HERE AFTER FIRST ENTRY
C
C NEXT VALUE OF Z:
      Z=AMIN1(ZCPL,ZCPR)
      IF (Z.GT.99998.) GO TO 100
      OUTLIM(1,3)=Z
C
C DO WE WANT TO PRINT AT THIS VALUE OF Z?
  10  IF (ABS(ZCPR-Z) .GT. 10.E-5) GO TO 17
      IOP=IOP+1
      IPR=IPR+1
      ZCPR=ZPRVAL(IPR)
      IF (IPR.GT.IZPR) ZCPR=99999.
C
C DO WE WANT TO PLOT AT THIS VALUE OF Z?
  17  IF (ABS(ZCPL-Z) .GT. 10.E-5) GO TO 100
      IOP=IOP+2
      IPL=IPL+1
      ZCPL=ZPLVAL(IPL)
      IF (IPL.GT.IZPL) ZCPL=99999.
C
  100 RETURN
      END
C
C
C
C
      SUBROUTINE THEBOX(U,ALIM)
C
C On entry U defines the axis of the map as real space vectors
C alin gives the limits to be plotted
C On exit alout should contain the expanded limits for interpolation
C    and VLIM the minimum and maximum values of the fractional coordinates
C Apply a fractional increase to ensure points for interpolation
C Extra volume around each corner CellVolume*(1.5)**3)/(numberOfPoints)
C Total fractional increase in voluem= 27/Npts, in length = 3/(Npts**1/3)
C
      dimension u(3,3),alim(3,2),tvec(3),VEC(3),bspan(3,3)
     &,bmin(3)
      CHARACTER *2 PLUR
C
/CELPAR/
/IOUNIT/
      COMMON /PNTGEN/STEP(3,3),VECEND(3,3),BOXOR(3),alatv(3,4),nprim
     &,ZEDVEC(3)
      COMMON /MAXENT/GRID(3,3),NXP(3),XLIM(3,3)
     &,XORIG(3),UOUT (3,3),NDIMEN
      DATA PLUR/'s:'/
C
C
C Ensure U  RH
      NP=JFIX(DETER3(U))
      IF (NP.LT.0) STOP 'LEFT HANDED AXES'
      CALL GMPRD(XLIM,U,STEP,3,3,3)
C Size of border for extrapolation
      IF (NDIMEN.EQ.3) THEN
        CELLVOL= V(1)*FLOAT(NP)
        NPTS=NXP(1)*NXP(2)*NXP(3)
        ADDLEN = 1.5*((CELLVOL/FLOAT(NPTS))**(1./3.))
      ELSE
        PLEN=VCTMOD(1.,U(1,3),2)
        CELAREA= FLOAT(NP)/PLEN
        NPTS=NXP(1)*NXP(2)
        ADDLEN = 1.5*SQRT((CELAREA/FLOAT(NPTS)))
        FRAC3=ADDLEN/(PLEN*V(1))
        CALL GMSCA(U(1,3),TVEC,FRAC3,3,1)
        CALL GMPRD(XLIM,TVEC,BSPAN(1,3),3,3,1)
        CALL ORTHO(TVEC,ZEDVEC,1)
        WRITE (LPT,1006) ZEDVEC
 1006   FORMAT ('Step in z for 2D: ',3F10.4)
      ENDIF
      CALL GMZER(BOXOR,3,1)
C ADD THIS TO LIMITS
      DO 1 I=1,NDIMEN
      ALEN=VCTMOD(1.,U(1,I),1)
      FAC=ADDLEN/ALEN
C Origin moves by -FAC
      BMIN(I)=ALIM(I,1)-FAC
      CALL GMSCA(U(1,I),TVEC,BMIN(I),3,1)
      CALL GMADD(BOXOR,TVEC,BOXOR,3,1)
C Span increases by 2*FAC
      VEC(I)=ALIM(I,2)-ALIM(I,1) + 2*FAC
      CALL GMSCA(U(1,I),TVEC,VEC(I),3,1)
C Convert to calculation steps
      CALL GMPRD(XLIM,TVEC,BSPAN(1,I),3,3,1)
C Normalize steps
      CALL FCTOR(STEP(1,I),N)
    1 CONTINUE
      CALL GMEQ(BOXOR,TVEC,3,1)
      CALL GMPRD(XLIM,TVEC,BOXOR,3,3,1)
      CALL GMSUB(BOXOR,XORIG,BOXOR,1,3)
      J=2
      K=3
      DO 2 I=1,NDIMEN
      BOXOR(I)=ANINT(BOXOR(I))
      CALL VECPRD(BSPAN(1,J),BSPAN(1,K),VECEND(1,I))
      TVEC(I)=SCALPR(BSPAN(1,I),VECEND(1,I))
      WRITE (LPT,1005)I,J,K,(VECEND(II,I),II=1,3),TVEC(I)
 1005 FORMAT (3I4,4F10.4)
      J=K
      K=I
    2 CONTINUE
      WRITE (LPT,1001) BOXOR
C      WRITE (LPT,1002) BSPAN
 1001 format (/'Box Origin: ',3f8.2)
 1002 format  ('bspan    : ',3f8.2,2(/12X,3F8.2))
C      write (lpt,1003) ((vecEND(j,i),j=1,3),tvec(i),i=1,3)
      RAWVOL=SCALPR(BSPAN(1,1),VECEND(1,1))
      SCAL=1./RAWVOL
      CALL GMSCA(VECEND,VECEND,SCAL,3,3)
      WRITE (LPT,1000) STEP
 1003 FORMAT  ('VECEND: ',3F10.2,2X,F10.2,2(/8X,3F10.2,2X,F10.2))
 1000 FORMAT  ('STEP  : ',3F10.5,2(/8X,3F10.5))
      CALL LATVCS(STEP,ALATV,NPRIM)
      IF (NPRIM.EQ.1) PLUR=' :'
      IF (NPRIM.GT.1)
     &WRITE (LPT,1004) NPRIM-1,A2,((ALATV(I,J),I=1,3),J=2,NPRIM)
 1004 FORMAT (I5,' Non-primitive step vector',A2,4(3F5.0,2X)/)
      RETURN
      END
C
C
C
C
C LEVEL 50      PROGRAM NONCRY
      PROGRAM NONCRY
C
C *** NONCRY by JCM ***
C
C ******************************************************************************
C
C                             N O N C R Y
C
C PROGRAM GIVING AN EXAMPLE OF A NON-CRYSTALLOGRAPHIC USE OF CCSL:
C INVERTS 3X3 MATRICES
C
C ******************************************************************************
C
C
C
      DIMENSION ICARD(80),A(3,3),B(3,3)
/IOUNIT/
C
C FIRST INITIALISE CCSL: NOT "CALL PREFIN" BECAUSE THAT WOULD TRY TO
C READ CRYSTAL DATA:
      CALL INITIL('NONCRY')
   1  READ (5,10,END=100) ICARD
  10  FORMAT (80A1)
      CALL RDNUMS(A,ICARD,1,9,NUM,IER)
      IF (NUM .NE. 9) GO TO 99
      IF (IER .NE. 0) GO TO 99
      CALL GMEQ(A,B,3,3)
      CALL TRINV3(B,D)
      WRITE (LPT,11) A
  11  FORMAT (/' Input:'/3(3F10.4/))
      CALL TRANSQ(B,3)
      WRITE (LPT,12) B
  12  FORMAT (/' Inverse:'/3(3F10.4/))
      WRITE (LPT,15) D
  15  FORMAT (/' Determinant:',F10.4)
      DO 2 I=1,3
      DO 2 J=1,3
   2  A(I,J)=D*B(I,J)
      WRITE (LPT,16) A
  16  FORMAT (/' Inverse * determinant:'/3(3F10.4/))
      GO TO 1
C
  99  WRITE (LPT,13) ICARD
  13  FORMAT (/' Bad card:'/1X,80A1)
      GO TO 1
C
 100  STOP
      END
C
C
C
C
C LEVEL 50      PROGRAM PALSQ
      PROGRAM PALSQ
C
C *** PALSQ updated by PJB  C105 April 2001 ***
C ****************************************************************************
C
C                       P A L S Q
C
C ****************************************************************************
C
CC 6D
CH Least squares refinement from neutron polarimetry data
C
CD Main program for least squares refinement, of polarisation analysis data
CD from (possibly) mixed nuclear and magnetic structure factors
CD the magnetic symmetry is allowed to be less than the nuclear symmetry.
C
CI The crystal data file must contain all cards needed for magnetic
CI and nuclear structure factor calculations vis:
CI       S cards giving the symmetry.
CI       A C card with the cell dimensions.
CI       A cards defining the atoms, their positions and isotropic.
CI       temperature factors.
CI       F cards giving the  magnetic and non-magnetic scattering
CI       factors
CI       Q cards defining the magnetic structure
CI optionally:
CI       T cards giving anisotropic temperature factors
CI Additionally:
CI       L cards indicating which parameters should be refined
CI       (see the CCSL users' manual)
CI       I cards which may have the words words NCYC, CYCL1, PRIN, MCOR CONV
CI       and AXES
CI       NCYC the number of least squares cycles (default 3)
CI       CYC1 the number to be assigned to the first cycle (default 1)
CI           PRIN frequency at which output lists are printed
CI               PRIN = 0 no printing
CI               PRIN = 1 first cycle
CI               PRIN = 2 last cycle
CI               PRIN = 3 first and last cycles
CI               PRIN = 4 every cycle
CI           MCOR controls the correlations printed at tyhe end of the job
CI               (default +70)
CI               MCOR = 0 whole correlation matrix printed
CI               MCOR = -ve no printing
CI               MCOR = +ve correlations above MCOR printed
CI           CONV convergence criterion; LSQ cycling is terminated if the
CI               maximum shift/esd < CONV (default 0.01)
CI           AXES = 0 polarisations are given on crytallographic axes
CI           AXES = 1 polarisations are given on "polarisation" axes (default)
CI       A P card giving the incident polarisation
CI       D cards giving the crystal orientation
CI The data file which should be a list of the components of the incident
CI and scattered polarisation with repect to the axes implied by AXES as
CI written by CRYPAD (default extension .pol).
C
CO The usual listing file reporting the data which have been read. This file
CO also contains the output listings requested by the I PRIN card  as well as
CO the R-factors and chisqrd at the end of each least squares cycle.
CO A new crystal data file corresponding to the structure at the end of the
CO least squares refinement.
C
CR On running the program the user is asked for the name of the crystal data
CR file and the name of the file containing the polarisation data.
CR The value of \$\chi^2\$  at the end of each cycle is reported on the
CR terminal.
CR After the last cycle user is asked for a name for the new crystal data file.
C
      CHARACTER*132 VFMT
      CHARACTER*8 TEMP,TITLE*28
      CHARACTER *4 ISFWRD(17)
      LOGICAL PRINT,PRNCYC,NEW,REAPOL,ONCARD,KAXES,DFLTMG,DOMAG2,
     &CLAIMD
      EXTERNAL DFLTMG,LFCALC,LMCALC,DOMAG1,DOMAG2,PARRUN,MAGCNL,VARSMG
     &,VARMAK
%      DIMENSION ALSQ(%MATS%),ISWDSP(3,17),TVEC(12)
      DIMENSION K(3),H(3),HF(3,2),VEC(3),POLC(3),PDIF(3),
     &DPOLM(3)
      EQUIVALENCE (H,HF)
/CARDRC/
/DEPMAT/
/DGEOM/
/IOUNIT/
/NEWOLD/
/NSYM/
/OBSCAL/
/POLDA/
/POLDAT/
/POSNS/
/PRBLEM/
/REFINE/
/SATELL/
/SCRACH/
/SYMMAG/
      DATA ISFWRD/
     & 'SCAL','DOMR','MOSC',
     & 'PSI1','PSI2','PSI3','PSI4',
     & 'THET','PHI','THE1','PHI1','MU','MU1',
     & 'PSIS','ANGS','MUS', 'MPAR'/
      DATA ISWDSP/
     & 1,2,0, 1,1,8, 1,1,9,
     & 2,0,13, 2,0,14, 2,0,15, 2,0,16,
     & 2,0,17, 2,0,18, 2,0,19, 2,0,20, 2,0,21, 2,0,22,
     & -8,0,0, -9,0,0, -10,0,0, -11,0,0/
C BLOCK DATA F2PARS NOW USED
C
      DATA VFMT/'(4X,''h'',3X,''k'',3X,''l'',12X,''P(in)'',20X, ''Pout(o
     &bs)'',16X,''Pout(calc)'',16X,''Pout(diff)'' /10X,4(9X,''x       y
     &      z''))'/
C
C ALTER VALUE HERE IF NECESSARY, WITH DIMENSION OF ALSQ:
%      MATSZ=%MATS%
C
C SET UP STRUCTURE FACTOR CALCULATION:
      CALL PREFIN('PALSQ')
C
C SET "MAGNETIC"
      MAG=.TRUE.
C
C OPEN FILE FROM WHICH TO READ DATA:
      MESSAG='Polarisation data'
      NAMFIL='.POL'
      LUNI=NOPFIL(111)
      CALL SETFCM(DOMAG1)
C  NUMBER OF DOMAINS
      NDOMN=NDOM
C DOUBLE IF GROUP IS CENTRIC AND MAGNETIC STRUCTURE NOT
      IF (CENTRC .AND. NMSYM .GT.0) NDOMN=NDOMN*2
C DOUBLE IF HELICAL
      IF (HELI) NDOMN=NDOMN*2
C DOUBLE IF  180 DEGREE  DOMAINS POSSIBLE
        NDOMN=NDOMN*ND180
C
C  SET ORTHOGONAL SYMMETRY ROTATIONS
      CALL ROTOSM(H,H,1,0)
C
C SPECIFY PROBLEM:
      NFAM=2
      NGENS(1)=2
      NGENS(2)=NATOM
      NSPC(1)=20
      NSPC(2)=22
C
C SPECIES TYPES FOR EACH GENUS OF FAMILY 1:
      LF1SP(1)=9
      LF1SP(2)=-20
C
C WORDS RELEVANT TO THIS PROBLEM FROM DATA INTO COMM0N:
      CALL LSETUP(38,ISWDSP,ISFWRD)
C
C NAMES SET UP SO THAT:
C FAMILY 1 GENUS 1 HAS SPECIES TFAC, DOMR, MOSC
C   '    1    '  2 HAS GENUS NAME SCAL, SPECIES INDICATED TO BE 1,2,3 ETC
C THE SCALES WILL BE USED FOR THE DOMAIN POPULATIONS
C
C FAMILY 2 IS AS USUAL THE PARAMETERS WHICH DEPEND ON THE ATOM.  GENUS NAMES
C ARE THEREFORE THE SAME AS ATOM NAMES, AND SPECIES NAMES ARE:
C X Y Z B11 B22 B33 B23 B13 B12 SCAT SITE ITF,
C THE MAGNETIC MOMENT MU AND ORIENTATION THET, AND PHI
C FOR HELICAL STRUCTURES THERE ARE ALSO MU1, THET1 AND PHI1 WHICH FIX THE
C MINOR AXIS, AND THE PHASE ANGLES PSI GIVING THE RELATIVE PHASES OF
C DIFFERENT SUBLATTICES.
C
      CALL MESS(LPT,3,
     & 'Least Squares Refinement - Scattered Polarisation Program')
C
C READ I AND (MOST) L CARDS:
      CALL STLSSF
      IF (ONCARD('I','AXES',A)) THEN
        KAXES=(NINT(A).EQ.1)
        IF (.NOT. KAXES) THEN
          CALL MESS(LPT,1,'AXES=0: Components of polarisation '//
     &    'on Crystallographic axes')
        ELSE
          CALL MESS(LPT,1,'AXES=1: Components of polarisation '//
     &    'on k-based axes')
        ENDIF
      ELSE
        KAXES=.TRUE.
        CALL MESS(LPT,1,'No I AXES value given. Assuming'//
     &  ' components of polarisation on k-based axes')
      ENDIF
C
C  GET POLARISATION DIRECTION ETC
      CALL SETPOL
      IF (KAXES) THEN
C SET 3RD POLARISATION AXIS PARALLEL TO OMEGA AXIS
        POLIT(1,3)=UM(3)
        POLIT(2,3)=UM(6)
        POLIT(3,3)=UM(9)
      ELSE
        CALL GMUNI(POLIT,3,3)
      ENDIF
C
C SET UP PARAMETERS AS VARIABLES:
      CALL LOGMAG
      CALL PARSSF(DOMAG2)
      CALL DOMAG1(2)
      CALL VARMAK(DFLTMG,PARRUN,VARSMG,DOMAG2)
C
      CALL ERRMES(0,0,'in PALSQ')
C
C
      IF (IPROP.GT.0) THEN
C CHANGE HEADING FOR FLOATING INDICES
        VFMT(1:INDEX(VFMT,'''l''')-1)='(6X,''h'',5X,''k'',5X,'
        I=INDEX(VFMT,'/')
        VFMT(I+1:I+2)='16'
      ENDIF
C
      DONE=.FALSE.
      DO 1 ICYC=NCYC1,LASTCY
      WRITE (ITO,2042) ICYC
2042  FORMAT(' >>> Starting cycle ',I3)
C IS PRINTING OF STRUCTURE FACTOR LIST REQUESTED THIS CYCLE?
      PRINT=PRNCYC(1)
      IF (PRINT) THEN
C
C PRINTING IN MAIN PROGRAM FOR EASE OF ADJUSTMENT BY USER:
        CALL MESS(LPT,2,'Output listing :')
        WRITE (LPT,VFMT)
      ENDIF
C INITIALISE R FACTOR SUMS:
      CALL RFACS(1)
C SET UP POINTERS IN TRIANGULAR MATRIX AND CLEAR OUT LSQ MATRIX AND RHS:
      CALL MATSET(ALSQ,MATSZ)
C
C COUNT USED OBSERVATIONS (THERE IS NOT AT PRESENT ANY WAY OF NOT USING ONE)
      NOBS=0
C
C
    2 IF (REAPOL(HF(1,2),POLM,DPOLM,MTYP,TEMP,TITLE,LUNI)) GO TO 3
C neglect MTYP for now assuming APO
C  IS IT A NEW REFLECTION
      IF (MATCHF(HF).NE.0) THEN
        CALL INDFIX(HF(1,2),K)
        CALL GMEQ(HF(1,2),H,1,3)
        IF (KAXES) THEN
C  GET OTHER TWO POLARISATION AXES
          CALL ORTHO(H,POLIT(1,1),2)
          CALL UNIVEC(POLIT(1,1),STHL)
          CALL VECPRD(POLIT(1,3),POLIT(1,1),POLIT(1,2))
        ENDIF
        NEW=.TRUE.
      ENDIF
C  SCALE INPUT POLARISATION TO ITS REAL VALUE
      CALL GMSCA(POLM,POLM,POLUP,3,1)
      IF (KAXES) THEN
        DO 5 I=1,4,3
        CALL GMEQ(POLM(I),TVEC(I),3,1)
        CALL GMPRD(POLIT,TVEC(I),POLM(I),3,3,1)
    5   CONTINUE
      ENDIF
C
C CALCULATE FUNCTI0N TO MATCH OBSERVED, AND ITS DERIVATIVES:
C DO NEXT BIT OVER ALL THREE DIRECTIONS
      CALL GMEQ(POLM(4),VEC,3,1)
      DO 20 ICOMP=1,3
      OBS=POLM(3+ICOMP)
      DOBS=DPOLM(ICOMP)
      CALL CALPOL(H,(NEW.AND.ICOMP.EQ.1),ICOMP,LFCALC,LMCALC)
C CALPOL FORMS GCALC,  PUTS DG/DV INTO DERIVV FOR ALL VARIABLES, AND SETS UP
C ALL REQUIRED QUANTITIES IN OBSCAL FOR SUBSEQUENT CALLS OF MATREF AND RFACS
C
C MAKE DERIVATIVES WRT BASIC VARIABLES FROM THOSE WRT VARIABLES:
      CALL RELATE
C
C DIFFERENCES AND WEIGHTS:
      DIFF = OBS - GCALC
      CALL WGHTSF
C GETS WEIGHT AND SQRTWT INTO COMM0N
C
C ADD IN TO R FACTORS:
      CALL RFACS(2)
C
C ADD DERIVATIVES IN TO LSQ MATRIX:
      CALL MATTOT(ALSQ,MATSZ)
      NOBS=NOBS+1
      POLC(ICOMP)=GCALC
      PDIF(ICOMP)=DIFF
C
   20 CONTINUE
C
C OUTPUT LISTING IF REQUIRED:
      IF (PRINT) THEN
        IF (KAXES) THEN
C  TRANSFORM BACK TO K-BASED AXES
          CALL GMPRD(POLC,POLIT,TVEC(7),1,3,3)
          CALL GMPRD(PDIF,POLIT,TVEC(10),1,3,3)
        ENDIF
        IF (NEW) THEN
          IF (IPROP.GT.0) THEN
            IF (KAXES) THEN
              WRITE (LPT,2006) H,TVEC
            ELSE
              WRITE (LPT,2006) H,POLM,POLC,PDIF
            ENDIF
          ELSE
            IF (KAXES) THEN
              WRITE (LPT,2004) K,TVEC
            ELSE
              WRITE (LPT,2004) K,POLM,POLC,PDIF
            ENDIF
          ENDIF
          NEW=.FALSE.
 2004     FORMAT (/1X,3I4,1X,6(3F8.3,2X))
 2006     FORMAT (/1X,3F6.2,1X,6(3F8.3,2X))
        ELSE
          IF (IPROP.GT.0) THEN
            IF (KAXES) THEN
               WRITE (LPT,2007) TVEC
            ELSE
              WRITE (LPT,2007) POLM,POLC,PDIF
            ENDIF
          ELSE
            IF (KAXES) THEN
               WRITE (LPT,2007) TVEC
            ELSE
              WRITE (LPT,2005) POLM,POLC,PDIF
            ENDIF
          ENDIF
 2005     FORMAT (14X,6(3F8.3,2X))
 2007     FORMAT (20X,6(3F8.3,2X))
        ENDIF
      ENDIF
C
C MAKE O/P FILE IF REQUESTED
      IF (ICYC .EQ.LASTCY .AND. IPRNT(7) .NE.0) THEN
        IF (NEW) WRITE (LDEP,2010) K
        WRITE (LDEP,2011) (POLM(3+I),I=1,3),POLC
 2010   FORMAT ('*',3I5)
 2011   FORMAT (6F10.4)
      ENDIF
      NEW=.FALSE.
C NEXT OBSERVATION:
      GO TO 2
C
C HERE ON NO MORE OBSERVATIONS - REWIND OBSERVATIONS FILE AND PRINT R FACTORS:
   3  REWIND LUNI
      CALL RFACS(3)
C
C INVERT MATRIX, CALCULATE SHIFTS AND ESD'S; APPLY AND PRINT:
      CALL MATINV(ALSQ,MATSZ)
      CALL MATSHF(ALSQ,MATSZ)
      CALL APSHSF(DOMAG2)
C ON PENULTIMATE CYCLE PRODUCE NEW CRYSTAL DATA FILE:
      IF (DONE) GO TO 39
      DONE=(AMAXSH.LT.CONV .OR. ICYC.EQ.LASTCY-1 .OR. NCYC.EQ.1)
      IF (DONE) CALL NWINSF(DOMAG2)
C RESET SPIN VECTORS IF ABOUT TO DO ANOTHER CYCLE
      IF (ICYC.NE.LASTCY) THEN
        CLAIMD = DOMAG2(0,5)
        IF (HELI) CALL VARMAK(DFLTMG,PARRUN,VARSMG,DOMAG2)
      ENDIF
   1  CONTINUE
C
C PRINT CORRELATION MATRIX:
  39  CALL MATCOR(ALSQ,MATSZ)
      STOP
      END
C
C
C
C
C LEVEL 50      PROGRAM PAXLSQ
      PROGRAM PAXLSQ
C
C *** PAXLSQ (May 91) BY PJB  18-Mar-1997 ***
CC 6D
CH Least squares refinement from neutron polarimetry with special extinction
C ****************************************************************************
C
C                             P A X L S Q
C
C
CD Main program for least squares refinement, of polarisation analysis data
CD from (possibly) mixed nuclear and magnetic structure factors
CD magnetic symmetry allowed to be less than nuclear symmetry.
CD PAXLSQ allows extinction with different coherence for magnetic and nuclear
C
C ****************************************************************************
C
      CHARACTER*132 VFMT
      CHARACTER*8 TEMP,TITLE*28
      CHARACTER *4 ISFWRD(34)
      LOGICAL PRINT,PRNCYC,IEND,NEW,REAPOL,ONCARD,CLAIMD
      LOGICAL DFLTMG,LDUMMY
      EXTERNAL DFLTMG,LFCALC,LQCALC,DOMAG1,DOMAG2,PARRUN,MAGCNL,
     &VARSSF,LDUMMY
%      DIMENSION ALSQ(%MATS%),ISWDSP(3,34)
      DIMENSION K(3),H(3),HF(3,2),POLQ(6),VEC(3),POLC(3),PDIF(3),
     & TVEC(6)
      EQUIVALENCE (H,HF)
/BRAGG/
/CARDRC/
/DEPMAT/
/EXTN/
/EXTRAE/
/FCAL/
/IOUNIT/
/NSYM/
/OBSCAL/
/POLDA/
/POLDAT/
/POSNS/
/PRBLEM/
/QCAL/
/REFINE/
/SATELL/
/SCLDAT/
/SCRACH/
/SYMMAG/
      DATA ISFWRD/'SCAL','TFAC','X','Y','Z',
     & 'B11','B22','B33','B23','B13',
     & 'B12','SCAT','SITE','ITF',
     & 'XYZ','BIJ','XYZT','FAM1',
     & 'FAM2','DMR1','DMR2','DMR3','MOSC','OVLP',
     & 'PSI1','PSI2','PSI3','PSI4',
     & 'THET','PHI','THE1','PHI1','MU','MU1'/
      DATA ISWDSP/1,2,0, 1,1,1, 2,0,1, 2,0,2, 2,0,3,
     & 2,0,4, 2,0,5, 2,0,6, 2,0,7, 2,0,8,
     & 2,0,9, 2,0,10, 2,0,11, 2,0,12,
     & -1,0,0, -2,0,0, -3,0,0, 1,0,0,
     & 2,0,0, 1,1,8, 1,1,9, 1,1,10, 1,1,11, 1,1,12,
     & 2,0,13, 2,0,14, 2,0,15, 2,0,16,
     & 2,0,17, 2,0,18, 2,0,19, 2,0,20, 2,0,21, 2,0,22/
C
      DATA VFMT/'(4X,''h'',3X,''k'',3X,''l'',12X,''P(in)'',20X,
     & ''Pout(obs)'',16X,''Pout(calc)'',16X,''Pout(diff)''
     & /10X,4(9X,''x      y       z''))'/
C
C ALTER VALUE HERE IF NECESSARY, WITH DIMENSION OF ALSQ:
%      MATSZ=%MATS%
C
C SET UP STRUCTURE FACTOR CALCULATION:
      CALL PREFIN('PAXLSQ')
C
C SET "MAGNETIC"
      MAG=.TRUE.
C
C OPEN FILE FROM WHICH TO READ DATA:
      MESSAG='Polarisation data'
      NAMFIL='.POL'
      LUNI=NOPFIL(111)
      CALL SETFCM(DOMAG1)
C  NUMBER OF DOMAINS
      NDOMN=NDOM
C DOUBLE IF GROUP IS CENTRIC AND MAGNETIC STRUCTURE NOT
      IF (CENTRC .AND. NMSYM .GT.0) NDOMN=NDOMN*2
C DOUBLE IF HELICAL
      IF (MTYP.EQ.3) NDOMN=NDOMN*2
C DOUBLE IF  180 DEGREE  DOMAINS POSSIBLE
        NDOMN=NDOMN*ND180
C
C  SET ORTHOGONAL SYMMETRY ROTATIONS
      CALL ROTOSM(H,H,1,0)
C
C SPECIFY PROBLEM:
      NFAM=2
      NGENS(1)=2
      NGENS(2)=NATOM
      NSPC(1)=20
      NSPC(2)=22
C
C SPECIES TYPES FOR EACH GENUS OF FAMILY 1:
      LF1SP(1)=12
      LF1SP(2)=-20
C
C WORDS RELEVANT TO THIS PROBLEM FROM DATA INTO COMM0N:
      CALL LSETUP(33,ISWDSP,ISFWRD)
C
C NAMES SET UP SO THAT:
C FAMILY 1 GENUS 1 HAS SPECIES TFAC, DMR1, DMR2, DMR3, MOSC
C   '    1    '  2 HAS GENUS NAME SCAL, SPECIES INDICATED TO BE 1,2,3 ETC
C THE SCALES WILL BE USED FOR THE DOMAIN POPULATIONS
C
C FAMILY 2 IS AS USUAL THE PARAMETERS WHICH DEPEND ON THE ATOM.  GENUS NAMES
C ARE THEREFORE THE SAME AS ATOM NAMES, AND SPECIES NAMES ARE:
C X Y Z B11 B22 B33 B23 B13 B12 SCAT SITE ITF,
C THE MAGNETIC MOMENT MU AND ORIENTATION THET, AND PHI
C FOR HELICAL STRUCTURES THERE ARE ALSO MU1, THET1 AND PHI1 WHICH FIX THE
C MINOR AXIS, AND THE PHASE ANGLES PSI GIVING THE RELATIVE PHASES OF
C DIFFERENT SUBLATTICES.
C
      CALL CENTRE(LPT,3,'Least Squares Refinement - Scattered'//
     & ' Polarisation Program',80)
C
C READ I AND (MOST) L CARDS:
      CALL STLSSF
      IF (ONCARD('I','AXES',A)) THEN
        MODEQ=NINT(A)
        IF (MODEQ.EQ.0) THEN
          CALL MESS(LPT,1,'AXES=0: components of polarisation '//
     &    'on Crystallographic axes')
        ELSE
          MODEQ=1
          CALL MESS(LPT,1,'AXES=1: components of polarisation '//
     &    'on k-based axes')
        ENDIF
      ELSE
        MODEQ=1
        CALL MESS(LPT,1,'No I AXES value given. Assuming components'//
     & ' of polarisation on k-based axes')
      ENDIF
C
C SET UP EXTINCTION
      CALL EXTINC(1)
C  GET POLARISATION DIRECTION ETC
      CALL SETPOL
      IF (MODEQ.EQ.1) THEN
C SET 3RD POLARISATION AXIS PARALLEL TO OMEGA AXIS
        CALL GMEQ(POLND,POLIT(1,3),3,1)
      ELSE
        CALL GMUNI(POLIT,3,3)
      ENDIF
C
C SET UP PARAMETERS AS VARIABLES:
      CALL PARSSF(MAGCNL)
      CALL DOMAG1(2)
      CALL VARMAK(DFLTMG,PARRUN,VARSSF,DOMAG2)
C
      IF (IERR .NE.0) STOP 'ERRORS IN INPUT'
C
C
      IF (IPROP.GT.0) THEN
C CHANGE HEADING FOR FLOATING INDICES
        VFMT(1:INDEX(VFMT,'''l''')-1)='(6X,''h'',5X,''k'',5X,'
        I=INDEX(VFMT,'/')
        VFMT(I+1:I+2)='16'
      ENDIF
      DO 1 ICYC=NCYC1,LASTCY
      WRITE (ITO,2042) ICYC
2042  FORMAT(' >>> Starting cycle ',I3)
C IS PRINTING OF STRUCTURE FACTOR LIST REQUESTED THIS CYCLE?
      PRINT=PRNCYC(1)
      IF (PRINT) THEN
C
C PRINTING IN MAIN PROGRAM FOR EASE OF ADJUSTMENT BY USER:
        CALL MESS(LPT,2,'Output listing :')
        WRITE (LPT,VFMT)
      ENDIF
C
C INITIALISE R FACTOR SUMS:
      CALL RFACS(1)
C SET UP POINTERS IN TRIANGULAR MATRIX AND CLEAR OUT LSQ MATRIX AND RHS:
      CALL MATSET(ALSQ,MATSZ)
C
C COUNT USED OBSERVATIONS (THERE IS NOT AT PRESENT ANY WAY OF NOT USING ONE)
      NOBS=0
C
C
   2  IF (REAPOL(HF(1,2),POLM,WLGTH,TM,TEMP,TITLE,LUNI)) GO TO 3
C  IS IT A NEW REFLECTION
        IF (MATCHF(HF).NE.0) THEN
        CALL INDFIX(HF(1,2),K)
        CALL GMEQ(HF(1,2),H,1,3)
        IF (MODEQ.EQ.1) THEN
C  GET OTHER TWO POLARISATION AXES
          CALL ORTHO(H,POLIT(1,1),2)
          CALL UNIVEC(POLIT(1,1),STHL)
          STHL=STHL/2.
          CALL VECPRD(POLIT(1,3),POLIT(1,1),POLIT(1,2))
        ENDIF
C  CALCULATE EXTINCTION CONSTANTS
        CALL EXTPAR(H,WLGTH,TM)
        NEW=.TRUE.
      ENDIF
C  SCALE INPUT POLARISATION TO ITS REAL VALUE
      CALL GMSCA(POLM,POLM,P,3,1)
C
C CALCULATE FUNCTI0N TO MATCH OBSERVED, AND ITS DERIVATIVES:
C DO NEXT BIT OVER ALL THREE DIRECTIONS
      CALL GMEQ(POLM(4),VEC,3,1)
C  STANDARD DEVIATION OF POLARISATIONS IS CONSTANT AND ABOUT .02
      DOBS=.02
      DO 20 ICOMP=1,3
      CALL CALPXE(H,(NEW.AND.ICOMP.EQ.1),ICOMP,LFCALC,LQCALC)
      OBS=POLM(3+ICOMP)
C CALPOL FORMS GCALC,  PUTS DG/DV INTO DERIVV FOR ALL VARIABLES, AND SETS UP
C ALL REQUIRED QUANTITIES IN OBSCAL FOR SUBSEQUENT CALLS OF MATREF AND RFACS
C
C MAKE DERIVATIVES WRT BASIC VARIABLES FROM THOSE WRT VARIABLES:
      CALL RELATE
C
C DIFFERENCES AND WEIGHTS:
      DIFF = OBS - GCALC
      CALL WGHTSF
C GETS WEIGHT AND SQRTWT INTO COMM0N
C
C
C ADD IN TO R FACTORS:
      CALL RFACS(2)
C
C ADD DERIVATIVES IN TO LSQ MATRIX:
      CALL MATTOT(ALSQ,MATSZ)
      NOBS=NOBS+1
      POLC(ICOMP)=GCALC
      PDIF(ICOMP)=DIFF
C
   20 CONTINUE
C OUTPUT LISTING IF REQUIRED:
      IF (PRINT) THEN
C  TRANSFORM BACK TO K-BASED AXES
C        CALL GMPRD(POLC,POLIT,TVEC(1),1,3,3)
C        CALL GMPRD(PDIF,POLIT,TVEC(4),1,3,3)
        IF (NEW) THEN
          IF (IPROP.GT.0) THEN
            WRITE (LPT,2006) H,POLM,POLC,PDIF
          ELSE
            WRITE (LPT,2004) K,POLM,POLC,PDIF
            NEW=.FALSE.
          ENDIF
 2004     FORMAT (/1X,3I4,1X,6(3F8.3,2X))
 2006     FORMAT (/1X,3F6.2,1X,6(3F8.3,2X))
        ELSE
          IF (IPROP.GT.0) THEN
            WRITE (LPT,2007) POLM,POLC,PDIF
          ELSE
            WRITE (LPT,2005) POLM,POLC,PDIF
          ENDIF
 2005     FORMAT (14X,6(3F8.3,2X))
 2007     FORMAT (20X,6(3F8.3,2X))
        ENDIF
      ENDIF
C
C MAKE O/P FILE IF REQUESTED
   22 IF (ICYC .EQ.LASTCY .AND. IPRNT(7) .NE.0) THEN
        IF (NEW) WRITE (LDEP,2010) K
        WRITE (LDEP,2011) (POLM(3+I),I=1,3),POLC
 2010   FORMAT ('*',3I5)
 2011   FORMAT (6F10.4)
      ENDIF
      NEW=.FALSE.
C NEXT OBSERVATION:
      GO TO 2
C
C HERE ON NO MORE OBSERVATIONS - REWIND OBSERVATIONS FILE AND PRINT R FACTORS:
   3  REWIND LUNI
      CALL RFACS(3)
C
C INVERT MATRIX, CALCULATE SHIFTS AND ESD'S; APPLY AND PRINT:
      CALL MATINV(ALSQ,MATSZ)
      CALL MATSHF(ALSQ,MATSZ)
      CALL APSHSF(DOMAG2)
C ON PENULTIMATE CYCLE PRODUCE NEW CRYSTAL DATA FILE:
      IF (ICYC .EQ. LASTCY-1 .OR. NCYC .EQ. 1) CALL NWINSF(DOMAG2)
C RESET SPIN VECTORS IF ABOUT TO DO ANOTHER CYCLE
      IF (ICYC.NE.LASTCY) CLAIMD=DOMAG2(0,5)
   1  CONTINUE
C
C PRINT CORRELATION MATRIX:
      CALL MATCOR(ALSQ,MATSZ)
 100  STOP
      END
C
C
C
C
      SUBROUTINE CALPXE(H,NEW,ICOMP,SFCALC,MGCALC)
C
C *** CALPXE from CALPOL PJB May 91 ***
C
CX
CC 7B
CH Calculates scattered polarisations and their derivatives for structures
CH which may have mixed magnetic and nuclear reflections, includes extinction.
C
CA On entry H is the 1x3 array holding h,k,l
CA          NEW is TRUE if this hkl differs from the previous one
CA                   FALSE if it is the same
CA          ICOMP is the component of polarisation required
CA          SFCALC is the name of the routine to get nuclear structure factors
CA                 and their derivatives.  This is usually LFCALC.(here LCCALC)
CA          MGCALC is the name of the routine to get magnetic structure factors
CA                and their derivatives.  This is usually LQCALC.
CP Structure factor data must have been set up in various COMMON blocks
CP by SYMOP RECIP ATOPOS, SETFOR, SETANI
CP LSETUP, PARSSF, VARMAK must have set up the Least Squares.
CP STLSSF must have read the L cards:
C
CD Sets GCALC to the ICOMPth component of the scattered polarisation.
CD Also produces the vector DERIVV (LVARV long) of derivatives of this
CD function wrt each variable in turn.
C
CD The sequence of operations is:
CD      Get STHL= sin theta/lambda, SSQRD= STHL squared.
CD      Clear derivatives to zero.
CD      If NEW calculate the nuclear and magnetic structure factors and
CD      their derivatives.
CD      If ICOMP=1 (ie 1st component for this input polarisation)
CD      calculate the output polarisation, and its differential wrt all
CD      parameters,summing over all domains.
CD      Otherwise just set GCALC to previously calculated component
CD      of polarisation and scale the appropriate component of the
CD      differentials.
CD All the unnormalised polarisations and their differentials are held as
CD length 4 vectors the 4th component holding the corresponding cross-section.
CD On exit in /OBSCAL/ GCALC = calculated function to compare with observed
CD         in /DERVAR/ DERIVV is an array holding all derivatives of GCALC
CD                            wrt all variables.
C
      EXTERNAL SFCALC,MGCALC
      DIMENSION H(3),DPOXDX(4),VEC(4),VEC1(3),POLI(4),RPOLI(4)
     & ,QCROSP(3),PTERM(4,3),DPDOV(4,3),DPOXDN(4,3),DPOXDQ(4,3,3)
%     & ,RPOL(4),DIFFER(4,%VVAR%)
      COMPLEX FND,FN,PHASE,CVEC(4),QSTAR(3),CPRD,CRSCLP,QCROSP,CFAC
     & DPOXDX,PDOTDP,DPOXDX
      LOGICAL TESTOV,NEW
/BRAGG/
/DERVAR/
/EXTN/
/EXTRAE/
/FCAL/
/IOUNIT/
/QCAL/
/OBSCAL/
/OVER/
/PHASE/
/POINTS/
/POLDAT/
/PRBLEM/
/SATELL/
/SCLDAT/
C
      STHL = VCTMOD(0.5,H,2)
C STHL=SIN THETA/LAMBDA;  SSQRD = IT SQUARED
      SSQRD = STHL*STHL
C
C  CALCULATE STRUCTURE FACTORS ON FIRST ENTRY
      IF (NEW) THEN
        CALL SFCALC(H)
        CALL MGCALC(H)
      ENDIF
      IF (ICOMP.EQ.1) THEN
C CLEAR DERIVATIVES WRT VARIABLES - THERE MAY NOT BE AN ENTRY FOR EVERY ONE FOR
C THIS INPUT VALUE OF H:
        IF (LVARV .GT. 0) CALL GMZER(DIFFER,4,LVARV)
C  CLEAR DERIVATIVE SUMS
        CALL CGMZER(DPOXDQ,12,3)
        CALL CGMZER(DPOXDN,4,3)
C  SUM THE POLARISED INTENSITY IN RPOL
        CALL GMZER(RPOL,4,1)
C  SET POLARISATION
        CALL GMEQ(POLM,POLI,3,1)
        POLI(4)=1.
C  LOOP OVER DOMAINS
        NND=0
        DO 22 N180=1,ND180
        DO 20 ND=1,NDOMN/ND180
        NND=NND+1
C  CALCULATION OF POLARISATION DIRECTIONS, SEPARATE INTO NN NQ AND QQ TERMS
C  NP.Q* TERM
        CALL CMCONJ(Q(1,ND),QSTAR,3,1)
        CALL CGMSCA(Q(1,ND),CVEC,CONJG(FC),3,1)
        CALL CMREAL(CVEC,PTERM(1,2),3,1)
        PTERM(4,2)=SCALPR(POLI,PTERM(1,2))
C  QXQ* TERM
        CALL CMREAL(QSTAR,VEC,3,1)
        CALL CMIMAG(QSTAR,VEC1,3,1)
        CALL VECPRD(VEC,VEC1,PTERM(1,3))
        PTERM(4,3)=SCALPR(POLI,PTERM(1,3))
C  N*PXQ PART OF POLARISATION
        CALL CMIMAG(CVEC,VEC,3,1)
        CALL VECPRD(POLI,VEC,VEC1)
        CALL GMADD(PTERM(1,2),VEC1,PTERM(1,2),3,1)
C  Q(P.Q*) PART OF POLARISATION
        CPRD=CRSCLP(QSTAR,POLI)
        CALL CGMSCA(Q(1,ND),CVEC,CPRD,3,1)
        CALL CMREAL(CVEC,VEC,3,1)
        CALL GMADD(PTERM(1,3),VEC,PTERM(1,3),3,1)
C  DOUBLE ALL THIS FOR TWICE REAL AND IMAG PARTS
        DO I=2,3
          CALL GMSCA(PTERM(1,I),PTERM(1,I),2.,4,1)
        ENDDO
C  PART PARALLEL TO INCIDENT POLN
        FNSQR=REAL(FC)*CONJG(FC)
        QMOD=RSCALP(Q(1,ND),Q(1,ND))
        CALL GMSCA(POLI,PTERM(1,1),FNSQR,4,1)
        CALL GMSCA(POLI,VEC,QMOD,3,1)
        PTERM(4,3)=PTERM(4,3)+QMOD
        CALL GMSUB(PTERM(1,3),VEC,PTERM(1,3),3,1)
C  GET THE DIFFERENTIALS WITH RESPECT TO FOVLP
        IPTOV=KFOVLP
        IF (IPTOV.NE.0) THEN
          CALL GMEQ(PTERM(1,2),DPDOV(1,2),4,1)
          CALL GMEQ(PTERM(1,3),DPDOV(1,3),4,1)
          CALL DBITS3(DPDOV(1,1),DPDOV(1,2),DPDOV(1,3),FOVLP)
        ENDIF
C  TRANSFORM THE 3 BITS INTO THE DIFFERENT POLARISED INTENSITIES
        CALL BITS3(PTERM(1,1),PTERM(1,2),PTERM(1,3),FOVLP)
C
C DERIVATIVES WITH RESPECT TO FC AND Q
C THE DIFFERENTIALS OF THE SCATTERED POLARISATION
C  FIRST WITH RESPECT TO NUCLEAR PART
C  AGAIN SEPARATE NN NQ AND QQ BITS
        CALL C1MSCA(POLI,DPOXDN(1,1),CONJG(FC),4,1)
C NPxQ* TERM
        CALL CMREAL(QSTAR,VEC,3,1)
        CALL VECPRD(VEC,POLI,VEC1)
        CALL C1MSCA(VEC1,QCROSP,CMPLX(0.,-1.),3,1)
        CALL CMIMAG(QSTAR,VEC,3,1)
        CALL VECPRD(VEC,POLI,VEC1)
        CALL C1MSCA(VEC1,CVEC,CMPLX(1.,0.),3,1)
        CALL CGMADD(CVEC,QCROSP,QCROSP,3,1)
        CALL CGMEQ(QCROSP,DPOXDN(1,2),3,1)
C NQ TERM
        CALL CGMADD(DPOXDN(1,2),QSTAR,DPOXDN(1,2),3,1)
        DPOXDN(4,2)=CPRD
C THIRD PART IS ZERO
        CALL GMZER(DPOXDN(1,3),4,1)
C TRANSFORM THESE THREE BITS
        CALL CBITS3(DPOXDN(1,1),DPOXDN(1,2),DPOXDN(1,3),FOVLP)
C THEN THE TENSORS FOR THE MAGNETIC DERIVATIVES
        DO 25 J=1,3
        DO 25 I=1,3
C THE FIRST PART IS ZERO
        DPOXDQ(I,J,1)=0.
        DPOXDQ(I,J,3)=QSTAR(I)*POLI(J)-POLI(I)*QSTAR(J)
        IF (I.EQ.J) THEN
          DPOXDQ(I,I,2)=CONJG(FC)
          DPOXDQ(I,I,3)=DPOXDQ(I,I,3)+CPRD
          DPOXDQ(4,I,1)=0
          DPOXDQ(4,I,2)=CONJG(FC)*POLI(I)
          DPOXDQ(4,I,3)=QSTAR(I)+QCROSP(I)
        ELSE
          DO 26 K=1,3
          IF (K.EQ.I .OR. K.EQ.J) GO TO 26
          IF (ABS(J-I).EQ.1) THEN
            SIG=FLOAT(ISIGN(1,J-I))
          ELSE
            SIG=FLOAT(ISIGN(1,I-J))
          ENDIF
          DPOXDQ(I,J,2)=DPOXDQ(I,J,2)+
     &     SIG*CMPLX(0.,1.)*CONJG(FC)*POLI(K)
          DPOXDQ(I,J,3)=DPOXDQ(I,J,3)+SIG*CMPLX(0.,1.)*QSTAR(K)
   26     CONTINUE
        ENDIF
   25   CONTINUE
C AND TRANSFORM THEM IN THREE  SEPARATE CALLS
        DO I=1,3
          CALL CBITS3(DPOXDQ(1,I,1),DPOXDQ(1,I,2),DPOXDQ(1,I,3),FOVLP)
        ENDDO
C  LOOP OVER THREE DIFFERENTLY EXTINGUISHED BITS
C  CALCULATE THREE CROSS-SECTIONS AND EXTINCTION FACTORS
        CALL GMZER(RPOLI,4,1)
        DO 1 IQ=1,3
          IF (PTERM(4,IQ).EQ.0) GO TO 1
          FMEAN=SQRT(PTERM(4,IQ))
          DOMR=DOMRI(IQ)
          CALL EXTINC(3,FMEAN)
          YCOR=EXTCOR*EXTCOR
          CALL GMSCA(PTERM(1,IQ),VEC,YCOR,4,1)
          CALL GMADD(RPOLI,VEC,RPOLI,4,1)
C
C  SUMS FOR DERIVATIVES
C  DERIVATIVES W.R.T. EXTINCTION PARAMETERS
C  DOMRs ARE FIRST
        DEXD=DEXDRQ
        DO IPP=1,2
          IPT=KDOMRI(IQ)
          IF (IPT.NE.0) THEN
            FAC=SCALE(NND)*DEXD*2.*YCOR
            CALL GMSCA(PTERM(1,IQ),VEC,FAC,4,1)
            CALL GMADD(DIFFER(1,IPT),VEC,DIFFER(1,IPT),4,1)
          ENDIF
C  THE LAST IS MOSC
          IP=11
          DEXD=DEXDGQ
        ENDDO
C
C OVERLAP AND FAMILY 2 DERIVATIVES
        FAC=YCOR*DEXDFQ/FMEAN
C CONSTANT FACTORS X 2 TO GET TWICE REAL PART
        FAC1=2.*SCALE(NND)*FAC
        FAC2=2.*SCALE(NND)*YCOR
        DO 4 I=0,NVARF(2,JPHASE,1)
C  FOR OVLP DERIVATIVE
          IF (I.EQ.0) THEN
            IPT=IPTOV
          ELSE
            IPT=LVFST1(2,JPHASE,1)+I
          ENDIF
          IF (IPT.EQ.0) GO TO 4
C WORK OVER BOTH MAGNETIC AND NUCLEAR PARTS
          DO 5 NUCMAG=1,2
          IF (I.EQ.0) THEN
C  FOR OVLP DERIVATIVE
            IF (NUCMAG.NE.1) GO TO 5
C  COMPENSATE FOR USING TWICE IT LATER
            CALL C1MSCA(DPDOV(1,IQ),DPOXDX,CMPLX(0.5,0.),4,1)
C NEXT NUCLEAR DERIVATIVES
          ELSE IF (NUCMAG.EQ.1) THEN
            IF (DERIVT(I).EQ.0) GO TO 5
            CALL CGMSCA(DPOXDN(1,IQ),DPOXDX,DERIVT(I),4,1)
          ELSE
C MAGNETIC DERIVATIVES
            IF (N180.EQ.2) THEN
              CALL CMRSCA(FQCDER(1,ND-NDOMN/2,I),CVEC,-1.,3,1)
            ELSE
              CALL CGMEQ(FQCDER(1,ND,I),CVEC,3,1)
            ENDIF
            DO II=1,3
              IF (REAL(CVEC(II)).NE.0 .OR. AIMAG(CVEC(II)).NE.0)
     &         GO TO 7
            ENDDO
            GO TO 5
    7       CALL CGMPRD(DPOXDQ(1,1,IQ),CVEC,DPOXDX,4,3,1)
          ENDIF
          CALL C1MSCA(PTERM(1,IQ),CVEC,FAC1*DPOXDX(4),4,1)
          CALL CMREAL(CVEC,VEC,4,1)
          CALL GMADD(DIFFER(1,IPT),VEC,DIFFER(1,IPT),4,1)
          CALL CMREAL(DPOXDX,VEC,4,1)
          CALL GMSCA(VEC,VEC,FAC2,4,1)
          CALL GMADD(DIFFER(1,IPT),VEC,DIFFER(1,IPT),4,1)
    5     CONTINUE
    4     CONTINUE
C END OF PARAMETER LOOP
    1     CONTINUE
C END OF EXTINCTION LOOP
C SCALE BY DOMAIN FRACTIONS ADD INTO SUMS FOR MEAN POLARISATION
        CALL GMSCA(RPOLI,VEC,SCALE(NND),4,1)
        CALL GMADD(RPOL,VEC,RPOL,4,1)
C  DERIVATIVES FOR DOMAIN POPULATIONS (SCALE FACTORS)
        IPT=KSCALE(ND)
        IF (IPT .NE.0) THEN
          CALL GMEQ(RPOLI,DIFFER(1,IPT),4,1)
        ENDIF
C REVERSE Q FOR 180 DEGREE DOMAIN
        IF (ND180.EQ.2) THEN
          DO II=1,3
            Q(II,ND)=-Q(II,ND)
          ENDDO
        ENDIF
   20   CONTINUE
   22   CONTINUE
C END OF DOMAIN LOOPS
C        WRITE (LPT,3000) (DIFFER(JC,1),JC=1,4),RPOL
C 3000 FORMAT (' Differentials:',(4F8.4,2X)' Polarisations:',
C     & (4F8.4,2X))
C
C  NORMALISE POLARISATION
        CALL GMSCA(RPOL,RPOL,1./RPOL(4),3,1)
      ENDIF
C  END OF PART DONE ONLY ON READING FIRST COMPONENT
C
C GET DERIVATIVE OF REQUIRED COMPONENT
      DO I=1,LVARV
      DERIVV(I)=(DIFFER(ICOMP,I)-RPOL(ICOMP)*DIFFER(4,I))/RPOL(4)
      DIFFER(ICOMP,I)=DERIVV(I)
      IF (ICOMP.EQ.3 .AND. IOUT.EQ.90) WRITE (LPT,3001)
     &  I,(DIFFER(II,I),II=1,3)
 3001 FORMAT(' Parameter',I3,' Differentials',3F10.4)
      ENDDO
C
      GCALC = RPOL(ICOMP)
 100  RETURN
      END
C
C
C
C
      SUBROUTINE BITS3(P1,P2,P3,W)
C
      DIMENSION P1(4),P2(4),P3(4)
C  GET THE THREE DIFFERENTLY EXTINGUISHED BITS
      CALL GMSCA(P2,VEC,W,4,1)
      CALL GMADD(P1,VEC,P1,4,1)
      CALL GMSCA(P3,VEC,W*W,4,1)
      CALL GMADD(P1,VEC,P1,4,1)
      CALL GMSCA(P3,VEC,W,4,1)
      CALL GMADD(P2,VEC,P2,4,1)
      CALL GMSCA(P2,P2,(1.-W),4,1)
      CALL GMSCA(P3,P3,(1.-W)*(1.-W),4,1)
      RETURN
      END
C
C
C
C
      SUBROUTINE CBITS3(P1,P2,P3,W)
C
C  COMPLEX VERSION
C
      COMPLEX P1(4),P2(4),P3(4)
C  GET THE THREE DIFFERENTLY EXTINGUISHED BITS
      CALL CMRSCA(P2,VEC,W,4,1)
      CALL CGMADD(P1,VEC,P1,4,1)
      CALL CMRSCA(P3,VEC,W*W,4,1)
      CALL CGMADD(P1,VEC,P1,4,1)
      CALL CMRSCA(P3,VEC,W,4,1)
      CALL CGMADD(P2,VEC,P2,4,1)
      CALL CMRSCA(P2,P2,(1.-W),4,1)
      CALL CMRSCA(P3,P3,(1.-W)*(1.-W),4,1)
      RETURN
      END
C
C
C
C
      SUBROUTINE DBITS3(P1,P2,P3,W)
C
      DIMENSION P1(4),P2(4),P3(4)
C  GET THE DIFFERENTIALS OF THE THREE DIFFERENTLY EXTINGUISHED BITS
C  WITH RESPECT TO W
      CALL GMEQ(P2,P1,4,1)
      CALL GMSCA(P3,VEC,2.*W,4,1)
      CALL GMADD(P1,VEC,P1,4,1)
      CALL GMREV(P2,P2,4,1)
      CALL GMSCA(P3,VEC,(1.-2*W),4,1)
      CALL GMADD(P2,VEC,P2,4,1)
      CALL GMSCA(P3,P3,2.*(W-1.),4,1)
      RETURN
      END
C
C
C
C
      SUBROUTINE EXTPAR(H,WLGTH,TM)
C
C *** EXTPAR NEW BY PJB MAY 91 ***
C
CC 2B
CH Calculates the theta dependent extinction parameters for reflection H
CH On entry WLGTH holds the wavelength and TM the mean pathlength
C
CP RECIP for VCTMOD
C
      DIMENSION ANG(4),KK(3),W1(5),W2(5),ABSC(3)
/CARDRC/
/CELPAR/
/EXTN/
/IOUNIT/
C
C  THETA DEPENDENT PART OF EXTINCTION CONSTANTS
      VEC=VCTMOD(0.5,H,2)
      ALAM3=WLGTH**3
      SINTH = WLGTH*VEC
      CALL SINCOS(SINTH,COSTH,'EXTCAL')
      SINTH = 2.*SINTH*COSTH
      COSTH = (2.*COSTH*COSTH) - 1.
      CON1 = 1000*ALAM3/(SINTH*V(1)**2)
      CEXT(2) = WLGTH/SINTH
      IF (LOREN) THEN
C EXTINCTION FOR LORENTZIAN DISTRIBUTION
        CEXT(3) = .025 + .285*COSTH
        IF (COSTH.GT.0) THEN
          CEXT(4) = 0.15 - 0.2*(0.75-COSTH)**2
        ELSE
          CEXT(4)= -0.45*COSTH
        ENDIF
      ELSE IF (GAUSS) THEN
C GAUSSIAN DISTRIBUTION
        CEXT(3) = 0.58+0.48*COSTH+0.24*(COSTH**2)
        CEXT(4) = 0.02-0.025*COSTH
      ENDIF
C
C  ASSUME DIMENSIONS FOR G CARDS ARE mm
      CEXT(1)=CON1*TM
      RETURN
      END
C
C
C
C
C LEVEL 50      PROGRAM PLOTFM
      PROGRAM PLOTFM
C
C *** PLOTFM corrected by PJB  12-March 1996 ***
C
C ******************************************************************************
C
C                              P L O T F M
C
C PROGRAM TO PLOT GRAPHS - AS BROUGHT IN RAW CONDITION FROM ILL
C
C ******************************************************************************
C
C
      CHARACTER*15 LABEL(2)
      LOGICAL START
      DIMENSION K(3),H(3),F(3),AMAG(2),JP(2)
/IOUNIT/
/PLOTCH/
/PLTS/
C
      DATA LABEL,SSINC/'Sin#t/#l','Form Factor',0.005/
      DATA JP/1,2/
C
      AMAG(1)=2.168
      AMAG(2)=0.8960
      CALL PREFIN('PLOTFM')
      CALL SYMOP
      CALL SETFOR
C
      LUNI=NOPFIL(1)
C
C  SET SIZE OF GRAPH
      CALL ASK('Give lengths of x and y axes in cms (2F)')
      CALL RDNUMS(X(1,2),1,2,NUM,IER)
      DO 3 I=1,2
    3 NTEX(I)=LABEL(I)
      CALL GETSCL(-0.10,1.0,2)
      CALL GETSCL(0.,0.6,1)
      CALL ASK('Increase character size, give value in mms or 0')
      CALL RDREAL(ER,1,IPT,80,IER)
      ER=ER/10.
      CALL PLOTO(A,B,ER,0)
C
C READ TABLE OF VALUES WITH STANDARD DEVIATIONS:
    1 READ (LUNI,1002,END=2) AK,FF,ER
1002  FORMAT (3F10.4)
C
      CALL PLOTO(AK,FF,ER,1)
      GO TO 1
C
C END OF INPUT:
    2 CALL PLOTO(0.,1.,0.,-3)
      CALL PLOTO(0.,1.,0.,-2)
      DO 9 I=1,60
      AK = .01*I
C real put in to satisfy compilers C60
      Y=REAL(FORMFA(AK,1))
      CALL PLOTO(AK,Y,0.,-1)
    9 CONTINUE
      CALL PLOTO(AK,Y,0.,-3)
      CALL PIGLET(A,B,-999)
      STOP
      END
C
C
C
C
C LEVEL 50      PROGRAM PLTCHR
       PROGRAM PLTCHR
C
C *** PLTCHR by JCM ***
C
C ******************************************************************************
C
C                              P L T C H R
C
C ******************************************************************************
C
C PROGRAM TO TAKE AS DATA THE LIST (ORIGINALLY COMPUTER LAB SUPPLIED)
C OF INSTRUCTIONS TO DRAW CHARACTERS ON THE PLOTTER, AND TURN THEN INTO
C NUMBERS FOR THE DATA STATEMENT IN KANGA2.
C
C IT NEEDS UPGRADING SO THAT WHAT COMES OUT IS EXACTLY THE DATA STATEMENT.
C
C THE DATA ARE IN 3084 FILE .DATA(PLOTCHAR)
C
      CHARACTER *1 IWD(10)
C  **** ALL THIS WANTS PUTTING INTO F77  ***
      CHARACTER *1 IALCHR,ITAG,ICHAR,IWITH,IEND
      DIMENSION LINES(1000),ITBLCH(85)
      DIMENSION ITAG(3),ICHAR(4),IWITH(4),IEND(3)
      DIMENSION IALCHR(84)
/CHARS/
/IOUNIT/
/SCRACH/
      EQUIVALENCE (IALCHR(1),LETUP(1))
      DATA ITAG,ICHAR,IWITH,IEND/'t','a','g','c','h','a','r','w',
     & 'i','t','h','e','n','d'/
C
      CALL PREFIN('PLTCHR')
      K=0
      N=0
   1  N=N+1
  31  READ(5,100,END=30) ICARD
 100  FORMAT (A80)
      IPT=1
      CALL RDWORD(IWD,LEN,IPT,IPT,3,0,IER)
      IF (IWD(1).NE.ITAG(1).OR.IWD(2).NE.ITAG(2).OR.IWD(3).NE.ITAG(3))
     & GO TO 31
      CALL RDINTG(J,IPT,IPT,80,IER)
      IF (J .EQ. N) GO TO 2
      WRITE (LPT,20) J,N
  20  FORMAT (' SEQUENCE WRONG - J,N=',2I4)
      STOP
C
   2  CALL RDWORD(IWD,LEN,IPT,IPT,11,0,IER)
      IF (IWD(1).EQ.IWITH(1).AND.IWD(2).EQ.IWITH(2).AND.IWD(3).EQ.
     & IWITH(3).AND.IWD(4).EQ.IWITH(4)) GO TO 3
      WRITE (LPT,21) (IWD(I),I=1,4),N
  21  FORMAT (' NOT with ',4A1,' CARD',I4)
      STOP
C
   3  CALL RDWORD(IWD,LEN,IPT,IPT,80,0,IER)
      IF (LEN .EQ. 1 .AND. N .EQ. 53) GO TO 34
      DO 4 I=1,84
      IF (IWD(2) .EQ. IALCHR(I)) GO TO 5
   4  CONTINUE
   6  WRITE (LPT,22) IWD(2),N
  22  FORMAT (' LETTER TAG WRONG - ',A1,' CARD',I4)
      STOP
C
   5  IF (I .NE. N) GO TO 6
  34  READ (5,100) ICARD
      IPT=1
      CALL RDWORD (IWD,LEN,IPT,IPT,4,0,IER)
      IF (IWD(1).EQ.ICHAR(1).AND.IWD(2).EQ.ICHAR(2).AND.IWD(3).EQ.
     & ICHAR(3).AND.IWD(4).EQ.ICHAR(4)) GO TO 36
      WRITE (LPT,23) (IWD(I),I=1,4),N
  23  FORMAT (' NOT char - ',4A1,' CARD',I4)
      STOP
C
  36  CALL RDINTG(J,IPT,IPT,80,IER)
      IF (J .EQ. N) GO TO 7
      WRITE (LPT,24) J,N
  24  FORMAT (' SERIAL ON char CARD WRONG - J,N=',2I4)
      STOP
C
   7  CALL RDWORD(IWD,LEN,IPT,IPT,9,0,IER)
      IF (IWD(1) .EQ. ISMBOL(21)) GO TO 8
      WRITE (LPT,25) N
  25  FORMAT (' NO < - CARD',I4)
      STOP
C
   8  CALL RDWORD(IWD,LEN,IPT,IPT,13,0,IER)
      IF (IWD(1).EQ.IEND(1).AND.IWD(2).EQ.IEND(2).AND.IWD(3).EQ.
     & IEND(3)) GO TO 9
      WRITE (LPT,26) (IWD(I),I=1,3),N
  26  FORMAT (' NO end - CARD',I4)
      STOP
C
   9  CALL RDINTG(NLEN,IPT,IPT,80,IER)
      K=K+1
      IF (K .GT. 1000) GO TO 33
      LINES(K)=NLEN
      ITBLCH(N)=K
      CALL RDINTG(NTEMP,IPT,IPT,80,IER)
      CALL RDWORD(IWD,LEN,IPT,IPT,80,0,IER)
      CALL RDINTG(NTEMP,IPT,IPT,80,IER)
      CALL RDINTG(NTEMP,IPT,IPT,80,IER)
C
      ISIG=1
  10  CALL RDWORD(IWD,LEN,IPT,IPT,80,0,IER)
      IF (IER .NE. 100) GO TO 32
      READ (5,100) ICARD
      IPT=1
      GO TO 10
  32  IF (LEN .EQ. 1 .AND. IWD(1) .EQ. ISMBOL(20)) GO TO 1
      IF (IWD(2) .EQ. IALCHR(46)) GO TO 11
  12  WRITE (LPT,27) (IWD(I),I=1,2),N
  27  FORMAT (' NOT mt or dt ',2A1,' - CARD',I4)
      STOP
  11  IF (IWD(1) .NE. IALCHR(30)) GO TO 13
      ISIG=-1
      GO TO 14
  13  IF (IWD(1) .NE. IALCHR(39)) GO TO 12
      ISIG=1
  14  CALL RDINTG(N1,IPT,IPT,80,IER)
      IF (IER .NE. 100) GO TO 15
      READ (5,100) ICARD
      IPT=1
      GO TO 14
  15  CALL RDINTG(N2,IPT,IPT,80,IER)
      IF (K .LT. 1000) GO TO 16
  33  WRITE (LPT,29)
  29  FORMAT (' LINES FULL')
      STOP
C
  16  K=K+1
      LINES(K)=ISIG*(N1*32+N2+8)
      GO TO 10
C
  30  ITBLCH(N)=K+1
      WRITE (LPT,200) ITBLCH
 200  FORMAT (' ',13(I4,',')/)
      WRITE (LPT,201) (LINES(I),I=1,K)
 201  FORMAT (100(' ',10(I4,',')/))
      STOP
      END
C
C
C
C
C LEVEL 50      PROGRAM POLSQ
      PROGRAM POLSQ
C
C *** POLSQ updated by JCM  18-Mar-1997 ***
C
C
CC 6D
CH Least squares from flipping ratios allowing polarisation refinement
C
CD Program for least squares refinement of flipping ratios for mixed nuclear
CD and magnetic reflections with extinction corrections.
CD The magnetic symmetry is allowed to be less than nuclear symmetry.
CD The depolarisations for one or more data sets are refined as the scale
CD factor parameters.
c
C ****************************************************************************
C
C                        P O L S Q
C
C
C MAIN PROGRAM FOR LEAST SQUARES REFINEMENT OF FLIPPING RATIOS FOR
C MIXED NUCLEAR AND MAGNETIC REFLECTIONS WITH EXTINCTION CORRECTIONS
C    MAGNETIC SYMMETRY ALLOWED TO BE LESS THAN NUCLEAR SYMMETRY.
C           DEPOLARISATION REFINED IN PLACE OF SCALE
C
C ****************************************************************************
C
      COMPLEX FMC(3)
      CHARACTER *44 HEAD1,HEAD2
      CHARACTER *4 IPOWRD(3)
      LOGICAL PRINT,PRNCYC,IEND,ONCARD,FOUND,DFLTMG,TESTOV
      EXTERNAL DFLTMG,LFCALC,LMCALC,DOMAG1,DOMAG2,PARRUN,VARSMG,
     &MAGCNL,F2PARS
%      DIMENSION ALSQ(%MATS%),IPWDSP(3,3)
      DIMENSION K(3),H(3)
/CARDRC/
/DGEOM/
/EXTN/
/FCAL/
/IOUNIT/
/MCAL/
/NEWOLD/
/NSYM/
/OBSCAL/
/POLDA/
/POSNS/
/PRBLEM/
/QCAL/
/REFINE/
/RSTATS/
/SCLDAT/
/SYMMAG/
/SCRACH/
      DATA IPOWRD/'POLN','DOMR','MOSC'/
      DATA IPWDSP/1,2,0, 1,1,8, 1,1,9/
      DATA HEAD1/'     R(obs)   R(calc)     Diff   Wgt Diff   '/
      DATA HEAD2/'F(nuc)   F(mag)    mod Fc    Poln.    Weight'/
C
C ALTER VALUE HERE IF NECESSARY, WITH DIMENSION OF ALSQ:
%      MATSZ=%MATS%
C
C SET UP STRUCTURE FACTOR CALCULATION:
      CALL PREFIN('POLSQ')
      LUNI=NOPFIL(1)
      CALL SETFCM(DOMAG1)
C
C SPECIFY PROBLEM:
      NFAM=2
      NGENS(1)=2
      NGENS(2)=NATOM
      NSPC(1)=20
      NSPC(2)=22
C
C SPECIES TYPES FOR EACH GENUS OF FAMILY 1:
      LF1SP(1)=9
      LF1SP(2)=-20
C
C WORDS RELEVANT TO THIS PROBLEM FROM DATA INTO COMM0N:
      CALL LSETSF(3,IPWDSP,IPOWRD)
C
C NAMES SET UP SO THAT:
C FAMILY 1 GENUS 1 HAS SPECIES TFAC, DOMR, MOSC
C   '    1    '  2 HAS GENUS NAME POLN, SPECIES INDICATED TO BE 1,2,3 ETC
C
C FAMILY 2 IS AS USUAL THE PARAMETERS WHICH DEPEND ON THE ATOM.  GENUS NAMES
C ARE THEREFORE THE SAME AS ATOM NAMES, AND SPECIES NAMES ARE:
C X Y Z B11 B22 B33 B23 B13 B12 SCAT SITE ITF,
C THE MAGNETIC MOMENT MU AND ORIENTATION ANG1, ANG2
C
C
C READ I AND (MOST) L CARDS:
      CALL STLSSF
C
C  GET POLARISATION DIRECTION ETC
      CALL SETPOL
      CALL EXTINC(1)
C  SET MONO-DOMAIN
      MTYP=2
      CALL DOMAIN(POLND)
C
C SET UP PARAMETERS AS VARIABLES:
      CALL PARSSF(MAGCNL)
      CALL DOMAG1(2)
      CALL VARMAK(DFLTMG,PARRUN,VARSSF,DOMAG2)
C
      CALL ERRMES(0,0,'in POLSQ')
C
      DONE=.FALSE.
      DO 1 ICYC=NCYC1,LASTCY
      IF (ICYC.EQ.LASTCY) THEN
      IF (.NOT. TESTOV(RNUM,RDEN)) WRITE (ITO,5002) 100.*RNUM/RDEN
5002  FORMAT (' Final R factor : ',F8.2)
C IS AN OUTPUT FILE TO BE MADE?
        LUNOPF=0
        FOUND =ONCARD('I','OPFL',A)
          IF (FOUND .AND. A .NE.0.) THEN
          MESSAG='output file (return for none)'
          NAMFIL='.FMC'
          LUNOPF=NOPFIL(112)
        ENDIF
      ENDIF
C IS PRINTING OF STRUCTURE FACTOR LIST REQUESTED THIS CYCLE?
      PRINT=PRNCYC(1)
      IF (PRINT) THEN
C
C PRINTING IN MAIN PROGRAM FOR EASE OF ADJUSTMENT BY USER:
        CALL MESS(LPT,2,'Structure factor listing :')
        IF (MODER .GE. 7) THEN
          CALL MESS(LPT,0,'     h       k       l '//HEAD1//HEAD2)
        ELSE
          CALL MESS(LPT,0,'    h    k    l'//HEAD1//HEAD2)
        ENDIF
      ENDIF
C
C INITIALISE R FACTOR SUMS:
      CALL RFACS(1,2)
C SET UP POINTERS IN TRIANGULAR MATRIX AND CLEAR OUT LSQ MATRIX AND RHS:
      CALL MATSET(ALSQ,MATSZ)
C
C COUNT USED OBSERVATIONS (THERE IS NOT AT PRESENT ANY WAY OF NOT USING ONE)
      NOBS=0
C
C BRANCH ON REFLECTION DATA FORMAT:
   2  IF (MODER .EQ. 0) THEN
C USER'S OWN INPUT R0UTINE TO BE SUPPLIED:
        CALL QLSQIN(K,IEND)
        IF (IEND) GO TO 3
        GO TO 20
      ENDIF
C
      GO TO (10,10,13,10,15,10,17,18), MODER
C  THE ALLOWED OPTIONS FOR MODER IN POLSQ ARE JUST:
C   3.   H,K,L,OBS,STANDARD DEVIATION OF OBS, (POLN GROUP),(CODE)
C   5.   H,K,L,OBS,STD DEVN,C1 C2 C3 C4, WHERE C1-C4 ARE THE
C        CONSTANTS INVOLVED IN EXTINCTION CORRECTIONS
C   7.   H,K,L (FLOATING) OBS,STD DEVN,(POLN GROUP), (CODE)
C   8.   H,K,L(FLOATING),OBS,STD DEVN,C1 C2 C3 C4, WHERE C1-C4
C        ARE THE CONSTANTS INVOLVED IN THE EXTINCTION CORRECTION
C WHERE BOTH THE POLN GROUP AND CODE ARE OPTIONAL.  IF THE POLN GROUP IS
C READ AS ZERO, IT WILL BE SET = 1.
C   THE CODE IS NOT AT PRESENT USED; IT IS ENVISAGED THAT IT MAY BE USEFUL
C IN REJECTING SELECTED OBSERVATIONS LATER.
C
  10  STOP 'ERROR IN MODER'
C
  13  READ (LUNI,1001,END=3) K,OBS,DOBS,ISCALE,ICODE
1001  FORMAT (3I5,2F10.4,2I5)
      CALL INDFLO(H,K)
      GO TO 20
C
C THESE ARE FOR EXT CORR:
  15  READ (LUNI,1002,END=3) K,OBS,DOBS,CEXT,ISCALE
1002  FORMAT (3I5,6F10.4,I5)
      CALL INDFLO(H,K)
      ICODE=0
      GO TO 20
C
  17  READ (LUNI,1003,END=3) H,OBS,DOBS,ISCALE,ICODE
 1003 FORMAT (3F8.4,2F10.4,2I5)
      GO TO 20
C
C THESE ARE FOR EXT CORR:
  18  READ (LUNI,1004,END=3) H,OBS,DOBS,CEXT,ISCALE
1004  FORMAT (3F8.4,6F10.4,I5)
      ICODE=0
      GO TO 20
C
C PUT ISCALE WITHIN PERMITTED RANGE:
  20  IF ((ISCALE .EQ. 0) .OR. (ISCALE .GT. NSCALE)) ISCALE=1
C
C CALCULATE FUNCTI0N TO MATCH OBSERVED, AND ITS DERIVATIVES:
      CALL CALCFR(H,LFCALC,LMCALC)
C CALCFR FORMS GCALC( THE FLIPPING RATIO),
C PUTS DG/DV INTO DERIVV FOR ALL VARIABLES, AND SETS UP
C ALL REQUIRED QUANTITIES IN OBSCAL FOR SUBSEQUENT CALLS OF MATREF AND RFACS
C
C MAKE DERIVATIVES WRT BASIC VARIABLES FROM THOSE WRT VARIABLES:
      CALL RELATE
C
C DIFFERENCES AND WEIGHTS:
      DIFF = OBS - GCALC
      CALL WGHTSF
C GETS WEIGHT AND SQRTWT INTO COMM0N
C
C STRUCTURE FACTOR LISTING IF REQUIRED:
      IF (PRINT) THEN
        IF (MODER .GE.7) THEN
          WRITE (LPT,2004) H,OBS,GCALC,DIFF,WDIFF,FCMOD,FMCMOD,YCALC,
     &    SCALE(ISCALE),WT
2004      FORMAT (' ',3F8.4,4F10.4,3F10.4,F10.4,G12.4)
        ELSE
          WRITE (LPT,2005) K,OBS,GCALC,DIFF,WDIFF,FCMOD,FMCMOD,YCALC,
     &    SCALE(ISCALE),WT
2005      FORMAT (' ',3I5,4F10.4,2F10.4,2F10.4,G12.4)
        ENDIF
      ENDIF
C
C MAKE O/P FILE IF REQUESTED
      IF (ICYC .EQ. LASTCY .AND. LUNOPF.NE.0) THEN
        SOBS=OBS
        SDOBS=DOBS
*** MAKE FMC NOW
        CALL CGMEQ(Q(1,1),FMC,1,3)
        IF (MODER .GE.7) THEN
          WRITE (LUNOPF,2011) H,FMC,SOBS,SDOBS
 2011     FORMAT (3F8.4,8F10.4)
        ELSE
          WRITE (LUNOPF,2010) K,FMC,SOBS,SDOBS
 2010     FORMAT (3I5,8F10.4)
        ENDIF
      ENDIF
C
C ADD IN TO R FACTORS:
      CALL RFACS(2,2)
C
C ADD DERIVATIVES IN TO LSQ MATRIX:
      CALL MATTOT(ALSQ,MATSZ)
      NOBS=NOBS+1
C
C NEXT OBSERVATION:
      GO TO 2
C
C HERE ON NO MORE OBSERVATIONS - REWIND OBSERVATIONS FILE AND PRINT R FACTORS:
   3  REWIND LUNI
      CALL RFACS(3,2)
C
C INVERT MATRIX, CALCULATE SHIFTS AND ESD'S; APPLY AND PRINT:
      CALL MATINV(ALSQ,MATSZ)
      CALL MATSHF(ALSQ,MATSZ)
      CALL APSHSF(DOMAG2)
C ON PENULTIMATE CYCLE PRODUCE NEW CRYSTAL DATA FILE:
      IF (DONE) GO TO 39
      DONE=(AMAXSH.LT.CONV .OR. ICYC.EQ.LASTCY-1 .OR. NCYC.EQ.1)
      IF (DONE) CALL NWINSF(DOMAG2)
   1  CONTINUE
C
C PRINT CORRELATION MATRIX:
  39  CALL MATCOR(ALSQ,MATSZ)
 100  STOP
      END
C
C
C
C
      SUBROUTINE DOMAIN(HA)
C
C *** DOMAIN new by PJB April 1992 ***
C
CH To determine the number of domains and give starting populations
CA HA is a vector in the applied field direction (orthogonal axes)
C
      DIMENSION SV(3),SUMVEC(3),HR(3),HA(3),HAC(3),HO(3)
      COMMON /DMAINS/DOMPOP(48)
/MAGDAT/
/NSYM/
/POSNS/
/SYMMAG/
C
      IF (FERO .OR. FERA) THEN
        NDOM=NOP
      ELSE
        NDOM=1
        DO 1 N=2,NOPC
        IF (ABS(MSTAB(N)).EQ.N) NDOM=NDOM+1
    1   CONTINUE
      ENDIF
      IF (FERA) THEN
C FIND THE RESULTANT MOMENT DIRECTION
        CALL GMZER(SUMVEC,3,1)
        DO 2 IA=1,NATOM
        M=MAGAT(IA)
        IF (M.EQ.0) GO TO 2
        CALL SPHPOL(ANGM(1,M),ANGM(2,M),SPIND(1,1,1,M),1)
        CALL GMEQ(SPIND(1,1,1,M),SV,3,1)
        FAC=SMOD(1,M)*AMULT(IA)
        CALL GMSCA(SV,SV,FAC,3,1)
        CALL GMADD(SV,SUMVEC,SUMVEC,3,1)
    2   CONTINUE
        SUM=0.
        TMAX=0.
        CALL ORTHO(HA,HAC,-2)
        DO 3 N=1,NOPC
        CALL ROTSYM(HAC,HR,N,2)
        CALL ORTHO(HR,HO,2)
        TEST=SCALPR(HO,SUMVEC)
        DOMPOP(N)=TEST*TEST
        IF (DOMPOP(N).GT.TMAX) THEN
          TMAX=DOMPOP(N)
          IT=N
        ENDIF
        SUM=SUM+DOMPOP(N)
    3   CONTINUE
         CALL GMZER(DOMPOP,NDOM,1)
         DOMPOP(IT)=1.
C        DO 4 N=1,NOPC
C        DOMPOP(N)=DOMPOP(N)*FLOAT(NOPC)/SUM
C    4   CONTINUE
      ELSE
        DO 5 N=1,NDOM
        DOMPOP(N)=1.
    5   CONTINUE
      ENDIF
      RETURN
      END
C
C
C
C
C LEVEL 50      PROGRAM POWDER
      PROGRAM POWDER
C
C *** POWDER by PJB Nov 1995 ***
C
C ****************************************************************************
C
C                             P O W D E R
C
C                     TO GENERATE POWDER DIAGRAMS
C
C ****************************************************************************
C
CC 2D
CH To calculate the positions and intensities of the lines in a powder
CH diagram
C
CD POWDER reads a crystal data file and, using a wavelength given
CD interactively, calculates the angles 2\$\theta\$, at which reflections will
CD occur. For each reflection the square of the structure factor, the
CD multiplicity, the factor relating Fsq to intensity, and the intensity
CD of the corresponding powder line are tabulated.
C
CI The crystal data file must contain:
CI               S card(s) giving the space group symmetry (note that a
CI               single card saying "S GRUP n" card should suffice n
CI               is the space group number)
CI               A C card with the cell dimensions
CI               A cards with the atomic positions
CI               F cards with the form factors or scattering lengths
C
CO A listing file: powder.lis which reports how the crystal data file
CO was interpreted and gives the results of the calculation. The results
CO columns are headed:
CO       h k l:     for the reflection indices
CO       2theta:    for the scattering angle
CO       Fsqrd:     for the square of the structure factor
CO       Mult:      for the multiplicity of the powder line
CO       Factor:    gives the factor by which the intensity should be
CO                  multiplied to get Fsqrd. (\$\sin\theta\sin2\theta/m\$)
CO       Intensity: The expected intensity of the powder line
CO The format of the results file, if one is requested
CO is (3I5,F10.4,2f10.2) and contains hkl, 2\$\theta\$, Intensity, Factor,
CO for each reflection.
C
CR On running the program the user is asked for the name of the crystal data
CR data file, the wavelength, the maximum and optionally the
CR minimum 2\$\theta\$ for which results are required; also whether the
CR results should be written to a file, if so the name of the file is requested.
C
%      DIMENSION H(3,%NSFS%),IS(%NSFS%),MULT(%NSFS%),M(%NSFS%)
      DIMENSION VAL(5),K(3)
      COMPLEX FCALC,FC
      LOGICAL ENDREF,OUTPUT,LAYER,SAYS,LATABS
      CHARACTER*150 VFMT
/BRAGG/
/IOUNIT/
/SCRACH/
      DATA VFMT/'(6X,''h'',7X,''k'',7X,''l'',5X,''  h   k   l      '',
     &''2Theta      FNsqr     FMsqr     Intensity''/)'/
C
      LAYER=.FALSE.
      CALL PREFIN('POWDER')
C
      SMIN=0.
C
   30 CALL ASK('Wavelength and Maximum (& minimum if non-zero) 2Theta?')
      CALL RDNUMS(VAL,1,3,N,IER)
      IF (N .LT. 2 .OR. N .GT.3 .OR. IER .NE.0) GO TO 30
      ALAM=VAL(1)
      WRITE (LPT,2082) ALAM
 2082 FORMAT (' Wavelength ',F8.4)
      IF (N.EQ.2) THEN
        AMAX=VAL(2)
      ELSE
        AMIN=AMIN1(VAL(2),VAL(3))
        AMAX=AMAX1(VAL(2),VAL(3))
        SMIN=SIN(RADIAN(AMIN/2.))/ALAM
        WRITE (LPT,2081) AMIN
2081    FORMAT (' Minimum 2Theta =',F8.2)
      ENDIF
      SMAX=SIN(RADIAN(AMAX/2.))/ALAM
C
      WRITE (LPT,2080) AMAX
2080  FORMAT (' Maximum 2Theta=',F8.2)
      CALL ASK('Store indices on file? Y or N')
      OUTPUT=(SAYS('Y'))
C
C  SET UP CRYSTALLOGRAPHY
      CALL SETFC
      CALL SYMUNI
      CALL SETGEN(SMAX)
      CALL ERRMES(0,0,'for POWDER')
C
C  NOW GENERATE REFLECTIONS
      TEST=0.
      NUM=1
    1 CALL GENMUL(H(1,NUM),ENDREF,MULT(NUM))
      IF (ENDREF) GO TO 2
      S=VCTMOD(0.5,H(1,NUM),2)
      IF (S .GT. SMAX .OR. S .LT. SMIN) GO TO 1
      IS(NUM)=JFIX(S*(10**4))
      NUM=NUM+1
%      IF (NUM.LE. %NSFS%) GO TO 1
      WRITE (ITO,3000) SMAX
%3000  FORMAT (' There are more than the allowed maximum of %NSFS%',
     & ' reflections'/' inside the SinTheta/lambda limit of',F7.3)
C
C  SORT ON SINTHETA/LAMDA
    2 NUM=NUM-1
      CALL SORTN(IS,M,NUM)
C
C
C  HEADING
      CALL CENTRE(LPT,100,'***** Calculation of powder '//
     &'diagram  *****',90)
      LIN=3
      IF (OUTPUT) THEN
        LPT1=NOPFIL(2)
        LIN=LIN+1
        CALL MESS(LPT,0,
     & '                   Indices output to '//NAMFIL)
      ENDIF
C
C  AND PRINT OUT RESULTS
      CALL MESS(LPT,1,' ')
      WRITE (LPT,1001)
 1001 FORMAT ('    h   k   l    2theta       Fsqrd     Mult    Factor',
     1'    Intensity')
      DO 5 N=1,NUM
      J=M(N)
      DO 6 NN=N+1,NUM
      JJ=M(NN)
      IF (IS(JJ).GT.IS(J)) GO TO 7
      DO 8 I=1,3
      IF (ABS(H(I,J)-H(I,JJ)).GT..0001) GO TO 6
    8 CONTINUE
C MATCH FOUND SKIPc
      GO TO 5
    6 CONTINUE
    7 S=FLOAT(IS(J))
      S=S/(10**4)
      STHL=S
      IF (.NOT.LATABS(H(1,J))) THEN
        FC=FCALC(H(1,J))
        FNSQR = REAL(FC*CONJG(FC))
      ENDIF
      CALL TESTP(LPT,LIN,1,VFMT,1)
      IN=MULT(J)
      STHET=S*ALAM
      THETA=ASIN(STHET)
      FAC=2.*STHET*STHET*COS(THETA)
      ANG=2.*DEGREE(THETA)
      AINT=FLOAT(IN)*FNSQR/FAC
      CALL INDFIX(H(1,J),K)
      WRITE (LPT,2007) K,ANG,FNSQR,IN,FAC,AINT
2007  FORMAT (1X,3I4,2X,F8.2,2X,F10.4,2X,I5,2X,F10.4,2X,F10.3)
      IF (OUTPUT) WRITE (LPT1,2008) K,ANG,FAC,AINT
2008  FORMAT (3I5,F10.2,2F10.4)
    5 CONTINUE
      STOP
      END
C
C
C
C
C LEVEL 50      PROGRAM QUINTO
      PROGRAM QUINTO
C
C *** QUINTO by PJB Nov 89 ***
C
C************************************************************************
C
C                          Q U I N T O
C
C READS THE DIRECTIONS OF INCIDENT & SCATTERED POLARISATION AND PLOTS
C            THE RESULTS ON A STEREOGRAPHIC PROJECTION
C
C************************************************************************
C
      DIMENSION PANG(2,2),RTH(2),VEC(3),ICH(2),NP(50),EP(2)
      CHARACTER*4 LABEL
      DATA ICH/1,2/
C
/CONSTA/
/IOUNIT/
/POLKA/
/TITLE/
C
      CALL INITIL('QUINTO')
      LUNI=NOPFIL(1)
C
C GET SCATTERING ANGLE
      READ (LUNI,1000) ITITLE
1000  FORMAT (A80)
      READ (LUNI,1001) TWOTH
1001  FORMAT (F10.2)
      VTHETA=TWOTH*0.5
      WRITE (LPT,2000)VTHETA
2000  FORMAT (1X,'THETA BRAGG =',F7.2)
C
C PHYSICAL ERRORS ON PHI-COILS IN(1) AND OUT(2)--ANGLES IN DEGREES
      WRITE(ITO,*)'ENTER EP1,EP2'
      READ(ITI,*)EP(1),EP(2)
      WRITE (LPT,2001)EP(1),EP(2)
2001  FORMAT(1X,'PHYSICAL ERRORS ON PHI COILS: Phi-in',F7.2,
     & 4X,' Phi-out',F7.2)
      EP(1)=RADIAN(EP(1))
      EP(2)=RADIAN(EP(2))
C TEXT FOR OUTPUT TABLE
      WRITE (LPT,2002)
2002  FORMAT(/9X,'THE-IN',4X,'PHI-IN',3X,'THE-OUT',3X,
     & 'PHI-OUT',7X,'POL')
      TWOTH=RADIAN(TWOTH)
      THETA=0.5*TWOTH
C
C PREPARE STEREOGRAHIC PLOT
      VEC(1)=0.5
      VEC(2)=THETA
      CALL STEREO(VEC,' ',0,0)
C
C  PLOT A POINT
      IP=1
    3 READ (LUNI,1002,END=4) N,PANG,POL
1002  FORMAT (I5,6F10.2)
      FPOL(IP)=POL
      NP(IP)=N
      WRITE(LPT,1002)N,PANG,POL
C
C  INCLUDE PHYSICAL ERROR EPSILON FROM PHI-COIL
C NOTE THAT IF THETA IS NEGATIVE,SOMETHING DIFFERENT HAPPENS***************
      DO 42 M=1,2
      IF (PANG(1,M).GE.0.) GO TO 42
      TETA=RADIAN(PANG(1,M))
      IF (TETA .LT. -PIBY2) TETA=TETA+PI
      CT=COS(TETA)
      ST=SIN(TETA)
      PDASH=CT*CT*SIN(EP(M))*SIN(EP(M))-ST*ST
      PDASH=PDASH/(1.-COS(EP(M))*COS(EP(M))*CT*CT)
      IF (PDASH .LT. -1.) PDASH=-1.
      PDASH=ACOS(PDASH)*DEG
      IF (EP(M).GT.0.) THEN
        IF (PANG(1,M).GE.-90.) PDASH=360.-PDASH
      ELSE
        IF (PANG(1,M).LT.-90.) PDASH=360.-PDASH
      ENDIF
      PANG(2,M)=PANG(2,M)+PDASH
      PANG(1,M)=-PANG(1,M)
  42  CONTINUE
C
C CALL SUB FOR PHI-IN COIL
      CALL EPSLON(EP(1),RADIAN(PANG(1,1)),RADIAN(PANG(2,1)),VINT,VINP)
C NOW PHI-OUT
      CALL EPSLON(EP(2),RADIAN(PANG(1,2)),-RADIAN(PANG(2,2)),
     & VOUTT,VOUTP)
C NOTE THAT +VOUTP REPLACES -PANG(2,2)
      PANG(1,1)=VINT
      PANG(2,1)=VINP-VTHETA
      PANG(1,2)=VOUTT
      PANG(2,2)=VTHETA+VOUTP
      IF (POL.LT.0.) THEN
        POL=-POL
        PANG(1,2)=180.-PANG(1,2)
        PANG(2,2)=PANG(2,2)-180.
      ENDIF
      IF (PANG(2,2).LE.-180.) PANG(2,2)=PANG(2,2)+360.
C
      WRITE(LPT,2005)PANG(1,1),PANG(2,1),PANG(1,2),PANG(2,2),POL
 2005 FORMAT (8F10.4)
C
      DO 2 I=1,2
      ANG=RADIAN(PANG(2,I))+THETA
      VEC(3)=COS(RADIAN(PANG(1,I)))
      VEC(2)=SIN(RADIAN(PANG(1,I)))
      VEC(1)=VEC(2)*COS(ANG)
      VEC(2)=VEC(2)*SIN(ANG)
      WRITE (LABEL,2006) NP(IP)
2006  FORMAT (I4)
      CALL STEREO(VEC,LABEL,ICH(I),1)
    2 CONTINUE
      IP=IP+1
      GO TO 3
C
    4 NPTS=IP-1
      CALL STEREO(VEC,' ',0,-1)
      STOP
      END
C
C
C
C
      SUBROUTINE EPSLON(EP,T,P,THETA,PHI)
C
C *** EPSLON by PJB Nov 89 ***
C
C CALCULATES PHI AND THETA GIVEN ERROR ON THE PHI COIL,EPSILON
C
/CONSTA/
/IOUNIT/
C
      CT=COS(T)
      ST=SIN(T)
      CEP=COS(EP)
      SEP=SIN(EP)
      CP=COS(P)
      SP=SIN(P)
      Z=CT*(CEP*CEP+SEP*SEP*CP)-SEP*ST*SP
      Y=CEP*(CT*SEP*(1.-CP)+ST*SP)
      X=ST*CP+SEP*CT*SP
      THETA=ARCCOS(Z)*DEG
      DMIN=0.000001
      IF(ABS(X).LT.DMIN) THEN
        PHI=90.
        IF (ABS(Y).LT.DMIN) PHI=P*DEG
        GOTO 1
      ENDIF
      PHI=ATAN(Y/X)*DEG
C USE POSITIVE VALUES FOR PHI
      IF (PHI.LT.-0.00001) PHI=PHI+180.0
C TAKE CARE OF ASSOCIATE ANGLES
   1  IF (ABS(Y).LT.DMIN.AND.X+DMIN.LT.0.0.OR.Y+DMIN.LT.0.0)PHI=PHI+180.
C
      WRITE (LPT,2000)X,Y,Z,THETA,PHI
2000  FORMAT(' X=',F6.2,' Y=',F6.2,' Z=',F6.2,' THE',F6.2,' PHI',F6.2)
      RETURN
      END
C
C
C
C
      SUBROUTINE STEREO(VEC,LABEL,ICH,MODE)
C
C *** STEREO by PJB Nov 89 ***
C
      DIMENSION VEC(3)
      CHARACTER*11 ANUM
      CHARACTER*(*) LABEL
/BRAGG/
/DGEOM/
/CONSTA/
/IOUNIT/
/PLODAT/
/POLKA/
C
      RADI=1.0
      CH=.1
      IF (MODE.LT.0) GO TO 4
      IF (MODE.NE.0) GO TO 20
C
C  SET UP
      CALL GETSCL(-1.,1.,1)
      CALL GETSCL(-1.,1.,2)
      CALL STQUIP(22.,22.,VEC(1))
C DRAW CIRCLE
      STEP=TWOPI/500.
      IP=3
      ANG=0.
    1 X=RADI*COS(ANG)
      Y=RADI*SIN(ANG)
      CALL PLOTO(X,Y,CH,-IP)
      ANG=ANG+STEP
      IP=1
      IF (ANG.LT.6.3) GO TO 1
C
      Y=RADI*SIN(VEC(2))
      X=RADI*COS(VEC(2))
      CALL PLOTO(Y,-X,ER,-3)
      CALL PLOTO(-Y,X,ER,-1)
      CALL PLOTO(-X,-Y,ER,-3)
      CALL PLOTO(X,Y,ER,-1)
      CALL PLOTO(RADI,0,ER,-3)
      CALL PLOTO(1.05*RADI,0,ER,-1)
      CALL GRAFOF
      GO TO 100
C
C  PLOT A POINT
   20 CALL GRAFON
      CH=.3
C POINT UNDERNEATH
      IF (VEC(3).LT.0)CH=.5
      CALL SINCOS(VEC(3),STH,'STEREO')
      THET=ACOS(ABS(VEC(3)))
      RTH=RADI*TAN(THET/2.)
      IF (ABS(STH).LT..0001) THEN
        CSPH=1.
        SNPH=0.
      ELSE
        CSPH=VEC(1)/STH
        SNPH=VEC(2)/STH
      ENDIF
      X=CSPH*RTH
      Y=SNPH*RTH
      CALL SPCSET(4)
      CALL KANGA3(X,Y,CH,ICH)
C  LABEL POINT
      CALL PLCONV(X,Y,4,X1,Y1,6)
      CALL SPCSET(6)
      L=LENGT(LABEL)
      CALL KANGA2(X1,Y1,WID,LABEL,-L)
      X1=X1-WID-0.5*CHUNIT
      Y1=Y1-0.3*CHUNIT
      CALL KANGA2(X1,Y1,WID,LABEL,L)
      GO TO 100
C
    4 CALL SPCSET(5)
C
C  PLOT DOMAIN FRACTIONS
      NDOM=0
      IF (NDOM.NE.0) THEN
        Y1=(NDOM+2)*CHUNIT
        CALL PLCONV(0.,Y1,7,XX1,YY1,4)
        Y2=-NDOM*CHUNIT
        CALL KANGA2(0,Y1,XF,' Dom  Pop  ',-11)
        CALL PLCONV(XF,Y2,7,XX2,YY2,4)
        CALL FRAME(XX1,YY1,XX2,YY2)
        Y2=NDOM*CHUNIT
        CALL PLCONV(0.,Y2,7,XX1,YY1,4)
        CALL KANGA1(XX1,YY1,3)
        CALL KANGA1(XX2,YY1,2)
        CALL SPCSET(7)
        Y1=Y1-1.5*CHUNIT
        CALL KANGA2(0,Y1,XF,' Dom  Pop  ',11)
        DO 6 I=1,NDOM
        Y1=Y1-2*CHUNIT
        WRITE (ANUM,10)I,FRAC(I)
        CALL KANGA2(0,Y1,XF,ANUM,11)
    6   CONTINUE
      ENDIF
C  PLOT POLARISATIONS
      YSTART=(NPTS+2)*CHUNIT
      Y1=YSTART
      CALL PLCONV(0.,Y1,5,XX1,YY1,4)
      NCOL=1
      NPC=NPTS
      IF (YY1.GT.RADI) THEN
        NPC=NPTS/2+MOD(NPTS,2)
        YSTART=(NPC+2)*CHUNIT
        Y1=YSTART
        CALL PLCONV(0.,Y1,5,XX1,YY1,4)
        NCOL=2
      ENDIF
      CALL KANGA2(0,Y1,XF,' Pnt  Pol  ',-11)
      Y2=-NPC*CHUNIT
      CALL PLCONV(XF,Y2,5,XX2,YY2,4)
      XDIF=XX2-XX1
      Y2=Y1-2*CHUNIT
      CALL PLCONV(0.,Y2,5,XX3,YY3,4)
      NS=1
      XS=0.
      NF=NPC
      DO 9 NC=1,NCOL
      CALL SPCSET(4)
      CALL FRAME(XX1,YY1,XX2,YY2)
      CALL KANGA1(XX1,YY3,3)
      CALL KANGA1(XX2,YY3,2)
      CALL SPCSET(5)
      Y1=Y1-1.5*CHUNIT
      CALL KANGA2(XS,Y1,XF,' Pnt  Pol  ',11)
      DO 8 I=NS,NF
      Y1=Y1-2*CHUNIT
      WRITE (ANUM,10)I,FPOL(I)
      CALL KANGA2(XS,Y1,XF,ANUM,11)
    8 CONTINUE
      XS=XS+XF
      Y1=YSTART
      NS=NPC+1
      NF=NPTS
      XX2=XX2+XDIF
      XX1=XX1+XDIF
    9 CONTINUE
   10 FORMAT (I2,2X,F5.3)
      CALL PIGLET(X,Y,-888)
      CALL PIGLET(X,Y,-999)
      CALL GRAFOF
  100 RETURN
      END
C
C
C
C
      SUBROUTINE STQUIP(XX,YY,ER)
C
C *** STQUIP by PJB (VERSION OF SETPLT FOR QUINTO) Nov 89 ***
C
      DIMENSION YC(2),Y(2),XO(2),IPNT(2),ICH(2),AM(2,3)
/IOUNIT/
/PLODAT/
/PLTRAN/
/PLTS/
/TITLE/
      EQUIVALENCE (Y(1),A),(Y(2),B)
C
C***********************************************************************
C                                                                      *
C      THE VECTOR X(I,J) HELD IN COMMON PLTS DEFINES HOW THE GRAPH     *
C      WILL BE DRAWN. I=1 FOR X-AXIS, I=2 FOR Y-AXIS.                  *
C            J=1  LENGTH OF AXIS IN USER UNITS                         *
C            J=2  LENGTH OF AXIS IN CMS.                               *
C            J=3  DIVISION OF AXIS IN USER UNITS                       *
C            J=4  MINIMUM VALUE IN USER UNITS                          *
C            J=5  POSITION OF AXIS TO BE PLOTTED                       *
C                                                                      *
C***********************************************************************
C
C  GET HOLD OF PLOTTER
      CALL PIGLET(0.,0.,0)
C
C  SET LENGTHS OF AXES IN CMS
      DO 21 I=1,2
      X(1,2)=XX
      X(2,2)=YY
C  SET SCALE OF GRAPH
      S(I)=X(I,2)/X(I,1)
   21 CONTINUE
C
C CHARACTER SIZE
      CH=.6
      IF (ER.NE.0.) CH=ER
      XS=CH
C
C OFFSET SPACE 4 TO ALLOW AN INFORMATION PANEL
      OFFSET=XX/2.
      FULWID=1.5*XX
C
C  GRAPH SPACE (SPACE 4)
      AM(1,1)=S(1)
      AM(2,2)=S(2)
      AM(1,2)=0.
      AM(2,1)=0.
      AM(1,3)=BORDER+OFFSET-X(1,4)*S(1)
      AM(2,3)=BORDER-X(2,4)*S(2)
      CALL PLTRIN(AM,4,3)
C
C  SIZE OF PLOT WITH SPACE FOR TITLE AND INFORMATION PANEL
      PW=FULWID+2.*BORDER
      PH=X(2,2)+12*CH+2.*BORDER
C
C
C  CHARACTER 2 SPACE - FOR LABELLING NUMBERS (SPACE 6)
      A1=CH/CHUNIT
      A2=A1*ASPECT
      AM(1,1)=A1
      AM(2,2)=A2
      AM(1,2)=0.
      AM(2,1)=0.
      CALL PLTRIN(AM,6,3)
      CALL PIGLET(PW,PH,999)
      CALL PIGLET(PW,PH,888)
C BLACK PEN:
      CALL PIGLET(0.,0.,-1)
C
C  WRITE TITLE
      LTIT=LENGT(ITITLE)
      CHT=2.*CH
      CALL KANGA2(0,0,WIDTIT,ITITLE,-LTIT)
      WIDTIT=WIDTIT*CHT/CHUNIT
      IF (WIDTIT.GT.FULWID) THEN
        CHT=FULWID*CHT/WIDTIT
        WIDTIT=FULWID
      ENDIF
      HFWID=0.5*WIDTIT
      HT=2.*CHT
      X1=0.5*FULWID+BORDER
      Y1=X(2,2)+BORDER+4*CH
      CALL SPCSET(3)
      CALL FRAME(X1-HFWID,Y1,X1+HFWID,Y1+HT)
C  CHARACTER 1 SPACE FOR TITLE (SPACE 5)
      AM(1,1)=CHT/CHUNIT
      AM(2,2)=AM(1,1)*ASPECT
      AM(1,3)=X1-HFWID
      AM(2,3)=Y1+0.5*CHT
      CALL PLTRIN(AM,5,3)
      CALL SPCSET(5)
      CALL KANGA2(-0.5*WID,0,WID,ITITLE,LTIT)
C
C  REDEFINE SPACE 5 FOR INFO
      CHT=1.4*CH
      AM(1,1)=CHT/(CHUNIT*S(1))
      AM(2,2)=AM(1,1)*ASPECT
      AM(1,3)=-2
      AM(2,3)=0
      CALL PLTRIN(AM,5,4)
      CALL SPCSET(5)
C
C  YET ANOTHER SPACE FOR DOMAINS
      AM(1,1)=CHT/(CHUNIT*S(1))
      AM(2,2)=AM(1,1)*ASPECT
      AM(1,3)=XX+.05
      AM(2,3)=0
      CALL PLTRIN(AM,7,4)
C
C  SET GRAPH SPACE
      CALL SPCSET(4)
 100  RETURN
      END
C
C
C
C
C LEVEL 50      PROGRAM SFLSQ
      PROGRAM SFLSQ
C
C *** SFLSQ  restructured to use LSQCYC C4.19 March 2010 ***
C
C ****************************************************************************
C
C                       S F L S Q
C
C
C MAIN PROGRAM SFLSQ FOR STRUCTURE FACTOR LEAST SQUARES REFINEMENT WITH
C EXTINCTION CORRECTIONS, AND INCLUDING GEOMETRIC SLACK CONSTRAINTS.
C
C IT IS POSSIBLE TO APPLY SLACK CONSTRAINTS WITHOUT DOING THE STRUCTURE
C FACTOR PART AT ALL (USING AN L SLAK 1 CARD)
C
C ****************************************************************************
C
CC 6D
CH Least squares refinement from measured structure factors
C
CD Main program for least squares refinement of structure factors.
CD Extinction corrections can be included and the extinction parameters refined.
CD Geometric slack constraints can be included (see chaper 5 of the CCSL users
CD manual and the documentation of program BONDS)
C
CI The crystal data file must contain all cards needed for structure factor
CI calculations vis:
CI       S cards giving the symmetry.
CI       A C card with the cell dimensions.
CI       A cards defining the atoms, their positions and isotropic.
CI       temperature factors.
CI       F cards giving the scattering factors
CI optionally:
CI       T cards giving anisotropic temperature factors
CI Additionally:
CI       L cards indicating which parameters should be refined
CI          (see the CCSL users' manual)
CI       I cards which may have the words words NCYC, CYCL1, PRIN,
CI       MCOR and CONV.
CI           NCYC the number of least squares cycles (default 3)
CI           CYC1 the number to be assigned to the first cycle (default 1)
CI           PRIN frequency at which output lists are printed
CI               PRIN = 0 no printing
CI               PRIN = 1 first cycle
CI               PRIN = 2 last cycle
CI               PRIN = 3 first and last cycles
CI               PRIN = 4 every cycle
CI           MCOR controls the correlations printed at the end of the job
CI               (default +70)
CI               MCOR = 0 whole correlation matrix printed
CI               MCOR = -ve no printing
CI               MCOR = +ve correlations above MCOR printed
CI           CONV convergence criterion; LSQ cycling is terminated if the
CI               maximum shift/esd < CONV (default 0.01)
CI One or more data files which should be  lists of hkl and observations of the
CI type and in the format indicated by the values of REFI and MODE. For
CI single data sets MODE and REFI may be given on an L card, but with multiple
CI data sets they must be given interactively along with the file name. The
CI relative wieghts to be given to different data sets is also given there.
C
CO The usual listing file reporting the data which have been read. This file
CO also contains the output listings requested by the I PRIN card  as well as
CO the R-factors and chisqrd at the end of each least squares cycle.
CO A new crystal data file corresponding to the structure at the end of the
CO least squares refinement.
C
CR On running the program the user is asked for the name of the crystal data
CR file and the name of the file containing the structure factor data.
CR The value of \$\chi^2\$  at the end of each cycle is reported on the
CR terminal.
CR After the last cycle user is asked for a name for the new crystal data file.
C
CN The EXTERNAL parameters DFLTSF,DUMMY,PARRUN,LFCALC,VARSSF,DUMPAR
CN are the names of routines called to set parameters and carry out
CN calculations which may be different in different types of LSQ. For further
CN Information see chapter 5 of the CCSL manual.
C
      CHARACTER *4 ISFWRD(3)
      CHARACTER *48 HEAD1
      CHARACTER *23 HEAD2
      LOGICAL DFLTSF,LDUMMY
      EXTERNAL DFLTSF,LDUMMY,PARRUN,LFCALC,VARSSF
%      DIMENSION ALSQ(%MATS%),ISWDSP(3,3),MODES(7)
/CARDRC/
/DEPMAT/
/DERBAS/
/DGEOM/
/DSOURC/
/EXTN/
/FCAL/
/IOUNIT/
/NEWOLD/
/NSYM/
/OBSCAL/
/POSNS/
/PRBLEM/
/REFINE/
/SCLDAT/
/SCRACH/
/SFDATA/
/SLAKDA/
/SLKGEO/
      DATA ISFWRD/'SCAL','DOMR','MOSC'/
      DATA ISWDSP/1,2,0, 1,1,8, 1,1,9/
      DATA HEAD1/'    h    k    l    G(obs)   G(calc)      Diff   '/
      DATA HEAD2/'Fc      Scale    Weight'/
C THE EXISTING OPTIONS FOR MODER ARE:
C   1.   H,K,L,OBS,(SCALE GROUP), (CODE)
C   2.   H,K,L,OBS,WEIGHT, (SCALE GROUP), (CODE)
C   3.   H,K,L,OBS,STANDARD DEVIATION OF OBS, (SCALE GROUP),(CODE)
C   4.   H,K,L,GCAL,OBS,STANDARD DEVN. (O/P FROM MEANGM)
C  (5.   H,K,L,OBS,STD DEVN,C1 C2 C3 C4, WHERE C1-C4 ARE THE
C        CONSTANTS INVOLVED IN EXTINCTION CORRECTIONS)
C   6.   H,K,L,ACALC,BCALC,OBS,STANDARD DEVN., (SCALE GROUP) (CODE)
C   12.   H,K,L,OBS,STANDARD DEVIATION OF OBS,WAVLN,PATH,(SCALE GROUP),(CODE)
C WHERE BOTH THE SCALE GROUP AND CODE ARE OPTIONAL.  IF THE SCALE GROUP IS REA
C  AS ZERO, IT WILL BE SET = 1.
C   THE CODE IS NOT AT PRESENT USED; IT IS ENVISAGED THAT IT MAY BE USEFUL
C IN REJECTING SELECTED OBSERVATIONS LATER.
C MASK of ALLOWED MODER
      DATA NMODES,MODES/7,1,2,3,4,5,6,12/
C
C ALTER VALUE HERE AND DIMENSION OF ALSQ IF UNSUITABLE
%      MATSZ=%MATS%
C
C SET UP STRUCTURE FACTOR CALCULATION:
      CALL PREFIN('SFLSQ')
C SET "NON-MAGNETIC"
      MAG=.FALSE.
C DISCOVER WHETHER ACTUALLY ANY SLACK CONSTRAINTS, SETTING SLONLY
      CALL GEOMIN(0)
      CALL SETFC
C
C SPECIFY PROBLEM:
      NFAM=2
      NGENS(1)=2
      NGENS(2)=NATOM
      NSPC(1)=22
      NSPC(2)=12
C
C SPECIES TYPES FOR EACH GENUS OF FAMILY 1:
      LF1SP(1)=9
      LF1SP(2)=-20
C
C WORDS RELEVANT TO THIS PROBLEM FROM DATA INTO COMM0N:
      CALL LSETSF(3,ISWDSP,ISFWRD)
C
C NAMES SET UP SO THAT:
C FAMILY 1 GENUS 1 HAS SPECIES TFAC, A* . . . F*, DOMR, MOSC
C   '    1    '  2 HAS GENUS NAME SCAL, SPECIES INDICATED TO BE 1,2,3 ETC
C
C FAMILY 2 IS AS USUAL THE PARAMETERS WHICH DEPEND ON THE ATOM.  GENUS NAMES
C ARE THEREFORE THE SAME AS ATOM NAMES, AND SPECIES NAMES ARE:
C X Y Z B11 B22 B33 B23 B13 B12 SCAT SITE ITF
C
      CALL CENTRE(LPT,3,'Least Squares Refinement',80)
      CALL CENTRE(LPT,0,'Single crystal structure factor program '//
     & 'with geometric slack constraints',80)
C
C READ I AND (MOST) L CARDS:
      CALL STLSSF
      CALL EXTINC(1,0.)
C4.1 constants can now be calculated when reading the data
      IF (IEXTYP .NE. 0 .AND. MODER .NE. 5) THEN
        CALL SETDC
C find out whether PATHs should be calculated
        PATHS =(IEXTYP.NE.0 .AND. ICDNO(7).NE.0)
        IF (PATHS) CALL SETABS
      ENDIF
C
C SET UP PARAMETERS AS VARIABLES:
      CALL PARSSF(LDUMMY)
C MAKE VARIABLES:
      CALL VARMAK(DFLTSF,PARRUN,VARSSF,LDUMMY)
C IF ANY SLACK CONSTRAINTS, SET UP TO DO THEM:
      CALL GEOMCO(1)
C
C READ ALL THE DATA
      CALL DATASF(NMODES,MODES)
C
C Least squares cycles
      DONE=.FALSE.
      DO 1 ICYC=NCYC1,LASTCY
      CALL LSQCYC(ALSQ,MATSZ,LFCALC,DUMMY)
C
C APPLY SHIFTS AND PRINT:
      CALL APSHSF(LDUMMY)
      IF (DONE) GO TO 39
      DONE=(AMAXSH.LT.CONV .OR. ICYC.EQ.LASTCY-1 .OR. NCYC.EQ.1)
      IF (DONE) CALL NWINSF(LDUMMY)
   1  CONTINUE
C
C PRINT CORRELATION MATRIX:
  39  CALL MATCOR(ALSQ,MATSZ)
      STOP
      END
C
C
C
C
C LEVEL 50      PROGRAM SFTLSQ
      PROGRAM SFTLSQ
C
C *** SFLSQ updated to allow multiple sources C4.2 by PJB September 2007
C
C
C ****************************************************************************
C
C                       S F T L S Q
C
C
C MAIN PROGRAM SFTLSQ FOR STRUCTURE FACTOR LEAST SQUARES REFINEMENT WITH
C EXTINCTION CORRECTIONS, AND INCLUDING GEOMETRIC SLACK CONSTRAINTS.
C SFTLSQ takes account of twinning
C
C IT IS POSSIBLE TO APPLY SLACK CONSTRAINTS WITHOUT DOING THE STRUCTURE
C FACTOR PART AT ALL (USING AN L SLAK 1 CARD)
C Calls CALCTW rather than CALCSF
C
C ****************************************************************************
C
CC 6D
CH Least squares refinement from structure factors measured on twinned crystals
C
CD Main program for least squares refinement of structure factors measured
CD from twinned crystals. Extinction corrections can be included and the
CD extinction parameters refined.
CD Geometric slack constraints can be included (see chaper 5 of the CCSL users
CD manual and the documentation of program BONDS)
C
CI The crystal data file must contain all cards needed for structure factor
CI calculations vis:
CI       S cards giving the symmetry.
CI       A C card with the cell dimensions.
CI       A cards defining the atoms, their positions and isotropic.
CI       temperature factors.
CI       F cards giving the scattering factors
CI       R cards describing the twinning:
CI          R TMAT followed by 9 numbers giving the twin matrices
CI                (one for each twin component)
CI          R TPOP followed by numbers giving the fractional population
CI                 of each twin in the order of the TMAT cards.
CI optionally:
CI       T cards giving anisotropic temperature factors
CI Additionally:
CI       L cards indicating which parameters should be refined
CI          (see the CCSL users' manual)
CI       I cards which may have the words words NCYC, CYCL1, PRIN,
CI       MCOR and CONV.
CI           NCYC the number of least squares cycles (default 3)
CI           CYC1 the number to be assigned to the first cycle (default 1)
CI           PRIN frequency at which output lists are printed
CI               PRIN = 0 no printing
CI               PRIN = 1 first cycle
CI               PRIN = 2 last cycle
CI               PRIN = 3 first and last cycles
CI               PRIN = 4 every cycle
CI           MCOR controls the correlations printed at tyhe end of the job
CI               (default +70)
CI               MCOR = 0 whole correlation matrix printed
CI               MCOR = -ve no printing
CI               MCOR = +ve correlations above MCOR printed
CI           CONV convergence criterion; LSQ cycling is terminated if the
CI               maximum shift/esd < CONV (default 0.01)
CI The data file which should be a list of hkl and the measured structure
CI factors as implied by the L MODE card.
C
CO The usual listing file reporting the data which have been read. This file
CO also contains the output listings requested by the I PRIN card  as well as
CO the R-factors and chisqrd at the end of each least squares cycle.
CO A new crystal data file corresponding to the structure at the end of the
CO least squares refinement.
C
CR On running the program the user is asked for the name of the crystal data
CR file and the name of the file containing the structure factor data.
CR The value of  chisqrd  at the end of each cycle is reported on the
CR terminal.
CR After the last cycle user is asked for a name for the new crystal data file.
C
      CHARACTER *4 ISFWRD(4)
      CHARACTER *48 HEAD1
      CHARACTER *23 HEAD2
      LOGICAL DFTWSF,DOTWN2
      EXTERNAL DFTWSF,PARRUN,LFCALC,VARSSF,DOTWN1,DOTWN2
%      DIMENSION ALSQ(%MATS%),ISWDSP(3,4),MODES(9)
/CARDRC/
/DSOURC/
/DEPMAT/
/DERBAS/
/EXTN/
/FCAL/
/IOUNIT/
/NEWOLD/
/NSYM/
/OBSCAL/
/POSNS/
/PRBLEM/
/REFINE/
/SCLDAT/
/SCRACH/
/SFDATA/
/SLAKDA/
/SLKGEO/
/TWIN/
      DATA ISFWRD/'SCAL','DOMR','MOSC','TPOP'/
      DATA ISWDSP/1,2,0, 1,1,8, 1,1,9, 1,3,0/
      DATA HEAD1/'    h    k    l    G(obs)   G(calc)      Diff   '/
      DATA HEAD2/'Fc      Scale    Weight'/
C THE EXISTING OPTIONS FOR MODER ARE:
C   1.   H,K,L,OBS,(SCALE GROUP), (CODE)
C   2.   H,K,L,OBS,WEIGHT, (SCALE GROUP), (CODE)
C   3.   H,K,L,OBS,STANDARD DEVIATION OF OBS, (SCALE GROUP),(CODE)
C   4.   H,K,L,GCAL,OBS,STANDARD DEVN. (O/P FROM MEANGM)
C  (5.   H,K,L,OBS,STD DEVN,C1 C2 C3 C4, WHERE C1-C4 ARE THE
C        CONSTANTS INVOLVED IN EXTINCTION CORRECTIONS)
C   6.   H,K,L,ACALC,BCALC,OBS,STANDARD DEVN., (SCALE GROUP) (CODE)
C WHERE BOTH THE SCALE GROUP AND CODE ARE OPTIONAL.  IF THE SCALE GROUP IS REA
C  AS ZERO, IT WILL BE SET = 1.
C   THE CODE IS NOT AT PRESENT USED; IT IS ENVISAGED THAT IT MAY BE USEFUL
C IN REJECTING SELECTED OBSERVATIONS LATER.
C MASK of ALLOWED MODER
      DATA NMODES,MODES/9,1,2,3,4,5,6,7,8,12/
C
C ALTER VALUE HERE AND DIMENSION OF ALSQ IF UNSUITABLE
%      MATSZ=%MATS%
C
C SET UP STRUCTURE FACTOR CALCULATION:
      CALL PREFIN('SFTLSQ')
C SET TWINNED
      TWIN=.TRUE.

C DISCOVER WHETHER ACTUALLY ANY SLACK CONSTRAINTS, SETTING SLONLY
      CALL GEOMIN(0)
      CALL SETFC
      CALL OPSYM(2)
C To read the twin matrices and populations
      CALL DOTWN1(1)
C
C SPECIFY PROBLEM:
      NFAM=2
      NGENS(1)=3
      NGENS(2)=NATOM
      NSPC(1)=22 + NTWIN
      NSPC(2)=12
C
C SPECIES TYPES FOR EACH GENUS OF FAMILY 1:
      LF1SP(1)=9
      LF1SP(2)=-20
      LF1SP(3)=-NTWIN
C
C WORDS RELEVANT TO THIS PROBLEM FROM DATA INTO COMM0N:
      CALL LSETSF(4,ISWDSP,ISFWRD)
C
C NAMES SET UP SO THAT:
C FAMILY 1 GENUS 1 HAS SPECIES TFAC, A* . . . F*, DOMR, MOSC
C   '    1    '  2 HAS GENUS NAME SCAL, SPECIES INDICATED TO BE 1,2,3 ETC
C   '    1    '  3 HAS GENUS NAME TPOPL, SPECIES INDICATED TO BE 1,2,3 ETC
C
C FAMILY 2 IS AS USUAL THE PARAMETERS WHICH DEPEND ON THE ATOM.  GENUS NAMES
C ARE THEREFORE THE SAME AS ATOM NAMES, AND SPECIES NAMES ARE:
C X Y Z B11 B22 B33 B23 B13 B12 SCAT SITE ITF
C
      CALL CENTRE(LPT,3,'Least Squares Refinement',80)
      CALL CENTRE(LPT,0,'Twinned  crystal structure factor program '//
     & 'with geometric slack constraints',80)
C
C READ I AND (MOST) L CARDS:
      CALL STLSSF
      CALL EXTINC(1,0.)
C4.1 constants can now be calculated when reading the data
      IF (IEXTYP .NE. 0 .AND. MODER .NE. 5) THEN
        CALL SETDC
C find out whether PATHs should be calculated
        PATHS =(IEXTYP.NE.0 .AND. ICDNO(7).NE.0)
        IF (PATHS) CALL SETABS
      ENDIF
C
C READ ALL THE DATA
      CALL DATASF(NMODES,MODES)
C
C
C SET UP PARAMETERS AS VARIABLES:
      CALL PARSSF(DOTWN2)
C MAKE VARIABLES:
      CALL VARMAK(DFTWSF,PARRUN,VARSSF,DOTWN2)
C IF ANY SLACK CONSTRAINTS, SET UP TO DO THEM:
      CALL GEOMCO(1)
C
C Least squares cycles
      DONE=.FALSE.
      DO 1 ICYC=NCYC1,LASTCY
      CALL LSQCYC(ALSQ,MATSZ,LFCALC,DUMMY)
C APPLY SHIFTS AND PRINT:
      CALL APSHSF(DOTWN2)
      IF (DONE) GO TO 39
      DONE=(AMAXSH.LT.CONV .OR. ICYC.EQ.LASTCY-1 .OR. NCYC.EQ.1)
      IF (DONE) CALL NWINSF(DOTWN2)
   1  CONTINUE
C
C PRINT CORRELATION MATRIX:
  39  CALL MATCOR(ALSQ,MATSZ)
      STOP
      END
C
C
C
C
      SUBROUTINE CALCTW(H,SFCALC)
C
C *** CALCTW updated by PJB C134 5-Nov-2004 ***
C
CX
CC 7B
CH Makes the calculated function and derivatives for twinned crystal LSQ.
CA On entry H is a 3-sized array containing h,k,l
CA   SFCALC is a subroutine name used for the actual structure factor
CA   calculation, like LFCALC
CP Structure factor data must have been set up in various COMMON blocks
CP by SYMOP RECIP ATOPOS, SETFOR, SETANI
CP LSETUP, PARSSF, VARMAK must have set up the Least Squares.
CP STLSSF must have read the L cards:
C
CD Sets GCALC, the calculated function corresponding to an OBS just read
CD Applies an extinction correction if there was an E card.
CD Also produces the vector DERIVV (LVARV long) of derivatives of this
CD function wrt each variable in turn.
C
CD The function GCALC is made up of three functions multiplied together.
CD We write G=P1*P2*P3 where P2 is a simple function of FCALC, P1 is
CD independent of FCALC (being Scale * overall itf), and P3 is the extinction
CD correction.(They are written in this way for ease of differentiation.)
C
CD If IREF=2, we are in fact comparing OBS squared with GCALC squared.  This is
CD dealt with right at the end, after proceeding as though we were not.
CD
CD The sequence of operations is:
CD      Get STHL= sin theta/lambda, SSQRD= STHL squared.
CD      Clear derivatives to zero.
CD      Form P1 and its derivatives.
CD      Form P2: get FCALC and derivatives of mod FCALC wrt family 2 variables
CD      Convert derivatives to be of P2, not just mod FCALC
CD      Form P3: convert derivatives
CD      Form GCALC and make all derivatives so that they are of GCALC
CD      Adjust for GCALC squared or not squared if necessary
CN The scale factors are used to refine the twin ratios. Not that they apply
CN to F rather than Fsqrd. This should prevent negative domain populations
C
      EXTERNAL SFCALC
      LOGICAL TESTOV,LATABS,ISPABS
      DIMENSION H(3),HTWIN(3),TEMP(24)
/BRAGG/
/DERVAR/
/EXTN/
/FCAL/
/IOUNIT/
/OBSCAL/
/OVER/
/POINTS/
/PRBLEM/
/REFINE/
/SCLDAT/
/TWIN/

C
      STHL = VCTMOD(0.5,H,2)
C STHL=SIN THETA/LAMBDA;  SSQRD = IT SQUARED
      SSQRD = STHL*STHL
C
C CLEAR DERIVATIVES WRT VARIABLES - THERE MAY NOT BE AN ENTRY FOR EVERY ONE FOR
C THIS INPUT VALUE OF H:
      IF (LVARV .GT. 0) CALL GMZER(DERIVV,1,LVARV)
      GCALC=0
C
C FORM P1, THE PART OF GCALC INDEPENDENT OF MOD(FC)
      P1T=EXP(-(TFAC*SSQRD))*SCALE(ISCALE)
      IF (KTFAC .NE. 0) DERIVV(KTFAC)=-SSQRD
C CYCLE OVER TWIN COMPONENTS
C134 Introduce NFOUND to avoid errors with systematically absent refs
      NFOUND=0
      DO 1 ITWIN=1,NTWIN
C NEXT DO P2:
      CALL GMPRD(H,TWMAT(1,1,ITWIN),HTWIN,1,3,3)
      IF (LATABS(HTWIN)) GO TO 1
      IF (ISPABS(HTWIN)) GO TO 1
      NFOUND=NFOUND+1
      P12=P1T*P1T*TWPOP(ITWIN)
      CALL SFCALC(HTWIN)
      P2=FCMOD
      IF (IREF .EQ. 4) P2T=REAL(FC)
      DP2DFQ=0.
      IF (.NOT. TESTOV(1.,FCMOD)) DP2DFQ=1./FCMOD
C
C P3:
      CALL EXTINC(3,FCMOD)
      P3=EXTCOR
      PROD=P12*(P2*P3)**2
C134 CORRECTION
      IF (KDOMR .NE. 0) DERIVV(KDOMR)=DERIVV(KDOMR)+DEXDRQ*PROD
      IF (KMOSC .NE. 0) DERIVV(KMOSC)=DERIVV(KMOSC)+DEXDGQ*PROD
      L=KTWPOP(ITWIN)
      IF (L .NE. 0) DERIVV(L)=PROD/(2.*TWPOP(ITWIN))
C
C CONVERT DERIVATIVES FOR FAMILY 2 FROM BEING 'OF FCMOD' AS THEY ARE OUT OF
C LFCALC, USING:
C DP2/DV = DMODFC/DV * DP2/DMODFC - AND ALL ARE DIVIDED BY P2
C DP3/DV = DMODFC/DV * DP3/DMODFC - AND ALL ARE DIVIDED BY P3
C GIVING D(GCALC)/DV OVER GCALC=(DP2/DV OVER P2 + DP3/DV OVER P3)
      DO 4 I=1,NVARF(2,1,1)
      DERIVV(LVFST1(2,1,1)+I)=DERIVV(LVFST1(2,1,1)+i)+
     &FCDERS(I)*(DP2DFQ+DEXDFQ)*prod
    4 continue
C
      GCALC = GCALC+ PROD
      TEMP(ITWIN) = FCMOD
C      WRITE (LPT,5000) HTWIN,FCMOD,PROD
C 5000 FORMAT (3F5.0,6F10.4)
    1 CONTINUE
C134 JUMP OUT IF NO REFLECTIONS FOUND
      IF (NFOUND .EQ.0) GO TO 100
C END OF TWIN LOOP, DO SCALE
      L=KSCALE(ISCALE)
      IF (L .NE. 0) DERIVV(L)=GCALC/SCALE(ISCALE)
C ADJUST IF NECESSARY FOR GCALC squared or NOT SQUARED:
      IF (IREF .NE. 2) THEN
C For twinning the quantity which is calculated must be Intensity
        GCALC=SQRT(GCALC)
        FAC=1./GCALC
      ELSE
        FAC=2.
      ENDIF
      DO 6 I=1,LVARV
   6  DERIVV(I)=DERIVV(I)*FAC
C      WRITE (LPT,5001) H,(TEMP(I),I=1,NTWIN),DERIVV(1)
C 5001 FORMAT (3F8.3,(10F10.4))
  100 RETURN
      END
C
C
C
C
      LOGICAL FUNCTION DFTWSF(IFAM,IGEN,ISPC)
C
C *** DFTWSF by PJB Apr 2000 ***
C
CX
CC 7A
CH Called as a substitute for DEFALT out of SUBROUTINE VARMAK, giving
CH default fix/vary information for structure parameters.
CA On entry IFAM, IGEN, ISPC specify the parameter.
CD On exit DFTWSF is .TRUE. if parameter IFAM,IGEN,ISPC is by default varied
CD         and .FALSE. if fixed.
C
CD In general varies, but fixes scattering factor, and only varies an itf
CD if there is no corresponding atf. Only allows A*-F* to vary if there
CD are slack constraints.
CD Fixes SCAL 1 and varies all TPOP by default
C
/ANISO/
/SLAKDA/
C
      DFTWSF=.TRUE.
      GO TO (1,2) , IFAM
      GO TO 100
C
C
C TRAP NON-EXISTENT CELL PARAMETERS:
   1  IF (IGEN .NE. 1) GO TO 3
      IF (NSLAK(1).EQ.0 .AND. (ISPC.GE.2 .AND. ISPC.LE.7)) GO TO 101
      GO TO 100
C
   2  IF (ISPC .LT. 10) GO TO 100
      IF (ISPC .LT. 12) GO TO 101
C IF VARYING ITF BY DEFAULT, CHECK NOT ALSO ATF:
      IF (IAPT(IGEN) .EQ. 0) GO TO 100
      GO TO 101
C
C Vary all TPOP
   3  IF (IGEN .EQ. 3) GO TO 100
C Fix scal 1
      IF (IGEN .EQ.2 .AND. ISPC .NE. 1) GO TO 100
C
C FIX:
 101  DFTWSF=.FALSE.
 100  RETURN
      END
C
C
C
C
C LEVEL 50      PROGRAM SIMPLE
      PROGRAM SIMPLE
C
C *** SIMPLE updated by JCM 17 Oct 87 ***
C
C ******************************************************************************
C
C                             S I M P L E
C
C ******************************************************************************
C
C  TEST PROGRAM FOR MK3 - SAMPLE 1 - GENERATE F CALC, SORT ETC.
      CHARACTER *1 IC
      CHARACTER *46 HEAD
      COMPLEX FC,FCALC
      LOGICAL NOMORE,ISPABS
      DIMENSION H(3),K(3,1000),A(1000),B(1000),SINTH(1000),IPNT(1000)
/IOUNIT/
/NSYM/
      DATA HEAD/'    No.    h   k   l    Mult     s            '/
C
      CALL PREFIN('SIMPLE')
      S=0.2715
C FOR NOW, S FIXED
C
      CALL SYMOP
      CALL OPSYM(1)
      CALL OPSYM(2)
      CALL RECIP
      CALL ATOPOS
      CALL SETFOR
      CALL SETANI
      CALL SYMUNI
      CALL CENTRE(LPT,4,'Sorted structure factors - * indicates '//
     & 'space group absence:',80)
      IF (.NOT. CENTRC) THEN
        CALL MESS(LPT,0,HEAD//'A            B          FcMod')
      ELSE
        CALL MESS(LPT,0,HEAD//'Fc')
      ENDIF
      CALL SETGEN(S)
      CALL ERRMES(0,0,'for SIMPLE')
C
      NSUM=0
      N=0
   2  CALL GETGEN(H,NOMORE)
      IF (NOMORE) GO TO 5
      N=N+1
      NSUM=NSUM+MULBOX(H)
      FC=FCALC(H)
      A(N)=REAL(FC)
      B(N)=AIMAG(FC)
      SINTH(N)=VCTMOD(0.5,H,2)
      CALL INDFIX(H,K(1,N))
      GO TO 2
C
   5  CALL SORTX(SINTH,IPNT,N)
      DO 3 I=1,N
      J=IPNT(I)
      FMOD=SQRT(A(J)*A(J)+B(J)*B(J))
      CALL INDFLO(H,K(1,J))
      IC=' '
      IF (ISPABS(H)) IC='*'
      M=MULBOX(H)
      IF (.NOT. CENTRC) THEN
        WRITE (LPT,2001) IC,I,(K(L,J),L=1,3),
     &   M,SINTH(J),A(J),B(J),FMOD
      ELSE
        WRITE (LPT,2001) IC,I,(K(L,J),L=1,3),
     &   M,SINTH(J),A(J)
      ENDIF
2001  FORMAT (' ',A1,I5,2X,3I4,2X,I5,F10.5,3X,3F12.5)
   3  CONTINUE
      WRITE (LPT,2002)  NSUM,S
 2002 FORMAT (/'  Total number of reflections inside sphere',
     & '=',I4/' S max=',F10.4)
C WRITE TO TERMINAL ALSO:
      WRITE (ITO,2002)  NSUM,S
      STOP
      END
C
C
C
C
C LEVEL 50      PROGRAM SNPLSQ
      PROGRAM SNPLSQ
C
C *** SNPLSQ  restructured to use LSQCYC C4.19 March 2010 *** ***
C
C ****************************************************************************
C
C                       S N P L S Q
C
C
C MAIN PROGRAM FOR STRUCTURE FACTOR LEAST SQUARES REFINEMENT, OF
C MIXED NUCLEAR AND MAGNETIC STRUCTURE FACTORS WITH EXTINCTION CORRECTIONS
C MULTIPLE DATA SOURCES INCLUDING SNP.
C
C ****************************************************************************
C
CC 6D
CH Least squares refinement from magnetic structure factor data
C
CD Main program for least squares refinement, of magnetic structure factor data
CD from (possibly) mixed nuclear and magnetic reflections
CD the magnetic symmetry can less than the nuclear symmetry. Can conbine
CD SNP, intensity and flipping ratio data
C
CI The crystal data file must contain all cards needed for magnetic
CI and nuclear structure factor calculations vis:
CI       S cards giving the symmetry.
CI       A C card with the cell dimensions.
CI       A cards defining the atoms, their positions and isotropic.
CI       temperature factors.
CI       F cards giving the  magnetic and non-magnetic scattering
CI       factors
CI       Q cards defining the magnetic structure
CI       R cards giving twin matrices if the magnetic structure can't be
CI        generated using all the symmetry elements of the structure group, even
CI        allowing NSYM type operations leading to s-domains.  One R TMAT for
CI        each missing operator
CI optionally:
CI       T cards giving anisotropic temperature factors
CI Additionally:
CI       L cards indicating which parameters should be refined
CI          (see the CCSL users' manual)
CI       L DATA <ID> <Fname> cards giving the data idedtifier ID and filename
CI              for each data source
CI       L SORC ID REFI <iref> IType of refinement for source ID
CI              REFI= 1 Refine on mod(Fc)
CI              REFI= 2 Refine on Fc squared
CI              REFI= 4 Refine on signed Fc
CI              REFI= 5 Refine  on polarised neutron Flipping Ratios
CI              REFI= 6 Refine on ratio of magnetic to nuclear structure factors
CI              REFI= 7 Refine on Polarized neutron intensity asymmetry
CI              REFI= 8 Refine on elements of the polarisation matrix SNP
CI       L SORC ID MODE <Moder>  format of data source ID
CI                        (may be on the same card as REFI ans/or WGHT).
CI       L SORC ID WGHT <Moder>   relative weight to be given to data ID
CI                        (may be on the same card as REFI and/or MODE)
CI       L SORC ID SCAL <Scales>  scale factors for source ID as many as
CI                       required (may terminate the  same card as REFI or MODE,
CI                       start or continue on a different L SORC ID SCAL card
CI                       with the same ID.
CI       L SORC ID DPOP <Dpops> domain populations for source ID; as many as
CI                       required (may terminate the  same card as REFI or MODE,
CI                       start or continue on a different L SORC ID DPOP card
CI                       with the same ID.
CI       I cards which may have the words words NCYC, CYCL1, PRIN,
CI           MCOR and CONV
CI           NCYC the number of least squares cycles (default 3)
CI           CYC1 the number to be assigned to the first cycle (default 1)
CI           PRIN frequency at which output lists are printed
CI               PRIN = 0 no printing
CI               PRIN = 1 first cycle
CI               PRIN = 2 last cycle
CI               PRIN = 3 first and last cycles
CI               PRIN = 4 every cycle
CI           MCOR controls the correlations printed at the end of the job
CI               (default +70)
CI               MCOR = 0 whole correlation matrix printed
CI               MCOR = -ve no printing
CI               MCOR = +ve correlations above MCOR printed
CI           CONV convergence criterion; LSQ cycling is terminated if the
CI               maximum shift/esd < CONV (default 0.01)
CI The data files whose names were given on the L DATA cards.  They should be
CI lists of hkl and observations of the type and in the format indicated by the
CI associated REFI and MODE.
C
CO The usual listing file reporting the data which have been read. This file
CO also contains the output listings requested by the I PRIN card  as well as
CO the R-factors and chisqrd at the end of each least squares cycle.
CO A new crystal data file corresponding to the structure at the end of the
CO least squares refinement.
C
CR On running the program the user is asked for the name of the crystal data
CR file.
CR The value of \$\chi^2\$ for each data set is reported on the terminal
CR at the end of each cycle.
CR Just before the last cycle user is asked for a name for the new crystal
CR data file.
C
C
      DIMENSION MODES(7)
      CHARACTER *4 ISFWRD(4)
      LOGICAL DFLTMG,DOMAG2,CLAIMD,DOPOPS
      EXTERNAL DFLTMG,LFCALC,LMCALC,DOMAG2,PARRUN,VARSSF,DOMAG1,MGTDOM
      DIMENSION ALSQ(10000)
      DIMENSION ISWDSP(3,4)
/DERBAS/
/CARDRC/
/DEPMAT/
/DGEOM/
/DSOURC/
/EXTN/
/FCAL/
/IOUNIT/
/MCAL/
/NEWOLD/
/OBSCAL/
/POLDA/
/POSNS/
/PRBLEM/
/REFINE/
/SFDATA/
/SATELL/
/SCLDAT/
/SCRACH/
/SYMMAG/
/TWIN/
/WDSPC/
/WORDS/
%      DATA NPSI/%PSIS%/
      DATA ISFWRD/'SCAL','DOMR','MOSC','DPOP'/
      DATA ISWDSP/-12,0,0, 1,1,8, 1,1,9, -13,0,0/
      DATA NTRUE,MODES/7,3,5,7,8,9,10,12/
C
C ALTER VALUE HERE IF NECESSARY, WITH DIMENSION OF ALSQ:
%      MATSZ=%MATS%
C
C SET UP STRUCTURE FACTOR CALCULATION:
      CALL PREFIN('SNPLSQ')
C
C SET "MAGNETIC"
      MAG=.TRUE.
C
      CALL SETFCM(DOMAG1)
C READ E CARD:
      CALL EXTINC(1,0.)
      MTWIN=(ICDN(18,1) .GT.0)
C To read the twin matrices and populations
      IF (MTWIN) THEN
        CALL DOTWN1(0)
      ELSE
        NTWIN=1
        CALL GMUNI(TWMAT(1,1,1),3,3)
      ENDIF
      NDOMS=NTWIN*NDOM*ND180*KCENT
      WRITE (LPT,2020) NDOMS
 2020 format (/i3,' Domain populations to determine:')
      MTWIN=(NDOMS.GT.1)
C Indicate which domain is which
      IF (MTWIN) CALL PRIDOM
C
C SPECIFY PROBLEM:
      NFAM=3
      NGENS(1)=1
      NGENS(2)=NATOM
      NSPC(1)=9
      NSPC(2)=18+NPSI
C
C SPECIES TYPES FOR EACH GENUS OF FAMILY 1:
      LF1SP(1)=9
C Count the L DATA cards
      KPOS=0
      MDATA=0
    6 CALL FINDCD('L','DATA' ,4,KPOS,LCD)
      IF (LCD .GT.0) THEN
        MDATA=MDATA+1
        KPOS=LCD
        GO TO 6
      ENDIF
      IF (MDATA .EQ.0)  CALL ERRMES(2,0,
     &'at least one L DATA card giving a data file-name ')
      NGENS(3)=MDATA
%      NSPC(3)=%DPOP%+20
C WORDS RELEVANT TO THIS PROBLEM FROM DATA INTO COMMON:
      CALL LSETSF(4,ISWDSP,ISFWRD)
C
C NAMES SET UP SO THAT:
C FAMILY 1 GENUS 1 HAS SPECIES TFAC, DOMR, MOSC (WITH PROVISION FOR
C A* ETC FOR GEOMETRIC CONSTRAINTS)
C   "    1    "  2 HAS GENUS NAME SCAL, SPECIES INDICATED TO BE 1,2,3 ETC
C   '    1    '  3 HAS GENUS NAME DPOP, SPECIES INDICATED TO BE 1,2,3 ETC
C ENOUGH DPOPS FOR NDOM S-DOMAINS Kcent chiral domains and IF IPROP=0,2 180
C degree domains IN EACH Twin
C FAMILY 2 IS AS USUAL THE PARAMETERS WHICH DEPEND ON THE ATOM.  GENUS NAMES
C ARE THEREFORE THE SAME AS ATOM NAMES, AND SPECIES NAMES ARE:
C X Y Z B11 B22 B33 B23 B13 B12 SCAT SITE ITF,
C THE MAGNETIC MOMENTS MU AND MU1 ORIENTATION PARAMETERS THET PHI THE1 PHI1
C AND POSSIBLE SUB-LATTICE PHASE ANGLES PSI1 PSI2 PSI3 FOR SPIRALS
      CALL CENTRE(LPT,3,'Least Squares Refinement',80)
      CALL CENTRE(LPT,0,'Multi-Source Magnetic and Nuclear '//
     & 'Structure Factor and SNP program',80)
C
C find out whether PATHs should be calculated
      PATHS =(IEXTYP.NE.0 .AND. ICDNO(7).NE.0)
      IF (PATHS) CALL SETABS
C READ I AND (MOST) L CARDS:
      CALL STLSSF
C Set the actual number of magnetic domains and scale factors,
C and make their parameter names
      ISAVE=IWDNUM
      NP=NDOMS
      IF (MDATA.NE.0) MTWIN= DOPOPS(NP,1)
      NSPC(3)=NP
      DO 8 I=1,NUMSRC
      LF3SP(I,1,1)=I
    8 CONTINUE
C
C SET UP PARAMETERS AS VARIABLES:
      CALL LOGMAG
      CALL PARSSF(MGTDOM)
      CALL DOMAG1(2)
      CALL ERRMES(0,0,'to SNPLSQ(2)')
C
C READ ALL THE DATA now not done from inplsq
      CALL DATASF(NTRUE,MODES)
C
      CALL VARMAK(DFLTMG,PARRUN,VARSSF,MGTDOM)
C
C
C Least squares cycles
      DONE=.FALSE.
      DO 1 ICYC=NCYC1,LASTCY
      CALL LSQCYC(ALSQ,MATSZ,LFCALC,LMCALC)
      CALL APSHSF(MGTDOM)
C ON PENULTIMATE CYCLE PRODUCE NEW CRYSTAL DATA FILE:
      IF (DONE) GO TO 39
      DONE=(AMAXSH.LT.CONV .OR. ICYC.EQ.LASTCY-1 .OR. NCYC.EQ.1)
      IF (DONE)  CALL NWINSF(MGTDOM)
C RESET SPIN VECTORS IF ABOUT TO DO ANOTHER CYCLE
      IF (ICYC.NE.LASTCY) THEN
        CLAIMD = DOMAG2(0,5)
        IF (HELI) CALL VARMAK(DFLTMG,PARRUN,VARSSF,MGTDOM)
      ENDIF
   1  CONTINUE
C
C PRINT CORRELATION MATRIX:
  39  CALL MATCOR(ALSQ,MATSZ)
      STOP
      END
C
C
C
C
      LOGICAL FUNCTION MGTDOM(NN,MODE)
C
C *** 4.23 MGTDOM rewritten June 2011 to write the new crystal data correctly ***
C
CC 17B
CH Routine to combine set up of twin, domain and magnetic parameters for multisource LSQ
CD Returns true if  this request can be treated by either
CD DOMAG2 or DOPOPS
C
/NEWOLD/
      LOGICAL DOMAG2,DOPOPS
      IF (MODE .EQ.1 .OR. (MODE .EQ.2 .AND. NN .EQ.0)) go to 1
      go to (2,2,4,4,4,4) mode-1
      mgtdom=.false.
      go to 100
c Symmetry constra1nts for both multi-source and magnetic
    1 MGTDOM = DOMAG2(NN,MODE)
       MGTDOM = DOPOPS(NN,MODE)
       go to 100
    2 IF (IFAM .EQ.3 ) THEN
        MGTDOM  = DOPOPS(NN,MODE)
      else
        MGTDOM = DOMAG2(NN,MODE)
      endif
      go to 100
    4 MGTDOM = DOMAG2(NN,MODE)
      IF (.NOT. MGTDOM ) MGTDOM  = DOPOPS(NN,MODE)
  100 RETURN
      END
C
C
C
C
       LOGICAL FUNCTION DFLTMT(IFAM,IGEN,ISPC)
C
C *** DFLTMT by PJBAug 2004 ***
C
CX
CC 7A
CH Called as a substitute for DEFALT out of SUBROUTINE VARMAK, giving
CH default fix/vary information for structure parameters.
CA On entry IFAM, IGEN, ISPC specify the parameter.
CD On exit DFTWSF is .TRUE. if parameter IFAM,IGEN,ISPC is by default varied
CD         and .FALSE. if fixed.
C
C
CD Fixes SCAL 1 for each source and varies all TPOP by default
C Otherwise calls DFLTMG
      EXTERNAL DFLTMG
      LOGICAL RESULT,DFLTMG
/DSOURC/
C
      IF (IFAM.EQ. 1) THEN
        IF (IGEN .EQ.2) THEN
          IP=1
          DO 1 JS=1,NUMSRC
          IF (ISPC .EQ. IP) THEN
            RESULT=.FALSE.
            GO TO 99
          ENDIF
          IP=IPSCAL(JS)+1
    1     CONTINUE
          RESULT=.TRUE.
        ELSE
C Vary all DPOP
          RESULT =(IGEN .EQ. 3)
        ENDIF
      ELSE
        RESULT = DFLTMG(IFAM,IGEN,ISPC)
      ENDIF
   99 DFLTMT = RESULT
      RETURN
      END
C
C
C
C
C LEVEL 50      PROGRAM SORASY
      PROGRAM SORASY
C
C
C *** SORASY Corrected by  PJB C4.June 2011 ESD for R-1=0 ***
C *********************************************************************
C
C                          S O R A S Y
C
C  Calculats asymmetry factors and their means from the arranged flipping ratios
C useful for acentric structures
C
C
C *********************************************************************
C
CC 2D
CH Calculation of approximate mean asymmetry factors from flipping ratios
CH Can be used for acentric structures.
C
CD SORASY calculates the assymetry factors from a set of flipping
CD ratio measurements which have been sorted by ARRNGE. The program assumes
CD that there is a unique magnetisation direction which by default is parallel
CD to the Z axis of the diffractometer which is the polarisation direction.
CD The factors for equivalent reflections are averaged, after correction for
CD polarisation and weighted according to their esd's.
CN If  M~N he angular correction is only approximate so the mean values should
CN not be used in further processing anless a symmetry axis is closely // z.
CN For M<<N the averaging is valid and so is the extinction correction.
C
CI The crystal data file, which must contain:
CI       S cards giving the symmetry.
CI       A C card with the cell dimensions.
CI Additionally:
CI       A P card giving the polarisation
CI       D cards giving the crystal orientation,
CI         an optional D LAM2 card giving the half wavelength contamination
CI         as a fraction of the full wavelength intensity.
CI The P and D cards can be copied from the file dcards.cry written by D3OP97
CI       I cards which should be the same as those used for ARRNGE but can
CI         include the extra words OUTP GAMA, MAGD, X, Y, Z, PHI
CI
CI A file of sorted flipping ratios as written by ARRNGE. Default
CI extension .arr
CI
CO A listing file sorasy.lis which reports what as read from the crystal data
CO file and gives the calculated asymetry factors for each set of equivalent
CO reflections.
CR On running the program the user is asked for the name of the crystal data
CR file, then whether output of \$\gamma 's\$ and/or magnetic structure factors
C NINDEP = Number of independent results to store
      PARAMETER (NINDEP=500)
      CHARACTER*10 FILNAM,FILNOM
      CHARACTER*150 HEADNG,BUFFER
      LOGICAL LERCHK,NOK,OUTP,SAYS,LATABS,ISPABS
      COMPLEX FCALC,FCAL
      DIMENSION LUN(1),KK(3),WRK(5),G(2),H(3),OH(3),KD(3,NINDEP),LOUT(2)
     &,FMAG(NINDEP),EMAG(NINDEP),IPTR(NINDEP)
/ABSDAT/
/CARDRC/
/CELPAR/
/DGEOM/
/EXTN/
/IOUNIT/
/POLDA/
/REFS/
/SCRACH/
/WHEN/
      DATA HEADNG/'(''    h    k    l     ASYM     dASYM   Cosrho**2   C
     &*ASYM     esd     label index   Sinth/Lam  abs(FN)     Phi(N) mean
     &(FmCos)  esd   ''/)'/
C
      SCALE(1)=1.0
C SET POLARISED DATA
      MODE=2
      NUNITS=1
      NOK=.TRUE.
      CALL PREFIN('SORASY')
      CALL INPUTI
      CALL ICDFMT(INC,ITEMS)
      CALL SETFC
C
C  NOW OPEN FILES
      NAMFIL='.ARR'
      LUNI=NOPFIL(101)
      LUN(1)=LUNI
C4.12  READ THE DATA HEADER
      CALL ARRHED(1)
      CALL ASK (
     &' Output mean Fm cos(phin-phim) valid if Fm<<Fn (Y/N def N) ')
      OUTP = SAYS('Y')
      FILNAM=FILNOM(LUNI)
      L=LENG(FILNAM,10)
      MESSAG=FILNAM(1:L-4)
      NAMFIL='.ASY '
      LOUT(1)=NOPFIL(122)
      IF (OUTP) THEN
        MESSAG=FILNAM(1:L-4)
        NAMFIL='.ASM '
        LOUT(2)=NOPFIL(122)
        NUNITS=2
      ENDIF
      CALL SETDC
      CALL SETPOL
      DO 5 I=1,3
    5 POLND(I)=UM(3*I)
      EXTFAC=1.0
      IF (ICDNO(7).NE.0)  CALL SETABS
C4.19 Write header on asymmetry outputs
      CALL HDROUT(LOUT,NUNITS,MODE)
C
      CALL CENTRE(LPT,1,'******  ASYMMETRY FACTORS and  their MEANs '//
     &' ******',100)
      CALL NEWLIN(LPT)
C
C WRITE HEADING
      WRITE (LPT,HEADNG)
C
      LBUF=0
      NDONE=0
      LCOUNT=9
      CALL STATIS(-1)
C     READ EACH GROUP OF EQUIVALENT REFLECTIONS BEFORE PROCESSING
   25 IEND= INPUAR(1,LUN)
      IF (IEND.NE.0) GO TO 60
      CALL STATIS(1)
C
      VEC = VCTMOD(0.5,FF(1,1),2)
C
C     PROCESSING OF ONE GROUP OF EQUIVALENT REFLECTIONS STARTS HERE
      NRF = 1
      NREF=0
      II = 0
      CALL WTMEAN(G(1),G(2),0,WRK)
   37 L=LL(NRF,1)
      CALL GMEQ(R(II+1,1),H,3,1)
C Skip if a nuclear absence
      IF (LATABS(H) .OR. ISPABS(H)) GO TO 25
      CALL INDFIX(H,KK)
      IF (L .EQ. 3) GO TO 21
      IF (LBUF .GT.0) WRITE (LPT,2000) (BUFFER(LB:LB),LB=1,LBUF)
      IF (LBUF .GT.65) WRITE (LPT,2000)
      LBUF=0
 2000 FORMAT (132A1)
C CALCULATE COS RHO
      CALL ORTHO(H,OH,2)
      CALL UNIVEC(OH,D)
      SINRHO=SCALPR(OH,POLND)
      COSSQR=1.-SINRHO**2
C  CALCULATE ASYMMETRY FOR THIS REFLECTION
      II = II+L
      NRF = NRF+1
      G(1)=(R(II+1,1)-1)/(R(II+1,1)+1)
C4.23 Correction to esd for zero ASYM
      G(2)=2.*R(II+2,1)/((R(II+1,1)+1)**2)
C Output of raw asymmetry factor
      WRITE (LOUT(1),2008) KK,G
      WRITE (BUFFER,2006) KK,G,COSSQR
      G(1)=G(1)/((POLUP + ABS(POLDW))*COSSQR)
      G(2)=G(2)/((POLUP + ABS(POLDW))*COSSQR)
      LBUF=45
C Approximate angle correction
      WRITE (BUFFER(LBUF+1:),2005) G
      LBUF=LBUF+20
C STEP PAST MEANS
      II=II+2
      IFUN=2
      CALL WTMEAN(G(1),G(2),IFUN,WRK)
2005  FORMAT (2F10.5)
2006  FORMAT (3I5,3F10.5)
2008  FORMAT (3I5,2F10.6,F10.4)
C     GET NEXT EQUIVALENT REFLECTION
      GO TO 37
C
C     HERE AT THE END OF A GROUP
   21 CALL WTMEAN(AMEANX,ESD,-1,WRK)
       FCAL=FCALC(H)
      IF (OUTP) THEN
        WRITE (LOUT(2),2012) (K(I,1),I=1,3),AMEANX,ESD
2012    FORMAT (3I5,2F10.5)
      ENDIF
      FN=CABS(FCAL)
      AMEANX=AMEANX*FN
      ESD=ESD*FN
      PHIN=ATAN2(IMAG(FCAL),REAL(FCAL))
      WRITE (BUFFER(LBUF+1:),2007) (K(I,1),I=1,3),VEC,FN,PHIN,AMEANX
     &,ESD
2007  FORMAT (3I5,3F10.4,2F10.4)
      IF (NOK) THEN
        NOK=LERCHK(2,NDONE,NINDEP,-1,'Independent reflections')
        IF (NOK) THEN
          FMAG(NDONE)=AMEANX
          EMAG(NDONE)=ESD
          CALL JGMEQ(K,KD(1,NDONE),3,1)
        ENDIF
      ENDIF
      LBUF=LBUF+65
C     RETURN TO READ NEXT BLOCK
      LCOUNT=LCOUNT+1
      GO TO 25
C
C     DATA ALL FINISHED
  60  IF (LBUF .GT.0) WRITE (LPT,2000) (BUFFER(LB:LB),LB=1,LBUF)
      WRITE (LPT,2000)
C CHECK FOR REFLECTIONS TO REMEASURE
      WRITE (LPT,2011)
 2011 FORMAT (' Check reflections to remeasure '
     &,'(ordered by decreasing esd):'/'   h   k   l    DFmag    Fmag')
      CALL SORTX(EMAG,IPTR,NDONE)
      DO 61 I=NDONE,I,-1
      IP=IPTR(I)
      WRITE (LPT,2010) (KD(J,IP),J=1,3),EMAG(IP),FMAG(IP)
C      WRITE (LPT,2010) (KD(J,I),J=1,3),EMAG(I),FMAG(I)
 2010 FORMAT (3I4,2F10.5)
   61 CONTINUE
      STOP
      END
C
C
C
C
C LEVEL 50      PROGRAM SORGAM
      PROGRAM SORGAM
C
C *** SORGAM Updated by  PJB C4.19 March 2010 to use common header output ***
C
C *********************************************************************
C
C                          S O R G A M
C
C  A VERSION OF SORGAM WHICH INCLUDES AN EXTINCTION CORRECTION
C  CALCULATES GAMMA FROM THE ARRANGED R (FLIPPING RATIOS)
C
C *********************************************************************
C
CC 2D
CH Calculation of gamma and magnetic structure factors from flipping ratios
C
CD SORGAM calculates the magnetic structure factors from a set of flipping
CD ratio measurements which have been sorted by ARRNGE. The program assumes
CD that there is a unique magnetisation direction which by default is parallel
CD to the Z axis of the diffractometer which is the polarisation direction.
CD Corrections are made for the inclination of the scattering vector to the
CD x-y plane and for extinction if an E card is present. The gamma values of
CD equivalent reflections are averaged, weighted according to their esd's.
C
CI The crystal data file, which must contain:
CI       S cards giving the symmetry.
CI       A C card with the cell dimensions.
CI       A cards defining the atoms, their positions and isotropic.
CI       temperature factors.
CI       F cards giving the scattering factors
CI optionally:
CI       T cards giving anisotropic temperature factors
CI       G cards giving the size and shape of the crystal (for path length
CI           calculations)
CI       An E card giving the extinction parameters
CI Additionally:
CI       A P card giving the polarisation
CI       D cards giving the crystal orientation,
CI         an optional D LAM2 card giving the half wavelength contamination
CI         as a fraction of the full wavelength intensity.
CI The P and D cards can be copied from the file dcards.cry written by D3OP97
CI       I cards which should be the same as those used for ARRNGE but can
CI         include the extra words OUTP GAMA, MAGD, X, Y, Z, PHI
CI         OUTP 100 causes a file SORCOR.LIS to be written which gives all the
CI                  correction factors
CI         GAMA 1 indicates that there are reflections for which \$\gamma \> 1\$
CI                ie the magnetic scattering is greater than the nuclear.
CI                (default 0)
CI         MAGD defines the magnetisation direction
CI              MAGD = 1 (default) magnetisation parallel to omega axis
CI              MAGD = 2 magnetisation parallel to an axis given on an I card
CI                       by numbers following the words X, Y, and Z
CI              MAGD = 3 magnetisation between 1 and 2 at
CI                       \$\cos^{-1}(\cos\phi)\$ to 2. Where \$\phi\$ follows
CI                       the word PHI on an I card
CI              MAGD = 4 Schwinger scattering
CI
CI A file of sorted flipping ratios as written by ARRNGE. Default
CI extension .arr
CI
CI If GAMA = 1 a file containing the indices of reflections for which
CI \$\gamma > 1\$. This may be followed by the value of \$\cos\rho\$ below
CI which the effective \$\gamma < 1\$. (\$\rho\$ is the angle of inclination
CI of the scattering vector to the x-y plane of the diffractometer). These
CI indices must be given in the standard order of ARRNGE files ie sorted in
CI order of increasing \$\ell\$ then \$k\$, then \$h\$.
CO A listing file sorgam.lis which reports what as read from the crystal data
CO file and gives the calculated \$\gamma\$ values for each set of equivalent
CO reflections. The mean \$\gamma\$, its esd, \$\sinth\$, the nuclear structure
CO factor and the experimental magnetic structure factor with its esd are
CO given for each reflection in the asymmetric unit.
CO If OUTP = 100 a file SORCOR.LIS which lists the extinction factor, and the
CO correction factors \$\{\bf q\}\cdot \{\bf q\}\$ and
CO \$\{\bf q\}\cdot\{\bf\lambda\}\$. \$\{\bf q\}\$ is a unit vector parallel
CO to the projection of
CO the magnetisation direction on the plane perpendicular to the scattering
CO vector and \$\{\bf \lambda\}\$ is a unit vector parallel to the polarisation
CO direction.
CO a file containing \$hkl\$ \$\gamma\$ and its esd and/or one containing
CO \$hkl\$ and the observed magnetic structure factor with its esd for each
CO reflection in the asymmetric unit.
CR On running the program the user is asked for the name of the crystal data
CR file, then whether output of \$\gamma 's\$ and/or magnetic structure factors
CR are required. If GAMA = 1 the name of the file containing the indices of
CR reflections with \$\gamma \> 1\$ is requested.
CR Finally the name of the data file containing the flipping ratios
CR is required (default extension .arr).
CR The output files are named with the leaf name of the data file
CR and extension .gam for \$\gamma 's\$ and .msf for magnetic structure
CR factors.
CN SORGAM will make a \$\lambda/2\$ correction If a D LAM2 line is included
CN in the cdf
      CHARACTER*10 FILNAM,FILNOM
      COMPLEX FCALC
      LOGICAL SOME,OUTG,OUTF,SAYS,LAM2,ONCARD
      CHARACTER*2 IPMARK(2),IEMARK(2)
      CHARACTER*132 HEADNG
      DIMENSION ABSC(3),LUN(1),LOUT(2),KK(3),WRK(5),G(2),H(3)
/ABSDAT/
/CARDRC/
/CELPAR/
/DGEOM/
/EXTN/
/IOUNIT/
/REFS/
/POLDA/
/SCRACH/
/WHEN/
      DATA HEADNG/'(''0        h    k    l    Gamma     DGamma   labelli
     &ng index  Mean G   Mean DG   Sinth/Lam   Fnucl     FobsM     DFobs
     &M''/)'/
      DATA VALMUB/.2695/
      DATA IPMARK,IEMARK /'  ','**','  ','##'/
C

C Set polarised data
      MODEHD=2
      SCALE(1)=1.0
      CALL PREFIN('SORGAM')
      CALL INPUTI
      CALL ICDFMT(INC,ITEMS)
      IF  (ONCARD('I','MULS',AMULS)) THEN
      WRITE (LPT,2050) AMULS
 2050   FORMAT ('Multiple scattering ',f8.4, 'included')
      ELSE
        AMULS=0
      ENDIF
C   OPEN INPUT FILE
      NAMFIL='.ARR'
      LUNI=NOPFIL(101)
      LUN(1)=LUNI
C4.12 READ THE DATA HEADER
      CALL ARRHED(1)
      CALL SETFC
      CALL SETDC
      LAM2=ALAM2.GT.10E-6
      CALL SETPOL
      CALL EXTINC(1,0.)
      MODE=1
      IF (IEXTYP .NE.0) THEN
        IF (ICDNO(7).NE.0) THEN
          CALL SETABS
          PATHS=.TRUE.
C set record absorption
          MODEHD=MODEHD+1
C  SET MODEA FOR PATHLENGTH
          MODEA=5
        ELSE
        PATHS=.FALSE.
        CALL MESS(LPT,1,'No G cards to give size of crystal: '//
     & 'assuming a constant path of 2mm')
        ENDIF
      ENDIF
C
      CALL MESS(ITO,0,'Output of mean gammas, magnetic structure '//
     & 'factors, both or none?')
      CALL ASK('(G, F, B or N)')
      OUTG = SAYS('G') .OR. SAYS('B')
      OUTF = SAYS('F') .OR. SAYS('B')
      NUNI=0
C   OPEN OUTPUT FILES
      FILNAM=FILNOM(LUN(1))
      L=LENG(FILNAM,10)
      IF (OUTG) THEN
        MESSAG=FILNAM(1:L-4)
        NAMFIL='.MNG '
        NUNI=1
        LOUT(1)=NOPFIL(122)
      ENDIF
C
      IF (OUTF) THEN
        MESSAG=FILNAM(1:L-4)
        NAMFIL='.MSF '
        NUNI=NUNI+1
        LOUT(NUNI)=NOPFIL(122)
      ENDIF
C4.12 Write header on all output files
      CALL HDROUT(LOUT,NUNI,MODEHD)
C
C  CHECK FOR GAMMAS >1
      IF (IOUT .EQ. 100) THEN
        MESSAG='SORCOR.LIS'
        LLPT=NOPFIL(2022)
        FILNAM=FILNOM(ICRYDA)
        WRITE (LLPT,2001) DATIM,FILNAM
2001    FORMAT (/'      **** CORRECTION FACTORS USED IN SORGAM ****',
     &   /'  Job run on ',A24,' crystal data from ',A10
     &   //'     h    k    l    Extcor  Qunit.lam    mod(Q)   Path',
     & '     Lambda/2'/)
      ENDIF
      CALL SETGAM(SOME,LBIG)
C
      CALL CENTRE(LPT,100,'******CALCULATION OF GAMMA AND MAGNETIC '//
     & 'STRUCTURE FACTORS******',100)
      CALL NEWLIN(LPT)
C
C  SET GEOMETRY
      CALL ENTMAG
C WRITE HEADING
      WRITE (LPT,HEADNG)
C
      LCOUNT=9
      CALL STATIS(-1)
C     READ EACH GROUP OF EQUIVALENT REFLECTIONS BEFORE PROCESSING
   25 IEND= INPUAR(1,LUN)
      IF (IEND.NE.0) GO TO 100
      CALL STATIS(1)
C
      FC=REAL(FCALC(FF(1,1)))
      VEC = VCTMOD(0.5,FF(1,1),2)
C IF NO EXTINCTION, DO NOT NEED COEFFICIENTS
      IF (IEXTYP .EQ. 0) GO TO 3
      TM = 2.0
      CALL EXTPAR(FF(1,1),WLGTH,TM)
   3  IQQ=0
      IF (SOME) CALL BIGGAM(K(1,1),IQQ,CSRED,LBIG)
C
C     PROCESSING OF ONE GROUP OF EQUIVALENT REFLECTIONS STARTS HERE
      NRF = 1
      NREF=0
      II = 0
      CALL WTMEAN(G(1),G(2),0,WRK)
   37 L=LL(NRF,1)
      CALL GMEQ(R(II+1,1),H,3,1)
      CALL INDFIX(H,KK)
      IF (L .EQ. 3) GO TO 21
C CALCULATE PATH LENGTH IF DATA ARE AVAILABLE
      IF (PATHS) THEN
        CALL ABMULT(H,ABSC)
        TM = ABSC(3)/ABSC(1)
      ENDIF
C Correct for half wave contamination
      IF (LAM2) THEN
        FACLAM=ALAMB2(H,.FALSE.)
      ELSE
        FACLAM=0.
      ENDIF
      FACLAM=(FACLAM+AMULS)/(FC**2)
      CORLAM=1.+FACLAM
      CALL MAGDIR(H,QLAM,QQ)
      IQ=IQQ
C CASE WHERE GAMMA > 1 BUT NOT ON THIS LAYER
      IF (IQQ.EQ.1 .AND. CSRED.GT. QLAM) IQ=0
      II = II+L
      NRF = NRF+1
C  CALCULATE GAMMA FOR THIS REFLECTION
      G(1)=R(II+1,1)
      G(2)=R(II+2,1)
      CALL FGAMMA(G,IQ,QQ,QLAM,FACLAM)
      G0=G(1)
      G2=G(2)
      IF (IEXTYP .NE. 0) THEN
        CALL GAMEX(R(II+1,1),G,FC,QQ,QLAM,FACLAM,IER)
        EXTFAC=G(1)/G0
C129 Line added to save correcting twice in case of small gamma
        IF (ABS(G(1)).GE. 0.001) G(2)=G2*EXTFAC
      ELSE
        EXTFAC=1
        IER=0
      ENDIF
C STEP PAST MEANS
      II=II+2
      IF (IER.EQ.0) THEN
      IF (IOUT.EQ.100) WRITE (LLPT,2010)KK,EXTFAC,QLAM,QQ,TM,CORLAM
2010  FORMAT (1X,3I5,6F10.4)
      IFUN=2
      CALL WTMEAN(G(1),G(2),IFUN,WRK)
      WRITE (LPT,2011) IEMARK(1),IPMARK(IQ+1),KK,G
2011  FORMAT (1X,2A2,3I5,4F10.5)
      ENDIF
C     GET NEXT EQUIVALENT REFLECTION
      GO TO 37
C
C     HERE AT THE END OF A GROUP
   21 CALL WTMEAN(AMEANX,ESD,-2,WRK)
      FOBS = FC*AMEANX/(VALMUB)
      DFOBS = ABS(FC)*ESD/(VALMUB)
      WRITE (LPT,2007) (K(I,1),I=1,3),AMEANX,ESD,VEC,FC,FOBS,DFOBS
2007  FORMAT ('+',40X,3I5,1X,2F10.6,2F10.4,2F10.5/)
      IF (OUTG) WRITE (LOUT(1),2008) KK,AMEANX,ESD
      IF (OUTF) WRITE (LOUT(NUNI),2009) KK,FOBS,DFOBS
2008  FORMAT (3I5,2F10.7)
2009  FORMAT (3I5,2F10.5)
C     RETURN TO READ NEXT BLOCK
      LCOUNT=LCOUNT+1
      GO TO 25
C
C     DATA ALL FINISHED
 100  STOP
      END
C
C
C
C
C LEVEL 50      PROGRAM SORPOL
      PROGRAM SORPOL
C
C *** SORPOL rewritten by PJB  August 2016 ***
C *********************************************************************
C
C                          S O R P O L
C
C  CALCULATES GAMMA FROM  ARRANGED SNP data
C
C *********************************************************************
C
CC 2D
CH Calculation of gamma and magnetic structure factors from SNP data
C
CD SORPOL calculates the magnetic structure factors from a set of p\scatterd
CD polarisations measurements which have been sorted by ARRSNP. Gamma values are
CD calculated for related polarisation components of equivalent reflections and
CD are averaged together, weighted according to their esd's.
C
CI The crystal data file, which must contain:
CI       S cards giving the symmetry.
CI       A C card with the cell dimensions.
CI       A cards defining the atoms, their positions and isotropic.
CI       temperature factors.
CI       F cards giving the scattering factors
CI       Q cards to define the magnetic structure including a PSYM card
CI         defining the symmetry relationships between the components of
CI         scattered polarisation .
CI optionally:
CI       T cards giving anisotropic temperature factors
CI A file of sorted polarisations as written by ARSNP. Default
CI extension .arr
CI
CO A listing file SORPOL.lis which reports what as read from the crystal data
CO file and gives the calculated \$\gamma\$ values for each set of equivalent
CO polarisation components of each reflection.
CD A mean \$\gamma\$, its esd, \$\sinth\$, the nuclear structure
CO factor and the experimental magnetic structure factor with its esd are
CO calculated from all data for each reflection in the asymmetric unit.
CR On running the program the user is asked for the name of the crystal data
CR file, and the value of the domain ratio, then whether output of \$\gamma's\$
CR and/or magnetic structure factors are required.
CR Finally the name of the data file containing the polarisation measurements
CR is required (default extension .arr).
CR The output files are named with the leaf name of the data file
CR and extension .gam for \$\gamma 's\$ and .msf for magnetic structure
CR factors.
CN The attribution of a sign to gamma (gamma2) derived from the diagonal elements
CN depends on there being at least one valid value (gamma1) from an off diagonal
CN element in the group. Similarly the choice of a plus or minus sign in
CN the quadratic equation for gamma from the off diagonal elements requires
CN at least one valid  diagonal element.
C
      DIMENSION QMAT(3,3),KK(3),
%     & GAMA(2),DGAMA(2),DPOP(%DP*2%),WORK(5,3),
%     & IOPD(%DOMS%),MULDOM(%DOMS%,%DOMS%),RH(3),KR(3),LUN(2),LOUT(2)
      EXTERNAL DOMAG1
      LOGICAL OK,BIGGAM,TESTOV,LATABS,MAGABS,FIRST,NOSIGN
      LOGICAL SAYS
      CHARACTER*10 FILNAM,FILNOM
      COMPLEX FCALC,FC,QPOL(3),QCOS(3,10),FCUNI
      CHARACTER*2 LCOMP(9)
      CHARACTER*160 HEADNG
/IOUNIT/
/REFS/
/MAGSF/
/QCAL/
/STATP/
/SYMMAG/
/SCRACH/
      DATA LCOMP/'XX','XY','XZ','YX','YY','YZ','ZX','ZY','ZZ'/
      DATA VALMUB/.2695/
      DATA HEADNG/'(''   h   k   l  Dom  Pij   Gamma1   DGamma1    Gamma
     &2   DGamma2    Label Index  Mean G  Mean DG   Sth/L   Fnucl   Fobs
     &M    DFobsM'')'/
C
      MODE=0
      CALL PREFIN('SORPOL')
      CALL INPUTI
      CALL ICDFMT(INC,ITEMS)
      CALL SETFCM(DOMAG1)
      CALL MAGCNC
      CALL DOMAG1(2)
      CALL SYMUNI
C
C Get domain ratios etc
      call ask('Give domain populations one for each S-domain in'//
     &'each 180Âº config.')
      call RDNUMS(DPOP,1,20,N,ier)
      IF (IER .NE.0 .OR. N .NE. 2*NDOM) THEN
        CALL ERRMES(1,1,'Error in domain populations')
      ELSE
        WRITE (LPT,2010) (DPOP(i),i=1,2*ndom)
 2010 FORMAT ('Domain Populations read:',12(2f8.3,2x))
      ENDIF
      CALL SYMDOM(IOPD,MULDOM)
C
C Choose type of output
      CALL MESS(ITO,0,'Output of mean gammas, magnetic structure '//
     & 'factors, both or none?')
      CALL ASK('(G, F, B or N)')
      LOUTG=0
      LOUTF=0
      IF (SAYS('G') .OR. SAYS('B')) LOUTG=1
      IF (SAYS('F') .OR. SAYS('B')) LOUTF=LOUTG+1
C Choose input data file
      NAMFIL='.ARR'
      LUNI=NOPFIL(101)
      LUN(1)=LUNI
      SCALE(1)=1.0
C Read and process data header
      CALL ARRHED(1)
      CALL SETDC
C INTERPRET Q PSYM
      CALL INPSYM(IPAR,MAXP,OK)
      IF (OK) THEN
        WRITE (LPT,5001) MAXP,(IPAR(I),I=1,18)
 5001 FORMAT (/I4,' Independent elements: ',18I3)
        CALL PSYMOP(IPAR,MAXP)
      ENDIF
C Report any errors
      CALL ERRMES(0,0,'IN SORPOL')
C Open output files
      NOUT=0
      FILNAM=FILNOM(LUNI)
      L=LENG(FILNAM,10)
      IF (LOUTG.GT.0) THEN
        MESSAG=FILNAM(1:L-4)
        NAMFIL='.MNG '
        NOUT=NOUT+1
        LOUT(LOUTG)=NOPFIL(122)
      ENDIF
      IF (LOUTF.GT.0) THEN
        MESSAG=FILNAM(1:L-4)
        NAMFIL='.MSF '
        NOUT=NOUT+1
        LOUT(LOUTF)=NOPFIL(122)
      ENDIF
C Write header on all output files
      CALL HDROUT(LOUT,NOUT,0)
C
      CALL CENTRE(LPT,100,'******CALCULATION OF GAMMA AND MAGNETIC '//
     & 'STRUCTURE FACTORS******',100)
      CALL NEWLIN(LPT)
C
C WRITE HEADING
      LCOUNT=9
      WRITE (LPT,HEADNG)
C     READ AND AVERAGE POL MATRIX ELEMENTS FOR ONE GROUP OF EQUIVALENT REFLECTIONS
      IENTRY=1
    1 IEND= INPUAR(1,LUN)
      IF (IEND.NE.0) GO TO 100
      CALL STATPA(IENTRY,ILEAVE)
      CALL FLUSH
      IENTRY=ILEAVE
      IF (ILEAVE .EQ.0 ) GO TO 1
      CALL INDFIX(HLABEL,KK)
C CHECK DATA SET BY  STATPA
C      DO 50 IPOL=1,NPOLN
C        WRITE (LPT,5050) KK,IPOLN(IPOL),AMEAN(IPOL),DEV(IPOL)
C   50 CONTINUE
C 5050 FORMAT (3I5,2X,I4,2F9.3)

C
C Process one independent reflection,
C Calculate factors dependent on the reflection indices
C SKIP IF EITHER M OR N ABSENT
      IF (LATABS(HLABEL) .OR. MAGABS(HLABEL)) GO TO 1
      STHL=VCTMOD(0.5,HLABEL,2)
      FC=FCALC(HLABEL)
      FCMOD=CABS(FC)
C FCUNI is needed for the rotation terms
      FCUNI=CONJG(FC)/FCMOD
      FCSQR=REAL(FC*CONJG(FC))
      IF (FCSQR.EQ.0) GO TO 1
      CALL FMCALC(HLABEL,FMCMOD,FMCSQR,FMSQR)
      IF (FMCSQR.EQ.0) GO TO 1
      ANORM=1./(SQRT(FMSQR))
      CALL POLAXE(HLABEL,QMAT)
      CALL INDFIX(HLABEL,KK)
C Get QCOS(3,ndom) the COMPLEX direction cosines of the interaction vector
C for each domain on polarisation axes
      DO 3 N=1,NDOM
        CALL RCMPRD(QMAT,Q(1,N),QPOL,3,3,1)
C Normalise with sqrt(FMSQR)
        CALL CMRSCA(QPOL,QCOS(1,N),ANORM,3,1)
    3 CONTINUE
C PROCESSING OF ONE SET OF POLARISATION ELEMENTS STARTS HERE
C CLEAR WORKING SPACE FOR AVERAGES
C IF NEED TO COLLECT DOMAINS SEPARATELY work(1,2*nd)
      CALL WTMEAN (A,B,0,WORK(1,1))
      CALL WTMEAN (A,B,0,WORK(1,2))
      FIRST=.TRUE.
      BIGGAM=.FALSE.
C*********************************************************************
C START LOOP OVER DATA ENTRIES
      DO 2 IPOL=1,NPOLN
        ISLOT=IPOLN(IPOL)
        IP=MOD(ISLOT-1,MAXP) +1
        ND=1+(ISLOT-1)/MAXP
        ICOMP=NFIND(IP,IPAR,18)
        P=AMEAN(ISLOT)
        DP=DEV(ISLOT)
C        WRITE (LPT,5000) ISLOT,ND,IP,ICOMP,P,DP
C 5000 FORMAT (4I4,2F9.3)
C Get original indices using inverse domain operator
        CALL ROTSYM(HLABEL,RH,ND,-2)
        CALL INDFIX(RH,KR)
C SUM THE QPOL COMPONENTS OVER DOMAINS
      QSUM=0
      QDIF=0
      DO 4 N=1,NDOM
        NTDOM=MULDOM(N,ND)
        YLEN=ABS(QCOS(2,NTDOM))**2
        ZLEN=ABS(QCOS(3,NTDOM))**2
        DFAC=DPOP(N)+DPOP(NDOM+N)
        QSUM=QSUM + DFAC*(YLEN+ZLEN)
        QDIF=QDIF + DFAC*(YLEN-ZLEN)
C        write (lpt,5000)N,NTDOM, ylen,zlen, dfac,qsum,qdif
C 5000 format ('ylen,zlen,dfac,qsum,qdif)'
C     &,2I4,7f10.3)
    4 CONTINUE
C*********************************************************************
C TREAT DIAGONAL ELEMENTS 1=XX,5=YY,9=ZZ
        IF (ICOMP.EQ.1 .OR.ICOMP.EQ.5 .OR. ICOMP .EQ.9) THEN
C*********************************************************************
          IAX=(ICOMP+3)/4
C IF NEED TO COLLECT DOMAINS SEPARATELY IWRK=(2*ND)-1
          IWRK=2
          ANUM=1-P
          IF (IAX.EQ.1) THEN
            ADEN=QSUM*(1+P)
            DNUM=2*QSUM
          ELSE IF (IAX.EQ.2) THEN
            ADEN=P*QSUM - QDIF
            DNUM=QSUM - QDIF
          ELSE IF (IAX.EQ.3) THEN
            ADEN= P*QSUM + QDIF
            DNUM=QSUM+QDIF
          ENDIF
          IF (TESTOV(ANUM,ADEN) .OR. ANUM/ADEN .LT. 0) THEN
            IF (ANUM .LT. 0  .AND. ANUM .GT. -2*DP) THEN
              GAM=0
              DGAM=ABS(DP/aden)
            ELSE
              WRITE (LPT,1002) KK,ND,LCOMP(ICOMP),ANUM,ADEN
              GO TO 2
 1002 FORMAT (3I4,I5,A4,'  Indeterminate gamma;  gamma**2 < 0:'
     &' numerator = ',F8.3,' denominator =',F8.3)
            ENDIF
          ELSE
            GAM=SQRT(ANUM/ADEN)
            BIGGAM=BIGGAM .OR. (GAM.GT.1)
            DGAM=0.5*DP*ABS(DNUM/(GAM*ADEN*ADEN))
          ENDIF
          WRITE (LPT,1003) KR,ND,LCOMP(ICOMP),GAM,DGAM
 1003 FORMAT (3I4,I5,A4,20X,3F9.3)
C*********************************************************************
C  ROTATION ELEMENTS 2=XY,3=XZ
        ELSE IF (ICOMP.EQ.2 .OR. ICOMP.EQ.3) THEN
C*********************************************************************
          IAX=5-ICOMP    !3,2
          IWRK=1
          QCROSS=0
          DO 5 N=1,NDOM
            NTDOM=MULDOM(ND,N)
            DFAC=DPOP(NTDOM)-DPOP(NDOM+NTDOM)
C minus because using conjg(FC)*Q
            CROSS=-IMAG(FCUNI*(QCOS(IAX,NTDOM)))
            QCROSS=QCROSS+(DFAC*CROSS)
    5     CONTINUE
          IF (ABS(QCROSS) .lt. 0.01) THEN
            WRITE (LPT,1004) KK,ND,LCOMP(ICOMP),QCROSS
 1004  FORMAT (3I4,I5,A4,'  Polarisation  does not depend on gamma: ',
     &'Qcos =',F8.4)
            GO TO 2
          ENDIF
          PU=P/QCROSS
           IF ((PU**2)*QSUM .GT. 1.) THEN
            WRITE (LPT,1005)KR,ND,LCOMP(ICOMP), P, QCROSS,QSUM
 1005 FORMAT (3I4,I5,A4,'  Indeterminate gamma (imaginary roots):',
     & ' Qsum*(P/Qcross)**2 >1: P=',f8.3,',  Qcross =',F8.3,
     &',  qsum =',F8.3)
            GO TO 2
          ENDIF
          IF (ABS(PU) .LT. 0.02 ) THEN
C CASE OF SMALL GAMMA
            GAMA=0.5*PU
            DGAMA=0.5*DP/QCROSS
          ELSE
          ROOT=SQRT(1-qsum*(PU**2))
            IF (BIGGAM) THEN
              GAM=(1 + ROOT)/PU
            ELSE
              GAM= (1 - ROOT)/PU
           ENDIF
          ENDIF
          GSQR=GAM**2
          DGAM=ABS((DP*(1+GSQR)**2)/(2*QCROSS*(1-2.*GSQR)))
            WRITE (LPT,1000) KR,ND,LCOMP(ICOMP),GAM,DGAM,BIGGAM
 1000 FORMAT (3I4,I5,A4,2F9.3,2x,L)
C*********************************************************************
C SKIP ALL OTHERS
        ELSE
C*********************************************************************
          GO TO 2
        ENDIF
        CALL WTMEAN(GAM,DGAM,2,WORK(1,IWRK))
    2 CONTINUE
C Get mean values
      CALL WTMEAN(GAMA(1),DGAMA(1),-1,WORK(1,1))
      CALL WTMEAN(GAMA(2),DGAMA(2),-1,WORK(1,2))
C CHOOSE THE SIGN
      NOSIGN=(WORK(4,1).EQ.0)
        IF (.NOT.NOSIGN) GAMA(2)=SIGN(GAMA(2),GAMA(1))
C MEAN OF 1 AND 2
      CALL WTMEAN(GAMA(2),DGAMA(2),0,WORK(1,3))
      CALL WTMEAN(GAMA(1),DGAMA(1),2,WORK(1,3))
      CALL WTMEAN(GAMA(2),DGAMA(2),2,WORK(1,3))
      CALL WTMEAN(GAM,DGAM,-1,WORK(1,3))
      FOBS=GAM*FCMOD
      DFOBS=DGAM*FCMOD*VALMUB
      IF (NOSIGN) THEN
        WRITE (LPT,1006) (GAMA(IP),DGAMA(IP),IP=1,2),KK,GAM,DGAM,STHL,
     &  FCMOD,FOBS,DFOBS,'+/-'
 1006 FORMAT ('      Mean Values',4X,2F9.3,2X,2F9.3,3X,3I4,3F9.3,3F9.4,
     &1X,A3)
        IF (LOUTG .GT.0) WRITE (LOUT(LOUTG),1007) KK,GAM,DGAM,'+/-'
        IF (LOUTF .GT.0) WRITE (LOUT(LOUTF),1008) KK,STHL,FOBS,DFOBS,
     &'+/-'
 1007 FORMAT (3I5,2F10.4,4X,A3)
 1008 FORMAT (3I5,3F10.4,4X,A3)
      ELSE
        WRITE (LPT,1006) (GAMA(IP),DGAMA(IP),IP=1,2),KK,GAM,DGAM,STHL,
     &  FCMOD,FOBS,DFOBS
        IF (LOUTG .GT.0) WRITE (LOUT(LOUTG),1007) KK,GAM,DGAM
        IF (LOUTF .GT.0) WRITE (LOUT(LOUTF),1008) KK,STHL,FOBS,DFOBS
      ENDIF
      WRITE (LPT,1007)
C GO TO READ NEXT BLOCK
      GO TO 1
C
C     DATA ALL FINISHED
 100  STOP
      END
C
C
C
C
C LEVEL 50      PROGRAM SXDABS
      PROGRAM SXDABS
C
C *** SXDABS written  by PJB and JBF June 92 ***
C
C *****************************************************************************
C
C                            S X D A B S
C
C TO READ .REF FILES WITH HKL, IOBS, STDEV, LAMBDA AND SXD DIFFRACTOMETER
C ANGLES AND APPLY ABSORPTION CORRECTIONS IF G CARDS ARE GIVEN AND CALCULATE
C MEAN PATH LENGTH FOR EXTINCTION CALCULATION AT REFINEMENT STAGE.
C
C *****************************************************************************
C
      DIMENSION H(3),FSQR(2),ABSC(3),TANG(5)
      LOGICAL ABSENT
      CHARACTER*160 HEDING
/ABSDAT/
/BRAGG/
/CARDRC/
/DGEOM/
/IOUNIT/
/REFS/
/SCRACH/
/STATS/
      DATA HEDING/'(''  Ref No '',4X,''h'',7X,''k'',7X,''l'',10X,''Fs
     &qCor'',8X,''DFsq'',8X,''AbsCor'',6X,''Lambda'',8X,''Tbar''/)'/
C
      CALL PREFIN('SXDABS')
      LH=2
      NAMFIL='.REF'
      LUNI=NOPFIL(101)
      NAMFIL='.SXD'
      LOUT=NOPFIL(102)
      CALL SYMOP
      CALL RECIP
C READ TITLE
      READ(LUNI,12)ICARD
   12 FORMAT(A80)
      WRITE (LPT,13)ICARD
   13 FORMAT (' ',A80)
C  READ UBM
      CALL SXDUBM
      CALL SETABS
C SAVE THE ABSORPTION COEFFICIENT AT THE STANDARD WAVELENGTH
      AMU1=AMU
C FORCE ABSORPTION + PATHLENGTH INTEGRAL
      MODEA=5
C
      WRITE (LPT,2007)
2007  FORMAT ('1')
      WRITE (LPT,HEDING)
      LINO=3
      RADFAC=RADIAN(1.0)
C
C SKIP HEADER LINE
      READ (LUNI,12)
C
    1 READ (LUNI,2010,END=100) IREC,H,FSQR,WLGTH,TANG
 2010 FORMAT(I8,3F8.3,F12.2,F10.2,F10.4,5F8.2)
      AMU=ABSFAC(WLGTH,AMU1)
      CALL GMSCA(TANG,DIFANG,RADFAC,5,1)
      IF (IEND.NE.0) GO TO 100
      CALL ABMULT(H,ABSC)
      FAC=1./ABSC(1)
      CALL GMSCA(FSQR,FSQR,FAC,2,1)
C WRITE OUT ANSWERS
      WRITE (LOUT,2006) IREC,H,FSQR,WLGTH,ABSC(3)
2006  FORMAT (I8,3F8.3,2F10.2,2F10.5)
      WRITE (LPT,2005) IREC,H,FSQR,FAC,WLGTH,ABSC(3)
2005  FORMAT (1X,I8,3F8.3,2X,2F12.3,2X,3F12.4)
      GO TO 1
C
  100 STOP
      END
C
C
C
C
      FUNCTION ABSFAC(WL,AMU)
C
      DATA STANWL/1.7979/
C
      ABSFAC=AMU*WL/STANWL
      RETURN
      END
C
C
C
C
      SUBROUTINE SXDUBM
C
C *** SXDUBM BY PJB ***
C
C
      DIMENSION V(9)
      DIMENSION H(9)
/DGEOM/
/DREAD/
/CARDRC/
/IOUNIT/
/SCRACH/
C
C
      IGEOM=12
      WRITE (LPT,1999)
 1999 FORMAT (' Orientation for these data')
C
C
      J=1
C Skip header line
      READ (LUNI,10)
      DO 1 I=1,3
      READ(LUNI,10) ICARD
   10 FORMAT (A80)
      CALL RDNUMS(V(J),1,3,NUM,IER)
      IF (IER.NE.0 .OR. NUM.NE.3) CALL ERRMES(1,0,
     &'reading UB matrix')
      J=J+3
    1 CONTINUE
      UM(1)=V(4)
      UM(2)=-V(1)
      UM(3)=V(7)
      UM(4)=V(5)
      UM(5)=-V(2)
      UM(6)=V(8)
      UM(7)=V(6)
      UM(8)=-V(3)
      UM(9)=V(9)
  107 FORMAT (2('D UMAT',3F10.6/),'D UMAT',3F10.6)
      CALL GMEQ(UM,H,9,1)
      CALL TRANSQ(H,3)
      DO 4 I=1,7,3
   4  CALL ORTHO(H(I),UM(I),1)
      CALL TRANSQ(UM,3)
C
      CALL TRINV3(UM,D)
      WRITE (LPT,2000) D
2000  FORMAT (/' Determinant of UB matrix is ',F12.6)
      IF (ABS(D-1.) .GE. 10.E-2) CALL ERRMES(1,0,
     & 'cell dimensions and UB matrix not compatible')
   11 IF (ABS(D-1.) .LT. 1.E-4) GO TO 12
      CALL GMEQ(UM,H,1,9)
      CALL TRINV3(UM,D)
      DO 14 I = 1,9
   14 UM(I) = 0.5*(H(I)+UM(I))
      GO TO 11
C
C UB MATRIX NOW OK:
   12 WRITE (LPT,2002) UM
2002  FORMAT (/' Matrix between diffractometer axes and ',
     & 'orthogonal crystallographic axes is:'/3(12X,3F10.5/))
 100  RETURN
C
      END
C
C
C
C
C LEVEL 50      PROGRAM SXDEXF
      PROGRAM SXDEXF
C
C *** SXDEXF by PJB 02-Nov-1994 ***
C
C *****************************************************************************
C
C                            S X D E X F
C
C TO CALCULATE EXPERIMENTAL STRUCTURE FACTORS FROM ARRANGED INTENSITIES
C FOR SXD DATA  AND WRITE A FILE WITH THE 4 EXTINCTION PARAMETERS
C
C *****************************************************************************
C
CC 2D
CH To calculate structure factors and extinction constants from arranged SXD
CH data
CD For SXD data, SXDEXF reads the file of reflection intensities written by
CD by ARRNGE or ARRINC and calculates the structure factor,its standard
CD deviation and the four extinction constant of the Becker Coppens extinction
CD correction for the fundamental reflections only. Two output modes are
CD possible: either all fundamental reflections are treated individually or
CD groups of equivalent reflections may be selected. The first mode provides an
CD output which can be read directly by structure factor least squares programs
CD and the second is to allow extinction to be treated by trying to make
CD equivalent reflections have equal intensities.
C
CI The crystal data file must contain:
CI     The cell dimensions on a C card
CI     An E card indicating which extinction model is to be used
CI     Symmetry information on S cards
CI     An I DTYP card indicating the format of the data which were arranged
CI              this should be DTYP 5 ie SXD data
CI     Possibly a Q PROP card giving the propagation vector if this is not zero
C
CO A listing file: SXDEXF.LIS which reports how the crystal data file was
CO interpreted and gives a list of the calculated structure factors, their
CO standard deviations and the 4 extinction constants. In group mode groups of
CO equivalent reflections are separated by empty lines.
CO A file with extension .SFE designed to be read by a least squares program
CO with L MODE 5. In group mode the groups of equivalents are separated by
CD lines containing just the labelling indices of the group. This file is
CD written with FORMAT (3I5,6F10.4)
C
CR On running the program the user is asked for the name of the crystal data
CR file, and then to type "g" if group mode is wanted.
CR After this the names of the input and output data files should be given in
CR response to the queries. The former should have the format written by ARRNGE
CR or ARRINC (default extension .ARR), and the latter is described under output
CR and has default extension .SFE.
C
      DIMENSION LUN(2),SUMS(3)
      LOGICAL GROUPS,SAYS
      CHARACTER*100 HEDING
/CELPAR/
/EXTN/
/IOUNIT/
/REFS/
/SATELL/
/SCRACH/
      DATA HEDING/'(5X,''h'',4X,''k'',4X,''l'',5X,''Fobs'',6X,''DFobs'',
     & 10X,''Extinction Coefficients'',10X,''Input''/)'/
C
      CALL PREFIN('SXDEXF')
      CALL SYMOP
      CALL RECIP
      CALL EXTINC(1,F)
C  READ FROM STREAM 1 ONLY
      ISTRM=1
      CALL INPUTI
      CALL ICDFMT(INC,ITEMS)
      CALL ERRMES(0,0,'of SXDEXF')
      CALL MESS(ITO,0,
     & 'Type G to treat groups of equivalent reflections')
      CALL ASK('for internal determination of extinction')
      GROUPS= SAYS('G')
      CALL GMZER(SUMS,1,3)
      SCALE(1)=1.
      SCALE(2)=1.
      LH=2
      NAMFIL='.ARR'
      LUN(ISTRM)=NOPFIL(101)
      NAMFIL='.SFE'
      LUNO=NOPFIL(102)
      CALL NEWPAG(LPT)
      WRITE (LPT,HEDING)
      LINO=3
C
    1 IEND= INPUAR(ISTRM,LUN)
      IF (IEND.NE.0) GO TO 2
C SKIP MAGNETIC OR SUPERSTRUCTURE REFLECTIONS
      IF (JJ(NR,ISTRM) .GT.100) GO TO 1
C IF COLLECTING GROUPS SKIP SINGLE MEASUREMENTS
      IF (GROUPS .AND. NR.LT.3 .AND. (LL(1,ISTRM) .LT. ITEMS+4)) GO TO 1
C GET SINTHETA/LAMBDA FOR THIS GROUP
      STL=VCTMOD(0.5,R(1,ISTRM),2)
      IR=1
      II=0
    3 L=LL(IR,ISTRM)
      IF (L.EQ.3) GO TO 4
      IE=II+L
      IB=II+4
      CALL INDFIX(R(II+1,ISTRM),K(1,ISTRM))
      DO 5 I=IB,IE,ITEMS
      IF (R(I,ISTRM).LT.0) GO TO 5
      SUMS(1)=SUMS(1)+R(I,ISTRM)
      SUMS(2)=SUMS(2)+R(I+1,ISTRM)
      SUMS(3)=SUMS(3)+1.
      SINTH=STL*R(I+2,ISTRM)
      TM = R(I+3,ISTRM)
      ALAM3=R(I+2,ISTRM)**3
      CALL SINCOS(SINTH,COSTH,'SXDEXF')
      SINTH = 2.*SINTH*COSTH
      COSTH = (2.*COSTH*COSTH) - 1.
      CEXT(1) = ALAM3*TM/(SINTH*V(1)**2)
      CEXT(1) = 1000*CEXT(1)
      CEXT(2) = R(I+2,ISTRM)/SINTH
C EXTINCTION FOR LORENTZIAN DISTRIBUTION
      IF (LOREN) THEN
        CEXT(3) = .025 + .285*COSTH
        CEXT(4) = 0.15 - 0.2*(0.75-COSTH)**2
      ELSE IF (GAUSS) THEN
C GAUSSIAN DISTRIBUTION
        CEXT(3) = 0.58+0.48*COSTH+0.24*(COSTH**2)
        CEXT(4) = 0.02-0.025*COSTH
      ENDIF
C  CALCULATE F FROM F**2
      F=SQRT(R(I,ISTRM))
      DF=SQRT(R(I,ISTRM)+R(I+1,ISTRM))-F
      CALL TESTP(LPT,LINO,1,HEDING,LH)
      WRITE (LPT,15) (K(J,ISTRM),J=1,3),F,DF,(CEXT(J),J=1,4),ISTRM
   15 FORMAT (1X,3I5,6F10.4,2X,I4)
      WRITE (LUNO,16) (K(J,ISTRM),J=1,3),F,DF,(CEXT(J),J=1,4),ISTRM
   16 FORMAT (3I5,6F10.4,I5)
    5 CONTINUE
      IR=IR+1
C SKIP THE TWO ENTRIES LEFT FOR THE MEANS
      II=IE+2
      GO TO 3
    4 IF (GROUPS) THEN
        WRITE (LPT,16)
        CALL INDFIX(R(II+1,ISTRM),K(1,ISTRM))
        WRITE (LUNO,16) (K(I,ISTRM),I=1,3)
      ENDIF
      GO TO 1
C
C  END OF DATA GIVE STATITSICS
    2 R1=100.*SUMS(2)/SUMS(1)
      AMEANF=SUMS(1)/SUMS(3)
      WRITE (LPT,2000) NINT(SUMS(3)),R1
      WRITE (ITO,2000) NINT(SUMS(3)),R1
      WRITE (LPT,2014) AMEANF
      WRITE (ITO,2014) AMEANF
2000  FORMAT (/' The R on Fsqrd for',I6,' measurements, based on ',
     & 'counting statistics is',F7.2,'%'/)
2014  FORMAT (' The average F squared over all measured reflections is'
     & ,F8.2)
      STOP
      END
C
C
C
C
C LEVEL 50      PROGRAM SYMTST
      PROGRAM SYMTST
C
C *** SYMTST by JCM ***
C
C ******************************************************************************
C
C                             S Y M T S T
C
C ******************************************************************************
C
C PROGRAM REQUIRING ONLY S AND C CARDS AS INPUT, TO CHECK THAT THE BASIC
C SYMMETRY ROUTINES OF CCSL ARE STILL WORKING.
C
C THE NUMBER OF REFLECTIONS FOUND SHOULD BE 80 USUALLY, OR 200 & SOMETHING
C FOR THE HEXAGONAL CASES, WHEN USING STANDARD DATA FROM THE DATASET "PG"
C
      CHARACTER *1 ISPCE,ISTAR,IC
      LOGICAL NOMORE,ISPABS
      DIMENSION H(3),K(3,1000),SINTH(1000),IPNT(1000)
/IOUNIT/
      DATA ISPCE,ISTAR/' ','*'/
C
      CALL PREFIN('SYMTST')
      S=0.2715
      CALL SYMOP
      CALL OPSYM(1)
      CALL OPSYM(2)
      CALL RECIP
      CALL SYMUNI
      CALL SETGEN(S)
      CALL ERRMES(0,0,' ')
C
      NSUM=0
      N=0
      CALL MESS(LPT,3,'    No.    h   k   l    Mult     s')
   2  CALL GETGEN(H,NOMORE)
      IF (NOMORE) GO TO 5
      N=N+1
      NSUM=NSUM+MULBOX(H)
      SINTH(N)=VCTMOD(0.5,H,2)
      CALL INDFIX(H,K(1,N))
      GO TO 2
C
   5  CALL SORTX(SINTH,IPNT,N)
      DO 3 I=1,N
      J=IPNT(I)
      CALL INDFLO(H,K(1,J))
      IC=ISPCE
      IF (ISPABS(H)) IC=ISTAR
      M=MULBOX(H)
      WRITE (LPT,2001) IC,I,(K(L,J),L=1,3),M,SINTH(J)
2001  FORMAT (' ',A1,I5,2X,3I4,2X,I5,F10.5)
   3  CONTINUE
      WRITE (LPT,100)  NSUM,S
 100  FORMAT (/'  Total number of reflections inside sphere',
     & '=',I4/' S max=',F10.4)
      STOP
      END
C
C
C
C
C LEVEL 50      PROGRAM T2LSQ
      PROGRAM T2LSQ
C
C *** T2LSQ by JCM 24 Nov 86 ***
C
C ******************************************************************************
C
C                         T 2 L S Q
C
C ******************************************************************************
C
C
C T2LSQ TO REFINE THE 6 CELL PARAMETER QUADRATIC PRODUCTS IN RECIPROCAL SPACE,
C A* B* C* D* E* F* AS IN RIETVELD PR, AND ZERO, A POSSIBLE ZERO POINT
C IN THE EXPRESSION FOR 2THETA DEGREES.
C
C THE OBSERVATIONS ARE VALUES OF 2 THETA DEGREES
C
C THE PROBLEM IS SET UP TO HAVE:
C ONE FAMILY (NO STRUCTURE FACTORS=NO FAMILY 2)
C WITHIN THAT ONE FAMILY, 1 GENUS
C WITHIN THAT GENUS, 7 SPECIES
C
C GENUS 1 OF FAMILY 1 REALLY HAS 'NO' NAME
C SPECIES NAMES ARE A* B* C* D* E* F* ZERO
C
C SUBROUTINE ENDING "T2" ARE INCLUDED:
C         APSHT2   (APPLY SHIFTS)
C         NWINT2   (NEW INPUT CRYSTAL DATA)
C         CALCT2   (CALCULATE FUNCTION AND ITS DERIVATIVES)
C         PARSDS   (SET UP PARAMETERS)
C
C STLST2 (BY ANALOGY TO STLSFW, STLSSF ETC) IS SO SMALL THAT IT IS INCLUDED IN
C MAIN, RATHER THAN BEING MADE A SEPARATE SUBROUTINE
C
C THE TRIAL CELL PARAMETERS ARE ON A "C" CARD.
C THE ZERO POINT IS ON A L ZERO CARD, AND THE WAVELENGTH LAMBDA ON
C AN L WVLN CARD
C THERE IS THE POSSIBILITY OF DRIVING IT USING I CARDS.
C ACCEPTABLE WORDS ON THE I CARD ARE:
C   NCYC    NO. OF CYCLES
C   CYC1    SERIAL NO OF FIRST CYCLE
C   MCOR    MAXIMUM PERCENTAGE CORRELATION TO PRINT
C   PRIN    HOW OFTEN TO PRINT OBS/CALC LIST
C
      CHARACTER *4 IT2WRD(7)
      LOGICAL PRINT,PRNCYC,ONCARD
      LOGICAL DFTRUE,LDUMMY
      EXTERNAL DFTRUE,PARRUN,VARST2,LDUMMY
      DIMENSION ALSQ(50),IT2SPC(3,7),K(3),H(3)
/DGEOM/
/CARDRC/
/IOUNIT/
/NEWOLD/
/OBSCAL/
/PRBLEM/
/REFINE/
/SCRACH/
/ZEROPT/
      DATA IT2WRD/'A*','B*','C*','D*','E*','F*','ZERO'/
      DATA IT2SPC/1,1,1, 1,1,2, 1,1,3, 1,1,4, 1,1,5,
     & 1,1,6, 1,1,7/
C
      MATSZ=50
C SET UP PROBLEM:
      NFAM=1
      NGENS(1)=1
      NSPC(1)=7
C
C SPECIES TYPES OF GENERA IN F1 (0=NONE, -VE=INTEGERS, +VE=NAMES)
      LF1SP(1)=7
C
C WORDS RELEVANT TO THIS PROBLEM FROM DATA INTO COMMON:
      CALL LSETUP(7,IT2SPC,IT2WRD)
      CALL PREFIN('T2LSQ')
      MESSAG='2theta observations file'
      LUNI=NOPFIL(111)
      CALL NEWCD
C
C READ SYMMETRY AND CELL:
      CALL SYMOP
      CALL OPSYM(1)
      CALL RECIP
C
C SET '2THETA DATA FOR CELL PARAMETER AND ZERO TYPE LSQ':
      IREF=-3
      CALL CENTRE(LPT,3,'Least Squares Refinement',80)
      CALL CENTRE(LPT,0,'2theta values for Cell parameters & Zeropoint')
      IF (.NOT. ONCARD('L','ZERO',ZERO)) CALL ERRMES(3,0,'L ZERO')
C
      WRITE (LPT,2021) ZERO
2021  FORMAT (/' Zero point =',F10.4)
      IF (.NOT. ONCARD('L','WVLN',WLGTH)) CALL ERRMES(3,0,
     & 'L WVLN')
C
      WRITE (LPT,2020) WLGTH
2020  FORMAT (/' Wavelength =',F10.4)
      IF (INREAD(9) .GT. 0) CALL INPUTI
      CALL IICD1
C
C SET UP VARIABLES AND BASIC VARIABLES:
      CALL PARSDS
      CALL VARMAK(DFTRUE,PARRUN,VARST2,LDUMMY)
C
C
C CYCLE:
      DONE=.FALSE.
      DO 1 ICYC=NCYC1,LASTCY
C IS PRINTING OF OBS AND CALC LIST REQUESTED THIS CYCLE?
      PRINT=PRNCYC(1)
      IF (PRINT) THEN
        CALL MESS(LPT,2,'Observed and calculated values :')
        CALL MESS(LPT,0,'   h   k   l        Obs 2 theta     '//
     &  'Calc 2 theta  Diff        Error')
      ENDIF
C
C INITIALISE R FACTOR SUMS:
      CALL RFACS(1)
C
C SET UP TRIANGULAR MATRIX POINTERS, CLEAR OUT LSQ MATRIX AND RHS:
      CALL MATSET(ALSQ,MATSZ)
C
C COUNT USED OBSERVATIONS (THERE IS NOT AT PRESENT ANY WAY OF NOT USING ONE)
      NOBS=0
   5  READ(LUNI,1000,END=3) K,OBS,DOBS
1000  FORMAT (3I5,2F12.4)
      CALL INDFLO(H,K)
      CALL CALCT2(H)
C CALCT2 FORMS GCALC,  PUTS DG/DV INTO DERIVV FOR ALL VARIABLES, AND SETS UP
C ALL REQUIRED QUANTITIES IN OBSCAL FOR SUBSEQUENT CALLS OF MATTOT AND RFACS
C
C MAKE BASIC VARIABLE DERIVATIVES FROM VARIABLE DERIVATIVES:
      CALL RELATE
      DIFF = OBS - GCALC
C
C UNIT WEIGHTS IF DOBS NOT READ - OTHERWISE WEIGHT = 1/DOBS SQRD:
      IF (DOBS .EQ. 0.) SQRTWT=1.
      IF (DOBS .NE. 0.) SQRTWT=ABS(1./DOBS)
      WT=SQRTWT*SQRTWT
      WDIFF=SQRTWT*DIFF
C
      IF (PRINT) WRITE (LPT,2003) K,OBS,GCALC,DIFF,DOBS
2003  FORMAT (' ',3I4,2(5X,F12.5),F10.5,F11.5)
C
C ADD IN TO R FACTORS:
      CALL RFACS(2)
C
C ADD DERIVATIVES IN TO LSQ MATRIX:
      CALL MATTOT(ALSQ,MATSZ)
      NOBS=NOBS+1
C NEXT OBSERVATION:
      GO TO 5
C
C HERE ON NO MORE OBSERVATIONS - REWIND OBSERVATIONS FILE AND PRINT R FACTORS:
   3  REWIND LUNI
      CALL RFACS(3)
C
C INVERT MATRIX, CALCULATE SHIFTS AND ESD'S; APPLY AND PRINT:
      CALL MATINV(ALSQ,MATSZ)
      CALL MATSHF(ALSQ,MATSZ)
      CALL APSHT2
C PRODUCE NEW INPUT DATA FILE ON PENULTIMATE CYCLE:
      IF (DONE) GO TO 39
      DONE=(AMAXSH.LT.CONV .OR. ICYC.EQ.LASTCY-1 .OR. NCYC.EQ.1)
      IF (DONE) CALL NWINT2
   1  CONTINUE
C
  39  CALL MATCOR(ALSQ,MATSZ)
 100  STOP
      END
##ENDMAI
##PIG
C
C            A L T E R N A T I V E   P I G L E T S
C
C
C
C LEVEL 49 GRAPHIC  PIGORIG
C
CH The original base piglet, probably now (2017) obsolete but
C includes useful comment not included with the current versions

       SUBROUTINE PIGLET(X,Y,N)
C
C *** PIGLET updated by JCM 27 Jun 86 ***
C
CX
CC 14C
CH A complete set of device-specific plotting commands.
CA On entry X and Y are plotter coordinates
CA          N indicates the function required:
CA
CA N=0  Called at very start of a plotting job, to set up physical things like
CA       plotter width in cms, plotter units (as FROMCM which converts from cms
CA       to plotter units).  Also sets up some transformation matrices and
CA       initialises quantities for transformations.
CD
CA N=2   Move the pen to the point X,Y (in the plotter's own coordinates)
CA or          N=2 moves with pen down (i.e. draws)
CA N=3         N=3 moves with pen up.
CA             There was originally an N=1 meaning move with the pen in the
CA             state it was last time.  Not every library implements this,
CA             so although CCSL uses it, it is now done by the routines which
CA             call PIGLET.
CD
CA N=-1 -  -15 Changes the colour of the ink in the pen
CA             Cokours defined in /PGNUMS/
CA             (These may be altered, or others added, as the user wishes)
CD
CA The remaining values of N carry out whatever special actions the local
CA plotter software needs to make when starting or finishing various stages.
CD
CD The complete plotter output produced by the whole job is called here a
CD "plot".  The plot may be made up of various "pictures" such as layers of
CD a Fourier map; or it may be just one graph. Within a "picture" there are
CD various boxes of explanatory text and the main graphic object such as a
CD "map" for fouriers or a "graph" from PLOTO
CD
CD Most plotter software libraries require that a certain routine be called to
CD start a plot, and some also require another routine to be called to finish
CD a plot (say, to move the pen clear of the plot ready for the next job).
CD There is no obvious need for any special action on an actual plotter at the
CD start and finish of one "picture", but if a Tektronix or other vdu is used,
CD there will be only one "picture" on the screen at once (remember several
CD "pictures"=1 "plot"), so special actions will be needed to start (say, clear
CD screen) and finish (say, ask user if he wants a hard copy) a picture.
CD
CD To accomplish these actions large values of n are assigned as follows:
CD N=999 Start "plot" (which will be X cms wide and Y cms high)
CD N=-999 Finish "plot" (which was X cms wide and Y cms high)
CD N=888 Start "picture" (which will be X cms wide and Y cms high)
CD N=-888 Finish "picture" (which was X cms wide and Y cms high)
C
CD Sets PMTRIX number 1: the CCSL to hardware transformation
C
CO When requested, sends output to graphical device.
CN Contains all plotting commands which are specific to whatever machine (and
CN which output device) is being used.  These are believed to be a bare
CN minimum.  Whenever a new plotter (specifically a new plotter software
CN library) is implemented on the system a specific version of this routine
CN must be made.
CN
CN There are other versions of PIGLET in CCSL for specific output devices.
C
      DIMENSION PTEMP(2,3)
/PGNAMS/
/PGNUMS/
/PLTRAN/
/PLODAT/
/SCRACH/
C
      IF (N .NE. 0) GO TO 3
C INITIAL ENTRY - SET UP PLOTTER WITHOUT YET KNOWING WHAT WE WISH TO PLOT:
C
C PLOTTER CONVENTIONS - FIRST SET UP DEFAULTS COMMON TO ALL:
      CALL PINITL
C CONVERSION MATRIX WHICH TAKES (X,Y) IN CCSL UNITS INTO (X',Y') IN YOUR
C ACTUAL PLOTTER UNITS.  SEE THE ANNOTATION FOR SUBROUTINE PLCONV FOR
C DEFINITIONS.  THE DEFAULT HERE IS THE UNIT TRANSFORMATION.
      CALL GMZER(PTEMP,2,3)
      CALL GMUNI(PTEMP,2)
C
C FROMCM POSITIVE USED TO INDICATE PLOTTER NOT VDU:
CS RALC RUTHERFORD VAX PLOTTER WORKS IN SAME ORIENTATION AS CCSL EXPECTS,
CS RALC  BUT IN INCHES.
CS RAL      FROMCM=1./2.54
CS RAL      PAPERW=28.
C
CS PICKYC THE 3084 PLOTTER HAS ITS ORIGIN THE OTHER SIDE, WITH X AND Y REVERSED,
CS PICKYC  AND IT WORKS IN MILLIMETRES.
CS PICKY      FROMCM=10.
CS PICKY      PAPERW=30.
CS PICKY      PTEMP(1,1)=0.
CS PICKY      PTEMP(2,1)=1.
CS PICKY      PTEMP(1,2)=-1.
CS PICKY      PTEMP(2,2)=0.
CS PICKY      PTEMP(1,3)=PAPERW
CS PICKY      PTEMP(2,3)=0.
C
C SET UP CCSL TO PLOTTER TRANSFORMATION:
      CALL GMSCA(PTEMP,PTEMP,ABS(FROMCM),2,3)
      CALL PLTRIN(PTEMP,2,1)
C
      GO TO 100
C
   3  IF (IABS(N) .GT. 500) GO TO 1
      IF (N .LT. 0) GO TO 2
C
C BASIC PEN MOVING: 2=DOWN, 3=UP
CS LAX      IF ((N .EQ.2) .OR. (N .EQ. 3)) GO TO 4
CS PICKY      IF (N .EQ. 2) GO TO 4
CS PICKY      IF (N .EQ. 3) GO TO 5
      CALL ERRMES(-1,0,'call of PIGLET with small N not 2 or 3')
C
CS PICKYC INSTALLATION DEPENDENT LIBRARY CALLS FOR CURVE PLOTTING ON 3084
CS PICKYC 'DRAW TO'
CS PICKY   4  CALL GLDT2S(X,Y)
CS PICKY      GO TO 100
CS PICKYC 'MOVE TO'
CS PICKY   5  CALL GLMT2S(X,Y)
C
CS LAX   4  CALL PLOT(X,Y,N)
      GO TO 100
C
C PEN COLOUR CHANGE:
CS PICKY   2  CALL GLDV2S(-N)
CS LAX   2  CALL NEWPEN(-N)
      GO TO 100
C
C START/FINISH ROUTINES:
C INPUT X AND Y WERE IN CCSL UNITS - PUT INTO PLOTTER:
   1  CALL PLCONV(X,Y,2,XX,YY,1)
      IF (IABS(N) .NE. 999) GO TO 100
C ONLY "START/STOP PLOT" IS RELEVANT HERE AT PRESENT:
CS PICKY      IF (N .EQ. -999) GO TO 9
CS PICKYC INITIALISE PACKAGE:
CS PICKY      CALL GLPC2S
CS PICKYC TIE UP PLOTTING WITH JCL ITEM LABELLED 'PLOT';  ASK FOR PAPER WHICH IS
CS PICKYC 300 MMS WIDE (MAXIMUM 30 CMS AS SET IN PAPERW IN ROUTINE FRIG AND ALREADY
CS PICKYC CHECKED) AND MAX 6 METRES LONG (NO CHECK AT PRESENT)
CS PICKYC
CS PICKYC THE LAST PARAMETER IS THE RATIO OF THE LENGTH TO THE WIDTH
CS PICKY      CALL GLPS2S('PLOT    ',300.0,20.001)
CS PICKYC THESE NEXT 4 PROVIDED BY CS - THIS SAYS IT DEFINES DEVICE WINDOW IN
CS PICKYC NORMALISED DEVICE SPACE WITH PREFERRED WIDTH:
CS PICKY      CALL GLWV4S(0.0, 0.05, 0.0, 1.0, 300.0)
CS PICKYC THIS SAYS IT DEFINES USER VIEWPORT IN NORMALISED DEVICE SPACE:
CS PICKY      CALL GLWV3S(0.0, 0.05, 0.0, 0.05)
CS PICKYC AND THIS SAYS IT DEFINES USER WINDOW IN WORLD COORDINATE SPACE:
CS PICKY      CALL GLWV2S(0.0, 300.0, 0.0, 300.0)
CS PICKYC SELECT TRANSPARENT MODE FOR SOME REASON:
CS PICKY      CALL GLMD3S(3)
CS PICKY      GO TO 100
CS PICKYC
CS PICKYC FINISH PLOT:
CS PICKYC CLOSE OUTPUT STREAM:
CS PICKY   9  CALL GLPS7S
CS PICKYC CLOSE PACKAGE:
CS PICKY      CALL GLPC4S
C
CS ILL      IF (N .EQ. 999) CALL PLOTS(0,XX,YY)
CS ILL      IF (N .EQ. -999) CALL PLOT(0.,0.,999)
C
CS RAL      IF (N .EQ. 999) CALL PLOTS(53,0,8)
CS RAL      IF (N .EQ. -999) CALL PLOT(XX,-0.5,999)
 100  RETURN
      END
C
C
C
C
C
C LEVEL 49 GRAPHIC PIGGPLIB
C
C *** PLOTTER SUB-LIBRARY USING  GNUPLOT  by PJB Sept 2016 ***
CC 14C
CH A complete set of plotting functions which use  GNUPLOT as a front end
CP Expects to find local terminal options in $CCSl_GRAF/gnuplt.trm
C
C
C
C
C LEVEL 1      BLOCK DATA GF2GPL
      BLOCK DATA GF2GPL
C translation tables for GRAFIC symbols and linestyles (best fits)
      COMMON /GPSYMS/LGPSYM(11,2),LGPSTY(5)
C                plussi','xcross','asterx','square','circle','trianu',
      DATA LGPSYM/  1,      2,       3,       4,       5,       6,
C Standard gnuplot only defines 6 symbol types
     &             1,      2,       3,       4,       5,
C Best fit CCSL to Postscript defined symbols
     &             1,      2,       3,       4,       6,       8,
C '              triand','diamon', 'star', 'eggtim','bowtie'/
     &            10,     12,       14,     22,      25/
C   Line styles  'FULL','DASH','DADO','DOTT','DADD'/
      DATA LGPSTY/  1,     2,     4,     3,     5/
      END
C
C
C
C
C LEVEL 2      SUBROUTINE GPCHAR(IN,OUT,LOU,PS)
      SUBROUTINE GPCHAR(IN,OUT,PS)
C
C *** GPCHAR New by PJB Jan 2017 ***
CC 14C
CH Translates PGPLOT escape codes to GNUPLOT ones
CA lOU is the number of print characters in the output
CA PS is true if the terminal uses Postscript fonts
C
      CHARACTER *(*)IN,OUT
      CHARACTER *9 SYMB(2),SUB*2,SUP*2
      CHARACTER *1 CTRL(3),PGPLET(4),GNPLET(4),SOUT
      LOGICAL INSYM,ISSUB,ISSUP,PS
      DATA CTRL/'g','d','u'/
      DATA SYMB,SUB,SUP/'{/symbol ','{/Symbol ','_{','^{'/
      DATA PGPLET/'c','h','x','y'/
      DATA GNPLET/'x','q','c','h'/

      ISSUB=.FALSE.
      ISSUP=.FALSE.
      LENW=LENGT(IN)
      OUT=''
      LO=1
      LOU=0
      LI=0
   11 INSYM=.FALSE.
    1 LI=LI+1
      IF (LI.GT.LENW) GO TO 99
      IF (.NOT.INSYM) THEN
        IF (IN(LI:LI) .NE.'\') GO TO 10
        INSYM=.TRUE.
        LENOUT=LENOUT-1
        GO TO 1
      ELSE
        JSYM= NCFIND(IN(LI:LI),CTRL,3)
        GO TO (9,2,3,4) JSYM+1
      ENDIF
      GO TO 1
    2 LI=LI+1
C greek letters which may differ in pgplot and gnuplot
      SOUT = IN(LI:LI)
      LC=NCFIND(SOUT,PGPLET,4)
      IF (LC.NE.0) SOUT=GNPLET(LC)
      IS=1
      IF (PS) IS= 2
      OUT(LO:)=SYMB(IS)//SOUT//'}'
      LO=LO+11
      LOU=LOU+1
      GO TO 11
    3 ISSUB=.NOT.ISSUP
      IF (ISSUB) GOTO 6
      ISSUP=.FALSE.
      GO TO 5
    4 ISSUP=.NOT.ISSUB
      IF (ISSUP) GOTO 6
      ISSUP=.FALSE.
      GO TO 5
    5 OUT(LO:LO)='}'
      LO=LO+1
      GO TO 11
    6 IF (ISSUB) OUT(LO:)=SUB
      IF (ISSUP) OUT(LO:)=SUP
      LO=LO+2
      GO TO 11
    9 INSYM=.FALSE.
   10  OUT(LO:LO)=IN(LI:LI)
       LO=LO+1
       LOU=LOU+1
       GO TO 1
   99  RETURN
        END
C
C
C
C
C LEVEL 2      SUBROUTINE GPLFIL(IDEV,LCMD,ASPCTM,PS)
      SUBROUTINE GPLFIL(IDEV,LCMD,ASPCTM,PS)
C
      LOGICAL PS,SAID
      CHARACTER *8 OBJECT(2)
      COMMON /GPLGRF/KFONT,SYMSCL
/GNPLT/
/GPCHRS/
/IOUNIT/
/SCRACH/
      DATA OBJECT/'Display ','Printing'/
      DATA LFONT1,LFONT2,PSFSCA,PSSSCA/16,20,1.5,1.5/
C
C To use either gnuplot or postscript symbols
      PS=(SAID(TERM(IDEV)(1:4),'POST') .OR. SAID(TERM(IDEV)(1:3),'X11'))
C      WRITE (ITO,1016) OBJECT(IDEV),TERM(IDEV)(1:LENGT(TERM(IDEV))),
C     &TOPTS(IDEV)(1:LENGT(TOPTS(1))),MSYM,(TNUMS(I,IDEV),
C    &I=2,3),TNUMS(1,IDEV),aspctm
C 1016 FORMAT(/'GPLFIL Setting gnuplot commands for ',A,':',2X,A,/
C     &'Options ',A/'Symbol type',i3,' Size',F8.2,' x',F8.2,
C     &' Scaled by',F8.3,' map aspect',f8.3)
      IF (LCMD.NE.0) CALL CLOFIL(LCMD)
      IF (TERM(IDEV).EQ. ' ') RETURN
C OPEN  FILE FOR GNUPLOT COMMANDS
      MESSAG='gplc'//TERM(IDEV)(1:2)//'.gpl'
      LCMD=NOPFIL(226)
      WRITE (ITO,1002) MESSAG
      WRITE (LPT,1002) MESSAG
 1002  FORMAT ('Creating gnuplot command file  ',A)
C Calculate canvas size
      IF (ABS(ASPCTM) .LT. 0.0001) ASPCTM=1.0
C Portrait or Landscape?
      IF (ASPCTM.GT.1.) THEN
        WID=TNUMS(2,IDEV)
        HGT=WID/ASPCTM
      ELSE
        HGT=TNUMS(2,IDEV)
        WID=HGT*ASPCTM
      ENDIF
C Set TERMINAL
        LTERM=LENGT(TOPTS(IDEV))
C        WRITE (ito,1000) TERM(IDEV),TOPTS(IDEV)(1:LTERM),
C     &  WID,HGT
 1000 FORMAT ('set terminal  ',A,1X,A,' size',F8.2,','F8.2,
     &' font "Helvetica,',i2,'"')
      FNTSCA=1.
      SYMSCL=1.
      IF (TERM(IDEV)(1:4) .EQ. 'post') THEN
        FNTSCA=PSFSCA
        SYMSCL=PSSSCA
      ENDIF
      JFONT=NINT(FLOAT(LFONT1)*FNTSCA)
      KFONT=NINT(FLOAT(LFONT2)*FNTSCA)
      WRITE (LCMD,1000) TERM(IDEV),TOPTS(IDEV)(1:LTERM),
     &  WID,HGT,JFONT
      IF (TERM(IDEV)(1:4) .EQ. 'post')  write (LCMD,1009)
 1009   FORMAT ('set lmargin 8' /'set tmargin 4 ')
      RETURN
      END
C
C
C
C
C LEVEL 2      INTEGER FUNCTION GPLGO(LCMD)
      INTEGER FUNCTION GPLGO(LCMD)
C
C *** GPLGO New by PJB Jan 2017 ***
CC 14C
C
CH Submits a GNUPLOT command file for processing
CA LCMD is the unit number of the file.
CA Returns 0 if successful, 1 if not
      CHARACTER * 10 FILNOM
/IOUNIT/
      GPLGO=0
      CALL EXECUTE_COMMAND_LINE ('gnuplot '//FILNOM(LCMD),
     &.TRUE.,IEXIT,ISTATUS)
      IF ((IEXIT.NE.0) .OR. (ISTATUS.NE.0)) THEN
        WRITE (ITO,1020) IEXIT,ISTAT
 1020   FORMAT('Error in GNUPLO command: ExitStatus =',i4,
     &' CommandStatus =',i12)
        GPLGO=1
      ENDIF
      RETURN
      END
C
C
C
C
C LEVEL 2      SUBROUTINE GPPREF
      SUBROUTINE GPPREF
C
C
C *** GPPREF New by PJB Jan 2017 ***
CC 14C
CH Allows the user to customise the devices used to display graphics
C
CN New symbolic parameter GDEV to set the maximum number of possible terminal types
CN for GNUPLOT plotting
C
      LOGICAL FOUND(2),says
%      CHARACTER * 4 TNAMES(%GDEV%,2),DEV,TNAME(2)
      character * 22 devmes(2),hcname*40
C
/GNPLT/
/GPCHRS/
/IOUNIT/
/SCRACH/
      data devmes/'Terminal for display? ','Format for hard copy? '/
C
C Find the preferences file
      CALL GETENV('CCSL_OPT',NAMFIL)
      MESSAG=NAMFIL(1:LENGT(NAMFIL))//'/gnuplt'
      LGPL=NOPFIL(221)
C Read names of possible terminal devices
   10 do 1 idev=1,2
        READ (LGPL,1000) ICARD
 1000   FORMAT (A80)
C        write (ito,1000) icard
        IF (ICARD(1:1) .EQ.'#') GO TO 10
        CALL RDWRDS(TNAMES(1,IDEV) ,1,5,NUM,IER)
        IF (IER.NE.0 ) THEN
          WRITE (NAMFIL,1005) 'device names',IPT,IER,'Num =',NUM
 1005     FORMAT (A,I3,' IER =',I4,X,A,I4)
          GO TO 3
        ENDIF
 1001   FORMAT(a,a4)
        WRITE (ITO,1001) devmes(idev),tnames(1,idev)
        do 2  n=2,num
          WRITE (ITO,1001) '                      ',tnames(n,idev)
    2   continue
C Choose a display and hard copy device
        if (num .gt.1) then
          CALL ASK('Choose one: (default: '//tnames(1,idev)//')')
          do 12 l=1,num
            len=lengt(icard)
            if (says(tnames(l,idev)(1:len))) go to 11
   12     continue
        endif
        l=0
   11   if (l.eq.0) l=1
        tname(idev)=tnames(l,idev)
    1 continue
C Get parameters needed for the chosen devices
   4  READ (LGPL,1000,END=5) ICARD
      IF (ICARD(1:1) .EQ.'#') GO TO 4
      IDEV= NCFIND(icard(1:4),tname,2)
      if (IDEV .eq.0) go to 4
      CALL RDWORD(TERM(idev),LENW,1,IPT1,IPT+10,0,IER)
      IF (IER.NE.0) THEN
        write (ito,5000) 'ier',ier,ipt,nlet,dev,lenW,icard
 5000 format ( a,3i5,2x,a,2x,i2/a)
        WRITE (NAMFIL,1005) 'device name at',IPT1,IER
        GO TO 3
      ENDIF
C The output file extension
      IF (IDEV.EQ.2) THEN
        CALL RDWORD(EXT,LENW,IPT1,IPT2,IPT1+10,0,IER)
        IF (IER.NE.0 .OR. LENW.GT.3) THEN
          WRITE (NAMFIL,1005) 'file extension at',IPT1,IER
          GO TO 3
        ENDIF
        HCOUT=HCNAME(EXT)
        IPT1=IPT2
      ENDIF
      DO 6 I=1,2
      CALL RDREAL(TNUMS(i,idev),IPT1,IPT2,IPT1+10,IER)
      IF (IER.NE.0) THEN
        WRITE (NAMFIL,1005) 'Canvas size prefs at',IPT1,IER,'I =',I
        GO TO 3
      ENDIF
      IPT1=IPT2
    6 CONTINUE
C The rest of the card gives the terminal options
      topts(idev)=icard(iPt2:lengt(icard))
      found(idev)=.true.
      go to 4
C Error in input
    3 CALL ERRMES(1,-1,'Error reading '//NAmFIL)
      WRITE (ITO,1000) ICARD
C
    5 IF (.NOT.found(1))
     &  CALL ERRMES(1,1,'No valid display terminal found')
      IF (.NOT.found(2)) then
        CALL ERRMES(1,-1,'No valid print device found')
        term(2)=''
      endif
      call errmes(0,1,'Setting gnuplot terminal preferences')
      go to 7
CC Report choices
    7 WRITE (LPT,1006) TERM(1)(1:LENGT(TERM(1))),
     &TOPTS(1)(1:LENGT(TOPTS(1))),(TNUMS(I,1),I=2,3),TNUMS(1,1)
 1006 FORMAT(/'Destinations for plots chosen are:'/'Display on ',A,2X,
     &A,2X,'Size',F8.2,' x',F8.2,' Scaled by',F8.3)
      WRITE (LPT,1007) TERM(2)(1:LENGT(TERM(2))),
     &TOPTS(2)(1:LENGT(TOPTS(2))),EXT,(TNUMS(I,2),I=2,3),TNUMS(1,2)
 1007 FORMAT('Print file type ',A,X,A,X,'Extension ',A,' Size',
     &F8.2,' x',F8.2,' Scaled by',F8.3/)
      RETURN
      END
C
C
C
C
C LEVEL 2      SUBROUTINE GRAFDV(LDAT,NSETS,NBLKS,TEXT,ALIM,ISYM,SYMSIZ,
C     &ICOL,NVALS,IDX,IDY,IPLOT,DTITLE)
      SUBROUTINE GRAFDV(LDAT,NSETS,NBLKS,TEXT,ALIM,ISYM,SYMSIZ,
     &ICOL,NVALS,IDX,IDY,IPLOT,DTITLE)
C
C *** GRAFDV for gnuplot New by PJB Jan 2017 ***
CC 14B
C
CH  Device dependent driver for graph plotting routines
C
      EXTERNAL GFDEFS, GF2GPL
      DIMENSION ALIM(4),ISYM(NSETS),SYMSIZ(NSETS),ICOL(NSETS),
     &NVALS(2,NBLKS),IDX(2,NBLKS),IDY(2,NSETS),IPLOT(NBLKS),
     &DTITLE(NSETS)
      INTEGER GPLGO
      CHARACTER * 80 SLINE,VFMT*10,HCNAME*40,PSNAME*40
      LOGICAL PS,SAYS
      CHARACTER *80 TEXT(3),DTITLE*20,LABEL*40
      CHARACTER *10 LABELS(3),FILNOM,DFILE
/GFWRDS/

/GPCHRS/
      COMMON /GPLGRF/KFONT,SYMSCL
%       COMMON /GPSYMS/LGPSYM(%GFSM%,2),LGPSTY(%GFLS%)
/IOUNIT/
/SCRACH/
/WHEN/
      DATA LABELS/'title','xlabel','ylabel'/
      DATA VFMT /'(a,12a1,a)'/
      data SYMSCA,FNTSCA/1.5,1.2/

      do 30 i=1,nsets
      L=lengt(dtitle(i))
      write (ito,5001) i,nsets,l,dtitle(i)(1:L)
 5001 format ('Dtitles ',3i4,2x,a)
   30 continue
C Save data file
      DFILE=FILNOM(LDAT)
      CALL CLOFIL(LDAT)
C SELECT TERMINALS
      CALL GPPREF
      IDEV=1
      LMCU=0
      ASPCTM=0
      LDV=1
  10  CALL GPLFIL(IDEV,LCMU,ASPCTM,PS)
      IF (LCMU .EQ.0) GO TO 50
C GENERATE the gpl commands
      DO 1 I=1,3
        CALL GPCHAR(TEXT(I)(1:LENGT(TEXT(I))),LABEL,PS)
        IF (I.EQ.1) THEN
          WRITE (LCMU,1007) LABELS(I),LABEL,KFONT
 1007     FORMAT ('set ',a,'  "',a,'" font "Helvetica-bold,',i2,'"')
        ELSE
          WRITE (LCMU,1000) LABELS(I),LABEL
        ENDIF
 1000   FORMAT ('set ',a,'  "',a,'"')
    1 CONTINUE
       WRITE (LCMU,1001) (ALIM(I),I=1,4)
 1001 FORMAT ('set size square 0.95,0.95'/'set xrange  [',
     &F8.2':',F8.2,']'/'set yrange  [',F8.2,':',F8.2,']'/
     & 'set grid xtics ytics lt 0 lw 1 lc rgb "#bbbbbb"')
      if (PS) then
        SCLKEY=1.5
      ELSE
        SCLKEY=1
      ENDIF
      WRITE (LCMU,1003) SCLKEY
      IF (IDEV .EQ.2) WRITE (LCMU,1002) HCOUT(1:lengt(psname))
 1002 FORMAT ('set output "',A,'"')
 1003 format ('set key Left spacing', f8.2)
C Label plot with date and time
      write (LCMU,1004) DATIM(1:24),-0.07,-0.07
 1004 format ('set label 1 "{/*0.8 ',a,'}" at graph', f6.2,',',f6.2)
      NSET=0
      do 3 IBLK=1,NBLKS
        ITYPE=0
        IF (IDX(2,IBLK).NE.0)   ITYPE= IOR(ITYPE,2)
        DO 4 JBLK=1,NVALS(2,IBLK)
          NSET=NSET+1
          M=NSET
C Translate the escape codes in data titles
          L=LENGT(DTITLE(M))
          CALL GPCHAR(DTITLE(M)(1:L),namfil,PS)
          LT=LENGT(NAMFIL)
C          write (ito,5003) m,DTITLE(M),NAMFIL(1:LT)
C 5003 format('Setting KEY TITLE ',I3,2X,a,2X,A)
           IF (IDY(2,NSET).NE.0) ITYPE= IOR(ITYPE,1)
          IF (NSET.EQ.1) THEN
            SLINE='plot "'//DFILE(1:LENGT(DFILE))//'" '
          ELSE
            SLINE=',"'//DFILE(1:LENGT(DFILE))//'" '
          ENDIF
          IF (IPLOT(NSET).EQ.1) THEN
            LL=MOD(ISYM(NSET),100)
C for filled symbols
            IF (PS) THEN
              LPOINT=LGPSYM(LL,2)+ ISYM(NSET)/100
            ELSE
              LPOINT=LGPSYM(LL,1)
            ENDIF
C            write (ito,5000)'Symbpls ',PS, ISYM(NSET),LL, LPOINT
            SIZE=SYMSIZ(M)*SYMSCL
C 5000 format (a,2x,l5,2i5)
            WRITE (ICARD,1005) SIZE,LPOINT,rgbwrd(ICOL(NSET))
 1005       format ('ps',f8.2,' pt',i4,' lc "',a,'" ')
            LIC=LENGT(ICARD)
            GO TO (41,42,43,44) ITYPE+1
          ENDIF
          WRITE (ICARD,1006) SIZE,LGPSTY(ISYM(NSET)),
     &    rgbwrd(ICOL(NSET))
 1006     FORMAT ('lw',f8.2,' dt',i4,' lc "',a,'" ')
          LIC=LENGT(ICARD)
          GO TO 45
   41     WRITE (LCMU,2000) SLINE(1:LENGT(SLINE)),
     &    IDX(1,M),IDY(1,M),ICARD(1:LIC),NAMFIL(1:LT)
 2000     FORMAT (a,' using ',i2,':',i2,
     &    ' with points ',a,' t "',a,'"\')
          go to 40
   42     WRITE (LCMU,2001) SLINE(1:LENGT(SLINE)),
     &    IDX(1,M),IDY(1,M),IDY(2,M),ICARD(1:LIC),NAMFIL(1:LT)
 2001     FORMAT (a,' using ',i2,':',i2,':',i2,
     &    ' with errorbars ',a,' t "',a,'"\')
          go to 40
   43     WRITE (LCMU,2002) SLINE(1:LENGT(SLINE)),
     &    IDX(1,M),IDY(1,M),IDX(2,M),ICARD(1:LIC),NAMFIL(1:LT)
 2002     FORMAT (a,' using ',i2,':',i2,':',i2,
     &    ' with xerrorbars ',a,' t "',a,'"\')
          go to 40
   44     write (LCMU,2003) sline(1:lengt(sline)),idx(1,m),
     &    idy(1,m),idx(2,m),idy(2,m),ICARD(1:LIC),NAMFIL(1:lt)
 2003     FORMAT (a,' using ',i2,':',i2,':',i2,':',i2,
     &    ' with xyerrorbars ',a,' t "',a,'"\')
          go to 40
   45     write (LCMU,2004) sline(1:lengt(sline)),
     &    idx(1,m),idy(1,m),ICARD(1:LIC), NAMFIL(1:lt)
 2004     FORMAT (a,' using ',i2,':',i2,
     &    ' with lines ',a,' t "',a,'"\')
          go to 40
   40     CONTINUE
    4   continue
    3 continue
C
      if (GPLGO(LCMU) .ne. 0) go to 100
   50 IF (IDEV.EQ.2) go to 99
      CALL ASK('Hard copy required (Y/N)')
      IF (.NOT. SAYS('Y')) GO TO 100
      idev=2
      go to 10
  99  CALL MESS(LPT,1,'Graph saved as '//PSNAME)
      CALL MESS(ITO,1,'Graph saved as '//PSNAME)
 100  STOP
      END
C
C
C
C
C LEVEL 2       SUBROUTINE PIGLET(XPOS,YPOS,MODE)
      SUBROUTINE PIGLET(XPOS,YPOS,MODE)
C
C *** PIGLET FOR GNUPLOT UPDATED by PJB Aug 2017 ***
CC 14C
CH Implements the primitive plotting commands used by contour and picture plotting
CN  SEE COMMENT ON MAIN PIGLET FOR PLOTTERS
C
      INTEGER GPLGO
      LOGICAL SAYS,THERE,PS
      DIMENSION PTEMP(2,3)
      CHARACTER * 10 FILNOM,HCNAME*40
/CARDRC/
/CONSTA/
/GPCHRS/
/GFWRDS/
/GFNUMS/
/GNPLT/
/IOUNIT/
/MAPMAP/
/PLODAT/
/PLOMAP/
/PLTRAN/
/SCRACH/
/WHEN/
      SAVE LCMD,NMAP,ASPCTM
      DATA NMAP,PTEMP/0,1.0,0,0,1.0,0,0/
      DATA PXPCM /85.83/
C
      N=MODE
      X=XPOS
      Y=YPOS
      IF (N .NE. 0) GO TO 3
C
      CALL PINITL
      CALL GPPREF
C  SET CCSL TO Screen transformation to be unit
      FROMCM=0
C Number of MAP cms expected in widmap
      CHMAP=(1.5*PXPCM)/TNUMS(2,1)
      CALL PLTRIN(PTEMP,2,1)
      LDAT=0
      LCMD=0
      INPLOT=.FALSE.
      CALL GMZER(PSIZE,2,1)
      GO TO 100
C
C JUMP IF START/FINISH OF PICTURE/WHOLE PLOT:
   3  IF (IABS(N) .GT. 500) GO TO 1
      IF (N .LT. 0) GO TO 2
C
C BASIC PEN MOVING: 2=DOWN, 3=UP
      IF (N.EQ.3)  WRITE (LDAT,1003)
      IF (N .LE. 3) THEN
        WRITE (LDAT,1003) X,Y,LNECOL
 1003 FORMAT (2F8.2,i4)
      ELSE
        CALL ERRMES(1,0,
     & 'call of PIGLET with N small, not 2 or 3')
      ENDIF
      GO TO 100
C
ChANGE COLOR
    2 IF (N.GE.-NGFCOL) LNECOL=-N
      GO TO 100
C
C START/FINISH ROUTINES:
C START/FINISH ROUTINES:
C    1  write (ito,5000) N,x,y,ldat,lcmd
C 5000 format ('**********Call of PIGLET ',i4,2x,2f8.3,3i5)
    1 IF (N.LT.0) GO TO 7
C 999 - START PLOT -
C or 888 CHECK WHETHER THE SIZE HAS CHANGED
      IF ((N .EQ. 999) .OR.
     &(ABS(X-WIDPIC).GT.0.0001 .OR. ABS(Y-WIDPIC).GT.0.0001)) THEN
        ASPCTM=X/Y
C SET UP TRANSFORMATION FROM PICTURE SPACE TO CCSL SPACE:
C IN CASE NOT SET ELSWHERE
        IF (N .eq.888  .or. WIDPIC.EQ.0.) WIDPIC=X
        IF (N .eq.888  .or. HGTPIC.EQ.0.) HGTPIC=Y
C Set black color
        LNECOL=1
C 888 - START PICTURE (THIS MAY NOT BE USED IF ONLY 1 PICTURE)
      ELSE

      ENDIF
C only the data file changes
        if (LDAT.eq.0) then
C OPEN  FILE for GNUPLOT data
         MESSAG='gnuplt.dat'
          LDAT=NOPFIL(226)
C       write (ito,5004) ldat
C 5004  format ('Creating data file',i5)

        else
        rewind(ldat)
      ENDIF


      INPLOT=.TRUE.
      GO TO 100
C
C FINISH A PICTURE OR A WHOLE PLOT - ENTRIES LARGE -VE:
    7 IF (INPLOT) THEN
        ID=1
        if (term(ID) .EQ.'') GO TO 5
    4   call gplfil(ID,LCMD,ASPCTM,PS)
        IF (ID.EQ.2) THEN
C Check whether we need a new output file
          INQUIRE(FILE=HCOUT(1:lengt(HCOUT)),EXIST=THERE)
          write (lpt,1012) HCOUT(1:lengt(HCOUT)),there
 1012     format ('Testing file:',A,2x,L)
          IF (THERE) THEN
            I=INDEX(HCOUT,'.')+1
            HCOUT=HCNAME(HCOUT(I:I+2))
          ENDIF
          write (LCMD,1007) HCOUT(1:lengt(HCOUT))
 1007     FORMAT ('set output "',A,'"')
        ENDIF
C Define the linetype colors
        DO 20 N=1, NGFCOL
          WRITE (LCMD,1004) N,RGBWRD(N)
 1004     FORMAT ('set linetype',I3,' lc rgbcolor "'A7,'"')
   20   CONTINUE
C Limits 5% inside page boundaries
        WRITE  (LCMD,1002) 0.95,0.95
 1002   FORMAT ('set size',F8.2,',',F8.2)
        call plconv(widpic,hgtpic,3,wid,hgt,1)
        WRITE (LCMD,1009) 0.,wid,0.,hgt
 1009   FORMAT (
     &      'unset border;unset xtics;unset ytics;unset key'/
     &      'set xrange  [',F8.2':',F8.2,']'/
     &      'set yrange  [',F8.2,':',F8.2,']')
        write (LCMD,1006) FILNOM(LDAT)
 1006   FORMAT (/'plot "',A10,'" using 1:2:3 with lines lc variable')
        IF (GPLGO(LCMD) .ne. 0) go to 101
    5   IF (ID .EQ.1 .AND. TERM(2) .NE.'') THEN
          CALL ASK('Hard copy required (Y/N)')
          IF (.NOT. SAYS('Y')) GO TO 6
          ID=2
          GO TO 4
        ENDIF
        if (id.eq.2) then
          CALL MESS(ITO,0,'Completing output file '//hcout)
          CALL MESS(LPT,0,'Map saved to file '//hcout)
        ENDIF
      endif
C Have finished with these data
    6 REWIND(LDAT)
      INPLOT=.FALSE.
C N=-999 finish plotting
  100 RETURN
C Error return from GPLGO stop
  101 call errmes(1,0,'in GNUPLOT command')
      END
C
C
C
C
C LEVEL 49 GRAPHIC PIGPGLIB

C *** PLOTTER SUB-LIBRARY USING  PGPLOT  reorganised by PJB Jan 2017 ***
CC 14C
CH A Library of plotting functions which use the PGPLOT library as a front end

C LEVEL 2 SUBROUTINE GRAFDV(LDAT,NSETS,NBLKS,TEXT,ALIM,ISYM,SYMSIZ,
C     &ICOL,NVALS,IDX,IDY,IPLOT,DTITLE)
      SUBROUTINE GRAFDV(LDAT,NSETS,NBLKS,TEXT,ALIM,ISYM,SYMSIZ,
     &ICOL,NVALS,idx,IDY,IPLOT)
C
C *** GRAFDV for PGPLOT extracted from grafic program  by PJB Jan 2017 ***
CC 14B
C
CH  Device dependent driver for graph plotting routines
C

      PARAMETER (maxpts=1000)
      EXTERNAL GRFWRD, GRF2PG
      DIMENSION alim(4),ISYM(NSETS),SYMSIZ(NSETS),ICOL(NSETS),
     &NVALS(2,NBLKS),IDX(2,NBLKS),idy(2,NSETS),IPLOT(NBLKS)
      CHARACTER *80 TEXT(3),FILNOM*10,HCNAME*40
      LOGICAL SAYS,LERCHK
      INTEGER PGOPEN
      DIMENSION VALUES(1000),XV(100),YV(100),ldev(2)
      CHARACTER *8 TERM,pgfile*20
/IOUNIT/
      COMMON /GFWRDS/COLORS(8),SYMBOL(7),LINSTY(5)
      CHARACTER *8 COLORS,SYMBOL*4,LINSTY*4
      COMMON /PGSYMS/LPGSYM(7,2)
      COMMON /GRFNOS/NGFCOL,NGFSYM,NGFSTY
/SCRACH/
/WHEN/
C
C OPEN PLOTTER WINDOW
   50 CALL ASK('Display on Aqua or X-terminal (A/X)')
      IF (SAYS('A')) THEN
        TERM='/AQT'
      ELSE IF (SAYS('X')) THEN
        TERM='/XW'
      ELSE
        GO TO 50
      ENDIF
      LDEV(1)=PGOPEN(TERM)
      IF (LDEV(1).LT.0) STOP 'Error opening pgplot device 1'
      CALL PGPAP(9.0,1.)
C
      IDEV=1
   51 CALL PGSLCT(LDEV(IDEV))
C Set black on white background
      CALL PGSCR(0,1.0,1.0,1.0)
      CALL PGSCR(1,0.,0.,0.)
      call pgqcol(i1,i2)
C 5010 format ('Color indices from',i1,' to',i4/'colors '8(a,2x))
C      write (ito,5010) i1,22,colors
      DO 55 I=2,8
      CALL PGSCRN(I,COLORS(I),IER)
   55 continue
      CALL PGASK(.FALSE.)
      CALL PGSCH(1.)
      CALL PGSLW(2)
      call pgsvp(0.1,0.9,0.15,0.85)
      CALL PGWINDOW(ALIM(1),ALIM(2),ALIM(3),ALIM(4))
      CALL PGBOX('BCGNS',0.0,0,'BCGNS',0.0,0)
      CEN=(ALIM(1)+ALIM(2))/2.
      EXT=(ALIM(4)-ALIM(3))*.09
      TOP=ALIM(4)+EXT
      BOT= ALIM(3)-1.5*EXT
      EXTW=(ALIM(2)-ALIM(1))*.09
C4.15 Label plot with date and time
      ALF= ALIM(1)-EXTW
      CALL PGSCF(1)
      CALL PGSCH(0.6)
      CALL PGPTEXT(ALF,BOT,0,0.0,DATIM(1:24))
      CALL PGSCF(2)
      CALL PGSCH(1.5)
      CALL PGPTEXT(CEN,TOP,0,0.5,TEXT(1)(1:LENGT(TEXT(1))))
      CALL PGSCH(1.)
      CALL PGSCF(1)
      CALL PGLABEL(TEXT(2)(1:LENGT(TEXT(2))),TEXT(3)
     &   (1:LENGT(TEXT(3))),' ')
      CALL PGSCH(1.)
C
C Plot the data
      REWIND(LDAT)
      JY = 0
      NSET=0
      DO 30 IBLK=1,NBLKS
        NV=NVALS(1,IBLK)
        LINE=0
        ip=1
   32   READ (LDAT,10,END=31) ICARD
   10 format (a80)
C BLANK LINE MARKS END OF BLOCK
        IF (LENGT(ICARD).LT.2) GO TO 31
        LINE=LINE+1
       IF (.NOT.LERCHK(1,IP+NV,MAXPTS,0,'DATA POINTS'))
     &  STOP'fatal error'
        CALL RDNUMS(VALUES(ip),1,NV,NUM,IER)
        IF (iER.NE.0 .OR. NUM.NE.NV) THEN
          CALL ERRIN2(IBLK,1,'Reading data from','')
          GO TO 32
        ENDIF
        IP=IP+NV
        GO TO 32
   31   LINES=LINE
C End of data block plot sets
        DO 35 N=1,NVALS(2,IBLK)
          NSET=NSET+1
          L=ICOL(NSET)
C          write (ito,5001) 'Line 116',NSET,L,idx(1,iblk),idy(1,nset)
C 5001 format (a,2x,5i5)
          IF (L.EQ.0) L=1
          CALL PGSCI(L)
          IF (SYMSIZ(NSET).EQ.0) SYMSIZ(NSET)=2
          IF (ISYM(NSET).EQ.0) ISYM(NSET)=1
C Find the corresponding Hershey GPLOT symbol number
          M=MOD(ISYM(NSET),10)
          MM=(ISYM(NSET)/10)+1
          LSYM=LPGSYM(M,MM)
          IF (IPLOT(NSET).EQ.2) THEN
            CALL PGSLS(ISYM(NSET))
            CALL PGSLW(NINT(SYMSIZ(NSET)))
C      write (ito,5007)  ISYM(NSET) , JFIX(SYMSIZ(NSET)),icol(nset)
C 5007 format ('Curve linestyle',i3,' Linewidth',i3 ,' color' ,i3)
            IL=0
          ELSE
            CALL PGSCH(SYMSIZ(NSET))
          ENDIF
          CALL PGBBUF
          LL=0
          DO 36 L=1,LINES
C Get coordinate pairs
            NX=LL+IDX(1,IBLK) !x coordinate
            NY=LL+IDY(1,NSET)
            XX = VALUES(NX)
            YY = VALUES(NY)
            GO TO (34,37) ,IPLOT(IBLK)
C PLOT POINTS
   34       NXE=IDX(2,IBLK)
            NYE=IDY(2,NSET)
            SIG = VALUES(NXE)
            SIGY = VALUES(NYE)
            CALL PGPT1(XX,YY,LSYM)
            IF (NXE .NE.0)  THEN
              SIG = VALUES(LL+nxe)
              CALL PGERRX(1,XX+SIG,XX-SIG,YY,2.)
            ENDIF
            IF (NYE .NE.0) THEN
              SIGY = VALUES(LL+nYe)
              CALL PGERRY(1,XX,YY+SIGY,YY-SIGY,2.)
            ENDIF
            GO TO 33
C PLOT CURVES
   37       Il=IL+1
            XV(IL)=XX
            YV(IL)=YY
   33       LL=LL+NV
   36     CONTINUE
          if (IPLOT(IBLK).eq.2) then
            call pgline(il,XV,YV)
          endif
          CALL PGEBUF
   35   continue
        CALL PGSCI(1)
   30 CONTINUE
      IF (IDEV.EQ.2) GO TO 52
      CALL ASK('Hard copy required (Y/N)')
      IF (SAYS('Y')) THEN
        MESSAG=FILNOM(LUNI)
        WRITE (PGFILE,1008) MESSAG(1:INDEX(MESSAG,'.')-1)
 1008  format (A,'_graf.ps')
        L=LENGT(PGFILE)
        LDEV(2)=PGOPEN(PGFILE(1:L)//'/CPS')
        IF (LDEV(2).LT.0) STOP 'Error opening postscript device 2'
        IDEV=2
        CALL PGPAP(7.5,1.)
        GO TO 51
      ENDIF
      GO TO 99
   52 CALL MESS(ITO,0,'Completing postscript file '//PGFILE)
      CALL MESS(LPT,1,'Graph saved as '//PGFILE)
      CALL PGEND(LDEV(2))
   99 CALL PGEND(LDEV(1))
      close(unit=ldat,STATUS='delete')
      RETURN
      END
C
C
C
C
C LEVEL 2     BLOCK DATA GRF2PG
      BLOCK DATA GRF2PG
      COMMON /PGSYMS/LPGSYM(7,2)
      DATA LPGSYM/22,6,7,12,5,6,7,17,16,13,18,0,0,0/
      END
C
C
C
C
C LEVEL 2       SUBROUTINE PIGLET(XPOS,YPOS,MODE)
      SUBROUTINE PIGLET(XPOS,YPOS,MODE)
C
C *** PIGLET FOR PGPLOT updated by PJB  4th Apr 2003 C122 ***
CC 14C
CH Implements the primitive plotting commands used by contour and picture plotting
CN  SEE COMMENT ON MAIN PIGLET FOR PLOTTERS
C
      INTEGER PGOPEN
      CHARACTER *10 TERM,PGHARD,PGFIL*20,HCNAME*20
      LOGICAL SAYS
      DIMENSION PTEMP(2,3)
/CONSTA/
      COMMON /PGPLT/NP,XP(100),YP(100),PLOTS,IDEV,LUNH,HARD,LDEV(2),
     &BOPEN
      LOGICAL PLOTS,HARD,BOPEN
/IOUNIT/
/PGNAMS/
/PGNUMS/
/PLODAT/
/PLOMAP/
/PLTRAN/
/SCRACH/
      SAVE PGFIL
      DATA PTEMP/1.,0.,0.,1.0,0.,0./
C
      N=MODE
      X=XPOS
      Y=YPOS
      IF (N .NE. 0) GO TO 3
C
C INITIAL ENTRY
      CALL PINITL
C  SET CCSL TO GKS WORLD COORDINATES AS UNIT TRANSFORMATION
C  BUT THIS IS CHANGED LATER WHEN WE KNOW THE SIZE OF GRAPH
      CALL PLTRIN(PTEMP,2,1)
      NP=0
      FROMCM=-100.
      PLOTS=.FALSE.
      HARD=.FALSE.
      BOPEN=.FALSE.
C Initialise device number to zero
      IDEV=0
C OPEN SCRATCH FILE FOR HARD COPY
      LUNH=NOPFIL(5)
      GO TO 100
C
C SEQUENCE FOR HARD COPY (POSTSCRIPT OUTPUT)
  101 READ(LUNH,1011) ICARD
 1011 FORMAT (A80)
      CALL RDREAL(X,1,IPT,80,IER)
      CALL RDREAL(Y,IPT,IPT1,80,IER)
      CALL RDINTG(N,IPT1,IPT,IPT1+10,IER)
      GO TO 55
C
C RECORD ALL COMMANDS TO THE SCRATCH FILE FOR LATER HARD COPY
   3  WRITE (LUNH,1010) X,Y,N
 1010 FORMAT (2F12.6,2X,I5,12X)
C
C JUMP IF START/FINISH OF PICTURE/WHOLE PLOT:
  55  IF (IABS(N) .GT. 500) GO TO 1
      IF (N .LT. 0) GO TO 2
C
C BASIC PEN MOVING: 2=DOWN, 3=UP
      IF (N .EQ. 3) GO TO 5
      IF (N .NE. 2) THEN
      CALL ERRMES(1,0,
     & 'call of PIGLET with N small, not 2 or 3')
      ENDIF
C
C PEN DOWN:
      IF (NP .LT. 99) GO TO 14
      NP=NP+1
      XP(NP)=X
      YP(NP)=Y
C ALSO PEN UP
   5  IF (NP .GT. 1) CALL PGLINE(NP,XP,YP)
      NP=0
  14  NP=NP+1
      XP(NP)=X
      YP(NP)=Y
      GO TO 100
C
C PEN COLOUR CHANGE AND PARTICULAR FUNCTIONS (EG CLEAR SCREEN):
C   N SMALL AND -VE REQUESTS
C PEN COLOUR CHANGE AND PARTICULAR FUNCTIONS (EG CLEAR SCREEN):
C   N SMALL AND -VE REQUESTS
C Colours defined in common PGNAME
C   -1=BLACK        -2=RED        -3=GREEN   -4=Blue
C   -5=Cyan         -6=Magenta    -7=Yellow  -8=Orange
C   -9=SpringGreen -10=SeaGreen  -11=Aqua   -12=Purple
C   -13=Pink      -14=Dkgray    -15=Ltgray
C
C draw the rest of the line
    2 IF (N.GE.-NGFCOL)  THEN
        IF (NP .GT.1) CALL PGLINE(NP,XP,YP)
        NP=0
C SET POLYLINE COLOUR INDEX
        CALL PGSCI(-N)
      ENDIF
      IF (N .GT. -50) GO TO 100
C
C START/FINISH ROUTINES:
   1  IF (N.LT.0) GO TO 7
C
      IF (N .EQ. 999) THEN
C 999 - START PLOT - SET UP TRANSFORMATION FROM PICTURE SPACE TO CCSL SPACE:
C IN CASE NOT SET ELSWHERE
        WIDTOT=X
        HGTTOT=Y
        IF (WIDPIC.EQ.0.) WIDPIC=X
        IF (HGTPIC.EQ.0.) HGTPIC=Y
C ON FIRST ENTRY SET UP DEVICES
        IF (IDEV.EQ.0) THEN
          IDEV=1
          IF (X.GT.Y) THEN
C LANDSCAPE FORMAT
            PGHARD='/CPS'
          ELSE
C PORTRAIT FORMAT
            PGHARD='/VCPS'
          ENDIF
   20     CALL ASK('Display on Tektronix or X-terminal or '//
     &    'Aqua-terminal(T/X/A)')
          IF (SAYS('T')) THEN
            TERM='/TEK4010'
          ELSE IF (SAYS('X')) THEN
            TERM='/XWIN'
C C122 Putenv no longer supported
C UNIX            CALL PUTENV('PGPLOT_XW_WIDTH=0.75')
C134 Add Aqua for MAC
         ELSE IF (SAYS('A')) THEN
            TERM='/AQT'
         ELSE
            GO TO 20
          ENDIF
          PGFIL = HCNAME('ps')
          L=LENGT(PGFIL)
C 122 remove double /
          LDEV(2)=PGOPEN(PGFIL(1:L)//PGHARD)
          IF (LDEV(2).LT.0) STOP 'Error opening pgplot device 2'
          LDEV(1)=PGOPEN(TERM)
          IF (LDEV(1).LT.0) STOP 'Error opening pgplot device 1'
C Set black on white background
          CALL PGSCR(0,1.0,1.0,1.0)
          CALL PGSCR(1,0.0,0.0,0.0)
          CALL PGASK(.FALSE.)
        ENDIF
      ENDIF
C 888 - START PICTURE (THIS MAY NOT BE USED IF ONLY 1 PICTURE)
      IF (IDEV.EQ.1) PLOTS=.TRUE.
      CALL PGSLCT(LDEV(IDEV))
      IF (N.EQ.888 )THEN
        CALL PGPAGE
      ENDIF
C Get the size of the view surface in mm
      CALL PGQVSZ(2,X0,PAPERW,Y0,PAPERH)
C scale to maintain aspect ratio
      FACTOR=(PAPERW*Y)/(PAPERH*X)
      IF (FACTOR.LE.1) THEN
        DIF=(1.-FACTOR)*.95/2.
        CALL PGSVP(0.025,.95,0.025+DIF,.95-DIF)
      ELSE
         DIF=(1.-1./FACTOR)*.95/2.
         CALL PGSVP(0.025+DIF,.95-DIF,0.025,.95)
      ENDIF
      CALL PGSWIN(0.,X,0.,Y)
      IF (.NOT. BOPEN) THEN
        CALL PGBBUF
        BOPEN = .TRUE.
      ENDIF
      GO TO 100
C
C FINISH A PICTURE OR A WHOLE PLOT - ENTRIES LARGE -VE:
C SEND REMAINDER OF LINE IF ANY:
    7 IF (NP .GT.1) CALL PGLINE(NP,XP,YP)
      NP=0
C
C CLOSE CURRENT SEGMENT - EITHER ENTRY -888, OR PICTURE IS SAME AS WHOLE:
      IF (BOPEN) THEN
        CALL PGEBUF
        BOPEN = .FALSE.
      ENDIF
      IF ((IDEV .EQ. 1) .AND. PLOTS) THEN
        CALL ASK('Hard copy required (Y/N)')
        IF (N .EQ.-999) CALL PGEND(LDEV(IDEV))
        IF (SAYS('Y')) THEN
          HARD=.TRUE.
          REWIND(LUNH)
          IDEV=2
        ELSE
          IF (N .EQ.-999) CALL CLOFIL(LUNH)
        ENDIF
        IF (N.EQ.-888) PLOTS=.FALSE.
      ELSE
        IF (N .EQ.-999) THEN
          CALL PGEND(LDEV(IDEV))
         IF (HARD) CALL MESS(ITO,0,'Completing postscript file '
     &  //PGFIL)
        ENDIF
        CALL CLOFIL(LUNH)
        IF (N .EQ.-999) GO TO 102
        IDEV=1
        LUNH=NOPFIL(5)
        GO TO 100
      ENDIF
C
 100  IF (IDEV.EQ.2) GO TO 101
C FINISH WHOLE JOB:
  102 RETURN
      END
C
C
C
C
C LEVEL 49 GRAPHIC PIGPSLIB
C
C *** PLOTTER SUB-LIBRARY USING  POSTSCRIPT directly  by PJB Sept 2016 ***
CC 14C
CH A complete set of plotting functions which send graphic output
CH Directly to a postscript file
C
C
C
C

C LEVEL 2      SUBROUTINE KANGA2(X0,Y0,XF,ICHARS,NCHAR)
      SUBROUTINE KANGA2(X0,Y0,XF,ICHARS,NCHAR)
C
C *** KANGA2 for POSTSCRIPT by PJB Oct 90 **
C
CX
CC 14C
CH Writes on a plot a string of characters, or simulates this in order
CH to measure the length of the string.
CA On entry ICHARS is a character string
CA          NCHAR is the number of characters in ICHARS;  if NCHAR is given
CA                negatively, KANGA2 goes through the motions of writing but
CA                does not actually plot anything.  This facility is for
CA                measuring strings.
CA          X0, Y0 give where, in the current (character) space, to start
CA                 writing (i.e. the bottom left hand side of the first letter)
CA On exit XF has been updated to be the X position for the "next" character,
CA                 it is adjusted (by the subtraction of X0) so that it is the
CA                 length of the string in character units.
C
CP Plotting must have already been set up by, e.g., STPLOT, and we must
CP already be in "character" space, though this may be of one of various
CP types of character previously set up.
C
C
CN The two fonts available are Helvetica and Symbol. They are scaled
CN appropriately.
CN The character # (hash) is a special character, signalling that the
CN one character which follows it is in the symbol font.
CN A number enclosed between #'s is used to give the ASCII code (decimal) of
CN symbols not correponding to keyboard characters. This will produce funny
CN output with the other plotter interfaces.
CN
CN Unidentifiable characters are converted to spaces.
C
      DIMENSION ICHWID(224),ISYWID(224)
      CHARACTER *80 ICHARS
/IOUNIT/
/PLODAT/
/PLTRAN/
      COMMON /POSTCH/CHFONT(5),SYFONT(5)
      CHARACTER*3 CHFONT,SYFONT
      COMMON /POSTSC/DOWN,FILL,XP,YP,LETSPC(7),PSIZE(5),RTFONT(5),
     & NFONT,POSTC,LAND,PGOPEN,NPAGE
      LOGICAL DOWN,FILL,POSTC,LAND,PGOPEN
/SCRACH/
      LOGICAL GREEK
      CHARACTER*50 VFMT
      DATA VFMT/'(A8,'' SF ('',A???,'') SH'')'/
      DATA IBCKSL/92/
C Widths of 500pt Helvetica ASCII characters in pts
C The first character is ASCII 32 (ie space)
      DATA ICHWID/
     & 138,138,177,280,280,446,333,110,170,170,195,294,138,167,142,142,
     & 280,280,280,280,280,280,280,280,280,280,138,138,294,294,294,280,
     & 510,337,337,361,361,337,308,390,361,138,252,337,280,418,361,390,
     & 337,390,365,337,308,365,337,475,340,340,308,138,138,138,220,280,
     & 113,280,280,252,280,280,138,280,280,113,113,252,113,418,280,280,
     & 280,280,170,252,138,280,252,361,252,252,252,167,128,170,294,138,
     & 138,138,138,138,138,138,138,138,138,138,138,138,138,138,138,138,
     & 138,138,138,138,138,138,138,138,138,138,138,138,138,138,138,138,
     & 138,167,280,280, 96,280,280,280,280, 96,167,280,167,167,252,252,
     & 138,280,280,280,138,138,280,177,113,167,167,280,503,503,138,308,
     & 138,167,167,167,167,167,167,167,167,138,167,167,138,167,167,167,
     & 503,138,138,138,138,138,138,138,138,138,138,138,138,138,138,138,
     & 138,503,138,184,138,138,138,138,280, 39,149,184,138,138,138,138,
     & 138,446,138,138,138,138,138,138,113,308,475,308,138,138,138,138/
C Widths of 500pt Symbol set ASCII characters in pts
      DATA ISYWID/
     & 126,168,358,252,275,418,392,221,168,168,252,275,126,275,126,140,
     & 252,252,252,252,252,252,252,252,252,252,140,140,276,276,276,223,
     & 276,363,338,363,308,308,383,305,363,168,319,363,345,448,363,363,
     & 386,372,280,298,308,347,221,386,324,400,308,168,216,168,331,252,
     & 252,317,276,276,248,221,262,207,303,167,303,276,276,291,262,276,
     & 276,262,276,303,221,291,358,345,248,345,248,243,101,241,276,126,
     & 126,126,126,126,126,126,126,126,126,126,126,126,126,126,126,126,
     & 126,126,126,126,126,126,126,126,126,126,126,126,126,126,126,126,
     & 126,312,124,276, 85,  0, 25,376,376,376,376,524,496,305,496,305,
     & 202,276,207,276,276,358,248,230,276,276,276,276,503,305,503,331,
     & 418,344,400,496,386,386,415,386,386,358,358,358,358,358,358,358,
     & 386,358,397,397,448,415,276,126,358,303,303,524,496,303,496,303,
     & 248,167,397,397,397,358,193,193,193,193,193,193,248,248,248,248,
     & 126,167,138,344,344,344,193,193,193,193,193,193,248,248,248,126/
C
C SET NOT IN SYMBOL FONT:
      GREEK=.FALSE.
      NGRK=0
      if (down)  then
        down=.false.
        write (iplo,1300) 'S'
      endif
 1300 format (A)
C
      IF (NCHAR .EQ. 0) GO TO 100
      MODNC=IABS(NCHAR)
      IF (NCHAR.LT.0) GO TO 2
C  HAS THIS SPACE BEEN DEFINED AS A CHARACTER SPACE
      IFONT=LETSPC(NSPCE)
      IF (IFONT.EQ.0) THEN
C  SET UP FONTS FOR THIS SPACE
        CALL ERRCHK(2,NFONT,5,0,'Too many font-sizes')
        IFONT=NFONT
        LETSPC(NSPCE)=IFONT
C  FIRST GET THE SIZE AND ROTATION
        CALL PLCONV(0.,CHUNIT*ASPECT,NSPCE,X,Y,1)
        CALL PLCONV(0.,0.,NSPCE,XX,YY,1)
        X=X-XX
        Y=Y-YY
        PSIZE(IFONT)=SQRT(X*X+Y*Y)
        IPTS=NINT(PSIZE(IFONT))
        RTFONT(IFONT)=-DEGREE(ATAN2(X,Y))
C THEN WRITE THE FONT DEFINITION
        WRITE (CHFONT(IFONT),1400) IFONT
        WRITE (SYFONT(IFONT),1401) IFONT
 1400 FORMAT ('Cf',I1)
 1401 FORMAT ('Sf',I1)
        WRITE (IPLO,1500) CHFONT(IFONT),IPTS,SYFONT(IFONT),IPTS
 1500 FORMAT ('/',A3,' /Helvetica findfont ',I3,' SC def'/
     & '/',A3,' /Symbol findfont ',I3,' SC def'/)
      ENDIF
C
      IF (NCHAR.GT. 0) THEN
        CALL PLCONV(X0,Y0,NSPCE,XX,YY,1)
        WRITE (IPLO,1504) XX,YY,RTFONT(IFONT)
 1504 FORMAT(2F8.2,' T',F8.2,' R 0 0 M')
      ENDIF
      NCH=0
    2 IWID=0
      DO 1 I=1,MODNC
C IS IT IN SYMBOL FONT
      IF (ICHARS(I:I).NE.'#') THEN
        IF (GREEK) THEN
          IF (ICHARS(I:I).GE.'0' .AND. ICHARS(I:I) .LE. '9') THEN
            NGRK=NGRK+1
            ICARD(NGRK:)=ICHARS(I:I)
          ELSE
            IF (NCHAR .GT.0) WRITE (IPLO,1502) SYFONT(IFONT),ICHARS(I:I)
 1502 FORMAT (A8,' SF (',A1,') SH')
            GREEK=.FALSE.
            IWID=IWID+ISYWID(ICHAR(ICHARS(I:I))-31)
          ENDIF
        ELSE
          IWID=IWID+ICHWID(ICHAR(ICHARS(I:I))-31)
          NCH=NCH+1
        ENDIF
      ELSE
C IF HASH, NEXT CHARACTER IS FROM SYMBOL FONT
C UNLESS IT SIGNALS END OF NUMBERED CHARACTER
        IF (NGRK.NE.0) THEN
          CALL RDINTG(IGRK,1,IPT,NGRK,IER)
          IF (IGRK.LT.256) THEN
            IWID=IWID+ISYWID(IGRK-31)
            IF (NCHAR .GT.0) THEN
C              CALL OCTAL(IGRK,WORD)
              WRITE (IPLO,1505) CHAR(IBCKSL),SYFONT(IFONT),IGRK
            ENDIF
 1505 FORMAT (A8,' SF (',A1,O3,') SH')
          ENDIF
          NGRK=0
          GREEK=.FALSE.
        ELSE
          GREEK=.TRUE.
C  CLEAR THE BUFFER OF ORDINARY CHARACTERS
          IF (NCHAR.GT.0 .AND. NCH.GT.0) THEN
            WRITE (VFMT(14:16),1402) NCH
 1402 FORMAT (I3)
            WRITE (IPLO,VFMT) CHFONT(IFONT),ICHARS(I-NCH:I-1)
            NCH=0
          ENDIF
        ENDIF
      ENDIF
    1 CONTINUE
C
      IF (NCHAR.GT.0 .AND. NCH.GT.0) THEN
          WRITE (VFMT(14:16),1402) NCH
          WRITE (IPLO,VFMT) CHFONT(IFONT),ICHARS(I-NCH:I-1)
      ENDIF
C
C CONVERT CALCULATED WIDTH TO CHARACTER SPACE UNITS
      XF=IWID*CHUNIT/500.
C SET BACK TO OLD COORDINATE SYSTEM
      IF (NCHAR.GT. 0) THEN
        XX=-XX
        YY=-YY
        R=-RTFONT(IFONT)
        WRITE (IPLO,1506) R,XX,YY
 1506   FORMAT(F8.2,' R',2F8.2,' T')
      ENDIF
 100  RETURN
      END
C
C
C
C
C LEVEL 2      SUBROUTINE KANGA3(X,Y,SIZE,MSYM)
      SUBROUTINE KANGA3(X,Y,SIZE,MSYM)
C
C *** KANGA3 special for POSTSCRIPT by PJB 91 ***
C
CX
CC 14C
CH Plots a special symbol
CA On entry X,Y give the position in current coordinates of the CENTRE of the
CA              symbol.  The current space will usually be graph or map space.
CA          MSYM idicates which symbol is required:
CA          MSYM=1   square                                        4
CA          MSYM=2   triangle, apex up                             6
CA          MSYM=3   triangle, apex down                           7
CA          MSYM=4   proper circle with postscript                 5
CA          MSYM=5   cross like X                                  2
CA          MSYM=6   cross like +                                  3
CA          MSYM=7   cross like X with top and bottom (egg-timer) 10
CA          MSYM=8   cross like X with sides (butterfly)          11
CA          MSYM=9   diamond                                       8
CA The symbols are "the right way up" for CCSL space.
CA The actual symbol size in is scaled is set so that all have the same area
CA SIZE is in cms and must be scaled appropriately by the calling program (Cms are CCSL units).
CP Plotting must be set up by, e.g., STPLOT, and a suitable space set by SPCSET
C
CN This is distinct from KANGA2, which can also draw symbols if they can
CN be represented as A1 characters, but expects them to be part of a
CN sentence, and draws them on a 30 x 30 character space grid with origin
CN at a point part way up the left hand side.  KANGA3 centres the symbol.
C
      DIMENSION SMPTS(12,2),MLINE(30),MPOINT(10),LSYMTB(9)
      LOGICAL FILABL
      CHARACTER *10 MESSAG
/GFWRDS/
/GFNUMS/
/IOUNIT/
/PLTRAN/
      COMMON /POSTSC/DOWN,FILL,XP,YP,LETSPC(7),PSIZE(5),RTFONT(5),
     & NFONT,POSTC,LAND,PGOPEN,NPAGE
      LOGICAL DOWN,POSTC,LAND,PGOPEN
      DATA SMPTS/-2., 0., 2.,-2., 2.,-2., 2.,-2., 2.,-2., 0., 2.,
     &           -2.,-2.,-2.,-1.,-1., 0., 0., 1., 1., 2., 2., 2./
      DATA MPOINT/1,5,8,11,11,15,19,23,27,31/
      DATA MLINE/1,3,12,10, 2,9,8, 1,4,11, 1,12,-3,10, 2,11,-6,7,
     &1,12,10,3, 1,12,3,10, 2,6,11,7/
      DATA LSYMTB/4,6,7,5,2,3,10,11,8/
C
      write (ito,5010) 'start of kanga3'
 5010 format (a)
      IF (DOWN)  THEN
        DOWN=.FALSE.
        WRITE (IPLO,1300) 'S'
      ENDIF
 1300 FORMAT (A)
      S4=SIZE/4.
C
      ISYM=IABS(MSYM)
      MSYMB=LSYMTB(ISYM)
C      WRITE (IPLO,1500) MSYM,MSYMB
      FILABL=(ISYM.NE.5 .OR. ISYM.NE.6)
C
C CONVERT POINT AT SYMBOL CENTRE TO BE IN PLOTTER SPACE:
      CALL PLCONV(X,Y, 0,X0,Y0,1)
      SS1=sqrt((pmtrix(1,1,1)*pmtrix(2,2,1)) -
     &(pmtrix(1,2,1)*pmtrix(2,1,1)))
      SS2=sqrt((pmtrix(1,1,2)*pmtrix(2,2,2)) -
     &(pmtrix(1,2,2)*pmtrix(2,1,2)))
      sscale=ss1*ss2
      s4=s4*sscale
      WRITE (ITO,5000) SS1,SS2,fromcm
 5000 FORMAT ('Scale for chars' ,3F8.2, '  to pts')

      GO TO (4,2,2,5,4,4,4,4,3) ,MSYMB
C
C For Triangles  sqrt(8/sqrt(3))
   2  S4=S4*2.149
      GO TO 4
C For diamond
    3 S4=S4*sqrt(2.)
      GO TO 4
C

C    4 WRITE (IPLO,1500) ISYM,MSYMB,s4
C 1500 FORMAT ('%Here starts symbol ',2i3,' Size',f8.2)
C      WRITE (ITO,1500) ISYM,MSYMB,s4
    4 K=MPOINT(MSYMB)
      L=MPOINT(MSYMB+1)-1
      DO 1 I=K,L
      M=MLINE(I)
      MPEN=2
      XIN=X0+SMPTS(M,1)*S4
      YIN=Y0+SMPTS(M,2)*s4
      IF (I.EQ.K .OR. M.LT.0) THEN
        WRITE (IPLO,1504) XIN,YIN
      ELSE
        WRITE (IPLO,1505) XIN,YIN
      ENDIF
 1504 FORMAT ('NP',2F8.2,' M')
 1505 FORMAT (2F8.2,' L')
    1 CONTINUE
      IF (MSYM.LT.0 .AND. FILABL) THEN
        MESSAG(1:3)='CP'
        IF (MSYM .LT.0)  MESSAG='CP fill'
      ELSE
        MESSAG(1:)=' S'
      ENDIF
      WRITE (IPLO,1506) MESSAG
 1506 FORMAT (A)
C      WRITE (IPLO,1501) ISYM,MSYMB
C      WRITE (ITO,1501) ISYM,MSYMB
C 1501 FORMAT ('%Here ends symbol ',2I3/)
      GO TO 100
C
C  DRAW CIRCLE
    5 RX=1.128*s4
C      WRITE (IPLO,1500) ISYM,MSYMB,s4
C      CALL PLCONV(0.,0.,2,RXX,RYY,1)
C      RX=SQRT((RX-RXX)**2+(RY-RYY)**2)
      IF (MSYM.LT.0 .AND. FILABL) THEN
        WRITE (IPLO,1502)X0,Y0, RX
 1502 FORMAT ('S ',3F8.2,' 0 360 arc CP fill')
      ELSE
        WRITE (IPLO,1503) X0,Y0,RX
 1503 FORMAT ('S ',3F8.2,' 0 360 arc CP S')
      ENDIF
C      WRITE (IPLO,1501) MSYM
  100 RETURN
      END
C
C
C
C
C LEVEL 4       SUBROUTINE PIGPOS(X,Y,N)
       SUBROUTINE PIGLET(X,Y,N)
C
C *** PIGLET for POSTSCRIPT updated by PJB Jan 98 ***
C
C
C  SEE COMMENT ON MAIN PIGLET FOR PLOTTERS
C
CC 14C
CH graphical interface for Postscript
      EXTERNAL GFDEFS
C      LOGICAL DOWN
      CHARACTER*40 HCNAME
      DIMENSION PTEMP(2,3),BBOX(4),Icval(3)
      CHARACTER * 10 filnom,fname
/CONSTA/
/IOUNIT/
/GFNUMS/
/GFWRDS/
/PLODAT/
/PLOMAP/
/PLTRAN/
      COMMON /POSTCH/CHFONT(5),SYFONT(5)
      CHARACTER*3 CHFONT,SYFONT
      COMMON /POSTSC/DOWN,FILL,XP,YP,LETSPC(7),PSIZE(5),RTFONT(5),
     & NFONT,POSTC,LAND,PGOPEN,NPAGE
      LOGICAL DOWN,FILL,POSTC,LAND,PGOPEN
/TITLE/
/WHEN/
/SCRACH/
      DATA PTEMP/28.35,0.,0.,28.35,0.,0./
      save xp1,yp1
C ascii value of backslash
C
      IF (N .NE. 0) GO TO 3
C
C INITIAL ENTRY
      POSTC=.TRUE.
      LAND=.FALSE.
      PGOPEN=.FALSE.
      NPAGE=0
      DOWN=.FALSE.
      CALL PINITL
C  SET CCSL TO POSTSCRIPT transformation (postscript works in points)
      CALL PLTRIN(PTEMP,2,1)
C  OPEN A FILE FOR POSTSCRIPT OUTPUT
C      POSNAM=MAIN
C      IPLO=ISQFIL(POSNAM)
C      write (ito,5000) 'pigpos line 55'
 5000 format (a,2i3)
      fname=MAIN//'.tps'
      call upone(fname,2)
      messag=fname
      IPLO=nopfil(226)
      L=LENGT(ITITLE)
      write (ito,5000) 'pigpos line 61 ',l
      WRITE (IPLO,1500) MAIN,DATIM,(ICARD(I:I),I=1,L)
 1500 FORMAT ('%!PS-Adobe-3.0'/'%%Title: ',A/
     &'%%Creator: CCSL Poscript Generator'/
     &'%%CreationDate: ',A24/'%%For: ',80A1)
C WRITE PROLOG
         WRITE (IPLO,1512)
 1512 FORMAT('%%BeginProlog'/'/bd {bind def} bind def'/
     &'/S  {stroke}bd    /M {moveto}bd   /CP {closepath}bd'/
     &'/NP {newpath}bd /R {rotate}bd   /T {translate}bd'/
     &'/L {lineto}bd  /SR {setrgbcolor}bd',
     &'/SF {setfont}bd /SC {scalefont}bd'/
     &'/SH {show}bd'/ '%%EndProlog'/)
C INITIALISE THE FONTSIZE POINTER
      CALL JGMZER(LETSPC,5,1)
      NFONT=0
C
C  DONT PUT PICTURES SIDE BY SIDE
      FROMCM=-28.35
C SIZE OF A4 PAPER
      PAPERH=29.7
      PAPERW=21.0
      GO TO 100
C
C JUMP IF START/FINISH OF PICTURE/WHOLE PLOT:
   3  IF (IABS(N) .GT. 500) GO TO 1
      IF (N .LT. 0) GO TO 2
C
C BASIC PEN MOVING: 2=DOWN, 3=UP
      write (iplo,2000) n,x,y,xp,yp,xp1,yp1
 2000 format ('% Piglet called with ',i3,3(2f8.2,2x))
      IF (N .EQ. 3) GO TO 5
      IF (N .NE. 2) CALL ERRMES(1,0,
     & 'call of PIGLET with N small, not 2 or 3')
C
C PEN DOWN:
      if (.not. down) then
C Starting a new path
        xp1=xp
      	yp1=yp
        WRITE (IPLO,1511) xp,yp
 1511   FORMAT ('NP ',2F8.2,' M')
        down=.true.
      endif
      write (iplo,1501) x,y
 1501 FORMAT (3x,2F8.2,' L')
      GO TO 6
C
C  PEN UP
   5  IF (down) THEN
        if (abs(xp1-xp)+abs(yp1-yp).lt.0.05) then
          if (fill) then
            write (iplo,1502) 'CP fill'
          else
             write (iplo,1502) 'CP S'
          endif
        else
          write (iplo,1502) 'S'
        endif
 1502   FORMAT (A)
        DOWN=.FALSE.
      endif
    6 xp=x
      yp=y
      go to 100

C
C PEN COLOUR CHANGE
C All colors are available no lookup needed
    2 IF (N .GE. -NGFCOL) THEN
        read (RGBWRD(iabs(n)),1000) icval
 1000 format (1x,3z2)
        WRITE(IPLO,1600) (float(icval(j))/256,J=1,3)
      write (ito,5001)N,RGBWRD(iabs(n)),ICVAL,
     &(float(icval(j))/256,J=1,3)
 5001 format ('N=',i4,', ',A,' red,green,blue',3I4,3f6.2)
 1600 FORMAT ('S' 3F6.2,' SR ' )
      ENDIF
      IF (N.GT.-50) GO TO 100
C
C START/FINISH ROUTINES:
   1  IF (N.LT.0) GO TO 7
C
C IN CASE NOT SET ELSWHERE
        WIDTOT=X
        HGTTOT=Y
C CHOOSE BETWEEN PORTRAIT AND LANDSCAPE
      PW=PAPERW
      PH=PAPERH
      IF (X-Y.GT.0) THEN
        PH=PAPERW
        PW=PAPERH
        LAND=.TRUE.
      ENDIF
      IF (WIDPIC.EQ.0.) WIDPIC=X
      IF (HGTPIC.EQ.0.) HGTPIC=Y
      IF (X.GT.PW .OR. Y.GT.PH) THEN
        CALL ERRMES(1,1,'Picture does not fit on A4 paper.'//
     & ' It will be scaled')
         SCALEP=PW/X
         SCALET=PH/Y
         IF (SCALEP.LT.SCALET) SCALET=SCALEP
      ELSE
         SCALET=0
       ENDIF
C CENTRE PICTURE ON THE PAPER
      PTEMP(1,3)=(PW-X)/2.
      PTEMP(2,3)=(PW-Y)/2.
      CALL PLTRIN(PTEMP,2,1)
C set bounding box
      CALL PLCONV(0.,0.,2,BBOX(1),BBOX(3),1)
      CALL PLCONV(X,Y,2,BBOX(2),BBOX(4),1)
      IF (SCALET.NE.0) CALL GMSCA(BBOX,BBOX,SCALET,3,1)
      IF (N.EQ. 999) THEN
        PGOPEN=.TRUE.
        NPAGE=NPAGE+1
        IF (LAND) THEN
        WRITE (IPLO,1509) BBOX(2),BBOX(1),BBOX(4),BBOX(3)
 1509   FORMAT ('%%BoundingBox ',4F8.2)
        ELSE
          WRITE (IPLO,1509) BBOX
        ENDIF
        WRITE (IPLO,1520) NPAGE,NPAGE
 1520   FORMAT ('%%Page:',I3,I3/'/PIGPOS save def')
        IF (SCALET.NE.0) WRITE (IPLO,1514) SCALET,SCALET
 1514   FORMAT (2F7.4,'scale')
        IF (LAND) WRITE (IPLO,1507)
 1507   FORMAT ('595.3 0 T 90 R')
C
        else
C      IF (N.EQ.888) THEN
        IF (.NOT. PGOPEN) THEN
          NPAGE=NPAGE+1
          WRITE (IPLO,1520) NPAGE,NPAGE
C Redefine fonts being used
          DO 21 I=1,7
          IFONT= LETSPC(I)
          IF (IFONT.NE.0) THEN
C WRITE THE FONT DEFINITION
            IPTS=NINT(PSIZE(IFONT))
            WRITE (CHFONT(IFONT),1400) IFONT
            WRITE (SYFONT(IFONT),1401) IFONT
 1400       FORMAT ('Cf',I1)
 1401       FORMAT ('Sf',I1)
            WRITE (IPLO,1402) CHFONT(IFONT),IPTS,SYFONT(IFONT),IPTS
 1402 FORMAT ('/',A3,' /Helvetica findfont ',I3,' SC def'/
     & '/',A3,' /Symbol findfont ',I3,' SC def'/)
          ENDIF
   21   CONTINUE
        ENDIF
        IF (LAND) THEN
          WRITE (IPLO,1510) BBOX(2),BBOX(1),BBOX(4),BBOX(3)
 1510     FORMAT ('%%PageBoundingBox ',4F8.2)
          IF (.NOT. PGOPEN) WRITE (IPLO,1507)
        ELSE
          WRITE (IPLO,1510) BBOX
        ENDIF
        IF (.NOT. PGOPEN .AND.  (SCALET.NE.0))
     &  WRITE (IPLO,1514) SCALET,SCALET
      ENDIF
      GO TO 100
C
C FINISH A PICTURE OR A WHOLE PLOT - ENTRIES LARGE -VE:
C SEND REMAINDER OF LINE IF ANY:
    7 IF (DOWN) WRITE (IPLO,1506)
 1506 FORMAT ('S')
      IF (N.EQ.-888) THEN
        WRITE (IPLO,1505)
 1505   FORMAT('PIGPOS restore showpage')
        PGOPEN=.FALSE.
C  EXIT IF ALL PLOTS NOT YET DONE
        GO TO 100
      ENDIF
C
      IF (PGOPEN) WRITE (IPLO,1505)
      PGOPEN=.FALSE.
C
C FINISH WHOLE JOB:
      call flush
      WRITE (IPLO,1508) NPAGE
 1508 FORMAT ('%%Trailer'/'%%DocumentFonts: '/
     &'%%Pages: ',I2/'%%EOF')
      fname=filnom(IPLO)
      CALL CLOFIL(IPLO)
      NAMFIL(1:40)=HCNAME('ps')
      L=LENGT(NAMFIL)
      write (ito,5000) 'Naming '//fname//' HCname '//NAMFIL(1:l)
      call rename(fname,namfil(1:L))
      WRITE (LPT,1550) namfil(1:L)
      WRITE (ITO,1550) namfil(1:L)
 1550 FORMAT ('Postscript file ',A,' completed')
 100  RETURN
      END
C
C
C
C
##ENDPIG
##PJB
C
C                    P J B   O W N    L I B R A R Y
C
C Created Sep 86 from the collection of PJB programs (often with attendant
C special routines) which are not (yet) to be put into the MAIN section
C
C LEVEL 50      PROGRAM CONVOL
      PROGRAM CONVOL
C
C *** CONVOL by PJB 78 ***
C
C*********************************************************************
C
C                        C O N V O L
C
C     MAIN PROGRAM TO CALCULATE THE FOURIER TRANSFORM OF A MOLECULAR
C     ORBITAL WAVE FUNCTION IN A CRYSTAL.
C
C  MODIFIED FOR DIVA WITH NEW MK3 LIBRARY Dec-86 PJB
C  MODIFIED FOR F77 Nov-84
C  NEW VERSION TO DEAL WITH NON-ZERO K  MADE FOR MK3 LIBRARY May 83
C
C**************************************************************************
C
C
      CHARACTER*10 FILNAM(22),FILNOM
C
      COMPLEX WCALC,F,F0,F1,F2,PSIFAC(2),FCL(3)
      COMPLEX WCAL(2,100),PSI(2,100),C1,C2,PHASE(24)
C
      DIMENSION FCAL(4)
C
      LOGICAL BEGIN,NONE,LATABS
C
/ATNAM/
/CELPAR/
/CONSTA/
/FUNIT/
/CARDRC/
/IOUNIT/
/NSYM/
      COMMON /NUMBS/IW
      COMMON /SCRAT/ KMAX(3),K(3),H(3),KK(3),EH(3),RH(3),
     & KS(150),KF(150),NEQ(24),HK(3,24),FC(2,2000,2)
      COMPLEX FC
/SYMDA/
/SYMREP/
/SYMTAB/
C
      EQUIVALENCE (FC(1,1,1),WCAL(1,1)),(FC(1,1500,1),PSI(1,1)),
     & (FC(1,1500,2),PHASE(1))
C
      DATA F0/(0.,0.)/
C
C     SET UP CRYSTALLOGRAPHY
      CALL PREFIN('CONVOL')
      WRITE (LPT,100)
  100 FORMAT (/' *** Calculation of Fourier Coefficients of Molecular
     &  Orbital Wave-Functions ***')
      CALL SYMOP
      CALL OPSYM(1)
      CALL RECIP
C CHECK THAT THE SPACE GROUP IS CENTRIC
      IF (.NOT. CENTRC) CALL ERRMES(1,0,
     & 'Program does not work with no centre of symmetry')
      CALL ASK('Give maximum SinTheta/lambda, (and IOUT if required)')
      IOU=IOUT
      CALL RDREAAL(SINTH,1,IPT,80,IER)
      CALL RDINTG(IOUT,IPT,IPT,80,IER)
      IF (IOUT .EQ. 0) IOUT=IOU
      CALL SETREP
      CALL ATOPOS
C      CALL TRREPS
      CALL WAVSET
      IF (IERR .NE.0) CALL ERRMES(0,0,'in CONVOL')
C
C  PRETEND NO CENTRE
      NC=NCENT
      LUNI=NOPFIL(1)
      LUNO=NOPFIL(2)
      NCENT=1
      NOPSAV=NOPC
      NOPC=NOPP
      NOP=NOPC
*** BEWARE CENTRC IF THIS NOW DOESN'T WORK
      CALL SYMUNI
      NOPC=NOPSAV
      NCENT=NC
      NOP=NOPC*NCENT
C
C      FIRST CALCULATE MAXIMUM VALUES OF INDICES
      DO 1 I = 1,3
      S = SINTH*CELL(I,1,1)*2.
C  FIX AND ADD 1 TO ALLOW FOR NON-ZERO K VECTORS
      KMAX(I) = IFIX(S)+1
    1 CONTINUE
C     CALCULATE NUMBERS OF H,K,L ETC VALUES
      NH = (2*KMAX(1)+1)
      NK = (2*KMAX(2)+1)
      NL = (2*KMAX(3)+1)
      NKH = NH*NK
      IF (NKH.GE.2000) CALL ERRIN2(NKH,0,'Number of reflections in ',
     &  'layer too big for dimension 2000 of array FC')
      NMAX = NKH*NL
      TYPE 500,KMAX,NMAX
      WRITE (LPT,500) KMAX,NMAX
  500 FORMAT ('0 MAXIMUM INDICES '3I4,'  TOTAL NUMBER OF POINTS',I6/)
      LRECL = 4*NH+2
C      LSCRCH=NOPFIL(11005)
      OPEN (UNIT=15,FILE='SCRATCH:',ACCESS='DIRECT',STATUS='SCRATCH',
     & RECL=LRECL)
      LSCRCH=15
      NO = (NK*NL+1)/2
C  NO IS THE RECORD NUMBER OF THE ROW CONTAINING F(000)
C  NREC IS THE NUMBER OF RECORDS
      NREC=(2*NO)-1
C  SET IW FOR ZERO LAYER
      NREC = 2*NO
C      KVEC = JFIX(2*AKVEC(3))
      KVEC=0
      NKVEC = KVEC*NK
C
C FIX ASYMMETRIC UNIT TO CONTAIN ALL POSITIVE L
      NAS=0
      DO 33 N=1,NASYM
      IF (ASYM(1,N).EQ.0 .AND.ASYM(2,N).EQ.0) GO TO 34
      IF (ASYM(3,N).NE.0) GO TO 33
C  LEAVE OUT THIS ONE
   34 NAS=NAS+1
      DO 35 I=1,4
   35 ASYM(I,NAS)=ASYM(I,N)
   33 CONTINUE
      NASYM=NAS
C  NOW GENERATE INDICES
      NLL = KMAX(3)+1
C  ONLY DO POSITIVE L
      DO 7 K3 = NLL,NL
C  CLEAR STORAGE
      DO 9 I=1,NKH
      DO 9 J=1,2
      FC(J,I,1)=F0
    9 FC(J,I,2)=F0
      K(3) = K3-1-KMAX(3)
      H(3) = FLOAT(K(3))
      DO 2 K2 = 1,NK
      K(2) = K2 - KMAX(2) - 1
      H(2) = FLOAT(K(2))
      DO 2 K1 = 1,NH
      K(1) = K1 - KMAX(1) - 1
      H(1) = FLOAT(K(1))
C  IS IT A LATTICE ABSENCE?
      IF (LATABS(H)) GO TO 2
C      IS IT IN ASYMMETRIC UNIT
      CALL INBOX(H,IN)
      IF (IN.GE.0) GO TO 36
C  OR ITS OPPOSITE (ASYMMETRIC UNIT MAY ALLOW POS OR NEG L)
      CALL GMREV(H,EH,3,1)
      CALL INBOX(EH,IN)
      IF (IN.LT.0) GO TO 2
C      AND INSIDE SINTHETA LIMIT?
   36 SINTH2 = VCTMOD(0.5,H,2)
      IF (SINTH-SINTH2.LT.0) GO TO 2
      DO 57 IC=1,2
      CALL GMADD(H,AKVEC,EH,1,3)
    4 IF (IC.EQ.2.AND.NCSTAR.EQ.2) GO TO 58
      CALL WACALC(EH,PSIFAC)
      IF (IOUT.EQ.99) WRITE (LPT,511) H,PSIFAC
  511 FORMAT (3F5.0,4F10.5)
      IF (ABS(REAL(PSIFAC(1))).LT.10E-7.AND.ABS(AIMAG(PSIFAC(1))).LT.1
     & 0E-7.AND.ABS(REAL(PSIFAC(2))).LT.10E-7.AND.ABS(AIMAG(PSIFAC(2)))
     & .LT.10E-7)GO TO 57
      GO TO 59
   58   DO 52 I=1,2
   52 PSIFAC(I)=CONJG(PSIFAC(I))
C
C  AFTER CALCULATING EACH PSI INTEGRAL GENERATE EQUIVALENTS IN THE LAYER
   59 DO 54 N = 1,NOPS
      IF (LREP(N).NE.1) GO TO 54
      CALL ROTSYM(H,EH,N,2)
      IF (ABS(ABS(EH(3))-ABS(H(3))) .GT. 10E-5) GO TO 54
C  NOT IN THIS LAYER
      TRA = 0.0
      DO 8 I=1,3
    8 TRA = TRA + EH(I)*TRANS(I,N)
      IS = JFIX(NH*(KMAX(2)+EH(2))+KMAX(1)+EH(1)+1)
      IL=1
      IF (EH(3).LT.0) IL=2
      DO 55 J=1,2
      F= PSIFAC(J)*CEXP(CMPLX(0.,TWOPI*TRA))*REP(IVEC,N)
   55 FC(J,IS,IL)=F
      IF (IOUT.EQ.98) WRITE(ITO,508) N,IS,H,EH,TRA,REP(IVEC,N),FC(1
     & ,IS,IL)
  508 FORMAT (1X,2I5,3F5.0,3F5.1,20F10.4)
   54 CONTINUE
   57 CALL GMREV(H,H,1,3)
    2 CONTINUE
C
      IF (IOUT.EQ.92)WRITE (LPT,503) ((N,FC(1,N,1)),N=1,NKH)
  503 FORMAT (I6,2F12.6)
C
C  PUT THIS LAYER INTO THE RANDOM ACCESS FILE
C  DO BOTH POSITIVE AND NEGATIVE LAYERS
      J3=K3
      DO 27 IL=1,2
      K(3)=J3-NLL
C  GET RECORD NUMBER FOR START OF LAYER
      IWS=NK*(J3-1)+1
      IW=IWS
      BEGIN = .TRUE.
      NONE = .TRUE.
      KS(J3) = NK
      KF(J3) = 0
      I = 1
      IS = 0
      DO 20 K2=1,NK
      I = IS+1
      DO 21 K1=1,NH
      IF (FC(1,I,IL).NE.F0 .OR.FC(2,I,IL).NE. F0)
     & GO TO 24
      I = I+1
   21 CONTINUE
C  NO VALUES IN THIS ROW
C  WRITE DUMMY RECORD
      IB=0
      WRITE (UNIT=LSCRCH,REC=IW) IB,IB
      IF (IOUT.EQ.97) WRITE (LPT,510) IW,IB,IB
      IW=IW+1
      IF (.NOT. NONE) KF(J3)=K2-1
      NONE = .TRUE.
      GO TO 20
   24 IF (BEGIN) KS(J3)=K2
      BEGIN = .FALSE.
      NONE = .FALSE.
      IB = K1
      I = IS+NH
      DO 22 K1=NH,1,-1
      IF (FC(1,I,IL) .EQ.F0 .AND. FC(2,I,IL).EQ.F0)
     & GO TO 22
      IE = K1
      GO TO 23
   22 I = I-1
      TYPE 103
  103 FORMAT (' LOGICAL ERROR #1')
      STOP
   23 IWS = IW
      IF (IOUT.EQ.97) WRITE (LPT,510) IW,IS,IB,IE,(((FC(1,IS+J,IL))
     & ),J=IB,IE)
      WRITE (UNIT=LSCRCH,REC=IW) IB,IE,((FC(IQ,IS+J,IL),IQ=1,2),J=IB,IE)
  510 FORMAT (1X,I5,'*',3I5,8F10.5/12(22X,8F10.5/))
      IW=IW+1
   20 IS = IS+NH
C  IF NO ZERO ROWS FOUND INSERT K FINAL
      IF (.NOT. NONE) KF(K3)=NK
      TYPE 501,K(3),KS(J3),KF(J3)
  501 FORMAT (' LAYER',I3,' DONE. INITIAL K',I4,' FINAL K',I4,12X,3I5)
C      WRITE (LPT,507) K(3),KS(J3),KF(J3)
  507 FORMAT (' LAYER',I3,' INITIAL K',I3,' FINAL K',I3/)
      IF (K(3) .EQ. 0) GO TO 7
   27 J3=NL-K3+1
    7 CONTINUE
      FILNAM(1)=FILNOM(LUNO)
      FILNAM(2)=FILNOM(LUNI)
      WRITE (LPT,19)FILNAM(2),FILNAM(1)
   19 FORMAT (/' Reflection indices from file ',A10,', output to file ',
     & A10)
      CALL INPUTN(LPT)
C
C
C  NOW CARRY OUT THE CONVOLUTION
       WRITE (LPT,10) SINTH,(ATNAME(I),I=1,2),(ATNAME(I),I=1,2)
   10 FORMAT ('0Structure Factors calculated by the Convolution Method',
     &' from Molecular Orbital Wave-functions'/15X,'Convolution termin',
     &'ated at sintheta/lambda =',F6.4/'0    h    k    l    sinth/l '
     &,1X,2(3X,'Atom ',A4,2X),4X,'Overlap'8X,'Total'/62X,A4,1X,A4)
C
   72 READ (LUNI,512,END=100) KK
  512 FORMAT (3I5)
C
C NEXT GENERATE OTHER K TO COPE WITH STAR AND MULTI-DIMENSIONAL REPS
      CALL INDFLO(HK(1,1),KK)
      NEQ(1)=0
      NE=1
      PHASE(1)=CMPLX(1.,0.)
C  GENERATE INEQUVALENT EQUIVALENT INDICES
      DO 84 N=1,NOPC
      IF (N.GT.NOPS) GO TO 85
      IF (LREP(N).EQ.1) GO TO 87
   85 CALL ROTSYM(HK(1,1),RH,N,2)
      DO 86 NP=1,NOPS
      IF (LREP(NP).NE.1) GO TO 86
      CALL ROTSYM(RH,EH,NP,2)
C  CHECK OPPOSITE ALSO
      DO 86 IR=1,2
      CALL EQVEC(HK,EH,NE,M,NOPC)
      IF (M.GT.NE) GO TO 86
C  EQUIVALENT FOUND INCREASE MULTIPLICITY
      NEQ(M)=NEQ(M)+1
      GO TO 84
   86 CALL GMREV(EH,EH,3,1)
C
C  IF GET HERE, NO EQUIVALENTS ADD TO LIST
      NE=NE+1
      CALL GMEQ(RH,HK(1,NE),3,1)
      ANGL=TWOPI*SCALPR(TRANS(1,N),RH)
      PHASE(NE)=CEXP(CMPLX(0.,ANGL))
      NEQ(NE)=1
      GO TO 84
   87 NEQ(1)=NEQ(1)+1
   84 CONTINUE
C
      DO 75 I=1,3
   75 FCAL(I)=F0
      DO 81 IREF=1,NE
      DO 74 I=1,3
   74 FCL(I)=F0
      CALL INDFIX(HK(1,IREF),K)
      NUM = NK*(KMAX(3)+K(3))+ (KMAX(2)+K(2)) + 1
      NUM = NUM-NO
      DO 66 K3 = 1,NL
      KN3 = K3-K(3)
      IF (KN3 .LE. 0 .OR. KN3 .GT. NL) GO TO 66
      N2 = NK*(K3-1)
      IF(KS(K3).GT.KF(K3)) GO TO 66
      DO 64 K2 = KS(K3),KF(K3)
      N = N2+K2
      KN2 = K2-K(2)
      IF (KN2 .LT. KS(KN3) .OR. KN2 .GT. KF(KN3)) GO TO 64
      NN = N-NUM
      IF (IOUT.EQ.96) WRITE (LPT,506)K,K1,K2,K3,KN1,KN2,KN3,N,NN
  506 FORMAT (20I5)
      IW = N
      IF (IW.GT.NREC) GO TO 64
      READ (UNIT=LSCRCH,REC=IW) IB,IE
      IF (IB.EQ.0 .OR. IB.GT.IE) GO TO 64
      IW = N
      IF (IW.GT.NREC) GO TO 64
      READ (UNIT=LSCRCH,REC=IW) I,I,((WCAL(IQ,I),IQ=1,2),I=IB,IE)
      IW = N-NUM
      IWW = IW
      IF (IW.GT.NREC) GO TO 64
      READ (UNIT=LSCRCH,REC=IW) NB,NE
      IF (NB.EQ.0 .OR. NB.GT.NE) GO TO 64
      IW = IWW
      IF (IW.GT.NREC) GO TO 64
      READ (UNIT=LSCRCH,REC=IW) NB,NE,((PSI(IQ,I),IQ=1,2),I=NB,NE)
      DO 60 K1 = IB,IE
      KN1 = K1-K(1)
      IF (KN1 .LT. NB .OR. KN1 .GT. NE) GO TO 60
      F1 = CONJG(PSI(1,KN1))
      F2 = CONJG(PSI(2,KN1))
      IF (F1 .EQ. F0 .AND. F2.EQ.F0) GO TO 60
      C1 = WCAL(1,K1)
      C2 = WCAL(2,K1)
      IF (C1 .EQ. F0 .AND. C2.EQ.F0) GO TO 60
      FCL(1) = FCL(1) +F1*C1
      FCL(2) = FCL(2)+F2*C2
      FCL(3) = FCL(3)+F1*C2+F2*C1
      IF (IOUT.EQ.95) WRITE (LPT,505) K,N,K1,K2,K3,C1,NN,KN1,KN2,KN
     & 3,F1,FCL
  505 FORMAT (1X,7I4,2F10.3/13X,4I4,2F10.3,2X,2F10.3,6F8.2)
   60 CONTINUE
   64 CONTINUE
   66 CONTINUE
      IF (IOUT.EQ.94) WRITE (LPT,513) KK,K,NEQ(IREF),PHASE(IREF),FC
     & L(1)
  513 FORMAT (1X,3I4,2X,3I4,2X,I6,2F8.4,2X,2F10.3)
      DO 88 I=1,3
   88 FCAL(I)=FCAL(I)+REAL(FCL(I)*PHASE(IREF))*FLOAT(NEQ(IREF))
C  AS CENTRO-SYMMETRIC WE ONLY WANT THE REAL PART
      IF (IOUT.EQ.93) WRITE (LPT,516) K,FCL,PHASE(IREF),NEQ(IREF)
  516 FORMAT (3I5,4(2F9.3,2X),I5)
   81 CONTINUE
C     MULTIPLY BY 1/V
   71 FCAL(4)=FCAL(1)+FCAL(2)+FCAL(3)
      DO 73 I=1,4
   73 FCAL(I) = FCAL(I)/(V(1)*FLOAT(NOPC))
      CALL INDFLO(H,KK)
      SINTH2 =  VCTMOD(0.5,H,2)
      WRITE (LPT,17) KK,SINTH2,FCAL
   17 FORMAT (1X,3I5,F10.4,4(4X,F10.5))
      TYPE 504,KK,FCAL
  504 FORMAT (1X,3I5,4F10.4)
      WRITE (LUNO,18) KK,FCAL
   18 FORMAT (3I5,4F10.5)
      GO TO 72
C
  100 STOP
C
      END
C
C
C
C
      SUBROUTINE SETREP
C
C *** SETREP updated by JCM 22 Oct 87 ***
C
      CHARACTER*4 LABEL(3),WORD
C
      LOGICAL KZERO,NOTRAN,FREPN
C
/CARDRC/
/IOUNIT/
/NSYM/
/SCRACH/
/SYMDA/
/SYMREP/
/SYMTAB/
C REORDERED FOR BAD BOUNDARIES - JANE MUST HAVE WHATEVER NEEDS IT
      COMMON /SCRAT/VEC(3),SIMT(9),SINV(9),TEMP(9),ITAB(24),
     & JTAB(24),LTAB(24),ICNT(4),AK(3,2),TRN(9),KTAB(24),INTG(3),
     & JUNK(6)
      COMPLEX VEC,SINV,SIMT,TEMP
      COMPLEX C1,C0
      DIMENSION REAVEC(6)
      EQUIVALENCE (VEC(1),REAVEC(1))
C
      DATA LABEL/'SIMT','MTRX','REPN'/
C
C
      NCARD=ICDNO(22)
      IF (NCARD.EQ.0) THEN
      WRITE (LPT,249)
  249 FORMAT (' No V cards to define the representaion of the',
     & ' space-group have been given')
      GO TO 101
      ENDIF
C
      KZERO=.FALSE.
      FREPN=.FALSE.
      NGENC=NGEN+NCENT-1
C
C MARK SLOT NOPC+1 FOR CENTRE OF SYMMETRY
      IF (CENTRC) IGENER(NGENC)=NOPC+1
      C0=CMPLX(0.,0.)
      C1=CMPLX(1.,0.)
      NC=0
C  INITIALISE
      CALL JGMZER(ITAB,1,NOPC)
      CALL JGMZER(LTAB,1,NOPC)
      DO 12 I=1,NGEN
      ITAB(I)=IGENER(I)
      LTAB(IGENER(I))=I
   12 ICNT(I)=0
      ICNT(NGENC)=0
      ICNTS=0
C
      ID=IABS(INREAD(22))
      INREAD(22)=-ID
C
      DO 2 NC=1,NCARD
    1 CALL CARDIN(ID,ICARD)
      ID=ID+NYZ
      IPT=2
      CALL RDWORD(WORD,LENG,IPT,IPT1,80,0,IER)
      IF (IER.NE.0) GO TO 150
      ILAB=NCFIND(WORD,LABEL,3)
      IF (ILAB.EQ.0) GO TO 151
C
      DO 4 I=1,ILAB
      IPT=IPT1
      CALL RDINTG(INTG(I),IPT,IPT1,80,IER)
      IF (IER.NE.0) GO TO 150
    4 CONTINUE
C
      CALL CGMZER(VEC,1,3)
      CALL RDNUMS(REAVEC,IPT1,6,NUM,IER)
      IF (IER.NE.0) GO TO 150
      GO TO (7,6,5),ILAB
C
C  HERE FOR REPN
    5 FREPN=.TRUE.
      NREP=INTG(1)
      IF (NREP.GT. 3) GO TO 152
      IVEC=INTG(2)
      IF (IVEC.LT.1 .OR. IVEC.GT.NREP) GO TO 153
      JVEC=INTG(3)
      IF (JVEC.LT.1 .OR. JVEC.GT.NREP) GO TO 153
      DO 88 IJ=1,3
  88  AKVEC(IJ)=REAL(VEC(IJ))
      NDIM=NREP*NREP
      GO TO 2
C
C  HERE FOR MTRX
    6 IOP=INTG(1)
      IAX=INTG(2)
      IF (IAX.GT.3) GO TO 154
      IF (IOP.EQ.1) GO TO 9
      DO 10 I=1,NGEN
      IF (IOP.EQ.IGENER(I)) GO TO 11
   10 CONTINUE
      GO TO 155
    9 IOP=NOPC+1
      I=NGENC
   11 ICNT(I)=ICNT(I)+2**(IAX-1)
      IF (NUM.GT.6) NUM=6
      IF (MOD(NUM,2).NE.0) NUM=NUM+1
      NUM=NUM/2
      CALL CGMEQ(VEC,REP(3*IAX-2,IOP),NUM,1)
      GO TO 2
C
C  HERE FOR SIMT
    7 I=INTG(1)
      IF (I.GT.3) GO TO 156
      ICNTS=ICNTS+2**(I-1)
C THIS REPLACES CALL GMEQ(VEC,TRN(3*I-2),NUM,1) WHICH CAN'T BE RIGHT
      DO 89 IJ=1,NUM
  89  TRN(3*I-3+IJ)=REAL(VEC(IJ))
      GO TO 2
C
C
C ACTION ON READING ERRORS
  150 WRITE (LPT,250)IER,IPT,IPT1, ICARD
  250 FORMAT (' Error (IER=',I4,' in field',I3,'-',I2,')',
     & ' interpreting the card which reads:'/1X,80A1)
      GO TO 102
C
  151 WRITE (LPT,251) WORD
  251 FORMAT (' Word ',A4,' on V card not rcognised')
      GO TO 102
C
  152 WRITE (LPT,252) NREP
  252 FORMAT (' Dimension of representation read as',I3,', it should n
     & ot be greater than 3.')
      GO TO 101
C
  153 WRITE (LPT,253) NREP,IVEC,JVEC
  253 FORMAT (' Partner numbers must be between 1 and',I3,'(the dimensi
     & on of the representation) - (',I3,' and',I3,' were read')
      GO TO 102
C
  154 WRITE (LPT,254) IAX,NREP
  254 FORMAT (' Label of a matrix row (',I3,') is greater than the dim
     & ension of the representation (',I3,')')
      GO TO 102
C
  155 WRITE (LPT,255) IOP
  255 FORMAT (' Element',I3,' for which a matrix row has been read is
     & not one of the chosen generators')
      GO TO 102
C
  156 WRITE (LPT,256) I,NREP
  256 FORMAT (' The label of a row read for the symmetry transformatio
     & n (',I3,') is greater the the dimension of the representation ('
     & ,I3,')')
      GO TO 102
C
  258 FORMAT (' The representation matrix for element',I3' i
     & s absent, incomplete or incorrect ICHK =,'I3,/)
C
C THIS LOT IS NOT REFFERED TO - SOMEWHERE THERE MUST BE A TEST WHICH SHOULD
C  160 WRITE (LPT,260)
C  260 FORMAT (' The projection of the function given on the
C     & function required is zero.'/)
C      GO TO 101
C
  102 IERR=IERR+1
C
   2  CONTINUE
C
C  HERE TO CLEAN UP AND CHECK
   26 IF (FREPN) GO TO 157
       WRITE (LPT,257)
  257 FORMAT (' No "V REPN" card giving dimension and k-vector of repr
     &esentation found')
      GO TO 101
 157  WRITE (LPT,105) IVEC,NREP
  105 FORMAT ('0The function given should transform as partner number'
     &,I3,' in the',I3,'-dimensional representation'/' whose representi
     &on matrices are given for the following elements:')
C
C  SET IVEC TO GET THE ELEMENT REQUIRED
      IVEC=NREP*(JVEC-1)+IVEC
      ICHK=2**NREP-1
      DO 13 I=1,NGENC
      IF (ICNT(I).EQ.ICHK) GO TO 14
      WRITE (LPT,258)I,ICNT(I)
      IERR=IERR+1
   14 CONTINUE
      IF (NREP .NE.2) GO TO 13
      J=IGENER(I)
      REP(3,J)=REP(4,J)
      REP(4,J)=REP(5,J)
C  WRITE THEM OUT
C
   13 CONTINUE
      WRITE (LPT,110) (IGENER(N),N=1,NGEN)
      II=0
      DO 15 I=1,NREP
      WRITE (LPT,111) (((REP(II+J,IGENER(N))),J=1,NREP),N=1,NGEN)
      WRITE (LPT,113)
   15 II=II+NREP
      IF (.NOT. CENTRC) GO TO 16
      WRITE (LPT,114)
      II=0
      DO 17 I=1,NREP
      WRITE (LPT,112) (REP(II+J,25),J=1,NREP)
      WRITE (LPT,113)
   17 II=II+NREP
C
C  SEE WHETHER TRANSFORMATION OF THE REPRESENTATIONS IS REQUIRED
   16 IF (ICNTS.NE.0) GO TO 18
      NOTRAN=.TRUE.
C  SET UNIT TRANSFORMATION
      CALL CGMUNI(SIMT,NREP)
      GO TO 19
   18 IF (ICNTS.EQ.ICHK) GO TO 159
      WRITE (LPT,259)
  259 FORMAT (' The transformation of the representation is',
     & ' incomplete or incorrect'/)
      GO TO 101
 159  IF (NREP.NE.2) GO TO 20
      TRN(3)=TRN(4)
      TRN(4)=TRN(5)
   20 DO 21 I=1,NDIM
   21 SIMT(I)=CMPLX(TRN(I),0.)
      NOTRAN=.FALSE.
C
C  REPORT THE TRANSFORMATION
      WRITE (LPT,115)
  115 FORMAT (/' The representation is to be transformed by the ',
     & 'unitary matrix:')
      II=0
      DO 70 N=1,NREP
      DO 71 I=1,NREP
   71 TRN(I)=REAL(SIMT(II+I))
      WRITE (LPT,116) (TRN(I),I=1,NREP)
  116 FORMAT ('+',70X,3F10.5)
      WRITE (LPT,113)
   70 II=II+NREP
C
C  NEXT CONSTRUCT THE INVERSE TRANSFORMATION MATRIX
      ANORM=REAL(SIMT(IVEC))
      IF (ANORM.GT.10E-5) GO TO 161
      NUMOP=NUMOP*NCENT
      NUMO=NOPC*NCENT
      WRITE (LPT,261)NUMOP,NUMO
  261 FORMAT (' The elements whose representation matrices a
     &re given only generate',I3,' out of the',I3,' elements of the gr
     &oup'/)
      GO TO 101
C
 161  ANORM=1./ANORM
C  IF TRANSFORMED SET NORMALISATION
      IJ=0
      DO 65 I=1,NREP
      IJ=IJ+I
      JI=IJ
      SINV(IJ)=SIMT(IJ)
      DO 65 J=I,NREP
      IF (I.EQ.J) GO TO 65
      IJ=IJ+1
      JI=JI+NREP
      SINV(JI)=SIMT(IJ)
      SINV(IJ)=SIMT(JI)
   65 CONTINUE
C  TRANSFORM THE REPRESENTATIONS HERE
      DO 66 N=1,NGENC
      J=IGENER(N)
      CALL CGMPRD(REP(1,J),SIMT,TEMP,NREP,NREP,NREP)
   66 CALL CGMPRD(SINV,TEMP,REP(1,J),NREP,NREP,NREP)
   19 NUMOP=NGEN
C FORM THE REST OF THE REPRESENTATION MATRICES FROM THE MULTIPLICATION TABLE
      NUM=0
   24 NUM=NUM+1
      J=ITAB(NUM)
      DO 23 N=1,NUM
      I=ITAB(N)
      DO 22 IP=1,2
      MUL=MULTAB(I,J)
      IF (LTAB(MUL).NE.0) GO TO 29
      NUMOP=NUMOP+1
      ITAB(NUMOP)=MUL
      LTAB(MUL)=NUMOP
      CALL CGMPRD(REP(1,I),REP(1,J),REP(1,MUL),NREP,NREP,NREP)
      IF (NUMOP.EQ.NOPC) GO TO 35
   29 MUL=J
      J=I
      I=MUL
   22 CONTINUE
   23 CONTINUE
      IF (NUMOP.GT.NUM) GO TO 24
C
   35 DO 34 N=1,NOPC
      NORD(N)=NORDER(N)
      LREP(N)=-1
      TEST=CABS(REP(IVEC,N))
      IF (TEST.LT.10.E-4) LREP(N)=0
      IF (1.-TEST.LT.10.E-4) LREP(N)=1
   34 CONTINUE
C
C
C  GENERATE THE STAR OF K AND SEPARATE THE CORRESPONDING SUBGROUP
      IF (ABS(AKVEC(1))+ABS(AKVEC(2))+ABS(AKVEC(3)).LT.10E-4)
     & KZERO=.TRUE.
C
C  CLEAR TABLES
      DO 31 N=2,NOPC
      KTAB(N)=1
      LTAB(N)=0
   31 JTAB(N)=0
      NUM=1
      ITAB(1)=1
      JTAB(1)=1
      KTAB(1)=3
      LTAB(1)=1
      IF (KZERO) GO TO 32
C
C  TEST THE ACTION OF THE CENTRE IF PRESENT
      NC=NCENT
      IF (NC.EQ.1) GO TO 37
      CALL GMEQ(AKVEC,AK,3,1)
      CALL GMREV(AK,AK,3,1)
      NC=1
      CALL EQPOS(AK,AKVEC,NC,NF,2)
      NC=NF
   37 DO 30 N=2,NOPC
      CALL ROTSYM(AKVEC,AK,N,2)
      DO 38 IC=1,NC
      I=1
      CALL EQPOS(AK,AKVEC,I,NF,2)
      I=NF
      IF (I.EQ.2) GO TO 38
C
C  UNCHANGED BY OPERATOR ADD TO SUB-GROUP
      KTAB(N)=2
C  MARK WHETHER ALSO INVARIANT FOR PARTNER
      IF (LREP(N).EQ.1) KTAB(N)=KTAB(N)+1
C  MARK WHETHER INVERTING
      KTAB(N)=KTAB(N)*(3-2*IC)
      JTAB(N)=NUM
      GO TO 30
   38 CALL GMREV(AK,AK,3,1)
   30 CONTINUE
C
C  NOW WORK OUT THE NEW ORDER OF ELEMENTS
   47 NUM=0
      DO 46 J=1,3
      JJ=4-J
      DO 33 N=1,NOPC
      IF (IABS(KTAB(N)).NE.JJ) GO TO 33
      NUM=NUM+1
      LTAB(NUM)=0
      IF (J.NE.3) LTAB(NUM)=ISIGN(1,KTAB(N))
      ITAB(NUM)=N
      JTAB(N)=NUM
   33 CONTINUE
      IF (J.EQ.1) NOPP=NUM
      IF (J.EQ.2) NOPS=NUM
   46 CONTINUE
C
      CALL SHUFLE(ITAB,JTAB)
C
C  SKIP IF NO PROBLEM WITH CENTRE
      IF (NC.EQ.1 .OR. KZERO) GO TO 51
      IC=0
      DO 40 N=1,NOPS
      IF (LTAB(N).NE.-1) GO TO 40
      IC=N
      CALL GMREV(TRANS(1,N),TRANS(1,N),3,1)
      CALL GMREV(SYM(1,1,N),SYM(1,1,N),3,3)
C  AND FORM PRODUCT REPRESENTATION WITH THE CENTRE
      CALL CGMEQ(REP(1,N),TEMP,NREP,NREP)
      CALL CGMPRD(REP(1,NOPC+1),TEMP,REP(1,N),NREP,NREP,NREP)
   40 CONTINUE
      IF (IC.EQ.0) GO TO 51
      NUM=NOPS+1
      DO 41 N=NUM,NOPC
      M=MULTAB(IC,N)
   44 IF (LTAB(N)) 42,45,43
   45 LTAB(N)=-LTAB(M)
      IF (LTAB(M).NE.0) GO TO 44
      LTAB(N)=-1
   42 IF (LTAB(N)*LTAB(M).GT.0) STOP 'ERROR IN GROUP'
      LTAB(M)=1
      CALL GMREV(SYM(1,1,N),SYM(1,1,N),3,3)
      CALL GMREV(TRANS(1,N),TRANS(1,N),3,1)
C  AND FORM PRODUCT REPRESENTATION WITH THE CENTRE
      CALL CGMEQ(REP(1,N),TEMP,NREP,NREP)
      CALL CGMPRD(REP(1,NOPC+1),TEMP,REP(1,N),NREP,NREP,NREP)
      GO TO 41
   43 IF (LTAB(N)*LTAB(M).GT.0) STOP 'ERROR IN GROUP'
      LTAB(M)=-1
   41 CONTINUE
      GO TO 51
C
C  HERE IF K-VECTOR IS ZERO
   32 NOPS=NOPC
      NOPP=0
C  SEE WHETHER ORDER SHOULD BE CHANGED
      DO 27 N=1,NOPC
      KTAB(N)=2
      IF (LREP(N).NE.1) GO TO 27
      NOPP=NOPP+1
      KTAB(N)=3
   27 CONTINUE
      IF (NOPP.LT.NOPC) GO TO 47
C
   51 WRITE (LPT,117) JVEC,AKVEC
  117 FORMAT ('0The function transforming as partner number',I3,' of t
     &he representation with wave-vector',3F8.4,' will be used')
      IF (KZERO .OR. NOPP.EQ.NOPC) GO TO 72
      WRITE (LPT,118) NOPS
  118 FORMAT ('0The symmetry elements are rearranged so the the',I3,'
     &elements of the sub-group of K come first')
      NOPSAV=NOPC
C  SET NC TO INDICATE CENTRE IN SUB-GROUP
      NCSTAR=2
      IF (.NOT. CENTRC .OR. NC.EQ.2) NCSTAR=1
      IC=NCENT
      CALL OPSYM(1)
      NOPC=NOPSAV
      NCENT=IC
   72 DO 52 N=1,NOPC,2
      NN=N+1
      WRITE (LPT,110) N,NN
  110 FORMAT ('0',I3,' =',60X,I3,' =')
      II=0
      DO 36 I=1,NREP
      WRITE (LPT,111) (REP(II+J,N),J=1,NREP)
      IF (NN.LE.NOPC) WRITE (LPT,112) (REP(II+J,NN),J=1,NREP)
      WRITE (LPT,113)
  111 FORMAT ('+',2(8X,3(2F8.4,2X)))
  112 FORMAT ('+',70X,3(2F8.4,2X))
  113 FORMAT (1X)
   36 II=II+NREP
   52 CONTINUE
      LREP(NOPC+1)=0
      WRITE (LPT,114)
  114 FORMAT ('0The matrix representing the centre of symmetry is:')
      II=0
      DO 39 I=1,NREP
      WRITE (LPT,112) (REP(II+J,NOPC+1),J=1,NREP)
      WRITE (LPT,113)
   39 II=II+NREP
      LREP(NOPC+1)=-1
      TEST=CABS(REP(IVEC,NOPC+1))
      IF (TEST.LT.10.E-4) LREP(NOPC+1)=0
      IF (1.-TEST.LT.10.E-4) LREP(NOPC+1)=1
      GO TO 100
C
 101  IERR=IERR+1
  100 RETURN
      END
C
C
C
C
      SUBROUTINE TRREPS
C
C *** TRREPS by PJB 10 Apr 87 ***
C
      DIMENSION P(3),PP(3),T(3),XX(3)
/CONSTA/
/IOUNIT/
/NSYM/
/POSNS/
/SYMDA/
/SYMREP/
C
      DO 5 IAT=1,NATOM
      CALL INCELL(X(1,IAT),XX)
      DO 1 N=1,NOPC
      CALL ROTSYM(XX,PP,N,1)
      DO 6 IR=1,NCENT
      IF (IR.EQ.2) CALL GMREV(PP,PP,3,1)
      CALL INCELL(PP,P)
      CALL GMSUB(PP,P,T,3,1)
      TT=SCALPR(T,AKVEC)
      TREP(N,IR,IAT)=CEXP(CMPLX(0.,TWOPI*TT))*REP(IVEC,N)
    6 CONTINUE
      IF (IOUT.EQ.80) WRITE(LPT,4000)IAT,N,(TREP(N,IR,IAT),
     & IR=1,NCENT)
4000  FORMAT (2I5,2(2F10.5,4X))
    1 CONTINUE
    5 CONTINUE
      RETURN
      END
C
C
C
C
      SUBROUTINE WACALC(H,WCALC)
C
C *** WACALC by PJB 10 Apr 87 ***
C
CX
CC 17B
CH Calculates PSI*EXP(I*K.R) for the reflection H.
CA On entry H is  1x3 real vector containing h,k,l
CA On exit CALC holds the answer.
C
CP PREFIN,RECIP,SYMOP,ATOPOS,WAVSET,AND SYMINV must be obeyed first
C
      DIMENSION RH(3),AH(3),H(3),XX(3,2)
      COMPLEX WCALC(2),WAVFAC,WAVFC,SUM1,TERM,TERM1,CFAC
/CONSTA/
/IOUNIT/
/NSYM/
/POSNS/
/SYMDA/
/SYMREP/
/WAVCHR/
/WAVEFN/
C
      CALL GMSUB(H,AKVEC,AH,3,1)
C     CALCULATE SINTHETA/LAMDA
      AK = VCTMOD(TWOPI,H,2)
      J = 0
      CALL GMZER(WCALC,2,2)
      N1=0
C     SUM OVER ATOMS IN CELL
      DO 1 N = 1,NATOM
      CALL EQPOS(XX,X(1,N),N1,N2,3)
      IF (N2.GT.2) THEN
      WRITE (LPT,101)
  101 FORMAT (/' WACALC won''t work with more than two distinct sites')
      STOP 'More than 2 sites'
      ENDIF
      IF (N2.GT.N1) N1=N2
      SUM1 = CMPLX(0.,0.)
      IF (.NOT. CENTRC) GO TO 2
C  CHECK THE ACTION OF THE CENTRE OF SYMMETRY ON WAVFAC
      CALL GMREV(H,RH,3,1)
      CFAC=WAVFAC(N,RH)*REP(IVEC,NOPC+1)
C
C     SUM OVER EQUIVALENTS
C  REPLACE NOPC BY NOPS Jan 87
    2 DO 3 I = 1,NOPS
      IF (LREP(I).EQ.0) GO TO 3
      CALL ROTSYM(AH,RH,I,-1)
      F1=SCALPR(X(1,N),RH)+SCALPR(TRANS(1,I),AH)
      CALL ROTSYM(H,RH,I,-1)
      TERM = CEXP(CMPLX(0.,TWOPI*F1))
C     CALCULATE WAVEFUNCTION FACTOR
      WAVFC = WAVFAC(N,RH)
      IF (I.NE.1 .OR. .NOT. CENTRC)GO TO 4
      IF (ABS(WAVFC).GT. .0001) GO TO 5
      IF (ABS(CFAC).GT..0001) STOP 'CFAC ERROR IN WAVFC'
      CFAC=CMPLX(1.,0.)
      GO TO 4
    5 CFAC=CFAC/WAVFC
C    4 TERM1 = TERM*WAVFC*TREP(I,1,N)
    4 TERM1 = TERM*WAVFC*REP(IVEC,I)
C  ADD CENTROSYMMETRIC PART IF REQUIRED
C      IF (CENTRC) TERM1=TERM1+CONJG(TERM)*WAVFC*CFAC*TREP(I,2,N)
      IF (CENTRC) TERM1=TERM1+CONJG(TERM)*WAVFC*CFAC*REP(IVEC,I)
      SUM1 = SUM1 + TERM1
      IF (IOUT.EQ.89) WRITE (LPT,4000) RH,I,SUM1,TERM1,WAVFC,
     & F1,CFAC
4000  FORMAT (3F5.0,I5,10F10.5)
    3 CONTINUE
      L = NFUN(1,N)
      FORFAC = FORMFC(AK,L,2,N)
      IF (IOUT.EQ.88) WRITE (LPT,4001) H,AK,SUM1,AMULT(N),FORFAC,L,N
4001  FORMAT (3F5.0,5F10.5,2I5)
      BMULT=FLOAT(NREP*NOPC)/FLOAT(NOPS)
      SUM1 = SUM1*(AMULT(N))*FORFAC*BMULT
C  MUTIPLY BY FLOAT(NREP*NOPC)/FLOAT(NOPS) TO RESTORE NORMALISATION
C
      IF (IOUT.EQ.87) WRITE (LPT,4002) N2,H,AK,WCALC(N2),SUM1
     & ,FORFAC,BMULT,L,N
4002  FORMAT (I5,3F5.2,6F8.4,F4.0,2I4)
    1 WCALC(N2) = WCALC(N2)+SUM1
      RETURN
      END
C
C
C
C
       COMPLEX FUNCTION WAVFAC(IAT,H)
C
C *** WAVFAC by PJB ***
C
C     RELATIONSHIP BETWEEN Y(M) AND Y(-M) CHANGED 18:10:77
C
      DIMENSION OH(3),H(3)
      COMPLEX Y(45),COEFF,FORM,PHASE,AI
/CONSTA/
/IOUNIT/
/QROT/
/RADINT/
/WAVCHR/
/WAVEFN/
C
      NNN=NEIG(IAT)
      NN=NFUN(1,IAT)
      DO 4 I=1,NNN
      IF (NFUN(I,IAT).GT.NN) NN=NFUN(I,IAT)
    4 CONTINUE
      I = 0
      NN = NN+1
      NUM = NN*(NN+1)/2
C
C     GET ANGLES FOR SPHERICAL HARMONICS
      CALL GMPRD(H,ROT(1,1,IAT),OH,1,3,3)
      CALL UNIVEC(OH,AK)
      T = ACOS(OH(3))
      P = 0.
      IF (1.-ABS(OH(3)).GT.10E-5 .AND. AK.GT.10E-5)
     & P = ATAN2(OH(2),OH(1))
C
C     CALCULATE ALL NECCESSARY SPHERICAL HARMONICS
      CALL SPHARM(Y,T,P,NN,NUM)
C  DO THE SUM OVER THE M VALUES FOR THE PRESCIBED L
      L = NN-1
      PHASE = CMPLX(1.,0.)
      AI = CMPLX(0.,1.)**L
      NS = NUM-L
      FORM = CMPLX(0.,0.)
      SIG = -1.
      DO 2 I = NS,NUM
      SIG = -SIG
    2 FORM = FORM + Y(I)*AMP(2*I-1,IAT)+ SIG*CONJG(Y(I))*AMP(2*I,IAT)
      WAVFAC = FOURPI*AI*FORM
      IF (IOUT.EQ.85) WRITE (LPT,500) H,OH,IAT,L,AI,FORM,WAVFAC
  500 FORMAT (3F5.0,3F8.4,2I5,6F10.5)
      RETURN
      END
C
C
C
C
      SUBROUTINE WAVSET
C
C *** WAVSET by PJB ***
C
C  SUBROUTINE TO DIRECT THE READING OF W CARDS FOR MOLECULAR
C  ORBITAL CALCULATIONS
C
      CHARACTER*4 WORD,WWORDS(3)
/ATNAM/
/CARDRC/
/IOUNIT/
/POSNS/
      DATA WWORDS/'RADF','ROTN','FUNC'/
C
C     CONVERSION AU TO ANGSTROMS
      S = 1./0.529172
      NCARD=ICDNO(23)
      IF (NCARD .EQ.0)THEN
      WRITE (LPT,12)
   12 FORMAT ('0No W cards given: W ',A4,', ',A4,' and ',A4,' required')
      IERR=IERR+1
      GO TO 100
      ENDIF
C  CHECK NUMBER OF ATOMS
      IF (NATOM.GT.5) THEN
      WRITE (LPT,55) NATOM
   55 FORMAT ('0',I4,' independent atoms given, only 5 allowed')
      IERR=IERR+1
      NATOM=5
      ENDIF
C
      IERSAV=IERR
      IERR=0
      IDT=IABS(INREAD(23))
      INREAD(23)=-IDT
C
C  INITIALISE
      IEND=-1
      CALL RADFUN(IEDN,IEND)
      CALL READRT(IEND,IEND)
      CALL MOLORB(IEND,IEND)
C
      DO 3 N=1,NCARD
      CALL INPUTW(IAT,WORD,IDT,IPT)
      GO TO (3,4,5,6), 1+NCFIND(WORD,WWORDS,3)
    4 CALL RADFUN(IAT,IPT)
      GO TO 3
    5 CALL READRT(IAT,IPT)
      GO TO 3
    6 CALL MOLORB(IAT,IPT)
    3 CONTINUE
      IEND=0
      DO 1 IAT=1,NATOM
      WRITE (LPT,11) ATNAME(IAT)
   11 FORMAT (//' *********'/' *  ',A4,' *'/' *********')
    2 CALL RADFUN(IAT,IEND)
      CALL READRT(IAT,IEND)
      CALL MOLORB(IAT,IEND)
    1 CONTINUE
      IF (IERR.NE.0) WRITE (ITO,10)
   10 FORMAT (/' Errors in input of wave-functions')
      IERR=IERR+IERSAV
  100 RETURN
      END
C
C
C
C
C LEVEL 50      PROGRAM GETRL
      PROGRAM GETRL
C
C *** GETRL by PJB Aug 86 ***
C
C *****************************************************************************
C
C                              G E T R L
C
C  TO DERIVE THE RECIPROCAL VECTOR CORRESPONDING TO A SET OF ANGLES
C  OR THE ANGLES CORRESPONDING TO A RECIPROCAL VECTOR
C
C *****************************************************************************
C
      DIMENSION VAL(2500)
      DIMENSION V(3,3),UI(3,3),ANG(4),A(4),RV(3),LAB(2,3),H(3)
      LOGICAL SAYS
      COMMON /CDATA/IETAT,IA(2),NOMU(3),NOMLC(3),IDATE(5)
     & ,ITIME(4),ICOM(36),NUMERO,KCTRL,N1,VALCO(30),MANIP
     & ,N2,VALDEF(10),M,ICDESC(5),M1,VAL
      COMMON /GEO/U(3,3),AL
/IOUNIT/
/SCRACH/
C
C
      CALL INITIL('GETRL')
      LUN=NOPFIL(1)
      READ(LUN,1000) AL
 1000 FORMAT (6X,F10.4)
      DO 50 I=1,3
      READ(LUN,1003)(U(J,I),J=1,3)
 1003 FORMAT (6X,3F10.5)
   50 CONTINUE
C
C  INVERT UBM
      DO 30 I=1,3
      DO 30 J=1,3
   30 UI(I,J)=U(I,J)
      CALL TRINV3(UI,D)
C
  32  CALL ASK('Input of Angles, Indices, or Exit? (A,I or E)')
      IF (SAYS('A')) GO TO 31
      IF (SAYS('I')) GO TO 40
      IF (SAYS('E')) GO TO 100
      IF (SAYS('F')) GO TO 60
      GO TO 32
C
  31  CALL ASK('Give angles gamma, omega, nu')
      CALL RDNUMS(ANG,1,3,NUM,IER)
      IF (ABS(ANG(1))+ABS(ANG(2))+ABS(ANG(3)).EQ.0.) GO TO 32
      GO TO 61
C
   60 OPEN (2,FILE='CENTRA.DAT',STATUS='OLD')
      READ (2,1011)
 1011 FORMAT (1X)
  62  READ (2,1006,END=32) ANG
 1006 FORMAT (25X,4F9.3)
      WRITE (ITO,2124) ANG
 2124 FORMAT (' 2theta =',F8.2,' omega =',F8.2,' chi =',F8.2,
     & ' phi =',F8.2)
   61 CALL ATORL(ANG,RV,AL)
      CALL GMPRD(RV,UI,H,1,3,3)
      WRITE (ITO,2119) RV,H
 2119 FORMAT (' x =',F8.3,'  y =',F8.3,'  z =',F8.3/
     & ' h =',F8.3,'  k =',F8.3,'  l =',F8.3/)
      IF (SAYS('F')) GO TO 62
      GO TO 31
C
  40  CALL ASK('Give reflection indices h, k, l (floating)')
      CALL RDNUMS(RV,1,3,NUM,IER)
      IF (ABS(RV(1))+ABS(RV(2))+ABS(RV(3)).EQ.0.) GO TO 32
      CALL RLTOA(RV,ANG,IERR)
      IF (IERR.NE.0) THEN
        WRITE (ITO,3000)
3000    FORMAT (' Impossible geometry')
        GO TO 40
      ENDIF
      WRITE (ITO,2125) RV,ANG
 2125 FORMAT ('    h  =',F8.3,'    k  =',F8.3,'  l  =',F8.3/
     & ' 2theta =',F8.2,' omega =',F8.2,' chi =',F8.2,
     & ' phi =',F8.2)
      GO TO 40
C
 100  STOP
      END
C
C
C
C
      SUBROUTINE ATORL(AN,RV,AL)
C
C *** ATORL by PJB Aug 86 ***
C
C  CALCULATES RECIPROCAL LATTICE VECTORS FROM SCATTERING ANGLES
C  4-CIRCLE GEOMETRY
C
      DIMENSION RV(3),AN(4),A(4)
C
C  DIFFRACTION ANGLE POSITIVE FOR D15
      NLR=1
      DO 1 I=1,4
      A(I)=RADIAN(AN(I))
    1 CONTINUE
      RV(3)=SIN(A(3))
      CA3=COS(A(3))
      IF (CA3.LT.0) THEN
      A(4)=-A(4)
      CA3=-CA3
      ENDIF
      THETA=A(1)/2.
      D=2.*SIN(THETA)/AL
      PSI=-THETA+A(2)+A(4)
      RV(1)=SIN(PSI)*CA3
      RV(2)=COS(PSI)*CA3
      DO 2 I=1,3
      RV(I)=RV(I)*D
    2 CONTINUE
      RETURN
      END
C
C
C
C
      SUBROUTINE RLTOA(H,A,IER)
C
C *** RLTOA by PJB Aug 86 ***
C
C  RECIPROCAL LATTICE TO ANGLE CONVERSION - 4-CIRCLE HICHI
C
      DIMENSION H(3),A(4),SCR(12)
      COMMON /GEO/UBM(3,3),AL
C
C  DIFFRACTION ANGLES POSITIVE EXCEPT FOR D3
      NLR=1
C  SET NO ERROR
      IER=0
      CALL GMPRD(UBM,H,SCR,3,3,1)
C
      D2=0.
      DO 1 I=1,3
      D2 = D2+SCR(I)*SCR(I)
      IF (I.EQ.2) HYP=SQRT(D2)
    1 CONTINUE
      D = SQRT(D2)
C
C  CHECK GEOMETRY
      D2=AL*D/2
      IF (D2.LT.1) GO TO 3
      IER=-1
      GO TO 100
C
C  NOW GET ANGLES
    3 A(2)=ASIN(D2)
      A(3)=ATAN2(0.,-1.)-ATAN2(SCR(3),HYP)
      A(1)=2.*A(2)
      A(4)=-ATAN2(SCR(1),SCR(2))
C
      DO 6 I=1,4
      A(I)=DEGREE(A(I))
    6 CONTINUE
      A(4)=RANGER(A(4),180.,-180.)
C
 100  RETURN
      END
C
C
C
C
C LEVEL 50      PROGRAM GMLSQ
      PROGRAM GMLSQ
C
C *** GMSLQ by PJB Jun 86 ***
C
C ******************************************************************************
C
C                       G M L S Q
C
C MAIN PROGRAM GMLSQ FOR POLARISED NEUTRON GAMMAS LEAST SQUARES REFINEMENT
C
C ******************************************************************************
C
      CHARACTER *4 ISFWRD(20)
      LOGICAL PRINT,PRNCYC,FIRST
      LOGICAL DFLTSF
      EXTERNAL DFLTSF,DUMMY,PARRUN,VARSSF,LDUMMY
%      DIMENSION ALSQ(%MATS%),ISWDSP(3,20)
      DIMENSION K(3),H(3)
/DERVAR/
/FCAL/
      COMMON /GMOBS/ANUC,BNUC
/IOUNIT/
/NSYM/
/OBSCAL/
/PHASE/
/POSNS/
/PRBLEM/
/REFINE/
/SCLDAT/
/SCRACH/
       DATA ISFWRD/' ','SCAL','TFAC','X','Y','Z',
     & 'B11','B22','B33','B23','B13',
     & 'B12','SCAT','SITE','ITF',
     & 'XYZ','BIJ','XYZT','FAM1',
     & 'FAM2'/
** NB UPDATE LIKE SFLSQ TO USE XYZB,XYZS FACILITIES
      DATA ISWDSP/1,1,0, 1,2,0, 1,1,1, 2,0,1, 2,0,2, 2,0,3,
     & 2,0,4, 2,0,5, 2,0,6, 2,0,7, 2,0,8,
     & 2,0,9, 2,0,10, 2,0,11, 2,0,12,
     & -1,0,0, -2,0,0, -3,0,0, 1,0,0,
     & 2,0,0/
C
C ALTER VALUE HERE:
%      MATSZ=%MATS%
C
C SET UP STRUCTURE FACTOR CALCULATION:
      CALL PREFIN('GMLSQ')
      MAG=.FALSE.
      MESSAG='Reflection data'
      LUNI=NOPFIL(11)
      CALL SETFC
C
C SPECIFY PROBLEM:
      NFAM=2
      NGENS(1)=2
      NGENS(2)=NATOM
      NSPC(1)=20
      NSPC(2)=12
C
C SPECIES TYPES FOR EACH GENUS OF FAMILY 1:
      LF1SP(1)=1
      LF1SP(2)=-20
C
C SET UP INTO STANDARD SPACE:
      CALL LSETUP(20,ISWDSP,ISFWRD)
C
C NAMES SET UP SO THAT:
C FAMILY 1 GENUS 1 HAS SPECIES TFAC (BY ITSELF FOR NOW)
C   '    1    '  2 HAS GENUS NAME SCAL, SPECIES INDICATED TO BE 1,2,3 ETC
C
C FAMILY 2 IS AS USUAL THE PARAMETERS WHICH DEPEND ON THE ATOM.  GENUS NAMES
C ARE THEREFORE THE SAME AS ATOM NAMES, AND SPECIES NAMES ARE:
C X Y Z B11 B22 B33 B23 B13 B12 SCAT SITE ITF
      WRITE (LPT,2020)
2020  FORMAT (///' Least Squares Refinement - polarised neutron",
     & ' gammas')
C
C READ I AND (MOST) L CARDS:
      CALL STLSSF
C
C SET UP PARAMETERS AS VARIABLES:
      CALL PARSSF(LDUMMY)
      CALL VARMAK(DFLTSF,PARRUN,VARSSF,LDUMMY)
C
C
      DONE=.FALSE.
      DO 1 ICYC=NCYC1,LASTCY
C IS PRINTING OF STRUCTURE FACTOR LIST REQUESTED THIS CYCLE?
      PRINT=PRNCYC(1)
      IF (.NOT. PRINT) GO TO 4
C
C PRINTING IN MAIN PROGRAM FOR EASE OF ADJUSTMENT BY USER:
      WRITE (LPT,2002)
2002  FORMAT ('     h    k    l     G(obs)   G(calc)     Diff     A ',
     & '      B        mod Fc    Scale    Weight')
C
C INITIALISE R FACTOR SUMS:
   4  CALL RFACS(1)
C SET UP POINTERS IN TRIANGULAR MATRIX AND CLEAR OUT LSQ MATRIX AND RHS:
      CALL MATSET(ALSQ,MATSZ)
C
C COUNT USED OBSERVATIONS (THERE IS NOT AT PRESENT ANT WAY OF NOT USING ONE)
      NOBS=0
      FIRST=.TRUE.
C
C BRANCH ON REFLECTION DATA FORMAT:
   2  READ (LUNI,1001,END=3) K,OBS,DOBS,ANUC,BNUC
1001  FORMAT (3I5,4F10.4)
      IF (FIRST) S=1./DOBS
      FIRST=.FALSE.
      DOBS=S*DOBS
      ISCALE=1
      MODER=3
C
C CALCULATE FUNCTION TO MATCH OBSERVED, AND ITS DERIVATIVES:
      CALL INDFLO(H,K)
      CALL CALCGM(H)
C CALCGM FORMS GCALC,  PUTS DG/DV INTO DERIVV FOR ALL VARIABLES, AND SETS UP
C ALL REQUIRED QUANTITIES IN OBSCAL FOR SUBSEQUENT CALLS OF MATREF AND RFACS
C
C MAKE DERIVATIVES WRT BASIC VARIABLES FROM THOSE WRT VARIABLES:
      CALL RELATE
C
C DIFFERENCES AND WEIGHTS:
      DIFF = OBS - GCALC
      CALL WGHTSF
C GETS WEIGHT AND SQRTWT INTO COMMON
C
C STRUCTURE FACTOR LISTING IF REQUIRED:
      IF (.NOT. PRINT) GO TO 9
   5  WRITE (LPT,2004) K,OBS,GCALC,DIFF,FC,FCMOD,SCALE(ISCALE),WT
2004  FORMAT (' ',3I5,2F10.3,F10.5,5F10.4)
C
C ADD IN TO R FACTORS:
   9  CALL RFACS(2)
C
C ADD DERIVATIVES IN TO LSQ MATRIX:
      CALL MATTOT(ALSQ,MATSZ)
      NOBS=NOBS+1
C
C NEXT OBSERVATION:
      GO TO 2
C
C HERE ON NO MORE OBSERVATIONS - REWIND OBSERVATIONS FILE AND PRINT R FACTORS:
   3  REWIND LUNI
      CALL RFACS(3)
C
C INVERT MATRIX, CALCULATE SHIFTS AND ESD'S; APPLY AND PRINT:
      CALL MATINV(ALSQ,MATSZ)
      CALL MATSHF(ALSQ,MATSZ)
      CALL APSHSF(DUMMY)
C PRODUCE NEW INPUT DATA FILE ON PENULTIMATE CYCLE:
      IF (ICYC .EQ. LASTCY-1 .OR. NCYC.EQ.1) CALL NWINSF(DUMMY)
   1  CONTINUE
C
C PRINT CORRELATION MATRIX; PRODUCE NEW CRYSTAL DATA FILE:
      CALL MATCOR(ALSQ,MATSZ)
 100  STOP
      END
C
C
C
C
      SUBROUTINE CALCGM(H)
C
C *** CALCGM FROM CALCSF by PJB ***
C
C THIS SUBROUTINE IS CALLED BY MAIN PROGRAMS FOR THE GMLSQ CALCULATION.
C IT TAKES AS ARGUMENT H,K,L IN H(3) - (AS DOES FCALC(H))
C AND DATA SET UP IN VARIOUS COMMON BLOCKS, AND IT FORMS GCALC,
C THE CALCULATED  FUNCTION CORRESPONDING TO AN OBS JUST READ.
C
C ON THE WAY IT PRODUCES IN VECTOR DERIVV A LIST OF DERIVATIVES
C OF GCALC WRT ALL VARIABLES
C
C THE FUNCTION GCALC IS MADE UP OF TWO FUNCTIONS MULTIPLIED TOGETHER.
C WE WRITE G=P1*P2 WHERE P2 IS A FUNCTION OF FCALC, AND P1 IS NOT.
C THEY ARE WRITTEN IN THIS WAY FOR EASE OF DIFFERENTIATION.
C
C THE SEQUENCE OF OPERATIONS IS:
C      GET S SQRD AND CLEAR THINGS TO ZERO
C      FORM P1 AND ITS DERIVATIVES
C      FORM P2: GET FCALC AND DERIVATIVES OF MOD FCALC WRT FAMILY 2 VARIABLES
C      CONVERT DERIVATIVES TO BE OF P2, NOT JUST MOD FCALC
C      FORM GCALC AND MAKE ALL DERIVATIVES SO THAT THEY ARE OF GCALC
C      ADJUST FOR GCALC SQUARED IF NECESSARY
C
      DIMENSION H(3)
/BRAGG/
/DERVAR/
/FCAL/
      COMMON /GMOBS/ANUC,BNUC
/IOUNIT/
/OBSCAL/
/OVER/
/PHASE/
/POINTS/
/REFINE/
/SCLDAT/
C
      STHL = VCTMOD(0.5,H,2)
C STHL=SIN THETA/LAMBDA;  SSQRD = IT SQUARED
      SSQRD = STHL*STHL
C
C CLEAR DERIVATIVES WRT VARIABLES - THERE MAY NOT BE AN ENTRY FOR EVERY ONE FOR
C THIS INPUT VALUE OF H:
      IF (LVARV .GT. 0) CALL GMZER(DERIVV,1,LVARV)
C
C FORM P1, THE PART OF GCALC INDEPENDENT OF MOD(FC)
      P1=SCALE(ISCALE)*EXP((-TFAC)*SSQRD)/(ANUC*ANUC+BNUC*BNUC)
      IF (KTFAC .GT. 0) DERIVV(KTFAC)=-SSQRD
      L=KSCALE(ISCALE)
      IF (L .GT. 0) DERIVV(L)=1./SCALE(ISCALE)
C NEXT DO P2:
      CALL LFCALC(H)
      P2=FCMOD*(ANUC*COSAL + BNUC*SINAL)
      DP2DFQ=1./FCMOD
C
C CONVERT DERIVATIVES FOR FAMILY 2 FROM BEING 'OF FCMOD' AS THEY ARE OUT OF
C LFCALC, TO BEING 'OF P2' BY USING:
C DP2/DV = DMODFC/DV * DP2/DMODFC - AND ALL ARE DIVIDED BY P2
C
      DO 4 I=1,NVARF(2,1,1)
   4  DERIVV(LVFST1(2,1,1)+I)=FCDERS(I)*DP2DFQ
C
      GCALC = P1*P2
      DO 6 I=1,LVARV
   6  DERIVV(I)=DERIVV(I)*GCALC
 100  RETURN
      END
C
C
C
C
C LEVEL 50      PROGRAM MAGEXT
      PROGRAM MAGEXT
C
C *** MAGEXT by PJB Aug 86 ***
C
C ***************************************************************************
C
C                             M A G E X T
C
C  TO SEPARATE MAGNETIC AND NUCLEAR SCATTERING IN A CRYSTAL WITH EXTINCTION
C
C ***************************************************************************
C
      DIMENSION H(3),K(3),S(5)
      CHARACTER*7855 HEADNG
/IOUNIT/
/EXTN/
/SCRACH/
      DATA HEADNG/'(''    h    k    l     Fnucl     Fmag      DFmag
     & Fobs      DFobs'')'/
C
      CALL PREFIN('MAGEXT')
      CALL SETFC
      CALL EXTINC(1,0.)
      CALL FINDCD('L','SCAL',4,0,LCD)
      CALL RDNUMS(S,7,6,NUM,IER)
C
      NAMFIL='.SF'
      LUN=NOPFIL(101)
      MESSAG='Magnetic Stucture Factors'
      NAMFIL='.MSF'
      LUNM=NOPFIL(102)
C
      WRITE (LPT,15)
      WRITE (LPT,FMT=HEADNG)
   15 FORMAT ('1')
      LINO=2
C
    1 READ (LUN,10,END=2) K,FO,DFO,CEXT,IS
   10 FORMAT (3I5,6F10.4,I5)
      CALL INDFLO(H,K)
      FC=ABS(FCALC(H))
C
      A=0
      B=10.
      ERR=DFO
      MAXIT=50
      KK=0
   20 CALL NB01A(KK,A,B,ERR,X,Y,MAXIT)
      GO TO (21,22,23,24),KK
   24 CALL TESTP(LPT,LINO,2,HEADNG,1)
      WRITE (LPT,11)K
   11 FORMAT (1X,3I5,' Required accuracy not obtained')
      GO TO 1
   23 CALL TESTP(LPT,LINO,2,HEADNG,1)
      WRITE (LPT,12) K
   12 FORMAT (1X,3I5,' No zero in the range')
      GO TO 1
   21 F1=FC+X
      CALL EXTINC(2,F1)
      Y1=EXTCOR
      IF (FC.LT..01) THEN
      Y=Y1*X
      ELSE
      Y1=Y1*Y1
      F2=FC-X
      CALL EXTINC(2,F2)
      Y2=EXTCOR**2
      Y=SQRT(((FC**2+X**2)*(Y1+Y2)+2.*FC*X*(ABS(Y1-Y2)))/2.)
      ENDIF
      Y=(FO/S(IS))-Y
      GO TO 20
   22 DFM=DFO
      WRITE (LUNM,13) K,X,DFM
   13 FORMAT (3I5,2F10.4)
      CALL TESTP(LPT,LINO,2,HEADNG,1)
      WRITE (LPT,14) K,FC,X,DFM,FO,DFO
   14 FORMAT (1X,3I5,5F10.4)
      GO TO 1
C
    2 STOP
      END
C
C
C
C
C LEVEL 50      PROGRAM MAGPLT
      PROGRAM MAGPLT
C
C *** MAGPLT from SPIRAL by PJB Mar 88 ***
C
C
C***************************************************************************
C
C                        M A G P L T
C
C
C***************************************************************************
C
      DIMENSION AM(2,3),POS(3,48),RX(3),RM(2,2),PM(2,2),NM(2),C(3),
     & TMP(3),RL(3),PX(3),P(3),SDD(3),SV(3),SW(3),SF(3),IOP(48),RD(5)
      EQUIVALENCE(TMP(1),XMAX),(TMP(2),YMAX),(TMP(3),SCALE)
C
/CELPAR/
/CONSTA/
/IOUNIT/
/MAGDAT/
/NSYM/
/NTITL/
/PLODAT/
/POSNS/
/SCRACH/
/SYMDA/
/SYMMAG/
/TITLE/
      DATA RD/.1,.2,0.4,.8,0.3/
C
C  TO PLOT MAGNETIC STRUCTURES
C  JUST X-Y PROJECTIONS FOR NOW
C
      CALL PREFIN('MAGPLT')
      CALL SYMOP
      CALL RECIP
      CALL ATOPOS
      CALL DOMAG1(1)
      CALL DOMAG1(2)
C  TRY TO IMPROVE LAYOUT
      BORDER=2.
C
C  INITIAL DIALOGUE
      WRITE (ITO,103)
  103 FORMAT (' Number of cells in x and y directions and scale',
     & ' cms/A :'$)
  22  READ (ITI,101) ICARD
  101 FORMAT (A80)
      CALL RDNUMS(TMP,1,3,N,IER)
      IF (IER.NE.0) GO TO 22
      CALL INPUTN(LPT)
C  MEASURE TITLE
      CALL KANGA2(0.,0.,TLEN,ITITLE,-NTITLE)
C
C  GET PLOTTER
      CALL PIGLET(0.,0.,0)
C
C  SET GRAPH SPACE
      AM(1,1)=CELL(1,1,1)*SCALE
      AM(1,2)=CELL(2,1,1)*CELL(3,2,1)*SCALE
      AM(2,1)=0.
      AM(2,2)=-CELL(2,1,1)*CELL(3,3,1)*SCALE
C  SPACE FOR TITLE
      TLEN=TLEN+2.*CHUNIT
      WIDTH =AM(1,1)*XMAX - AM(1,2)*YMAX
      WDIF=-AM(1,2)*YMAX*0.5
      CHU1=(WIDTH-2.*WDIF)/TLEN
      CH1=CHU1*CHUNIT*ASPECT
C
C  ORIGIN OFFSET
      AM(1,3)=-AM(1,2)*YMAX+2.*BORDER
      AM(2,3)=-AM(2,2)*YMAX+2.*BORDER+5*CH1
C
C  SIZE OF PICTURE
      PW=WIDTH + 4*BORDER
      PH=-AM(2,2)*YMAX+4.*BORDER+5.*CH1
      CALL PIGLET(PW,PH,999)
C
      CALL PLTRIN(AM,4,3)
C  CHARACTER SPACE
      AM(1,1)=CHU1
      AM(2,2)=CHU1*ASPECT
      AM(2,1)=0
      AM(1,2)=0.
      AM(1,3)=2.*BORDER+WDIF
      AM(2,3)=2.*BORDER
      CALL PLTRIN(AM,5,3)
      CALL SPCSET(5)
C      CALL FRAME(0.,0.,TLEN,2.*CHUNIT)
C      CALL KANGA2(CHUNIT,0.5*CHUNIT,TLEN,ITITLE,NTITLE)
C
C  DRAW THE CELLS
      CALL SPCSET(4)
      DO 1 Y=0.,XMAX,2.
      CALL KANGA1(Y,0.,3)
      CALL KANGA1(Y,YMAX,2)
      IF (Y+1. .GT.XMAX) GO TO 1
      CALL KANGA1(Y+1.,YMAX,3)
      CALL KANGA1(Y+1.,0.,2)
    1 CONTINUE
      DO 2 Y=0.,YMAX,2
      CALL KANGA1(0.,Y,3)
      CALL KANGA1(XMAX,Y,2)
      IF (Y+1. .GT.YMAX) GO TO 2
      CALL KANGA1(XMAX,Y+1.,3)
      CALL KANGA1(0,Y+1.,2)
    2 CONTINUE
C
C  GENERATE THE ATOMIC POSITIONS
      DO 5 NA=1,NATOM
      NMAG=MAGAT(NA)
      IF (NMAG.EQ.0) GO TO 5
      CALL GMEQ(X(1,NA),POS(1,1),1,3)
      IOP(1)=1
      M=1
      DO 3 N=1,NOPC
      CALL ROTSYM(X(1,NA),PX,N,1)
      CALL GMADD(PX,TRANS(1,N),RX,3,1)
      DO 6 IC=1,NCENT
      CALL EQPOS(POS(1,1),RX,M,M1,48)
      IF (M1.GT. M) THEN
      M=M1
      IOP(M)=(3-2*IC)*N
      ENDIF
      IF (IC .EQ. NCENT-1) CALL GMREV(RX,RX,3,1)
    6 CONTINUE
    3 CONTINUE
      ZV=POS(3,1)
C  SET THE SPIN DIRECTION FOR THIS ATOM
      SDD(1)=SIN(RADIAN(ANG1(NMAG)))*COS(RADIAN(ANG2(NMAG)))
      SDD(2)=SIN(RADIAN(ANG1(NMAG)))*SIN(RADIAN(ANG2(NMAG)))
      SDD(3)=COS(RADIAN(ANG1(NMAG)))
      SCALA=0.6*SCALE*SMOD(NMAG)/16
      CALL GMSCA(SDD,SDD,SCALA,3,1)
C
C  NOW DRAW THE ARROWS
C
C  WORK OVER UNIT CELLS
      DO 10 CZ=0.,YMAX-1.
      DO 11 CX=0.,XMAX-1.
      DO 14 NL=1,NLAT
      CALL GMEQ(ALAT(1,NL),RL,3,1)
      RL(1)=RL(1)+CX
      RL(3)=RL(3)+CZ
      PH0=SCALPR(PROP,RL)
      DO 13 N=1,M
      PHASE=PH0
      CALL GMADD(POS(1,N),ALAT(1,NL),P,3,1)
      DO 15 I=1,3
      IF (P(I).LT.0.) THEN
        P(I)=P(I)+1.
        PHASE=PHASE+AKSTAR(I,1)
      ELSE
      IF (P(I).GE.1.) THEN
        P(I)=P(I)-1.
        PHASE=PHASE-AKSTAR(I,1)
      ENDIF
      ENDIF
   15 CONTINUE
      PHP=COS(TWOPI*PHASE)
      CALL GMPRD(OTRSYM(1,1,IABS(IOP(N))),SDD,SV,3,3,1)
C  IF INVERSION IS INCLUDED
      IF (IOP(N).LT.0) THEN
      CALL GMPRD(OTRSYM(1,1,NOPC+1),SV,SW,3,3,1)
      CALL GMEQ(SW,SV,3,1)
      ENDIF
      CALL GMSCA(SV,SF,PHP,3,1)
      AM(1,1)=SF(1)
      AM(2,2)=SF(1)
      AM(1,2)=-SF(2)
      AM(2,1)=SF(2)
      A=CX+P(1)
      B=CZ+P(2)
      LEVEL=0
      IF (ABS(P(3)-ZV).GE. .5) LEVEL=2
      CALL SPCSET(4)
      CALL CIRCLE(A,B,SCALE*RD(NA),LEVEL)
      CALL PLCONV(A,B,4,AM(1,3),AM(2,3),3)
      CALL PLTRIN(AM,5,3)
      CALL SPCSET(5)
      CALL ARROW(0.,0,2)
   13 CONTINUE
   14 CONTINUE
   11 CONTINUE
   10 CONTINUE
    5 CONTINUE
C
C  FINISH OFF
      CALL PIGLET(A,B,-999)
      CALL GRAFOF
      STOP
      END
C
C
C
C
C LEVEL 50      PROGRAM MERGE
      PROGRAM MERGE
C
C *** MERGE updated by PJB Mar 87 ***
C
C *************************************************************************
C
C                             M E R G E
C
C  TO MERGE TWO DATA SETS OUTPUT FROM SOMEWHERE AS YET INDETERMINATE
C               BUT WHATEVER PRODUCES .GAM FILES . . .
C                   AND PRODUCE SOME STATISTICS
C
C *************************************************************************
C
      CHARACTER*40 FILNAM,FILNOM
      LOGICAL TESTOV
      COMMON/HEADNG/HEDING
      CHARACTER*280 HEDING
/IOUNIT/
      COMMON/SCRAT/LL(48,2),R(500,2),K(3,2),KK(3),WRK1(5),WRK2(5),
     & WRK3(5),IEND,SCALE(2),LINO,SUM(4),LUN(2)
/SCRACH/
C
      CALL INITIL('MERGE')
C
      CALL GMZER(SUM,1,4)
      IEND=0
      DO 1 IS=1,2
    8 WRITE (ITO,10) IS
   10 FORMAT (' Give file-name and scale for stream',I2,' : '$)
      READ (ITI,11) ICARD
   11 FORMAT (80A1)
      CALL RDWORD(FILNAM,LEN,1,IE,80,0,IER)
      IF (IER.EQ.0) GO TO 5
      WRITE (ITO,16)
   16 FORMAT (' Illegal character in file-name')
      GO TO 8
C
   5  CALL RDREAL(SCALE(IS),IE,I,80,IER)
      IF (IER.NE.0) SCALE(IS)=1.
    7 MESSAG=FILNAM
      NAMFIL='.GAM'
      LUN(IS)=NOPFIL(131)
      IF (LUN(IS) .LE. 0) GO TO 8
      WRITE (LPT,18) IS,SCALE(IS),NAMFIL
  18  FORMAT (' Stream',I2,' data scaled by ',F7.3,' read from ',A60)
    1 CONTINUE
      NAMFIL='.MNG'
      LUNI=NOPFIL(102)
      NAME(1)=FILNOM(LUN(1))
      NAME(2)=FILNOM(LUN(2))
      NAME(3)=FILNOM(LUNI)
      WRITE (LPT,13) (NAME(I),I=1,3)
   13 FORMAT (//22X,'****** MERGE of ',A10,' with ',A10,' ******'/30X,
     & 'output of mean data to ',A10/)
      WRITE (LPT,HEDING)
      LINO=11
C
      MODE=0
      CALL WTMEAN(X,DX,0,WRK1)
    6 IF (INPUT(MODE).EQ.0) GO TO 3
C
C  END OF FILE DETECTED
      IF (IEND.EQ.3) GO TO 4
      MODE=3-IEND
      GO TO 2
C
    3 IF (IEND.NE.0) GO TO 2
      MODE=MATCH(K)
C
    2 CALL STATS(MODE)
      GO TO 6
C
C  HERE TO END
    4 CALL WTMEAN(X,DX,-1,WRK1)
      WRITE (LPT,12) X,DX
      WRITE (ITO,12) X,DX
   12 FORMAT (/' Ratio 2:1 is',F8.4,' +/-',F7.4)
      IF (TESTOV(SUM(1),SUM(2))) GO TO 101
      CHI1=SUM(1)/SUM(2)
      WRITE (LPT,14) CHI1
      WRITE (ITO,14) CHI1
   14 FORMAT (/' The chisquared for repeated measurements is',F6.2)
C
 101  IF (TESTOV(SUM(3),SUM(4))) GO TO 100
      CHI2=SUM(3)/SUM(4)
      WR[BITE (LPT,15) CHI2
      WRITE (ITO,15) CHI2
   15 FORMAT (/' The chisquared for supposedly equivalent',
     & ' measurements is',F8.2)
 100  STOP
C
      END
C
C
C
C
      BLOCK DATA BLKHED
      COMMON/HEADNG/HEDING
      CHARACTER*280 HEDING
      DATA HEDING/'(43X,''Mean of Repeated'',6X,''Labelling   Mean of
     &Equivalent'',8X,''Ratio''/'' File    Indices'',6X,2('' Measurem
     &ents'',9X),''Indices       Measurements         Str1/Str2''/9X,'
     & 'h   k   l    Value      Esd        Value      Esd        h   k
     &  l'',2(4X,''Value      Esd  '')/)'/
      END
C
C
C
C
      FUNCTION INPUT(M)
C
/IOUNIT/
      COMMON/SCRAT/LL(48,2),R(500,2),K(3,2),KK(3),WRK1(5),WRK2(5),
     & WRK3(5),IEND,SCALE(2),LINO,SUM(4),LUN(2)
C
      INPUT=0
      IF (M.EQ.0) THEN
      MS=1
      ME=2
      ELSE
      MS=M
      ME=M
      ENDIF
      DO 1 IS=MS,ME
      NR=1
      L=0
      II=0
    2 II=II+L
      READ (LUN(IS),10,END=4) L,(R(II+I,IS),I=1,L)
   10 FORMAT (I5,3F5.0,(6F10.6))
      LL(NR,IS)=L
      IF (L.EQ.3) GO TO 3
      DO 6 I=4,L
    6 R(II+I,IS)=SCALE(IS)*R(II+I,IS)
      NR=NR+1
      GO TO 2
C
C  END OF A GROUP OF EQUIVALENTS
    3 CALL INDFIX(R(II+1,IS),K(1,IS))
      GO TO 1
C
C  END OF DATA
    4 IEND=IEND+IS
      INPUT=IEND
C
    1 CONTINUE
      RETURN
      END
C
C
C
C
      SUBROUTINE STATS(MODE)
C
C  TO CALCULATE MEANS AND OTHER STATISTICS FOR A SET OF MEASUREMENTS
C  OF A SINGLE QUANTITY
C
      DIMENSION AMEAN(2),DEV(2)
/IOUNIT/
      COMMON/SCRAT/LL(48,2),R(500,2),K(3,2),KK(3),WRK1(5),WRK2(5),
     & WRK3(5),IEND,SCALE(2),LINO,SUM(4),LUN(2)
      COMMON/HEADNG/HEDING
      CHARACTER*280 HEDING
C
      IF (MODE.NE.0) THEN
      MS=MODE
      ME=MS
      ELSE
      MS=1
      ME=2
      ENDIF
C
      DO 4 IS=MS,ME
      CALL WTMEAN(X,DX,0,WRK3)
      IR=1
      II=0
    2 CALL INDFIX(R(II+1,IS),KK)
      L=LL(IR,IS)
      IF (L.EQ.3) GO TO 3
      CALL TESTP(LPT,LINO,1,HEDING,4)
      WRITE (LPT,10) IS,KK
   10 FORMAT (1X,I2,3X,3I4)
      IE=II+L
      IB=II+4
      CALL WTMEAN(R(I,IS),R(I+1,IS),0,WRK2)
      DO 1 I=IB,IE,2
      CALL WTMEAN(R(I,IS),R(I+1,IS),2,WRK2)
      IF (I.EQ.IB) GO TO 6
      CALL TESTP(LPT,LINO,1,HEDING,4)
   14 FORMAT (1X)
      WRITE (LPT,14)
    6 WRITE (LPT,11) R(I,IS),R(I+1,IS)
   11 FORMAT ('+',18X,2F10.5)
    1 CONTINUE
      CALL WTMEAN(X,DX,-1,WRK2)
      CALL WTMEAN(X,DX,2,WRK3)
      SUM(1)=SUM(1)+WRK2(2)-X*WRK2(1)
      SUM(2)=SUM(2)+WRK2(4)-1.
      WRITE (LPT,12) X,DX
   12 FORMAT ('+',40X,2F10.5)
      II=II+L
      IR=IR+1
      GO TO 2
C
C  FINISH ONE INDEPENDENT MEASUREMENT
    3 CALL WTMEAN(AMEAN(IS),DEV(IS),-1,WRK3)
      SUM(3)=SUM(3)+WRK3(2)-AMEAN(IS)*WRK3(1)
      SUM(4)=SUM(4)+WRK3(4)-1.
      WRITE (LPT,13) KK,AMEAN(IS),DEV(IS)
   13 FORMAT ('+',62X,3I4,1X,2F10.5/)
      LINO=LINO+1
    4 CONTINUE
C
      IF (MODE .NE.0) THEN
        WRITE (LUNI,15) (K(I,MODE),I=1,3),AMEAN(MODE),DEV(MODE)
      ELSE
        X=AMEAN(2)/AMEAN(1)
        DX=SQRT((DEV(1)/AMEAN(1))**2+(DEV(2)/AMEAN(2))**2)
        CALL WTMEAN(X,DX,2,WRK1)
        CALL WTMEAN(Y,DY,0,WRK2)
        DO 5 I=1,2
        CALL WTMEAN(AMEAN(I),DEV(I),2,WRK2)
    5   CONTINUE
        CALL WTMEAN(Y,DY,-1,WRK2)
        WRITE (LUNI,15) KK,Y,DY
   15   FORMAT (3I5,2F10.6)
        CALL TESTP(LPT,LINO,2,HEDING,4)
        WRITE (LPT,16) Y,DY,X,DX
   16   FORMAT (/76X,4F10.5)
        LINO=LINO+1
      ENDIF
  100 RETURN
C
      END
C
C
C
C
C LEVEL 6      SUBROUTINE MFCALC(H)
      SUBROUTINE MFCALC(H)
C
C *** MFCALC by PJB Jun 86 ***
C
CC 17B
CH For a magnetic structure, calculates the structure factor and various
CH related quantities.
C SETS INTO COMMON FCAL THE COMPLEX STRUCTURE FACTOR, FC, ITS MODULUS,
C FCMOD, THE SINE AND COSINE OF ITS PHASE, COSAL AND SINAL, AND THE DERIVATIVES
C OF MOD F WRT ALL THE FAMILY 2 VARIABLES OF THE REFINEMENT.
C
C  THIS VERSION FOR NON-CONVENTIONAL FAMILY 2 PARAMS
C
      DIMENSION FORM(3)
      COMPLEX DERIVT,SUM1,TERM,HR
      LOGICAL TESTOV
      DIMENSION DERIVT(50),II(3),RH(3),H(3)
/BRAGG/
/CONSTA/
/FCAL/
/NSYM/
/POINTS/
/POSNS/
/PRBLEM/
/SYMDA/
      COMMON/VALUES/VAL(3,10),NVAL
C
C  FC COLLECTS THE CONVENTIONAL STRUCTURE FACTOR, COMPLEX:
      FC=CMPLX(0.0,0.0)
      IFF=0
C  CALCULATE CUBIC ASYMMETRY FACTOR
      AHKL=0.
      SHKL=0.
      J=2
      L=3
      DO 51 I=1,3
      AHKL=AHKL+(H(I)**4)-3*(H(J)*H(L))**2
      SHKL=SHKL+H(I)**2
      J=L
   51 L=I
      AHKL=AHKL/(SHKL**2)
C
C CYCLE OVER INDEPENDENT ATOMS:
      DO 1 IR=1,NATOM
      SUM1=CMPLX(0.,0.)
C
C  CALCULATE THE FORM FACTORS
      DO 50 I=1,3
      AK=FOURPI*STHL
      L=2*(I-1)
      FORM(I)=FORMFC(AK,L,0,IR)
   50 CONTINUE
C
C INNER LOOP OVER SYMMETRY EQUIVALENTS:
   2  DO 3 IS=1,NOPC
      CALL ROTSYM(H,RH,IS,-1)
      F1=TWOPI*(SCALPR(X(1,IR),RH)+SCALPR(TRANS(1,IS),H))
      ERS=ANITF(RH,IR)
C ANISOTROPIC T F (=1. IF NOT THERE) NEEDED SEPARATELY FOR LSQ:
      ARS=COS(F1)*ERS
      BRS=SIN(F1)*ERS
      TERM=CMPLX(ARS,BRS)
      SUM1=SUM1+TERM
    3 CONTINUE
C
C IF CENTROSYMMETRIC, COMPENSATE FOR USING ONLY HALF NUMBER OF OPERATORS:
      IF (CENTRC) SUM1=SUM1+CONJG(SUM1)
C
      FAC=AMULT(IR)*EXP(-TF(IR)*SSQRD)
      FAC1=FORM(1) +VAL(2,IR)*FORM(2)+AHKL*VAL(3,IR)*FORM(3)
      HRS=FAC*SITE(IR)*SUM1
      HR=HRS*FAC1*VAL(1,IR)
C HR IS PRODUCT OF ATOM DEPENDENT BUT SYMMETRY INDEPENDENT FACTORS
      FC=FC + HR
C
C  NOW MAKE THE DERIVATIVES
      L=KX(1,IR)
      IF (L .NE. 0) DERIVT(L-LO)=HRS*FAC1
      L=KX(2,IR)
      IF (L .NE. 0) DERIVT(L-LO)=HRS*VAL(1,IR)*FORM(2)
      L=KX(3,IR)
      IF (L .NE. 0) DERIVT(L-LO)=HRS*VAL(1,IR)*FORM(3)*AHKL
   1  CONTINUE
C END OF CYCLE OVER ATOMIC POSITIONS
C
C  TIDY FCALC AND COLLECT TRUE D(MODFC)/D(VARIABLE)
C
      A = REAL(FC)
      B = AIMAG(FC)
      FCMOD = SQRT(A*A+B*B)
      IF (.NOT.TESTOV(A,FCMOD)) THEN
        COSAL=A/FCMOD
        SINAL=B/FCMOD
      ENDIF
C
      DO 6 I=1,NVARF(2,1,1)
C NO SUMMING - THESE ARE THE ACTUAL DERIVATIVES (NOT DIVIDED BY ANYTHING, AS
C THEY ARE SUBJECT TO THE CHAIN RULE NEXT, NOT LOGARITHMIC DIFFERENTIATION:
      FCDERS(I)=REAL(DERIVT(I))*COSAL + AIMAG(DERIVT(I))*SINAL
   6  CONTINUE
 100  RETURN
      END
C
C
C
C
C LEVEL 50      PROGRAM OPTDER
      PROGRAM OPTDER
C
C *** OPTDER by PJB JULY 86
C
C ******************************************************************************
C
C                       O P T D E R
C
C MAIN PROGRAM OPTDER BASED ON STRUCTURE FACTOR REFINEMENT TO SELECT
C REFLECTIONS FOR MEASUREMENT ON THE BASIS OF THEIR DERIVATIVES WITH
C RESPECT TO THE PARAMETERS OF INTEREST
C
C ******************************************************************************
C
      CHARACTER *4 ISFWRD(20)
      LOGICAL PRINT,PRNCYC
      LOGICAL DFLTSF,LDUMMY
      EXTERNAL DFLTSF,LDUMMY,PARRUN,VARSSF
      DIMENSION ISFWRD(59),ISWDSP(3,20)
      DIMENSION K(3),H(3)
/DERBAS/
/DERVAR/
/FCAL/
/IOUNIT/
/NSYM/
/OBSCAL/
/POSNS/
/PRBLEM/
/REFINE/
/SCLDAT/
/SCRACH/
       DATA ISFWRD/' ','SCAL','TFAC','X','Y','Z',
     & 'B11','B22','B33','B23','B13',
     & 'B12','SCAT','SITE','ITF',
     & 'XYZ','BIJ','XYZT','FAM1',
     & 'FAM2'/
** NB UPDATE LIKE SFLSQ TO USE XYZB,XYZS FACILITIES
      DATA ISWDSP/1,1,0, 1,2,0, 1,1,1, 2,0,1, 2,0,2, 2,0,3,
     & 2,0,4, 2,0,5, 2,0,6, 2,0,7, 2,0,8,
     & 2,0,9, 2,0,10, 2,0,11, 2,0,12,
     & -1,0,0, -2,0,0, -3,0,0, 1,0,0,
     & 2,0,0/
C
C SET UP STRUCTURE FACTOR CALCULATION:
      CALL PREFIN('OPTDER')
      MESSAG='Reflection data'
      LUNI=NOPFIL(11)
      CALL SETFC
C
C SPECIFY PROBLEM:
      NFAM=2
      NGENS(1)=2
      NGENS(2)=NATOM
      NSPC(1)=20
      NSPC(2)=12
C
C SPECIES TYPES FOR EACH GENUS OF FAMILY 1:
      LF1SP(1)=1
      LF1SP(2)=-20
C
C SET UP INTO STANDARD SPACE:
      CALL LSETUP(20,ISWDSP,ISFWRD)
C
C NAMES SET UP SO THAT:
C FAMILY 1 GENUS 1 HAS SPECIES TFAC (BY ITSELF FOR NOW)
C   '    1    '  2 HAS GENUS NAME SCAL, SPECIES INDICATED TO BE 1,2,3 ETC
C
C FAMILY 2 IS AS USUAL THE PARAMETERS WHICH DEPEND ON THE ATOM.  GENUS NAMES
C ARE THEREFORE THE SAME AS ATOM NAMES, AND SPECIES NAMES ARE:
C X Y Z B11 B22 B33 B23 B13 B12 SCAT SITE ITF
C
C
C READ I AND (MOST) L CARDS:
      CALL STLSSF
C
C SET UP PARAMETERS AS VARIABLES:
      CALL PARSSF(LDUMMY)
      CALL VARMAK(DFLTSF,PARRUN,VARSSF,LDUMMY)
      LUNO=NOPFIL(2)
C
C
2002  FORMAT ('     h    k    l     G(obs)   G(calc)     Diff     A ',
     & '      B        mod Fc    Scale    Weight')
C
      ISCALE=1
    2 READ(LUNI,1000,END=3) K
1000  FORMAT (4X,3I4)
C
C CALCULATE FUNCTION TO MATCH OBSERVED, AND ITS DERIVATIVES:
      CALL INDFLO(H,K)
      CALL CALCSF(H)
C CALCSF FORMS GCALC,  PUTS DG/DV INTO DERIVV FOR ALL VARIABLES, AND SETS UP
C ALL REQUIRED QUANTITIES IN OBSCAL FOR SUBSEQUENT CALLS OF MATREF AND RFACS
C
C MAKE DERIVATIVES WRT BASIC VARIABLES FROM THOSE WRT VARIABLES:
      CALL RELATE
C
C STRUCTURE FACTOR LISTING IF REQUIRED:
      A=REAL(FC)
      IF (ABS(FC).LT.1) GO TO 2
      DIF1=ABS(DERIVB(2)-DERIVB(3))
      DIF2=ABS(DERIVB(3)-DERIVB(1))
      DIF3=ABS(DERIVB(1)-DERIVB(2))
      IF (AMAX1(DIF1,DIF2,DIF3) .LT.1) GO TO 2
      WRITE (LPT,2003) K,A,(DERIVB(I),I=1,LVARB)
      WRITE (LUNO,2004) K
 2004 FORMAT (3I5)
2003  FORMAT (' ',3I5,1F10.3,6F10.5)
C
C NEXT OBSERVATION:
      GO TO 2
C
C HERE ON NOMORE OBSERVATIONS:
    3 STOP
      END
C
C
C
C
C LEVEL 50      PROGRAM PKGEN
      PROGRAM PKGEN
C
C *** PKGEN by PJB Sep 87 **
C
C ***********************************************************************
C
C                          P K G E N
C
C GENERATE TEST DATA FOR PEAK FITTING, AND OPTIONALLY PLOT IT
C
C **********************************************************************
C
C
      DIMENSION DC(50,2),C(50,2)
      DIMENSION PL(3,100),SIZE(2)
      CHARACTER*4 LWORDS(2),WORD
/CARDRC/
/IOUNIT/
      COMMON /PKVALS/NPEAKS,PKPARS(4,10),KPKPRS(4,10),DPKPRS(4,10),
     & BKG(2,2),KBKG(2,2),DBKG(2,2)
/SCRACH/
      DATA LWORDS/'BACK','PEAK'/
C
      CALL PREFIN('PKGEN')
C
C READ L CARDS:   L BACK HAS 4 STARTING VALUES FOR BACKGROUND
C                 L PEAK HAS ESTIMATED HEIGHTS,WIDTH AND CENTRE
C                 ONE L PEAK CARD FOR EACH PEAK
C                 POSSIBLY SOME L FUDG CARDS
      ILCD=ICDNO(12)
      ID=IABS(INREAD(12))
      IF (ILCD .GT. 0) GO TO 5
      WRITE (LPT,3000)
3000  FORMAT (/' ERROR ** NO L CARDS')
      STOP
C
    5 NPEAKS=0
      DO 6 NC=1,ILCD
      CALL CARDIN(ID)
      ID=ID+NYZ
      CALL RDWORD(WORD,LEN,3,IPT,80,0,IE)
      IF (IE.NE.0) THEN
      WRITE (LPT,3001)
 3001 FORMAT (' ERROR ** reading L card')
      IERR=IERR+1
      ELSE
      GO TO (7,8,9) 1+ NCFIND(WORD,LWORDS,2)
C L BACK
    8 CALL GMZER(BKG,2,2)
      CALL RDNUMS(BKG,7,4,NV,IER)
      IF (IER .LT. 0) THEN
      WRITE (LPT,3001)
      IERR=IERR+1
      ENDIF
      GO TO 7
C L PEAK
   9  NPEAKS=NPEAKS+1
      CALL RDNUMS(PKPARS(1,NPEAKS),7,4,NV,IER)
    7 CONTINUE
      ENDIF
   6  CONTINUE
C
   4  IF (NPEAKS.EQ.0) THEN
      WRITE (LPT,3002)
 3002 FORMAT (' ERROR ** No peak information')
      IERR=IERR+1
      ENDIF
      WRITE (LPT,2010) NPEAKS,BKG,(I,(PKPARS(J,I),J=1,4),I=1,NPEAKS)
2010  FORMAT (/1X,I4,' Peaks in scan/ Background Level (up/down):',
     & 2F10.2,'  Background Slope (up/down):'2F10.4/
     & (' Peak No',I2,'  Height(up/down):',2F10.2,' Width:',
     & F10.5,'  Centre:',F10.4))
C
C  GENERATE OUTPUT
      LUNO=NOPFIL(2)
C
C  DETERMINE SCAN WIDTH
      CMAX=-1000.
      CMIN=1000.
      DO 25 NP=1,NPEAKS
      IF (PKPARS(4,NP).LT.CMIN) THEN
        CMIN=PKPARS(4,NP)
        MIN=NP
      ENDIF
      IF (PKPARS(4,NP).GT.CMAX) THEN
        CMAX=PKPARS(4,NP)
        MAX=NP
      ENDIF
   25 CONTINUE
      XMIN=CMIN-3.*PKPARS(3,MIN)
      XMAX=CMAX+3*PKPARS(3,MAX)
      STEP=(XMAX-XMIN)/40.
      CMAX=-1000.
      CMIN=0.
C
      I=0
      DO 20 X=XMIN,XMAX,STEP
      I=I+1
      IF (I .GE. 50) THEN
      WRITE (6,9999) XMIN,XMAX,CMIN,CMAX,STEP
9999  FORMAT (1X,5F10.4)
      STOP
      ENDIF
C FIRST DO BACKGROUND
      DO 21 J=1,2
   21 C(I,J)=BKG(J,1)+X*BKG(J,2)
C  THEN SUM OVER PEAKS
      DO 23 NP=1,NPEAKS
      ARG=((PKPARS(4,NP)-X)/PKPARS(3,NP))**2
      DO 23 J=1,2
  23  C(I,J)=C(I,J)+PKPARS(J,NP)*EXP(-ARG)
      DC(I,1)=SQRT(C(I,1))
      DC(I,2)=SQRT(C(I,2))
      WRITE (LUNO,10) X,(C(I,J),DC(I,J),J=1,2)
   10 FORMAT (5F10.4)
      VAR(I)=X
   22 CONTINUE
      CMAX=AMAX1(CMAX,C(I,1),C(I,2))
   20 CONTINUE
C
      DO 30 J=1,I
      PL(1,J)=VAR(J)
      PL(1,J+I)=VAR(J)
      PL(2,J)=C(J,2)
      PL(2,J+I)=C(J,1)
      PL(3,J)=DC(J,2)
      PL(3,J+I)=DC(J,1)
  30  CONTINUE
      SIZE(1)=25.
      SIZE(2)=25.
      CALL PLOTIT(P,2*I,SIZE)
      STOP
      END
C
C
C
C
C LEVEL 50      PROGRAM PKLSQ
      PROGRAM PKLSQ
C
C *** PKLSQ by PJB ***
C
C ******************************************************************************
C
C                         P K L S Q
C
C MAIN PROGRAM PKLSQ FOR AN EXAMPLE OF SIMPLE LEAST SQUARES REFINEMENT
C FOR FITTING GAUSSIAN PEAKS TO IN20 DATA
C
C ******************************************************************************
C
C THIS MAIN PROGRAM SETS UP THE PROBLEM.  THAT IS, IT FEEDS INTO
C THE COMMON /PRBLEM INFORMATION ABOUT:
C
C     HOW MANY FAMILIES OF PARAMETERS, AND THEIR NAMES
C     FOR EACH FAMILY, HOW MANY GENERA, AND THE NAMES OF EACH GENUS
C     FOR EACH GENUS, HOW MANY SPECIES, AND THEIR NAMES
C
      CHARACTER *4 IPKWRD(8),SCNVAR*8
      CHARACTER *10 FIL(2)
      LOGICAL PRINT,PRNCYC,ENDIP
      LOGICAL DFLTPK,LDUMMY
      EXTERNAL DFLTPK,PARRUN,VARSPK,LDUMMY
      DIMENSION ALSQ(1000),IPKDSP(3,8),QH(50,2),COUNT(50,2),DCO(50,2),
     & NQH(2),VALS(4)
/CARDRC/
/IOUNIT/
/NEWOLD/
/OBSCAL/
/PRBLEM/
/REFINE/
/SCRACH/
      CHARACTER*32 DATLIN
      EQUIVALENCE (DATLIN,MESSAG)
      DATA IPKWRD/'BKGL','BKGS','UP','DOWN','HGTU',
     & 'HGTD','WID','CEN'/
      DATA IPKDSP/
     & 1,1,0, 1,2,0, 1,0,1, 1,0,2, 3,1,0,
     & 3,2,0, 3,3,0, 3,4,0/
C
      MATSZ=1000
C
C SET UP PROBLEM:
      NFAM=3
      NGENS(1)=2
      NSPC(1)=2
      NGENS(2)=0
      NGENS(3)=4
      NSPC(3)=8
C
C SPECIES TYPES OF GENERA IN F1 (0=NONE, -VE=INTEGERS)
      LF1SP(1)=2
      LF1SP(2)=2
C
      CALL PREFIN('PKLSQ')
C WORDS RELEVANT TO THIS PROBLEM FROM DATA INTO COMMON:
      CALL LSETUP(8,IPKDSP,IPKWRD)
C
      CALL NEWCD
   55 READ (ICRYDA,2000,END=63) ICARD
 2000 FORMAT (80A1)
      IPT=1
      DO 50 I=1,2
      CALL RDWORD(FIL(I),LEN,IPT,IPT1,80,0,IER)
      IF (IER.NE.0) STOP 'Bad File-Name in input'
C
C  READ FROM FLX FILES
      IPT=IPT1
   50 CONTINUE
      DO 51 I=1,2
      MESSAG=FIL(I)
      NAMFIL='.FLX'
      LUNI=NOPFIL(121)
      IF (LUNI.EQ.0) STOP
   54 READ (LUNI,2004)SCNVAR
 2004 FORMAT (A8)
      IF (SCNVAR.NE.'!') GO TO 54
      READ (LUNI,2004) SCNVAR
      J=0
      MESSAG=' '
      NAMFIL=' '
   53 READ (LUNI,2001,END=52) DATLIN
 2001 FORMAT (A32)
      CALL RDNUMS(VALS,1,4,NUM,IE)
      IF (IE.GT.0.OR. NUM.EQ.0) GO TO 52
      J=J+1
      SCAL=10000./VALS(4)
      COUNT(J,I)=VALS(2)*SCAL
      DCO(J,I)=VALS(3)*SCAL
      QH(J,I)=VALS(1)
      GO TO 53
   52 NQH(I)=J-1
   51 CONTINUE
      GO TO 62
C
C  READ FROM DUMMY FILES
   63 LUNI=NOPFIL(1)
      I=1
   60 READ (LUNI,600,END=61) QH(I,1),(COUNT(I,J),DCO(I,J),J=1,2)
  600 FORMAT (5F10.4)
      QH(I,2)=QH(I,1)
      I=I+1
      GO TO 60
   61 NQH(1)=I-1
      NQH(2)=NQH(1)
C
C READ POSSIBLE I CARD, ALL L CARDS
   62 CALL STLSPK
C
C SET UP VARIABLES AND BASIC VARIABLES
      CALL PARSPK
      CALL VARMAK(DFLTPK,PARRUN,VARSPK,LDUMMY)
C
C
C CYCLE:
      DONE=.FALSE.
      DO 1 ICYC=NCYC1,LASTCY
C IS PRINTING OF OBS AND CALC LIST REQUESTED THIS CYCLE?
      PRINT=PRNCYC(1)
      IF (PRINT) WRITE (LPT,2005)SCNVAR
 2005 FORMAT(//' Observed and calculated values :'/A8,
     & '       Obs I       Calc I    Diff      Weight')
C
C INITIALISE R FACTOR SUMS:
      CALL RFACS(1)
C
C SET UP TRIANGULAR MATRIX POINTERS, CLEAR OUT LSQ MATRIX AND RHS:
      CALL MATSET(ALSQ,MATSZ)
C
C COUNT USED OBSERVATIONS (THERE IS NOT AT PRESENT ANY WAY OF NOT USING ONE)
      NOBS=0
      DO 3 ICODE=1,2
      DO 3 NOB=1,NQH(ICODE)
      STHETA=QH(NOB,ICODE)
      OBS=COUNT(NOB,ICODE)
      DOBS=DCO(NOB,ICODE)
      CALL CALCPK(STHETA)
C CALCPK FORMS GCALC,  PUTS DG/DV INTO DERIVV FOR ALL VARIABLES, AND SETS UP
C ALL REQUIRED QUANTITIES IN OBSCAL FOR SUBSEQUENT CALLS OF MATTOT AND RFACS
C
C MAKE BASIC VARIABLE DERIVATIVES FROM VARIABLE DERIVATIVES:
      CALL RELATE
      DIFF = OBS - GCALC
C
C SET STATISTICAL WEIGHTS
      WT=1./(DOBS*DOBS)
      SQRTWT=ABS(1./DOBS)
      WDIFF=DIFF*WT
C
      IF (PRINT) WRITE (LPT,2003) STHETA,OBS,GCALC,DIFF,WT
2003  FORMAT (' ',F12.4,2F10.3,F10.5,F10.4)
C
C ADD IN TO R FACTORS:
      CALL RFACS(2)
C
C ADD DERIVATIVES IN TO LSQ MATRIX:
      CALL MATTOT(ALSQ,MATSZ)
      NOBS=NOBS+1
C NEXT OBSERVATION:
C
C HERE ON NO MORE OBSERVATIONS - REWIND OBSERVATIONS FILE AND PRINT R FACTORS:
   3  CONTINUE
      CALL RFACS(3)
C
C INVERT MATRIX, CALCULATE SHIFTS AND ESD'S; APPLY AND PRINT:
      CALL MATINV(ALSQ,MATSZ)
      CALL MATSHF(ALSQ,MATSZ)
      CALL APSHPK
      IF (ICYC .EQ. LASTCY-1 .OR. NCYC.EQ.1) CALL NWINPK
   1  CONTINUE
C
C PRINT CORRELATION MATRIX:
      CALL MATCOR(ALSQ,MATSZ)
      IF (ENDIP) GO TO 100
      WRITE (NEWIN,2002) FIL
 2002 FORMAT ('*'/2A10)
      CALL NEXPRE(ENDIP)
 100  STOP
      END
C
C
C
C
      SUBROUTINE APSHPK
C
C *** APSHPK by PJB MARCH 1987 ***
C
C APPLY SHIFTS AFTER PEAK FITTING
C
      CHARACTER *4 LNAM1,LNAM2,NAME,IPNAME(12)
      DIMENSION PNEW(12),PEs12)
      DIMENSION PSHIFT(12),POLD(12)
/DERBAS/
/DERVAR/
/IOUNIT/
/MATDAT/
/NEWOLD/
      COMMON /PKVALS/NPEAKS,PKPARS(4,10),KPKPRS(4,10),DPKPRS(4,10),
     &  BKG(2,2),KBKG(2,2),DBKG(2,2)
/POINTS/
/REFINE/
C
      WRITE (LPT,2000) ICYC
2000  FORMAT (/////'1Shifts in variables for cycle',I3/
     & '   Variable       New           Esd          Shift        ',
     & '  Old    ')
      DO 1 I=1,LVARV
      J=LVRBS(I)
      KPACK=LVRPR(I)
C IF VARIABLE IS BASIC:
      IF (J .GT. 0) THEN
        SHIFT=BLSQ(J)
        ESD=DERIVB(J)
C OTHERWISE IT IS REDUNDANT, BY CONSTRAINT NUMBER -J:
      ELSE
        CALL SHFESD(-J)
      ENDIF
C
      CALL PUNPAK(KPACK,IFAM,IGEN,ISPC)
C
C  BRANCH ON FAMILY
      GO TO (11,12,12),IFAM
C
C BACKGROUND PARS
   11 CALL ADJUST(BKG(ISPC,IGEN))
      DBKG(ISPC,IGEN)=ESD
      GO TO 40
C
C  PEAK PARS
   12 CALL ADJUST(PKPARS(IGEN,ISPC))
      DPKPRS(IGEN,ISPC)=ESD
      GO TO 40
C
C COMMON EXIT TO PRINT SHIFTS:
  40  CALL PARNAM(LNAM1,LNAM2,3,KPACK)
C
   6  WRITE (LPT,2006) LNAM1,LNAM2,XNEW,ESD,SHIFT,XOLD
2006  FORMAT (' ',1X,A4,1X,A4,4G14.5)
   1  CONTINUE
      RETURN
      END
C
C
C
C
      SUBROUTINE CALCPK(S)
C
C *** CALCPK by PJB  ***
C
C PRODUCE CALCULATED FUNCTION TO MATCH OBSERVED
CA On entry S is sin theta
C
/DERVAR/
      COMMON /PKVALS/NPEAKS,PKPARS(4,10),KPKPRS(4,10),DPKPRS(4,10),
     &  BKG(2,2),KBKG(2,2),DBKG(2,2)
/POINTS/
/OBSCAL/
C
      IUP=ICODE
C
C  CLEAR DERIVATIVES
      IF (LVARV .GT. 0) CALL GMZER(DERIVV,1,LVARV)
C
C  DO BACKGROUND
      GCALC=BKG(IUP,1)
      L=KBKG(IUP,1)
      IF (L.GT.0) DERIVV(L)=1.0
      GCALC=GCALC+S*BKG(IUP,2)
      L=KBKG(IUP,2)
      IF (L.GT.0) DERIVV(L)=S
C
C  NOW PEAKS
      DO 1 I=1,NPEAKS
      POS=(S-PKPARS(4,I))/PKPARS(3,I)
      POS2=-POS*POS
      TEX=EXP(POS2)
      TERM=PKPARS(IUP,I)*TEX
      GCALC=GCALC+TERM
      L=KPKPRS(IUP,I)
      IF (L.GT.0) DERIVV(L)=TEX
      L=KPKPRS(3,I)
      IF (L.GT.0) DERIVV(L)=-2.*POS2*TERM/PKPARS(3,I)
      L=KPKPRS(4,I)
      IF (L.GT.0) DERIVV(L)=2.*TERM*POS/PKPARS(3,I)
    1 CONTINUE
C
      RETURN
      END
C
C
C
C
      LOGICAL FUNCTION DFLTPK(IFAM,IGEN,ISPC)
C
C CALLED AS A SUBSTITUTE FOR DEFALT OUT OF SUBROUTINE VARMAK.  RETURNS
C VALUE .TRUE. IF PARAMETER IFAM,IGEN,ISPC IS BY DEFAULT VARIED, .FALSE. IF
C FIXED.
C
C  FOR PKFITTING VARY EVERYTHING BY DEFAULT
C
      DFLTPK=.TRUE.
 100  RETURN
      END
C
C
C
C
      SUBROUTINE NWINPK
C
C *** NWINPK updated by JCM 10 May 88 ***
C
C PUTS OUT ON UNIT NEWIN,  A REPLACEMENT
C CRYSTAL DATA FILE AFTER REFINEMENT OF PARAMETERS, WHICH LOOKS LIKE
C FILE GIVEN BY USER
C
      CHARACTER*4 LWORD(4),WORD
/CARDRC/
/NEWOLD/
      COMMON /PKVALS/NPEAKS,PKPARS(4,10),KPKPRS(4,10),DPKPRS(4,10),
     &  BKG(2,2),KBKG(2,2),DBKG(2,2)
/SCRACH/
      DATA LWORD /'BACK','PEAK','DBAK','DEPK'/
C
C SCAN CARDS ON FILE IO10, PRODUCING NEW ONES IF THEY MAY HAVE CHANGED:
      I=0
      M=0
      ID=0
   1  ID=ID+1
      IF (ID .GT. NTOTAL(1)) GOTO 100
      READ (IO10,REC=ID,FMT=1000) ICARD
1000  FORMAT(80A1)
      L=LETTER(ICARD(1))
      IF (L .EQ. 12) GO TO 3
      IF (L.NE.9) GO TO 2
C
C I CARD:
      CALL OTPUTI
      GO TO 1
C
C
C L CARD - THE OUTPUT OF THESE IS PROBLEM DEPENDENT:
   3  CALL RDWORD(WORD,LEN,3,IPT,80,0,IER)
      GO TO (2,4,5,6,7), 1+NCFIND(WORD,LWORD,4)
   4  WRITE (NEWIN,1001) WORD,BKG
 1001 FORMAT ('L ',A4,2F10.3,2F10.3)
      GO TO 1
    6 WRITE (NEWIN,1001) WORD,DBKG
      GO TO 1
    5 I=I+1
      WRITE (NEWIN,1002) WORD,(PKPARS(J,I),J=1,4)
 1002 FORMAT ('L ',A4,2F10.2,2F10.5)
      GO TO 1
    7 M=M+1
      WRITE (NEWIN,1002) WORD,(DPKPRS(J,M),J=1,4)
      GO TO 1
C
C
C OTHERWISE COPY CARD AS INPUT:
   2  LEN=LENG(ICARD,80)
      WRITE (NEWIN,1000) (ICARD(I),I=1,LEN)
      GO TO 1
C
 100  RETURN
      END
C
C
C
C
      SUBROUTINE PARSPK
C
C *** PARSPK by PJB MARCH 87 ***
C
C COLLECT ALL PARAMETER FIX AND VARY INFORMATION FOR PK TYPE LSQ
C
      EXTERNAL LDUMMY
C READ ALL 'L RELA' CARDS:
      CALL RDRELA
C READ ALL 'L FIX' AND 'L VARY' CARDS:
      CALL RDFV(LDUMMY)
C
C
      RETURN
      END
C
C
C
C
      SUBROUTINE STLSPK
C
C *** STLSPK by PJB MARCH 87 ***
C
C  SET UP TO DO CONSTRAINED PEAK FITTING
C
      CHARACTER*4 LWORDS(3),WORD
/CARDRC/
/IOUNIT/
      COMMON /PKVALS/NPEAKS,PKPARS(4,10),KPKPRS(4,10),DPKPRS(4,10),
     &  BKG(2,2),KBKG(2,2),DBKG(2,2)
/PRBLEM/
/REFINE/
/SCRACH/
      DATA LWORDS/'BACK','PEAK'/
C
C WRITE TITLE IN CASE USER HAS INVOKED WRONG SUB-LIBRARY:
      WRITE (LPT,2000)
2000  FORMAT (///' Least Squares Refinement - of peak shapes')
      CALL IICD1
C
C READ L CARDS:   L BACK HAS 4 STARTING VALUES FOR BACKGROUND
C                 L PEAK HAS ESTIMATED HEIGHTS,WIDTH AND CENTRE
C                 ONE L PEAK CARD FOR EACH PEAK
      ILCD=ICDNO(12)
      ID=IABS(INREAD(12))
      IF (ILCD .GT. 0) GO TO 5
      WRITE (LPT,3000)
3000  FORMAT (/' ERROR ** NO L CARDS')
      STOP
C
   5  NPEAKS=0
      NC=0
    6 CALL CARDIN(ID)
      ID=ID+NYZ
      CALL RDWORD(WORD,LEN,3,IPT,80,0,IE)
      IF (IE.NE.0) THEN
      WRITE (LPT,3001)
 3001 FORMAT (' ERROR ** reading L card')
      IERR=IERR+1
      ELSE
      GO TO (7,8,9) 1+ NCFIND(WORD,LWORDS,2)
C L BACK
    8 CALL GMZER(BKG,2,2)
      CALL RDNUMS(BKG,7,4,NV,IER)
      IF (IER .LT. 0) THEN
      WRITE (LPT,3001)
      IERR=IERR+1
      ENDIF
      GO TO 7
C L PEAK
   9  NPEAKS=NPEAKS+1
      CALL RDNUMS(PKPARS(1,NPEAKS),7,4,NV,IER)
      GO TO 7
    7 CONTINUE
      ENDIF
      NC=NC+1
      IF (NC.LT.ILCD) GO TO 6
   4  IF (NPEAKS.EQ.0) THEN
      WRITE (LPT,3002)
 3002 FORMAT (' ERROR ** No peak information')
      IERR=IERR+1
      ENDIF
C PROBABLY DOES NOT WORK HERE:
      CALL FUDGIN
      LF3SP(1)=-NPEAKS
      LF3SP(2)=-NPEAKS
      LF3SP(3)=-NPEAKS
      LF3SP(4)=-NPEAKS
      WRITE (LPT,2010) NPEAKS,BKG,(I,(PKPARS(J,I),J=1,4),I=1,NPEAKS)
2010  FORMAT (/1X,I4,' Peaks in scan/ Background Level (up/down):'
     & ,2F10.2,'  Background Slope (up/down):'2F10.4/
     & (' Peak No',I2,'  Height(up/down):',2F10.2,' Width:',
     & F10.5,'  Centre:',F10.4))
      RETURN
      END
C
C
C
C
C LEVEL 50      PROGRAM POLCAL
      PROGRAM POLCAL
C
C *** POLCAL PJB/JBF OCT 89 ***
C
C ****************************************************************************
C
C                              P O L C A L
C
C       READS A FILE OF REFLECTION INDICES AND CALCULATED Q'S ETC.
C       CALCULATES AND PLOTS ON A STEREOGRAPHIC PROJECTION THE SCATTERED
C       POLARISATION DIRECTIONS FOR GIVEN DOMAIN POPULATIONS
C
C ****************************************************************************
C
      COMPLEX FC,QSTAR(3),Q(3,25),CVEC(3),CPRD,CRSCLP,FCBUF
      DIMENSION H(3),A(15),K(3)
      DIMENSION VEC(3),VEC1(3),POLI(3),POLO(3),POLD(3),HBUF(3)
      LOGICAL END,SAYS,CHANGE
      CHARACTER*4 LABEL
/IOUNIT/
/NTITL/
/POLKA/
/TITLE/
/SCRACH/
C
      CALL INITIL('POLCAL')
      LUNI=NOPFIL(1)
      READ (LUNI,2023) ITITLE
 2023 FORMAT (A80)
      NTITLE=LENGT(ITITLE)
C  ASK FOR DOMAIN FRACTIONS AND SCAN TYPE
      CALL DOMPOP(FRAC,NDD)
      CALL SCNTYP(II,JJ,KK,NPTS)
C
C  HEADING
      WRITE (LPT,2003)
2003  FORMAT ('1',25X,'***** Calculation of Scattered Polarisation',
     & '***** ')
      LIN=3
C
   32 CALL MESS(LPT,1,' ')
      ND=1
C
C   READ ALL Q'S FOR ONE REFLECTION
C    1 READ (LUNI,3000,END=4)ICARD
C 3000 FORMAT (A120)
C      CALL RDNUMS(A,1,11,NUM,IER)
C      IF  (IER.NE.0) GO TO 1
C      CALL GMEQ(A,HBUF,3,1)
C      THETA=A(4)
C      N=NINT(A(5))
C      CALL CGMEQ(A(6),Q(2,ND),2,1)
C      CALL GMEQ(A(10),FCBUF,2,1)
    1 READ (LUNI,3000,END=4) K,THETA,N,(Q(I,ND),I=2,3),FCBUF
      CALL INDFLO(HBUF,K)
 3000 FORMAT (3I5,F10.2,I5,6F10.4)
      Q(1,ND)=0
      IF (N .NE. ND) GO TO 5
C
      CALL GMEQ(HBUF,H,3,1)
      FC=FCBUF
      ND=ND+1
      GO TO 1
C
    4 END=.TRUE.
    5 NDOM=ND-1
      CALL INDFIX(H,K)
      IF (NDOM.EQ.0) NDOM=1
      IF (FC.NE.0) NDOM=2*NDOM
      IF (NDD.NE.NDOM) WRITE (ITO,2020) NDOM
 2020 FORMAT (' Wrong number of domain fractions given, ',I3,
     & ' are needed')
C
C  HERE TO DO SCAN
    8 IF (NTITLE.GT.59) NTITLE=59
      ITITLE(NTITLE+1:80)=' '
      WRITE (ITITLE(NTITLE+1:),3052) K
 3052 FORMAT (1X,3I4,' reflection')
C
C  PREPARE STEREOGRAPHIC PLOT
      POLD(1)=.5
      CALL STERPO(POLD,' ',0,0)
C
C  LOOP OVER INPUT POLARISATION STARTS HERE
      ASTEP=RADIAN(360./FLOAT(NPTS))
      ANG=-RADIAN(180.)
      DO 21 IP=1,NPTS
      POLI(II)=SIN(ANG)
      POLI(JJ)=0.
      POLI(KK)=COS(ANG)
      WRITE (LABEL,2206) IP
 2206 FORMAT ('  ',I2)
      CALL STERPO(POLI,LABEL,4,1)
C  CLEAR SUMS
      CALL GMZER(POLD,1,3)
      QSQRM=0
C  LOOP OVER DOMAINS
      NSTEP=1
      IF (FC.NE.0) NSTEP=2
      NND=0
      DO 22 N180=1,NSTEP
      DO 20 ND=1,NDOM/2
      NND=NND+1
C  CALCULATION OF POLARISATION DIRECTIONS
      CALL CMCONJ(Q(1,ND),QSTAR,3,1)
      CALL CGMSCA(Q(1,ND),CVEC,CONJG(FC),3,1)
      CALL CMREAL(CVEC,POLO,3,1)
      CALL CMIMAG(CVEC,VEC,3,1)
      CALL VECPRD(POLI,VEC,VEC1)
      CALL GMADD(POLO,VEC1,POLO,3,1)
      CPRD=CRSCLP(QSTAR,POLI)
      CALL CGMSCA(Q(1,ND),CVEC,CPRD,3,1)
      CALL CMREAL(CVEC,VEC,3,1)
      CALL GMADD(POLO,VEC,POLO,3,1)
C  DOUBLE ALL THIS FOR TWICE REAL AND IMAG PARTS
      CALL GMSCA(POLO,POLO,2.,3,1)
**** ????? REAL(FC*CONJG(FC)) ??  Judy
C  PART PARALLEL TO INCIDENT POLN
      FNSQR=REAL(FC)*CONJG(FC)
      QMOD=RSCALP(Q(1,ND),Q(1,ND))
      CALL GMSCA(POLI,VEC,FNSQR-QMOD,3,1)
      CALL GMADD(POLO,VEC,POLO,3,1)
C  NORMALISE IT
C  ADD INTO SUMS FOR MEAN POLARISATION
      CALL GMSCA(POLO,POLO,FRAC(NND),3,1)
      CALL GMADD(POLO,POLD,POLD,3,1)
      CALL GMEQ(POLO,VEC,3,1)
      CALL UNIVEC(POLO,QSQR)
      WRITE (LPT,2200) H,ND,NND,FRAC(NND),VEC,QSQR
      QSQRM=QSQRM+QSQR
 2200 FORMAT (1X,3F5.2,2I4,8(F8.2),F8.2)
      DO 23 ICOMP=1,3
      Q(ICOMP,ND)=-Q(ICOMP,ND)
   23 CONTINUE
   20 CONTINUE
   22 CONTINUE
C
C  GET FINAL POLARISATION DIRECTION AND POLARISATION
      CALL GMEQ(POLD,VEC,3,1)
      CALL UNIVEC(POLD,D)
      WRITE (LABEL,2207) IP
 2207 FORMAT (I2,'  ')
      CALL STERPO(POLD,LABEL,2,1)
      FPOL(IP)=D/QSQRM
      WRITE (LPT,2201) POLI,POLD,FPOL(IP),QSQRM
 2201 FORMAT (16X,2(3F8.4,3X),2F8.4)
      ANG=ANG+ASTEP
   21 CONTINUE
C
      CALL STERPO(POLO,' ',0,-1)
      CHANGE=.FALSE.
      CALL ASK('Another scan? (Y/N)')
      IF (SAYS('Y'))THEN
        CHANGE=.TRUE.
        CALL SCNTYP(II,JJ,KK,NPTS)
      ENDIF
      CALL ASK('Change domain fractions? (Y/N)')
      IF (SAYS('Y'))THEN
        CHANGE=.TRUE.
        CALL DOMPOP(FRAC,NDD)
      ENDIF
      IF(CHANGE) GO TO 8
C
C  PREPARE TO COMPLETE READING NEW REFLECTION
      CALL GMEQ(Q(1,ND),Q(1,1),3,1)
      ND=2
      IF (.NOT. END)GO TO 1
    3 STOP
      END
C
C
C
C
      SUBROUTINE SCNTYP(II,JJ,KK,NPTS)
C
C *** SCNTYP BY PJB NOV 89 ***
C
      LOGICAL SAYS
/IOUNIT/
C
   1  CALL ASK('Give scan axis X,Y or Z')
      IF (SAYS('X'))THEN
        II=1
        JJ=2
        KK=3
      ELSE IF (SAYS('Y'))THEN
        II=2
        JJ=1
        KK=3
      ELSE IF (SAYS('Z'))THEN
        II=1
        JJ=3
        KK=2
      ELSE
        GO TO 1
      ENDIF
      CALL ASK('Number of points?')
      CALL RDINTG(NPTS,1,IPT,80,IER)
  100 RETURN
      END
C
C
C
C
      SUBROUTINE DOMPOP(FRAC,NDD)
C
C *** DOMPOP BY PJB NOV 89 ***
C
      DIMENSION FRAC(1)
/IOUNIT/
/SCRACH/
C
      CALL ASK('Give domain fractions')
      CALL RDNUMS(FRAC,1,24,NDD,IER)
      RETURN
      END
C
C
C
C
      SUBROUTINE STERPO(VEC,LABEL,ICH,MODE)
C
C *** STERPO BY PJB (VERSION OF STEREO FOR POLCAL) NOV 89 ***
C
      DIMENSION VEC(3)
      CHARACTER*11 ANUM
      CHARACTER*(*) LABEL
/BRAGG/
/CONSTA/
/DGEOM/
/IOUNIT/
/PLODAT/
/POLKA/
C
      RADI=1.0
      CH=.1
      IF (MODE.LT.0) GO TO 4
      IF (MODE.NE.0) GO TO 20
C
C  SET UP
      CALL GETSCL(-1.,1.,1)
      CALL GETSCL(-1.,1.,2)
      CALL STPOLP(22.,22.,VEC(1))
C DRAW CIRCLE
      STEP=TWOPI/500.
      IP=3
      ANG=0
    1 X=RADI*COS(ANG)
      Y=RADI*SIN(ANG)
      CALL PLOTO(X,Y,CH,-IP)
      ANG=ANG+STEP
      IP=1
      IF (ANG.LT.6.3) GO TO 1
C
      CALL PLOTO(-RADI,0.,ER,-3)
      CALL PLOTO(RADI,0,ER,-1)
      CALL PLOTO(0.,-RADI,ER,-3)
      CALL PLOTO(0.,RADI,ER,-1)
      GO TO 100
C
C  PLOT DOMAIN FRACTIONS
   4  CALL SPCSET(4)
      IF (NDOM.NE.0) THEN
        Y1=(NDOM+2)*CHUNIT
        CALL PLCONV(0.,Y1,7,XX1,YY1,4)
        Y2=-NDOM*CHUNIT
        CALL KANGA2(0,Y1,XF,' Dom  Pop  ',-11)
        CALL PLCONV(XF,Y2,7,XX2,YY2,4)
        CALL FRAME(XX1,YY1,XX2,YY2)
        Y2=NDOM*CHUNIT
        CALL PLCONV(0.,Y2,7,XX1,YY1,4)
        CALL KANGA1(XX1,YY1,3)
        CALL KANGA1(XX2,YY1,2)
        CALL SPCSET(7)
        Y1=Y1-1.5*CHUNIT
        CALL KANGA2(0,Y1,XF,' Dom  Pop  ',11)
        DO 6 I=1,NDOM
        Y1=Y1-2*CHUNIT
        WRITE (ANUM,10)I,FRAC(I)
        CALL KANGA2(0,Y1,XF,ANUM,11)
    6   CONTINUE
      ENDIF
C  PLOT POLARISATIONS
      YSTART=(NPTS+2)*CHUNIT
      Y1=YSTART
      CALL PLCONV(0.,Y1,5,XX1,YY1,4)
      NCOL=1
      NPC=NPTS
      IF (YY1.GT.RADI) THEN
        NPC=NPTS/2+MOD(NPTS,2)
        YSTART=(NPC+2)*CHUNIT
        Y1=YSTART
        CALL PLCONV(0.,Y1,5,XX1,YY1,4)
        NCOL=2
      ENDIF
      CALL KANGA2(0,Y1,XF,' Pnt  Pol  ',-11)
      Y2=-NPC*CHUNIT
      CALL PLCONV(XF,Y2,5,XX2,YY2,4)
      XDIF=XX2-XX1
      Y2=Y1-2*CHUNIT
      CALL PLCONV(0.,Y2,5,XX3,YY3,4)
      NS=1
      XS=0.
      NF=NPC
      DO 9 NC=1,NCOL
      CALL SPCSET(4)
      CALL FRAME(XX1,YY1,XX2,YY2)
      CALL KANGA1(XX1,YY3,3)
      CALL KANGA1(XX2,YY3,2)
      CALL SPCSET(5)
      Y1=Y1-1.5*CHUNIT
      CALL KANGA2(XS,Y1,XF,' Pnt  Pol  ',11)
      DO 8 I=NS,NF
      Y1=Y1-2*CHUNIT
      WRITE (ANUM,10)I,FPOL(I)
      CALL KANGA2(XS,Y1,XF,ANUM,11)
    8 CONTINUE
      XS=XS+XF
      Y1=YSTART
      NS=NPC+1
      NF=NPTS
      XX2=XX2+XDIF
      XX1=XX1+XDIF
    9 CONTINUE
   10 FORMAT (I2,2X,F5.3)
      CALL PIGLET(X,Y,-999)
      CALL GRAFOF
      GO TO 100
C
C  PLOT A POINT
   20 CALL GRAFON
      CH=.3
C POINT UNDERNEATH
      IF (VEC(3).LT.0)CH=.5
      CALL SINCOS(VEC(3),STH,'STEREO')
      THET=ACOS(ABS(VEC(3)))
      RTH=RADI*TAN(THET/2.)
      IF (ABS(STH).LT..0001) THEN
        CSPH=1.
        SNPH=0.
      ELSE
        CSPH=VEC(1)/STH
        SNPH=VEC(2)/STH
      ENDIF
      X=CSPH*RTH
      Y=SNPH*RTH
      CALL SPCSET(4)
      CALL KANGA3(X,Y,CH,ICH)
C  LABEL POINT
      CALL PLCONV(X,Y,4,X1,Y1,6)
      CALL SPCSET(6)
      L=LENGT(LABEL)
      CALL KANGA2(X1,Y1,WID,LABEL,-L)
      X1=X1-WID-0.5*CHUNIT
      Y1=Y1-0.3*CHUNIT
      CALL KANGA2(X1,Y1,WID,LABEL,L)
      GO TO 100
C
  100 RETURN
      END
C
C
C
C
      SUBROUTINE STPOLP(XX,YY,ER)
C
C *** STPOLP BY PJB (VERSION OF SETPLT FOR PLOCAL) NOV 89 ***
C
      DIMENSION YC(2),Y(2),XO(2),IPNT(2),ICH(2),AM(2,3)
/IOUNIT/
/PLODAT/
/PLTRAN/
/PLTS/
/TITLE/
      EQUIVALENCE (Y(1),A),(Y(2),B)
C
C***********************************************************************
C                                                                      *
C      THE VECTOR X(I,J) HELD IN COMMON PLTS DEFINES HOW THE GRAPH     *
C      WILL BE DRAWN. I=1 FOR X-AXIS, I=2 FOR Y-AXIS.                  *
C            J=1  LENGTH OF AXIS IN USER UNITS                         *
C            J=2  LENGTH OF AXIS IN CMS.                               *
C            J=3  DIVISION OF AXIS IN USER UNITS                       *
C            J=4  MINIMUM VALUE IN USER UNITS                          *
C            J=5  POSITION OF AXIS TO BE PLOTTED                       *
C                                                                      *
C***********************************************************************
C***********************************************************************
C
C  GET HOLD OF PLOTTER
      CALL PIGLET(0.,0.,0)
C
C  SET LENGTHS OF AXES IN CMS
      DO 21 I=1,2
      X(1,2)=XX
      X(2,2)=YY
C  SET SCALE OF GRAPH
      S(I)=X(I,2)/X(I,1)
   21 CONTINUE
C
C CHARACTER SIZE
      CH=.6
      IF (ER.NE.0.) CH=ER
      XS=CH
C
C OFFSET SPACE 4 TO ALLOW AN INFORMATION PANEL
      OFFSET=XX/2.
      FULWID=1.5*XX
C
C  GRAPH SPACE (SPACE 4)
      AM(1,1)=S(1)
      AM(2,2)=S(2)
      AM(1,2)=0.
      AM(2,1)=0.
      AM(1,3)=BORDER+OFFSET-X(1,4)*S(1)
      AM(2,3)=BORDER-X(2,4)*S(2)
      CALL PLTRIN(AM,4,3)
C
C  SIZE OF PLOT WITH SPACE FOR TITLE AND INFORMATION PANEL
      PW=FULWID+2.*BORDER
      PH=X(2,2)+12*CH+2.*BORDER
C
C
C  CHARACTER 2 SPACE - FOR LABELLING NUMBERS (SPACE 6)
      A1=CH/CHUNIT
      A2=A1*ASPECT
      AM(1,1)=A1
      AM(2,2)=A2
      AM(1,2)=0.
      AM(2,1)=0.
      CALL PLTRIN(AM,6,3)
      CALL PIGLET(PW,PH,999)
C BLACK PEN:
      CALL PIGLET(0.,0.,-1)
C
C  WRITE TITLE
      LTIT=LENGT(ITITLE)
      CHT=2.*CH
      CALL KANGA2(0,0,WIDTIT,ITITLE,-LTIT)
      WIDTIT=WIDTIT*CHT/CHUNIT
      IF (WIDTIT.GT.FULWID) THEN
        CHT=FULWID*CHT/WIDTIT
        WIDTIT=FULWID
      ENDIF
      HFWID=0.5*WIDTIT
      HT=2.*CHT
      X1=0.5*FULWID+BORDER
      Y1=X(2,2)+BORDER+4*CH
      CALL SPCSET(3)
      CALL FRAME(X1-HFWID,Y1,X1+HFWID,Y1+HT)
C  CHARACTER 1 SPACE FOR TITLE (SPACE 5)
      AM(1,1)=CHT/CHUNIT
      AM(2,2)=AM(1,1)*ASPECT
      AM(1,3)=X1-HFWID
      AM(2,3)=Y1+0.5*CHT
      CALL PLTRIN(AM,5,3)
      CALL SPCSET(5)
      CALL KANGA2(-0.5*WID,0,WIDD,ITITLE,LTIT)
C
C  REDEFINE SPACE 5 FOR INFO
      CHT=XX/45
      AM(1,1)=CHT/(CHUNIT*S(1))
      AM(2,2)=AM(1,1)*ASPECT
      AM(1,3)=-2
      AM(2,3)=0
      CALL PLTRIN(AM,5,4)
      CALL SPCSET(5)
C
C  YET ANOTHER SPACE FOR DOMAINS
      AM(1,1)=CHT/(CHUNIT*S(1))
      AM(2,2)=AM(1,1)*ASPECT
      AM(1,3)=-1.4
      AM(2,3)=0
      CALL PLTRIN(AM,7,4)
C
C  SET GRAPH SPACE
      CALL SPCSET(4)
 100  RETURN
      END
C
C
C
C
C LEVEL 50      PROGRAM PTHEXT
      PROGRAM PTHEXT
C
C *** PTHEXT by PJB Aug 86 ***
C
C *****************************************************************************
C
C                            P T H E X T
C
C
C *****************************************************************************
C
      DIMENSION LUN(2)
      LOGICAL ABSENT
      CHARACTER*56 HEDING
      CHARACTER*10 FILNAM
/DGEOM/
/CARDRC/
/IOUNIT/
/REFS/
/SCRACH/
      EQUIVALENCE (ICARD(1),MESSAGE),(ICARD(41),NAMFIL)
/STATS/
      DATA HEDING/'(5X,''h'',4X,''k'',4X,''l'',10X,''Fobs'',7X,''DFobs
     &''/)'/
      INC = 0
C
      CALL PREFIN('PTHEXT')
      CALL SYMOP
      CALL RECIP
      CALL SETABS
      CALL INPUTI
      CALL ICDFMT(INC,ITEMS)
      SCALE(1)=1.
      SCALE(2)=1.
      LH=2
      NAMFIL='.SF '
      LUNI=NOPFIL(102)
      IG=0
  109 WRITE (ITO,110)
  110 FORMAT (' Give input file name, wavelength and scale (RETURN ',
     & 'if no more ): ')
      READ (ITI,111) ICARD
  111 FORMAT(80A1)
      CALL RDWORD(FILNAM,LEN,1,IE,11,0,IER)
      IF (IER.EQ.0) GO TO 11
      IF (IER.EQ.100) GO TO 100
      WRITE (ITO,112)
  112 FORMAT (' Illegal file name')
      GO TO 109
C
   11 CALL RDREAL(ALAMB,IE,I,80,IER)
      IF (IER.NE.0) GO TO 109
      CALL RDREAL(SCALE,I,IE,80,IER)
      IF (IER.NE.0) SCALE(2)=1.
      MESSAG=FILNAM
      NAMFIL='.ARR'
      LUN(1)=NOPFIL(131)
      IF (LUN(1).LE.0) GO TO 109
      WRITE (LPT,117) ALAMB(1),NAMFIL,SCALE(1)
  117 FORMAT ('0Data measured with lambda =',F7.3,' read from ',A10,
     & ' and multiplied by',F8.3/)
      IG = IG+1
      WRITE (LPT,17)
   17 FORMAT ('1')
      WRITE (LPT,HEDING)
      LINO=3
C
    1 IEND= INPUAR(1,LUN)
      IF (IEND.NE.0) GO TO 109
      CALL PATH(IG)
C
      GO TO 1
C
  100 STOP
      END
C
C
C
C
      SUBROUTINE PATH(IG)
C
C *** PATH by PJB 10 Apr 87 ***
C
      DIMENSION KK(3),H(3),ABSC(3)
      COMPLEX FCALC
/CELPAR/
/DGEOM/
/EXTN/
/IOUNIT/
/REFS/
/STATS/
C
      IS=1
      IR=1
      II=0
      CALL GMEQ(R(II+1,IS),H,3,1)
      CALL INDFIX(H,KK)
      VEC = VCTMOD(0.5,H(1),2)
      ALAM3=WLGTH**3
      SINTH = WLGTH*VEC
      CALL SINCOS(SINTH,COSTH,'PTHEXT')
      SINTH = 2.*SINTH*COSTH
      COSTH = (2.*COSTH*COSTH) - 1.
      CEXT(2) = WLGTH/SINTH
      IF (LOREN) THEN
C EXTINCTION FOR LORENTZIAN DISTRIBUTION
        CEXT(3) = .025 + .285*COSTH
        CEXT(4) = 0.15 - 0.2*(0.75-COSTH)**2
      ELSE IF (GAUSS) THEN
C GAUSSIAN DISTRIBUTION
        CEXT(3) = 0.58+0.48*COSTH+0.24*(COSTH**2)
        CEXT(4) = 0.02-0.025*COSTH
      ENDIF
      L=LL(IR,IS)
      CALL GMEQ(R(II+1,IS),H,3,1)
      CALL INDFIX(H,KK)
      IF (L.EQ.3) GO TO 100
      IE=II+L
      IB=II+4
      CALL WTMEAN(R(I,IS),R(I+1,IS),0,WRK2)
      DO 1 I=IB,IE,2
      CALL WTMEAN(R(I,IS),R(I+1,IS),2,WRK2)
    1 CONTINUE
      CALL ABMULT(R(II+1,IS),ABSC)
      TM = ABSC(3)/ABSC(1)
      CEXT(1) = ALAM3*TM/(SINTH*V(1)**2)
      CEXT(1) = 1000.*CEXT(1)
      II=II+L
      CALL WTMEAN(R(II+1,IS),R(II+2,IS),-1,WRK2)
      R(II+1,IS)=R(II+1,IS)/ABSC(1)
      R(II+2,IS)=R(II+2,IS)/ABSC(1)
      IF(R(II+1,IS).LT.0.) THEN
        FOBS = 0.
        DF = 0.
      ELSE
        FOBS=(SQRT(R(II+1,IS)))/SCALE(1)
        DF=((SQRT(R(II+1,IS)+R(II+2,IS))) -FOBS)/SCALE(1)
      ENDIF
      WRITE (LPT,15) KK,FOBS,DF,(CEXT(I),I=1,4),IG,ABSC(1),TM
      WRITE (LUNI,16) KK,FOBS,DF,(CEXT(I),I=1,4),IG
   15 FORMAT (1X,3I5,6F10.4,I5,2F10.4)
   16 FORMAT (3I5,6F10.4,I5)
C  LEAVE SPACE FOR MEANS
      II=II+2
      IR=IR+1
      GO TO 2
C
 100  RETURN
      END
C
C
C
C
C LEVEL 50      PROGRAM SPIRAL
      PROGRAM SPIRAL
C
C *** SPIRAL by PJB Sep 87 ***
C
C
      DIMENSION AM(2,3),POS(3,48,2),RX(3),RM(2,2),PM(2,2),NM(2),
     & TMP(3),AK(3),AX(2),RL(3),PHSE(48),PX(3),P(3)
      COMPLEX ROT
      EQUIVALENCE(ROT,RM),(TMP(1),XMAX),(TMP(2),YMAX),(TMP(3),SCALE)
C
/CELPAR/
/CONSTA/
/IOUNIT/
/PLODAT/
/POSNS/
/NSYM/
/SCRACH/
/SYMDA/
C
C  TO PLOT SPIRAL STRUCTURES
C
      CALL PREFIN('SPIRAL')
      CALL SYMOP
      CALL RECIP
      CALL ATOPOS
C
C  INITIAL DIALOGUE
  20  CALL ASK('Give propagation vector')
      CALL RDNUMS(AK,1,3,N,IER)
      IF (IER.NE.0) GO TO 20
  21  CALL ASK('Orientation and axial ratio of Spiral')
      CALL RDNUMS(AX,1,2,N,IER)
      IF (IER.NE.0) GO TO 21
  22  CALL ASK('Number of cells in x and z directions and scale'//
     & ' cms/A')
      CALL RDNUMS(TMP,1,3,N,IER)
      IF (IER.NE.0) GO TO 22
C
C  GET PLOTTER
      CALL PIGLET(0.,0.,0)
C
C  SET GRAPH SPACE
      AM(1,1)=CELL(1,1,1)*SCALE
      AM(1,2)=CELL(3,1,1)*CELL(2,2,1)*SCALE
      AM(2,1)=0.
      AM(2,2)=-CELL(3,1,1)*CELL(2,3,1)*SCALE
C  ORIGIN OFFSET
      AM(1,3)=-AM(1,2)*XMAX+BORDER
      AM(2,3)=-AM(2,2)*YMAX+BORDER
C
C  SIZE OF PICTURE
      PW=AM(1,1)*XMAX - AM(1,2)*YMAX + 2*BORDER
      PH=-AM(2,2)*YMAX+2.*BORDER
      CALL PIGLET(PW,PH,999)
C
      CALL PLTRIN(AM,4,3)
C
C  DRAW THE CELLS
      CALL SPCSET(4)
      DO 1 Y=0.,XMAX,2.
      CALL KANGA1(Y,0.,3)
      CALL KANGA1(Y,YMAX,2)
      IF (Y+1. .GT.XMAX) GO TO 1
      CALL KANGA1(Y+1.,YMAX,3)
      CALL KANGA1(Y+1.,0.,2)
    1 CONTINUE
      DO 2 Y=0.,YMAX,2
      CALL KANGA1(0.,Y,3)
      CALL KANGA1(XMAX,Y,2)
      IF (Y+1. .GT.YMAX) GO TO 2
      CALL KANGA1(XMAX,Y+1.,3)
      CALL KANGA1(0,Y+1.,2)
    2 CONTINUE
C
C  GENERATE THE ATOMIC POSITIONS
      DO 5 NA=1,NATOM
      CALL GMEQ(X(1,NA),POS(1,1,NA),1,3)
      M=1
      DO 3 N=1,NOPC
      CALL ROTSYM(X(1,NA),PX,N,1)
      CALL GMADD(PX,TRANS(1,N),RX,3,1)
      DO 6 IC=1,NCENT
      CALL EQVEC(POS(1,1,NA),RX,M,M1,48)
      IF (M1.GT. M) M=M1
      IF (IC .EQ. NCENT-1) CALL GMREV(RX,RX,3,1)
    6 CONTINUE
    3 CONTINUE
    5 NM(NA)=M
C
C  NOW DRAW THE ARROWS
C  FIRST SET ARROW SPACE
      PM(1,1)=SCALE/12.
      PM(2,1)=0.
      PM(1,2)=0.
      PM(2,2)=PM(1,1)
      AM(1,3)=0.
      AM(2,3)=0.
C
C  WORK OVER UNIT CELLS
      ALPHA=RADIAN(AX(1))
      DO 10 CZ=0,YMAX-1
      DO 11 CX=0,XMAX-1
      DO 14 NL=1,NLAT
      CALL GMEQ(ALAT(1,NL),RL,3,1)
      RL(1)=RL(1)+CX
      RL(3)=RL(3)+CZ
      PH0=SCALPR(AK,RL)
      DO 12 IA=1,NATOM
      DO 13 N=1,NM(IA)
      PHASE=PH0
      CALL GMADD(POS(1,N,IA),ALAT(1,NL),P,3,1)
      DO 15 I=1,3
      IF (P(I).LT.0.) THEN
      P(I)=P(I)+1.
      PHASE=PHASE+AK(I)
      ELSE
      IF (P(I).GE.1.) THEN
      P(I)=P(I)-1.
      PHASE=PHASE-AK(I)
      ENDIF
      ENDIF
   15 CONTINUE
      ROT=CEXP(CMPLX(0.,TWOPI*PHASE))
      RM(1,2)=-AIMAG(ROT)
      RM(2,2)=REAL(ROT)
      CALL GMPRD(PM,RM,AM,2,2,2)
      A=CX+P(1)
      B=CZ+P(3)
      CALL PLCONV(A,B,4,AM(1,3),AM(2,3),3)
      PHP=(TWOPI*PHASE)-ALPHA
      ALEN=SQRT((COS(PHP)**2)+((SIN(PHP)*AX(2))**2))
      CALL GMSCA(AM,AM,ALEN,2,2)
      CALL PLTRIN(AM,5,3)
      CALL SPCSET(5)
      LARROW=0
      IF (P(2).NE.0) LARROW=1
      CALL ARROW(0.,0,LARROW)
   13 CONTINUE
      CALL GMREV(AM,AM,2,2)
   12 CONTINUE
   14 CONTINUE
   11 CONTINUE
   10 CONTINUE
C
C  FINISH OFF
      CALL PIGLET(A,B,-999)
      STOP
      END
C
C
C
C
C LEVEL 50      PROGRAM VECGEN
      PROGRAM VECGEN
C
C *** VECGEN by PJB Sep 87 ***
C
      DIMENSION Y(9),Z(3,50),VECLST(3,2500),II(2500),JJ(2500),
     & NUM(2500),IP(2500),VEC(3),ALIM(2,3),PROP(3),ATRAN(3),
     & ANTI(2500)
      CHARACTER*10 LABEL(50)
/ATNAM/
/CONSTA/
/IOUNIT/
/NSYM/
/POSNS/
/SCRACH/
/SYMDA/
      DATA PROP/.5,0.,0./
C
      CALL PREFIN('VECGEN')
      CALL SYMOP
      CALL ATOPOS
C
    4 WRITE (ITO,200)
  200 FORMAT (' Give maximum and minimum values for x, y, z')
      READ (ITO,201) ICARD
  201 FORMAT (A80)
      CALL RDNUMS(ALIM,1,6,NN,IER)
      IF (IER .NE.0) THEN
      WRITE (ITO,202)
  202 FORMAT (' Error in input !')
      GO TO 4
      ENDIF
C
C  GENERATE ALL ATOMIC POSITIONS
      M=0
      WRITE (LPT,103)
  103 FORMAT ('0Atomic Positions:'/)
      DO 1 NA=1,NATOM
      DO 1 NO=1,NOPC
      CALL ROTSYM(X(1,NA),Y,NO,1)
      DO 1 IR=1,-1,-2
      CALL GMADD(Y,TRANS(1,NO),Y(4),3,1)
      DO 2 NL=1,NLAT
      CALL GMADD(Y(4),ALAT(1,NL),Y(7),3,1)
      DO 3 I=1,3
      Y(6+I)=AMOD(Y(6+I),1.)
      IF (Y(6+I).LT.0) Y(6+I)=Y(6+I)+1.
    3 CONTINUE
      CALL EQPOS(Z,Y(7),M,M1,200)
      IF (M1.LE.M) GO TO 2
      M=M1
      WRITE (LABEL(M1),100) ATNAME(NA),NL,IR*NO
  100 FORMAT (A4,I2,I3,1X)
      WRITE (LPT,104) LABEL(M1),(Y(6+I),I=1,3)
  104 FORMAT (1X,A10,2X,3F10.4)
    2 CONTINUE
      CALL GMREV(Y,Y,3,1)
    1 CONTINUE
      WRITE (LPT,105) ALIM
  105 FORMAT (/' Interatomic Vectors from',f8.4,' to',F8.4,' in x'
     & ,F8.4,' to',F8.4,' in y and',F8.4,' to',F8.4,' in z :'/)
C
      NVEC=1
      N=0
      DO 10 I=1,M
      DO 10 J=1,M
      CALL GMSUB(Z(1,I),Z(1,J),VEC,3,1)
C
C  PUT ALL VECTORS INTO IST CELL PRESERVING TRANSLATION
      CALL GMZER(ATRAN,1,3)
      DO 31 IV=1,3
      IF (VEC(IV).LT.0.) THEN
        VEC(IV)=VEC(IV)+1.
        ATRAN(IV)=-1.
      ELSE
        IF (VEC(IV).GE.1.) THEN
          VEC(IV)=VEC(IV)-1.
          ATRAN(IV)=1.
        ENDIF
      ENDIF
   31 CONTINUE
C TEST IF TRANSLATION IS ANTIFERROMAGNETIC
      TEST=SCALPR(ATRAN,PROP)
      ANTI(NVEC)=COS(TWOPI*TEST)
C  TEST INSIDE BOX
      DO 11 IV=1,3
      IF (VEC(IV).LT.ALIM(1,IV) .OR. VEC(IV).GT.ALIM(2,IV)) GO TO 10
   11 CONTINUE
      CALL EQVEC(VECLST,VEC,N,N1,2500)
      II(NVEC)=I
      JJ(NVEC)=J
      NUM(NVEC)=N1
      IF (N.LT.N1) N=N1
      NVEC=NVEC+1
   10 CONTINUE
      NTOT=NVEC-1
      WRITE (ITO,205) NTOT
  205 FORMAT (1X,I3, ' Vectors found')
      IF (NTOT.EQ.0) STOP
C
C  SORT THEM
      CALL SORTN(NUM,IP,NTOT)
C
C  PRINT OUT
      DO 20 IJ=1,NTOT
      JP=IP(IJ)
      I=II(JP)
      J=JJ(JP)
      N=NUM(JP)
      AANT=SIGN(1.,ANTI(JP))
      IF(N.NE.NOLD .OR. AANT.NE. AANTO)THEN
        IF (AANT.GT.0.) WRITE (LPT,101) (VECLST(IV,N),IV=1,3)
  101   FORMAT (/'0Ferromagnetic Vector    ',3F8.4)
        IF (AANT.LT.0.) WRITE (LPT,106) (VECLST(IV,N),IV=1,3)
  106   FORMAT (/'0Antiferromagnetic Vector',3F8.4)
      ENDIF
      WRITE (LPT,102) LABEL(I),LABEL(J)
  102 FORMAT ('+',48X,' from ',A10,' to ',A10/)
      NOLD=N
      AANTO=AANT
   20 CONTINUE
C
      STOP
      END
##ENDPJB
##JBF
C
C         B R U C E   F O R S Y T H ' S   O W N   L I B R A R Y
C
C
C LEVEL 50      PROGRAM BRLSQ
      PROGRAM BRLSQ
C
C *** BRLSQ by JCM 4 May 88 ***
C
C ****************************************************************************
C
C                       B R L S Q
C
C MAIN PROGRAM BRLSQ FOR EXAMPLE OF SPECIAL STRUCTURE FACTOR LEAST SQUARES
C REFINEMENT
C
C THE ONLY CHANGES FROM THE STANDARD SFLSQ REFER TO THE USE OF BRCALC:
C
C WHEREVER LFCALC IS REFERRED TO IN SFLSQ, BRCALC IS USED.
C BRCALC IS VERY LIKE LFCALC, WITH A BLISTER WHICH CALLS FUNCTION BRUCE
C - WHICH IS ALSO INCLUDED.
C
C ****************************************************************************
C THE DIMENSION OF ALSQ AND THE VALUE OF MATSZ MAY BE ADJUSTED TO SAVE STORE AS
C FOLLOWS:
C IF N IS THE NUMBER OF BASIC VARIABLES (INDEPENDENT OBJECTS YOU ARE REFINING)
C THEN M=N*(N+3)/2, ROUNDED UP A LITTLE IS A SUITABLE VALUE.
C
C
      LOGICAL DFLTSF,LDUMMY
      EXTERNAL DFLTSF,LDUMMY,PARRUN,VARSSF
      CHARACTER *4 ISFWRD(22)
      EXTERNAL BRCALC
      LOGICAL PRINT,PRNCYC,IEND
%      DIMENSION ALSQ(%MATS%),ISWDSP(3,22)
      DIMENSION K(3),H(3)
/EXTN/
/FCAL/
/IOUNIT/
/NSYM/
/OBSCAL/
/POSNS/
/PRBLEM/
/REFINE/
/SCLDAT/
/SCRACH/
      DATA ISFWRD/' ','SCAL','TFAC','X','Y','Z',
     & 'B11','B22','B33','B23','B13',
     & 'B12','SCAT','SITE','ITF',
     & 'XYZ','BIJ','XYZT','FAM1',
     & 'FAM2','DOMR','MOSC'/
** NB UPDATE LIKE SFLSQ TO USE XYZB,XYZS FACILITIES
      DATA ISWDSP/1,1,0, 1,2,0, 1,1,1, 2,0,1, 2,0,2, 2,0,3,
     & 2,0,4, 2,0,5, 2,0,6, 2,0,7, 2,0,8,
     & 2,0,9, 2,0,10, 2,0,11, 2,0,12,
     & -1,0,0, -2,0,0, -3,0,0, 1,0,0,
     & 2,0,0, 1,1,8, 1,1,9/
C
C ALTER VALUE HERE:
%       MATSZ=%MATS%
C
C SET UP STRUCTURE FACTOR CALCULATION:
      CALL PREFIN('BRLSQ')
      MAG=.FALSE.
      MESSAG='Reflection data'
      LUNI=NOPFIL(11)
      CALL SETFC
C
C SPECIFY PROBLEM:
      NFAM=2
      NGENS(1)=2
      NGENS(2)=NATOM
      NSPC(1)=20
      NSPC(2)=12
C
C SPECIES TYPES FOR EACH GENUS OF FAMILY 1:
      LF1SP(1)=9
      LF1SP(2)=-20
C
C WORDS RELEVANT TO THIS PROBLEM FROM DATA INTO COMMON:
      CALL LSETUP(22,ISWDSP,ISFWRD)
C
C NAMES SET UP SO THAT:
C FAMILY 1 GENUS 1 HAS SPECIES TFAC, DOMR, MOSC
C   '    1    '  2 HAS GENUS NAME SCAL, SPECIES INDICATED TO BE 1,2,3 ETC
C
C FAMILY 2 IS AS USUAL THE PARAMETERS WHICH DEPEND ON THE ATOM.  GENUS NAMES
C ARE THEREFORE THE SAME AS ATOM NAMES, AND SPECIES NAMES ARE:
C X Y Z B11 B22 B33 B23 B13 B12 SCAT SITE ITF
      WRITE (LPT,2020)
2020  FORMAT (///' Least Squares Refinement - Simple structure',
     & ' factor program')
C
C READ I AND (MOST) L CARDS:
      CALL STLSSF
      CALL EXTINC(1,0.)
      IF (IEXTYP .NE. 0 .AND. MODER .NE. 5) THEN
**PUT THIS EVERYWHERE:
        WRITE (LPT,3000)
3000    FORMAT (' ERROR ** Extinction corrections need MODE 5 ',
     &  'reflection data format')
        STOP
      ENDIF
C
C SET UP PARAMETERS AS VARIABLES:
      CALL PARSSF(LDUMMY)
C
C SET UP VARIABLES:
      CALL VARMAK(DFLTSF,PARRUN,VARSSF,LDUMMY)
C
C
      DONE=.FALSE.
      DO 1 ICYC=NCYC1,LASTCY
C IS PRINTING OF STRUCTURE FACTOR LIST REQUESTED THIS CYCLE?
      PRINT=PRNCYC(1)
      IF (.NOT. PRINT) GO TO 4
C
C PRINTING IN MAIN PROGRAM FOR EASE OF ADJUSTMENT BY USER:
      WRITE (LPT,2000)
2000  FORMAT(//' Structure factor listing :')
      IF (CENTRC) THEN
        WRITE (LPT,2001)
2001    FORMAT ('     h    k    l    G(obs)   G(calc)      Diff   Sgnd',
     &  ' Fc     Scale    Weight')
      ELSE
        WRITE (LPT,2002)
2002    FORMAT ('     h    k    l     G(obs)   G(calc)     Diff     A ',
     &  '      B        mod Fc    Scale    Weight')
      ENDIF
C
C INITIALISE R FACTOR SUMS:
      CALL RFACS(1)
C SET UP POINTERS IN TRIANGULAR MATRIX AND CLEAR OUT LSQ MATRIX AND RHS:
      CALL MATSET(ALSQ,MATSZ)
C
C COUNT USED OBSERVATIONS (THERE IS NOT AT PRESENT ANT WAY OF NOT USING ONE)
      NOBS=0
C
C BRANCH ON REFLECTION DATA FORMAT:
   2  IF (MODER .NE. 0) GO TO 7
C USER'S OWN INPUT ROUTINE TO BE SUPPLIED:
      CALL QLSQIN(K,IEND)
      IF (IEND) GO TO 3
      GO TO 20
C
   7  GO TO (11,12,13,14,15,16) , MODER
C THE EXISTING OPTIONS FOR MODER ARE:
C   1.   H,K,L,OBS,(SCALE GROUP), (CODE)
C   2.   H,K,L,OBS,WEIGHT, (SCALE GROUP), (CODE)
C   3.   H,K,L,OBS,STANDARD DEVIATION OF OBS, (SCALE GROUP),(CODE)
C   4.   H,K,L,GCAL,OBS,STANDARD DEVN. (O/P FROM MEANGM)
C  (5.   H,K,L,OBS,STD DEVN,C1 C2 C3 C4, WHERE C1-C4 ARE THE
C        CONSTANTS INVOLVED IN EXTINCTION CORRECTIONS)
C   6.   H,K,L,ACALC,BCALC,OBS,STANDARD DEVN., (SCALE GROUP) (CODE)
C WHERE BOTH THE SCALE GROUP AND CODE ARE OPTIONAL.  IF THE SCALE GROUP IS REA
C  AS ZERO, IT WILL BE SET = 1.
C   THE CODE IS NOT AT PRESENT USED; IT IS ENVISAGED THAT IT MAY BE USEFUL
C IN REJECTING SELECTED OBSERVATIONS LATER.
C
  11  READ (LUNI,1000,END=3) K,OBS,ISCALE,ICODE
1000  FORMAT (3I5,F10.4,2I5)
      GO TO 20
C
  12  READ (LUNI,1001,END=3) K,OBS,WT,ISCALE,ICODE
1001  FORMAT (3I5,2F10.4,2I5)
      GO TO 20
C
  13  READ (LUNI,1001,END=3) K,OBS,DOBS,ISCALE,ICODE
      GO TO 20
C
  14  READ (LUNI,1002,END=3) K,OBS,DOBS
1002  FORMAT (3I5,10X,2F10.4)
      ISCALE=0
      ICODE=0
      GO TO 20
C
C THESE ARE FOR EXT CORR:
  15  READ (LUNI,1003,END=3) K,OBS,DOBS,CEXT,ISCALE
1003  FORMAT (3I5,6F10.4,I5)
      IF (ISCALE .EQ. 0) ISCALE=1
      ICODE=0
      GO TO 20
C
  16  READ (LUNI,1004,END=3) K,OBS,DOBS,ISCALE,ICODE
1004  FORMAT (3I5,20X,2F10.4,2I5)
      IF (ISCALE .EQ. 0) ISCALE=1
      ICODE=0
      GO TO 20
C
C SQUARE INPUT OBS IF REFINEMENT TYPE 2:
  20  IF (IREF .EQ. 2) OBS=OBS*OBS
C PUT ISCALE WITHIN PERMITTED RANGE:
      IF ((ISCALE .EQ. 0) .OR. (ISCALE .GT. NSCALE)) ISCALE=1
C
C CALCULATE FUNCTION TO MATCH OBSERVED, AND ITS DERIVATIVES:
      CALL INDFLO(H,K)
      CALL CALCSF(H,BRCALC)
C CALCSF FORMS GCALC,  PUTS DG/DV INTO DERIVV FOR ALL VARIABLES, AND SETS UP
C ALL REQUIRED QUANTITIES IN OBSCAL FOR SUBSEQUENT CALLS OF MATREF AND RFACS
C
C MAKE DERIVATIVES WRT BASIC VARIABLES FROM THOSE WRT VARIABLES:
      CALL RELATE
C
C DIFFERENCES AND WEIGHTS:
      DIFF = OBS - GCALC
      CALL WGHTSF
C GETS WEIGHT AND SQRTWT INTO COMMON
C
C STRUCTURE FACTOR LISTING IF REQUIRED:
      IF (PRINT) THEN
        IF (CENTRC) THEN
          A=REAL(FC)
          WRITE (LPT,2003) K,OBS,GCALC,DIFF,A,SCALE(ISCALE),WT
2003      FORMAT (' ',3I5,2F10.3,F10.5,2F10.4,G12.4)
        ELSE
          WRITE (LPT,2004) K,OBS,GCALC,DIFF,FC,FCMOD,SCALE(ISCALE),WT
2004      FORMAT (' ',3I5,2F10.3,F10.5,4F10.4,G12.4)
        ENDIF
      ENDIF
C
C ADD IN TO R FACTORS:
      CALL RFACS(2)
C
C ADD DERIVATIVES IN TO LSQ MATRIX:
      CALL MATTOT(ALSQ,MATSZ)
      NOBS=NOBS+1
C
C NEXT OBSERVATION:
      GO TO 2
C
C HERE ON NO MORE OBSERVATIONS - REWIND OBSERVATIONS FILE AND PRINT R FACTORS:
   3  REWIND LUNI
      CALL RFACS(3)
C
C INVERT MATRIX, CALCULATE SHIFTS AND ESD'S; APPLY AND PRINT:
      CALL MATINV(ALSQ,MATSZ)
      CALL MATSHF(ALSQ,MATSZ)
      CALL APSHSF(DUMMY)
      IF (ICYC .EQ. LASTCY-1 .OR. NCYC.EQ.1) CALL NWINSF(DUMMY)
   1  CONTINUE
C
C PRINT CORRELATION MATRIX; PRODUCE NEW CRYSTAL DATA FILE:
      CALL MATCOR(ALSQ,MATSZ)
 100  STOP
      END
C
C
C
C
      SUBROUTINE BRCALC(H)
C
C *** BRCALC SPECIAL FOR BRUCE by JCM 29 Jan 88 ***
C
CH Calculate nuclear structure factor and its derivatives
CA On entry H is a 1x3 array containing h,k,l
CD On exit in /FCAL/
CD    FC is the complex structure factor
CD    FCMOD is its modulus
CD    COSAL is the cosine of its phase
CD    SINAL is the sine of its phase
CD    FCDERS is an array of derivatives of FCMOD wrt all family 2 (structure
CD           parameters.  These are NOT multiplied or divided by anything
CD           else;  compare LMCALC
CD The above will all be zero if h,k,l gives a lattice absence;  note that
CD such would not be true of FCALC
C
      COMPLEX DERIVT,SUM1,TERM,FORM,HR,FORMFA
      LOGICAL TESTOV,LATABS
%      DIMENSION DERIVT(%F2VA%),RH(3),H(3)
/ANISO/
/BRAGG/
/CONSTA/
/DERVAR/
/FCAL/
/FORMDA/
/NSYM/
/PHASE/
/POINTS/
/POSNS/
/PRBLEM/
/SYMDA/
C
C CLEAR ANSWERS IN CASE ABSENT:
C
C  FC COLLECTS THE CONVENTIONAL STRUCTURE FACTOR, COMPLEX:
      FC=CMPLX(0.,0.)
C CLEAR MODULUS AND ANGLES:
      FCMOD=0.
      COSAL=0.
      SINAL=0.
      LO=LVFST1(2,1,1)
      L2=NVARF(2,1,1)
C CLEAR DERIVATIVES:
      IF (L2 .GT. 0) CALL GMZER(FCDERS,1,L2)
C
C OUT IF ABSENT:
      IF (LATABS(H)) GO TO 100
C
C SET FIRST SCATTERING FACTOR:
      IFF=0
C
C CYCLE OVER INDEPENDENT ATOMS:
      DO 1 IR=1,NATOM
      SUM1=CMPLX(0.,0.)
      IF (NFORMF(IR) .NE. IFF) THEN
        IFF=NFORMF(IR)
        FORM=FORMFA(STHL,IFF)
C *** FOR BRUCE ***
        IF (IR .EQ. 1) FORM=FORM*BRUCE(H)
C *** END
      ENDIF
C
C INNER LOOP OVER SYMMETRY EQUIVALENTS:
      DO 3 IS=1,NOPC
      CALL ROTSYM(H,RH,IS,-1)
      F1=TWOPI*(SCALPR(X(1,IR),RH)+SCALPR(TRANS(1,IS),H))
      ERS=ANITF(RH,IR)
C ANISOTROPIC T F (=1. IF NOT THERE) NEEDED SEPARATELY FOR LSQ:
      ARS=COS(F1)*ERS
      BRS=SIN(F1)*ERS
      TERM=CMPLX(ARS,BRS)
      SUM1=SUM1+TERM
C
C  NOW WE DO THE INNERMOST SUMS FOR THE DERIVATIVES OF MODFC WRT
C VARIABLES XYZ AND ALL BIJ.  WE USE THE
C COMPLEX VECTOR DERIVT FOR THE DERIVATIVES OF THE REAL & IMAGINARY PARTS
C OF THE COMPLEX FC WRT EACH VARIABLE IN TURN.
C
      DO 7 I=1,3
      L=KX(I,IR)
      IF (L .NE. 0) DERIVT(L-LO)=RH(I)*CMPLX(-BRS,ARS) + DERIVT(L-LO)
   7  CONTINUE
C
C IF ANY ATF (NOT A LOOP, FOR SPEED):
      IA=IAPT(IR)
      IF (IA .NE. 0) THEN
        L=KATF(1,IA)
        IF (L.NE.0) DERIVT(L-LO)=RH(1)*RH(1)*TERM + DERIVT(L-LO)
        L=KATF(2,IA)
        IF (L.NE.0) DERIVT(L-LO)=RH(2)*RH(2)*TERM + DERIVT(L-LO)
        L=KATF(3,IA)
        IF (L.NE.0) DERIVT(L-LO)=RH(3)*RH(3)*TERM + DERIVT(L-LO)
        L=KATF(4,IA)
        IF (L.NE.0) DERIVT(L-LO)=RH(3)*RH(2)*TERM + DERIVT(L-LO)
        L=KATF(5,IA)
        IF (L.NE.0) DERIVT(L-LO)=RH(1)*RH(3)*TERM + DERIVT(L-LO)
        L=OKATF(6,IA)
        IF (L.NE.0) DERIVT(L-LO)=RH(1)*RH(2)*TERM + DERIVT(L-LO)
      ENDIF
   3  CONTINUE
C END OF INNERMOST CYCLE OVER SYMMETRY
C
C IF CENTROSYMMETRIC, COMPENSATE FOR USING ONLY HALF NUMBER OF OPERATORS:
      IF (CENTRC) SUM1=SUM1+CONJG(SUM1)
C
      FAC=AMULT(IR)*EXP(-TF(IR)*SSQRD)
      HR=FAC*FORM*SITE(IR)
C HR IS PRODUCT OF ATOM DEPENDENT BUT SYMMETRY INDEPENDENT FACTORS
      FC=FC + HR*SUM1
C
C  NOW WE TIDY UP THE XYZ AND BIJ DERIVATIVES, ALLOWING FOR CENTRE:
      DO 8 I=1,3
      L=KX(I,IR)
      IF (L.GT.0) THEN
        DERIVT(L-LO)=TWOPI*HR*DERIVT(L-LO)
        IF (CENTRC) DERIVT(L-LO)=DERIVT(L-LO)+CONJG(DERIVT(L-LO))
      ENDIF
      IF (IA .NE. 0) THEN
        L=KATF(I,IA)
        IF (L.GT.0) THEN
          DERIVT(L-LO)=-HR*DERIVT(L-LO)
          IF (CENTRC) DERIVT(L-LO)=DERIVT(L-LO)+CONJG(DERIVT(L-LO))
        ENDIF
        L=KATF(I+3,IA))
        IF (L.GT.0) THEN
          DERIVT(L-LO)=-HR*2.*DERIVT(L-LO)
          IF (CENTRC) DERIVT(L-LO)=DERIVT(L-LO)+CONJG(DERIVT(L-LO))
        ENDIF
      ENDIF
   8  CONTINUE
C FORM FACTOR:
      L=KCMULT(IR)
C4.18 DERIVATIVE FOR MULTIPLIER ONLY
C WAS      IF (L.GT.0) DERIVT(L-LO)=SITE(IR)*FAC*SUM1
      IF (L.GT.0) DERIVT(L-LO)=SITE(IR)*FAC*SUM1*FORM/CMULT(IR)
C SITE OCCUPATION:
      L=KSITE(IR)
      IF (L.GT.0) DERIVT(L-LO)=FORM*FAC*SUM1
C ISOTROPIC TEMPERATURE FACTOR:
      L=KTF(IR)
      IF (L.GT.0) DERIVT(L-LO)=-SSQRD*HR*SUM1
   1  CONTINUE
C END OF CYCLE OVER ATOMIC POSITIONS
C
C  TIDY FCALC AND COLLECT TRUE D(MODFC)/D(VARIABLE)
C
      A = REAL(FC)
      B = AIMAG(FC)
      FCMOD = SQRT(A*A+B*B)
      IF (.NOT. TESTOV(A,FCMOD)) THEN
        COSAL=A/FCMOD
        SINAL=B/FCMOD
      ENDIF
      DO 6 I=1,L2
C NO SUMMING - THESE ARE THE ACTUAL DERIVATIVES NOT DIVIDED BY ANYTHING, AS
C THEY ARE SUBJECT TO THE CHAIN RULE NEXT, NOT LOGARITHMIC DIFFERENTIATION:
      FCDERS(I)=REAL(DERIVT(I))*COSAL + AIMAG(DERIVT(I))*SINAL
   6  CONTINUE
 100  RETURN
      END
C
C
C
C
      FUNCTION BRUCE(H)
C
C *** BRUCE corrected by JCM 9 Sep 88 ***
C
C PARTICULAR ROUTINE TO MAKE GEOMETRIC FACTOR FOR P WARREN
C
      DIMENSION H(3),H2(3)
C
      B=0.
      DO 1 I=1,3
      H2(I)=H(I)*H(I)
   1  B=B+H2(I)
      A=H2(1)*H2(2)+H2(2)*H2(3)+H2(3)*H2(1)
      B=B*B
      BRUCE=1.-5.*A/B
      RETURN
      END
C
C
C
C
C LEVEL 50      PROGRAM COMPAF
      PROGRAM COMPAF
C
C *** COMPAF BY JBF/JCM Jul 87 ***
C
C ******************************************************************************
C
C                      C O M P A F
C
C  TO COMPARE TWO DATA SETS OUTPUT FROM ARRINC
C  AND PRODUCE SOME STATISTICS
C ******************************************************************************
C
      DIMENSION LUN(2)
      CHARACTER*10 FILNOM,TITLE
/CARDRC/
      COMMON/HEADNG/HEDING
      CHARACTER*180 HEDING
/IOUNIT/
/REFS/
/SCRACH/
/STATS/
C
      CALL PREFIN('COMPAF')
      IF (INREAD(9) .GT. 0) CALL INPUTI
      CALL ICDFMT(INC,ITEMS)
C
      DO 1 IS=1,2
    8 WRITE (ITO,10) IS
   10 FORMAT (' Give file-name for stream',I2,': '$)
      READ (ITI,11) ICARD
   11 FORMAT (80A1)
      CALL RDWORD(TITLE,LEN,1,IE,11,0,IER)
      IF (IER.EQ.0) GO TO 5
      WRITE (ITO,16)
   16 FORMAT (' File-name unreadable ')
      GO TO 8
   5  SCALE(IS)=1.
      MESSAG=TITLE(1:LEN)
      NAMFIL='.ARR'
      LUN(IS)=NOPFIL(121)
      IF (LUN(IS).LT.0) GO TO 8
    1 CONTINUE
      HEDING(7:16)=FILNOM(LUN(1))
      HEDING(24:33)=FILNOM(LUN(2))
      WRITE (LPT,13) (FILNOM(LUN(I)),I=1,2)
   13 FORMAT (//22X,'****** COMPARISON of ',A10,' with ',A10,' ******')
      WRITE (LPT,HEDING)
      LINO=8
C
      MODE=0
      CALL STATIS(-1)
      CALL WTMEAN(X,DX,0,WRK1)
    6 IF (INPUAR(MODE,LUN).NE.0) GO TO 4
      IF (MATCHF(FF) .NE. 0) GO TO 6
C
    2 CALL STATIS(0)
      CALL TESTP(LPT,LINO,1,HEDING,3)
      WRITE (LPT,15) (FF(I,1),I=1,3),(AMEAN(I),DEV(I),I=1,2),X,DX,RAT,
     & DRAT
   15 FORMAT (1X,3F8.3,4(2X,2F10.4))
      GO TO 6
C
C  HERE TO END
    4 CALL WTMEAN(X,DX,-1,WRK1)
      CHI=(WRK1(2)-X*WRK1(1))/(WRK1(4)-1.)
      WRITE (LPT,12) X,DX,CHI
   12 FORMAT (/' Ratio 2:1 is',F8.4,' +/-',F7.4,' with Chi-squared 'F8
     &.4)
      STOP
      END
C
C
C
C
      BLOCK DATA BLKHED
      COMMON/HEADNG/HEDING
      CHARACTER*180 HEDING
      DATA HEDING/'(32X,''          '',12X,''          '',13X,''Combin
     &ed'',16X,''Ratio''/''       h       k       l      Mean      Esd
     &Mean       Esd        Value      Esd        Value      Esd''/)'/
      END
C
C
C
C
C LEVEL 50      PROGRAM COMREF
      PROGRAM COMREF
C
C *** COMREF updated by JBF/JCM Jun 87 ***
C
C ******************************************************************************
C
C                      C O M R E F
C
C  TO COMPARE TWO DATA SETS WHOSE EQUIVALENTS HAVE ALREADY BEEN GROUPED
C  AND PRODUCE SOME STATISTICS
C CAN INPUT EITHER FIXED OR FLOATING INDICES
C ******************************************************************************
C
      DIMENSION LUN(2)
      CHARACTER*10 FILNOM,TITLE
/CARDRC/
      COMMON/HEADNG/HEDING
      CHARACTER*180 HEDING
/IOUNIT/
/REFS/
/SCRACH/
/STATS/
C
      CALL PREFIN('COMREF')
      CALL ICDFMT(INC,ITEMS)
      IF (INC .EQ. 0) THEN
        HEDING(2:3)='23'
        HEDING(63:63)='1'
        HEDING(72:72)='1'
        HEDING(82:82)='1'
      ENDIF
C
      DO 1 IS=1,2
    8 WRITE (ITO,10) IS
   10 FORMAT (' Give file-name for stream',I2,': '$)
      READ (ITI,11) ICARD
   11 FORMAT (80A1)
      CALL RDWORD(TITLE,LEN,1,IE,11,0,IER)
      IF (IER.EQ.0) GO TO 5
      WRITE (ITO,16)
   16 FORMAT (' File-name unreadable ')
      GO TO 8
    5 SCALE(IS)=1.
      MESSAG=TITLE(1:LEN)
C DEFAULT .DAT
      LUN(IS)=NOPFIL(21)
      IF (LUN(IS).LT.0) GO TO 8
    1 CONTINUE
      HEDING(7:16)=FILNOM(LUN(1))
      HEDING(24:33)=FILNOM(LUN(2))
      WRITE (LPT,13) (FILNOM(LUN(I)),I=1,2)
   13 FORMAT (//22X,'****** COMPARISON of ',A10,' with ',A10,' ******')
      WRITE (LPT,HEDING)
      LINO=8
C
      MODE=0
      CALL STATIS(-1)
      CALL WTMEAN(X,DX,0,WRK1)
    6 IF (INONE(MODE,LUN).NE.0) GO TO 4
      IF (INC .EQ. 0) MODE=MATCH(K)
      IF (INC .EQ. 1) MODE=MATCHF(FF)
      IF (MODE.NE.0) GO TO 6
C
    2 CALL STATIS(0)
      CALL TESTP(LPT,LINO,1,HEDING,3)
      IF (INC .EQ. 0) WRITE (LPT,2001) (K(I,1),I=1,3),(AMEAN(I),
     & DEV(I),I=1,2),X,DX,R AT,DRAT
2001  FORMAT (1X,3I5,4(2X,2F10.4))
      IF (INC .EQ. 1) WRITE (LPT,2002) (FF(I,1),I=1,3),(AMEAN(I),
     & DEV(I),I=1,2),X,DX,RAT,DRAT
2002  FORMAT (1X,3F8.3,4(2X,2F10.4))
      GO TO 6
C
C  HERE TO END
    4 CALL WTMEAN(X,DX,-1,WRK1)
      CHI=(WRK1(2)-X*WRK1(1))/(WRK1(4)-1.)
      WRITE (LPT,12) X,DX,CHI
   12 FORMAT (/' Ratio 2:1 is',F8.4,' +/-',F7.4,' with Chi-squared 'F8
     &.4)
      STOP
      END
C
C
C
C
      BLOCK DATA BLKHED
      COMMON/HEADNG/HEDING
      CHARACTER*180 HEDING
      DATA HEDING/'(32X,''          '',12X,''          '',13X,''Combin
     &ed'',16X,''Ratio''/4X,''  h'',4X,''   k'',4X,''   l       Mean'',
     &''      EsdMean     Mean   EsdMean     Value       Esd'',
     &''     Value  Esd''/ )'/
      END
C
C
C
C
      FUNCTION INONE(M,LUN)
C
C *** INONE BY JBF 19 Jun 87 ***
C
      DIMENSION LUN(2)
/REFS/
C
      INONE=0
      IF (M.EQ.0) THEN
      MS=1
      ME=2
      ELSE
      MS=M
      ME=M
      ENDIF
      DO 1 IS=MS,ME
      LL(1,IS)=5
      LL(2,IS)=3
   2  IF (INC .EQ. 1) READ (LUN(IS),1001,END=4)(R(I,IS),I=1,5)
      IF (INC .EQ. 0) READ (LUN(IS),1002,END=4)(R(I,IS),I=1,5)
1001  FORMAT (3F8.3,2F10.4)
1002  FORMAT (3F5.0,2F10.4)
      DO 6 I=4,5
    6 R(I,IS)=SCALE(IS)*R(I,IS)
C  LEAVE ROOM FOR STORAGE OF MEANS
C
      II=7
   3  CALL GMEQ(R(1,IS),FF(1,IS),1,3)
      CALL INDFIX(R(1,IS),K(1,IS))
      GO TO 1
C
C  END OF DATA
   4  INONE=INONE+IS
C
    1 CONTINUE
      RETURN
      END
C
C
C
C
C LEVEL 50      PROGRAM EXTTOF
      PROGRAM EXTTOF
C
C *** EXTTOF updated by JBF 16 Aug 89 ***
C
C ******************************************************************************
C
C                            E X T T O F
C
C  PROGRAM TO WRITE THE GOBS FILE FOR LSQ WITH EXTINCTION
C  THIS VERSION FOR TOF DATA BY J.B. FORSYTH MARCH 1986
C  THE OBSERVATIONS ARE HKL, FOBS, DFOBS, WAVELENGTH 3I5,3F10.4
C
C ******************************************************************************
      DIMENSION K(3),H(3)
      CHARACTER*40 FILNAM
      COMPLEX FCALC
      LOGICAL LATABS
/CELPAR/
/DGEOM/
/EXTN/
/IOUNIT/
/SCRACH/
C
      CALL PREFIN('EXTTOF')
      CALL SYMOP
      CALL RECIP
      CALL EXTINC(1,0.)
      CALL INPUTI
      CALL ICDFMT(INC,ITEMS)
      NAMFIL='.SF'
      LUNO=NOPFIL(102)
      IS=0
C
    9 WRITE (ITO,10)
   10 FORMAT (' Give input file name and scale (RETURN ',
     & 'if no more ): ')
      READ (ITI,11) ICARD
   11 FORMAT(80A1)
      CALL RDWORD(FILNAM,LEN,1,IE,40,0,IER)
      IF (IER.EQ.0) GO TO 1
      IF (IER.EQ.100) GO TO 100
      WRITE (ITO,12)
   12 FORMAT (' Illegal file name')
      GO TO 9
C
    1 CALL RDREAL(SCALE,I,IE,80,IER)
      IF (IER.NE.0) SCALE=1.
      MESSAG=FILNAM
      NAMFIL='.SF'
      LUN=NOPFIL(131)
      IF (LUN.LE.0) GO TO 9
      WRITE (LPT,17) NAMFIL,SCALE
   17 FORMAT ('0Data read from ',A10,' and multiplied by',F8.3/)
      IS = IS+1
   3  IF (INC .EQ. 0)READ (LUN,13,END=9) K,FOBS,DF,ALAMB
      IF (INC .EQ. 1)READ (LUN,133,END=9) H,FOBS,DF,ALAMB
   13 FORMAT (3I5,4F10.4)
 133  FORMAT (3F8.3,4F10.4)
      IF (INC .EQ. 0) THEN
        CALL INDFLO(H,K)
        IF (LATABS(H)) GO TO 3
      ENDIF
      FOBS = FOBS/SCALE
      DF = DF/SCALE
      VEC = VCTMOD(0.5,H(1),2)
C      CALL ABMULT(H(1),ABSC)
C      TM = ABSC(3)/ABSC(1)
      TM = 2.0
      ALAM3=ALAMB**3
      SINTH = ALAMB*VEC
      CALL SINCOS(SINTH,COSTH,'EXTTOF')
      SINTH = 2.*SINTH*COSTH
      COSTH = (2.*COSTH*COSTH) - 1.
      CEXT(1) = ALAM3*TM/(SINTH*V(1)**2)
      CEXT(1) = 1000*CEXT(1)
      CEXT(2) = ALAMB/SINTH
      IF (LOREN) THEN
C EXTINCTION FOR LORENTZIAN DISTRIBUTION
        CEXT(3) = .025 + .285*COSTH
        CEXT(4) = 0.15 - 0.2*(0.75-COSTH)**2
      ELSE IF (GAUSS) THEN
C GAUSSIAN DISTRIBUTION
        CEXT(3) = 0.58+0.48*COSTH+0.24*(COSTH**2)
        CEXT(4) = 0.02-0.025*COSTH
      ENDIF
      IF (INC .EQ. 0) WRITE (LPT,15) K,FOBS,DF,(CEXT(I),I=1,4),ALAMB,IS
      IF (INC .EQ. 1) WRITE (LPT,155) H,FOBS,DF,(CEXT(I),I=1,4),ALAMB,IS
   15 FORMAT (1X,3I5,7F10.4,I5)
 155  FORMAT (1X,3F8.3,7F10.4,I5)
      IF (INC .EQ. 0) WRITE (LUNO,16) K,FOBS,DF,(CEXT(I),I=1,4),IS
      IF (INC .EQ. 1) WRITE (LUNO,166) H,FOBS,DF,(CEXT(I),I=1,4),IS
   16 FORMAT (3I5,6F10.4,I5)
 166  FORMAT (3F8.3,6F10.4,I5)
      GO TO 3
C
  100 STOP
      END
C
C
C
C
C LEVEL 50      PROGRAM MERGEF
      PROGRAM MERGEF
C
C *** MERGEF BY JBF AFTER PJB'S MERGE ***
C
C *************************************************************************
C
C                             M E R G E F
C
C  TO MERGE TWO DATA SETS OUTPUT FROM ARRINC
C  AND PRODUCE SOME STATISTICS
C
C *************************************************************************
C
C THIS PROGRAM LAGS SLIGHTLY BEHIND MERGE IN PJB.  WHEN MERGE IS UPDATED,
C IT AND THIS SHOULD BE AMALGAMATED TO WORK FOR EITHER FIXED OR FLOATING
C INDICES.  THERE IS NO NEED TO USE ARRAY F IN /SCRAT - THE FLOATING INDICES
C ARE AVAILABLE IN ARRAY R.  THE TITLES STILL NEED ADJUSTING FOR THE WIDER
C H K L OUTPUT.
C
      CHARACTER*10 FILNAM,FILNOM
      COMMON/HEADNG/HEDING
      CHARACTER*280 HEDING
/IOUNIT/
      COMMON/SCRAT/LL(48,2),R(500,2),F(3,2),KK(3),WRK1(5),WRK2(5),
     & WRK3(5),IEND,SCALE(2),LINO,SUM(4),LUN(2)
/SCRACH/
      CHARACTER*10 NAME(2)
      EQUIVALENCE (MESSAG,NAME)
C
      CALL INITIL('MERGEF')
C
      DO 9 I=1,4
    9 SUM(I)=0.
      IEND=0
      DO 1 IS=1,2
    8 WRITE (ITO,10) IS
      READ (ITI,11) ICARD
      CALL RDWORD(FILNAM,LEN,1,IE,11,0,IER)
      IF (IER.EQ.0) GO TO 5
      WRITE (ITO,16)
      GO TO 8
    5 MESSAG=FILNAM
      NAMFIL='.ARR'
      LUN(IS)=NOPFIL(121)
    7 CALL RDREAL(SCALE(IS),IE,I,80,IER)
      IF (IER.NE.0) SCALE(IS)=1.
    1 CONTINUE
      NAMFIL='.MNG'
      LUNI=NOPFIL(102)
      NAME(1)=FILNOM(LUN(1))
      NAME(2)=FILNOM(LUN(2))
      NAME(3)=FILNOM(LUNI)
      WRITE (LPT,13) (NAME(I),I=1,3)
   13 FORMAT (//22X,'****** MERGE of ',A10,' with ',A10,' ******'/30X,
     & 'output of mean data to ',A10/)
      WRITE (LPT,HEDING)
      LINO=11
C
      MODE=0
      CALL WTMEAN(X,DX,0,WRK1)
    6 IF (INPUT(MODE).EQ.0) GO TO 3
C
C  END OF FILE DETECTED
      IF (IEND.EQ.3) GO TO 4
      MODE=3-IEND
      GO TO 2
C
    3 IF (IEND.NE.0) GO TO 2
      MODE=MATCHF(F)
C
    2 CALL STATS(MODE)
      GO TO 6
C
C  HERE TO END
    4 CALL WTMEAN(X,DX,-1,WRK1)
      WRITE (LPT,12) X,DX
      WRITE (ITO,12) X,DX
      CHI1=SUM(1)/SUM(2)
      CHI2=SUM(3)/SUM(4)
      WRITE (LPT,14) CHI1,CHI2
      WRITE (ITO,14) CHI1,CHI2
      STOP
C
   10 FORMAT (' Give file-name and scale for stream',I2,' : '$)
   11 FORMAT (80A1)
   12 FORMAT (/' Ratio 2:1 is',F8.4,' +/-',F7.4)
   14 FORMAT ('0The chisquared for repeated measurements is',F6.2//
     & ' That for supposedly equivalent measurements is',F6.2)
   16 FORMAT (' Illegal character in file-name')
   17 FORMAT (' File ',A10,' not found')
      END
C
C
C
C
      BLOCK DATA BLKHED
      COMMON/HEADNG/HEDING
      CHARACTER*280 HEDING
      DATA HEDING/'(43X,''Mean of Repeated'',6X,''Labelling   Mean of
     &Equivalent'',8X,''Ratio''/'' File    Indices'',6X,2('' Measurem
     &ents'',9X),''Indices       Measurements         Str1/Str2''/9X,'
     &'h   k   l    Value      Esd        Value      Esd        h   k
     &  l'',2(4X,''Value      Esd  '')/)'/
      END
C
C
C
C
      FUNCTION INPUT(M)
C
/FINAME/
/IOUNIT/
      COMMON/SCRAT/LL(48,2),R(500,2),F(3,2),KK(3),WRK1(5),WRK2(5),
     & WRK3(5),IEND,SCALE(2),LINO,SUM(4),LUN(2)
C
      INPUT=0
      IF (M.EQ.0) THEN
      MS=1
      ME=2
      ELSE
      MS=M
      ME=M
      ENDIF
      DO 1 IS=MS,ME
      NR=1
      L=0
      II=0
    2 II=II+L
      READ (LUN(IS),10,END=4) L,(R(II+I,IS),I=1,L)
   10 FORMAT (I5,3F8.0,(6F10.6))
      LL(NR,IS)=L
      IF (L.EQ.3) GO TO 3
      DO 6 I=4,L
    6 R(II+I,IS)=SCALE(IS)*R(II+I,IS)
      NR=NR+1
      GO TO 2
C
C  END OF A GROUP OF EQUIVALENTS
    3 DO 50 JJ=1,3
   50 F(JJ,IS)=R(II+JJ,IS)
      GO TO 1
C
C  END OF DATA
    4 IEND=IEND+IS
      INPUT=IEND
C
    1 CONTINUE
      RETURN
      END
C
C
C
C
      SUBROUTINE STATS(MODE)
C
C  TO CALCULATE MEANS AND OTHER STATISTICS FOR A SET OF MEASUREMENTS
C  OF A SINGLE QUANTITY
C
      DIMENSION AMEAN(2),DEV(2)
/FINAME/
/IOUNIT/
      COMMON/SCRAT/LL(48,2),R(500,2),F(3,2),KK(3),WRK1(5),WRK2(5),
     & WRK3(5),IEND,SCALE(2),LINO,SUM(4),LUN(2)
      COMMON/HEADNG/HEDING
      CHARACTER*280 HEDING
C
      IF (MODE.NE.0) THEN
      MS=MODE
      ME=MS
      ELSE
      MS=1
      ME=2
      ENDIF
C
      DO 4 IS=MS,ME
      CALL WTMEAN(X,DX,0,WRK3)
      IR=1
      II=0
    2 DO 7 JJ=1,3
    7 F(JJ,IS)=R(II+JJ,IS)
      L=LL(IR,IS)
      IF (L.EQ.3) GO TO 3
      CALL TESTP(LPT,LINO,1,HEDING,4)
      WRITE (LPT,10) IS,(F(J,IS) ,J=1,3)
      IE=II+L
      IB=II+4
      CALL WTMEAN(R(I,IS),R(I+1,IS),0,WRK2)
      DO 1 I=IB,IE,2
      CALL WTMEAN(R(I,IS),R(I+1,IS),2,WRK2)
      IF (I.EQ.IB) GO TO 6
      CALL TESTP(LPT,LINO,1,HEDING,4)
      WRITE (LPT,14)
    6 WRITE (LPT,11) R(I,IS),R(I+1,IS)
    1 CONTINUE
      CALL WTMEAN(X,DX,-1,WRK2)
      CALL WTMEAN(X,DX,2,WRK3)
      SUM(1)=SUM(1)+WRK2(2)-X*WRK2(1)
      SUM(2)=SUM(2)+WRK2(4)-1.
      WRITE (LPT,12) X,DX
      II=II+L
      IR=IR+1
      GO TO 2
C
C  FINISH ONE INDEPENDENT MEASUREMENT
    3 CALL WTMEAN(AMEAN(IS),DEV(IS),-1,WRK3)
      SUM(3)=SUM(3)+WRK3(2)-AMEAN(IS)*WRK3(1)
      SUM(4)=SUM(4)+WRK3(4)-1.
      WRITE (LPT,13) KK,AMEAN(IS),DEV(IS)
      LINO=LINO+1
    4 CONTINUE
C
      IF (MODE .NE.0)THEN
      WRITE (LUNI,15) (F(I,MODE),I=1,3),AMEAN(MODE),DEV(MODE)
      ELSE
      X=AMEAN(2)/AMEAN(1)
      DX=SQRT((DEV(1)/AMEAN(1))**2+(DEV(2)/AMEAN(2))**2)
      CALL WTMEAN(X,DX,2,WRK1)
      CALL WTMEAN(Y,DY,0,WRK2)
      DO 5 I=1,2
      CALL WTMEAN(AMEAN(I),DEV(I),2,WRK2)
    5 CONTINUE
      CALL WTMEAN(Y,DY,-1,WRK2)
      WRITE (LUNI,15) KK,Y,DY
      CALL TESTP(LPT,LINO,2,HEDING,4)
      WRITE (LPT,16) Y,DY,X,DX
      LINO=LINO+1
      ENDIF
C
  100 RETURN
C
   10 FORMAT (1X,I2,3X,3F8.3)
   11 FORMAT ('+',18X,2F10.5)
   12 FORMAT ('+',40X,2F10.5)
   13 FORMAT ('+',62X,3F8.3,1X,2F10.5/)
   14 FORMAT (1X)
   15 FORMAT (3I5,2F10.6)
   16 FORMAT (/76X,4F10.5)
      END
C
C
C
C
C
C LEVEL 50      PROGRAM POWINT
      PROGRAM POWINT
C
C *** POWINT BY JBF AND SP ***
C
C*******************************************************************************
C
C                       P O W I N T
C
C THE CALCULATION OF POWDER PATTERNS AND THEIR INTENSITIES,FOR MONOCHROMATIC
C WAVELENGTH OR TIME OF FLIGHT MEASUREMENTS.
C
C*******************************************************************************
C
      CHARACTER *1 ICHR,ISPCE,ISTAR
      REAL L
      REAL LAM
      COMPLEX FCALC
      LOGICAL NOMORE,ISPABS,SAYS,TOF
/IOUNIT/
/SCRACH/
      COMMON/SCRAT/H(3),K(3),HLIST(3,1000),DSTAR(1000),IND(1000)
      CHARACTER *70 VFMT
      DATA ISPCE,ISTAR/' ','*'/
      DATA VFMT/'(''0    h    k   l  Sinth/Lam      A       B
     & Fcalc''/)'/
C
      CALL PREFIN('POWINT')
      CALL SETFC
      CALL SYMUNI
C
C TWO TYPES OF CALCULATION NOW AVAILABLE,TIME OF FLIGHT OR MONOCHROMATIC
C WAVELENGTH.IF MONOCHROMATIC CALCULATION USED IT IS SAME AS BEFORE.
C
      CALL ASK('Give minimum d spacing in Angstroms')
      CALL RDREAL(DMIN,1,IPT,80,IER)
      WRITE(LPT,504) DMIN
504   FORMAT(/' Min d =',F10.4)
      CALL SETGEN(0.5/(DMIN))
400   CALL ASK('Time of Flight or Monochromatic'//
     & ' Wavelength calculation? (T or M)')
      IREP=MESSAG(1:1)
      TOF=SAYS('T')
      IF (SAYS('M')) GO TO 900
      IF (.NOT.TOF) GO TO 400
      CALL ASK('Length of diffractometer in metres, and detector'//
     & ' 2Theta?')
      CALL RDREAL(L,1,IPT,80,IER)
      CALL RDREAL(TTHETA,IPT,IPT,80,IER)
      CALL MESS(LPT,2,
     & '     h    k    l     d    Sinth/Lam    ToF    Fc')
      GO TO 2010
C
C INSTEAD OF CALL SETDC AS ON MK2, FOR ASK FOR MAX THETA DEGREES AND LAMBDA
C(SETDC NOW EXISTS - INVESTIGATE ITS USE)
C
900   CALL ASK('Give wavelength')
      CALL RDREAL(ALAMB,1,IPT,80,IER)
      WRITE (LPT,1012)ALAMB
1012  FORMAT (/' Wavelength =',F10.4)
      CALL MESS(LPT,2,'      h    k    l      D     Sinth/Lam    '//
     & '2*Theta     J     Sinth*Sin2th       Fc        Intensity')
2010  IC=0
    1 CALL GETGEN(H,NOMORE)
      IF(NOMORE) GO TO 4
      IC=IC+1
      IF (IC .GT. 1000) GO TO 4
      DSTAR(IC)=VCTMOD(1.0,H,2)
      CALL GMEQ (H,HLIST(1,IC),1,3)
      GO TO 1
C
C  HERE AT END OF USEFUL REFLECTIONS AND SEPERATE INTO TOF OR MONOCHROMATIC
C  CALCULATIONS
    4 IF(IC.LT.2) GO TO 8
C     SORT ARRAY OF DSTAR IN ASCENDING ORDER
      CALL SORTX(DSTAR,IND,IC)
   8  DO 5 I=1,IC
      ISORT=IND(I)
      CALL GMEQ(HLIST(1,ISORT),H,1,3)
      CALL INDFIX(H,K)
      FC=CABS(FCALC(H))
      ICHR=ISPCE
      IF (ISPABS(H)) ICHR=ISTAR
      IF(DSTAR(ISORT).LT.0.0001) GO TO 9
      D=1/(DSTAR(ISORT))
      STHLMB=DSTAR(ISORT)/2.0
      M=MULBOX(H)
      IF(TOF) GO TO 3000
      SINTH=STHLMB*ALAMB
      TTHETA=2.*ASIN(SINTH)
      TTHETAD=DEGREE(TTHETA)
      ANGFAC=SINTH*SIN(TTHETA)
      SCINT=FC*FC*FLOAT(M)/ANGFAC
      WRITE(LPT,1004) ICHR,K,D,STHLMB,TTHETAD,M,ANGFAC,FC,SCINT
 1004 FORMAT(' ',A1,3I5,2F10.4,F12.2,I6,6X,F10.6,F10.3,7X,F10.3)
      GO TO 5
    9 WRITE(LPT,1002) K,TTHETA,M,ANGFAC,FC
 1002 FORMAT(' ',3I5,20X,F12.2,I6,6X,F10.6,F10.3)
      GOTO 5
C
C BACK TO THE TIME OF FLIGHT CALCULATION IGNORING ALL GEOMETRICAL FACTORS
C
3000  THETA=TTHETA/2
      LAM=SIN(RADIAN(THETA))/(2*DSTAR(ISORT))
      TOF=252.7*LAM*L
      WRITE(LPT,3005)ICHR,K,D,STHLAM,TOF,FC
3005  FORMAT(' ',A1,3I5,2F10.4,F10.1,7X)
    5 CONTINUE
      STOP
      END
C
C
C
C
C LEVEL 50      PROGRAM REMES
C
C *** REMES BY JBF updated by SP ***
C
C*******************************************************************************
C
C                             R E M E S
C
C
C THIS PROGRAM IS TO BE USED WITH DATA OBTAINED ON THE D3 DIFFRACTOMETER AT
C THE ILL.  IT CHECKS WHETHER THE REFLECTIONS HAVE BEEN MEASURED TO SUFFICENT
C ACCURACY;  IF NOT IT GENERATES A NEW SET OF MEASURING INSTRUCTIONS.
C
C WRITTEN ONLY FOR CENTRO-SYMMETRIC STRUCTURES
C
C*******************************************************************************
C
      COMPLEX FCALC
      DIMENSION H(3),K(3),F(3),RH(3)
/IOUNIT/
/NSYM/
/SCRACH/
C
      CALL PREFIN('REMES')
      CALL SETFC
C
      MESSAG='Reflection data'
      INREF=NOPFIL(11)
      CALL ASK('Frequency of standards?')
      CALL RDINTG(NSS,1,IPT,80,IER)
      CALL ASK('Give upper and lower limits for Nuclear Structure'//
     & ' Factors')
      CALL RDREAL(BNUC,1,IPT,80,IER)
      CALL RDREAL(BNUC1,IPT,IPT,80,IER)
   31 WRITE (ITO,30)
   30 FORMAT (' Select reflections with :'/
     & '     1. Large error in observed FM'/
     & '     & . Gamma > Minimum Limit'/
     & '     3. Observed FM > Minimum Limit')
      CALL ASK(' Type 1,2 or 3 : ')
      CALL RDINTG(ISW,1,IPT,80,IER)
      IF(ISW .LT. 1 .OR. ISW .GT. 3) GO TO 31
C
      GO TO (32,33,50) , ISW
   32 CALL ASK('Maximum error in F')
      CALL RDREAL(ERR,1,IPT,80,IER)
      GO TO 6
C
   33 CALL ASK('Give lower limit for Gamma')
      CALL RDREAL(BGAM,1,IPT,80,IER)
      GO TO 6
C
   50 CALL ASK('Give minimum observed FM')
      CALL RDREAL(BFMOBS,1,IPT,80,IER)
C HERE TO READ REFLECTION FILE FOR FIRST TIME
    6 NUM=0
      NUN=0
      NS=0
C AND HERE TO READ SUCCESSIVE REFLECTIONS
    1 READ (INREF,12,END=2) K,F
   12 FORMAT (3I5,3F10.4)
C NOW CHECK THAT CALCULATED FN IS IN RANGE
      CALL INDFLO(H,K)
      FC=REAL(FCALC(H))
      AFC=ABS(FC)
      IF (AFC.GT.BNUC.OR.AFC.LE.BNUC1) GO TO 1
C
C NOW ROUTE TO REQUIRED TEST
      GO TO (60,61,62),ISW
C
C HERE IF CHECK IS ON ERROR
   60 IF (F(3).LT.ERR) GO TO 1
      WRITE (LPT,16) K,F(2),F(3)
      GO TO 70
C
C HERE IF CHECK IS ON GAMMA
   61 GAM=F(2)*(.2715)/FC
      IF (ABS(GAM).LT. BGAM ) GO TO 1
      WRITE (LPT,16) K,FC,GAM
   16 FORMAT (1X,3I5,3F10.4)
      GO TO 70
C HERE IF CHECK IS ON OBSERVED FM
   62 IF (ABS(F(2)).LT.BFMOBS) GO TO 1
      WRITE (LPT,16) K,F(2)
   70 NUN=NUN+1
C GENERATE THE EQUIVALENT REFLECTIONS
      DO 4 IS=1,2
      DO 3 N=1,NOPC
      CALL ROTSYM(H,RH,N,2)
C IGNORE IF GENERATED K IS -VE:
      IF(RH(2).LT.0) GO TO 3
      WRITE (LPT1,13) RH
   13 FORMAT ('*HKM ',F4.0,' ',F4.0,' ',F4.0,' =')
      NUM=NUM+1
      NS=NS+1
      IF(NS.LE.NSS) GO TO 3
      WRITE (LPT1,18)
   18 FORMAT ('*SRM')
      NS=0
    3 CONTINUE
      CALL GMREV(H,H,1,3)
    4 CONTINUE
      GO TO 1
C
C AND REPORT WHAT HAS BEEN DONE
    2 WRITE (LPT,22) NUN
   22 FORMAT (' There are',I5,' independent reflections ')
      WRITE (LPT,17) BNUC,BNUC1
   17 FORMAT (' with nuclear structure factors between',F6.2,
     & ' and',F6.2)
      GOTO(80,81,82),ISW
   80 WRITE (8,24) ERR
   24 FORMAT (' and errors greater than',F6.2)
      GO TO 90
C
   81 WRITE (8,23) BGAM
   23 FORMAT (' and gamma greater than',F6.2)
      GO TO 90
C
   82 WRITE (8,27) BFMOBS
   27 FORMAT (' and observed Fm greater than',F6.2)
   90 WRITE (LPT,25) NUM
   25 FORMAT(' The output file contains',I5,' reflections to be measured
     & ')
      STOP
      END
C
C
C
C
##ENDJBF



